From cd57dcf0b25e21ea62702b25bc3b0607cd3f3c9d Mon Sep 17 00:00:00 2001
From: Carlos Munoz <carlos.munoz@caviumnetworks.com>
Date: Wed, 23 Apr 2014 14:23:46 -0700
Subject: [PATCH 055/202] OCTEON: OCLA driver to support blocking IO.

Signed-off-by: Carlos Munoz <carlos.munoz@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.1-544]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/executive/Makefile    |    2 +-
 arch/mips/cavium-octeon/executive/cvmx-ocla.c |  764 +++
 arch/mips/include/asm/octeon/cvmx-dtx-defs.h  | 7636 +++++++++++++++++++++++++
 arch/mips/include/asm/octeon/cvmx-ocla.h      |  449 ++
 drivers/char/Kconfig                          |   13 +
 drivers/char/Makefile                         |    1 +
 drivers/char/octeon-ocla.c                    |  503 ++
 7 files changed, 9367 insertions(+), 1 deletion(-)
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-ocla.c
 create mode 100644 arch/mips/include/asm/octeon/cvmx-dtx-defs.h
 create mode 100644 arch/mips/include/asm/octeon/cvmx-ocla.h
 create mode 100644 drivers/char/octeon-ocla.c

diff --git a/arch/mips/cavium-octeon/executive/Makefile b/arch/mips/cavium-octeon/executive/Makefile
index 5acfae8..a2af201 100644
--- a/arch/mips/cavium-octeon/executive/Makefile
+++ b/arch/mips/cavium-octeon/executive/Makefile
@@ -20,7 +20,7 @@ obj-y += cvmx-pko.o cvmx-spi.o cvmx-cmd-queue.o cvmx-helper-cfg.o	\
 	cvmx-helper-board.o cvmx-helper.o cvmx-helper-xaui.o \
 	cvmx-helper-rgmii.o cvmx-helper-sgmii.o cvmx-helper-npi.o \
 	cvmx-helper-loop.o cvmx-helper-spi.o cvmx-helper-util.o	\
-	cvmx-pki-resources.o cvmx-gser.o cvmx-bgx.o
+	cvmx-pki-resources.o cvmx-gser.o cvmx-bgx.o cvmx-ocla.o
 
 obj-y += cvmx-helper-errata.o cvmx-helper-jtag.o
 obj-y += cvmx-pcie.o
diff --git a/arch/mips/cavium-octeon/executive/cvmx-ocla.c b/arch/mips/cavium-octeon/executive/cvmx-ocla.c
new file mode 100644
index 0000000..21f71ca
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-ocla.c
@@ -0,0 +1,764 @@
+/***********************license start***************
+ * Copyright (c) 2003-2014  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Interface to the On Chip Logic Analyzer (OCLA) hardware.
+ *
+ */
+
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-ocla.h>
+#include <asm/octeon/cvmx-dtx-defs.h>
+#include <asm/octeon/cvmx-l2c-defs.h>
+#include <asm/octeon/cvmx-oclax-defs.h>
+#else
+#include "cvmx.h"
+#include "cvmx-ocla.h"
+#include <cvmx-dtx-defs.h>
+#include <cvmx-l2c-defs.h>
+#include <cvmx-oclax-defs.h>
+#endif
+
+
+/* Types of dtx registers */
+enum {
+	DTX_SEL,
+	DTX_ENA,
+	DTX_DAT,
+	DTX_CTL
+};
+
+/* Information needed to derive a DTX block register address */
+struct dtx_reg_addr_rule {
+	cvmx_dtx_id_t	id;
+	uint64_t	base;
+	int		inst_factor;
+	int		half_factor;
+};
+
+
+/* DTX registers on the 70xx */
+static struct dtx_reg_addr_rule dtx_regs_70xx[] = {
+	{AGL,		0x00011800FE700000ull,	0,		8},
+	{DFA,		0x00011800FE1B8000ull,	0,		8},
+	{DPI,		0x00011800FEEF8000ull,	0,		8},
+	{FPA,		0x00011800FE140000ull,	0,		8},
+	{GMX,		0x00011800FE040000ull,	0x40000,	8},
+	{IOB,		0x00011800FE780000ull,	0,		8},
+	{IPD,		0x00011800FE278000ull,	0,		8},
+	{L2C_CBC,	0x00011800FE420000ull,	0,		8},
+	{L2C_MCI,	0x00011800FE2E0000ull,	0,		8},
+	{L2C_TAD,	0x00011800FE240000ull,	0,		8},
+	{LMC,		0x00011800FE440000ull,	0,		8},
+	{MIO,		0x00011800FE000000ull,	0,		8},
+	{PCS,		0x00011800FE580000ull,	0x40000,	8},
+	{PEM,		0x00011800FE600000ull,	0x8000,		8},
+	{PIP,		0x00011800FE500000ull,	0,		8},
+	{PKO,		0x00011800FE280000ull,	0,		8},
+	{POW,		0x00011800FE338000ull,	0,		8},
+	{RST,		0x00011800FE030000ull,	0,		8},
+	{SATA,		0x00011800FE360000ull,	0,		8},
+	{SLI,		0x00011800FE8F8000ull,	0,		8},
+	{TIM,		0x00011800FE2C0000ull,	0,		8},
+	{USBDRD,	0x00011800FE340000ull,	0x8000,		8},
+	{INVALID_BLOCK_ID, 0,			0,		0}
+};
+
+/* DTX registers on the 78xx */
+static struct dtx_reg_addr_rule dtx_regs_78xx[] = {
+	{ASE,		0x00011800FE6E8000ull,	0, 		8},
+	{BGX,		0x00011800FE700000ull,	0x8000,		8},
+	{CIU,		0x00011800FE808000ull,	0,		8},
+	{DFA,		0x00011800FE1B8000ull,	0,		8},
+	{DPI,		0x00011800FEEF8000ull,	0,		8},
+	{FPA,		0x00011800FE940000ull,	0,		8},
+	{GSER,		0x00011800FE480000ull,	0x8000,		8},
+	{HNA,		0x00011800FE238000ull,	0,		8},
+	{ILA,		0x00011800FE0B8000ull,	0,		8},
+	{ILK,		0x00011800FE0A0000ull,	0,		8},
+	{IOBN,		0x00011800FE780000ull,	0,		8},
+	{IOBP,		0x00011800FE7A0000ull,	0,		8},
+	{L2C_CBC,	0x00011800FE420000ull,	0x8000,		8},
+	{L2C_MCI,	0x00011800FE2E0000ull,	0x8000,		8},
+	{L2C_TAD,	0x00011800FE240000ull,	0x8000,		8},
+	{LAP,		0x00011800FE060000ull,	0x8000,		8},
+	{LBK,		0x00011800FE090000ull,	0,		8},
+	{LMC,		0x00011800FE440000ull,	0x8000,		8},
+	{MIO,		0x00011800FE000000ull,	0,		8},
+	{OCX_LNK,	0x00011800FE180000ull,	0x8000,		8},
+	{OCX_OLE,	0x00011800FE1A0000ull,	0x8000,		8},
+	{OCX_TOP,	0x00011800FE088000ull,	0,		8},
+	{OSM,		0x00011800FE6E0000ull,	0,		8},
+	{PEM,		0x00011800FE600000ull,	0x8000,		8},
+	{PKI_PBE,	0x00011800FE228000ull,	0,		8},
+	{PKI_PFE,	0x00011800FE220000ull,	0,		8},
+	{PKI_PIX,	0x00011800FE230000ull,	0,		8},
+	{PKO,		0x00011800FEAA0000ull,	0,		8},
+	{RAD,		0x00011800FE380000ull,	0,		8},
+	{RNM,		0x00011800FE200000ull,	0,		8},
+	{RST,		0x00011800FE030000ull,	0,		8},
+	{SLI,		0x00011800FE8F8000ull,	0,		8},
+	{SSO,		0x00011800FEB38000ull,	0,		8},
+	{TIM,		0x00011800FE2C0000ull,	0,		8},
+	{USBH,		0x00011800FE340000ull,	0,		8},
+	{ZIP,		0x00011800FE1C0000ull,	0,		8},
+	{INVALID_BLOCK_ID, 0,			0,		0}
+};
+
+/* Must keep track of which fsm AND terms are in use */
+static uint16_t		and_terms[CVMX_MAX_NODES][MAX_COMPLEXES];
+
+/* Must keep track of which fsm OR terms are in use */
+static uint16_t		or_terms[CVMX_MAX_NODES][MAX_COMPLEXES];
+
+
+/*
+ * Get the register address for the given dtx block and register type.
+ *
+ *  block_id:		Specifies one of the DTX block types.
+ *  block_inst:		Specifies the block instance.
+ *  half:		36-bit debug bus half.
+ *  reg_type:		Specifies the register to get the address for.
+ * 
+ *  Returns:		Register address on success, 0 otherwise.
+ */
+static uint64_t cvmx_get_dtx_reg_addr(cvmx_dtx_id_t	block_id,
+				      int		block_inst,
+				      int		half,
+				      int		reg_type)
+{
+	struct dtx_reg_addr_rule	*regs = dtx_regs_78xx;
+	uint64_t			addr;
+	int				offset;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN70XX))
+		regs = dtx_regs_70xx;
+
+	while ((block_id != regs->id) && (regs->id != INVALID_BLOCK_ID))
+		regs++;
+
+	if (regs->id == INVALID_BLOCK_ID) {
+		cvmx_dprintf("Invalid dtx block ID [%d]\n", block_id);
+		return 0;
+	}
+
+	switch (reg_type) {
+	case DTX_SEL:
+		offset = 0;
+		break;
+	case DTX_ENA:
+		offset = 0x20;
+		break;
+	case DTX_DAT:
+		offset = 0x40;
+		break;
+	case DTX_CTL:
+		offset = 0x60;
+		break;
+	default:
+		cvmx_dprintf("Invalid dtx register type [%d]\n",reg_type);
+		return 0;
+	}
+
+	addr = CVMX_ADD_IO_SEG(regs->base) + offset +
+		regs->inst_factor * block_inst + regs->half_factor * half;
+
+	return addr;
+}
+
+/**
+ * Disable all DTXs on all nodes.
+ */
+int cvmx_dtx_reset(void)
+{
+	cvmx_dtx_l2c_cbcx_bcst_rsp_t	bcst_rsp;
+	int				node;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_OCLA)) {
+		cvmx_dprintf("This chip does not have OCLA support.\n");
+		return -1;
+	}
+
+	for (node = 0; node < CVMX_MAX_NODES; node++) {
+		/* Initialize broadcast */
+		bcst_rsp.u64 = 0;
+		bcst_rsp.s.ena = 1;
+		cvmx_write_csr_node(node, CVMX_DTX_L2C_CBCX_BCST_RSP(0),
+				    bcst_rsp.u64);
+
+		/* Flush rml */
+		cvmx_read_csr_node(node, CVMX_L2C_TBFX_BIST_STATUS(0));
+
+		/* Clear all dtx's from driving data into the debug bus */
+		cvmx_write_csr_node(node, CVMX_DTX_BROADCAST_CTL, 0);
+		cvmx_write_csr_node(node, CVMX_DTX_BROADCAST_ENAX(0), 0);
+		cvmx_write_csr_node(node, CVMX_DTX_BROADCAST_ENAX(1), 0);
+		cvmx_write_csr_node(node, CVMX_DTX_BROADCAST_SELX(0), 0);
+		cvmx_write_csr_node(node, CVMX_DTX_BROADCAST_SELX(1), 0);
+
+		/* Flush rml */
+		cvmx_read_csr_node(node, CVMX_L2C_TBFX_BIST_STATUS(0));
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_dtx_reset);
+
+/**
+ * Setup a Debug Transmitter (DTX) hardware.
+ *
+ * @param node		Node to enable dtx on.
+ * @param dtx		Pointer to DTX configuration to enable.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+int cvmx_dtx_enable(int			node,
+		    cvmx_dtx_def_t	*dtx)
+{
+	uint64_t			addr;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_OCLA)) {
+		cvmx_dprintf("This chip does not have OCLA support.\n");
+		return -1;
+	}
+
+	addr = cvmx_get_dtx_reg_addr(dtx->id, dtx->inst, dtx->half, DTX_ENA);
+	cvmx_write_csr_node(node, addr, dtx->ena);
+
+	addr = cvmx_get_dtx_reg_addr(dtx->id, dtx->inst, dtx->half, DTX_SEL);
+	cvmx_write_csr_node(node, addr, dtx->sel);	
+
+	/* Flush rml */
+	cvmx_read_csr_node(node, CVMX_L2C_TBFX_BIST_STATUS(0));
+
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_dtx_enable);
+
+/**
+ * Disable a DTX.
+ *
+ * @param node		Node to disable dtx on.
+ * @param dtx		Pointer to DTX to disable.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+int cvmx_dtx_disable(int		node,
+		     cvmx_dtx_def_t	*dtx)
+{
+	uint64_t			addr;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_OCLA)) {
+		cvmx_dprintf("This chip does not have OCLA support.\n");
+		return -1;
+	}
+
+	addr = cvmx_get_dtx_reg_addr(dtx->id, dtx->inst, dtx->half, DTX_ENA);
+	cvmx_write_csr_node(node, addr, 0);
+
+	addr = cvmx_get_dtx_reg_addr(dtx->id, dtx->inst, dtx->half, DTX_SEL);
+	cvmx_write_csr_node(node, addr, 0);
+
+	/* Flush rml */
+	cvmx_read_csr_node(node, CVMX_L2C_TBFX_BIST_STATUS(0));
+
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_dtx_disable);
+
+/**
+ * Reset the OCLA hardware.
+ *
+ * @param node		Node ocla complex is on.
+ * @param ix		OCLA complex to reset.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+int cvmx_ocla_reset(int	node,
+		    int	ix)
+{
+	cvmx_oclax_gen_ctl_t		gen_ctl;
+	cvmx_oclax_sft_rst_t		sft_rst;
+	cvmx_oclax_state_int_t		state_int;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_OCLA)) {
+		cvmx_dprintf("This chip does not have OCLA support.\n");
+		return -1;
+	}
+
+	/* Reset the OCLA complex */
+	sft_rst.u64 = 0;
+	sft_rst.s.reset = 1;
+	cvmx_write_csr_node(node, CVMX_OCLAX_SFT_RST(ix), sft_rst.u64);
+
+	/* Clear registers */
+	cvmx_write_csr_node(node, CVMX_OCLAX_GEN_CTL(ix), 0);
+	cvmx_write_csr_node(node, CVMX_OCLAX_FIFO_TRIG(ix), 0);
+	cvmx_write_csr_node(node, CVMX_OCLAX_STATE_SET(ix), 0);
+
+	/* Flush rml */
+	cvmx_read_csr_node(node, CVMX_L2C_TBFX_BIST_STATUS(0));
+
+	/* Clear interrupts */
+	state_int.u64 = 0;
+	state_int.s.fsm0_int = 1;
+	state_int.s.fsm1_int = 1;
+	cvmx_write_csr_node(node, CVMX_OCLAX_STATE_INT(ix), state_int.u64);
+
+	/* Enable ocla */
+	gen_ctl.u64 = cvmx_read_csr_node(node, CVMX_OCLAX_GEN_CTL(ix));
+	gen_ctl.s.den = 1;
+	cvmx_write_csr_node(node, CVMX_OCLAX_GEN_CTL(ix), gen_ctl.u64);
+
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_ocla_reset);
+
+/**
+ * Clear the OCLA interrupts.
+ *
+ * @param node		Node ocla complex is on.
+ * @param ix		OCLA complex whose interrupts are to be cleared.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+int cvmx_ocla_clear_interrupts(int	node,
+			       int	ix)
+{
+	cvmx_oclax_state_int_t		state_int;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_OCLA)) {
+		cvmx_dprintf("This chip does not have OCLA support.\n");
+		return -1;
+	}
+
+	/* Clear interrupts */
+	state_int.u64 = 0;
+	state_int.s.fsm0_int = 1;
+	state_int.s.fsm1_int = 1;
+	cvmx_write_csr_node(node, CVMX_OCLAX_STATE_INT(ix), state_int.u64);
+
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_ocla_clear_interrupts);
+
+/**
+ * Disable the OCLA hardware.
+ *
+ * @param node		Node ocla complex is on.
+ * @param ix		OCLA complex to disable.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+int cvmx_ocla_disable(int	node,
+		      int	ix)
+{
+	cvmx_oclax_gen_ctl_t		gen_ctl;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_OCLA)) {
+		cvmx_dprintf("This chip does not have OCLA support.\n");
+		return -1;
+	}
+
+	/* Disable ocla */
+	gen_ctl.u64 = cvmx_read_csr_node(node, CVMX_OCLAX_GEN_CTL(ix));
+	gen_ctl.s.den = 0;
+	cvmx_write_csr_node(node, CVMX_OCLAX_GEN_CTL(ix), gen_ctl.u64);
+
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_ocla_disable);
+
+/**
+ * Initialize the OCLA hardware.
+ *
+ * @param node		Node ocla complex is on.
+ * @param ix		OCLA complex to initialize.
+ * @param num_entries	Number of entries to capture. Zero for wrapping mode.
+ * @param lo_cap	Selects when to capture the lower 36-bit debug bus half.
+ * @param hi_cap	Selects when to capture the upper 36-bit debug bus half.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+int cvmx_ocla_init(int			node,
+		   int			ix,
+		   int			num_entries,
+		   cvmx_cap_sel_t	lo_cap,
+		   cvmx_cap_sel_t	hi_cap)
+{
+	cvmx_oclax_time_t		time;
+	cvmx_oclax_const_t		constant;
+	cvmx_oclax_fifo_trig_t		fifo_trig;
+	cvmx_oclax_cdhx_ctl_t		cdhx_ctl;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_OCLA)) {
+		cvmx_dprintf("This chip does not have OCLA support.\n");
+		return -1;
+	}
+
+	/* Initialize variables */
+	and_terms[node][ix] = 0;
+	or_terms[node][ix] = 0;
+
+	/* Clear the time */
+	time.u64 = cvmx_read_csr_node(node, CVMX_OCLAX_TIME(ix));
+	time.s.cycle = 0;
+	cvmx_write_csr_node(node, CVMX_OCLAX_TIME(ix), time.u64);
+
+	/*
+	 * Set the number of entries to collect after trigger event to the size
+	 * of ram.
+	 */
+	fifo_trig.u64 = 0;
+	if (num_entries) {
+		int	max_entries;
+
+		constant.u64 = cvmx_read_csr_node(node, CVMX_OCLAX_CONST(ix));
+		max_entries = constant.s.dat_size - 5;
+		fifo_trig.s.limit = num_entries <= max_entries ? num_entries :
+			max_entries;
+	}
+	cvmx_write_csr_node(node, CVMX_OCLAX_FIFO_TRIG(ix), fifo_trig.u64);
+
+	/* Configure when to capture for both the lower and upper 36 bits */
+	cdhx_ctl.u64 = 0;
+	cdhx_ctl.s.dup = 1;
+	cdhx_ctl.s.cap_ctl = lo_cap;
+	cvmx_write_csr_node(node, CVMX_OCLAX_CDHX_CTL(0, ix), cdhx_ctl.u64);
+
+	cdhx_ctl.s.cap_ctl = hi_cap;
+	cvmx_write_csr_node(node, CVMX_OCLAX_CDHX_CTL(1, ix), cdhx_ctl.u64);
+
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_ocla_init);
+
+/**
+ * Initialize the OCLA matchers hardware.
+ *
+ * @param node		Node matcher is on.
+ * @param ix		OCLA complex to initialize.
+ * @param mat		Matcher to initialize.
+ * @param lo_mask	Mask for the lower 36-bit debug bus half.
+ * @param lo_val	Value to match in the lower 36-bit debug bus half.
+ * @param hi_mask	Mask for the upper 36-bit debug bus half.
+ * @param hi_val	Value to match in the upper 36-bit debug bus half.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+int cvmx_matcher_init(int	node,
+		      int	ix,
+		      int	mat,
+		      uint64_t	lo_mask,
+		      uint64_t	lo_val,
+		      uint64_t	hi_mask,
+		      uint64_t	hi_val)
+{
+	if (!octeon_has_feature(OCTEON_FEATURE_OCLA)) {
+		cvmx_dprintf("This chip does not have OCLA support.\n");
+		return -1;
+	}
+
+	/* Lower 36-bit debug bus half */
+	cvmx_write_csr_node(node, CVMX_OCLAX_MATX_MASKX(ix, mat, 0), lo_mask);
+	cvmx_write_csr_node(node, CVMX_OCLAX_MATX_VALUEX(ix, mat, 0), lo_val);
+
+	/* Upper 36-bit debug bus half */
+	cvmx_write_csr_node(node, CVMX_OCLAX_MATX_MASKX(ix, mat, 1), hi_mask);
+	cvmx_write_csr_node(node, CVMX_OCLAX_MATX_VALUEX(ix, mat, 1), hi_val);
+
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_matcher_init);
+
+/*
+ * Allocate a free AND term.
+ *
+ *  node:		Node to allocate AND term from.
+ *  ix:			OCLA complex to allocate AND term from.
+ *
+ *  Returns:		AND term or -1 on error.
+ */
+static int and_term_alloc(int	node,
+			  int	ix)
+{
+	int	i;
+
+	/*
+	 * Start allocating from term 15 to avoid using term 0 since term 0 is
+	 * the default term.
+	 */
+	for (i = 15; i >= 0; i--) {
+		if (!(and_terms[node][ix] & (1 << i))) {
+			and_terms[node][ix] |= 1 << i;
+			break;
+		}
+	}
+
+	return i;
+}
+
+/**
+ * Initialize the OCLA finite state machine hardware.
+ *
+ * @param node		Node fsm is on.
+ * @param ix		OCLA complex to initialize.
+ * @param fsm		Fsm to initialize.
+ * @param mcd		MCD inputs to use.
+ * @param matcher	Matcher inputs to use.
+ * @param fsm0_st	Fsm0 state to use as input.
+ * @param fsm1_st	Fsm1 state to use as input.
+ * @param new_st	State to transtion to when all inputs are true.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+int cvmx_fsm_init(int			node,
+		  int			ix,
+		  int			fsm,
+		  cvmx_fsm_input_t	*mcd,
+		  cvmx_fsm_input_t	*matcher,
+		  cvmx_fsm_input_t	*fsm0_st,
+		  cvmx_fsm_input_t	*fsm1_st,
+		  uint			new_st)
+{
+	cvmx_oclax_fsmx_andx_ix_t	fsm_and;
+	cvmx_oclax_fsmx_andx_ix_t	fsm_and_i;
+	cvmx_oclax_fsmx_orx_t		fsm_or;
+	int				and_term;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_OCLA)) {
+		cvmx_dprintf("This chip does not have OCLA support.\n");
+		return -1;
+	}
+
+	/* Select a free AND term to use and check the new state is available */
+	if ((and_term = and_term_alloc(node, ix)) < 0) {
+		cvmx_dprintf("Failed to allocate a free AND term.\n");
+		return -1;
+	}
+	if (new_st > 15 || or_terms[node][ix] & (1 << new_st)) {
+		cvmx_dprintf("Invalid new state.\n");
+		return -1;
+	}
+	or_terms[node][ix] = 1 << new_st;
+
+	/* Start with zero values */
+	fsm_and.u64 = 0;
+	fsm_and_i.u64 = 0;
+	fsm_or.u64 = 0;
+
+	/* To disable an input the input and its complement must be set to 1 */
+	fsm_and.s.mcd 		= ~mcd->msk;
+	fsm_and_i.s.mcd 	= ~mcd->msk;
+	fsm_and.s.match		= ~matcher->msk;
+	fsm_and_i.s.match	= ~matcher->msk;
+	fsm_and.s.fsm0_state	= ~fsm0_st->msk;
+	fsm_and_i.s.fsm0_state	= ~fsm0_st->msk;
+	fsm_and.s.fsm1_state	= ~fsm1_st->msk;
+	fsm_and_i.s.fsm1_state	= ~fsm1_st->msk;
+
+	/* Set the inputs that must be 1 */
+	fsm_and.s.mcd 		|= mcd->msk & mcd->val;
+	fsm_and.s.match		|= matcher->msk & matcher->val;
+	fsm_and.s.fsm0_state	|= fsm0_st->msk & fsm0_st->val;
+	fsm_and.s.fsm1_state	|= fsm1_st->msk & fsm1_st->val;
+
+	/* Set the inputs that must be 0 */
+	fsm_and_i.s.mcd		|= mcd->msk & ~mcd->val;
+	fsm_and_i.s.match	|= matcher->msk & ~matcher->val;
+	fsm_and_i.s.fsm0_state	|= fsm0_st->msk & ~fsm0_st->val;
+	fsm_and_i.s.fsm1_state	|= fsm1_st->msk & ~fsm1_st->val;
+
+	/* Set the AND term */
+	cvmx_write_csr_node(node, CVMX_OCLAX_FSMX_ANDX_IX(ix, fsm, and_term, 0),
+		       fsm_and.u64);
+	cvmx_write_csr_node(node, CVMX_OCLAX_FSMX_ANDX_IX(ix, fsm, and_term, 1),
+		       fsm_and_i.u64);
+
+	/* The OR term determines the new state */
+	fsm_or.s.or_state = and_term;
+	cvmx_write_csr_node(node, CVMX_OCLAX_FSMX_ORX(ix, fsm, new_st),
+			    fsm_or.u64);
+
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_fsm_init);
+
+/**
+ * Enable a fsm.
+ *
+ * @param node		Node fsm is on.
+ * @param ix		OCLA complex fsm is on.
+ * @param fsm		Fsm to enable.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+int cvmx_fsm_enable(int	node,
+		    int	ix,
+		    int	fsm)
+{
+	cvmx_oclax_state_set_t		state_set;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_OCLA)) {
+		cvmx_dprintf("This chip does not have OCLA support.\n");
+		return -1;
+	}
+
+	state_set.u64 = cvmx_read_csr_node(node, CVMX_OCLAX_STATE_SET(ix));
+	switch (fsm) {
+	case 0:
+		state_set.s.fsm0_ena = 1;
+		break;
+	case 1:
+		state_set.s.fsm1_ena = 1;
+		break;
+	default:
+		cvmx_dprintf("Invalid fsm.\n");
+		return -1;
+	}
+	cvmx_write_csr_node(node, CVMX_OCLAX_STATE_SET(ix), state_set.u64);
+
+	/* Flush rml */
+	cvmx_read_csr_node(node, CVMX_L2C_TBFX_BIST_STATUS(0));
+
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_fsm_enable);
+
+/**
+ * Set the action to take for a fsm state.
+ *
+ * @param node		Node fsm is on.
+ * @param ix		OCLA complex fsm is on.
+ * @param fsm		Fsm to initialize.
+ * @param state		State to assign action to.
+ * @param action	Bit mask of actions for the fsm state.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+int cvmx_fsm_state_set(int			node,
+		       int			ix,
+		       int			fsm,
+		       uint			state,
+		       cvmx_fsm_action_t	action)
+{
+	cvmx_oclax_fsmx_statex_t	fsm_state;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_OCLA)) {
+		cvmx_dprintf("This chip does not have OCLA support.\n");
+		return -1;
+	}
+
+	/* Set the action for the new state */
+	fsm_state.u64 = cvmx_read_csr_node(node, CVMX_OCLAX_FSMX_STATEX(ix, fsm,
+									state));
+	if (action & ACTION_CAP)
+		fsm_state.s.cap = 1;
+	if (action & ACTION_INT)
+		fsm_state.s.set_int = 1;
+
+	cvmx_write_csr_node(node, CVMX_OCLAX_FSMX_STATEX(ix, fsm, state),
+			    fsm_state.u64);
+
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_fsm_state_set);
+
+/**
+ * Read a packet from the fifo.
+ *
+ * @param node		Node ocla complex is on.
+ * @param ix		OCLA complex to read from.
+ * @param data		Updated with packet read.
+ * 
+ * @return Returned value. Zero if packet is valid, -1 otherwise.
+ */
+int cvmx_ocla_get_packet(int		node,
+			 int		ix,
+			 uint64_t	*data)
+{
+	cvmx_oclax_dat_pop_t	dat_pop;
+	int			rc = -1;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_OCLA)) {
+		cvmx_dprintf("This chip does not have OCLA support.\n");
+		return -1;
+	}
+
+	dat_pop.u64 = cvmx_read_csr_node(node, CVMX_OCLAX_DAT_POP(ix));
+	if (dat_pop.s.valid) {
+		*data = dat_pop.u64;
+		rc = 0;
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(cvmx_ocla_get_packet);
+
+/**
+ * Check if the ocla fifo is full.
+ *
+ * @param node		Node ocla complex is on.
+ * @param ix		OCLA complex whose fifo is to be checked.
+ * 
+ * @return Returned value. Zero if fifo is not full, 1 if it's full.
+ */
+int cvmx_is_fifo_full(int	node,
+		      int	ix)
+{
+	cvmx_oclax_fifo_trig_t	fifo_trig;
+	int			rc;
+
+	fifo_trig.u64 = cvmx_read_csr_node(node, CVMX_OCLAX_FIFO_TRIG(ix));
+
+	/*
+	 * When wrapping is enabled, the fifo never fills. Well.. it does fill
+	 * but capturing never stops and the fifo wraps forever.
+	 */
+	if (!fifo_trig.s.limit)
+		rc = 0;
+	else
+		rc = fifo_trig.s.cnt >= fifo_trig.s.limit;
+
+	return rc;
+}
+EXPORT_SYMBOL(cvmx_is_fifo_full);
diff --git a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
new file mode 100644
index 0000000..482c867
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
@@ -0,0 +1,7636 @@
+/***********************license start***************
+ * Copyright (c) 2003-2014  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+
+/**
+ * cvmx-dtx-defs.h
+ *
+ * Configuration and status register (CSR) type definitions for
+ * Octeon dtx.
+ *
+ * This file is auto generated. Do not edit.
+ *
+ * <hr>$Revision$<hr>
+ *
+ */
+#ifndef __CVMX_DTX_DEFS_H__
+#define __CVMX_DTX_DEFS_H__
+
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_AGL_BCST_RSP CVMX_DTX_AGL_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_AGL_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_AGL_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE700080ull);
+}
+#else
+#define CVMX_DTX_AGL_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE700080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_AGL_CTL CVMX_DTX_AGL_CTL_FUNC()
+static inline uint64_t CVMX_DTX_AGL_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_AGL_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE700060ull);
+}
+#else
+#define CVMX_DTX_AGL_CTL (CVMX_ADD_IO_SEG(0x00011800FE700060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_AGL_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_AGL_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE700040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_AGL_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE700040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_AGL_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_AGL_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE700020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_AGL_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE700020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_AGL_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_AGL_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE700000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_AGL_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE700000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_ASE_BCST_RSP CVMX_DTX_ASE_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_ASE_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_ASE_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE6E8080ull);
+}
+#else
+#define CVMX_DTX_ASE_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE6E8080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_ASE_CTL CVMX_DTX_ASE_CTL_FUNC()
+static inline uint64_t CVMX_DTX_ASE_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_ASE_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE6E8060ull);
+}
+#else
+#define CVMX_DTX_ASE_CTL (CVMX_ADD_IO_SEG(0x00011800FE6E8060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_ASE_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_ASE_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE6E8040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_ASE_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE6E8040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_ASE_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_ASE_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE6E8020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_ASE_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE6E8020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_ASE_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_ASE_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE6E8000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_ASE_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE6E8000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_BGXX_BCST_RSP(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_DTX_BGXX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE700080ull) + ((offset) & 7) * 32768;
+}
+#else
+#define CVMX_DTX_BGXX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE700080ull) + ((offset) & 7) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_BGXX_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
+		cvmx_warn("CVMX_DTX_BGXX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE700060ull) + ((offset) & 7) * 32768;
+}
+#else
+#define CVMX_DTX_BGXX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE700060ull) + ((offset) & 7) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_BGXX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5))))))
+		cvmx_warn("CVMX_DTX_BGXX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE700040ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_BGXX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE700040ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_BGXX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5))))))
+		cvmx_warn("CVMX_DTX_BGXX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE700020ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_BGXX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE700020ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_BGXX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5))))))
+		cvmx_warn("CVMX_DTX_BGXX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE700000ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_BGXX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE700000ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_BROADCAST_CTL CVMX_DTX_BROADCAST_CTL_FUNC()
+static inline uint64_t CVMX_DTX_BROADCAST_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_BROADCAST_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE7F0060ull);
+}
+#else
+#define CVMX_DTX_BROADCAST_CTL (CVMX_ADD_IO_SEG(0x00011800FE7F0060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_BROADCAST_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_BROADCAST_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE7F0020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_BROADCAST_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE7F0020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_BROADCAST_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_BROADCAST_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE7F0000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_BROADCAST_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE7F0000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_CIU_BCST_RSP CVMX_DTX_CIU_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_CIU_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_CIU_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE808080ull);
+}
+#else
+#define CVMX_DTX_CIU_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE808080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_CIU_CTL CVMX_DTX_CIU_CTL_FUNC()
+static inline uint64_t CVMX_DTX_CIU_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_CIU_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE808060ull);
+}
+#else
+#define CVMX_DTX_CIU_CTL (CVMX_ADD_IO_SEG(0x00011800FE808060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_CIU_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_CIU_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE808040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_CIU_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE808040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_CIU_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_CIU_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE808020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_CIU_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE808020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_CIU_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_CIU_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE808000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_CIU_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE808000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_DFA_BCST_RSP CVMX_DTX_DFA_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_DFA_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_DFA_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE1B8080ull);
+}
+#else
+#define CVMX_DTX_DFA_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE1B8080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_DFA_CTL CVMX_DTX_DFA_CTL_FUNC()
+static inline uint64_t CVMX_DTX_DFA_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_DFA_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE1B8060ull);
+}
+#else
+#define CVMX_DTX_DFA_CTL (CVMX_ADD_IO_SEG(0x00011800FE1B8060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_DFA_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_DFA_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE1B8040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_DFA_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE1B8040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_DFA_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_DFA_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE1B8020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_DFA_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE1B8020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_DFA_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_DFA_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE1B8000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_DFA_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE1B8000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_DPI_BCST_RSP CVMX_DTX_DPI_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_DPI_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_DPI_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FEEF8080ull);
+}
+#else
+#define CVMX_DTX_DPI_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FEEF8080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_DPI_CTL CVMX_DTX_DPI_CTL_FUNC()
+static inline uint64_t CVMX_DTX_DPI_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_DPI_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FEEF8060ull);
+}
+#else
+#define CVMX_DTX_DPI_CTL (CVMX_ADD_IO_SEG(0x00011800FEEF8060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_DPI_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_DPI_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FEEF8040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_DPI_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FEEF8040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_DPI_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_DPI_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FEEF8020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_DPI_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FEEF8020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_DPI_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_DPI_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FEEF8000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_DPI_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FEEF8000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_FPA_BCST_RSP CVMX_DTX_FPA_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_FPA_BCST_RSP_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE140080ull);
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
+			break;
+	}
+	cvmx_warn("CVMX_DTX_FPA_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
+}
+#else
+#define CVMX_DTX_FPA_BCST_RSP CVMX_DTX_FPA_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_FPA_BCST_RSP_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE140080ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_FPA_CTL CVMX_DTX_FPA_CTL_FUNC()
+static inline uint64_t CVMX_DTX_FPA_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE140060ull);
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
+			break;
+	}
+	cvmx_warn("CVMX_DTX_FPA_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
+}
+#else
+#define CVMX_DTX_FPA_CTL CVMX_DTX_FPA_CTL_FUNC()
+static inline uint64_t CVMX_DTX_FPA_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE140060ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_FPA_DATX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE140040ull) + ((offset) & 1) * 8;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + ((offset) & 1) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_FPA_DATX (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + ((offset) & 1) * 8;
+}
+#else
+static inline uint64_t CVMX_DTX_FPA_DATX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE140040ull) + (offset) * 8;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + (offset) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + (offset) * 8;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_FPA_ENAX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE140020ull) + ((offset) & 1) * 8;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + ((offset) & 1) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_FPA_ENAX (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + ((offset) & 1) * 8;
+}
+#else
+static inline uint64_t CVMX_DTX_FPA_ENAX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE140020ull) + (offset) * 8;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + (offset) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + (offset) * 8;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_FPA_SELX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE140000ull) + ((offset) & 1) * 8;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + ((offset) & 1) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_FPA_SELX (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + ((offset) & 1) * 8;
+}
+#else
+static inline uint64_t CVMX_DTX_FPA_SELX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE140000ull) + (offset) * 8;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + (offset) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + (offset) * 8;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_GMXX_BCST_RSP(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
+		cvmx_warn("CVMX_DTX_GMXX_BCST_RSP(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE040080ull) + ((block_id) & 1) * 0x40000ull;
+}
+#else
+#define CVMX_DTX_GMXX_BCST_RSP(block_id) (CVMX_ADD_IO_SEG(0x00011800FE040080ull) + ((block_id) & 1) * 0x40000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_GMXX_CTL(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
+		cvmx_warn("CVMX_DTX_GMXX_CTL(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE040060ull) + ((block_id) & 1) * 0x40000ull;
+}
+#else
+#define CVMX_DTX_GMXX_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800FE040060ull) + ((block_id) & 1) * 0x40000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_GMXX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_GMXX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE040040ull) + (((offset) & 1) + ((block_id) & 1) * 0x8000ull) * 8;
+}
+#else
+#define CVMX_DTX_GMXX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE040040ull) + (((offset) & 1) + ((block_id) & 1) * 0x8000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_GMXX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_GMXX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE040020ull) + (((offset) & 1) + ((block_id) & 1) * 0x8000ull) * 8;
+}
+#else
+#define CVMX_DTX_GMXX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE040020ull) + (((offset) & 1) + ((block_id) & 1) * 0x8000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_GMXX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_GMXX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE040000ull) + (((offset) & 1) + ((block_id) & 1) * 0x8000ull) * 8;
+}
+#else
+#define CVMX_DTX_GMXX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE040000ull) + (((offset) & 1) + ((block_id) & 1) * 0x8000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_GSERX_BCST_RSP(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_DTX_GSERX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE480080ull) + ((offset) & 15) * 32768;
+}
+#else
+#define CVMX_DTX_GSERX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE480080ull) + ((offset) & 15) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_GSERX_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_DTX_GSERX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE480060ull) + ((offset) & 15) * 32768;
+}
+#else
+#define CVMX_DTX_GSERX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE480060ull) + ((offset) & 15) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_GSERX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_DTX_GSERX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE480040ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_GSERX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE480040ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_GSERX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_DTX_GSERX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE480020ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_GSERX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE480020ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_GSERX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_DTX_GSERX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE480000ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_GSERX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE480000ull) + (((offset) & 1) + ((block_id) & 15) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_HNA_BCST_RSP CVMX_DTX_HNA_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_HNA_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_HNA_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE238080ull);
+}
+#else
+#define CVMX_DTX_HNA_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE238080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_HNA_CTL CVMX_DTX_HNA_CTL_FUNC()
+static inline uint64_t CVMX_DTX_HNA_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_HNA_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE238060ull);
+}
+#else
+#define CVMX_DTX_HNA_CTL (CVMX_ADD_IO_SEG(0x00011800FE238060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_HNA_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_HNA_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE238040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_HNA_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE238040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_HNA_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_HNA_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE238020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_HNA_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE238020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_HNA_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_HNA_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE238000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_HNA_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE238000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_ILA_BCST_RSP CVMX_DTX_ILA_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_ILA_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_ILA_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE0B8080ull);
+}
+#else
+#define CVMX_DTX_ILA_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE0B8080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_ILA_CTL CVMX_DTX_ILA_CTL_FUNC()
+static inline uint64_t CVMX_DTX_ILA_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_ILA_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE0B8060ull);
+}
+#else
+#define CVMX_DTX_ILA_CTL (CVMX_ADD_IO_SEG(0x00011800FE0B8060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_ILA_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_ILA_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE0B8040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_ILA_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE0B8040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_ILA_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_ILA_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE0B8020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_ILA_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE0B8020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_ILA_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_ILA_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE0B8000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_ILA_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE0B8000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_ILK_BCST_RSP CVMX_DTX_ILK_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_ILK_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_ILK_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE0A0080ull);
+}
+#else
+#define CVMX_DTX_ILK_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE0A0080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_ILK_CTL CVMX_DTX_ILK_CTL_FUNC()
+static inline uint64_t CVMX_DTX_ILK_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_ILK_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE0A0060ull);
+}
+#else
+#define CVMX_DTX_ILK_CTL (CVMX_ADD_IO_SEG(0x00011800FE0A0060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_ILK_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_ILK_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE0A0040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_ILK_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE0A0040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_ILK_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_ILK_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE0A0020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_ILK_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE0A0020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_ILK_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_ILK_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE0A0000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_ILK_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE0A0000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_IOBN_BCST_RSP CVMX_DTX_IOBN_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_IOBN_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_IOBN_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE780080ull);
+}
+#else
+#define CVMX_DTX_IOBN_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE780080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_IOBN_CTL CVMX_DTX_IOBN_CTL_FUNC()
+static inline uint64_t CVMX_DTX_IOBN_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_IOBN_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE780060ull);
+}
+#else
+#define CVMX_DTX_IOBN_CTL (CVMX_ADD_IO_SEG(0x00011800FE780060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_IOBN_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_IOBN_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE780040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_IOBN_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE780040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_IOBN_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_IOBN_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE780020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_IOBN_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE780020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_IOBN_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_IOBN_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE780000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_IOBN_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE780000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_IOBP_BCST_RSP CVMX_DTX_IOBP_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_IOBP_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_IOBP_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE7A0080ull);
+}
+#else
+#define CVMX_DTX_IOBP_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE7A0080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_IOBP_CTL CVMX_DTX_IOBP_CTL_FUNC()
+static inline uint64_t CVMX_DTX_IOBP_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_IOBP_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE7A0060ull);
+}
+#else
+#define CVMX_DTX_IOBP_CTL (CVMX_ADD_IO_SEG(0x00011800FE7A0060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_IOBP_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_IOBP_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE7A0040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_IOBP_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE7A0040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_IOBP_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_IOBP_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE7A0020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_IOBP_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE7A0020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_IOBP_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_IOBP_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE7A0000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_IOBP_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE7A0000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_IOB_BCST_RSP CVMX_DTX_IOB_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_IOB_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_IOB_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE780080ull);
+}
+#else
+#define CVMX_DTX_IOB_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE780080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_IOB_CTL CVMX_DTX_IOB_CTL_FUNC()
+static inline uint64_t CVMX_DTX_IOB_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_IOB_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE780060ull);
+}
+#else
+#define CVMX_DTX_IOB_CTL (CVMX_ADD_IO_SEG(0x00011800FE780060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_IOB_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_IOB_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE780040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_IOB_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE780040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_IOB_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_IOB_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE780020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_IOB_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE780020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_IOB_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_IOB_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE780000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_IOB_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE780000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_IPD_BCST_RSP CVMX_DTX_IPD_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_IPD_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_IPD_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE278080ull);
+}
+#else
+#define CVMX_DTX_IPD_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE278080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_IPD_CTL CVMX_DTX_IPD_CTL_FUNC()
+static inline uint64_t CVMX_DTX_IPD_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_IPD_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE278060ull);
+}
+#else
+#define CVMX_DTX_IPD_CTL (CVMX_ADD_IO_SEG(0x00011800FE278060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_IPD_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_IPD_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE278040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_IPD_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE278040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_IPD_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_IPD_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE278020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_IPD_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE278020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_IPD_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_IPD_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE278000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_IPD_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE278000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_KEY_BCST_RSP CVMX_DTX_KEY_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_KEY_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_KEY_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE100080ull);
+}
+#else
+#define CVMX_DTX_KEY_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE100080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_KEY_CTL CVMX_DTX_KEY_CTL_FUNC()
+static inline uint64_t CVMX_DTX_KEY_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_KEY_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE100060ull);
+}
+#else
+#define CVMX_DTX_KEY_CTL (CVMX_ADD_IO_SEG(0x00011800FE100060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_KEY_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_KEY_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE100040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_KEY_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE100040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_KEY_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_KEY_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE100020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_KEY_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE100020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_KEY_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_KEY_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE100000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_KEY_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE100000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_CBCX_BCST_RSP(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_DTX_L2C_CBCX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE420080ull) + ((offset) & 3) * 32768;
+}
+#else
+#define CVMX_DTX_L2C_CBCX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE420080ull) + ((offset) & 3) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_CBCX_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_DTX_L2C_CBCX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE420060ull) + ((offset) & 3) * 32768;
+}
+#else
+#define CVMX_DTX_L2C_CBCX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE420060ull) + ((offset) & 3) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_CBCX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
+		cvmx_warn("CVMX_DTX_L2C_CBCX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE420040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_L2C_CBCX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE420040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_CBCX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
+		cvmx_warn("CVMX_DTX_L2C_CBCX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE420020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_L2C_CBCX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE420020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_CBCX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
+		cvmx_warn("CVMX_DTX_L2C_CBCX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE420000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_L2C_CBCX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE420000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_MCIX_BCST_RSP(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_DTX_L2C_MCIX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE2E0080ull) + ((offset) & 3) * 32768;
+}
+#else
+#define CVMX_DTX_L2C_MCIX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE2E0080ull) + ((offset) & 3) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_MCIX_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_DTX_L2C_MCIX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE2E0060ull) + ((offset) & 3) * 32768;
+}
+#else
+#define CVMX_DTX_L2C_MCIX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE2E0060ull) + ((offset) & 3) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_MCIX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
+		cvmx_warn("CVMX_DTX_L2C_MCIX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE2E0040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_L2C_MCIX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE2E0040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_MCIX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
+		cvmx_warn("CVMX_DTX_L2C_MCIX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE2E0020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_L2C_MCIX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE2E0020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_MCIX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
+		cvmx_warn("CVMX_DTX_L2C_MCIX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE2E0000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_L2C_MCIX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE2E0000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_TADX_BCST_RSP(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
+		cvmx_warn("CVMX_DTX_L2C_TADX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE240080ull) + ((offset) & 7) * 32768;
+}
+#else
+#define CVMX_DTX_L2C_TADX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE240080ull) + ((offset) & 7) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_TADX_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
+		cvmx_warn("CVMX_DTX_L2C_TADX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE240060ull) + ((offset) & 7) * 32768;
+}
+#else
+#define CVMX_DTX_L2C_TADX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE240060ull) + ((offset) & 7) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_TADX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7))))))
+		cvmx_warn("CVMX_DTX_L2C_TADX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE240040ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_L2C_TADX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE240040ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_TADX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7))))))
+		cvmx_warn("CVMX_DTX_L2C_TADX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE240020ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_L2C_TADX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE240020ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_L2C_TADX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7))))))
+		cvmx_warn("CVMX_DTX_L2C_TADX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE240000ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_L2C_TADX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE240000ull) + (((offset) & 1) + ((block_id) & 7) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_LAPX_BCST_RSP(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_LAPX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE060080ull) + ((offset) & 1) * 32768;
+}
+#else
+#define CVMX_DTX_LAPX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE060080ull) + ((offset) & 1) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_LAPX_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_LAPX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE060060ull) + ((offset) & 1) * 32768;
+}
+#else
+#define CVMX_DTX_LAPX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE060060ull) + ((offset) & 1) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_LAPX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_LAPX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE060040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_LAPX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE060040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_LAPX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_LAPX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE060020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_LAPX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE060020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_LAPX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_LAPX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE060000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_LAPX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE060000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_LBK_BCST_RSP CVMX_DTX_LBK_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_LBK_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_LBK_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE090080ull);
+}
+#else
+#define CVMX_DTX_LBK_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE090080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_LBK_CTL CVMX_DTX_LBK_CTL_FUNC()
+static inline uint64_t CVMX_DTX_LBK_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_LBK_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE090060ull);
+}
+#else
+#define CVMX_DTX_LBK_CTL (CVMX_ADD_IO_SEG(0x00011800FE090060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_LBK_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_LBK_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE090040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_LBK_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE090040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_LBK_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_LBK_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE090020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_LBK_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE090020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_LBK_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_LBK_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE090000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_LBK_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE090000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_LMCX_BCST_RSP(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_DTX_LMCX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE440080ull) + ((offset) & 3) * 32768;
+}
+#else
+#define CVMX_DTX_LMCX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE440080ull) + ((offset) & 3) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_LMCX_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_DTX_LMCX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE440060ull) + ((offset) & 3) * 32768;
+}
+#else
+#define CVMX_DTX_LMCX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE440060ull) + ((offset) & 3) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_LMCX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
+		cvmx_warn("CVMX_DTX_LMCX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE440040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_LMCX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE440040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_LMCX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
+		cvmx_warn("CVMX_DTX_LMCX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE440020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_LMCX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE440020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_LMCX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
+		cvmx_warn("CVMX_DTX_LMCX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE440000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_LMCX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE440000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_MIO_BCST_RSP CVMX_DTX_MIO_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_MIO_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_MIO_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE000080ull);
+}
+#else
+#define CVMX_DTX_MIO_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE000080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_MIO_CTL CVMX_DTX_MIO_CTL_FUNC()
+static inline uint64_t CVMX_DTX_MIO_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_MIO_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE000060ull);
+}
+#else
+#define CVMX_DTX_MIO_CTL (CVMX_ADD_IO_SEG(0x00011800FE000060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_MIO_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_MIO_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE000040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_MIO_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE000040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_MIO_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_MIO_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE000020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_MIO_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE000020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_MIO_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_MIO_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE000000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_MIO_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE000000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_LNKX_BCST_RSP(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
+		cvmx_warn("CVMX_DTX_OCX_LNKX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE180080ull) + ((offset) & 3) * 32768;
+}
+#else
+#define CVMX_DTX_OCX_LNKX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE180080ull) + ((offset) & 3) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_LNKX_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
+		cvmx_warn("CVMX_DTX_OCX_LNKX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE180060ull) + ((offset) & 3) * 32768;
+}
+#else
+#define CVMX_DTX_OCX_LNKX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE180060ull) + ((offset) & 3) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_LNKX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
+		cvmx_warn("CVMX_DTX_OCX_LNKX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE180040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_OCX_LNKX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE180040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_LNKX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
+		cvmx_warn("CVMX_DTX_OCX_LNKX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE180020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_OCX_LNKX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE180020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_LNKX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
+		cvmx_warn("CVMX_DTX_OCX_LNKX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE180000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_OCX_LNKX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE180000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_OLEX_BCST_RSP(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
+		cvmx_warn("CVMX_DTX_OCX_OLEX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE1A0080ull) + ((offset) & 3) * 32768;
+}
+#else
+#define CVMX_DTX_OCX_OLEX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE1A0080ull) + ((offset) & 3) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_OLEX_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
+		cvmx_warn("CVMX_DTX_OCX_OLEX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE1A0060ull) + ((offset) & 3) * 32768;
+}
+#else
+#define CVMX_DTX_OCX_OLEX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE1A0060ull) + ((offset) & 3) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_OLEX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
+		cvmx_warn("CVMX_DTX_OCX_OLEX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE1A0040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_OCX_OLEX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE1A0040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_OLEX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
+		cvmx_warn("CVMX_DTX_OCX_OLEX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE1A0020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_OCX_OLEX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE1A0020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_OLEX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
+		cvmx_warn("CVMX_DTX_OCX_OLEX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE1A0000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_OCX_OLEX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE1A0000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_OCX_TOP_BCST_RSP CVMX_DTX_OCX_TOP_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_OCX_TOP_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_OCX_TOP_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE088080ull);
+}
+#else
+#define CVMX_DTX_OCX_TOP_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE088080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_OCX_TOP_CTL CVMX_DTX_OCX_TOP_CTL_FUNC()
+static inline uint64_t CVMX_DTX_OCX_TOP_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_OCX_TOP_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE088060ull);
+}
+#else
+#define CVMX_DTX_OCX_TOP_CTL (CVMX_ADD_IO_SEG(0x00011800FE088060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_TOP_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_OCX_TOP_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE088040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_OCX_TOP_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE088040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_TOP_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_OCX_TOP_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE088020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_OCX_TOP_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE088020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_TOP_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_OCX_TOP_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE088000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_OCX_TOP_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE088000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_OSM_BCST_RSP CVMX_DTX_OSM_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_OSM_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_OSM_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
+}
+#else
+#define CVMX_DTX_OSM_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE6E0080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_OSM_CTL CVMX_DTX_OSM_CTL_FUNC()
+static inline uint64_t CVMX_DTX_OSM_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_OSM_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
+}
+#else
+#define CVMX_DTX_OSM_CTL (CVMX_ADD_IO_SEG(0x00011800FE6E0060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OSM_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_OSM_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_OSM_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OSM_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_OSM_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_OSM_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OSM_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_OSM_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_OSM_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PCSX_BCST_RSP(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
+		cvmx_warn("CVMX_DTX_PCSX_BCST_RSP(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE580080ull) + ((block_id) & 1) * 0x40000ull;
+}
+#else
+#define CVMX_DTX_PCSX_BCST_RSP(block_id) (CVMX_ADD_IO_SEG(0x00011800FE580080ull) + ((block_id) & 1) * 0x40000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PCSX_CTL(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((block_id <= 1)))))
+		cvmx_warn("CVMX_DTX_PCSX_CTL(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE580060ull) + ((block_id) & 1) * 0x40000ull;
+}
+#else
+#define CVMX_DTX_PCSX_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800FE580060ull) + ((block_id) & 1) * 0x40000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PCSX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_PCSX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE580040ull) + (((offset) & 1) + ((block_id) & 1) * 0x8000ull) * 8;
+}
+#else
+#define CVMX_DTX_PCSX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE580040ull) + (((offset) & 1) + ((block_id) & 1) * 0x8000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PCSX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_PCSX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE580020ull) + (((offset) & 1) + ((block_id) & 1) * 0x8000ull) * 8;
+}
+#else
+#define CVMX_DTX_PCSX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE580020ull) + (((offset) & 1) + ((block_id) & 1) * 0x8000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PCSX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_PCSX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE580000ull) + (((offset) & 1) + ((block_id) & 1) * 0x8000ull) * 8;
+}
+#else
+#define CVMX_DTX_PCSX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE580000ull) + (((offset) & 1) + ((block_id) & 1) * 0x8000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PEMX_BCST_RSP(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_DTX_PEMX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE600080ull) + ((offset) & 3) * 32768;
+}
+#else
+#define CVMX_DTX_PEMX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE600080ull) + ((offset) & 3) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PEMX_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_DTX_PEMX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE600060ull) + ((offset) & 3) * 32768;
+}
+#else
+#define CVMX_DTX_PEMX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE600060ull) + ((offset) & 3) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PEMX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
+		cvmx_warn("CVMX_DTX_PEMX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE600040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_PEMX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE600040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PEMX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
+		cvmx_warn("CVMX_DTX_PEMX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE600020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_PEMX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE600020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PEMX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3))))))
+		cvmx_warn("CVMX_DTX_PEMX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE600000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_PEMX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE600000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_PIP_BCST_RSP CVMX_DTX_PIP_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_PIP_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_PIP_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE500080ull);
+}
+#else
+#define CVMX_DTX_PIP_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE500080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_PIP_CTL CVMX_DTX_PIP_CTL_FUNC()
+static inline uint64_t CVMX_DTX_PIP_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_PIP_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE500060ull);
+}
+#else
+#define CVMX_DTX_PIP_CTL (CVMX_ADD_IO_SEG(0x00011800FE500060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PIP_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PIP_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE500040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_PIP_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE500040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PIP_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PIP_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE500020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_PIP_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE500020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PIP_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PIP_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE500000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_PIP_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE500000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_PKI_PBE_BCST_RSP CVMX_DTX_PKI_PBE_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_PKI_PBE_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_PKI_PBE_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE228080ull);
+}
+#else
+#define CVMX_DTX_PKI_PBE_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE228080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_PKI_PBE_CTL CVMX_DTX_PKI_PBE_CTL_FUNC()
+static inline uint64_t CVMX_DTX_PKI_PBE_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_PKI_PBE_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE228060ull);
+}
+#else
+#define CVMX_DTX_PKI_PBE_CTL (CVMX_ADD_IO_SEG(0x00011800FE228060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PKI_PBE_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PKI_PBE_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE228040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_PKI_PBE_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE228040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PKI_PBE_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PKI_PBE_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE228020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_PKI_PBE_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE228020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PKI_PBE_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PKI_PBE_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE228000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_PKI_PBE_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE228000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_PKI_PFE_BCST_RSP CVMX_DTX_PKI_PFE_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_PKI_PFE_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_PKI_PFE_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE220080ull);
+}
+#else
+#define CVMX_DTX_PKI_PFE_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE220080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_PKI_PFE_CTL CVMX_DTX_PKI_PFE_CTL_FUNC()
+static inline uint64_t CVMX_DTX_PKI_PFE_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_PKI_PFE_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE220060ull);
+}
+#else
+#define CVMX_DTX_PKI_PFE_CTL (CVMX_ADD_IO_SEG(0x00011800FE220060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PKI_PFE_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PKI_PFE_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE220040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_PKI_PFE_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE220040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PKI_PFE_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PKI_PFE_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE220020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_PKI_PFE_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE220020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PKI_PFE_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PKI_PFE_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE220000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_PKI_PFE_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE220000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_PKI_PIX_BCST_RSP CVMX_DTX_PKI_PIX_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_PKI_PIX_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_PKI_PIX_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE230080ull);
+}
+#else
+#define CVMX_DTX_PKI_PIX_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE230080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_PKI_PIX_CTL CVMX_DTX_PKI_PIX_CTL_FUNC()
+static inline uint64_t CVMX_DTX_PKI_PIX_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_PKI_PIX_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE230060ull);
+}
+#else
+#define CVMX_DTX_PKI_PIX_CTL (CVMX_ADD_IO_SEG(0x00011800FE230060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PKI_PIX_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PKI_PIX_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE230040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_PKI_PIX_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE230040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PKI_PIX_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PKI_PIX_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE230020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_PKI_PIX_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE230020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PKI_PIX_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_PKI_PIX_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE230000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_PKI_PIX_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE230000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_PKO_BCST_RSP CVMX_DTX_PKO_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_PKO_BCST_RSP_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE280080ull);
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
+			break;
+	}
+	cvmx_warn("CVMX_DTX_PKO_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
+}
+#else
+#define CVMX_DTX_PKO_BCST_RSP CVMX_DTX_PKO_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_PKO_BCST_RSP_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE280080ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_PKO_CTL CVMX_DTX_PKO_CTL_FUNC()
+static inline uint64_t CVMX_DTX_PKO_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE280060ull);
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
+			break;
+	}
+	cvmx_warn("CVMX_DTX_PKO_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
+}
+#else
+#define CVMX_DTX_PKO_CTL CVMX_DTX_PKO_CTL_FUNC()
+static inline uint64_t CVMX_DTX_PKO_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE280060ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PKO_DATX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE280040ull) + ((offset) & 1) * 8;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + ((offset) & 1) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_PKO_DATX (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + ((offset) & 1) * 8;
+}
+#else
+static inline uint64_t CVMX_DTX_PKO_DATX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE280040ull) + (offset) * 8;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + (offset) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + (offset) * 8;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PKO_ENAX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE280020ull) + ((offset) & 1) * 8;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + ((offset) & 1) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_PKO_ENAX (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + ((offset) & 1) * 8;
+}
+#else
+static inline uint64_t CVMX_DTX_PKO_ENAX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE280020ull) + (offset) * 8;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + (offset) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + (offset) * 8;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_PKO_SELX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FE280000ull) + ((offset) & 1) * 8;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + ((offset) & 1) * 8;
+			break;
+	}
+	cvmx_warn("CVMX_DTX_PKO_SELX (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + ((offset) & 1) * 8;
+}
+#else
+static inline uint64_t CVMX_DTX_PKO_SELX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FE280000ull) + (offset) * 8;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + (offset) * 8;
+	}
+	return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + (offset) * 8;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_POW_BCST_RSP CVMX_DTX_POW_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_POW_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_POW_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE338080ull);
+}
+#else
+#define CVMX_DTX_POW_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE338080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_POW_CTL CVMX_DTX_POW_CTL_FUNC()
+static inline uint64_t CVMX_DTX_POW_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_POW_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE338060ull);
+}
+#else
+#define CVMX_DTX_POW_CTL (CVMX_ADD_IO_SEG(0x00011800FE338060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_POW_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_POW_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE338040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_POW_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE338040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_POW_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_POW_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE338020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_POW_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE338020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_POW_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_POW_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE338000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_POW_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE338000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_RAD_BCST_RSP CVMX_DTX_RAD_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_RAD_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_RAD_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE380080ull);
+}
+#else
+#define CVMX_DTX_RAD_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE380080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_RAD_CTL CVMX_DTX_RAD_CTL_FUNC()
+static inline uint64_t CVMX_DTX_RAD_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_RAD_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE380060ull);
+}
+#else
+#define CVMX_DTX_RAD_CTL (CVMX_ADD_IO_SEG(0x00011800FE380060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RAD_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RAD_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE380040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RAD_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE380040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RAD_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RAD_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE380020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RAD_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE380020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RAD_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RAD_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE380000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RAD_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE380000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_RNM_BCST_RSP CVMX_DTX_RNM_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_RNM_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_RNM_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE200080ull);
+}
+#else
+#define CVMX_DTX_RNM_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE200080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_RNM_CTL CVMX_DTX_RNM_CTL_FUNC()
+static inline uint64_t CVMX_DTX_RNM_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_RNM_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE200060ull);
+}
+#else
+#define CVMX_DTX_RNM_CTL (CVMX_ADD_IO_SEG(0x00011800FE200060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RNM_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RNM_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE200040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RNM_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE200040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RNM_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RNM_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE200020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RNM_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE200020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RNM_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RNM_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE200000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RNM_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE200000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_RST_BCST_RSP CVMX_DTX_RST_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_RST_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_RST_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE030080ull);
+}
+#else
+#define CVMX_DTX_RST_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE030080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_RST_CTL CVMX_DTX_RST_CTL_FUNC()
+static inline uint64_t CVMX_DTX_RST_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_RST_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE030060ull);
+}
+#else
+#define CVMX_DTX_RST_CTL (CVMX_ADD_IO_SEG(0x00011800FE030060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RST_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RST_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE030040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RST_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE030040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RST_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RST_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE030020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RST_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE030020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_RST_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_RST_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE030000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_RST_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE030000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_SATA_BCST_RSP CVMX_DTX_SATA_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_SATA_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_SATA_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE360080ull);
+}
+#else
+#define CVMX_DTX_SATA_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE360080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_SATA_CTL CVMX_DTX_SATA_CTL_FUNC()
+static inline uint64_t CVMX_DTX_SATA_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DTX_SATA_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE360060ull);
+}
+#else
+#define CVMX_DTX_SATA_CTL (CVMX_ADD_IO_SEG(0x00011800FE360060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_SATA_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_SATA_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE360040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_SATA_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE360040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_SATA_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_SATA_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE360020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_SATA_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE360020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_SATA_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_SATA_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE360000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_SATA_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE360000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_SLI_BCST_RSP CVMX_DTX_SLI_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_SLI_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_SLI_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE8F8080ull);
+}
+#else
+#define CVMX_DTX_SLI_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE8F8080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_SLI_CTL CVMX_DTX_SLI_CTL_FUNC()
+static inline uint64_t CVMX_DTX_SLI_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_SLI_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE8F8060ull);
+}
+#else
+#define CVMX_DTX_SLI_CTL (CVMX_ADD_IO_SEG(0x00011800FE8F8060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_SLI_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_SLI_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE8F8040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_SLI_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE8F8040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_SLI_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_SLI_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE8F8020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_SLI_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE8F8020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_SLI_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_SLI_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE8F8000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_SLI_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE8F8000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_SSO_BCST_RSP CVMX_DTX_SSO_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_SSO_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_SSO_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FEB38080ull);
+}
+#else
+#define CVMX_DTX_SSO_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FEB38080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_SSO_CTL CVMX_DTX_SSO_CTL_FUNC()
+static inline uint64_t CVMX_DTX_SSO_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_SSO_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FEB38060ull);
+}
+#else
+#define CVMX_DTX_SSO_CTL (CVMX_ADD_IO_SEG(0x00011800FEB38060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_SSO_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_SSO_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FEB38040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_SSO_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FEB38040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_SSO_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_SSO_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FEB38020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_SSO_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FEB38020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_SSO_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_SSO_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FEB38000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_SSO_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FEB38000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_TIM_BCST_RSP CVMX_DTX_TIM_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_TIM_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_TIM_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE2C0080ull);
+}
+#else
+#define CVMX_DTX_TIM_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE2C0080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_TIM_CTL CVMX_DTX_TIM_CTL_FUNC()
+static inline uint64_t CVMX_DTX_TIM_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_TIM_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE2C0060ull);
+}
+#else
+#define CVMX_DTX_TIM_CTL (CVMX_ADD_IO_SEG(0x00011800FE2C0060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_TIM_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_TIM_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE2C0040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_TIM_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE2C0040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_TIM_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_TIM_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE2C0020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_TIM_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE2C0020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_TIM_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_TIM_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE2C0000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_TIM_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE2C0000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_USBDRDX_BCST_RSP(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_USBDRDX_BCST_RSP(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE340080ull) + ((offset) & 1) * 32768;
+}
+#else
+#define CVMX_DTX_USBDRDX_BCST_RSP(offset) (CVMX_ADD_IO_SEG(0x00011800FE340080ull) + ((offset) & 1) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_USBDRDX_CTL(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_USBDRDX_CTL(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE340060ull) + ((offset) & 1) * 32768;
+}
+#else
+#define CVMX_DTX_USBDRDX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800FE340060ull) + ((offset) & 1) * 32768)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_USBDRDX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_USBDRDX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_USBDRDX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_USBDRDX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_USBDRDX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_USBDRDX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_USBDRDX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 1))))))
+		cvmx_warn("CVMX_DTX_USBDRDX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
+}
+#else
+#define CVMX_DTX_USBDRDX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_USBHX_BCST_RSP(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
+		cvmx_warn("CVMX_DTX_USBHX_BCST_RSP(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE340080ull);
+}
+#else
+#define CVMX_DTX_USBHX_BCST_RSP(block_id) (CVMX_ADD_IO_SEG(0x00011800FE340080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_USBHX_CTL(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id == 0)))))
+		cvmx_warn("CVMX_DTX_USBHX_CTL(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE340060ull);
+}
+#else
+#define CVMX_DTX_USBHX_CTL(block_id) (CVMX_ADD_IO_SEG(0x00011800FE340060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_USBHX_DATX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
+		cvmx_warn("CVMX_DTX_USBHX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
+}
+#else
+#define CVMX_DTX_USBHX_DATX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_USBHX_ENAX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
+		cvmx_warn("CVMX_DTX_USBHX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
+}
+#else
+#define CVMX_DTX_USBHX_ENAX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_USBHX_SELX(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
+		cvmx_warn("CVMX_DTX_USBHX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
+}
+#else
+#define CVMX_DTX_USBHX_SELX(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_ZIP_BCST_RSP CVMX_DTX_ZIP_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_ZIP_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_ZIP_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE1C0080ull);
+}
+#else
+#define CVMX_DTX_ZIP_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE1C0080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_ZIP_CTL CVMX_DTX_ZIP_CTL_FUNC()
+static inline uint64_t CVMX_DTX_ZIP_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_ZIP_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE1C0060ull);
+}
+#else
+#define CVMX_DTX_ZIP_CTL (CVMX_ADD_IO_SEG(0x00011800FE1C0060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_ZIP_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_ZIP_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE1C0040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_ZIP_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE1C0040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_ZIP_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_ZIP_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE1C0020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_ZIP_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE1C0020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_ZIP_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_ZIP_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE1C0000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_ZIP_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE1C0000ull) + ((offset) & 1) * 8)
+#endif
+
+/**
+ * cvmx_dtx_agl_bcst_rsp
+ */
+union cvmx_dtx_agl_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_agl_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_agl_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_agl_bcst_rsp_s        cn70xxp1;
+};
+typedef union cvmx_dtx_agl_bcst_rsp cvmx_dtx_agl_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_agl_ctl
+ */
+union cvmx_dtx_agl_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_agl_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_agl_ctl_s             cn70xx;
+	struct cvmx_dtx_agl_ctl_s             cn70xxp1;
+};
+typedef union cvmx_dtx_agl_ctl cvmx_dtx_agl_ctl_t;
+
+/**
+ * cvmx_dtx_agl_dat#
+ */
+union cvmx_dtx_agl_datx {
+	uint64_t u64;
+	struct cvmx_dtx_agl_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_agl_datx_s            cn70xx;
+	struct cvmx_dtx_agl_datx_s            cn70xxp1;
+};
+typedef union cvmx_dtx_agl_datx cvmx_dtx_agl_datx_t;
+
+/**
+ * cvmx_dtx_agl_ena#
+ */
+union cvmx_dtx_agl_enax {
+	uint64_t u64;
+	struct cvmx_dtx_agl_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_agl_enax_s            cn70xx;
+	struct cvmx_dtx_agl_enax_s            cn70xxp1;
+};
+typedef union cvmx_dtx_agl_enax cvmx_dtx_agl_enax_t;
+
+/**
+ * cvmx_dtx_agl_sel#
+ */
+union cvmx_dtx_agl_selx {
+	uint64_t u64;
+	struct cvmx_dtx_agl_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_agl_selx_s            cn70xx;
+	struct cvmx_dtx_agl_selx_s            cn70xxp1;
+};
+typedef union cvmx_dtx_agl_selx cvmx_dtx_agl_selx_t;
+
+/**
+ * cvmx_dtx_ase_bcst_rsp
+ */
+union cvmx_dtx_ase_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_ase_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_ase_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_ase_bcst_rsp cvmx_dtx_ase_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_ase_ctl
+ */
+union cvmx_dtx_ase_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_ase_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_ase_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_ase_ctl cvmx_dtx_ase_ctl_t;
+
+/**
+ * cvmx_dtx_ase_dat#
+ */
+union cvmx_dtx_ase_datx {
+	uint64_t u64;
+	struct cvmx_dtx_ase_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ase_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_ase_datx cvmx_dtx_ase_datx_t;
+
+/**
+ * cvmx_dtx_ase_ena#
+ */
+union cvmx_dtx_ase_enax {
+	uint64_t u64;
+	struct cvmx_dtx_ase_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ase_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_ase_enax cvmx_dtx_ase_enax_t;
+
+/**
+ * cvmx_dtx_ase_sel#
+ */
+union cvmx_dtx_ase_selx {
+	uint64_t u64;
+	struct cvmx_dtx_ase_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_ase_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_ase_selx cvmx_dtx_ase_selx_t;
+
+/**
+ * cvmx_dtx_bgx#_bcst_rsp
+ */
+union cvmx_dtx_bgxx_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_bgxx_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_bgxx_bcst_rsp_s       cn78xx;
+};
+typedef union cvmx_dtx_bgxx_bcst_rsp cvmx_dtx_bgxx_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_bgx#_ctl
+ */
+union cvmx_dtx_bgxx_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_bgxx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_bgxx_ctl_s            cn78xx;
+};
+typedef union cvmx_dtx_bgxx_ctl cvmx_dtx_bgxx_ctl_t;
+
+/**
+ * cvmx_dtx_bgx#_dat#
+ */
+union cvmx_dtx_bgxx_datx {
+	uint64_t u64;
+	struct cvmx_dtx_bgxx_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_bgxx_datx_s           cn78xx;
+};
+typedef union cvmx_dtx_bgxx_datx cvmx_dtx_bgxx_datx_t;
+
+/**
+ * cvmx_dtx_bgx#_ena#
+ */
+union cvmx_dtx_bgxx_enax {
+	uint64_t u64;
+	struct cvmx_dtx_bgxx_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_bgxx_enax_s           cn78xx;
+};
+typedef union cvmx_dtx_bgxx_enax cvmx_dtx_bgxx_enax_t;
+
+/**
+ * cvmx_dtx_bgx#_sel#
+ */
+union cvmx_dtx_bgxx_selx {
+	uint64_t u64;
+	struct cvmx_dtx_bgxx_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_bgxx_selx_s           cn78xx;
+};
+typedef union cvmx_dtx_bgxx_selx cvmx_dtx_bgxx_selx_t;
+
+/**
+ * cvmx_dtx_broadcast_ctl
+ */
+union cvmx_dtx_broadcast_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_broadcast_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_broadcast_ctl_s       cn70xx;
+	struct cvmx_dtx_broadcast_ctl_s       cn70xxp1;
+	struct cvmx_dtx_broadcast_ctl_s       cn78xx;
+};
+typedef union cvmx_dtx_broadcast_ctl cvmx_dtx_broadcast_ctl_t;
+
+/**
+ * cvmx_dtx_broadcast_ena#
+ */
+union cvmx_dtx_broadcast_enax {
+	uint64_t u64;
+	struct cvmx_dtx_broadcast_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_broadcast_enax_s      cn70xx;
+	struct cvmx_dtx_broadcast_enax_s      cn70xxp1;
+	struct cvmx_dtx_broadcast_enax_s      cn78xx;
+};
+typedef union cvmx_dtx_broadcast_enax cvmx_dtx_broadcast_enax_t;
+
+/**
+ * cvmx_dtx_broadcast_sel#
+ */
+union cvmx_dtx_broadcast_selx {
+	uint64_t u64;
+	struct cvmx_dtx_broadcast_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_broadcast_selx_s      cn70xx;
+	struct cvmx_dtx_broadcast_selx_s      cn70xxp1;
+	struct cvmx_dtx_broadcast_selx_s      cn78xx;
+};
+typedef union cvmx_dtx_broadcast_selx cvmx_dtx_broadcast_selx_t;
+
+/**
+ * cvmx_dtx_ciu_bcst_rsp
+ */
+union cvmx_dtx_ciu_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_ciu_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_ciu_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_ciu_bcst_rsp cvmx_dtx_ciu_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_ciu_ctl
+ */
+union cvmx_dtx_ciu_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_ciu_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_ciu_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_ciu_ctl cvmx_dtx_ciu_ctl_t;
+
+/**
+ * cvmx_dtx_ciu_dat#
+ */
+union cvmx_dtx_ciu_datx {
+	uint64_t u64;
+	struct cvmx_dtx_ciu_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ciu_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_ciu_datx cvmx_dtx_ciu_datx_t;
+
+/**
+ * cvmx_dtx_ciu_ena#
+ */
+union cvmx_dtx_ciu_enax {
+	uint64_t u64;
+	struct cvmx_dtx_ciu_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ciu_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_ciu_enax cvmx_dtx_ciu_enax_t;
+
+/**
+ * cvmx_dtx_ciu_sel#
+ */
+union cvmx_dtx_ciu_selx {
+	uint64_t u64;
+	struct cvmx_dtx_ciu_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_ciu_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_ciu_selx cvmx_dtx_ciu_selx_t;
+
+/**
+ * cvmx_dtx_dfa_bcst_rsp
+ */
+union cvmx_dtx_dfa_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_dfa_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_dfa_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_dfa_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_dfa_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_dfa_bcst_rsp cvmx_dtx_dfa_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_dfa_ctl
+ */
+union cvmx_dtx_dfa_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_dfa_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_dfa_ctl_s             cn70xx;
+	struct cvmx_dtx_dfa_ctl_s             cn70xxp1;
+	struct cvmx_dtx_dfa_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_dfa_ctl cvmx_dtx_dfa_ctl_t;
+
+/**
+ * cvmx_dtx_dfa_dat#
+ */
+union cvmx_dtx_dfa_datx {
+	uint64_t u64;
+	struct cvmx_dtx_dfa_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_dfa_datx_s            cn70xx;
+	struct cvmx_dtx_dfa_datx_s            cn70xxp1;
+	struct cvmx_dtx_dfa_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_dfa_datx cvmx_dtx_dfa_datx_t;
+
+/**
+ * cvmx_dtx_dfa_ena#
+ */
+union cvmx_dtx_dfa_enax {
+	uint64_t u64;
+	struct cvmx_dtx_dfa_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_dfa_enax_s            cn70xx;
+	struct cvmx_dtx_dfa_enax_s            cn70xxp1;
+	struct cvmx_dtx_dfa_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_dfa_enax cvmx_dtx_dfa_enax_t;
+
+/**
+ * cvmx_dtx_dfa_sel#
+ */
+union cvmx_dtx_dfa_selx {
+	uint64_t u64;
+	struct cvmx_dtx_dfa_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_dfa_selx_s            cn70xx;
+	struct cvmx_dtx_dfa_selx_s            cn70xxp1;
+	struct cvmx_dtx_dfa_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_dfa_selx cvmx_dtx_dfa_selx_t;
+
+/**
+ * cvmx_dtx_dpi_bcst_rsp
+ */
+union cvmx_dtx_dpi_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_dpi_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_dpi_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_dpi_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_dpi_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_dpi_bcst_rsp cvmx_dtx_dpi_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_dpi_ctl
+ */
+union cvmx_dtx_dpi_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_dpi_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_dpi_ctl_s             cn70xx;
+	struct cvmx_dtx_dpi_ctl_s             cn70xxp1;
+	struct cvmx_dtx_dpi_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_dpi_ctl cvmx_dtx_dpi_ctl_t;
+
+/**
+ * cvmx_dtx_dpi_dat#
+ */
+union cvmx_dtx_dpi_datx {
+	uint64_t u64;
+	struct cvmx_dtx_dpi_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_dpi_datx_s            cn70xx;
+	struct cvmx_dtx_dpi_datx_s            cn70xxp1;
+	struct cvmx_dtx_dpi_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_dpi_datx cvmx_dtx_dpi_datx_t;
+
+/**
+ * cvmx_dtx_dpi_ena#
+ */
+union cvmx_dtx_dpi_enax {
+	uint64_t u64;
+	struct cvmx_dtx_dpi_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_dpi_enax_s            cn70xx;
+	struct cvmx_dtx_dpi_enax_s            cn70xxp1;
+	struct cvmx_dtx_dpi_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_dpi_enax cvmx_dtx_dpi_enax_t;
+
+/**
+ * cvmx_dtx_dpi_sel#
+ */
+union cvmx_dtx_dpi_selx {
+	uint64_t u64;
+	struct cvmx_dtx_dpi_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_dpi_selx_s            cn70xx;
+	struct cvmx_dtx_dpi_selx_s            cn70xxp1;
+	struct cvmx_dtx_dpi_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_dpi_selx cvmx_dtx_dpi_selx_t;
+
+/**
+ * cvmx_dtx_fpa_bcst_rsp
+ */
+union cvmx_dtx_fpa_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_fpa_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_fpa_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_fpa_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_fpa_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_fpa_bcst_rsp cvmx_dtx_fpa_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_fpa_ctl
+ */
+union cvmx_dtx_fpa_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_fpa_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_fpa_ctl_s             cn70xx;
+	struct cvmx_dtx_fpa_ctl_s             cn70xxp1;
+	struct cvmx_dtx_fpa_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_fpa_ctl cvmx_dtx_fpa_ctl_t;
+
+/**
+ * cvmx_dtx_fpa_dat#
+ */
+union cvmx_dtx_fpa_datx {
+	uint64_t u64;
+	struct cvmx_dtx_fpa_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_fpa_datx_s            cn70xx;
+	struct cvmx_dtx_fpa_datx_s            cn70xxp1;
+	struct cvmx_dtx_fpa_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_fpa_datx cvmx_dtx_fpa_datx_t;
+
+/**
+ * cvmx_dtx_fpa_ena#
+ */
+union cvmx_dtx_fpa_enax {
+	uint64_t u64;
+	struct cvmx_dtx_fpa_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_fpa_enax_s            cn70xx;
+	struct cvmx_dtx_fpa_enax_s            cn70xxp1;
+	struct cvmx_dtx_fpa_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_fpa_enax cvmx_dtx_fpa_enax_t;
+
+/**
+ * cvmx_dtx_fpa_sel#
+ */
+union cvmx_dtx_fpa_selx {
+	uint64_t u64;
+	struct cvmx_dtx_fpa_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_fpa_selx_s            cn70xx;
+	struct cvmx_dtx_fpa_selx_s            cn70xxp1;
+	struct cvmx_dtx_fpa_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_fpa_selx cvmx_dtx_fpa_selx_t;
+
+/**
+ * cvmx_dtx_gmx#_bcst_rsp
+ */
+union cvmx_dtx_gmxx_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_gmxx_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_gmxx_bcst_rsp_s       cn70xx;
+	struct cvmx_dtx_gmxx_bcst_rsp_s       cn70xxp1;
+};
+typedef union cvmx_dtx_gmxx_bcst_rsp cvmx_dtx_gmxx_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_gmx#_ctl
+ */
+union cvmx_dtx_gmxx_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_gmxx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_gmxx_ctl_s            cn70xx;
+	struct cvmx_dtx_gmxx_ctl_s            cn70xxp1;
+};
+typedef union cvmx_dtx_gmxx_ctl cvmx_dtx_gmxx_ctl_t;
+
+/**
+ * cvmx_dtx_gmx#_dat#
+ */
+union cvmx_dtx_gmxx_datx {
+	uint64_t u64;
+	struct cvmx_dtx_gmxx_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_gmxx_datx_s           cn70xx;
+	struct cvmx_dtx_gmxx_datx_s           cn70xxp1;
+};
+typedef union cvmx_dtx_gmxx_datx cvmx_dtx_gmxx_datx_t;
+
+/**
+ * cvmx_dtx_gmx#_ena#
+ */
+union cvmx_dtx_gmxx_enax {
+	uint64_t u64;
+	struct cvmx_dtx_gmxx_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_gmxx_enax_s           cn70xx;
+	struct cvmx_dtx_gmxx_enax_s           cn70xxp1;
+};
+typedef union cvmx_dtx_gmxx_enax cvmx_dtx_gmxx_enax_t;
+
+/**
+ * cvmx_dtx_gmx#_sel#
+ */
+union cvmx_dtx_gmxx_selx {
+	uint64_t u64;
+	struct cvmx_dtx_gmxx_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_gmxx_selx_s           cn70xx;
+	struct cvmx_dtx_gmxx_selx_s           cn70xxp1;
+};
+typedef union cvmx_dtx_gmxx_selx cvmx_dtx_gmxx_selx_t;
+
+/**
+ * cvmx_dtx_gser#_bcst_rsp
+ */
+union cvmx_dtx_gserx_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_gserx_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_gserx_bcst_rsp_s      cn78xx;
+};
+typedef union cvmx_dtx_gserx_bcst_rsp cvmx_dtx_gserx_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_gser#_ctl
+ */
+union cvmx_dtx_gserx_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_gserx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_gserx_ctl_s           cn78xx;
+};
+typedef union cvmx_dtx_gserx_ctl cvmx_dtx_gserx_ctl_t;
+
+/**
+ * cvmx_dtx_gser#_dat#
+ */
+union cvmx_dtx_gserx_datx {
+	uint64_t u64;
+	struct cvmx_dtx_gserx_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_gserx_datx_s          cn78xx;
+};
+typedef union cvmx_dtx_gserx_datx cvmx_dtx_gserx_datx_t;
+
+/**
+ * cvmx_dtx_gser#_ena#
+ */
+union cvmx_dtx_gserx_enax {
+	uint64_t u64;
+	struct cvmx_dtx_gserx_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_gserx_enax_s          cn78xx;
+};
+typedef union cvmx_dtx_gserx_enax cvmx_dtx_gserx_enax_t;
+
+/**
+ * cvmx_dtx_gser#_sel#
+ */
+union cvmx_dtx_gserx_selx {
+	uint64_t u64;
+	struct cvmx_dtx_gserx_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_gserx_selx_s          cn78xx;
+};
+typedef union cvmx_dtx_gserx_selx cvmx_dtx_gserx_selx_t;
+
+/**
+ * cvmx_dtx_hna_bcst_rsp
+ */
+union cvmx_dtx_hna_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_hna_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_hna_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_hna_bcst_rsp cvmx_dtx_hna_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_hna_ctl
+ */
+union cvmx_dtx_hna_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_hna_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_hna_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_hna_ctl cvmx_dtx_hna_ctl_t;
+
+/**
+ * cvmx_dtx_hna_dat#
+ */
+union cvmx_dtx_hna_datx {
+	uint64_t u64;
+	struct cvmx_dtx_hna_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_hna_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_hna_datx cvmx_dtx_hna_datx_t;
+
+/**
+ * cvmx_dtx_hna_ena#
+ */
+union cvmx_dtx_hna_enax {
+	uint64_t u64;
+	struct cvmx_dtx_hna_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_hna_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_hna_enax cvmx_dtx_hna_enax_t;
+
+/**
+ * cvmx_dtx_hna_sel#
+ */
+union cvmx_dtx_hna_selx {
+	uint64_t u64;
+	struct cvmx_dtx_hna_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_hna_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_hna_selx cvmx_dtx_hna_selx_t;
+
+/**
+ * cvmx_dtx_ila_bcst_rsp
+ */
+union cvmx_dtx_ila_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_ila_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_ila_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_ila_bcst_rsp cvmx_dtx_ila_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_ila_ctl
+ */
+union cvmx_dtx_ila_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_ila_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_ila_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_ila_ctl cvmx_dtx_ila_ctl_t;
+
+/**
+ * cvmx_dtx_ila_dat#
+ */
+union cvmx_dtx_ila_datx {
+	uint64_t u64;
+	struct cvmx_dtx_ila_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ila_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_ila_datx cvmx_dtx_ila_datx_t;
+
+/**
+ * cvmx_dtx_ila_ena#
+ */
+union cvmx_dtx_ila_enax {
+	uint64_t u64;
+	struct cvmx_dtx_ila_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ila_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_ila_enax cvmx_dtx_ila_enax_t;
+
+/**
+ * cvmx_dtx_ila_sel#
+ */
+union cvmx_dtx_ila_selx {
+	uint64_t u64;
+	struct cvmx_dtx_ila_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_ila_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_ila_selx cvmx_dtx_ila_selx_t;
+
+/**
+ * cvmx_dtx_ilk_bcst_rsp
+ */
+union cvmx_dtx_ilk_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_ilk_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_ilk_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_ilk_bcst_rsp cvmx_dtx_ilk_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_ilk_ctl
+ */
+union cvmx_dtx_ilk_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_ilk_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_ilk_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_ilk_ctl cvmx_dtx_ilk_ctl_t;
+
+/**
+ * cvmx_dtx_ilk_dat#
+ */
+union cvmx_dtx_ilk_datx {
+	uint64_t u64;
+	struct cvmx_dtx_ilk_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ilk_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_ilk_datx cvmx_dtx_ilk_datx_t;
+
+/**
+ * cvmx_dtx_ilk_ena#
+ */
+union cvmx_dtx_ilk_enax {
+	uint64_t u64;
+	struct cvmx_dtx_ilk_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ilk_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_ilk_enax cvmx_dtx_ilk_enax_t;
+
+/**
+ * cvmx_dtx_ilk_sel#
+ */
+union cvmx_dtx_ilk_selx {
+	uint64_t u64;
+	struct cvmx_dtx_ilk_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_ilk_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_ilk_selx cvmx_dtx_ilk_selx_t;
+
+/**
+ * cvmx_dtx_iob_bcst_rsp
+ */
+union cvmx_dtx_iob_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_iob_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_iob_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_iob_bcst_rsp_s        cn70xxp1;
+};
+typedef union cvmx_dtx_iob_bcst_rsp cvmx_dtx_iob_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_iob_ctl
+ */
+union cvmx_dtx_iob_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_iob_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_iob_ctl_s             cn70xx;
+	struct cvmx_dtx_iob_ctl_s             cn70xxp1;
+};
+typedef union cvmx_dtx_iob_ctl cvmx_dtx_iob_ctl_t;
+
+/**
+ * cvmx_dtx_iob_dat#
+ */
+union cvmx_dtx_iob_datx {
+	uint64_t u64;
+	struct cvmx_dtx_iob_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_iob_datx_s            cn70xx;
+	struct cvmx_dtx_iob_datx_s            cn70xxp1;
+};
+typedef union cvmx_dtx_iob_datx cvmx_dtx_iob_datx_t;
+
+/**
+ * cvmx_dtx_iob_ena#
+ */
+union cvmx_dtx_iob_enax {
+	uint64_t u64;
+	struct cvmx_dtx_iob_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_iob_enax_s            cn70xx;
+	struct cvmx_dtx_iob_enax_s            cn70xxp1;
+};
+typedef union cvmx_dtx_iob_enax cvmx_dtx_iob_enax_t;
+
+/**
+ * cvmx_dtx_iob_sel#
+ */
+union cvmx_dtx_iob_selx {
+	uint64_t u64;
+	struct cvmx_dtx_iob_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_iob_selx_s            cn70xx;
+	struct cvmx_dtx_iob_selx_s            cn70xxp1;
+};
+typedef union cvmx_dtx_iob_selx cvmx_dtx_iob_selx_t;
+
+/**
+ * cvmx_dtx_iobn_bcst_rsp
+ */
+union cvmx_dtx_iobn_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_iobn_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_iobn_bcst_rsp_s       cn78xx;
+};
+typedef union cvmx_dtx_iobn_bcst_rsp cvmx_dtx_iobn_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_iobn_ctl
+ */
+union cvmx_dtx_iobn_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_iobn_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_iobn_ctl_s            cn78xx;
+};
+typedef union cvmx_dtx_iobn_ctl cvmx_dtx_iobn_ctl_t;
+
+/**
+ * cvmx_dtx_iobn_dat#
+ */
+union cvmx_dtx_iobn_datx {
+	uint64_t u64;
+	struct cvmx_dtx_iobn_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_iobn_datx_s           cn78xx;
+};
+typedef union cvmx_dtx_iobn_datx cvmx_dtx_iobn_datx_t;
+
+/**
+ * cvmx_dtx_iobn_ena#
+ */
+union cvmx_dtx_iobn_enax {
+	uint64_t u64;
+	struct cvmx_dtx_iobn_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_iobn_enax_s           cn78xx;
+};
+typedef union cvmx_dtx_iobn_enax cvmx_dtx_iobn_enax_t;
+
+/**
+ * cvmx_dtx_iobn_sel#
+ */
+union cvmx_dtx_iobn_selx {
+	uint64_t u64;
+	struct cvmx_dtx_iobn_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_iobn_selx_s           cn78xx;
+};
+typedef union cvmx_dtx_iobn_selx cvmx_dtx_iobn_selx_t;
+
+/**
+ * cvmx_dtx_iobp_bcst_rsp
+ */
+union cvmx_dtx_iobp_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_iobp_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_iobp_bcst_rsp_s       cn78xx;
+};
+typedef union cvmx_dtx_iobp_bcst_rsp cvmx_dtx_iobp_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_iobp_ctl
+ */
+union cvmx_dtx_iobp_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_iobp_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_iobp_ctl_s            cn78xx;
+};
+typedef union cvmx_dtx_iobp_ctl cvmx_dtx_iobp_ctl_t;
+
+/**
+ * cvmx_dtx_iobp_dat#
+ */
+union cvmx_dtx_iobp_datx {
+	uint64_t u64;
+	struct cvmx_dtx_iobp_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_iobp_datx_s           cn78xx;
+};
+typedef union cvmx_dtx_iobp_datx cvmx_dtx_iobp_datx_t;
+
+/**
+ * cvmx_dtx_iobp_ena#
+ */
+union cvmx_dtx_iobp_enax {
+	uint64_t u64;
+	struct cvmx_dtx_iobp_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_iobp_enax_s           cn78xx;
+};
+typedef union cvmx_dtx_iobp_enax cvmx_dtx_iobp_enax_t;
+
+/**
+ * cvmx_dtx_iobp_sel#
+ */
+union cvmx_dtx_iobp_selx {
+	uint64_t u64;
+	struct cvmx_dtx_iobp_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_iobp_selx_s           cn78xx;
+};
+typedef union cvmx_dtx_iobp_selx cvmx_dtx_iobp_selx_t;
+
+/**
+ * cvmx_dtx_ipd_bcst_rsp
+ */
+union cvmx_dtx_ipd_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_ipd_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_ipd_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_ipd_bcst_rsp_s        cn70xxp1;
+};
+typedef union cvmx_dtx_ipd_bcst_rsp cvmx_dtx_ipd_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_ipd_ctl
+ */
+union cvmx_dtx_ipd_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_ipd_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_ipd_ctl_s             cn70xx;
+	struct cvmx_dtx_ipd_ctl_s             cn70xxp1;
+};
+typedef union cvmx_dtx_ipd_ctl cvmx_dtx_ipd_ctl_t;
+
+/**
+ * cvmx_dtx_ipd_dat#
+ */
+union cvmx_dtx_ipd_datx {
+	uint64_t u64;
+	struct cvmx_dtx_ipd_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ipd_datx_s            cn70xx;
+	struct cvmx_dtx_ipd_datx_s            cn70xxp1;
+};
+typedef union cvmx_dtx_ipd_datx cvmx_dtx_ipd_datx_t;
+
+/**
+ * cvmx_dtx_ipd_ena#
+ */
+union cvmx_dtx_ipd_enax {
+	uint64_t u64;
+	struct cvmx_dtx_ipd_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ipd_enax_s            cn70xx;
+	struct cvmx_dtx_ipd_enax_s            cn70xxp1;
+};
+typedef union cvmx_dtx_ipd_enax cvmx_dtx_ipd_enax_t;
+
+/**
+ * cvmx_dtx_ipd_sel#
+ */
+union cvmx_dtx_ipd_selx {
+	uint64_t u64;
+	struct cvmx_dtx_ipd_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_ipd_selx_s            cn70xx;
+	struct cvmx_dtx_ipd_selx_s            cn70xxp1;
+};
+typedef union cvmx_dtx_ipd_selx cvmx_dtx_ipd_selx_t;
+
+/**
+ * cvmx_dtx_key_bcst_rsp
+ */
+union cvmx_dtx_key_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_key_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_key_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_key_bcst_rsp_s        cn70xxp1;
+};
+typedef union cvmx_dtx_key_bcst_rsp cvmx_dtx_key_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_key_ctl
+ */
+union cvmx_dtx_key_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_key_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_key_ctl_s             cn70xx;
+	struct cvmx_dtx_key_ctl_s             cn70xxp1;
+};
+typedef union cvmx_dtx_key_ctl cvmx_dtx_key_ctl_t;
+
+/**
+ * cvmx_dtx_key_dat#
+ */
+union cvmx_dtx_key_datx {
+	uint64_t u64;
+	struct cvmx_dtx_key_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_key_datx_s            cn70xx;
+	struct cvmx_dtx_key_datx_s            cn70xxp1;
+};
+typedef union cvmx_dtx_key_datx cvmx_dtx_key_datx_t;
+
+/**
+ * cvmx_dtx_key_ena#
+ */
+union cvmx_dtx_key_enax {
+	uint64_t u64;
+	struct cvmx_dtx_key_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_key_enax_s            cn70xx;
+	struct cvmx_dtx_key_enax_s            cn70xxp1;
+};
+typedef union cvmx_dtx_key_enax cvmx_dtx_key_enax_t;
+
+/**
+ * cvmx_dtx_key_sel#
+ */
+union cvmx_dtx_key_selx {
+	uint64_t u64;
+	struct cvmx_dtx_key_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_key_selx_s            cn70xx;
+	struct cvmx_dtx_key_selx_s            cn70xxp1;
+};
+typedef union cvmx_dtx_key_selx cvmx_dtx_key_selx_t;
+
+/**
+ * cvmx_dtx_l2c_cbc#_bcst_rsp
+ */
+union cvmx_dtx_l2c_cbcx_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn70xx;
+	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s   cn78xx;
+};
+typedef union cvmx_dtx_l2c_cbcx_bcst_rsp cvmx_dtx_l2c_cbcx_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_l2c_cbc#_ctl
+ */
+union cvmx_dtx_l2c_cbcx_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_cbcx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_cbcx_ctl_s        cn70xx;
+	struct cvmx_dtx_l2c_cbcx_ctl_s        cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_ctl_s        cn78xx;
+};
+typedef union cvmx_dtx_l2c_cbcx_ctl cvmx_dtx_l2c_cbcx_ctl_t;
+
+/**
+ * cvmx_dtx_l2c_cbc#_dat#
+ */
+union cvmx_dtx_l2c_cbcx_datx {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_cbcx_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_cbcx_datx_s       cn70xx;
+	struct cvmx_dtx_l2c_cbcx_datx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_datx_s       cn78xx;
+};
+typedef union cvmx_dtx_l2c_cbcx_datx cvmx_dtx_l2c_cbcx_datx_t;
+
+/**
+ * cvmx_dtx_l2c_cbc#_ena#
+ */
+union cvmx_dtx_l2c_cbcx_enax {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_cbcx_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_cbcx_enax_s       cn70xx;
+	struct cvmx_dtx_l2c_cbcx_enax_s       cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_enax_s       cn78xx;
+};
+typedef union cvmx_dtx_l2c_cbcx_enax cvmx_dtx_l2c_cbcx_enax_t;
+
+/**
+ * cvmx_dtx_l2c_cbc#_sel#
+ */
+union cvmx_dtx_l2c_cbcx_selx {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_cbcx_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_cbcx_selx_s       cn70xx;
+	struct cvmx_dtx_l2c_cbcx_selx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_cbcx_selx_s       cn78xx;
+};
+typedef union cvmx_dtx_l2c_cbcx_selx cvmx_dtx_l2c_cbcx_selx_t;
+
+/**
+ * cvmx_dtx_l2c_mci#_bcst_rsp
+ */
+union cvmx_dtx_l2c_mcix_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_mcix_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn70xx;
+	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_bcst_rsp_s   cn78xx;
+};
+typedef union cvmx_dtx_l2c_mcix_bcst_rsp cvmx_dtx_l2c_mcix_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_l2c_mci#_ctl
+ */
+union cvmx_dtx_l2c_mcix_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_mcix_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_mcix_ctl_s        cn70xx;
+	struct cvmx_dtx_l2c_mcix_ctl_s        cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_ctl_s        cn78xx;
+};
+typedef union cvmx_dtx_l2c_mcix_ctl cvmx_dtx_l2c_mcix_ctl_t;
+
+/**
+ * cvmx_dtx_l2c_mci#_dat#
+ */
+union cvmx_dtx_l2c_mcix_datx {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_mcix_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_mcix_datx_s       cn70xx;
+	struct cvmx_dtx_l2c_mcix_datx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_datx_s       cn78xx;
+};
+typedef union cvmx_dtx_l2c_mcix_datx cvmx_dtx_l2c_mcix_datx_t;
+
+/**
+ * cvmx_dtx_l2c_mci#_ena#
+ */
+union cvmx_dtx_l2c_mcix_enax {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_mcix_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_mcix_enax_s       cn70xx;
+	struct cvmx_dtx_l2c_mcix_enax_s       cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_enax_s       cn78xx;
+};
+typedef union cvmx_dtx_l2c_mcix_enax cvmx_dtx_l2c_mcix_enax_t;
+
+/**
+ * cvmx_dtx_l2c_mci#_sel#
+ */
+union cvmx_dtx_l2c_mcix_selx {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_mcix_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_mcix_selx_s       cn70xx;
+	struct cvmx_dtx_l2c_mcix_selx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_mcix_selx_s       cn78xx;
+};
+typedef union cvmx_dtx_l2c_mcix_selx cvmx_dtx_l2c_mcix_selx_t;
+
+/**
+ * cvmx_dtx_l2c_tad#_bcst_rsp
+ */
+union cvmx_dtx_l2c_tadx_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_tadx_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn70xx;
+	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_bcst_rsp_s   cn78xx;
+};
+typedef union cvmx_dtx_l2c_tadx_bcst_rsp cvmx_dtx_l2c_tadx_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_l2c_tad#_ctl
+ */
+union cvmx_dtx_l2c_tadx_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_tadx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_tadx_ctl_s        cn70xx;
+	struct cvmx_dtx_l2c_tadx_ctl_s        cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_ctl_s        cn78xx;
+};
+typedef union cvmx_dtx_l2c_tadx_ctl cvmx_dtx_l2c_tadx_ctl_t;
+
+/**
+ * cvmx_dtx_l2c_tad#_dat#
+ */
+union cvmx_dtx_l2c_tadx_datx {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_tadx_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_tadx_datx_s       cn70xx;
+	struct cvmx_dtx_l2c_tadx_datx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_datx_s       cn78xx;
+};
+typedef union cvmx_dtx_l2c_tadx_datx cvmx_dtx_l2c_tadx_datx_t;
+
+/**
+ * cvmx_dtx_l2c_tad#_ena#
+ */
+union cvmx_dtx_l2c_tadx_enax {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_tadx_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_tadx_enax_s       cn70xx;
+	struct cvmx_dtx_l2c_tadx_enax_s       cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_enax_s       cn78xx;
+};
+typedef union cvmx_dtx_l2c_tadx_enax cvmx_dtx_l2c_tadx_enax_t;
+
+/**
+ * cvmx_dtx_l2c_tad#_sel#
+ */
+union cvmx_dtx_l2c_tadx_selx {
+	uint64_t u64;
+	struct cvmx_dtx_l2c_tadx_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_l2c_tadx_selx_s       cn70xx;
+	struct cvmx_dtx_l2c_tadx_selx_s       cn70xxp1;
+	struct cvmx_dtx_l2c_tadx_selx_s       cn78xx;
+};
+typedef union cvmx_dtx_l2c_tadx_selx cvmx_dtx_l2c_tadx_selx_t;
+
+/**
+ * cvmx_dtx_lap#_bcst_rsp
+ */
+union cvmx_dtx_lapx_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_lapx_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_lapx_bcst_rsp_s       cn78xx;
+};
+typedef union cvmx_dtx_lapx_bcst_rsp cvmx_dtx_lapx_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_lap#_ctl
+ */
+union cvmx_dtx_lapx_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_lapx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_lapx_ctl_s            cn78xx;
+};
+typedef union cvmx_dtx_lapx_ctl cvmx_dtx_lapx_ctl_t;
+
+/**
+ * cvmx_dtx_lap#_dat#
+ */
+union cvmx_dtx_lapx_datx {
+	uint64_t u64;
+	struct cvmx_dtx_lapx_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_lapx_datx_s           cn78xx;
+};
+typedef union cvmx_dtx_lapx_datx cvmx_dtx_lapx_datx_t;
+
+/**
+ * cvmx_dtx_lap#_ena#
+ */
+union cvmx_dtx_lapx_enax {
+	uint64_t u64;
+	struct cvmx_dtx_lapx_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_lapx_enax_s           cn78xx;
+};
+typedef union cvmx_dtx_lapx_enax cvmx_dtx_lapx_enax_t;
+
+/**
+ * cvmx_dtx_lap#_sel#
+ */
+union cvmx_dtx_lapx_selx {
+	uint64_t u64;
+	struct cvmx_dtx_lapx_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_lapx_selx_s           cn78xx;
+};
+typedef union cvmx_dtx_lapx_selx cvmx_dtx_lapx_selx_t;
+
+/**
+ * cvmx_dtx_lbk_bcst_rsp
+ */
+union cvmx_dtx_lbk_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_lbk_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_lbk_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_lbk_bcst_rsp cvmx_dtx_lbk_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_lbk_ctl
+ */
+union cvmx_dtx_lbk_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_lbk_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_lbk_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_lbk_ctl cvmx_dtx_lbk_ctl_t;
+
+/**
+ * cvmx_dtx_lbk_dat#
+ */
+union cvmx_dtx_lbk_datx {
+	uint64_t u64;
+	struct cvmx_dtx_lbk_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_lbk_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_lbk_datx cvmx_dtx_lbk_datx_t;
+
+/**
+ * cvmx_dtx_lbk_ena#
+ */
+union cvmx_dtx_lbk_enax {
+	uint64_t u64;
+	struct cvmx_dtx_lbk_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_lbk_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_lbk_enax cvmx_dtx_lbk_enax_t;
+
+/**
+ * cvmx_dtx_lbk_sel#
+ */
+union cvmx_dtx_lbk_selx {
+	uint64_t u64;
+	struct cvmx_dtx_lbk_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_lbk_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_lbk_selx cvmx_dtx_lbk_selx_t;
+
+/**
+ * cvmx_dtx_lmc#_bcst_rsp
+ */
+union cvmx_dtx_lmcx_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_lmcx_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_lmcx_bcst_rsp_s       cn70xx;
+	struct cvmx_dtx_lmcx_bcst_rsp_s       cn70xxp1;
+	struct cvmx_dtx_lmcx_bcst_rsp_s       cn78xx;
+};
+typedef union cvmx_dtx_lmcx_bcst_rsp cvmx_dtx_lmcx_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_lmc#_ctl
+ */
+union cvmx_dtx_lmcx_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_lmcx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_lmcx_ctl_s            cn70xx;
+	struct cvmx_dtx_lmcx_ctl_s            cn70xxp1;
+	struct cvmx_dtx_lmcx_ctl_s            cn78xx;
+};
+typedef union cvmx_dtx_lmcx_ctl cvmx_dtx_lmcx_ctl_t;
+
+/**
+ * cvmx_dtx_lmc#_dat#
+ */
+union cvmx_dtx_lmcx_datx {
+	uint64_t u64;
+	struct cvmx_dtx_lmcx_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_lmcx_datx_s           cn70xx;
+	struct cvmx_dtx_lmcx_datx_s           cn70xxp1;
+	struct cvmx_dtx_lmcx_datx_s           cn78xx;
+};
+typedef union cvmx_dtx_lmcx_datx cvmx_dtx_lmcx_datx_t;
+
+/**
+ * cvmx_dtx_lmc#_ena#
+ */
+union cvmx_dtx_lmcx_enax {
+	uint64_t u64;
+	struct cvmx_dtx_lmcx_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_lmcx_enax_s           cn70xx;
+	struct cvmx_dtx_lmcx_enax_s           cn70xxp1;
+	struct cvmx_dtx_lmcx_enax_s           cn78xx;
+};
+typedef union cvmx_dtx_lmcx_enax cvmx_dtx_lmcx_enax_t;
+
+/**
+ * cvmx_dtx_lmc#_sel#
+ */
+union cvmx_dtx_lmcx_selx {
+	uint64_t u64;
+	struct cvmx_dtx_lmcx_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_lmcx_selx_s           cn70xx;
+	struct cvmx_dtx_lmcx_selx_s           cn70xxp1;
+	struct cvmx_dtx_lmcx_selx_s           cn78xx;
+};
+typedef union cvmx_dtx_lmcx_selx cvmx_dtx_lmcx_selx_t;
+
+/**
+ * cvmx_dtx_mio_bcst_rsp
+ */
+union cvmx_dtx_mio_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_mio_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_mio_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_mio_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_mio_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_mio_bcst_rsp cvmx_dtx_mio_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_mio_ctl
+ */
+union cvmx_dtx_mio_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_mio_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_mio_ctl_s             cn70xx;
+	struct cvmx_dtx_mio_ctl_s             cn70xxp1;
+	struct cvmx_dtx_mio_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_mio_ctl cvmx_dtx_mio_ctl_t;
+
+/**
+ * cvmx_dtx_mio_dat#
+ */
+union cvmx_dtx_mio_datx {
+	uint64_t u64;
+	struct cvmx_dtx_mio_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_mio_datx_s            cn70xx;
+	struct cvmx_dtx_mio_datx_s            cn70xxp1;
+	struct cvmx_dtx_mio_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_mio_datx cvmx_dtx_mio_datx_t;
+
+/**
+ * cvmx_dtx_mio_ena#
+ */
+union cvmx_dtx_mio_enax {
+	uint64_t u64;
+	struct cvmx_dtx_mio_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_mio_enax_s            cn70xx;
+	struct cvmx_dtx_mio_enax_s            cn70xxp1;
+	struct cvmx_dtx_mio_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_mio_enax cvmx_dtx_mio_enax_t;
+
+/**
+ * cvmx_dtx_mio_sel#
+ */
+union cvmx_dtx_mio_selx {
+	uint64_t u64;
+	struct cvmx_dtx_mio_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_mio_selx_s            cn70xx;
+	struct cvmx_dtx_mio_selx_s            cn70xxp1;
+	struct cvmx_dtx_mio_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_mio_selx cvmx_dtx_mio_selx_t;
+
+/**
+ * cvmx_dtx_ocx_lnk#_bcst_rsp
+ */
+union cvmx_dtx_ocx_lnkx_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_lnkx_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_lnkx_bcst_rsp_s   cn78xx;
+};
+typedef union cvmx_dtx_ocx_lnkx_bcst_rsp cvmx_dtx_ocx_lnkx_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_ocx_lnk#_ctl
+ */
+union cvmx_dtx_ocx_lnkx_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_lnkx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_lnkx_ctl_s        cn78xx;
+};
+typedef union cvmx_dtx_ocx_lnkx_ctl cvmx_dtx_ocx_lnkx_ctl_t;
+
+/**
+ * cvmx_dtx_ocx_lnk#_dat#
+ */
+union cvmx_dtx_ocx_lnkx_datx {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_lnkx_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_lnkx_datx_s       cn78xx;
+};
+typedef union cvmx_dtx_ocx_lnkx_datx cvmx_dtx_ocx_lnkx_datx_t;
+
+/**
+ * cvmx_dtx_ocx_lnk#_ena#
+ */
+union cvmx_dtx_ocx_lnkx_enax {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_lnkx_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_lnkx_enax_s       cn78xx;
+};
+typedef union cvmx_dtx_ocx_lnkx_enax cvmx_dtx_ocx_lnkx_enax_t;
+
+/**
+ * cvmx_dtx_ocx_lnk#_sel#
+ */
+union cvmx_dtx_ocx_lnkx_selx {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_lnkx_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_lnkx_selx_s       cn78xx;
+};
+typedef union cvmx_dtx_ocx_lnkx_selx cvmx_dtx_ocx_lnkx_selx_t;
+
+/**
+ * cvmx_dtx_ocx_ole#_bcst_rsp
+ */
+union cvmx_dtx_ocx_olex_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_olex_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_olex_bcst_rsp_s   cn78xx;
+};
+typedef union cvmx_dtx_ocx_olex_bcst_rsp cvmx_dtx_ocx_olex_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_ocx_ole#_ctl
+ */
+union cvmx_dtx_ocx_olex_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_olex_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_olex_ctl_s        cn78xx;
+};
+typedef union cvmx_dtx_ocx_olex_ctl cvmx_dtx_ocx_olex_ctl_t;
+
+/**
+ * cvmx_dtx_ocx_ole#_dat#
+ */
+union cvmx_dtx_ocx_olex_datx {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_olex_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_olex_datx_s       cn78xx;
+};
+typedef union cvmx_dtx_ocx_olex_datx cvmx_dtx_ocx_olex_datx_t;
+
+/**
+ * cvmx_dtx_ocx_ole#_ena#
+ */
+union cvmx_dtx_ocx_olex_enax {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_olex_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_olex_enax_s       cn78xx;
+};
+typedef union cvmx_dtx_ocx_olex_enax cvmx_dtx_ocx_olex_enax_t;
+
+/**
+ * cvmx_dtx_ocx_ole#_sel#
+ */
+union cvmx_dtx_ocx_olex_selx {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_olex_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_olex_selx_s       cn78xx;
+};
+typedef union cvmx_dtx_ocx_olex_selx cvmx_dtx_ocx_olex_selx_t;
+
+/**
+ * cvmx_dtx_ocx_top_bcst_rsp
+ */
+union cvmx_dtx_ocx_top_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_top_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_top_bcst_rsp_s    cn78xx;
+};
+typedef union cvmx_dtx_ocx_top_bcst_rsp cvmx_dtx_ocx_top_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_ocx_top_ctl
+ */
+union cvmx_dtx_ocx_top_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_top_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_top_ctl_s         cn78xx;
+};
+typedef union cvmx_dtx_ocx_top_ctl cvmx_dtx_ocx_top_ctl_t;
+
+/**
+ * cvmx_dtx_ocx_top_dat#
+ */
+union cvmx_dtx_ocx_top_datx {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_top_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_top_datx_s        cn78xx;
+};
+typedef union cvmx_dtx_ocx_top_datx cvmx_dtx_ocx_top_datx_t;
+
+/**
+ * cvmx_dtx_ocx_top_ena#
+ */
+union cvmx_dtx_ocx_top_enax {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_top_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_top_enax_s        cn78xx;
+};
+typedef union cvmx_dtx_ocx_top_enax cvmx_dtx_ocx_top_enax_t;
+
+/**
+ * cvmx_dtx_ocx_top_sel#
+ */
+union cvmx_dtx_ocx_top_selx {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_top_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_top_selx_s        cn78xx;
+};
+typedef union cvmx_dtx_ocx_top_selx cvmx_dtx_ocx_top_selx_t;
+
+/**
+ * cvmx_dtx_osm_bcst_rsp
+ */
+union cvmx_dtx_osm_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_osm_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_osm_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_osm_bcst_rsp cvmx_dtx_osm_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_osm_ctl
+ */
+union cvmx_dtx_osm_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_osm_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_osm_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_osm_ctl cvmx_dtx_osm_ctl_t;
+
+/**
+ * cvmx_dtx_osm_dat#
+ */
+union cvmx_dtx_osm_datx {
+	uint64_t u64;
+	struct cvmx_dtx_osm_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_osm_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_osm_datx cvmx_dtx_osm_datx_t;
+
+/**
+ * cvmx_dtx_osm_ena#
+ */
+union cvmx_dtx_osm_enax {
+	uint64_t u64;
+	struct cvmx_dtx_osm_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_osm_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_osm_enax cvmx_dtx_osm_enax_t;
+
+/**
+ * cvmx_dtx_osm_sel#
+ */
+union cvmx_dtx_osm_selx {
+	uint64_t u64;
+	struct cvmx_dtx_osm_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_osm_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_osm_selx cvmx_dtx_osm_selx_t;
+
+/**
+ * cvmx_dtx_pcs#_bcst_rsp
+ */
+union cvmx_dtx_pcsx_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_pcsx_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_pcsx_bcst_rsp_s       cn70xx;
+	struct cvmx_dtx_pcsx_bcst_rsp_s       cn70xxp1;
+};
+typedef union cvmx_dtx_pcsx_bcst_rsp cvmx_dtx_pcsx_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_pcs#_ctl
+ */
+union cvmx_dtx_pcsx_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_pcsx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_pcsx_ctl_s            cn70xx;
+	struct cvmx_dtx_pcsx_ctl_s            cn70xxp1;
+};
+typedef union cvmx_dtx_pcsx_ctl cvmx_dtx_pcsx_ctl_t;
+
+/**
+ * cvmx_dtx_pcs#_dat#
+ */
+union cvmx_dtx_pcsx_datx {
+	uint64_t u64;
+	struct cvmx_dtx_pcsx_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pcsx_datx_s           cn70xx;
+	struct cvmx_dtx_pcsx_datx_s           cn70xxp1;
+};
+typedef union cvmx_dtx_pcsx_datx cvmx_dtx_pcsx_datx_t;
+
+/**
+ * cvmx_dtx_pcs#_ena#
+ */
+union cvmx_dtx_pcsx_enax {
+	uint64_t u64;
+	struct cvmx_dtx_pcsx_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pcsx_enax_s           cn70xx;
+	struct cvmx_dtx_pcsx_enax_s           cn70xxp1;
+};
+typedef union cvmx_dtx_pcsx_enax cvmx_dtx_pcsx_enax_t;
+
+/**
+ * cvmx_dtx_pcs#_sel#
+ */
+union cvmx_dtx_pcsx_selx {
+	uint64_t u64;
+	struct cvmx_dtx_pcsx_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_pcsx_selx_s           cn70xx;
+	struct cvmx_dtx_pcsx_selx_s           cn70xxp1;
+};
+typedef union cvmx_dtx_pcsx_selx cvmx_dtx_pcsx_selx_t;
+
+/**
+ * cvmx_dtx_pem#_bcst_rsp
+ */
+union cvmx_dtx_pemx_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_pemx_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_pemx_bcst_rsp_s       cn70xx;
+	struct cvmx_dtx_pemx_bcst_rsp_s       cn70xxp1;
+	struct cvmx_dtx_pemx_bcst_rsp_s       cn78xx;
+};
+typedef union cvmx_dtx_pemx_bcst_rsp cvmx_dtx_pemx_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_pem#_ctl
+ */
+union cvmx_dtx_pemx_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_pemx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_pemx_ctl_s            cn70xx;
+	struct cvmx_dtx_pemx_ctl_s            cn70xxp1;
+	struct cvmx_dtx_pemx_ctl_s            cn78xx;
+};
+typedef union cvmx_dtx_pemx_ctl cvmx_dtx_pemx_ctl_t;
+
+/**
+ * cvmx_dtx_pem#_dat#
+ */
+union cvmx_dtx_pemx_datx {
+	uint64_t u64;
+	struct cvmx_dtx_pemx_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pemx_datx_s           cn70xx;
+	struct cvmx_dtx_pemx_datx_s           cn70xxp1;
+	struct cvmx_dtx_pemx_datx_s           cn78xx;
+};
+typedef union cvmx_dtx_pemx_datx cvmx_dtx_pemx_datx_t;
+
+/**
+ * cvmx_dtx_pem#_ena#
+ */
+union cvmx_dtx_pemx_enax {
+	uint64_t u64;
+	struct cvmx_dtx_pemx_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pemx_enax_s           cn70xx;
+	struct cvmx_dtx_pemx_enax_s           cn70xxp1;
+	struct cvmx_dtx_pemx_enax_s           cn78xx;
+};
+typedef union cvmx_dtx_pemx_enax cvmx_dtx_pemx_enax_t;
+
+/**
+ * cvmx_dtx_pem#_sel#
+ */
+union cvmx_dtx_pemx_selx {
+	uint64_t u64;
+	struct cvmx_dtx_pemx_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_pemx_selx_s           cn70xx;
+	struct cvmx_dtx_pemx_selx_s           cn70xxp1;
+	struct cvmx_dtx_pemx_selx_s           cn78xx;
+};
+typedef union cvmx_dtx_pemx_selx cvmx_dtx_pemx_selx_t;
+
+/**
+ * cvmx_dtx_pip_bcst_rsp
+ */
+union cvmx_dtx_pip_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_pip_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_pip_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_pip_bcst_rsp_s        cn70xxp1;
+};
+typedef union cvmx_dtx_pip_bcst_rsp cvmx_dtx_pip_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_pip_ctl
+ */
+union cvmx_dtx_pip_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_pip_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_pip_ctl_s             cn70xx;
+	struct cvmx_dtx_pip_ctl_s             cn70xxp1;
+};
+typedef union cvmx_dtx_pip_ctl cvmx_dtx_pip_ctl_t;
+
+/**
+ * cvmx_dtx_pip_dat#
+ */
+union cvmx_dtx_pip_datx {
+	uint64_t u64;
+	struct cvmx_dtx_pip_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pip_datx_s            cn70xx;
+	struct cvmx_dtx_pip_datx_s            cn70xxp1;
+};
+typedef union cvmx_dtx_pip_datx cvmx_dtx_pip_datx_t;
+
+/**
+ * cvmx_dtx_pip_ena#
+ */
+union cvmx_dtx_pip_enax {
+	uint64_t u64;
+	struct cvmx_dtx_pip_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pip_enax_s            cn70xx;
+	struct cvmx_dtx_pip_enax_s            cn70xxp1;
+};
+typedef union cvmx_dtx_pip_enax cvmx_dtx_pip_enax_t;
+
+/**
+ * cvmx_dtx_pip_sel#
+ */
+union cvmx_dtx_pip_selx {
+	uint64_t u64;
+	struct cvmx_dtx_pip_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_pip_selx_s            cn70xx;
+	struct cvmx_dtx_pip_selx_s            cn70xxp1;
+};
+typedef union cvmx_dtx_pip_selx cvmx_dtx_pip_selx_t;
+
+/**
+ * cvmx_dtx_pki_pbe_bcst_rsp
+ */
+union cvmx_dtx_pki_pbe_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pbe_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pbe_bcst_rsp_s    cn78xx;
+};
+typedef union cvmx_dtx_pki_pbe_bcst_rsp cvmx_dtx_pki_pbe_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_pki_pbe_ctl
+ */
+union cvmx_dtx_pki_pbe_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pbe_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pbe_ctl_s         cn78xx;
+};
+typedef union cvmx_dtx_pki_pbe_ctl cvmx_dtx_pki_pbe_ctl_t;
+
+/**
+ * cvmx_dtx_pki_pbe_dat#
+ */
+union cvmx_dtx_pki_pbe_datx {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pbe_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pbe_datx_s        cn78xx;
+};
+typedef union cvmx_dtx_pki_pbe_datx cvmx_dtx_pki_pbe_datx_t;
+
+/**
+ * cvmx_dtx_pki_pbe_ena#
+ */
+union cvmx_dtx_pki_pbe_enax {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pbe_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pbe_enax_s        cn78xx;
+};
+typedef union cvmx_dtx_pki_pbe_enax cvmx_dtx_pki_pbe_enax_t;
+
+/**
+ * cvmx_dtx_pki_pbe_sel#
+ */
+union cvmx_dtx_pki_pbe_selx {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pbe_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pbe_selx_s        cn78xx;
+};
+typedef union cvmx_dtx_pki_pbe_selx cvmx_dtx_pki_pbe_selx_t;
+
+/**
+ * cvmx_dtx_pki_pfe_bcst_rsp
+ */
+union cvmx_dtx_pki_pfe_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pfe_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pfe_bcst_rsp_s    cn78xx;
+};
+typedef union cvmx_dtx_pki_pfe_bcst_rsp cvmx_dtx_pki_pfe_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_pki_pfe_ctl
+ */
+union cvmx_dtx_pki_pfe_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pfe_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pfe_ctl_s         cn78xx;
+};
+typedef union cvmx_dtx_pki_pfe_ctl cvmx_dtx_pki_pfe_ctl_t;
+
+/**
+ * cvmx_dtx_pki_pfe_dat#
+ */
+union cvmx_dtx_pki_pfe_datx {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pfe_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pfe_datx_s        cn78xx;
+};
+typedef union cvmx_dtx_pki_pfe_datx cvmx_dtx_pki_pfe_datx_t;
+
+/**
+ * cvmx_dtx_pki_pfe_ena#
+ */
+union cvmx_dtx_pki_pfe_enax {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pfe_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pfe_enax_s        cn78xx;
+};
+typedef union cvmx_dtx_pki_pfe_enax cvmx_dtx_pki_pfe_enax_t;
+
+/**
+ * cvmx_dtx_pki_pfe_sel#
+ */
+union cvmx_dtx_pki_pfe_selx {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pfe_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pfe_selx_s        cn78xx;
+};
+typedef union cvmx_dtx_pki_pfe_selx cvmx_dtx_pki_pfe_selx_t;
+
+/**
+ * cvmx_dtx_pki_pix_bcst_rsp
+ */
+union cvmx_dtx_pki_pix_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pix_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pix_bcst_rsp_s    cn78xx;
+};
+typedef union cvmx_dtx_pki_pix_bcst_rsp cvmx_dtx_pki_pix_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_pki_pix_ctl
+ */
+union cvmx_dtx_pki_pix_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pix_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pix_ctl_s         cn78xx;
+};
+typedef union cvmx_dtx_pki_pix_ctl cvmx_dtx_pki_pix_ctl_t;
+
+/**
+ * cvmx_dtx_pki_pix_dat#
+ */
+union cvmx_dtx_pki_pix_datx {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pix_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pix_datx_s        cn78xx;
+};
+typedef union cvmx_dtx_pki_pix_datx cvmx_dtx_pki_pix_datx_t;
+
+/**
+ * cvmx_dtx_pki_pix_ena#
+ */
+union cvmx_dtx_pki_pix_enax {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pix_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pix_enax_s        cn78xx;
+};
+typedef union cvmx_dtx_pki_pix_enax cvmx_dtx_pki_pix_enax_t;
+
+/**
+ * cvmx_dtx_pki_pix_sel#
+ */
+union cvmx_dtx_pki_pix_selx {
+	uint64_t u64;
+	struct cvmx_dtx_pki_pix_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_pki_pix_selx_s        cn78xx;
+};
+typedef union cvmx_dtx_pki_pix_selx cvmx_dtx_pki_pix_selx_t;
+
+/**
+ * cvmx_dtx_pko_bcst_rsp
+ */
+union cvmx_dtx_pko_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_pko_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_pko_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_pko_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_pko_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_pko_bcst_rsp cvmx_dtx_pko_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_pko_ctl
+ */
+union cvmx_dtx_pko_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_pko_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_pko_ctl_s             cn70xx;
+	struct cvmx_dtx_pko_ctl_s             cn70xxp1;
+	struct cvmx_dtx_pko_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_pko_ctl cvmx_dtx_pko_ctl_t;
+
+/**
+ * cvmx_dtx_pko_dat#
+ */
+union cvmx_dtx_pko_datx {
+	uint64_t u64;
+	struct cvmx_dtx_pko_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pko_datx_s            cn70xx;
+	struct cvmx_dtx_pko_datx_s            cn70xxp1;
+	struct cvmx_dtx_pko_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_pko_datx cvmx_dtx_pko_datx_t;
+
+/**
+ * cvmx_dtx_pko_ena#
+ */
+union cvmx_dtx_pko_enax {
+	uint64_t u64;
+	struct cvmx_dtx_pko_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pko_enax_s            cn70xx;
+	struct cvmx_dtx_pko_enax_s            cn70xxp1;
+	struct cvmx_dtx_pko_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_pko_enax cvmx_dtx_pko_enax_t;
+
+/**
+ * cvmx_dtx_pko_sel#
+ */
+union cvmx_dtx_pko_selx {
+	uint64_t u64;
+	struct cvmx_dtx_pko_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_pko_selx_s            cn70xx;
+	struct cvmx_dtx_pko_selx_s            cn70xxp1;
+	struct cvmx_dtx_pko_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_pko_selx cvmx_dtx_pko_selx_t;
+
+/**
+ * cvmx_dtx_pow_bcst_rsp
+ */
+union cvmx_dtx_pow_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_pow_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_pow_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_pow_bcst_rsp_s        cn70xxp1;
+};
+typedef union cvmx_dtx_pow_bcst_rsp cvmx_dtx_pow_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_pow_ctl
+ */
+union cvmx_dtx_pow_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_pow_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_pow_ctl_s             cn70xx;
+	struct cvmx_dtx_pow_ctl_s             cn70xxp1;
+};
+typedef union cvmx_dtx_pow_ctl cvmx_dtx_pow_ctl_t;
+
+/**
+ * cvmx_dtx_pow_dat#
+ */
+union cvmx_dtx_pow_datx {
+	uint64_t u64;
+	struct cvmx_dtx_pow_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pow_datx_s            cn70xx;
+	struct cvmx_dtx_pow_datx_s            cn70xxp1;
+};
+typedef union cvmx_dtx_pow_datx cvmx_dtx_pow_datx_t;
+
+/**
+ * cvmx_dtx_pow_ena#
+ */
+union cvmx_dtx_pow_enax {
+	uint64_t u64;
+	struct cvmx_dtx_pow_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_pow_enax_s            cn70xx;
+	struct cvmx_dtx_pow_enax_s            cn70xxp1;
+};
+typedef union cvmx_dtx_pow_enax cvmx_dtx_pow_enax_t;
+
+/**
+ * cvmx_dtx_pow_sel#
+ */
+union cvmx_dtx_pow_selx {
+	uint64_t u64;
+	struct cvmx_dtx_pow_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_pow_selx_s            cn70xx;
+	struct cvmx_dtx_pow_selx_s            cn70xxp1;
+};
+typedef union cvmx_dtx_pow_selx cvmx_dtx_pow_selx_t;
+
+/**
+ * cvmx_dtx_rad_bcst_rsp
+ */
+union cvmx_dtx_rad_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_rad_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_rad_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_rad_bcst_rsp cvmx_dtx_rad_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_rad_ctl
+ */
+union cvmx_dtx_rad_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_rad_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_rad_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_rad_ctl cvmx_dtx_rad_ctl_t;
+
+/**
+ * cvmx_dtx_rad_dat#
+ */
+union cvmx_dtx_rad_datx {
+	uint64_t u64;
+	struct cvmx_dtx_rad_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_rad_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_rad_datx cvmx_dtx_rad_datx_t;
+
+/**
+ * cvmx_dtx_rad_ena#
+ */
+union cvmx_dtx_rad_enax {
+	uint64_t u64;
+	struct cvmx_dtx_rad_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_rad_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_rad_enax cvmx_dtx_rad_enax_t;
+
+/**
+ * cvmx_dtx_rad_sel#
+ */
+union cvmx_dtx_rad_selx {
+	uint64_t u64;
+	struct cvmx_dtx_rad_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_rad_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_rad_selx cvmx_dtx_rad_selx_t;
+
+/**
+ * cvmx_dtx_rnm_bcst_rsp
+ */
+union cvmx_dtx_rnm_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_rnm_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_rnm_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_rnm_bcst_rsp cvmx_dtx_rnm_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_rnm_ctl
+ */
+union cvmx_dtx_rnm_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_rnm_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_rnm_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_rnm_ctl cvmx_dtx_rnm_ctl_t;
+
+/**
+ * cvmx_dtx_rnm_dat#
+ */
+union cvmx_dtx_rnm_datx {
+	uint64_t u64;
+	struct cvmx_dtx_rnm_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_rnm_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_rnm_datx cvmx_dtx_rnm_datx_t;
+
+/**
+ * cvmx_dtx_rnm_ena#
+ */
+union cvmx_dtx_rnm_enax {
+	uint64_t u64;
+	struct cvmx_dtx_rnm_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_rnm_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_rnm_enax cvmx_dtx_rnm_enax_t;
+
+/**
+ * cvmx_dtx_rnm_sel#
+ */
+union cvmx_dtx_rnm_selx {
+	uint64_t u64;
+	struct cvmx_dtx_rnm_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_rnm_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_rnm_selx cvmx_dtx_rnm_selx_t;
+
+/**
+ * cvmx_dtx_rst_bcst_rsp
+ */
+union cvmx_dtx_rst_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_rst_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_rst_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_rst_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_rst_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_rst_bcst_rsp cvmx_dtx_rst_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_rst_ctl
+ */
+union cvmx_dtx_rst_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_rst_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_rst_ctl_s             cn70xx;
+	struct cvmx_dtx_rst_ctl_s             cn70xxp1;
+	struct cvmx_dtx_rst_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_rst_ctl cvmx_dtx_rst_ctl_t;
+
+/**
+ * cvmx_dtx_rst_dat#
+ */
+union cvmx_dtx_rst_datx {
+	uint64_t u64;
+	struct cvmx_dtx_rst_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_rst_datx_s            cn70xx;
+	struct cvmx_dtx_rst_datx_s            cn70xxp1;
+	struct cvmx_dtx_rst_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_rst_datx cvmx_dtx_rst_datx_t;
+
+/**
+ * cvmx_dtx_rst_ena#
+ */
+union cvmx_dtx_rst_enax {
+	uint64_t u64;
+	struct cvmx_dtx_rst_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_rst_enax_s            cn70xx;
+	struct cvmx_dtx_rst_enax_s            cn70xxp1;
+	struct cvmx_dtx_rst_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_rst_enax cvmx_dtx_rst_enax_t;
+
+/**
+ * cvmx_dtx_rst_sel#
+ */
+union cvmx_dtx_rst_selx {
+	uint64_t u64;
+	struct cvmx_dtx_rst_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_rst_selx_s            cn70xx;
+	struct cvmx_dtx_rst_selx_s            cn70xxp1;
+	struct cvmx_dtx_rst_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_rst_selx cvmx_dtx_rst_selx_t;
+
+/**
+ * cvmx_dtx_sata_bcst_rsp
+ */
+union cvmx_dtx_sata_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_sata_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_sata_bcst_rsp_s       cn70xx;
+	struct cvmx_dtx_sata_bcst_rsp_s       cn70xxp1;
+};
+typedef union cvmx_dtx_sata_bcst_rsp cvmx_dtx_sata_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_sata_ctl
+ */
+union cvmx_dtx_sata_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_sata_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_sata_ctl_s            cn70xx;
+	struct cvmx_dtx_sata_ctl_s            cn70xxp1;
+};
+typedef union cvmx_dtx_sata_ctl cvmx_dtx_sata_ctl_t;
+
+/**
+ * cvmx_dtx_sata_dat#
+ */
+union cvmx_dtx_sata_datx {
+	uint64_t u64;
+	struct cvmx_dtx_sata_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_sata_datx_s           cn70xx;
+	struct cvmx_dtx_sata_datx_s           cn70xxp1;
+};
+typedef union cvmx_dtx_sata_datx cvmx_dtx_sata_datx_t;
+
+/**
+ * cvmx_dtx_sata_ena#
+ */
+union cvmx_dtx_sata_enax {
+	uint64_t u64;
+	struct cvmx_dtx_sata_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_sata_enax_s           cn70xx;
+	struct cvmx_dtx_sata_enax_s           cn70xxp1;
+};
+typedef union cvmx_dtx_sata_enax cvmx_dtx_sata_enax_t;
+
+/**
+ * cvmx_dtx_sata_sel#
+ */
+union cvmx_dtx_sata_selx {
+	uint64_t u64;
+	struct cvmx_dtx_sata_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_sata_selx_s           cn70xx;
+	struct cvmx_dtx_sata_selx_s           cn70xxp1;
+};
+typedef union cvmx_dtx_sata_selx cvmx_dtx_sata_selx_t;
+
+/**
+ * cvmx_dtx_sli_bcst_rsp
+ */
+union cvmx_dtx_sli_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_sli_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_sli_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_sli_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_sli_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_sli_bcst_rsp cvmx_dtx_sli_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_sli_ctl
+ */
+union cvmx_dtx_sli_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_sli_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_sli_ctl_s             cn70xx;
+	struct cvmx_dtx_sli_ctl_s             cn70xxp1;
+	struct cvmx_dtx_sli_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_sli_ctl cvmx_dtx_sli_ctl_t;
+
+/**
+ * cvmx_dtx_sli_dat#
+ */
+union cvmx_dtx_sli_datx {
+	uint64_t u64;
+	struct cvmx_dtx_sli_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_sli_datx_s            cn70xx;
+	struct cvmx_dtx_sli_datx_s            cn70xxp1;
+	struct cvmx_dtx_sli_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_sli_datx cvmx_dtx_sli_datx_t;
+
+/**
+ * cvmx_dtx_sli_ena#
+ */
+union cvmx_dtx_sli_enax {
+	uint64_t u64;
+	struct cvmx_dtx_sli_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_sli_enax_s            cn70xx;
+	struct cvmx_dtx_sli_enax_s            cn70xxp1;
+	struct cvmx_dtx_sli_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_sli_enax cvmx_dtx_sli_enax_t;
+
+/**
+ * cvmx_dtx_sli_sel#
+ */
+union cvmx_dtx_sli_selx {
+	uint64_t u64;
+	struct cvmx_dtx_sli_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_sli_selx_s            cn70xx;
+	struct cvmx_dtx_sli_selx_s            cn70xxp1;
+	struct cvmx_dtx_sli_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_sli_selx cvmx_dtx_sli_selx_t;
+
+/**
+ * cvmx_dtx_sso_bcst_rsp
+ */
+union cvmx_dtx_sso_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_sso_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_sso_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_sso_bcst_rsp cvmx_dtx_sso_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_sso_ctl
+ */
+union cvmx_dtx_sso_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_sso_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_sso_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_sso_ctl cvmx_dtx_sso_ctl_t;
+
+/**
+ * cvmx_dtx_sso_dat#
+ */
+union cvmx_dtx_sso_datx {
+	uint64_t u64;
+	struct cvmx_dtx_sso_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_sso_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_sso_datx cvmx_dtx_sso_datx_t;
+
+/**
+ * cvmx_dtx_sso_ena#
+ */
+union cvmx_dtx_sso_enax {
+	uint64_t u64;
+	struct cvmx_dtx_sso_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_sso_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_sso_enax cvmx_dtx_sso_enax_t;
+
+/**
+ * cvmx_dtx_sso_sel#
+ */
+union cvmx_dtx_sso_selx {
+	uint64_t u64;
+	struct cvmx_dtx_sso_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_sso_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_sso_selx cvmx_dtx_sso_selx_t;
+
+/**
+ * cvmx_dtx_tim_bcst_rsp
+ */
+union cvmx_dtx_tim_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_tim_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_tim_bcst_rsp_s        cn70xx;
+	struct cvmx_dtx_tim_bcst_rsp_s        cn70xxp1;
+	struct cvmx_dtx_tim_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_tim_bcst_rsp cvmx_dtx_tim_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_tim_ctl
+ */
+union cvmx_dtx_tim_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_tim_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_tim_ctl_s             cn70xx;
+	struct cvmx_dtx_tim_ctl_s             cn70xxp1;
+	struct cvmx_dtx_tim_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_tim_ctl cvmx_dtx_tim_ctl_t;
+
+/**
+ * cvmx_dtx_tim_dat#
+ */
+union cvmx_dtx_tim_datx {
+	uint64_t u64;
+	struct cvmx_dtx_tim_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_tim_datx_s            cn70xx;
+	struct cvmx_dtx_tim_datx_s            cn70xxp1;
+	struct cvmx_dtx_tim_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_tim_datx cvmx_dtx_tim_datx_t;
+
+/**
+ * cvmx_dtx_tim_ena#
+ */
+union cvmx_dtx_tim_enax {
+	uint64_t u64;
+	struct cvmx_dtx_tim_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_tim_enax_s            cn70xx;
+	struct cvmx_dtx_tim_enax_s            cn70xxp1;
+	struct cvmx_dtx_tim_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_tim_enax cvmx_dtx_tim_enax_t;
+
+/**
+ * cvmx_dtx_tim_sel#
+ */
+union cvmx_dtx_tim_selx {
+	uint64_t u64;
+	struct cvmx_dtx_tim_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_tim_selx_s            cn70xx;
+	struct cvmx_dtx_tim_selx_s            cn70xxp1;
+	struct cvmx_dtx_tim_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_tim_selx cvmx_dtx_tim_selx_t;
+
+/**
+ * cvmx_dtx_usbdrd#_bcst_rsp
+ */
+union cvmx_dtx_usbdrdx_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_usbdrdx_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_usbdrdx_bcst_rsp_s    cn70xx;
+	struct cvmx_dtx_usbdrdx_bcst_rsp_s    cn70xxp1;
+};
+typedef union cvmx_dtx_usbdrdx_bcst_rsp cvmx_dtx_usbdrdx_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_usbdrd#_ctl
+ */
+union cvmx_dtx_usbdrdx_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_usbdrdx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_usbdrdx_ctl_s         cn70xx;
+	struct cvmx_dtx_usbdrdx_ctl_s         cn70xxp1;
+};
+typedef union cvmx_dtx_usbdrdx_ctl cvmx_dtx_usbdrdx_ctl_t;
+
+/**
+ * cvmx_dtx_usbdrd#_dat#
+ */
+union cvmx_dtx_usbdrdx_datx {
+	uint64_t u64;
+	struct cvmx_dtx_usbdrdx_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_usbdrdx_datx_s        cn70xx;
+	struct cvmx_dtx_usbdrdx_datx_s        cn70xxp1;
+};
+typedef union cvmx_dtx_usbdrdx_datx cvmx_dtx_usbdrdx_datx_t;
+
+/**
+ * cvmx_dtx_usbdrd#_ena#
+ */
+union cvmx_dtx_usbdrdx_enax {
+	uint64_t u64;
+	struct cvmx_dtx_usbdrdx_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_usbdrdx_enax_s        cn70xx;
+	struct cvmx_dtx_usbdrdx_enax_s        cn70xxp1;
+};
+typedef union cvmx_dtx_usbdrdx_enax cvmx_dtx_usbdrdx_enax_t;
+
+/**
+ * cvmx_dtx_usbdrd#_sel#
+ */
+union cvmx_dtx_usbdrdx_selx {
+	uint64_t u64;
+	struct cvmx_dtx_usbdrdx_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_usbdrdx_selx_s        cn70xx;
+	struct cvmx_dtx_usbdrdx_selx_s        cn70xxp1;
+};
+typedef union cvmx_dtx_usbdrdx_selx cvmx_dtx_usbdrdx_selx_t;
+
+/**
+ * cvmx_dtx_usbh#_bcst_rsp
+ */
+union cvmx_dtx_usbhx_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_usbhx_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_usbhx_bcst_rsp_s      cn78xx;
+};
+typedef union cvmx_dtx_usbhx_bcst_rsp cvmx_dtx_usbhx_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_usbh#_ctl
+ */
+union cvmx_dtx_usbhx_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_usbhx_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_usbhx_ctl_s           cn78xx;
+};
+typedef union cvmx_dtx_usbhx_ctl cvmx_dtx_usbhx_ctl_t;
+
+/**
+ * cvmx_dtx_usbh#_dat#
+ */
+union cvmx_dtx_usbhx_datx {
+	uint64_t u64;
+	struct cvmx_dtx_usbhx_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_usbhx_datx_s          cn78xx;
+};
+typedef union cvmx_dtx_usbhx_datx cvmx_dtx_usbhx_datx_t;
+
+/**
+ * cvmx_dtx_usbh#_ena#
+ */
+union cvmx_dtx_usbhx_enax {
+	uint64_t u64;
+	struct cvmx_dtx_usbhx_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_usbhx_enax_s          cn78xx;
+};
+typedef union cvmx_dtx_usbhx_enax cvmx_dtx_usbhx_enax_t;
+
+/**
+ * cvmx_dtx_usbh#_sel#
+ */
+union cvmx_dtx_usbhx_selx {
+	uint64_t u64;
+	struct cvmx_dtx_usbhx_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_usbhx_selx_s          cn78xx;
+};
+typedef union cvmx_dtx_usbhx_selx cvmx_dtx_usbhx_selx_t;
+
+/**
+ * cvmx_dtx_zip_bcst_rsp
+ */
+union cvmx_dtx_zip_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_zip_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_zip_bcst_rsp_s        cn78xx;
+};
+typedef union cvmx_dtx_zip_bcst_rsp cvmx_dtx_zip_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_zip_ctl
+ */
+union cvmx_dtx_zip_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_zip_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_zip_ctl_s             cn78xx;
+};
+typedef union cvmx_dtx_zip_ctl cvmx_dtx_zip_ctl_t;
+
+/**
+ * cvmx_dtx_zip_dat#
+ */
+union cvmx_dtx_zip_datx {
+	uint64_t u64;
+	struct cvmx_dtx_zip_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_zip_datx_s            cn78xx;
+};
+typedef union cvmx_dtx_zip_datx cvmx_dtx_zip_datx_t;
+
+/**
+ * cvmx_dtx_zip_ena#
+ */
+union cvmx_dtx_zip_enax {
+	uint64_t u64;
+	struct cvmx_dtx_zip_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_zip_enax_s            cn78xx;
+};
+typedef union cvmx_dtx_zip_enax cvmx_dtx_zip_enax_t;
+
+/**
+ * cvmx_dtx_zip_sel#
+ */
+union cvmx_dtx_zip_selx {
+	uint64_t u64;
+	struct cvmx_dtx_zip_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_zip_selx_s            cn78xx;
+};
+typedef union cvmx_dtx_zip_selx cvmx_dtx_zip_selx_t;
+
+#endif
diff --git a/arch/mips/include/asm/octeon/cvmx-ocla.h b/arch/mips/include/asm/octeon/cvmx-ocla.h
new file mode 100644
index 0000000..b625d6f
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-ocla.h
@@ -0,0 +1,449 @@
+/***********************license start***************
+ * Copyright (c) 2003-2014  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Interface to the On Chip Logic Analyzer (OCLA) hardware.
+ *
+ * The ocla provides capabilities to trace internal transactions for software
+ * debugging, performance tuning, and hardware diagnostics.
+ *
+ * The ocla receives 72 bits of data from coprocessors or capture points via
+ * debug bus transmitters (DTXs). These 72 bits of data are broken up into two
+ * halves of 36 bits each.
+ *
+ *                          ----------------------------
+ *                          |                          |
+ *         data from DTXs   |                          |
+ *        ----------------->|         ocla             |
+ *         2 36-bit halves  |                          |
+ *             (72 bits)    |                          |
+ *                          ----------------------------
+ *
+ * The ocla alignes each bit of data (Aligner).
+ * The aligner passes the data to the 4 matchers.
+ * The matchers pass the data to the FSMs.
+ * The FSMs determine when to capture data. When the FSM requests a capture, the
+ * data is stored in the data fifo and optionally overflows to ddr/L2 cache.
+ *
+ *                  X 1               X 4             X 2              X 1
+ *              -----------       -----------       -------       -------------
+ *         DTX  |         |       |         |       |     |       |           |
+ *        ----->| Aligner |------>| Matcher |------>| FSM |------>| data fifo |
+ *              |         |   ^   |         |       |     |   |   |           |
+ *              -----------   |   -----------       -------   |   -------------
+ *                            |                               |
+ *                            ---------------------------------
+ *
+ * Debug Bus Transmitters (DTX):
+ *	. The DTXs feed the OCLA.
+ *	. The DTXs get data from points outside the ocla.
+ *	. Each dtx can drive one or both 36-bit halves.
+ *	. Each 36-bit halve can be shared by multiple DTXs, but each DTX must 
+ *	  drive a different set of bits.
+ *	. Each DTX must be configured to select which data format will be put on
+ *	  the 36-bit halve. The data formats are hardcoded in the hardware.
+ *	  Software simple selects the format to use.
+ *
+ * Aligner:
+ *	. The aligner delays each bit to correct for the variable amount of
+ *	  propagation delay between signals from different blocks.
+ *
+ * Matchers:
+ *      . Each matcher contains a mask and data to compere the aligned data
+ *	  with.
+ *	. Each matcher also contains a 32-bit counter. This counter can be used
+ *	  to count the number of matches or to collect samples of capture data
+ *	  (sample every Nth match, or match after every Nth cycle).
+ *
+ * FSMs:
+ *	. Each FSM is implemented as a programmable logic array (PLA) style
+ *	  organization, with 15 inputs and 4 outputs.
+ *
+ *	. The 15 inputs are:
+ *	    . Matchers output (x4).
+ *	    . Previous state of FSM0 (x4).
+ *	    . Previous state of FSM1 (x4).
+ *	    . Multicore debug wires (x3).
+ *
+ *	. The 15 inputs are manipulated and produce the 4 outputs.
+ *	. The 4 outputs select one of 16 states the fsm can transtion to.
+ *	. Each of the 16 states can be configured to capture data, generate
+ *	  an interrupt, etc.
+ *
+ *	. The FSM implementation is that of an PLA:
+ *
+ *                          AND0  AND1        AND15
+ *                            |    |   .....    |
+ *            mcd      -------+----+------------+--
+ *                            |    |            |
+ *            matchers -------+----+------------+--
+ *                            |    |            |
+ *            fsm0     -------+----+------------+--
+ *                            |    |            |
+ *            fsm1     -------+----+------------+--
+ *                            |    |            |
+ *                            |    |            |
+ *                          --+----+------------+-------- OR0
+ *                            |    |            |
+ *                          --+----+------------+-------- OR1
+ *                            |    |            |    .
+ *                            |    |            |    .
+ *                            |    |            |    .
+ *                            |    |            |    .
+ *                          --+----+------------+-------- OR15
+ *                            |    |            |
+ *                            |    |            |
+ *
+ *	. AND Columns:
+ *		. Each AND column ANDs all 15 input signals and all 15
+ *		  complemented input signals.
+ *		. Any signal can be ignored. To ignore a signal, both the
+ *		  signal and it's complement must be set.
+ *	        . An AND column will be true (1) when all it's selected input
+ *		  signals are 1.
+ *
+ *     . OR rows:
+ *	        . Each OR row must be configured to select one of the AND
+ *		  columns.
+ *		. The OR row that is true (it's configured AND column is true)
+ *		  determines the new fsm state. If OR row 4 is true, the fsm
+ *		  transitions to state 4.
+ *		. The OR rows are prioritized with row 0 having the highest
+ *		  priority and row 15 the lowest. This means if both row 3 and
+ *		  row 4 are true, the fsm will transition to state 3.
+ *
+ * Data fifos:
+ *      . The 72-bits of potential capture data is split into two 36-bit halves.
+ *	. Capture of each half can be controlled by either a single FSM or by a
+ *	  combination of both FSM outputs.
+ *	. Captured data is in the form of 38-bit-wide capture entries.
+ */
+
+
+#ifndef __CVMX_OCLA_H__
+#define __CVMX_OCLA_H__
+
+
+#define MAX_70XX_OCLA_COMPLEXES	1
+#define MAX_78XX_OCLA_COMPLEXES	5
+#define MAX_COMPLEXES		MAX_78XX_OCLA_COMPLEXES
+
+
+/**
+ * Supported DTX blocks.
+ */
+typedef enum {
+	AGL,
+	ASE,
+	BGX,
+	CIU,
+	DFA,
+	DPI,
+	FPA,
+	GMX,
+	GSER,
+	HNA,
+	ILA,
+	ILK,
+	IOBN,
+	IOBP,
+	IOB,
+	IPD,
+	L2C_CBC,
+	L2C_MCI,
+	L2C_TAD,
+	LAP,
+	LBK,
+	LMC,
+	MIO,
+	OCX_LNK,
+	OCX_OLE,
+	OCX_TOP,
+	OSM,
+	PCS,
+	PEM,
+	PIP,
+	PKI_PBE,
+	PKI_PFE,
+	PKI_PIX,
+	PKO,
+	POW,
+	RAD,
+	RNM,
+	RST,
+	SATA,
+	SLI,
+	SSO,
+	TIM,
+	USBH,
+	USBDRD,
+	ZIP,
+	INVALID_BLOCK_ID = -1
+} cvmx_dtx_id_t;
+
+/**
+ *  DTX definition.
+ *
+ *  half:	36-bit debug bus half used by this DTX.
+ *  id:		ID of DTX block to configure.
+ *  inst:	DTX block instance to configure.
+ *  sel:	One of the hardware hardcoded values to select which signals
+ *		will be put on the debug bus.
+ *  ena:	36-bit mask to enable the bits to drive the debug bus.
+ */
+typedef struct {
+	uint			half;
+	cvmx_dtx_id_t		id;
+	uint			inst;
+	uint64_t		sel;
+	uint64_t		ena;
+} cvmx_dtx_def_t;
+
+/**
+ * Capture request.
+ *
+ *  node:			Node to capture data on.
+ *  ix:				Ocla complex index.
+ */
+struct cap_req {
+	uint			node;
+	uint			ix;
+};
+
+/* Ioctl commands */
+#define OCLA_CAP_REQ		_IOW('o', 0x01, struct cap_req)
+
+/**
+ * Selects what causes data to be captured.
+ *
+ *  NO_CAP		No data is captured.
+ *  FSM0_CAP		Capture when fsm0 requests it.
+ *  FSM1_CAP		Capture when fsm1 requests it.
+ *  FSM0_OR_FSM1	Capture when fsm0 or fsm1 request it.
+ *  FSM0_AND_FSM1	Capture when fsm0 and fsm1 request it.
+ *  CAP			Always capture.
+ */
+typedef enum {
+	NO_CAP = 0,
+	FSM0_CAP = 2,
+	FSM1_CAP = 4,
+	FSM0_OR_FSM1 = 6,
+	FSM0_AND_FSM1 = 8,
+	CAP = 0xf
+} cvmx_cap_sel_t;
+
+/**
+ * Describe a fsm input.
+ *
+ *  msk			Bit mask.
+ *  val			Bit values
+ */
+typedef struct {
+	uint8_t		msk;
+	uint8_t		val;
+} cvmx_fsm_input_t;
+
+/**
+ * Bit mask of actions to take by fsm states.
+ *
+ *  NO_ACTION		Do nothing.
+ *  ACTION_CAP		Capture.
+ *  ACTION_INT		Generate an interrupt.
+ */
+typedef enum {
+	NO_ACTION 	= 0,
+	ACTION_CAP	= 1,
+	ACTION_INT	= 2
+} cvmx_fsm_action_t;
+
+/**
+ * Disable all DTXs on all nodes.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+extern int cvmx_dtx_reset(void);
+
+/**
+ * Setup the Debug Transmitters (DTX) hardware.
+ *
+ * @param node		Node to enable dtx on.
+ * @param dtx		Pointer to DTX configuration to enable.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+extern int cvmx_dtx_enable(int node, cvmx_dtx_def_t *dtx);
+
+/**
+ * Disable a DTX.
+ *
+ * @param node		Node to disable dtx on.
+ * @param dtx		Pointer to DTX to disable.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+extern int cvmx_dtx_disable(int node, cvmx_dtx_def_t *dtx);
+
+/**
+ * Reset the OCLA hardware.
+ *
+ * @param node		Node ocla complex is on.
+ * @param ix		OCLA complex to reset.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+extern int cvmx_ocla_reset(int node, int ix);
+
+/**
+ * Clear the OCLA interrupts.
+ *
+ * @param node		Node ocla complex is on.
+ * @param ix		OCLA complex whose interrupts are to be cleared.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+extern int cvmx_ocla_clear_interrupts(int node, int ix);
+
+/**
+ * Disable the OCLA hardware.
+ *
+ * @param node		Node ocla complex is on.
+ * @param ix		OCLA complex to disable.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+extern int cvmx_ocla_disable(int node, int ix);
+
+/**
+ * Initialize the OCLA hardware.
+ *
+ * @param node		Node ocla complex is on.
+ * @param ix		OCLA complex to initialize.
+ * @param num_entries	Number of entries to capture. Zero for wrapping mode.
+ * @param lo_cap	Selects when to capture the lower 36-bit debug bus half.
+ * @param hi_cap	Selects when to capture the upper 36-bit debug bus half.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+extern int cvmx_ocla_init(int node, int ix, int num_entries,
+			  cvmx_cap_sel_t lo_cap, cvmx_cap_sel_t hi_cap);
+
+/**
+ * Initialize the OCLA matchers hardware.
+ *
+ * @param node		Node matcher is on.
+ * @param ix		OCLA complex to initialize.
+ * @param mat		Matcher to initialize.
+ * @param lo_mask	Mask for the lower 36-bit debug bus half.
+ * @param lo_val	Value to match in the lower 36-bit debug bus half.
+ * @param hi_mask	Mask for the upper 36-bit debug bus half.
+ * @param hi_val	Value to match in the upper 36-bit debug bus half.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+extern int cvmx_matcher_init(int node, int ix, int mat, uint64_t lo_mask,
+			     uint64_t lo_val, uint64_t hi_mask,
+			     uint64_t hi_val);
+
+/**
+ * Initialize the OCLA finite state machine hardware.
+ *
+ * @param node		Node fsm is on.
+ * @param ix		OCLA complex to initialize.
+ * @param fsm		Fsm to initialize.
+ * @param mcd		MCD inputs to use.
+ * @param matcher	Matcher inputs to use.
+ * @param fsm0_st	Fsm0 state to use as input.
+ * @param fsm1_st	Fsm1 state to use as input.
+ * @param new_st	State to transtion to when all inputs are true.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+extern int cvmx_fsm_init(int node, int ix, int fsm, cvmx_fsm_input_t *mcd,
+			 cvmx_fsm_input_t *matcher, cvmx_fsm_input_t *fsm0_st,
+			 cvmx_fsm_input_t *fsm1_st, uint new_st);
+
+/**
+ * Enable a fsm.
+ *
+ * @param node		Node fsm is on.
+ * @param ix		OCLA complex fsm is on.
+ * @param fsm		Fsm to enable.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+extern int cvmx_fsm_enable(int node, int ix, int fsm);
+
+/**
+ * Set the action to take for a fsm state.
+ *
+ * @param node		Node fsm is on.
+ * @param ix		OCLA complex fsm is on.
+ * @param fsm		Fsm to initialize.
+ * @param state		State to assign action to.
+ * @param action	Action for the fsm state.
+ * 
+ * @return Returned value. Zero on success, -1 otherwise.
+ */
+extern int cvmx_fsm_state_set(int node, int ix, int fsm, uint state,
+			      cvmx_fsm_action_t action);
+
+/**
+ * Read a packet from the fifo.
+ *
+ * @param node		Node ocla complex is on.
+ * @param ix		OCLA complex to read from.
+ * @param data		Updated with packet read.
+ * 
+ * @return Returned value. Zero if packet is valid, -1 otherwise.
+ */
+extern int cvmx_ocla_get_packet(int node, int ix, uint64_t *data);
+
+/**
+ * Check if the ocla fifo is full.
+ *
+ * @param node		Node ocla complex is on.
+ * @param ix		OCLA complex whose fifo is to be checked.
+ * 
+ * @return Returned value. Zero if fifo is not full, 1 if it's full.
+ */
+extern int cvmx_is_fifo_full(int node, int ix);
+
+#endif /* __CVMX_OCLA_H__ */
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index ca307c3..b3835e6 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -612,5 +612,18 @@ config TILE_SROM
 	  device appear much like a simple EEPROM, and knows
 	  how to partition a single ROM for multiple purposes.
 
+config OCTEON_OCLA
+	tristate "Octeon On Chip Logic Analizer"
+	depends on CAVIUM_OCTEON_SOC
+	default n
+	---help---
+	  This driver provides kernel-side support for the On Chip Logic
+	  Analizer found on Cavium Networks CN70XX and CN78XX SOCs.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called octeon-ocla.
+
+	  If unsure, say N.
+
 endmenu
 
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index ffebabf..952edb0 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -63,3 +63,4 @@ obj-$(CONFIG_JS_RTC)		+= js-rtc.o
 js-rtc-y = rtc.o
 
 obj-$(CONFIG_TILE_SROM)		+= tile-srom.o
+obj-$(CONFIG_OCTEON_OCLA)	+= octeon-ocla.o
diff --git a/drivers/char/octeon-ocla.c b/drivers/char/octeon-ocla.c
new file mode 100644
index 0000000..4e071ee
--- /dev/null
+++ b/drivers/char/octeon-ocla.c
@@ -0,0 +1,503 @@
+/*************************************************************************
+ *
+ * Author: Cavium Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2010 - 2014 Cavium, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium, Inc. for more information
+ *************************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/semaphore.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/interrupt.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-ocla.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Carlos Munoz <cmunoz@caviumnetworks.com>");
+MODULE_DESCRIPTION("Octeon On Chip Logig Analizer driver");
+MODULE_SUPPORTED_DEVICE("cn70xx/cn78xx");
+
+
+/* Dynamic allocation of the major device number */
+#define OCLA_MAJOR		0
+
+#define DEVICE_NAME		"octeon-ocla"
+#define MAX_OCLA_IRQS		2
+
+
+/* Ocla comlex states */
+enum {
+	COMPLEX_INVALID,
+	COMPLEX_FREE,
+	COMPLEX_IN_USE
+};
+
+/*
+ * irq_info:			Contains the information needed to handle irqs.
+ *
+ *  irq:			Virtual irq number.
+ *  en:				Irq state: 1=enabled, 0=disabled.
+ */
+struct irq_info {
+	int			irq;
+	int			en;
+};
+
+/*
+ * ocla_complex:		Information needed to manage each ocla complex.
+ *
+ *  node:			Node the ocla complex is on.
+ *  ix:				Ocla complex index.
+ *  state:			Current ocla complex state.
+ *  data_avail:			Indicates capture data is available. Set to 1 by
+ *				the interrupt handler. Set to 0 by the read
+ *				method when all entries have been read.
+ *  waitq:			Wait queue to support blocking io.
+ *  pdev:			Pointer to platform device structure for this
+ *				ocla complex.
+ *  irqs:			IRQs used by this ocla complex.
+ *  lock:			Spin lock.
+ */
+struct ocla_complex {
+	int			node;
+	int			ix;
+	int			state;
+	int			data_avail;
+	wait_queue_head_t	waitq;
+	struct platform_device	*pdev;
+	spinlock_t		lock;
+	struct irq_info		irqs[MAX_OCLA_IRQS];
+};
+
+
+static int ocla_major = OCLA_MAJOR;
+static DEFINE_SEMAPHORE(complexes_sem);
+static struct ocla_complex ocla_complexes[CVMX_MAX_NODES][MAX_COMPLEXES] = {
+	{ {.state = COMPLEX_INVALID}, {.state = COMPLEX_INVALID},
+	  {.state = COMPLEX_INVALID}, {.state = COMPLEX_INVALID},
+	  {.state = COMPLEX_INVALID} },
+	{ {.state = COMPLEX_INVALID}, {.state = COMPLEX_INVALID},
+	  {.state = COMPLEX_INVALID}, {.state = COMPLEX_INVALID},
+	  {.state = COMPLEX_INVALID} }
+};
+
+/*
+ * Process ocla interrutps.
+ * To mitigate interrupt overhead an approach similar to the one use by NAPI is
+ * implemented:
+ * 	. Readers enable the ocla interrupts and block waiting for captured
+ *	  entries.
+ *	. The interrupt handler is invoked when there's captured data. It
+ *	  disables the interrupt and wakes up any blocked readers.
+ *	. The readers read all entries. Enable the ocla interrupts and block
+ *	  again.
+ *
+ *  irq:			Interrupt to process.
+ *  dev_id:			Pointer to ocla complex.
+ *
+ *  returns:			Indication interrupt was handled.
+ */
+static irqreturn_t  ocla_irq_handler(int	irq,
+				     void	*dev_id)
+{
+	struct ocla_complex	*complex = dev_id;
+	unsigned long		flags;
+	int			i;
+
+	/* Clear the interrupts */
+	cvmx_ocla_clear_interrupts(complex->node, complex->ix);
+
+	/* Disable the irq */
+	spin_lock_irqsave(&complex->lock, flags);
+	disable_irq_nosync(irq);
+	for (i = 0; i < MAX_OCLA_IRQS; i++) {
+		if (irq == complex->irqs[i].irq) {
+			complex->irqs[i].en = 0;
+			break;
+		}
+	}
+	complex->data_avail = 1;
+	spin_unlock_irqrestore(&complex->lock, flags);
+
+	wake_up_interruptible(&complex->waitq);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Read captured entries.
+ * To mitigate interrupt overhead an approach similar to the one use by NAPI is
+ * implemented:
+ * 	. Readers enable the ocla interrupts and block waiting for captured
+ *	  entries.
+ *	. The interrupt handler is invoked when there's captured data. It
+ *	  disables the interrupt and wakes up any blocked readers.
+ *	. The readers read all entries, enable interrupts again when there
+ *	  are no more entries to read, and block waiting for new enties.
+ *
+ *  file:			Pointer to file structure.
+ *  buf:			Buffer to fill with the captured entries.
+ *  count:			Size of buf.
+ *  off:			File offset. Updated with amount of data read.
+ *
+ *  returns:			Number of bytes read, or error.
+ */
+static ssize_t ocla_read(struct file *file, char __user *buf, size_t count,
+			 loff_t *off)
+{
+	struct ocla_complex	*complex;
+	ssize_t			read_cnt = 0;
+	unsigned long		flags;
+	uint64_t		data;
+	int			node;
+	int			ix;
+	int			i;
+
+	complex = (struct ocla_complex *)file->private_data;
+
+	if (count < 8)
+		return -EINVAL;
+
+	if (complex == NULL) {
+		printk(KERN_ERR "OCLA: Capture is not enabled\n");
+		return -EPERM;
+	}
+
+	node = complex->node;
+	ix = complex->ix;
+
+	/* Block if no data is available */
+	if (!complex->data_avail) {
+		/* No data available, enable interrupts and wait */
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		spin_lock_irqsave(&complex->lock, flags);
+		for (i = 0; i < MAX_OCLA_IRQS; i++) {
+			if (!complex->irqs[i].en) {
+				enable_irq(complex->irqs[i].irq);
+				complex->irqs[i].en = 1;
+			}
+		}
+		spin_unlock_irqrestore(&complex->lock, flags);
+
+		if (wait_event_interruptible(complex->waitq,
+					     complex->data_avail == 1))
+			return -ERESTARTSYS;
+	}
+
+	/* Indicate data is not available before trying to empty the fifo */
+	complex->data_avail = 0;
+
+	/* Try to read as many entries as possible */
+	while (read_cnt <= count - 8) {
+		if (cvmx_ocla_get_packet(node, ix, &data) < 0)
+			break;
+		if (copy_to_user(buf + read_cnt, (char *)&data, 8))
+			return -EFAULT;
+		read_cnt += 8;
+	}
+
+	/* Indicate data is available if the fifo is not yet empty */
+	if (read_cnt)
+		complex->data_avail = 1;
+
+	*off += read_cnt;
+	/* If the buffer is full, we've reached the end of file */
+	if (!read_cnt && cvmx_is_fifo_full(node, ix))
+		read_cnt = -ENOSPC;
+
+	return read_cnt;
+}
+
+/*
+ * Process a capture request.
+ *
+ *  file:			Pointer to file structure.
+ *  req:			Capture request.
+ *
+ *  returns:			0 on success, error otherwise.
+ */
+static long ioctl_cap_req(struct file		*file,
+			  struct cap_req	*req)
+{
+	struct ocla_complex	*complex;
+
+	/* Verify arguments */
+	if (req->node >= CVMX_MAX_NODES || req->ix >= MAX_COMPLEXES)
+		return -EINVAL;
+
+	/* Make sure complex is available */
+	complex = &ocla_complexes[req->node][req->ix];
+	if (complex->state != COMPLEX_FREE)
+		return -EINVAL;
+
+	complex->state = COMPLEX_IN_USE;
+	file->private_data = complex;
+
+	return 0;
+}
+
+/*
+ * Process ioctl commands.
+ *
+ *  file:			Pointer to file structure.
+ *  cmd:			Ioctl command.
+ *  arg:			Ioctl command argument.
+ *
+ *  returns:			0 on success, error otherwise.
+ */
+static long ocla_ioctl(struct file	*file,
+		       unsigned int 	cmd,
+		       unsigned long	arg)
+{
+	struct cap_req	req;
+	long		rc = 0;
+
+	switch (cmd) {
+	case OCLA_CAP_REQ:
+		if (copy_from_user(&req, (void __user *)arg, sizeof(req)))
+			return -EFAULT;
+
+		rc = ioctl_cap_req(file, &req);
+		break;
+
+	default:
+		printk(KERN_ERR "OCLA: Invalid ioctl cmd [%x]\n", cmd);
+		rc = -EINVAL;
+		break;
+	}
+
+	return rc;
+}
+
+/*
+ * Open file request.
+ *
+ *  inode:			Pointer to inode structure.
+ *  file:			Pointer to file structure.
+ *
+ *  returns:			0 on success, error otherwise.
+ */
+static int ocla_open(struct inode	*inode,
+		     struct file	*file)
+{
+	/* No ocla complex currently in use */
+	file->private_data = NULL;
+
+	return 0;
+}
+
+/*
+ * Close file request.
+ *
+ *  inode:			Pointer to inode structure.
+ *  file:			Pointer to file structure.
+ *
+ *  returns:			0 on success, error otherwise.
+ */
+static int ocla_release(struct inode *inode, struct file *file)
+{
+	struct ocla_complex	*complex;
+	unsigned long		flags;
+
+	complex = (struct ocla_complex *)file->private_data;
+
+	if (complex) {
+		int	i;
+
+		/* Disable the interrupts */
+		spin_lock_irqsave(&complex->lock, flags);
+		for (i = 0; i < MAX_OCLA_IRQS; i++) {
+			if (complex->irqs[i].en) {
+				disable_irq(complex->irqs[i].irq);
+				complex->irqs[i].en = 0;
+			}
+		}
+		complex->data_avail = 0;
+		spin_unlock_irqrestore(&complex->lock, flags);
+
+		complex->state = COMPLEX_FREE;
+	}
+
+	return 0;
+}
+
+/*
+ * Probe the ocla complex specified in pdev.
+ *
+ *  pdev:			Pointer to platform_device structure.
+ *
+ *  returns:			0 on success, error otherwise.
+ */
+static int __init ocla_probe(struct platform_device *pdev)
+{
+	struct ocla_complex	*complex;
+	const __be32		*zero_addr;
+	const u32		*reg;
+	u64			base_addr;
+	int			node;
+	int			ix;
+	struct resource		*res;
+	int			irq;
+	unsigned long		flags;
+	int			i;
+	int			j;
+	int			rc = -1;
+
+	/* Get the node this complex is on */
+	zero_addr = of_get_address(pdev->dev.of_node, 0, NULL, NULL);
+	base_addr = of_translate_address(pdev->dev.of_node, zero_addr);
+	base_addr = (u64)phys_to_virt(base_addr);
+	node = (base_addr >> 36) & 3;
+
+	/* Get the index of the ocla complex being initialized */
+	reg = of_get_property(pdev->dev.of_node, "reg", NULL);
+	if (!reg) {
+		printk(KERN_ERR "ocla: No 'reg' property, aborting\n");
+		return -ENODEV;
+	}
+	ix = (reg[1] >> 24) & 7;
+
+	/* Initialize the ocla complex information */
+	complex = &ocla_complexes[node][ix];
+	platform_set_drvdata(pdev, complex);
+	complex->node = node;
+	complex->ix = ix;
+	complex->state = COMPLEX_FREE;
+	complex->data_avail = 0;
+	init_waitqueue_head(&complex->waitq);
+	complex->pdev = pdev;
+	spin_lock_init(&complex->lock);
+
+	/* Register the interrupt handlers */
+	for (i = 0; i < pdev->num_resources; i++) {
+		if ((res = platform_get_resource(pdev, IORESOURCE_IRQ, i))) {
+			irq = irq_of_parse_and_map(pdev->dev.of_node, i);
+			if (irq) {
+				if ((rc = request_irq(irq, ocla_irq_handler, 0,
+						      DEVICE_NAME, complex))) {
+					printk(KERN_ERR "ocla: failed to "
+					       "request irq\n");
+					for (j = 0; j < i; j++)
+						free_irq(complex->irqs[j].irq,
+							 complex);
+					return rc;
+				}
+				complex->irqs[i].irq = irq;
+
+				/*
+				 * Interrupts are disabled until we have a
+				 * reader. The reader will enable interrupts
+				 * before blocking.
+				 */
+				spin_lock_irqsave(&complex->lock, flags);
+				disable_irq(irq);
+				complex->irqs[i].en = 0;
+				spin_unlock_irqrestore(&complex->lock, flags);
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Remove ocla complex specified in pdev.
+ *
+ *  pdev:			Pointer to platform_device structure.
+ *
+ *  returns:			0 on success, error otherwise.
+ */
+static int __exit ocla_remove(struct platform_device *pdev)
+{
+	struct ocla_complex	*complex;
+	int			i;
+
+	complex = platform_get_drvdata(pdev);
+	for (i = 0; i < MAX_OCLA_IRQS; i++)
+		free_irq(complex->irqs[i].irq, complex);
+
+	return 0;
+}
+
+static const struct file_operations ocla_fops = {
+	.open		= ocla_open,
+	.unlocked_ioctl = ocla_ioctl,
+	.read		= ocla_read,
+	.release	= ocla_release,
+};
+
+static const struct of_device_id ocla_of_match_table[] = {
+        { .compatible = "cavium,octeon-7xxx-ocla", },
+        {}
+};
+
+static struct platform_driver ocla_driver = {
+        .probe          = ocla_probe,
+        .remove         = ocla_remove,
+        .driver         = {
+                .owner  = THIS_MODULE,
+                .name   = "ocla",
+                .of_match_table = ocla_of_match_table,
+        },
+};
+
+static int __init ocla_init(void)
+{
+	int	rc;
+
+	/* Register the platform driver */
+	if ((rc = platform_driver_register(&ocla_driver))) {
+		printk(KERN_ERR "ocla: failed to register platform driver\n");
+		return rc;
+	}
+
+	/* Register the character device */
+	if ((rc = register_chrdev(ocla_major, DEVICE_NAME, &ocla_fops)) < 0) {
+		printk(KERN_ERR "ocla: can't register major %d\n", ocla_major);
+		platform_driver_unregister(&ocla_driver);
+		return rc;
+	}
+	if (!ocla_major)
+		ocla_major = rc;
+
+        return 0;
+}
+
+static void __exit ocla_exit(void)
+{
+        platform_driver_unregister(&ocla_driver);
+	unregister_chrdev(ocla_major, DEVICE_NAME);
+}
+
+module_init(ocla_init);
+module_exit(ocla_exit);
-- 
1.8.2.1

