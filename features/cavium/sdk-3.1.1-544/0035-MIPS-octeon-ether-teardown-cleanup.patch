From 348d76403710f7de187c9589bd1e85269eebbfc8 Mon Sep 17 00:00:00 2001
From: Peter Swain <peter.swain@cavium.com>
Date: Sat, 1 Mar 2014 04:36:15 -0800
Subject: [PATCH 035/202] MIPS: octeon-ether teardown cleanup

On ifdown/rmmod some species of octeon-ethernet were missing tasklet
teardown, others were leaking memory ...

SPI4000 had _no_ ndo_stop entry, now uses cvm_oct_common_stop()

cvm_oct_common_stop() now does phy_disconnect() if phydev != NULL,
so RGMII & SPI4000 teardown paths both get this.  SGMII had it already,
but it's no longer explicit, inherited via _common_stop().

Teardown on octeon_mgmt_stop() & failed octeon_mgmt_open() was inconsistent.
Now octeon_mgmt_open() failures call octeon_mgmt_stop(), which unwinds
everything in inverse order, NULL-guarded for partial-teardown case.

octeon_mgmt_probe() / octeon_mgmt_remove() are now balanced:
- tasklet is killed, avoiding crash on rmmod
- regions are iounmap()d & released so module can be re-inserted without clash

Signed-off-by: Peter Swain <peter.swain@cavium.com>
[Original patch taken from Cavium SDK 3.1.1-544]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/octeon/ethernet-mdio.c  |   6 ++
 drivers/net/ethernet/octeon/ethernet-rgmii.c |   2 +-
 drivers/net/ethernet/octeon/ethernet-sgmii.c |   6 --
 drivers/net/ethernet/octeon/ethernet.c       |   1 +
 drivers/net/ethernet/octeon/octeon_mgmt.c    | 150 +++++++++++++++------------
 5 files changed, 94 insertions(+), 71 deletions(-)

diff --git a/drivers/net/ethernet/octeon/ethernet-mdio.c b/drivers/net/ethernet/octeon/ethernet-mdio.c
index 661c6e8..d31a1a9 100644
--- a/drivers/net/ethernet/octeon/ethernet-mdio.c
+++ b/drivers/net/ethernet/octeon/ethernet-mdio.c
@@ -362,6 +362,12 @@ int cvm_oct_common_stop(struct net_device *dev)
 	struct octeon_ethernet *priv = netdev_priv(dev);
 	cvmx_helper_link_info_t link_info;
 
+	priv->poll = NULL;
+
+	if (priv->phydev)
+		phy_disconnect(priv->phydev);
+	priv->phydev = NULL;
+
 	if (priv->last_link) {
 		link_info.u64 = 0;
 		priv->last_link = 0;
diff --git a/drivers/net/ethernet/octeon/ethernet-rgmii.c b/drivers/net/ethernet/octeon/ethernet-rgmii.c
index ffd0e71..a88dcd6 100644
--- a/drivers/net/ethernet/octeon/ethernet-rgmii.c
+++ b/drivers/net/ethernet/octeon/ethernet-rgmii.c
@@ -280,7 +280,7 @@ int cvm_oct_rgmii_stop(struct net_device *dev)
 	cvmx_write_csr(CVMX_IPD_SUB_PORT_FCS, ipd_sub_port_fcs.u64);
 	priv->rx_strip_fcs = 0;
 
-	return 0;
+	return cvm_oct_common_stop(dev);
 }
 
 int cvm_oct_rgmii_init(struct net_device *dev)
diff --git a/drivers/net/ethernet/octeon/ethernet-sgmii.c b/drivers/net/ethernet/octeon/ethernet-sgmii.c
index 199613a..c214703 100644
--- a/drivers/net/ethernet/octeon/ethernet-sgmii.c
+++ b/drivers/net/ethernet/octeon/ethernet-sgmii.c
@@ -197,12 +197,6 @@ int cvm_oct_sgmii_stop(struct net_device *dev)
 		priv->hw_status_notifier.notifier_call = NULL;
 	}
 
-	priv->poll = NULL;
-
-	if (priv->phydev)
-		phy_disconnect(priv->phydev);
-	priv->phydev = NULL;
-
 	return cvm_oct_common_stop(dev);
 }
 
diff --git a/drivers/net/ethernet/octeon/ethernet.c b/drivers/net/ethernet/octeon/ethernet.c
index 5111ffb..aeeced0 100644
--- a/drivers/net/ethernet/octeon/ethernet.c
+++ b/drivers/net/ethernet/octeon/ethernet.c
@@ -612,6 +612,7 @@ static const struct net_device_ops cvm_oct_spi_netdev_ops = {
 	.ndo_init		= cvm_oct_spi_init,
 	.ndo_uninit		= cvm_oct_spi_uninit,
 	.ndo_open		= cvm_oct_phy_setup_device,
+	.ndo_stop		= cvm_oct_common_stop,
 	.ndo_start_xmit		= cvm_oct_xmit,
 	.ndo_set_rx_mode	= cvm_oct_set_rx_filter,
 	.ndo_set_mac_address	= cvm_oct_set_mac_address,
diff --git a/drivers/net/ethernet/octeon/octeon_mgmt.c b/drivers/net/ethernet/octeon/octeon_mgmt.c
index 645fbfe..b682136 100644
--- a/drivers/net/ethernet/octeon/octeon_mgmt.c
+++ b/drivers/net/ethernet/octeon/octeon_mgmt.c
@@ -750,6 +750,9 @@ static void octeon_mgmt_update_link(struct octeon_mgmt *p)
 
 	prtx_cfg.u64 = cvmx_read_csr(p->agl + AGL_GMX_PRT_CFG);
 
+	if (!p->phydev)
+		return;
+
 	if (!p->phydev->link)
 		prtx_cfg.s.duplex = 1;
 	else
@@ -876,6 +879,45 @@ static int octeon_mgmt_init_phy(struct net_device *netdev)
 	return 0;
 }
 
+static int octeon_mgmt_stop(struct net_device *netdev)
+{
+	struct octeon_mgmt *p = netdev_priv(netdev);
+
+	napi_disable(&p->napi);
+	netif_stop_queue(netdev);
+
+	if (p->phydev)
+		phy_disconnect(p->phydev);
+	p->phydev = NULL;
+
+	netif_carrier_off(netdev);
+
+	octeon_mgmt_reset_hw(p);
+
+	if (p->irq)
+		free_irq(p->irq, netdev);
+
+	/* dma_unmap is a nop on Octeon, so just free everything.  */
+	skb_queue_purge(&p->tx_list);
+	skb_queue_purge(&p->rx_list);
+
+	if (p->rx_ring_handle)
+		dma_unmap_single(p->dev, p->rx_ring_handle,
+				 ring_size_to_bytes(OCTEON_MGMT_RX_RING_SIZE),
+				 DMA_BIDIRECTIONAL);
+	if (p->rx_ring)
+		kfree(p->rx_ring);
+
+	if (p->tx_ring_handle)
+		dma_unmap_single(p->dev, p->tx_ring_handle,
+				 ring_size_to_bytes(OCTEON_MGMT_TX_RING_SIZE),
+				 DMA_BIDIRECTIONAL);
+	if (p->tx_ring)
+		kfree(p->tx_ring);
+
+	return 0;
+}
+
 static int octeon_mgmt_open(struct net_device *netdev)
 {
 	struct octeon_mgmt *p = netdev_priv(netdev);
@@ -1133,54 +1175,13 @@ static int octeon_mgmt_open(struct net_device *netdev)
 	napi_enable(&p->napi);
 
 	return 0;
+
 err_noirq:
-	octeon_mgmt_reset_hw(p);
-	dma_unmap_single(p->dev, p->rx_ring_handle,
-			 ring_size_to_bytes(OCTEON_MGMT_RX_RING_SIZE),
-			 DMA_BIDIRECTIONAL);
-	kfree(p->rx_ring);
 err_nomem:
-	dma_unmap_single(p->dev, p->tx_ring_handle,
-			 ring_size_to_bytes(OCTEON_MGMT_TX_RING_SIZE),
-			 DMA_BIDIRECTIONAL);
-	kfree(p->tx_ring);
+	octeon_mgmt_stop(netdev);
 	return -ENOMEM;
 }
 
-static int octeon_mgmt_stop(struct net_device *netdev)
-{
-	struct octeon_mgmt *p = netdev_priv(netdev);
-
-	napi_disable(&p->napi);
-	netif_stop_queue(netdev);
-
-	if (p->phydev)
-		phy_disconnect(p->phydev);
-	p->phydev = NULL;
-
-	netif_carrier_off(netdev);
-
-	octeon_mgmt_reset_hw(p);
-
-	free_irq(p->irq, netdev);
-
-	/* dma_unmap is a nop on Octeon, so just free everything.  */
-	skb_queue_purge(&p->tx_list);
-	skb_queue_purge(&p->rx_list);
-
-	dma_unmap_single(p->dev, p->rx_ring_handle,
-			 ring_size_to_bytes(OCTEON_MGMT_RX_RING_SIZE),
-			 DMA_BIDIRECTIONAL);
-	kfree(p->rx_ring);
-
-	dma_unmap_single(p->dev, p->tx_ring_handle,
-			 ring_size_to_bytes(OCTEON_MGMT_TX_RING_SIZE),
-			 DMA_BIDIRECTIONAL);
-	kfree(p->tx_ring);
-
-	return 0;
-}
-
 static int octeon_mgmt_xmit(struct sk_buff *skb, struct net_device *netdev)
 {
 	struct octeon_mgmt *p = netdev_priv(netdev);
@@ -1319,6 +1320,37 @@ static const struct net_device_ops octeon_mgmt_ops = {
 #endif
 };
 
+static int octeon_mgmt_remove(struct platform_device *pdev)
+{
+	struct net_device *netdev = dev_get_drvdata(&pdev->dev);
+	struct octeon_mgmt *p = netdev_priv(netdev);
+
+	if (p->napi.dev)
+		netif_napi_del(&p->napi);
+	tasklet_kill(&p->tx_clean_tasklet);
+	unregister_netdev(netdev);
+	dev_set_drvdata(&pdev->dev, NULL);
+	free_netdev(netdev);
+
+	if (p->agl_prt_ctl)
+		devm_iounmap(&pdev->dev,
+			(void __iomem *)p->agl_prt_ctl);
+	if (p->agl_prt_ctl_phys)
+		devm_release_region(&pdev->dev,
+			p->agl_prt_ctl_phys, p->agl_prt_ctl_size);
+	if (p->agl)
+		devm_iounmap(&pdev->dev,
+			(void __iomem *)p->agl);
+	if (p->agl_phys)
+		devm_release_region(&pdev->dev, p->agl_phys, p->agl_size);
+	if (p->mix)
+		devm_iounmap(&pdev->dev,
+			(void __iomem *)p->mix);
+	if (p->mix_phys)
+		devm_release_region(&pdev->dev, p->mix_phys, p->mix_size);
+	return 0;
+}
+
 static int octeon_mgmt_probe(struct platform_device *pdev)
 {
 	struct net_device *netdev;
@@ -1362,55 +1394,54 @@ static int octeon_mgmt_probe(struct platform_device *pdev)
 		goto err;
 
 	p->irq = result;
+	result = -ENXIO; /* default err from here down */
 
 	res_mix = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res_mix == NULL) {
 		dev_err(&pdev->dev, "no 'reg' resource\n");
-		result = -ENXIO;
 		goto err;
 	}
 
 	res_agl = platform_get_resource(pdev, IORESOURCE_MEM, 1);
 	if (res_agl == NULL) {
 		dev_err(&pdev->dev, "no 'reg' resource\n");
-		result = -ENXIO;
 		goto err;
 	}
 
 	res_agl_prt_ctl = platform_get_resource(pdev, IORESOURCE_MEM, 3);
 	if (res_agl_prt_ctl == NULL) {
 		dev_err(&pdev->dev, "no 'reg' resource\n");
-		result = -ENXIO;
 		goto err;
 	}
 
 	p->mix_phys = res_mix->start;
 	p->mix_size = resource_size(res_mix);
-	p->agl_phys = res_agl->start;
-	p->agl_size = resource_size(res_agl);
-	p->agl_prt_ctl_phys = res_agl_prt_ctl->start;
-	p->agl_prt_ctl_size = resource_size(res_agl_prt_ctl);
-
 
 	if (!devm_request_mem_region(&pdev->dev, p->mix_phys, p->mix_size,
 				     res_mix->name)) {
+		p->mix_phys = 0;
 		dev_err(&pdev->dev, "request_mem_region (%s) failed\n",
 			res_mix->name);
-		result = -ENXIO;
 		goto err;
 	}
 
+	p->agl_phys = res_agl->start;
+	p->agl_size = resource_size(res_agl);
+
 	if (!devm_request_mem_region(&pdev->dev, p->agl_phys, p->agl_size,
 				     res_agl->name)) {
-		result = -ENXIO;
+		p->agl_phys = 0;
 		dev_err(&pdev->dev, "request_mem_region (%s) failed\n",
 			res_agl->name);
 		goto err;
 	}
 
+	p->agl_prt_ctl_phys = res_agl_prt_ctl->start;
+	p->agl_prt_ctl_size = resource_size(res_agl_prt_ctl);
+
 	if (!devm_request_mem_region(&pdev->dev, p->agl_prt_ctl_phys,
 				     p->agl_prt_ctl_size, res_agl_prt_ctl->name)) {
-		result = -ENXIO;
+		p->agl_prt_ctl_phys = 0;
 		dev_err(&pdev->dev, "request_mem_region (%s) failed\n",
 			res_agl_prt_ctl->name);
 		goto err;
@@ -1453,19 +1484,10 @@ static int octeon_mgmt_probe(struct platform_device *pdev)
 	return 0;
 
 err:
-	free_netdev(netdev);
+	octeon_mgmt_remove(pdev);
 	return result;
 }
 
-static int octeon_mgmt_remove(struct platform_device *pdev)
-{
-	struct net_device *netdev = dev_get_drvdata(&pdev->dev);
-
-	unregister_netdev(netdev);
-	free_netdev(netdev);
-	return 0;
-}
-
 static struct of_device_id octeon_mgmt_match[] = {
 	{
 		.compatible = "cavium,octeon-5750-mix",
-- 
1.8.2.1

