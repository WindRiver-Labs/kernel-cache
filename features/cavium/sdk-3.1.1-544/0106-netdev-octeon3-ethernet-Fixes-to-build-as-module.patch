From 3543c20e1ef87513bafae6823f9239e7f98626f2 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 13 Feb 2015 15:09:44 +0530
Subject: [PATCH 106/148] netdev: octeon3-ethernet: Fixes to build as module.

Commit 9ef59d7952126fe5aed6d74c350efa9dd8fb65e5 from
git://git.yoctoproject.org/linux-yocto-3.14

Enable MAC address filtering.

netdev: octeon-bgx-nexus: Only init port config data if probed.
Calling __cvmx_helper_init_port_config_data() if we don't have BGX/PKI
causes octeon-ethernet driver to fail.

netdev:mips: separated interface enabled from port enable
took interface enable code out from bgx_probe and added
bgx_port_init in bgx_port_probe.

netdev: octeon-bgx-nexus: Request octeon3-ethernet driver...
... but only do it once.  This gets all the drivers properly loaded
from udev probing.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Vinita Gupta <vgupta@caviumnetworks.com>
Signed-off-by: Abhishek Paliwal <abhishek.paliwal@aricent.com>
---
 drivers/net/ethernet/octeon/octeon-bgx-nexus.c | 157 +++++++
 drivers/net/ethernet/octeon/octeon-bgx-port.c  | 589 +++++++++++++++++++++++++
 2 files changed, 746 insertions(+)
 create mode 100644 drivers/net/ethernet/octeon/octeon-bgx-nexus.c
 create mode 100644 drivers/net/ethernet/octeon/octeon-bgx-port.c

diff --git a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
new file mode 100644
index 0000000..951757e
--- /dev/null
+++ b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
@@ -0,0 +1,157 @@
+/**********************************************************************
+ * Author: Cavium, Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2014 Cavium, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium, Inc. for more information
+ **********************************************************************/
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-util.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
+#include <asm/octeon/cvmx-helper-bgx.h>
+#include <asm/octeon/cvmx-bgxx-defs.h>
+
+#include "octeon-bgx.h"
+
+static atomic_t bgx_nexus_once;
+static atomic_t request_ethernet3_once;
+
+static int bgx_probe(struct platform_device *pdev)
+{
+	struct bgx_platform_data platform_data;
+	const __be32 *reg;
+	u32 port;
+	u64 addr;
+	struct device_node *child;
+	struct platform_device *new_dev;
+	struct platform_device *pki_dev;
+	static int pki_id;
+	int numa_node, interface;
+	int i;
+	int r = 0;
+	char id[64];
+
+	/* One time initialization */
+	if (atomic_cmpxchg(&bgx_nexus_once, 0, 1) == 0)
+		__cvmx_helper_init_port_config_data();
+
+	reg = of_get_property(pdev->dev.of_node, "reg", NULL);
+	addr = of_translate_address(pdev->dev.of_node, reg);
+	interface = (addr >> 24) & 0xf;
+	numa_node = (addr >> 36) & 0x7;
+
+	__cvmx_helper_bgx_probe(cvmx_helper_node_interface_to_xiface(numa_node, interface));
+
+	/* Assign 8 CAM entries per LMAC */
+	for (i = 0; i < 32; i++) {
+		union cvmx_bgxx_cmr_rx_adrx_cam adr_cam;
+		adr_cam.u64 = 0;
+		adr_cam.s.id = i >> 3;
+		cvmx_write_csr_node(numa_node, CVMX_BGXX_CMR_RX_ADRX_CAM(i, interface), adr_cam.u64);
+	}
+
+	for_each_available_child_of_node(pdev->dev.of_node, child) {
+		union cvmx_bgxx_cmrx_config cmr_config;
+		if (!of_device_is_compatible(child, "cavium,octeon-7890-bgx-port"))
+			continue;
+		r = of_property_read_u32(child, "reg", &port);
+		if (r)
+			return -ENODEV;
+
+		/* Connect to PKI/PKO */
+		cmr_config.u64 = cvmx_read_csr_node(numa_node, CVMX_BGXX_CMRX_CONFIG(port, interface));
+		cmr_config.s.mix_en = 0;
+		cvmx_write_csr_node(numa_node, CVMX_BGXX_CMRX_CONFIG(port, interface), cmr_config.u64);
+
+		snprintf(id, sizeof(id), "%llx.%u.ethernet-mac", (unsigned long long)addr, port);
+		new_dev = of_platform_device_create(child, id, &pdev->dev);
+		if (!new_dev) {
+			dev_err(&pdev->dev, "Error creating %s\n", id);
+			continue;
+		}
+		platform_data.numa_node = numa_node;
+		platform_data.interface = interface;
+		platform_data.port = port;
+
+		pki_dev = platform_device_register_data(&new_dev->dev, "ethernet-mac-pki", pki_id++,
+							&platform_data, sizeof(platform_data));
+		dev_info(&pdev->dev, "Created PKI %u: %p\n", pki_dev->id, pki_dev);
+#ifdef CONFIG_NUMA
+		new_dev->dev.numa_node = pdev->dev.numa_node;
+		pki_dev->dev.numa_node = pdev->dev.numa_node;
+#endif
+		/* One time request driver module */
+		if (atomic_cmpxchg(&request_ethernet3_once, 0, 1) == 0)
+			request_module_nowait("octeon3-ethernet");
+	}
+
+	dev_info(&pdev->dev, "Probed\n");
+	return 0;
+}
+
+static int bgx_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static void bgx_shutdown(struct platform_device *pdev)
+{
+	return;
+}
+
+static struct of_device_id bgx_match[] = {
+	{
+		.compatible = "cavium,octeon-7890-bgx",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, bgx_match);
+
+static struct platform_driver bgx_driver = {
+	.probe		= bgx_probe,
+	.remove		= bgx_remove,
+	.shutdown       = bgx_shutdown,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= KBUILD_MODNAME,
+		.of_match_table = bgx_match,
+	},
+};
+
+/* Allow bgx_port driver to force this driver to load */
+void bgx_nexus_load(void)
+{
+}
+EXPORT_SYMBOL(bgx_nexus_load);
+
+module_platform_driver(bgx_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cavium Networks <support@caviumnetworks.com>");
+MODULE_DESCRIPTION("Cavium Networks BGX MAC Nexus driver.");
diff --git a/drivers/net/ethernet/octeon/octeon-bgx-port.c b/drivers/net/ethernet/octeon/octeon-bgx-port.c
new file mode 100644
index 0000000..80b08dc
--- /dev/null
+++ b/drivers/net/ethernet/octeon/octeon-bgx-port.c
@@ -0,0 +1,589 @@
+/**********************************************************************
+ * Author: Cavium, Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2014 Cavium, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium, Inc. for more information
+ **********************************************************************/
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_mdio.h>
+#include <linux/of_net.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/if_vlan.h>
+
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-util.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
+#include <asm/octeon/cvmx-bgxx-defs.h>
+#include <asm/octeon/cvmx-helper-bgx.h>
+#include <asm/octeon/cvmx-pko3.h>
+
+#include "octeon-bgx.h"
+
+struct bgx_port_priv {
+	int numa_node;
+	int bgx_interface;
+	int index; /* Port index on BGX block*/
+	int ipd_port;
+	int xiface;
+	const u8 *mac_addr;
+	struct phy_device *phydev;
+	struct device_node *phy_np;
+	struct net_device *netdev;
+	spinlock_t lock;
+	unsigned int last_duplex;
+	unsigned int last_link;
+	unsigned int last_speed;
+	struct delayed_work dwork;
+};
+
+static struct workqueue_struct *check_state_wq;
+static DEFINE_MUTEX(check_state_wq_mutex);
+
+static struct bgx_port_priv *bgx_port_netdev2priv(struct net_device *netdev)
+{
+	struct bgx_port_netdev_priv *nd_priv = netdev_priv(netdev);
+	return nd_priv->bgx_priv;
+}
+
+void bgx_port_set_netdev(struct device *dev, struct net_device *netdev)
+{
+	struct bgx_port_netdev_priv *nd_priv = netdev_priv(netdev);
+	struct bgx_port_priv *priv = dev_get_drvdata(dev);
+	nd_priv->bgx_priv = priv;
+	priv->netdev = netdev;
+}
+EXPORT_SYMBOL(bgx_port_set_netdev);
+
+int bgx_port_ethtool_get_settings(struct net_device	*netdev,
+				  struct ethtool_cmd	*cmd)
+{
+	cvmx_helper_link_info_t link_info;
+	struct bgx_port_priv *p = bgx_port_netdev2priv(netdev);
+
+	if (p->phydev)
+		return phy_ethtool_gset(p->phydev, cmd);
+
+	link_info = cvmx_helper_link_get(p->ipd_port);
+	cmd->speed = link_info.s.link_up ? link_info.s.speed : 0;
+	cmd->duplex = link_info.s.full_duplex ? DUPLEX_FULL : DUPLEX_HALF;
+
+	return 0;
+}
+EXPORT_SYMBOL(bgx_port_ethtool_get_settings);
+
+int bgx_port_ethtool_set_settings(struct net_device	*netdev,
+				  struct ethtool_cmd	*cmd)
+{
+	struct bgx_port_priv *p = bgx_port_netdev2priv(netdev);
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (p->phydev)
+		return phy_ethtool_sset(p->phydev, cmd);
+
+	return -EOPNOTSUPP;
+}
+EXPORT_SYMBOL(bgx_port_ethtool_set_settings);
+
+int bgx_port_ethtool_nway_reset(struct net_device *netdev)
+{
+	struct bgx_port_priv *p = bgx_port_netdev2priv(netdev);
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (p->phydev)
+		return phy_start_aneg(p->phydev);
+
+	return -EOPNOTSUPP;
+}
+EXPORT_SYMBOL(bgx_port_ethtool_nway_reset);
+
+const u8 *bgx_port_get_mac(struct net_device *netdev)
+{
+	struct bgx_port_priv *priv = bgx_port_netdev2priv(netdev);
+	return priv->mac_addr;
+}
+EXPORT_SYMBOL(bgx_port_get_mac);
+
+static void bgx_port_write_cam(int numa_node, int interface, int index, int cam, const u8 *mac)
+{
+	int i;
+	union cvmx_bgxx_cmr_rx_adrx_cam adr_cam;
+	u64 m = 0;
+	if (mac)
+		for (i = 0; i < 6; i++)
+			m |= (((u64)mac[i]) << ((5 - i) * 8));
+	adr_cam.u64 = m;
+	adr_cam.s.en = mac ? 1 : 0;
+	adr_cam.s.id = index;
+	cvmx_write_csr_node(numa_node, CVMX_BGXX_CMR_RX_ADRX_CAM(index * 8 + cam, interface), adr_cam.u64);
+}
+
+/* Set MAC address for the net_device that is attached. */
+void bgx_port_set_rx_filtering(struct net_device *netdev)
+{
+	union cvmx_bgxx_cmrx_rx_adr_ctl adr_ctl;
+	struct bgx_port_priv *priv = bgx_port_netdev2priv(netdev);
+	int available_cam_entries, current_cam_entry;
+	struct netdev_hw_addr *ha;
+
+	available_cam_entries = 8;
+	adr_ctl.u64 = 0;
+	adr_ctl.s.bcst_accept = 1; /* Accept all Broadcast*/
+
+	if ((netdev->flags & IFF_PROMISC) || netdev->uc.count > 7) {
+		adr_ctl.s.cam_accept = 0; /* Reject CAM match */
+		available_cam_entries = 0;
+	} else {
+		/* One CAM entry for the primary address, leaves seven
+		 * for the secondary addresses.
+		 */
+		adr_ctl.s.cam_accept = 1; /* Accept CAM match */
+		available_cam_entries = 7 - netdev->uc.count;
+	}
+
+	if (netdev->flags & IFF_PROMISC) {
+		adr_ctl.s.mcst_mode = 1; /* Accept all Multicast */
+	} else {
+		if (netdev->flags & IFF_MULTICAST) {
+			if ((netdev->flags & IFF_ALLMULTI) || netdev_mc_count(netdev) > available_cam_entries)
+				adr_ctl.s.mcst_mode = 1; /* Accept all Multicast */
+			else
+				adr_ctl.s.mcst_mode = 2; /* Accept all Multicast via CAM */
+		}
+	}
+	current_cam_entry = 0;
+	if (adr_ctl.s.cam_accept) {
+		bgx_port_write_cam(priv->numa_node, priv->bgx_interface, priv->index,
+				   current_cam_entry, netdev->dev_addr);
+		current_cam_entry++;
+		netdev_for_each_uc_addr(ha, netdev) {
+			bgx_port_write_cam(priv->numa_node, priv->bgx_interface, priv->index,
+					   current_cam_entry, ha->addr);
+			current_cam_entry++;
+		}
+	}
+	if (adr_ctl.s.mcst_mode == 2) {/* Accept all Multicast via CAM */
+		netdev_for_each_mc_addr(ha, netdev) {
+			bgx_port_write_cam(priv->numa_node, priv->bgx_interface, priv->index,
+					   current_cam_entry, ha->addr);
+			current_cam_entry++;
+		}
+	}
+	while (current_cam_entry < 8) {
+		bgx_port_write_cam(priv->numa_node, priv->bgx_interface, priv->index,
+				   current_cam_entry, NULL);
+		current_cam_entry++;
+	}
+	cvmx_write_csr_node(priv->numa_node,
+			    CVMX_BGXX_CMRX_RX_ADR_CTL(priv->index, priv->bgx_interface),
+			    adr_ctl.u64);
+}
+EXPORT_SYMBOL(bgx_port_set_rx_filtering);
+
+static void bgx_port_adjust_link(struct net_device *netdev)
+{
+	struct bgx_port_priv *p = bgx_port_netdev2priv(netdev);
+	int link_changed = 0;
+	unsigned int link, speed, duplex;
+	unsigned long flags;
+
+	spin_lock_irqsave(&p->lock, flags);
+
+	if (!p->phydev->link && p->last_link)
+		link_changed = -1;
+
+	if (p->phydev->link
+	    && (p->last_duplex != p->phydev->duplex
+		|| p->last_link != p->phydev->link
+		|| p->last_speed != p->phydev->speed)) {
+		link_changed = 1;
+	}
+
+	link = p->last_link = p->phydev->link;
+	speed = p->last_speed = p->phydev->speed;
+	duplex = p->last_duplex = p->phydev->duplex;
+
+	spin_unlock_irqrestore(&p->lock, flags);
+
+	if (link_changed != 0) {
+		cvmx_helper_link_info_t link_info;
+		if (link_changed > 0) {
+			pr_info("%s: Link is up - %d/%s\n", netdev->name,
+				p->phydev->speed,
+				DUPLEX_FULL == p->phydev->duplex ?
+				"Full" : "Half");
+		} else {
+			pr_info("%s: Link is down\n", netdev->name);
+		}
+		link_info.u64 = 0;
+		link_info.s.link_up = link ? 1 : 0;
+		link_info.s.full_duplex = duplex ? 1 : 0;
+		link_info.s.speed = speed;
+		if (!link) {
+			netif_carrier_off(netdev);
+			mdelay(50); /* Let TX drain.  FIXME really check that it is drained. */
+		}
+		cvmx_helper_link_set(p->ipd_port, link_info);
+		if (link)
+			netif_carrier_on(netdev);
+	}
+}
+
+static void bgx_port_check_state(struct work_struct *work)
+{
+	struct bgx_port_priv		*priv;
+	cvmx_helper_link_info_t		link_info;
+
+	priv = container_of(work, struct bgx_port_priv, dwork.work);
+
+	link_info = cvmx_helper_link_get(priv->ipd_port);
+	if (priv->last_link != link_info.s.link_up) {
+		priv->last_link = link_info.s.link_up;
+		if (link_info.s.link_up)
+			pr_info("%s: Link is up - %d/%s\n",
+				    priv->netdev->name, link_info.s.speed,
+				    link_info.s.full_duplex ? "Full" : "Half");
+		else
+			pr_info("%s: Link is down\n", priv->netdev->name);
+	}
+
+	queue_delayed_work(check_state_wq, &priv->dwork, HZ);
+}
+
+int bgx_port_enable(struct net_device *netdev)
+{
+	bool dont_use_phy;
+	union cvmx_bgxx_cmrx_config cfg;
+	struct bgx_port_priv *priv = bgx_port_netdev2priv(netdev);
+
+	cvmx_helper_set_1000x_mode(priv->xiface, priv->index, false);
+	cvmx_helper_set_mac_phy_mode(priv->xiface, priv->index, false);
+
+	cfg.u64 = cvmx_read_csr_node(priv->numa_node, CVMX_BGXX_CMRX_CONFIG(priv->index, priv->bgx_interface));
+	if (cfg.s.lmac_type == 0) {
+		/* 1G */
+		union cvmx_bgxx_gmp_gmi_txx_append tx_append;
+		union cvmx_bgxx_gmp_gmi_txx_min_pkt min_pkt;
+
+		tx_append.u64 = cvmx_read_csr_node(priv->numa_node,
+						   CVMX_BGXX_GMP_GMI_TXX_APPEND(priv->index, priv->bgx_interface));
+		tx_append.s.fcs = 1;
+		tx_append.s.pad = 1;
+
+		cvmx_write_csr_node(priv->numa_node,
+				    CVMX_BGXX_GMP_GMI_TXX_APPEND(priv->index, priv->bgx_interface),
+				    tx_append.u64);
+
+		min_pkt.u64 = 0;
+		/* packets are padded (without FCS) to MIN_SIZE + 1 in SGMII */
+		min_pkt.s.min_size = 60 - 1;
+		cvmx_write_csr_node(priv->numa_node,
+				    CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(priv->index, priv->bgx_interface),
+				    min_pkt.u64);
+	} else {
+		/* 10G or higher */
+		union cvmx_bgxx_smux_tx_append tx_append;
+		union cvmx_bgxx_smux_tx_min_pkt min_pkt;
+
+		tx_append.u64 = cvmx_read_csr_node(priv->numa_node,
+						   CVMX_BGXX_SMUX_TX_APPEND(priv->index, priv->bgx_interface));
+		tx_append.s.fcs_d = 1;
+		tx_append.s.pad = 1;
+
+		cvmx_write_csr_node(priv->numa_node,
+				    CVMX_BGXX_SMUX_TX_APPEND(priv->index, priv->bgx_interface),
+				    tx_append.u64);
+
+		min_pkt.u64 = 0;
+		/* packets are padded(with FCS) to MIN_SIZE  in non-SGMII */
+		min_pkt.s.min_size = 60 + 4;
+		cvmx_write_csr_node(priv->numa_node,
+				    CVMX_BGXX_SMUX_TX_MIN_PKT(priv->index, priv->bgx_interface),
+				    min_pkt.u64);
+
+	}
+
+	switch (cvmx_helper_interface_get_mode(priv->xiface)) {
+	case CVMX_HELPER_INTERFACE_MODE_XLAUI:
+	case CVMX_HELPER_INTERFACE_MODE_XFI:
+	case CVMX_HELPER_INTERFACE_MODE_10G_KR:
+	case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
+		dont_use_phy = true;
+		break;
+	default:
+		dont_use_phy = false;
+		break;
+	}
+
+	if (priv->phy_np == NULL || dont_use_phy) {
+		cvmx_helper_link_autoconf(priv->ipd_port);
+		netif_carrier_on(netdev);
+
+		mutex_lock(&check_state_wq_mutex);
+		if (!check_state_wq) {
+			check_state_wq =
+				alloc_workqueue("check_state_wq", WQ_UNBOUND |
+						WQ_MEM_RECLAIM, 1);
+		}
+		mutex_unlock(&check_state_wq_mutex);
+		if (!check_state_wq)
+			return -ENOMEM;
+
+		INIT_DELAYED_WORK(&priv->dwork, bgx_port_check_state);
+		queue_delayed_work(check_state_wq, &priv->dwork, 0);
+		pr_info("%s: Link is not ready\n", netdev->name);
+
+		return 0;
+	} else {
+		priv->phydev = of_phy_connect(netdev, priv->phy_np,
+					      bgx_port_adjust_link, 0,
+					      PHY_INTERFACE_MODE_SGMII);
+		if (!priv->phydev)
+			return -ENODEV;
+	}
+
+	netif_carrier_off(netdev);
+
+	if (priv->phydev)
+		phy_start_aneg(priv->phydev);
+
+	return 0;
+}
+EXPORT_SYMBOL(bgx_port_enable);
+
+int bgx_port_disable(struct net_device *netdev)
+{
+	struct bgx_port_priv *priv = bgx_port_netdev2priv(netdev);
+	cvmx_helper_link_info_t link_info;
+
+	if (priv->phydev)
+		phy_disconnect(priv->phydev);
+	priv->phydev = NULL;
+
+	netif_carrier_off(netdev);
+	link_info.u64 = 0;
+	priv->last_link = 0;
+	cvmx_helper_link_set(priv->ipd_port, link_info);
+
+	if (priv->phy_np == NULL)
+		cancel_delayed_work_sync(&priv->dwork);
+
+	return 0;
+}
+EXPORT_SYMBOL(bgx_port_disable);
+
+static int get_max_78xx_pass1_x_mtu(int xiface, int index)
+{
+	int	fifo_size;
+	int	max_mtu = 1500;
+
+	/* Due to errata PKO-20096, the mtu must be limited.
+	 * PKO-20096 causes PKO to lock up when calculating the L4
+	 * checksum for large packets. How large the packets can be
+	 * depends on the amount of pko fifo assigned to the port.
+	 *
+	 *   FIFO size                Max frame size
+	 *	2.5 KB				1920
+	 *	5.0 KB				4480
+	 *     10.0 KB				9600
+	 *
+	 * The maximum mtu is set to the largest frame size minus the
+	 * l2 header.
+	 */
+	fifo_size = cvmx_pko3_port_fifo_size(xiface, index);
+
+	switch (fifo_size) {
+	case 2560:
+		max_mtu = 1920 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
+		break;
+
+	case 5120:
+		max_mtu = 4480 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
+		break;
+
+	case 10240:
+		max_mtu = 9600 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
+		break;
+
+	default:
+		break;
+	}
+
+	return max_mtu;
+}
+
+int bgx_port_change_mtu(struct net_device *netdev, int new_mtu)
+{
+	union cvmx_bgxx_cmrx_config cfg;
+	struct bgx_port_priv *priv = bgx_port_netdev2priv(netdev);
+	int max_frame;
+
+	if (new_mtu < 60 || new_mtu > 65392)
+		return -EINVAL;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+		int	max_mtu;
+
+		max_mtu = get_max_78xx_pass1_x_mtu(priv->xiface, priv->index);
+		if (new_mtu > max_mtu) {
+			new_mtu = max_mtu;
+			netdev_warn(netdev, "Maximum MTU supported is %d",
+				    max_mtu);
+		}
+	}
+
+	netdev->mtu = new_mtu;
+
+	max_frame = round_up(new_mtu + ETH_HLEN + ETH_FCS_LEN, 8);
+
+	cfg.u64 = cvmx_read_csr_node(priv->numa_node, CVMX_BGXX_CMRX_CONFIG(priv->index, priv->bgx_interface));
+	if (cfg.s.lmac_type == 0)
+		cvmx_write_csr_node(priv->numa_node,		/* 1G */
+				    CVMX_BGXX_GMP_GMI_RXX_JABBER(priv->index, priv->bgx_interface),
+				    max_frame);
+	else
+		cvmx_write_csr_node(priv->numa_node,		/* 10G or higher */
+				    CVMX_BGXX_SMUX_RX_JABBER(priv->index, priv->bgx_interface),
+				    max_frame);
+
+
+	return 0;
+}
+EXPORT_SYMBOL(bgx_port_change_mtu);
+
+static int bgx_port_probe(struct platform_device *pdev)
+{
+	u64 addr;
+	const u8 *mac;
+	const __be32 *reg;
+	u32 index;
+	int r;
+	struct bgx_port_priv *priv;
+	int numa_node;
+
+	reg = of_get_property(pdev->dev.parent->of_node, "reg", NULL);
+	addr = of_translate_address(pdev->dev.parent->of_node, reg);
+	mac = of_get_mac_address(pdev->dev.of_node);
+
+	numa_node = (addr >> 36) & 0x7;
+
+	r = of_property_read_u32(pdev->dev.of_node, "reg", &index);
+	if (r)
+		return -ENODEV;
+	priv = kzalloc_node(sizeof(*priv), GFP_KERNEL, numa_node);
+	if (!priv)
+		return -ENOMEM;
+
+	spin_lock_init(&priv->lock);
+	priv->numa_node = numa_node;
+	priv->bgx_interface = (addr >> 24) & 0xf;
+	priv->index = index;
+	priv->xiface = cvmx_helper_node_interface_to_xiface(numa_node, priv->bgx_interface);
+	priv->ipd_port = cvmx_helper_get_ipd_port(priv->xiface, index);
+	if (mac)
+		priv->mac_addr = mac;
+
+	priv->phy_np = of_parse_phandle(pdev->dev.of_node, "phy-handle", 0);
+
+	if (priv->phy_np == NULL)
+		cvmx_helper_set_port_phy_present(priv->xiface, priv->index, false);
+	else
+		cvmx_helper_set_port_phy_present(priv->xiface, priv->index, true);
+
+	r = dev_set_drvdata(&pdev->dev, priv);
+
+	if (priv->phy_np)
+		__cvmx_helper_bgx_port_init(priv->ipd_port, 1);
+	else
+		__cvmx_helper_bgx_port_init(priv->ipd_port, 0);
+
+	if (r)
+		goto err;
+
+	dev_info(&pdev->dev, "Probed\n");
+	return 0;
+err:
+	kfree(priv);
+	return r;
+}
+
+static int bgx_port_remove(struct platform_device *pdev)
+{
+	struct bgx_port_priv *priv = dev_get_drvdata(&pdev->dev);
+	kfree(priv);
+	return 0;
+}
+
+static void bgx_port_shutdown(struct platform_device *pdev)
+{
+	return;
+}
+
+static struct of_device_id bgx_port_match[] = {
+	{
+		.compatible = "cavium,octeon-7890-bgx-port",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, bgx_port_match);
+
+static struct platform_driver bgx_port_driver = {
+	.probe		= bgx_port_probe,
+	.remove		= bgx_port_remove,
+	.shutdown       = bgx_port_shutdown,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= KBUILD_MODNAME,
+		.of_match_table = bgx_port_match,
+	},
+};
+
+static int __init bgx_port_driver_init(void)
+{
+	int r;
+
+	bgx_nexus_load();
+	r =  platform_driver_register(&bgx_port_driver);
+	return r;
+}
+module_init(bgx_port_driver_init);
+
+static void __exit bgx_port_driver_exit(void)
+{
+	platform_driver_unregister(&bgx_port_driver);
+	destroy_workqueue(check_state_wq);
+}
+module_exit(bgx_port_driver_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cavium Networks <support@caviumnetworks.com>");
+MODULE_DESCRIPTION("Cavium Networks BGX Ethernet MAC driver.");
-- 
1.8.2.1

