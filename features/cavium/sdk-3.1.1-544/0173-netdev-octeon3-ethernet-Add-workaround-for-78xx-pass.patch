From c07325e88d47256fe82b52fd1af51d236fc50ccd Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Fri, 11 Jul 2014 12:20:10 -0700
Subject: [PATCH 173/202] netdev: octeon3-ethernet: Add workaround for 78xx
 pass 1.x bug PKO-20096.

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.1-544]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/octeon/octeon-bgx-port.c | 53 +++++++++++++++++++++++++++
 1 file changed, 53 insertions(+)

diff --git a/drivers/net/ethernet/octeon/octeon-bgx-port.c b/drivers/net/ethernet/octeon/octeon-bgx-port.c
index 7681923..80b08dc 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-port.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-port.c
@@ -34,12 +34,14 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/list.h>
+#include <linux/if_vlan.h>
 
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-helper-util.h>
 #include <asm/octeon/cvmx-helper-cfg.h>
 #include <asm/octeon/cvmx-bgxx-defs.h>
 #include <asm/octeon/cvmx-helper-bgx.h>
+#include <asm/octeon/cvmx-pko3.h>
 
 #include "octeon-bgx.h"
 
@@ -399,6 +401,46 @@ int bgx_port_disable(struct net_device *netdev)
 }
 EXPORT_SYMBOL(bgx_port_disable);
 
+static int get_max_78xx_pass1_x_mtu(int xiface, int index)
+{
+	int	fifo_size;
+	int	max_mtu = 1500;
+
+	/* Due to errata PKO-20096, the mtu must be limited.
+	 * PKO-20096 causes PKO to lock up when calculating the L4
+	 * checksum for large packets. How large the packets can be
+	 * depends on the amount of pko fifo assigned to the port.
+	 *
+	 *   FIFO size                Max frame size
+	 *	2.5 KB				1920
+	 *	5.0 KB				4480
+	 *     10.0 KB				9600
+	 *
+	 * The maximum mtu is set to the largest frame size minus the
+	 * l2 header.
+	 */
+	fifo_size = cvmx_pko3_port_fifo_size(xiface, index);
+
+	switch (fifo_size) {
+	case 2560:
+		max_mtu = 1920 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
+		break;
+
+	case 5120:
+		max_mtu = 4480 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
+		break;
+
+	case 10240:
+		max_mtu = 9600 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
+		break;
+
+	default:
+		break;
+	}
+
+	return max_mtu;
+}
+
 int bgx_port_change_mtu(struct net_device *netdev, int new_mtu)
 {
 	union cvmx_bgxx_cmrx_config cfg;
@@ -408,6 +450,17 @@ int bgx_port_change_mtu(struct net_device *netdev, int new_mtu)
 	if (new_mtu < 60 || new_mtu > 65392)
 		return -EINVAL;
 
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+		int	max_mtu;
+
+		max_mtu = get_max_78xx_pass1_x_mtu(priv->xiface, priv->index);
+		if (new_mtu > max_mtu) {
+			new_mtu = max_mtu;
+			netdev_warn(netdev, "Maximum MTU supported is %d",
+				    max_mtu);
+		}
+	}
+
 	netdev->mtu = new_mtu;
 
 	max_frame = round_up(new_mtu + ETH_HLEN + ETH_FCS_LEN, 8);
-- 
1.8.2.1

