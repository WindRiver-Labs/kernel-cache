From adc5de15c3ba4abc792cc7605fc2652ef1ba5728 Mon Sep 17 00:00:00 2001
From: Tsvetan Erenditsov <terenditsov@caviumnetworks.com>
Date: Wed, 29 Oct 2014 11:17:03 -0700
Subject: [PATCH 179/202] Updated all left files to match the S.E. files

Signed-off-by: Tsvetan Erenditsov <terenditsov@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.1-544]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-rapidio.c          | 14 +++++++-------
 drivers/net/ethernet/octeon/ethernet-mem.c        | 10 +++++-----
 drivers/net/ethernet/octeon/ethernet-napi.c       |  8 ++++----
 drivers/net/ethernet/octeon/ethernet-rx.c         |  2 +-
 drivers/net/ethernet/octeon/ethernet-tx.c         |  8 ++++----
 drivers/net/ethernet/octeon/ethernet-xmit.c       | 22 +++++++++++-----------
 drivers/net/ethernet/octeon/ethernet.c            | 16 ++++++++--------
 drivers/net/ethernet/octeon/octeon-ethernet.h     |  8 ++++----
 drivers/net/ethernet/octeon/octeon-pow-ethernet.c | 14 +++++++-------
 9 files changed, 51 insertions(+), 51 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-rapidio.c b/arch/mips/cavium-octeon/octeon-rapidio.c
index aa55b41..40721d7 100644
--- a/arch/mips/cavium-octeon/octeon-rapidio.c
+++ b/arch/mips/cavium-octeon/octeon-rapidio.c
@@ -22,7 +22,7 @@
 #include <asm/octeon/cvmx-pexp-defs.h>
 #include <asm/octeon/cvmx-sriomaintx-defs.h>
 #include <asm/octeon/cvmx-dma-engine.h>
-#include <asm/octeon/cvmx-fpa.h>
+#include <asm/octeon/cvmx-fpa1.h>
 #include <asm/octeon/cvmx-config.h>
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-qlm.h>
@@ -315,12 +315,12 @@ int octeon_rio_dma_mem(struct rio_dev *rdev, u64 local_addr,
 	sli_address += memmap & 0x3ffffffffull;
 
 	/* Create the DMA header */
-	header.u64 = 0;
-	header.s.fport = 0;
-	header.s.lport = rdev->net->hport->id;
-	header.s.type = (is_outbound) ? CVMX_DMA_ENGINE_TRANSFER_OUTBOUND :
+	header.word0.u64 = 0;
+	header.word0.cn38xx.fport = 0;
+	header.word0.cn38xx.lport = rdev->net->hport->id;
+	header.word0.cn38xx.type = (is_outbound) ? CVMX_DMA_ENGINE_TRANSFER_OUTBOUND :
 		CVMX_DMA_ENGINE_TRANSFER_INBOUND;
-	header.s.addr = virt_to_phys(&dma_busy);
+	header.word0.cn38xx.addr = virt_to_phys(&dma_busy);
 
 	/* Do the DMA */
 	result = cvmx_dma_engine_transfer(0, header, local_addr,
@@ -816,7 +816,7 @@ static int __init octeon_rio_init(void)
 	}
 	if (count) {
 		int r;
-		cvmx_fpa_enable();
+		cvmx_fpa1_enable();
 		r = cvm_oct_alloc_fpa_pool(CVMX_FPA_OUTPUT_BUFFER_POOL,
 					   CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE);
 		if (r < 0)
diff --git a/drivers/net/ethernet/octeon/ethernet-mem.c b/drivers/net/ethernet/octeon/ethernet-mem.c
index 770212d..e8629d7 100644
--- a/drivers/net/ethernet/octeon/ethernet-mem.c
+++ b/drivers/net/ethernet/octeon/ethernet-mem.c
@@ -30,7 +30,7 @@
 #include <linux/slab.h>
 
 #include <asm/octeon/octeon.h>
-#include <asm/octeon/cvmx-fpa.h>
+#include <asm/octeon/cvmx-fpa1.h>
 
 #include "ethernet-defines.h"
 #include "octeon-ethernet.h"
@@ -77,7 +77,7 @@ static int cvm_oct_fill_hw_skbuff(struct fpa_pool *pool, int elements)
 		extra_reserve = desired_data - skb->data;
 		skb_reserve(skb, extra_reserve);
 		*(struct sk_buff **)(skb->data - sizeof(void *)) = skb;
-		cvmx_fpa_free(skb->data, pool_num, DONT_WRITEBACK(size / 128));
+		cvmx_fpa1_free(skb->data, pool_num, DONT_WRITEBACK(size / 128));
 		freed--;
 	}
 	return elements - freed;
@@ -96,7 +96,7 @@ static int cvm_oct_free_hw_skbuff(struct fpa_pool *pool, int elements)
 	int pool_num = pool->pool;
 
 	while (elements) {
-		memory = cvmx_fpa_alloc(pool_num);
+		memory = cvmx_fpa1_alloc(pool_num);
 		if (!memory)
 			break;
 		skb = *cvm_oct_packet_to_skb(memory);
@@ -131,7 +131,7 @@ static int cvm_oct_fill_hw_kmem(struct fpa_pool *pool, int elements)
 			       elements * pool->size, pool->pool);
 			break;
 		}
-		cvmx_fpa_free(memory, pool->pool, 0);
+		cvmx_fpa1_free(memory, pool->pool, 0);
 		freed--;
 	}
 	return elements - freed;
@@ -147,7 +147,7 @@ static int cvm_oct_free_hw_kmem(struct fpa_pool *pool, int elements)
 {
 	char *fpa;
 	while (elements) {
-		fpa = cvmx_fpa_alloc(pool->pool);
+		fpa = cvmx_fpa1_alloc(pool->pool);
 		if (!fpa)
 			break;
 		elements--;
diff --git a/drivers/net/ethernet/octeon/ethernet-napi.c b/drivers/net/ethernet/octeon/ethernet-napi.c
index 281b38b..d0d5c83 100644
--- a/drivers/net/ethernet/octeon/ethernet-napi.c
+++ b/drivers/net/ethernet/octeon/ethernet-napi.c
@@ -170,12 +170,12 @@ static int CVM_OCT_NAPI_POLL(struct napi_struct *napi, int budget)
 			}
 			dev_kfree_skb_any(skb);
 
-			cvmx_fpa_free(work, wqe_pool, DONT_WRITEBACK(1));
+			cvmx_fpa1_free(work, wqe_pool, DONT_WRITEBACK(1));
 
 			/* We are done with this one, adjust the queue
 			 * depth.
 			 */
-			cvmx_fau_atomic_add32(priv->tx_queue[packet_qos].fau, -1);
+			cvmx_hwfau_atomic_add32(priv->tx_queue[packet_qos].fau, -1);
 			continue;
 		}
 		segments = work->word2.s.bufs;
@@ -440,10 +440,10 @@ static int CVM_OCT_NAPI_POLL(struct napi_struct *napi, int budget)
 				 * the number of buffers we need to free by
 				 * one.
 				 */
-				cvmx_fau_atomic_add32(FAU_NUM_PACKET_BUFFERS_TO_FREE,
+				cvmx_hwfau_atomic_add32(FAU_NUM_PACKET_BUFFERS_TO_FREE,
 						      packets_to_replace);
 
-				cvmx_fpa_free(work, wqe_pool, DONT_WRITEBACK(1));
+				cvmx_fpa1_free(work, wqe_pool, DONT_WRITEBACK(1));
 			} else {
 				cvm_oct_free_work(work);
 			}
diff --git a/drivers/net/ethernet/octeon/ethernet-rx.c b/drivers/net/ethernet/octeon/ethernet-rx.c
index ac647ec..45eeab0 100644
--- a/drivers/net/ethernet/octeon/ethernet-rx.c
+++ b/drivers/net/ethernet/octeon/ethernet-rx.c
@@ -51,7 +51,7 @@
 
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-wqe.h>
-#include <asm/octeon/cvmx-fau.h>
+#include <asm/octeon/cvmx-hwfau.h>
 #include <asm/octeon/cvmx-pow.h>
 #include <asm/octeon/cvmx-pip.h>
 #include <asm/octeon/cvmx-ipd.h>
diff --git a/drivers/net/ethernet/octeon/ethernet-tx.c b/drivers/net/ethernet/octeon/ethernet-tx.c
index cd8b1e8..26f9340 100644
--- a/drivers/net/ethernet/octeon/ethernet-tx.c
+++ b/drivers/net/ethernet/octeon/ethernet-tx.c
@@ -42,10 +42,10 @@
 #include "octeon-ethernet.h"
 
 #include <asm/octeon/cvmx-wqe.h>
-#include <asm/octeon/cvmx-fau.h>
+#include <asm/octeon/cvmx-hwfau.h>
 #include <asm/octeon/cvmx-ipd.h>
 #include <asm/octeon/cvmx-pip.h>
-#include <asm/octeon/cvmx-pko.h>
+#include <asm/octeon/cvmx-hwpko.h>
 #include <asm/octeon/cvmx-helper.h>
 
 #include <asm/octeon/cvmx-gmxx-defs.h>
@@ -210,7 +210,7 @@ int cvm_oct_transmit_qos(struct net_device *dev,
 		pko_command.s.ipoffp1 = sizeof(struct ethhdr) + 1;
 
 	/* Send the packet to the output queue */
-	if (unlikely(cvmx_pko_send_packet_finish_pkoid(priv->pko_port, priv->tx_queue[qos].queue, pko_command, hw_buffer, lock_type))) {
+	if (unlikely(cvmx_hwpko_send_packet_finish_pkoid(priv->pko_port, priv->tx_queue[qos].queue, pko_command, hw_buffer, lock_type))) {
 		netdev_err(dev, "Error: Failed to send the packet\n");
 		dropped = -1;
 	}
@@ -222,7 +222,7 @@ int cvm_oct_transmit_qos(struct net_device *dev,
 		dev->stats.tx_dropped++;
 	} else
 	if (do_free)
-		cvmx_fpa_free(work, wqe_pool, DONT_WRITEBACK(1));
+		cvmx_fpa1_free(work, wqe_pool, DONT_WRITEBACK(1));
 
 	return dropped;
 }
diff --git a/drivers/net/ethernet/octeon/ethernet-xmit.c b/drivers/net/ethernet/octeon/ethernet-xmit.c
index f19d8f2..9af0965 100644
--- a/drivers/net/ethernet/octeon/ethernet-xmit.c
+++ b/drivers/net/ethernet/octeon/ethernet-xmit.c
@@ -79,7 +79,7 @@ CVM_OCT_XMIT
 		/* Fetch and increment the number of packets to be
 		 * freed.
 		 */
-		cvmx_fau_async_fetch_and_add32(CVMX_SCR_SCRATCH + 8,
+		cvmx_hwfau_async_fetch_and_add32(CVMX_SCR_SCRATCH + 8,
 					       FAU_NUM_PACKET_BUFFERS_TO_FREE,
 					       0);
 	}
@@ -101,7 +101,7 @@ CVM_OCT_XMIT
 		qos = 0;
 #endif
 	if (USE_ASYNC_IOBDMA) {
-		cvmx_fau_async_fetch_and_add32(CVMX_SCR_SCRATCH,
+		cvmx_hwfau_async_fetch_and_add32(CVMX_SCR_SCRATCH,
 					       priv->tx_queue[qos].fau, 1);
 	}
 
@@ -169,7 +169,7 @@ CVM_OCT_XMIT
 	} else {
 		u64 *hw_buffer_list;
 
-		work = cvmx_fpa_alloc(wqe_pool);
+		work = cvmx_fpa1_alloc(wqe_pool);
 		if (unlikely(!work)) {
 			netdev_err(dev, "Failed WQE allocate\n");
 			queue_type = QUEUE_DROP;
@@ -256,8 +256,8 @@ CVM_OCT_XMIT
 		buffers_to_free = cvmx_scratch_read64(CVMX_SCR_SCRATCH + 8);
 	} else {
 		/* Get the number of skbuffs in use by the hardware */
-		queue_depth = cvmx_fau_fetch_and_add32(priv->tx_queue[qos].fau, 1);
-		buffers_to_free = cvmx_fau_fetch_and_add32(FAU_NUM_PACKET_BUFFERS_TO_FREE, 0);
+		queue_depth = cvmx_hwfau_fetch_and_add32(priv->tx_queue[qos].fau, 1);
+		buffers_to_free = cvmx_hwfau_fetch_and_add32(FAU_NUM_PACKET_BUFFERS_TO_FREE, 0);
 	}
 
 	/* If we're sending faster than the receive can free them then
@@ -298,7 +298,7 @@ CVM_OCT_XMIT
 
 	if (queue_type == QUEUE_WQE) {
 		if (!work) {
-			work = cvmx_fpa_alloc(wqe_pool);
+			work = cvmx_fpa1_alloc(wqe_pool);
 			if (unlikely(!work)) {
 				netdev_err(dev, "Failed WQE allocate\n");
 				queue_type = QUEUE_DROP;
@@ -338,14 +338,14 @@ CVM_OCT_XMIT
 		if (timestamp_this_skb)
 			word2 |= 1ull << 40; /* Bit 40 controls timestamps */
 
-		if (unlikely(cvmx_pko_send_packet_finish3_pkoid(priv->pko_port,
+		if (unlikely(cvmx_hwpko_send_packet_finish3_pkoid(priv->pko_port,
 							  priv->tx_queue[qos].queue, pko_command, hw_buffer,
 							  word2, CVM_OCT_PKO_LOCK_TYPE))) {
 				queue_type = QUEUE_DROP;
 				netdev_err(dev, "Failed to send the packet with wqe\n");
 		}
 	} else {
-		if (unlikely(cvmx_pko_send_packet_finish_pkoid(priv->pko_port,
+		if (unlikely(cvmx_hwpko_send_packet_finish_pkoid(priv->pko_port,
 							 priv->tx_queue[qos].queue,
 							 pko_command, hw_buffer,
 							 CVM_OCT_PKO_LOCK_TYPE))) {
@@ -358,14 +358,14 @@ CVM_OCT_XMIT
 skip_xmit:
 	switch (queue_type) {
 	case QUEUE_DROP:
-		cvmx_fau_atomic_add32(priv->tx_queue[qos].fau, -1);
+		cvmx_hwfau_atomic_add32(priv->tx_queue[qos].fau, -1);
 		dev_kfree_skb_any(skb);
 		dev->stats.tx_dropped++;
 		if (work)
-			cvmx_fpa_free(work, wqe_pool, DONT_WRITEBACK(1));
+			cvmx_fpa1_free(work, wqe_pool, DONT_WRITEBACK(1));
 		break;
 	case QUEUE_HW:
-		cvmx_fau_atomic_add32(FAU_NUM_PACKET_BUFFERS_TO_FREE, -buffers_being_recycled);
+		cvmx_hwfau_atomic_add32(FAU_NUM_PACKET_BUFFERS_TO_FREE, -buffers_being_recycled);
 		break;
 	case QUEUE_WQE:
 		/* Cleanup is done on the RX path when the WQE returns */
diff --git a/drivers/net/ethernet/octeon/ethernet.c b/drivers/net/ethernet/octeon/ethernet.c
index 0ed97dc0..2cac73a 100644
--- a/drivers/net/ethernet/octeon/ethernet.c
+++ b/drivers/net/ethernet/octeon/ethernet.c
@@ -41,8 +41,8 @@
 #include "octeon-ethernet.h"
 
 #include <asm/octeon/cvmx-pip.h>
-#include <asm/octeon/cvmx-pko.h>
-#include <asm/octeon/cvmx-fau.h>
+#include <asm/octeon/cvmx-hwpko.h>
+#include <asm/octeon/cvmx-hwfau.h>
 #include <asm/octeon/cvmx-ipd.h>
 #include <asm/octeon/cvmx-srio.h>
 #include <asm/octeon/cvmx-helper.h>
@@ -270,7 +270,7 @@ static void cvm_oct_set_pko_multiqueue(void)
 static int cvm_oct_configure_common_hw(void)
 {
 	/* Setup the FPA */
-	cvmx_fpa_enable();
+	cvmx_fpa1_enable();
 
 	/* allocate packet pool */
 	packet_pool = cvm_oct_alloc_fpa_pool(packet_pool, FPA_PACKET_POOL_SIZE);
@@ -386,12 +386,12 @@ int cvm_oct_free_work(void *work_queue_entry)
 	while (segments--) {
 		union cvmx_buf_ptr next_ptr = *(union cvmx_buf_ptr *)phys_to_virt(segment_ptr.s.addr - 8);
 		if (!segment_ptr.s.i)
-			cvmx_fpa_free(cvm_oct_get_buffer_ptr(segment_ptr),
+			cvmx_fpa1_free(cvm_oct_get_buffer_ptr(segment_ptr),
 				      segment_ptr.s.pool,
 				      DONT_WRITEBACK(FPA_PACKET_POOL_SIZE / 128));
 		segment_ptr = next_ptr;
 	}
-	cvmx_fpa_free(work, wqe_pool, DONT_WRITEBACK(1));
+	cvmx_fpa1_free(work, wqe_pool, DONT_WRITEBACK(1));
 
 	return 0;
 }
@@ -870,12 +870,12 @@ static int cvm_oct_probe(struct platform_device *pdev)
 		}
 	}
 
-	cvmx_helper_ipd_and_packet_input_enable();
+	cvmx_helper_ipd_and_packet_input_enable_node(0);
 
 	/* Initialize the FAU used for counting packet buffers that
 	 * need to be freed.
 	 */
-	cvmx_fau_atomic_write32(FAU_NUM_PACKET_BUFFERS_TO_FREE, 0);
+	cvmx_hwfau_atomic_write32(FAU_NUM_PACKET_BUFFERS_TO_FREE, 0);
 
 	num_interfaces = cvmx_helper_get_number_of_interfaces();
 	for (interface = 0; interface < num_interfaces; interface++) {
@@ -964,7 +964,7 @@ static int cvm_oct_probe(struct platform_device *pdev)
 				priv->tx_queue[qos].queue = base_queue + qos;
 				fau = fau - sizeof(u32);
 				priv->tx_queue[qos].fau = fau;
-				cvmx_fau_atomic_write32(priv->tx_queue[qos].fau, 0);
+				cvmx_hwfau_atomic_write32(priv->tx_queue[qos].fau, 0);
 			}
 
 			/* Cache the fact that there may be multiple queues */
diff --git a/drivers/net/ethernet/octeon/octeon-ethernet.h b/drivers/net/ethernet/octeon/octeon-ethernet.h
index 191d4da..173dcaa 100644
--- a/drivers/net/ethernet/octeon/octeon-ethernet.h
+++ b/drivers/net/ethernet/octeon/octeon-ethernet.h
@@ -36,7 +36,7 @@
 #include "octeon_common.h"
 
 #include <asm/octeon/cvmx-helper.h>
-#include <asm/octeon/cvmx-fau.h>
+#include <asm/octeon/cvmx-hwfau.h>
 #include <asm/octeon/octeon-ethernet-user.h>
 
 /**
@@ -188,14 +188,14 @@ static inline void cvm_oct_rx_refill_pool(int fill_threshold)
 	int num_freed;
 	/* Refill the packet buffer pool */
 	number_to_free =
-		cvmx_fau_fetch_and_add32(FAU_NUM_PACKET_BUFFERS_TO_FREE, 0);
+		cvmx_hwfau_fetch_and_add32(FAU_NUM_PACKET_BUFFERS_TO_FREE, 0);
 
 	if (number_to_free > fill_threshold) {
-		cvmx_fau_atomic_add32(FAU_NUM_PACKET_BUFFERS_TO_FREE,
+		cvmx_hwfau_atomic_add32(FAU_NUM_PACKET_BUFFERS_TO_FREE,
 				      -number_to_free);
 		num_freed = cvm_oct_mem_fill_fpa(packet_pool, number_to_free);
 		if (num_freed != number_to_free) {
-			cvmx_fau_atomic_add32(FAU_NUM_PACKET_BUFFERS_TO_FREE,
+			cvmx_hwfau_atomic_add32(FAU_NUM_PACKET_BUFFERS_TO_FREE,
 					number_to_free - num_freed);
 		}
 	}
diff --git a/drivers/net/ethernet/octeon/octeon-pow-ethernet.c b/drivers/net/ethernet/octeon/octeon-pow-ethernet.c
index c6039a4..c2ab83b 100644
--- a/drivers/net/ethernet/octeon/octeon-pow-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon-pow-ethernet.c
@@ -19,7 +19,7 @@
 
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx.h>
-#include <asm/octeon/cvmx-fpa.h>
+#include <asm/octeon/cvmx-fpa1.h>
 #include <asm/octeon/cvmx-pow.h>
 #include <asm/octeon/cvmx-wqe.h>
 #include <asm/octeon/cvmx-pow-defs.h>
@@ -134,11 +134,11 @@ static int octeon_pow_free_work(cvmx_wqe_t *work)
 		union cvmx_buf_ptr next_ptr =
 			*(union cvmx_buf_ptr *)phys_to_virt(segment_ptr.s.addr - 8);
 		if (unlikely(!segment_ptr.s.i))
-			cvmx_fpa_free(get_buffer_ptr(segment_ptr),
+			cvmx_fpa1_free(get_buffer_ptr(segment_ptr),
 				 segment_ptr.s.pool, 0);
 		segment_ptr = next_ptr;
 	}
-	cvmx_fpa_free(work, fpa_wqe_pool, 0);
+	cvmx_fpa1_free(work, fpa_wqe_pool, 0);
 
 	return 0;
 }
@@ -175,7 +175,7 @@ static int octeon_pow_xmit(struct sk_buff *skb, struct net_device *dev)
 			continue;
 
 		/* Get a work queue entry */
-		work = cvmx_fpa_alloc(fpa_wqe_pool);
+		work = cvmx_fpa1_alloc(fpa_wqe_pool);
 		if (unlikely(work == NULL)) {
 			DEBUGPRINT("%s: Failed to allocate a work queue entry\n",
 				   dev->name);
@@ -183,7 +183,7 @@ static int octeon_pow_xmit(struct sk_buff *skb, struct net_device *dev)
 		}
 
 		/* Get a packet buffer */
-		packet_buffer = cvmx_fpa_alloc(fpa_packet_pool);
+		packet_buffer = cvmx_fpa1_alloc(fpa_packet_pool);
 		if (unlikely(packet_buffer == NULL)) {
 			DEBUGPRINT("%s: Failed to allocate a packet buffer\n",
 				   dev->name);
@@ -321,9 +321,9 @@ static int octeon_pow_xmit(struct sk_buff *skb, struct net_device *dev)
 
 fail:
 	if (work)
-		cvmx_fpa_free(work, fpa_wqe_pool, 0);
+		cvmx_fpa1_free(work, fpa_wqe_pool, 0);
 	if (packet_buffer)
-		cvmx_fpa_free(packet_buffer, fpa_packet_pool, 0);
+		cvmx_fpa1_free(packet_buffer, fpa_packet_pool, 0);
 	dev->stats.tx_dropped++;
 	dev_kfree_skb(skb);
 	return NETDEV_TX_OK;
-- 
1.8.2.1

