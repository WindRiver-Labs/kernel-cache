From 009afcfd1f30f57aa3dc990ee4152da52f366286 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 13 Feb 2015 14:19:26 +0530
Subject: [PATCH 068/148] MIPS: OCTEON: Fix local_flush_icache_range

Commit 7c8ec7bee16a3941c020da7faeaaff4b1e548428 from
git://git.yoctoproject.org/linux-yocto-3.14

We need a full memory barrier (SYNC) before the iCache invalidation to
ensure that any changes pending in write buffers are flushed before
the iCache has a chance to be reloaded.

MIPS: OCTEON: Add OCTEON specific implemtation of local_flush_icache_all().

MIPS: OCTEON: Do mb() for octeon_flush_data_cache_page()

MIPS: Add new function local_flush_icache_all()

... to flush the entire local ICache.  Default implementation is to do
flush_icache_all().  Processor specific implementations will be in
follow on patches.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Abhishek Paliwal <abhishek.paliwal@aricent.com>
---
 arch/mips/include/asm/cacheflush.h |  1 +
 arch/mips/mm/c-octeon.c            | 46 +++++++++++++++++++++++---------------
 arch/mips/mm/cache.c               |  5 ++++-
 3 files changed, 33 insertions(+), 19 deletions(-)

diff --git a/arch/mips/include/asm/cacheflush.h b/arch/mips/include/asm/cacheflush.h
index 69468de..5e0bac5 100644
--- a/arch/mips/include/asm/cacheflush.h
+++ b/arch/mips/include/asm/cacheflush.h
@@ -92,6 +92,7 @@ extern void copy_from_user_page(struct vm_area_struct *vma,
 
 extern void (*flush_cache_sigtramp)(unsigned long addr);
 extern void (*flush_icache_all)(void);
+extern void (*local_flush_icache_all)(void);
 extern void (*local_flush_data_cache_page)(void * addr);
 extern void (*flush_data_cache_page)(unsigned long addr);
 
diff --git a/arch/mips/mm/c-octeon.c b/arch/mips/mm/c-octeon.c
index 3fe97f5..ff0ea0a 100644
--- a/arch/mips/mm/c-octeon.c
+++ b/arch/mips/mm/c-octeon.c
@@ -34,17 +34,17 @@ EXPORT_SYMBOL_GPL(cache_err_dcache);
 static RAW_NOTIFIER_HEAD(co_cache_error_chain);
 
 /**
- * Octeon automatically flushes the dcache on tlb changes, so
- * from Linux's viewpoint it acts much like a physically
- * tagged cache. No flushing is needed
+ * Octeon automatically flushes the dcache on tlb changes, but we need
+ * a full barrier to make sure subsequent icache fills see any queued
+ * stores.
  *
  */
 static void octeon_flush_data_cache_page(unsigned long addr)
 {
-    /* Nothing to do */
+	mb(); /* SYNC */
 }
 
-static inline void octeon_local_flush_icache(void)
+static void octeon_local_flush_icache(void)
 {
 	asm volatile ("synci 0($0)");
 }
@@ -52,9 +52,19 @@ static inline void octeon_local_flush_icache(void)
 /*
  * Flush local I-cache for the specified range.
  */
-static void local_octeon_flush_icache_range(unsigned long start,
+static void octeon_local_flush_icache_all(void)
+{
+	mb();
+	octeon_local_flush_icache();
+}
+
+/*
+ * Flush local I-cache for the specified range.
+ */
+static void octeon_local_flush_icache_range(unsigned long start,
 					    unsigned long end)
 {
+	mb();
 	octeon_local_flush_icache();
 }
 
@@ -66,8 +76,8 @@ static void local_octeon_flush_icache_range(unsigned long start,
  */
 static void octeon_flush_icache_all_cores(struct vm_area_struct *vma)
 {
-	extern void octeon_send_ipi_single(int cpu, unsigned int action);
 #ifdef CONFIG_SMP
+	extern struct plat_smp_ops *mp_ops;	/* private */
 	int cpu;
 	cpumask_t mask;
 #endif
@@ -87,8 +97,7 @@ static void octeon_flush_icache_all_cores(struct vm_area_struct *vma)
 	else
 		mask = *cpu_online_mask;
 	cpumask_clear_cpu(cpu, &mask);
-	for_each_cpu(cpu, &mask)
-		octeon_send_ipi_single(cpu, SMP_ICACHE_FLUSH);
+	mp_ops->send_ipi_mask(&mask, SMP_ICACHE_FLUSH);
 
 	preempt_enable();
 #endif
@@ -191,8 +200,8 @@ static int octeon2_be_handler(struct pt_regs *regs, int is_fixup)
 	dcache_err = read_octeon_c0_dcacheerr();
 	if (dcache_err & wbfperr_mask) {
 		int rv = raw_notifier_call_chain(&co_cache_error_chain,
-						CO_CACHE_ERROR_WB_PARITY,
-						NULL);
+						 CO_CACHE_ERROR_WB_PARITY,
+						 NULL);
 		if ((rv & ~NOTIFY_STOP_MASK) != NOTIFY_OK) {
 			unsigned int coreid = cvmx_get_core_num();
 
@@ -235,8 +244,8 @@ static int octeon2_mcheck_handler(struct pt_regs *regs)
 		write_c0_cvmmemctl(cvmmemctl.u64);
 
 		rv = raw_notifier_call_chain(&co_cache_error_chain,
-						CO_CACHE_ERROR_TLB_PARITY,
-						NULL);
+					     CO_CACHE_ERROR_TLB_PARITY,
+					     NULL);
 		if ((rv & ~NOTIFY_STOP_MASK) != NOTIFY_OK) {
 			unsigned int coreid = cvmx_get_core_num();
 
@@ -262,8 +271,8 @@ static int octeon3_be_handler(struct pt_regs *regs, int is_fixup)
 	dcache_err = read_octeon_c0_errctl();
 	if (dcache_err & wbfperr_mask) {
 		int rv = raw_notifier_call_chain(&co_cache_error_chain,
-						CO_CACHE_ERROR_WB_PARITY,
-						NULL);
+						 CO_CACHE_ERROR_WB_PARITY,
+						 NULL);
 		if ((rv & ~NOTIFY_STOP_MASK) != NOTIFY_OK) {
 			unsigned int coreid = cvmx_get_core_num();
 
@@ -306,8 +315,8 @@ static int octeon3_mcheck_handler(struct pt_regs *regs)
 		write_c0_cvmmemctl(cvmmemctl.u64);
 
 		rv = raw_notifier_call_chain(&co_cache_error_chain,
-						CO_CACHE_ERROR_TLB_PARITY,
-						NULL);
+					     CO_CACHE_ERROR_TLB_PARITY,
+					     NULL);
 		if ((rv & ~NOTIFY_STOP_MASK) != NOTIFY_OK) {
 			unsigned int coreid = cvmx_get_core_num();
 
@@ -447,9 +456,10 @@ void octeon_cache_init(void)
 	flush_cache_range		= octeon_flush_cache_range;
 	flush_cache_sigtramp		= octeon_flush_cache_sigtramp;
 	flush_icache_all		= octeon_flush_icache_all;
+	local_flush_icache_all		= octeon_local_flush_icache_all;
 	flush_data_cache_page		= octeon_flush_data_cache_page;
 	flush_icache_range		= octeon_flush_icache_range;
-	local_flush_icache_range	= local_octeon_flush_icache_range;
+	local_flush_icache_range	= octeon_local_flush_icache_range;
 
 	__flush_kernel_vmap_range	= octeon_flush_kernel_vmap_range;
 
diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c
index fde7e56..61b01c1 100644
--- a/arch/mips/mm/cache.c
+++ b/arch/mips/mm/cache.c
@@ -44,6 +44,8 @@ void (*flush_cache_sigtramp)(unsigned long addr);
 void (*local_flush_data_cache_page)(void * addr);
 void (*flush_data_cache_page)(unsigned long addr);
 void (*flush_icache_all)(void);
+void (*local_flush_icache_all)(void);
+EXPORT_SYMBOL(local_flush_icache_all);
 
 EXPORT_SYMBOL_GPL(local_flush_data_cache_page);
 EXPORT_SYMBOL(flush_data_cache_page);
@@ -214,7 +216,8 @@ void cpu_cache_init(void)
 
 		octeon_cache_init();
 	}
-
+	if (!local_flush_icache_all)
+		local_flush_icache_all = flush_icache_all;
 	setup_protection_map();
 }
 
-- 
1.8.2.1

