From 8b1c7cc62ebd37eecc38ab83732462ebc451650c Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 13 Feb 2015 14:49:51 +0530
Subject: [PATCH 094/148] Although the existing code appears to work on most
 hardware, the hardware designers tell us that 8-bit access to the registers
 is not guaranteed to be reliable. Also the OCTEON simulation environments
 prohibit 8-bit accesses.

Commit 2ba3bc75440dec63efc0d25182e43e1683a141d3 from
git://git.yoctoproject.org/linux-yocto-3.14

For these reasons, we use __raw_readq/__raw_writeq for OCTEON.  This
code is protected with #ifdef CONFIG_64BIT so it still builds under
configurations lacking readq/writeq.

We can get rid of the #ifdef __BIG_ENDIAN, as under 64-bit accesses,
OCTEON is byte order invariant.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Aleksey Makarov <aleksey.makarov@auriga.com>
Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
Signed-off-by: Abhishek Paliwal <abhishek.paliwal@aricent.com>
---
 drivers/tty/serial/8250/8250_dw.c | 68 +++++++++++++++++++++++++++------------
 1 file changed, 47 insertions(+), 21 deletions(-)

diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
index ed31135..451c282 100644
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -60,6 +60,7 @@ struct dw8250_data {
 	int			line;
 	struct clk		*clk;
 	struct uart_8250_dma	dma;
+	bool			no_ucv;
 };
 
 static inline int dw8250_modify_msr(struct uart_port *p, int offset, int value)
@@ -82,6 +83,42 @@ static void dw8250_force_idle(struct uart_port *p)
 	(void)p->serial_in(p, UART_RX);
 }
 
+#ifdef CONFIG_64BIT
+static unsigned int dw8250_serial_inq(struct uart_port *p, int offset)
+{
+	offset <<= p->regshift;
+
+	return (u8)__raw_readq(p->membase + offset);
+}
+
+static void dw8250_serial_outq(struct uart_port *p, int offset, int value)
+{
+	struct dw8250_data *d = p->private_data;
+
+	if (offset == UART_MCR)
+		d->last_mcr = value;
+
+	offset <<= p->regshift;
+	value &= 0xff;
+	__raw_writeq(value, p->membase + offset);
+	/* Read back to ensure the register write ordering. */
+	 __raw_readq(p->membase + (UART_LCR << p->regshift));
+
+	/* Make sure LCR write wasn't ignored */
+	if (offset == UART_LCR) {
+		int tries = 1000;
+		while (tries--) {
+			unsigned int lcr = p->serial_in(p, UART_LCR);
+			if ((value & ~UART_LCR_SPAR) == (lcr & ~UART_LCR_SPAR))
+				return;
+			dw8250_force_idle(p);
+			__raw_writeq(value, p->membase + (UART_LCR << p->regshift));
+		}
+		dev_err(p->dev, "Couldn't set LCR to %d\n", value);
+	}
+}
+#endif /* CONFIG_64BIT */
+
 static void dw8250_serial_out(struct uart_port *p, int offset, int value)
 {
 	struct dw8250_data *d = p->private_data;
@@ -112,13 +149,6 @@ static unsigned int dw8250_serial_in(struct uart_port *p, int offset)
 	return dw8250_modify_msr(p, offset, value);
 }
 
-/* Read Back (rb) version to ensure register access ording. */
-static void dw8250_serial_out_rb(struct uart_port *p, int offset, int value)
-{
-	dw8250_serial_out(p, offset, value);
-	dw8250_serial_in(p, UART_LCR);
-}
-
 static void dw8250_serial_out32(struct uart_port *p, int offset, int value)
 {
 	struct dw8250_data *d = p->private_data;
@@ -223,23 +253,18 @@ static int dw8250_probe_of(struct uart_port *p,
 {
 	struct device_node	*np = p->dev->of_node;
 	u32			val;
-	bool has_ucv = true;
 
+#ifdef CONFIG_64BIT
 	if (of_device_is_compatible(np, "cavium,octeon-3860-uart")) {
-#ifdef __BIG_ENDIAN
-		/*
-		 * Low order bits of these 64-bit registers, when
-		 * accessed as a byte, are 7 bytes further down in the
-		 * address space in big endian mode.
-		 */
-		p->membase += 7;
-#endif
-		p->serial_out = dw8250_serial_out_rb;
+		p->serial_in = dw8250_serial_inq;
+		p->serial_out = dw8250_serial_outq;
 		p->flags = ASYNC_SKIP_TEST | UPF_SHARE_IRQ | UPF_FIXED_TYPE;
 		p->type = PORT_OCTEON;
 		data->usr_reg = 0x27;
-		has_ucv = false;
-	} else if (!of_property_read_u32(np, "reg-io-width", &val)) {
+		data->no_ucv = true;
+	} else
+#endif
+	if (!of_property_read_u32(np, "reg-io-width", &val)) {
 		switch (val) {
 		case 1:
 			break;
@@ -253,8 +278,6 @@ static int dw8250_probe_of(struct uart_port *p,
 			return -EINVAL;
 		}
 	}
-	if (has_ucv)
-		dw8250_setup_port(container_of(p, struct uart_8250_port, port));
 
 	if (!of_property_read_u32(np, "reg-shift", &val))
 		p->regshift = val;
@@ -362,6 +385,9 @@ static int dw8250_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
+	if (!data->no_ucv)
+		dw8250_setup_port(&uart);
+
 	data->line = serial8250_register_8250_port(&uart);
 	if (data->line < 0)
 		return data->line;
-- 
1.8.2.1

