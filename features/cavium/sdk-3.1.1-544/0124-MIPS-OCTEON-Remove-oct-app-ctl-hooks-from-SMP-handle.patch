From 8842906d9ac9f8b2e3a5dc053590083a489fa914 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Tue, 12 Aug 2014 16:53:06 -0700
Subject: [PATCH 124/202] MIPS: OCTEON: Remove oct-app-ctl hooks from SMP
 handlers.

The oct-app-ctl support is moved to a separate file in a follow-on
patch.

This allows us to use the cvmx-boot-vector support rather than
specific bootloader supplied code and structures.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.1-544]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/smp.c                      | 326 +++------------------
 .../asm/mach-cavium-octeon/kernel-entry-init.h     |  22 +-
 arch/mips/include/asm/octeon/octeon.h              |   1 -
 3 files changed, 42 insertions(+), 307 deletions(-)

diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index 6405b24..77f2a7e 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -3,38 +3,35 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2004 - 2013 Cavium, Inc.
+ * Copyright (C) 2004 - 2014 Cavium, Inc.
  */
 #include <linux/cpu.h>
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/smp.h>
 #include <linux/interrupt.h>
-#include <linux/kernel_stat.h>
 #include <linux/sched.h>
-#include <linux/module.h>
 
-#include <asm/mmu_context.h>
 #include <asm/time.h>
 #include <asm/setup.h>
+#include <asm/cacheflush.h>
+#include <asm/tlbflush.h>
 
 #include <asm/octeon/octeon.h>
-#include <asm/octeon/octeon-boot-info.h>
-#include <asm/octeon/cvmx-app-hotplug.h>
-#include <asm/octeon/cvmx-spinlock.h>
+#include <asm/octeon/cvmx-boot-vector.h>
 
-unsigned long octeon_processor_boot = 0xff;
+unsigned long octeon_processor_boot = ~0ul;
 __cpuinitdata unsigned long octeon_processor_sp;
 __cpuinitdata unsigned long octeon_processor_gp;
 
 #ifdef CONFIG_HOTPLUG_CPU
-static uint32_t octeon_hotplug_entry_addr;
+static void **octeon_bootvector;
+static void *octeon_hotplug_entry_raw;
 extern asmlinkage void octeon_hotplug_entry(void);
-static struct cvmx_app_hotplug_global *octeon_hotplug_global_ptr;
-#endif
 
-uint64_t octeon_bootloader_entry_addr;
-EXPORT_SYMBOL(octeon_bootloader_entry_addr);
+/* State of each CPU. */
+DEFINE_PER_CPU(int, cpu_state);
+#endif
 
 static void octeon_icache_flush(void)
 {
@@ -164,54 +161,17 @@ static inline void octeon_send_ipi_mask(const struct cpumask *mask,
 		octeon_send_ipi_single(cpu, action);
 }
 
-#ifdef CONFIG_HOTPLUG_CPU
-
-/*
- * Initialize the content of struct * cvmx_app_hotplug_global
- * if it is allocated, atomically.
- */
-static void octeon_hotplug_global_init(void *arg)
-{
-	struct linux_app_boot_info *labi;
-	cvmx_app_hotplug_global_t *hgp = arg;
-	memset(hgp, 0, CVMX_APP_HOTPLUG_INFO_REGION_SIZE);
-
-	hgp->magic_version = CVMX_HOTPLUG_MAGIC_VERSION;
-
-	cvmx_spinlock_init(&hgp->hotplug_global_lock);
-
-	/* Get legacy LABI data structure for initial parameters */
-	labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
-
-	/* Valicate signature */
-	if (labi->labi_signature != LABI_SIGNATURE)
-		return;
-
-	/* Initialize available cores from LABI */
-	cvmx_coremask_set64(&hgp->avail_coremask,
-		(uint64_t) labi->avail_coremask);
-}
-#endif
-
 static void octeon_smp_setup(void)
 {
 	const int coreid = cvmx_get_core_num();
 	int cpus;
 	int id;
-	struct linux_app_boot_info *labi;
 #ifdef CONFIG_HOTPLUG_CPU
 	unsigned int num_cores = cvmx_octeon_num_cores();
-	struct cvmx_app_hotplug_global *hgp;
 	unsigned long t;
 #endif
 	struct cvmx_sysinfo *sysinfo = cvmx_sysinfo_get();
 
-	labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
-
-	if (labi->labi_signature == LABI_SIGNATURE) {
-		octeon_bootloader_entry_addr = labi->InitTLBStart_addr;
-	}
-
 	/* The present CPUs are initially just the boot cpu (CPU 0). */
 	for (id = 0; id < NR_CPUS; id++) {
 		set_cpu_possible(id, id == 0);
@@ -233,14 +193,15 @@ static void octeon_smp_setup(void)
 		}
 	}
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
-		return;
-
 #ifdef CONFIG_HOTPLUG_CPU
-	t = __pa_symbol(octeon_hotplug_entry);
 
-	if (t < 0x20000000)
-		octeon_hotplug_entry_addr = (uint32_t)CKSEG0ADDR(t);
+	octeon_bootvector = cvmx_boot_vector_get();
+	if (!octeon_bootvector) {
+		pr_err("Error: Cannot allocate boot vector.\n");
+		return;
+	}
+	t = __pa_symbol(octeon_hotplug_entry);
+	octeon_hotplug_entry_raw = phys_to_virt(t);
 
 	/*
 	 * The possible CPUs are all those present on the chip.	 We
@@ -255,37 +216,6 @@ static void octeon_smp_setup(void)
 			cpus++;
 		}
 	}
-
-	/* Atomically allocate Hotplug global structure */
-	/* must be KSEG0-addresable to support N32 hotplugged apps */
-	hgp = (struct cvmx_app_hotplug_global *)
-		cvmx_bootmem_alloc_named_range_once(
-			CVMX_APP_HOTPLUG_INFO_REGION_SIZE,
-			0x0, 1ull << 29, 0,
-			CVMX_APP_HOTPLUG_INFO_REGION_NAME,
-			octeon_hotplug_global_init
-		);
-	if (!hgp) {
-		pr_err("Failed to allocate memory for Hotplug memory block\n");
-		octeon_hotplug_entry_addr = 0;
-		return;
-	}
-
-	/* Validate magic number */
-	if (hgp->magic_version != CVMX_HOTPLUG_MAGIC_VERSION) {
-		pr_err("Cavium Hotplug: data record invalid\n");
-		octeon_hotplug_entry_addr = 0;
-		return;
-	}
-#if 0
-	/* Convert coremask to string for printing */
-	cvmx_coremask_bmp2str(&hgp->avail_coremask, hexstr);
-
-	/* Print the available coremask on to the console */
-	pr_info("Cavium Hotplug: Available coremask 0x%s\n", hexstr);
-#endif
-	/* Set global ptr for use by other functions */
-	octeon_hotplug_global_ptr = hgp;
 #endif
 }
 
@@ -320,6 +250,9 @@ static void __cpuinit octeon_boot_secondary(int cpu, struct task_struct *idle)
 	}
 	if (count == 0)
 		pr_err("Secondary boot timeout\n");
+
+	octeon_processor_boot = ~0ul;
+	mb();
 }
 
 /**
@@ -378,6 +311,8 @@ void octeon_prepare_cpus(unsigned int max_cpus)
 static void octeon_smp_finish(void)
 {
 	octeon_user_io_init();
+	per_cpu(cpu_state, smp_processor_id()) = CPU_ONLINE;
+	mb();
 
 	/* to generate the first CPU timer interrupt */
 	write_c0_compare(read_c0_count() + mips_hpt_frequency / HZ);
@@ -389,42 +324,10 @@ static void octeon_smp_finish(void)
  */
 static void octeon_cpus_done(void)
 {
-#ifdef CONFIG_HOTPLUG_CPU
-	struct cvmx_app_hotplug_global *hgp;
-	struct cvmx_sysinfo *sysinfo = cvmx_sysinfo_get();
-	unsigned int cpu;
-
-	hgp = octeon_hotplug_global_ptr;
-
-	/* Boot core_mask is only used during boot-time SMP setup,
-	 * and needs to be cleared for CPU_HOTPLUG to work
-	 * with these and other cores.
-	 */
-	cvmx_coremask_clear_all(&sysinfo->core_mask);
-
-	/* Boot core_mask CPUs are now all on-line,
-	 * make the rest of the CPUs available for HOTPLUG
-	 * regardless if they are presently available
-	 */
-	for_each_possible_cpu(cpu) {
-		if (!cpu_online(cpu))
-			set_cpu_present(cpu, true);
-	}
-#if 0
-	/* Convert coremask to string for printing */
-	cvmx_coremask_bmp2str(&hgp->avail_coremask, hexstr);
-
-	/* Print the available coremask on to the console */
-	pr_info("Cavium Hotplug: Available coremask 0x%s\n", hexstr);
-#endif
-#endif
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
 
-/* State of each CPU. */
-DEFINE_PER_CPU(int, cpu_state);
-
 extern void fixup_irqs(void);
 
 static int octeon_cpu_disable(void)
@@ -445,198 +348,39 @@ static int octeon_cpu_disable(void)
 
 static void octeon_cpu_die(unsigned int cpu)
 {
-	int coreid = cpu_logical_map(cpu);
-	int node;
-	struct cvmx_app_hotplug_global *hgp = octeon_hotplug_global_ptr;
-
-	BUG_ON(!hgp);
-
 	while (per_cpu(cpu_state, cpu) != CPU_DEAD)
 		cpu_relax();
-
-	cvmx_spinlock_lock(&hgp->hotplug_global_lock);
-	cvmx_coremask_set_core(&hgp->avail_coremask, coreid);
-	cvmx_spinlock_unlock(&hgp->hotplug_global_lock);
-
-	mb();
-#if 0
-	/* Convert coremask to string for printing */
-	cvmx_coremask_bmp2str(&hgp->avail_coremask, hexstr);
-	pr_info("Reset core %d. Available Coremask = 0x%s\n", coreid, hexstr);
-#endif
-	/* Covert coreid to node/core spec and send NMI to target core */
-	node = cvmx_coremask_core_to_node(coreid);
-	coreid = cvmx_coremask_core_on_node(coreid);
-	cvmx_write_csr_node(node, CVMX_CIU_NMI, (1 << coreid));
 }
 
 void play_dead(void)
 {
 	int cpu = cpu_number_map(cvmx_get_core_num());
-	register unsigned long v;
-	v = ~0ULL;
-
 	idle_task_exit();
-	octeon_processor_boot = v;
 	per_cpu(cpu_state, cpu) = CPU_DEAD;
-
-	wmb(); /* nudge writeback */
-
+	mb();
+	local_irq_disable();
 	while (1) {	/* core will be reset here */
-		asm volatile ("nop\n wait\n nop\n");
+		asm volatile ("nop\n"
+			      "	wait\n"
+			      "	nop\n");
 	}
 }
 
-/*
- * Find the location of the system-wide boot vector table
- * for a given node.
- */
-static boot_init_vector_t *octeon_get_boot_vector(unsigned node)
-{
-	boot_init_vector_t *boot_vect;
-	cvmx_mio_boot_loc_cfgx_t boot_loc_cfg;
-	uint64_t addr = 0, io_addr, magic, vector;
-
-#ifdef OCTEON_BOOT_VECTOR_LOCATOR_NAME
-	/*
-	 * Try to locate boot vector using its name,
-	 * in case the address has been overwritten
-	 * in BOOT_MIO region.
-	 */
-	const cvmx_bootmem_named_block_desc_t *desc;
-	char name[32], n[2] = "0";
-
-	strcpy(name, OCTEON_BOOT_VECTOR_LOCATOR_NAME);
-	n[0] += node;
-	strcat(name, n);
-
-	pr_debug("%s: block name '%s'\n", __func__, name);
-
-	desc = cvmx_bootmem_find_named_block(name);
-	if (desc != NULL)
-		addr  = desc->base_addr;
-
-	if (addr != 0) {
-		/* Convert to virtual address */
-		boot_vect = cvmx_phys_to_ptr(addr);
-
-		pr_debug("boot_vect location paddr %#llx, vaddr %p\n",
-			(unsigned long long)addr, boot_vect);
-
-		/* Use vector table address located by name */
-		return boot_vect;
-	}
-#endif
-
-	boot_loc_cfg.u64 = cvmx_read_csr_node(node, CVMX_MIO_BOOT_LOC_CFGX(0));
-	if (!boot_loc_cfg.s.en) {
-		pr_warn("ERROR: MIO_BOOT_LOC_CFG not enabled\n");
-		goto _old_bloader;
-	}
-
-	addr = boot_loc_cfg.s.base << 7;
-	io_addr = (addr | (1ULL << 48)  | (1ULL << 63) |
-		(uint64_t)node << CVMX_NODE_IO_SHIFT);
-
-	pr_debug("Moveable address = %#llx\n", (unsigned long long) io_addr);
-
-	/* Read vector location from movable region */
-	magic = cvmx_read64_uint64(io_addr +
-		OCTEON_BOOT_MOVEABLE_MAGIC_OFFSET);
-	vector = cvmx_read64_uint64(io_addr +
-		OCTEON_BOOT_VECTOR_MOVEABLE_OFFSET);
-
-	/* Validate vector location */
-	if (magic != OCTEON_BOOT_MOVEABLE_MAGIC) {
-		pr_warn("ERROR: MOVEABLE_MAGIC invalid %#llx != %#llx\n",
-			(unsigned long long)magic,
-			(unsigned long long)OCTEON_BOOT_MOVEABLE_MAGIC);
-		goto _old_bloader;
-	}
-
-	if (vector == 0) {
-		pr_warn("ERROR: MOVEABLE_OFFSET is zero!\n");
-		goto _old_bloader;
-	}
-
-	/* Make physical address */
-	addr = vector & ~(1ULL << 63);
-
-	/* Convert to virtual address */
-	boot_vect = cvmx_phys_to_ptr(addr);
-
-	pr_debug("new boot_vect location paddr %#llx, vaddr %p\n",
-			(unsigned long long)addr, boot_vect);
-
-	return boot_vect;
-
-_old_bloader:
-	boot_vect = phys_to_virt(BOOTLOADER_BOOT_VECTOR);
-	pr_warn("WARNING: old bootloader assumed\n");
-	pr_debug("boot_vect paddr %#llx, vaddr %p\n",
-			(unsigned long long)BOOTLOADER_BOOT_VECTOR, boot_vect);
-
-	return boot_vect;
-}
-
-
-static int octeon_update_boot_vector(unsigned int cpu)
+static int octeon_up_prepare(unsigned int cpu)
 {
 	int coreid = cpu_logical_map(cpu);
 	int node;
-	struct cvmx_app_hotplug_global *hgp = octeon_hotplug_global_ptr;
-	struct boot_init_vector *boot_vect;
-	struct cvmx_sysinfo *sysinfo = cvmx_sysinfo_get();
-
-	/*
-	 * A core being brought up must be present either in the boot
-	 * core_mask or in the hotplug available coremask
-	 */
-	if ((cvmx_coremask_is_core_set(&sysinfo->core_mask, coreid))) {
-		/* CPU in boot core mask needs no further handling */
-		return 0;
-	}
-
-	/* Get boot vector address for this node */
-	boot_vect = octeon_get_boot_vector(cvmx_coremask_core_to_node(coreid));
-
-	/* Verify that required entry points are known at this stage */
-	if (!hgp || !octeon_hotplug_entry_addr || !boot_vect ||
-			!octeon_bootloader_entry_addr) {
-		pr_warn("Cavium Hotplug: boot-loader incompatible with Hotplug\n");
-		return -EINVAL;
-	}
-
-	/* Verify that coreid does not exceed the number of vector slots */
-	if (coreid >= CVMX_MAX_CORES) {
-		pr_warn("Cavium Hotplug: physical core %d is out of range\n",
-			coreid );
-		return -EINVAL;
-	}
-
-	cvmx_spinlock_lock(&hgp->hotplug_global_lock);
-	if (!cvmx_coremask_is_core_set(&hgp->avail_coremask, coreid)) {
-		cvmx_spinlock_unlock(&hgp->hotplug_global_lock);
-		pr_warn("Cavium Hotplug: cpu %u core %u is not available\n",
-			cpu, coreid);
-		return -EBUSY;
-	}
-
-	/* This core is no longer available */
-	cvmx_coremask_clear_core(&hgp->avail_coremask, coreid);
-	cvmx_spinlock_unlock(&hgp->hotplug_global_lock);
-
-	/* boot_vect array has CVMX_MAX_CORES slots */
-	boot_vect[coreid].app_start_func_addr = octeon_hotplug_entry_addr;
-	boot_vect[coreid].code_addr = octeon_bootloader_entry_addr;
 
+	per_cpu(cpu_state, smp_processor_id()) = CPU_UP_PREPARE;
+	octeon_bootvector[coreid] = octeon_hotplug_entry_raw;
 	mb();
-
 	/* Convert coreid to node,core spair and send NMI to target core */
 	node = cvmx_coremask_core_to_node(coreid);
 	coreid = cvmx_coremask_core_on_node(coreid);
-	cvmx_write_csr_node(node, CVMX_CIU_NMI, (1 << coreid));
-
+	if (octeon_has_feature(OCTEON_FEATURE_CIU3))
+		cvmx_write_csr_node(node, CVMX_CIU3_NMI, (1ull << coreid));
+	else
+		cvmx_write_csr(CVMX_CIU_NMI, (1 << coreid));
 	return 0;
 }
 
@@ -649,7 +393,7 @@ static int __cpuinit octeon_cpu_callback(struct notifier_block *nfb,
 	switch (action) {
 	case CPU_UP_PREPARE_FROZEN:
 	case CPU_UP_PREPARE:
-		ret = octeon_update_boot_vector(cpu);
+		ret = octeon_up_prepare(cpu);
 		if (ret)
 			return notifier_from_errno(ret);
 		break;
diff --git a/arch/mips/include/asm/mach-cavium-octeon/kernel-entry-init.h b/arch/mips/include/asm/mach-cavium-octeon/kernel-entry-init.h
index dfd6508..c06a618 100644
--- a/arch/mips/include/asm/mach-cavium-octeon/kernel-entry-init.h
+++ b/arch/mips/include/asm/mach-cavium-octeon/kernel-entry-init.h
@@ -29,7 +29,6 @@
 	.set arch=octeon
 #ifdef CONFIG_HOTPLUG_CPU
 	b	7f
-	nop
 
 FEXPORT(octeon_hotplug_entry)
 	move	a0, zero
@@ -38,22 +37,14 @@ FEXPORT(octeon_hotplug_entry)
 	move	a3, zero
 7:
 #endif	/* CONFIG_HOTPLUG_CPU */
-#ifdef	CONFIG_CPU_LITTLE_ENDIAN
-	.set push
-	.set noreorder
-	/* Hotpplugged CPUs enter in Big-Endian mode, switch here to LE */
-	dmfc0   v0, CP0_CVMCTL_REG
-	nop
-	ori     v0, v0, 2
-	nop
-	dmtc0   v0, CP0_CVMCTL_REG	/* little-endian */
-	nop
-	synci	0($0)
-	.set pop
-#endif	/* CONFIG_CPU_LITTLE_ENDIAN */
 	mfc0	v0, CP0_STATUS
 	/* Force 64-bit addressing enabled */
 	ori	v0, v0, (ST0_UX | ST0_SX | ST0_KX)
+	/* Clear NMI and SR as they are sometimes restored and 0 -> 1
+	 * transitions are not allowed
+	 */
+	li	v1, ~(ST0_NMI | ST0_SR)
+	and	v0, v1
 	mtc0	v0, CP0_STATUS
 
 	# Clear the TLB.
@@ -157,11 +148,12 @@ FEXPORT(octeon_hotplug_entry)
 	dsllv	v1, v1, t1
 	daddu	v1, v1, t3
 	sd	v1, 0(v0)
+#endif
 	dla	v0, continue_in_mapped_space
 	jr	v0
 
 continue_in_mapped_space:
-#endif
+
 	mfc0	v1, CP0_PRID_REG
 	andi	v1, 0xff00
 	li	v0, 0x9500		# cn78XX or later
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 21b3852..546c329 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -391,7 +391,6 @@ static inline uint32_t octeon_npi_read32(uint64_t address)
 
 extern struct cvmx_bootinfo *octeon_bootinfo;
 
-extern uint64_t octeon_bootloader_entry_addr;
 extern u32 octeon_cvmseg_lines;
 
 static inline uint64_t octeon_read_ptp_csr(u64 csr)
-- 
1.8.2.1

