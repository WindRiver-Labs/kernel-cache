From 25e446bccf900d397c352752d8c081d32423bf0e Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 13 Feb 2015 13:52:35 +0530
Subject: [PATCH 039/148] usb: Convert {ohci,ehci}-octeon.c to use device tree.

Commit 6d085de3ee1ece15e54bcb381e9b075680259a58 from
git://git.yoctoproject.org/linux-yocto-3.14

Several things need to be done at one time in order to preserve
buildability:

o Quit requesting platform devices.  The device tree infrastructure now
  supplies the devices.

o Remove non device tree irq domain handling of the USB interrupts.

o Add .of_match_table for the devices.

o Configure clocking parameters from the device tree.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Signed-off-by: Abhishek Paliwal <abhishek.paliwal@aricent.com>
---
 drivers/usb/host/ehci-octeon.c    | 17 ++++++++++----
 drivers/usb/host/octeon2-common.c | 49 +++++++++++++++++++++++++++++++++++----
 drivers/usb/host/ohci-octeon.c    | 19 +++++++++++----
 3 files changed, 71 insertions(+), 14 deletions(-)

diff --git a/drivers/usb/host/ehci-octeon.c b/drivers/usb/host/ehci-octeon.c
index 9051439..e1a264f 100644
--- a/drivers/usb/host/ehci-octeon.c
+++ b/drivers/usb/host/ehci-octeon.c
@@ -19,14 +19,14 @@
 #define OCTEON_EHCI_HCD_NAME "octeon-ehci"
 
 /* Common clock init code.  */
-void octeon2_usb_clocks_start(void);
+void octeon2_usb_clocks_start(struct device *dev);
 void octeon2_usb_clocks_stop(void);
 
-static void ehci_octeon_start(void)
+static void ehci_octeon_start(struct device *dev)
 {
 	union cvmx_uctlx_ehci_ctl ehci_ctl;
 
-	octeon2_usb_clocks_start();
+	octeon2_usb_clocks_start(dev);
 
 	ehci_ctl.u64 = cvmx_read_csr(CVMX_UCTLX_EHCI_CTL(0));
 	/* Use 64-bit addressing. */
@@ -134,7 +134,7 @@ static int ehci_octeon_drv_probe(struct platform_device *pdev)
 		goto err1;
 	}
 
-	ehci_octeon_start();
+	ehci_octeon_start(&pdev->dev);
 
 	ehci = hcd_to_ehci(hcd);
 
@@ -175,6 +175,14 @@ static int ehci_octeon_drv_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static struct of_device_id ehci_octeon_match[] = {
+	{
+		.compatible = "cavium,octeon-6335-ehci",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, ehci_octeon_match);
+
 static struct platform_driver ehci_octeon_driver = {
 	.probe		= ehci_octeon_drv_probe,
 	.remove		= ehci_octeon_drv_remove,
@@ -182,6 +190,7 @@ static struct platform_driver ehci_octeon_driver = {
 	.driver = {
 		.name	= OCTEON_EHCI_HCD_NAME,
 		.owner	= THIS_MODULE,
+		.of_match_table = ehci_octeon_match,
 	}
 };
 
diff --git a/drivers/usb/host/octeon2-common.c b/drivers/usb/host/octeon2-common.c
index d24b78b..29c3078 100644
--- a/drivers/usb/host/octeon2-common.c
+++ b/drivers/usb/host/octeon2-common.c
@@ -3,12 +3,14 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2010, 2011 Cavium Networks
+ * Copyright (C) 2010 - 2012 Cavium, Inc.
  */
 
-#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/export.h>
 #include <linux/mutex.h>
 #include <linux/delay.h>
+#include <linux/of.h>
 
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-uctlx-defs.h>
@@ -17,13 +19,16 @@ static DEFINE_MUTEX(octeon2_usb_clocks_mutex);
 
 static int octeon2_usb_clock_start_cnt;
 
-void octeon2_usb_clocks_start(void)
+void octeon2_usb_clocks_start(struct device *dev)
 {
 	u64 div;
 	union cvmx_uctlx_if_ena if_ena;
 	union cvmx_uctlx_clk_rst_ctl clk_rst_ctl;
 	union cvmx_uctlx_uphy_ctl_status uphy_ctl_status;
 	union cvmx_uctlx_uphy_portx_ctl_status port_ctl_status;
+	struct device_node *uctl_node;
+	u32 clock_rate = 12000000;
+	bool is_crystal_clock = false;
 	int i;
 	unsigned long io_clk_64_to_ns;
 
@@ -35,6 +40,26 @@ void octeon2_usb_clocks_start(void)
 		goto exit;
 
 	io_clk_64_to_ns = 64000000000ull / octeon_get_io_clock_rate();
+	if (dev->of_node) {
+		const char *clock_type;
+
+		uctl_node = of_get_parent(dev->of_node);
+		if (!uctl_node) {
+			pr_err("No UCTL device node\n");
+			goto exit;
+		}
+		i = of_property_read_u32(uctl_node,
+						"refclk-frequency", &clock_rate);
+		if (i) {
+			pr_err("No UCTL \"refclk-frequency\"\n");
+			goto exit;
+		}
+		i = of_property_read_string(uctl_node,
+						"refclk-type", &clock_type);
+
+		if (!i && strcmp("crystal", clock_type) == 0)
+			is_crystal_clock = true;
+	}
 
 	/*
 	 * Step 1: Wait for voltages stable.  That surely happened
@@ -67,8 +92,22 @@ void octeon2_usb_clocks_start(void)
 
 	/* 3b */
 	/* 12MHz crystal. */
-	clk_rst_ctl.s.p_refclk_sel = 0;
-	clk_rst_ctl.s.p_refclk_div = 0;
+	clk_rst_ctl.s.p_refclk_sel = is_crystal_clock ? 0 : 1;
+	switch (clock_rate) {
+	default:
+		pr_err("Invalid UCTL clock rate of %u, using 12000000 instead\n",
+			clock_rate);
+		/* Fall through */
+	case 12000000:
+		clk_rst_ctl.s.p_refclk_div = 0;
+		break;
+	case 24000000:
+		clk_rst_ctl.s.p_refclk_div = 1;
+		break;
+	case 48000000:
+		clk_rst_ctl.s.p_refclk_div = 2;
+		break;
+	}
 	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
 
 	/* 3c */
diff --git a/drivers/usb/host/ohci-octeon.c b/drivers/usb/host/ohci-octeon.c
index 15af895..2fd117b 100644
--- a/drivers/usb/host/ohci-octeon.c
+++ b/drivers/usb/host/ohci-octeon.c
@@ -7,7 +7,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2010 Cavium Networks
+ * Copyright (C) 2010 - 2012 Cavium, Inc.
  *
  */
 
@@ -19,14 +19,14 @@
 #define OCTEON_OHCI_HCD_NAME "octeon-ohci"
 
 /* Common clock init code.  */
-void octeon2_usb_clocks_start(void);
+void octeon2_usb_clocks_start(struct device *dev);
 void octeon2_usb_clocks_stop(void);
 
-static void ohci_octeon_hw_start(void)
+static void ohci_octeon_hw_start(struct device *dev)
 {
 	union cvmx_uctlx_ohci_ctl ohci_ctl;
 
-	octeon2_usb_clocks_start();
+	octeon2_usb_clocks_start(dev);
 
 	ohci_ctl.u64 = cvmx_read_csr(CVMX_UCTLX_OHCI_CTL(0));
 	ohci_ctl.s.l2c_addr_msb = 0;
@@ -144,7 +144,7 @@ static int ohci_octeon_drv_probe(struct platform_device *pdev)
 		goto err1;
 	}
 
-	ohci_octeon_hw_start();
+	ohci_octeon_hw_start(&pdev->dev);
 
 	hcd->regs = reg_base;
 
@@ -189,6 +189,14 @@ static int ohci_octeon_drv_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static struct of_device_id ohci_octeon_match[] = {
+	{
+		.compatible = "cavium,octeon-6335-ohci",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, ohci_octeon_match);
+
 static struct platform_driver ohci_octeon_driver = {
 	.probe		= ohci_octeon_drv_probe,
 	.remove		= ohci_octeon_drv_remove,
@@ -196,6 +204,7 @@ static struct platform_driver ohci_octeon_driver = {
 	.driver = {
 		.name	= OCTEON_OHCI_HCD_NAME,
 		.owner	= THIS_MODULE,
+		.of_match_table = ohci_octeon_match,
 	}
 };
 
-- 
1.8.2.1

