From 548bdcae9bf5497a57cbb95a71bfa22ff8e3a8bf Mon Sep 17 00:00:00 2001
From: Bin Jiang <bin.jiang@windriver.com>
Date: Thu, 9 May 2013 16:28:06 +0800
Subject: [PATCH 21/22] NET: octeon-ethernet: allocate memory from the 32bit
 shared region

Source: Cavium SDK 2.3-427

Tell the driver to allocate memory for buffers from the 32bit shared
region instead of the kernel memory space.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/octeon/ethernet-defines.h |    9 +++++++++
 drivers/net/ethernet/octeon/ethernet-mem.c     |   22 ++++++++++++++++++++++
 2 files changed, 31 insertions(+)

diff --git a/drivers/net/ethernet/octeon/ethernet-defines.h b/drivers/net/ethernet/octeon/ethernet-defines.h
index 4636eb5..4a62bb1 100644
--- a/drivers/net/ethernet/octeon/ethernet-defines.h
+++ b/drivers/net/ethernet/octeon/ethernet-defines.h
@@ -51,6 +51,9 @@
  *      may be somewhat dangerous. Checks are made, but if any buffer is reused
  *      without the proper Linux cleanup, the networking stack may have very
  *      bizarre bugs.
+ *  USE_32BIT_SHARED
+ *      This define tells the driver to allocate memory for buffers from the
+ *      32bit shared region instead of the kernel memory space.
  */
 #ifndef __ETHERNET_DEFINES_H__
 #define __ETHERNET_DEFINES_H__
@@ -72,6 +75,12 @@
 #define CONFIG_CAVIUM_RESERVE32 0
 #endif
 
+#if CONFIG_CAVIUM_RESERVE32 > 0
+#define USE_32BIT_SHARED	1
+#else
+#define USE_32BIT_SHARED	0
+#endif
+
 #define USE_SKBUFFS_IN_HW           1
 #ifdef CONFIG_NETFILTER
 #define REUSE_SKBUFFS_WITHOUT_FREE  0
diff --git a/drivers/net/ethernet/octeon/ethernet-mem.c b/drivers/net/ethernet/octeon/ethernet-mem.c
index c733733..24ef661 100644
--- a/drivers/net/ethernet/octeon/ethernet-mem.c
+++ b/drivers/net/ethernet/octeon/ethernet-mem.c
@@ -207,6 +207,26 @@ void cvm_oct_mem_cleanup(void)
 }
 EXPORT_SYMBOL(cvm_oct_mem_cleanup);
 
+static int cvm_oct_bootmem_fill(struct fpa_pool *pool, int elements)
+{
+	extern u64 octeon_reserve32_memory;
+	char *memory;
+	int freed = elements;
+
+	memory = cvmx_bootmem_alloc_range(elements * pool->size, 128, octeon_reserve32_memory,
+					octeon_reserve32_memory + (CONFIG_CAVIUM_RESERVE32 << 20) - 1);
+
+	if (memory == NULL)
+		panic("Unable to allocate %u bytes for FPA pool %d\n", elements * pool->size, pool->pool);
+
+	while (freed) {
+		cvmx_fpa_free(memory, pool->pool, 0);
+		memory += pool->size;
+		freed--;
+	}
+	return elements - freed;
+}
+
 /**
  * cvm_oct_alloc_fpa_pool() - Allocate an FPA pool of the given size
  * @pool:  Requested pool number (-1 for don't care).
@@ -270,6 +290,8 @@ int cvm_oct_alloc_fpa_pool(int pool, int size)
 		/* Special packet pool */
 		cvm_oct_pools[pool].fill = cvm_oct_fill_hw_skbuff;
 		cvm_oct_pools[pool].empty = cvm_oct_free_hw_skbuff;
+	} else if (USE_32BIT_SHARED) {
+		cvm_oct_pools[pool].fill = cvm_oct_bootmem_fill;
 	} else {
 		snprintf(cvm_oct_pools[pool].kmem_name,
 			 sizeof(cvm_oct_pools[pool].kmem_name),
-- 
1.7.10.4

