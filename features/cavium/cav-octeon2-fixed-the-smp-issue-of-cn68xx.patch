From f53f1703b6a34d005c9431c89e056d33428680a0 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Thu, 17 Jan 2013 20:05:46 +0800
Subject: [PATCH] cav-octeon2: fixed the smp issue of cn68xx

cn68xx is different from cn61xx/cn63xx/cn66xx in CIU.
The ciu of cn68xx need the irq_cpu_online/irq_cpu_offline too.

make the irq_enable affect all cores this is same as irq_disable.

The changes against header file is based on SDK 2.3.0-427

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c         |   17 ++++-
 arch/mips/include/asm/octeon/cvmx-ciu-defs.h |   90 +++++++++++++++++++++++++-
 2 files changed, 104 insertions(+), 3 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index 8a54d33..121f98e 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -1178,6 +1178,19 @@ static void octeon_irq_ciu2_disable_all(struct irq_data *data)
 	}
 }
 
+static void octeon_irq_ciu2_mbox_enable_all(struct irq_data *data)
+{
+	int cpu;
+	u64 mask;
+
+	mask = 1ull << (data->irq - OCTEON_IRQ_MBOX0);
+
+	for_each_online_cpu(cpu) {
+		u64 en_addr = CVMX_CIU2_EN_PPX_IP3_MBOX_W1S(octeon_coreid_for_cpu(cpu));
+		cvmx_write_csr(en_addr, mask);
+	}
+}
+
 static void octeon_irq_ciu2_mbox_disable_all(struct irq_data *data)
 {
 	int cpu;
@@ -1274,10 +1287,12 @@ static struct irq_chip octeon_irq_chip_ciu2_edge = {
 
 static struct irq_chip octeon_irq_chip_ciu2_mbox = {
 	.name = "CIU2-M",
-	.irq_enable = octeon_irq_ciu2_mbox_enable_local,
+	.irq_enable = octeon_irq_ciu2_mbox_enable_all,
 	.irq_disable = octeon_irq_ciu2_mbox_disable_all,
 	.irq_ack = octeon_irq_ciu2_mbox_disable_local,
 	.irq_eoi = octeon_irq_ciu2_mbox_enable_local,
+	.irq_cpu_online = octeon_irq_ciu2_mbox_enable_local,
+	.irq_cpu_offline = octeon_irq_ciu2_mbox_disable_local,
 };
 
 static struct irq_chip octeon_irq_chip_ciu2_wd = {
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
index 11d20c0..ae7b203 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
@@ -50,8 +50,6 @@
 #define CVMX_CIU_INTX_SUM4(offset) (CVMX_ADD_IO_SEG(0x0001070000000C00ull) + ((offset) & 15) * 8)
 #define CVMX_CIU_INT_DBG_SEL (CVMX_ADD_IO_SEG(0x00010700000007D0ull))
 #define CVMX_CIU_INT_SUM1 (CVMX_ADD_IO_SEG(0x0001070000000108ull))
-#define CVMX_CIU_MBOX_CLRX(offset) (CVMX_ADD_IO_SEG(0x0001070000000680ull) + ((offset) & 15) * 8)
-#define CVMX_CIU_MBOX_SETX(offset) (CVMX_ADD_IO_SEG(0x0001070000000600ull) + ((offset) & 15) * 8)
 #define CVMX_CIU_NMI (CVMX_ADD_IO_SEG(0x0001070000000718ull))
 #define CVMX_CIU_PCI_INTA (CVMX_ADD_IO_SEG(0x0001070000000750ull))
 #define CVMX_CIU_PP_DBG (CVMX_ADD_IO_SEG(0x0001070000000708ull))
@@ -71,6 +69,94 @@
 #define CVMX_CIU_TIMX(offset) (CVMX_ADD_IO_SEG(0x0001070000000480ull) + ((offset) & 3) * 8)
 #define CVMX_CIU_WDOGX(offset) (CVMX_ADD_IO_SEG(0x0001070000000500ull) + ((offset) & 15) * 8)
 
+static inline uint64_t CVMX_CIU_MBOX_CLRX(unsigned long offset)
+{
+	switch(cvmx_get_proc_id() & OCTEON_FAMILY_MASK) {
+		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001070000000680ull) + ((offset) & 0) * 8;
+			break;
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001070000000680ull) + ((offset) & 3) * 8;
+			break;
+		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001070000000680ull) + ((offset) & 1) * 8;
+			break;
+		case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 15))
+				return CVMX_ADD_IO_SEG(0x0001070000000680ull) + ((offset) & 15) * 8;
+			break;
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 11))
+				return CVMX_ADD_IO_SEG(0x0001070000000680ull) + ((offset) & 15) * 8;
+			break;
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 9))
+				return CVMX_ADD_IO_SEG(0x0001070000000680ull) + ((offset) & 15) * 8;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return CVMX_ADD_IO_SEG(0x0001070000000680ull) + ((offset) & 7) * 8;
+			break;
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x0001070100100600ull) + ((offset) & 31) * 8;
+			break;
+	}
+	printk(KERN_ERR "CVMX_CIU_MBOX_CLRX (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070000000680ull) + ((offset) & 3) * 8;
+}
+
+static inline uint64_t CVMX_CIU_MBOX_SETX(unsigned long offset)
+{
+	switch(cvmx_get_proc_id() & OCTEON_FAMILY_MASK) {
+		case OCTEON_CN30XX & OCTEON_FAMILY_MASK:
+			if ((offset == 0))
+				return CVMX_ADD_IO_SEG(0x0001070000000600ull) + ((offset) & 0) * 8;
+			break;
+		case OCTEON_CN52XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x0001070000000600ull) + ((offset) & 3) * 8;
+			break;
+		case OCTEON_CN31XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x0001070000000600ull) + ((offset) & 1) * 8;
+			break;
+		case OCTEON_CN38XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN58XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 15))
+				return CVMX_ADD_IO_SEG(0x0001070000000600ull) + ((offset) & 15) * 8;
+			break;
+		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 11))
+				return CVMX_ADD_IO_SEG(0x0001070000000600ull) + ((offset) & 15) * 8;
+			break;
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 9))
+				return CVMX_ADD_IO_SEG(0x0001070000000600ull) + ((offset) & 15) * 8;
+			break;
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return CVMX_ADD_IO_SEG(0x0001070000000600ull) + ((offset) & 7) * 8;
+			break;
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x0001070100100400ull) + ((offset) & 31) * 8;
+			break;
+	}
+	printk(KERN_ERR "CVMX_CIU_MBOX_SETX (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001070000000600ull) + ((offset) & 3) * 8;
+}
+
 union cvmx_ciu_bist {
 	uint64_t u64;
 	struct cvmx_ciu_bist_s {
-- 
1.7.9.7

