From c188018fd6a584bef993dbf7e600fb8628db3ef9 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Sun, 23 Feb 2014 13:46:59 -0800
Subject: [PATCH 556/974] MIPS: OCTEON: Update S.E. to r99089.

Must change octeon3-ethernet.c to match.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c | 42 +++++++++++++---------
 .../cavium-octeon/executive/cvmx-helper-pko3.c     | 23 +++++++++---
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      |  5 ++-
 arch/mips/include/asm/octeon/cvmx-helper-pko3.h    |  2 +-
 drivers/net/ethernet/octeon/octeon3-ethernet.c     |  2 +-
 5 files changed, 50 insertions(+), 24 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index dd8fc82..03e4eec 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -370,9 +370,12 @@ int __cvmx_helper_bgx_sgmii_enable(int xiface)
 	for (index = 0; index < num_ports; index++) {
 		gmp_txx_append.u64 = cvmx_read_csr_node(node,
 					CVMX_BGXX_GMP_GMI_TXX_APPEND(index, interface));
+#if 0
+		/* FCS/PAD options are set in cvmx_helper_bgx_tx_options() */
 		gmp_txx_append.s.fcs = 0;
 		gmp_txx_append.s.pad = 0;
 		cvmx_write_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_APPEND(index, interface), gmp_txx_append.u64);
+#endif
 
 		gmp_sgmii_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(index, interface));
 		gmp_sgmii_ctl.s.align = gmp_txx_append.s.preamble ? 0 : 1;
@@ -1084,13 +1087,9 @@ int __cvmx_helper_bgx_xaui_enable(int xiface)
 	cvmx_bgxx_cmrx_config_t cmr_config;
 	int index;
 	int num_ports = cvmx_helper_ports_on_interface(xiface);
-	cvmx_helper_interface_mode_t mode;
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int interface = xi.interface;
 	int node = xi.node;
-	unsigned credit;
-
-	mode = cvmx_helper_interface_get_mode(xiface);
 
 	__cvmx_bgx_common_init(xiface);
 	for (index = 0; index < num_ports; index++) {
@@ -1100,17 +1099,11 @@ int __cvmx_helper_bgx_xaui_enable(int xiface)
 			return res;
 		}
 
-		/* Set credit to 1/4 of actual LMAC FIFO size */
-		if (mode == CVMX_HELPER_INTERFACE_MODE_10G_KR
-		    || mode == CVMX_HELPER_INTERFACE_MODE_XFI)
-			credit = 2 * 1024 * 1;
-		else if (num_ports == 2)
-			credit = 2 * 1024 * 2;
-		else
-			credit = 2 * 1024 * 4;
-
 		smu_tx_thresh.u64 = 0;
-		smu_tx_thresh.s.cnt = credit / 16;
+		/* Hopefully big enough to avoid underrun, but not too
+		 * big to adversly effect shaping.
+		 */
+		smu_tx_thresh.s.cnt = 0x100;
 		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_THRESH(index, interface),
 					smu_tx_thresh.u64);
 
@@ -1318,16 +1311,33 @@ void cvmx_helper_bgx_rx_adr_ctl(unsigned node, unsigned interface, unsigned port
  */
 void cvmx_helper_bgx_tx_options(unsigned node,
 	unsigned interface, unsigned index,
-	bool fcs_enable,
-	bool pad_enable)
+	bool fcs_enable, bool pad_enable)
 {
 	cvmx_bgxx_cmrx_config_t cmr_config;
+	cvmx_bgxx_cmrx_config_t cmr_config0;
 	cvmx_bgxx_gmp_gmi_txx_append_t gmp_txx_append;
+	cvmx_bgxx_gmp_gmi_txx_min_pkt_t gmp_min_pkt;
 	cvmx_bgxx_smux_tx_append_t  smu_tx_append;
 
+	cmr_config0.u64 = cvmx_read_csr_node(node,
+		CVMX_BGXX_CMRX_CONFIG(0, interface));
 	cmr_config.u64 = cvmx_read_csr_node(node,
 		CVMX_BGXX_CMRX_CONFIG(index, interface));
+
+	/* Temp: initial mode setting is only applied to LMAC(0), use that */
+	if (cmr_config0.s.lmac_type != cmr_config.s.lmac_type) {
+		cvmx_dprintf("WARNING: %s: "
+			"BGX(%d).CMR(0).LMAC_TYPE != BGX(%d).CMR(%d).LMAC_TYPE\n",
+			__func__, interface, interface, index);
+		cmr_config.s.lmac_type = cmr_config0.s.lmac_type;
+	}
+
 	if (cmr_config.s.lmac_type == 0) {
+		gmp_min_pkt.u64 = 0;
+		gmp_min_pkt.s.min_size = 0x40;
+		cvmx_write_csr_node(node,
+                        CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(index, interface),
+			gmp_min_pkt.u64);
 		gmp_txx_append.u64 = cvmx_read_csr_node(node,
 			CVMX_BGXX_GMP_GMI_TXX_APPEND(index, interface));
 		gmp_txx_append.s.fcs = fcs_enable;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index 84148a9..2579d2a 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -776,10 +776,9 @@ static int __cvmx_pko3_config_null_interface(unsigned int node)
 /** Open all descriptor queues belonging to an interface/port
  * @INTERNAL
  */
-int __cvmx_pko3_helper_dqs_activate(int xiface, int index)
+int __cvmx_pko3_helper_dqs_activate(int xiface, int index, bool min_pad)
 {
 	int  ipd_port,dq_base, dq_count, i;
-	bool min_pad = __cvmx_helper_get_pko_padding(xiface);
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 
 	/* Get local IPD port for the interface */
@@ -932,7 +931,17 @@ int cvmx_helper_pko3_init_interface(int xiface)
 	/* Setup interface options */
 	for (subif = 0; subif < num_ports; subif++) {
 		/* Open interface/port DQs to allow transmission to begin */
-		res = __cvmx_pko3_helper_dqs_activate(xiface, subif);
+#ifdef	__PKO_MINPAD_FIXED
+		res = __cvmx_pko3_helper_dqs_activate(xiface,
+			subif, pad_enable);
+#else
+		if (mode == CVMX_HELPER_INTERFACE_MODE_ILK)
+			res = __cvmx_pko3_helper_dqs_activate(xiface,
+				subif, pad_enable);
+		else
+			res = __cvmx_pko3_helper_dqs_activate(xiface,
+				subif, false);
+#endif
 		if (res < 0)
 			goto __cfg_error;
 
@@ -951,10 +960,14 @@ int cvmx_helper_pko3_init_interface(int xiface)
 		res = cvmx_pko3_interface_options(xiface, subif,
 				  fcs_enable, pad_enable, fcs_sof_off);
 #else
-		if (mode == CVMX_HELPER_INTERFACE_MODE_ILK) {
+		if (xi.interface > 5) {
+			/* Not BGX, use PKO FCS but not PAD as it is broken */
 			res = cvmx_pko3_interface_options(xiface, subif,
-				  fcs_enable, pad_enable, fcs_sof_off);
+				  fcs_enable,
+				/* pad_enable */false,
+				fcs_sof_off);
 		} else {
+			/* Use BGX feature because PKO NONPAD i sbroken */
 			res = cvmx_pko3_interface_options(xiface, subif,
 				  false, false, fcs_sof_off);
 			cvmx_helper_bgx_tx_options(xi.node, xi.interface, subif,
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index 34148f4..8934e77 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -772,7 +772,10 @@ static int cvmx_pko_setup_macs(int node)
 		cvmx_write_csr_node(node, CVMX_PKO_MCI0_MAX_CREDX(mac_num),
 					pko_mci0_max_cred.u64);
 
-		tmp = (mac_credit + skid_credit) / 16;
+		/* XXX this is the latest HW recommended formula XXX */
+		tmp = (mac_credit + skid_credit) / 16; 
+		/* but we use this one for now, due to simulator */
+		tmp = (mac_credit) / 16;
 		pko_mci1_max_cred.u64 = 0;
 		pko_mci1_max_cred.s.max_cred_lim = tmp;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-pko3.h b/arch/mips/include/asm/octeon/cvmx-helper-pko3.h
index e1265d9..b6ef601 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-pko3.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-pko3.h
@@ -80,7 +80,7 @@ int __cvmx_pko3_config_gen_interface(int xiface, uint8_t subif,
  *
  */
 int cvmx_helper_pko3_init_interface(int xiface);
-int __cvmx_pko3_helper_dqs_activate(int xiface, int index);
+int __cvmx_pko3_helper_dqs_activate(int xiface, int index, bool min_pad);
 
 /**
  * Uninitialize PKO3 interface
diff --git a/drivers/net/ethernet/octeon/octeon3-ethernet.c b/drivers/net/ethernet/octeon/octeon3-ethernet.c
index c8a862b..af17218 100644
--- a/drivers/net/ethernet/octeon/octeon3-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon3-ethernet.c
@@ -593,7 +593,7 @@ static int octeon3_eth_ndo_init(struct net_device *netdev)
 	if (r)
 		return -ENODEV;
 
-	r = __cvmx_pko3_helper_dqs_activate(priv->xiface, priv->port_index);
+	r = __cvmx_pko3_helper_dqs_activate(priv->xiface, priv->port_index, false);
 	if (r < 0)
 		return -ENODEV;
 
-- 
2.6.2

