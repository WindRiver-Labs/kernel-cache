From b4bd20f1dc4f4831ef7deb9322a22f7d99f4f412 Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Wed, 16 Jul 2014 18:05:50 -0700
Subject: [PATCH 876/974] netdev: octeon-bgx-nexus: Unregister devices on exit.

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/octeon/octeon-bgx-nexus.c | 45 ++++++++++++++++++++++++++
 1 file changed, 45 insertions(+)

diff --git a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
index 173710f..dcedb61 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
@@ -78,6 +78,16 @@ static struct mix_port_lmac mix_port_lmacs[MAX_MIX];
 /* pki_ports keeps track of the lmacs connected to the pki */
 static bool pki_ports[MAX_NODES][MAX_BGX_PER_NODE][MAX_LMAC_PER_NODE];
 
+/* Created platform devices get added to this list */
+static struct list_head pdev_list;
+static struct mutex pdev_list_lock;
+
+/* Created platform device use this structure to add themselves to the list */
+struct pdev_list_item {
+	struct list_head	list;
+	struct platform_device	*pdev;
+};
+
 /* is_lmac_to_mix:		Search the list of lmacs connected to mix'es
  *				for a match.
  *
@@ -156,6 +166,7 @@ static int bgx_probe(struct platform_device *pdev)
 		bool is_mix = false;
 		bool is_pki = false;
 		union cvmx_bgxx_cmrx_config cmr_config;
+		struct pdev_list_item *pdev_item;
 
 		if (!of_device_is_compatible(child, "cavium,octeon-7890-bgx-port"))
 			continue;
@@ -185,11 +196,30 @@ static int bgx_probe(struct platform_device *pdev)
 		platform_data.interface = interface;
 		platform_data.port = port;
 
+		/* Add device to the list of created devices so we can remove it
+		 * on exit.
+		 */
+		pdev_item = kmalloc(sizeof(*pdev_item), GFP_KERNEL);
+		pdev_item->pdev = new_dev;
+		mutex_lock(&pdev_list_lock);
+		list_add(&pdev_item->list, &pdev_list);
+		mutex_unlock(&pdev_list_lock);
+
 		pki_dev = platform_device_register_data(&new_dev->dev,
 							is_mix ? "octeon_mgmt" : "ethernet-mac-pki",
 							pki_id++,
 							&platform_data, sizeof(platform_data));
 		dev_info(&pdev->dev, "Created %s %u: %p\n", is_mix ? "MIX" : "PKI", pki_dev->id, pki_dev);
+
+		/* Add device to the list of created devices so we can remove it
+		 * on exit.
+		 */
+		pdev_item = kmalloc(sizeof(*pdev_item), GFP_KERNEL);
+		pdev_item->pdev = pki_dev;
+		mutex_lock(&pdev_list_lock);
+		list_add(&pdev_item->list, &pdev_list);
+		mutex_unlock(&pdev_list_lock);
+
 #ifdef CONFIG_NUMA
 		new_dev->dev.numa_node = pdev->dev.numa_node;
 		pki_dev->dev.numa_node = pdev->dev.numa_node;
@@ -630,6 +660,9 @@ static int __init bgx_driver_init(void)
 {
 	int r;
 
+	INIT_LIST_HEAD(&pdev_list);
+	mutex_init(&pdev_list_lock);
+
 	bgx_mix_port_lmacs_init();
 	bgx_pki_ports_init();
 
@@ -640,6 +673,18 @@ static int __init bgx_driver_init(void)
 
 static void __exit bgx_driver_exit(void)
 {
+	struct pdev_list_item *pdev_item;
+
+	mutex_lock(&pdev_list_lock);
+	while (!list_empty(&pdev_list)) {
+		pdev_item = list_first_entry(&pdev_list, struct pdev_list_item,
+					     list);
+		list_del(&pdev_item->list);
+		platform_device_unregister(pdev_item->pdev);
+		kfree(pdev_item);
+	}
+	mutex_unlock(&pdev_list_lock);
+
 	platform_driver_unregister(&bgx_driver);
 }
 
-- 
2.6.2

