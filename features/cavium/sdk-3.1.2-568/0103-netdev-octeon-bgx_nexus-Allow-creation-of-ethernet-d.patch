From 87f85cd109561c2427b97976d15845c12eccfb42 Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Tue, 10 Mar 2015 13:09:08 -0700
Subject: [PATCH 103/184] netdev: octeon-bgx_nexus: Allow creation of ethernet
 devices on demand.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 9c2ad4f715bd23e4be3d3e6bf37acae49624df97
Description:

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/octeon/octeon-bgx-nexus.c | 245 ++++++++++++++++++++++++-
 1 file changed, 243 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
index 109a2a1..8459bce 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
@@ -42,11 +42,16 @@
 
 static atomic_t bgx_nexus_once;
 static atomic_t request_ethernet3_once;
+static atomic_t request_mgmt_once;
 
 static char *mix_port;
 module_param(mix_port, charp, S_IRUGO);
 MODULE_PARM_DESC(mix_port, "Specifies which ports connect to MIX interfaces.");
 
+static char *pki_port;
+module_param(pki_port, charp, S_IRUGO);
+MODULE_PARM_DESC(pki_port, "Specifies which ports connect to the PKI.");
+
 #define MAX_NODES		2
 #define MAX_MIX_PER_NODE	2
 #define MAX_BGX_PER_NODE	6
@@ -70,6 +75,9 @@ struct mix_port_lmac {
 /* mix_ports_lmacs contains all the lmacs connected to mix ports */
 static struct mix_port_lmac mix_port_lmacs[MAX_MIX];
 
+/* pki_ports keeps track of the lmacs connected to the pki */
+static bool pki_ports[MAX_NODES][MAX_BGX_PER_NODE][MAX_LMAC_PER_NODE];
+
 /* is_lmac_to_mix:		Search the list of lmacs connected to mix'es
  *				for a match.
  *
@@ -94,6 +102,21 @@ static bool is_lmac_to_mix(int node, int bgx, int lmac)
 	return false;
 }
 
+/* is_lmac_to_pki:		Search the list of lmacs connected to the pki
+ *				for a match.
+ *
+ *  node:			Numa node of lmac to search for.
+ *  bgx:			Bgx of lmac to search for.
+ *  lmac:			Lmac index to search for.
+ *
+ *  returns:			true if the lmac is connected to the pki, false
+ *				otherwise.
+ */
+static bool is_lmac_to_pki(int node, int bgx, int lmac)
+{
+	return pki_ports[node][bgx][lmac];
+}
+
 static int bgx_probe(struct platform_device *pdev)
 {
 	struct bgx_platform_data platform_data;
@@ -130,6 +153,7 @@ static int bgx_probe(struct platform_device *pdev)
 
 	for_each_available_child_of_node(pdev->dev.of_node, child) {
 		bool is_mix = false;
+		bool is_pki = false;
 		union cvmx_bgxx_cmrx_config cmr_config;
 
 		if (!of_device_is_compatible(child, "cavium,octeon-7890-bgx-port"))
@@ -139,6 +163,11 @@ static int bgx_probe(struct platform_device *pdev)
 			return -ENODEV;
 
 		is_mix = is_lmac_to_mix(numa_node, interface, port);
+		is_pki = is_lmac_to_pki(numa_node, interface, port);
+
+		/* Check if this port should be configured */
+		if (is_mix == false && is_pki == false)
+			continue;
 
 		/* Connect to PKI/PKO */
 		cmr_config.u64 = cvmx_read_csr_node(numa_node, CVMX_BGXX_CMRX_CONFIG(port, interface));
@@ -165,8 +194,14 @@ static int bgx_probe(struct platform_device *pdev)
 		pki_dev->dev.numa_node = pdev->dev.numa_node;
 #endif
 		/* One time request driver module */
-		if (atomic_cmpxchg(&request_ethernet3_once, 0, 1) == 0)
-			request_module_nowait("octeon3-ethernet");
+		if (is_mix) {
+			if (atomic_cmpxchg(&request_mgmt_once, 0, 1) == 0)
+				request_module_nowait("octeon_mgmt");
+		}
+		if (is_pki) {
+			if (atomic_cmpxchg(&request_ethernet3_once, 0, 1) == 0)
+				request_module_nowait("octeon3-ethernet");
+		}
 	}
 
 	dev_info(&pdev->dev, "Probed\n");
@@ -350,6 +385,211 @@ static int bgx_mix_port_lmacs_init(void)
 	return 0;
 }
 
+/* bgx_parse_pki_elem:		Parse a single element (node, bgx, or lmac) out
+ *				a pki lmac string and set its bitmap
+ *				accordingly.
+ *
+ *  str:			Pki lmac string to parse.
+ *  bitmap:			Updated with the bits selected by str.
+ *  size:			Maximum size of the bitmap.
+ *
+ *  returns:			Number of characters processed from str,
+ *				error otherwise.
+ */
+static int bgx_parse_pki_elem(const char *str, unsigned long *bitmap, int size)
+{
+	const char	*p = str;
+	int		len = -1;
+	int		bit;
+
+	if (*p == 0) {
+		/* If identifier is missing, the whole subset is allowed */
+		bitmap_set(bitmap, 0, size);
+		len = 0;
+	} else if (*p == '*') {
+		/* If identifier is an asterisk, the whole subset is allowed */
+		bitmap_set(bitmap, 0, size);
+		len = 1;
+	} else if (isdigit(*p)) {
+		/* If identifier is a digit, only the bit corresponding to the
+		 * digit is set.
+		 */
+		bit = *p - '0';
+		if (bit < size) {
+			bitmap_set(bitmap, bit, 1);
+			len = 1;
+		}
+	} else if (*p == '[') {
+		/* If identifier is a bracket, all the bits corresponding to
+		 * the digits inside the bracket are set.
+		 */
+		p++;
+		len = 1;
+		do {
+			if (isdigit(*p)) {
+				bit = *p - '0';
+				if (bit < size)
+					bitmap_set(bitmap, bit, 1);
+				else
+					return -1;
+			} else
+				return -1;
+			p++;
+			len++;
+		} while (*p != ']');
+		len++;
+	} else
+		len = -1;
+
+	return len;
+}
+
+/* bgx_pki_bitmap_set:		Set the bitmap bits for all elements (node, bgx,
+ *				and lmac) selected by a pki lmac string.
+ *
+ *  str:			Pki lmac string to process.
+ *  node:			Updated with the nodes specified in the pki lmac
+ *				string.
+ *  bgx:			Updated with the bgx's specified in the pki lmac
+ *				string.
+ *  lmac:			Updated with the lmacs specified in the pki lmac
+ *				string.
+ *
+ *  returns:			Zero on success, error otherwise.
+ */
+static unsigned long bgx_pki_bitmap_set(const char *str, unsigned long *node,
+					unsigned long *bgx, unsigned long *lmac)
+{
+	const char	*p = str;
+	int		len;
+
+	/* Parse the node */
+	len = bgx_parse_pki_elem(p, node, MAX_NODES);
+	if (len < 0)
+		goto err;
+
+	/* Parse the bgx */
+	p += len;
+	len = bgx_parse_pki_elem(p, bgx, MAX_BGX_PER_NODE);
+	if (len < 0)
+		goto err;
+
+	/* Parse the lmac */
+	p += len;
+	len = bgx_parse_pki_elem(p, lmac, MAX_LMAC_PER_NODE);
+	if (len < 0)
+		goto err;
+
+	return 0;
+ err:
+	bitmap_zero(node, MAX_NODES);
+	bitmap_zero(bgx, MAX_BGX_PER_NODE);
+	bitmap_zero(lmac, MAX_LMAC_PER_NODE);
+	return len;
+
+}
+
+/* bgx_pki_init_from_param:	Initialize the list of lmacs that connect to the
+ *				pki from information in the "pki_port"
+ *				parameter.
+ *
+ *				The pki_port parameter format is as follows:
+ *				pki_port=nbl
+ *				where:
+ *					n = node
+ *					b = bgx
+ *					l = lmac
+ *
+ *				Commas must be used to separate multiple lmacs:
+ *				pki_port=000,100,110
+ *
+ *				Asterisks (*) specify all possible characters in
+ *				the subset:
+ *				pki_port=00* (all lmacs of node0 bgx0).
+ *
+ *				Missing lmacs identifiers default to all
+ *				possible characters in the subset:
+ *				pki_port=00 (all lmacs on node0 bgx0)
+ *
+ *				Brackets ('[' and ']') specify the valid
+ *				characters in the subset:
+ *				pki_port=00[01] (lmac0 and lmac1 of node0 bgx0).
+ *
+ *  returns:			Zero on success, error otherwise.
+ */
+static int bgx_pki_init_from_param(void)
+{
+	char	*cur;
+	char	*next;
+	DECLARE_BITMAP(node_bitmap, MAX_NODES);
+	DECLARE_BITMAP(bgx_bitmap, MAX_BGX_PER_NODE);
+	DECLARE_BITMAP(lmac_bitmap, MAX_LMAC_PER_NODE);
+
+	/* Parse each comma separated lmac specifier */
+	cur = pki_port;
+	while (cur) {
+		unsigned long	node;
+		unsigned long	bgx;
+		unsigned long	lmac;
+
+		bitmap_zero(node_bitmap, BITS_PER_LONG);
+		bitmap_zero(bgx_bitmap, BITS_PER_LONG);
+		bitmap_zero(lmac_bitmap, BITS_PER_LONG);
+
+		next = strchr(cur, ',');
+		if (next)
+			*next++ = '\0';
+
+		/* Convert the specifier into a bitmap */
+		bgx_pki_bitmap_set(cur, node_bitmap, bgx_bitmap, lmac_bitmap);
+
+		/* Mark the lmacs to be connected to the pki */
+		for_each_set_bit(node, node_bitmap, MAX_NODES) {
+			for_each_set_bit(bgx, bgx_bitmap, MAX_BGX_PER_NODE) {
+				for_each_set_bit(lmac, lmac_bitmap,
+						 MAX_LMAC_PER_NODE)
+					pki_ports[node][bgx][lmac] = true;
+			}
+		}
+
+		cur = next;
+	}
+
+	return 0;
+}
+
+/* bgx_pki_ports_init:		Initialize the pki_ports variable with the
+ *				lmacs that connect to the pki.
+ *
+ *  returns:			Zero on success, error otherwise.
+ */
+static int bgx_pki_ports_init(void)
+{
+	int	i, j, k;
+	bool	def_val;
+
+	/* Whether all ports default to connect to the pki or not depend on the
+	 * passed module parameter (if any).
+	 */
+	if (pki_port)
+		def_val = false;
+	else
+		def_val = true;
+
+	for (i = 0; i < MAX_NODES; i++) {
+		for (j = 0; j < MAX_BGX_PER_NODE; j++) {
+			for (k = 0; k < MAX_LMAC_PER_NODE; k++)
+				pki_ports[i][j][k] = def_val;
+		}
+	}
+
+	/* Check if ports have to be individually configured */
+	if (pki_port && strcmp(pki_port, "none"))
+		bgx_pki_init_from_param();
+
+	return 0;
+}
+
 static int bgx_remove(struct platform_device *pdev)
 {
 	return 0;
@@ -390,6 +630,7 @@ static int __init bgx_driver_init(void)
 	int r;
 
 	bgx_mix_port_lmacs_init();
+	bgx_pki_ports_init();
 
 	r = platform_driver_register(&bgx_driver);
 
-- 
1.9.1

