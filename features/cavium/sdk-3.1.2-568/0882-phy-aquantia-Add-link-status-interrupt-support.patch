From 6a3cd24d5c603164e8b853f4fac6e12218801862 Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Wed, 23 Jul 2014 18:05:50 -0700
Subject: [PATCH 882/974] phy/aquantia: Add link status interrupt support.

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/phy/aquantia.c | 60 ++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 58 insertions(+), 2 deletions(-)

diff --git a/drivers/net/phy/aquantia.c b/drivers/net/phy/aquantia.c
index 93db565..a186cfa 100644
--- a/drivers/net/phy/aquantia.c
+++ b/drivers/net/phy/aquantia.c
@@ -11,8 +11,15 @@
 
 #define PHY_ID_AQR105			0x03a1b4a0
 
-#define PMA_RECEIVE_VENDOR_STATE_1	(MII_ADDR_C45 | 1 << 16 | 0xe800)
-#define AN_VENDOR_STATUS_1		(MII_ADDR_C45 | 7 << 16 | 0xc800)
+#define PMA_RECEIVE_VENDOR_STATE_1	(MII_ADDR_C45 | 0x01 << 16 | 0xe800)
+
+#define AN_TX_VENDOR_ALARMS_2		(MII_ADDR_C45 | 0x07 << 16 | 0xcc01)
+#define AN_VENDOR_STATUS_1		(MII_ADDR_C45 | 0x07 << 16 | 0xc800)
+#define AN_TX_VENDOR_INT_MASK_2		(MII_ADDR_C45 | 0x07 << 16 | 0xd401)
+
+#define GLOBAL_CW_VENDOR_INT_FLAGS	(MII_ADDR_C45 | 0x1e << 16 | 0xfc01)
+#define GLOBAL_INT_CW_VENDOR_MASK	(MII_ADDR_C45 | 0x1e << 16 | 0xff01)
+
 
 static int aqr105_config_aneg(struct phy_device *phydev)
 {
@@ -67,6 +74,51 @@ static int aqr105_read_status(struct phy_device *phydev)
 	return 0;
 }
 
+static int  aqr105_ack_interrupt(struct phy_device *phydev)
+{
+	int	reg;
+
+	reg = phy_read(phydev, AN_TX_VENDOR_ALARMS_2);
+
+	return 0;
+}
+
+static int aqr105_config_intr(struct phy_device *phydev)
+{
+	int	reg;
+
+	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
+		reg = phy_read(phydev, AN_TX_VENDOR_INT_MASK_2);
+		reg |= 0x1;
+		phy_write(phydev, AN_TX_VENDOR_INT_MASK_2, reg);
+
+		reg = phy_read(phydev, GLOBAL_INT_CW_VENDOR_MASK);
+		reg |= 0x1000;
+		phy_write(phydev, GLOBAL_INT_CW_VENDOR_MASK, reg);
+	} else {
+		reg = phy_read(phydev, GLOBAL_INT_CW_VENDOR_MASK);
+		reg &= ~0x1000;
+		phy_write(phydev, GLOBAL_INT_CW_VENDOR_MASK, reg);
+
+		reg = phy_read(phydev, AN_TX_VENDOR_INT_MASK_2);
+		reg &= ~0x1;
+		phy_write(phydev, AN_TX_VENDOR_INT_MASK_2, reg);
+	}
+
+	return 0;
+}
+
+static int aqr105_did_interrupt(struct phy_device *phydev)
+{
+	int	reg;
+
+	reg = phy_read(phydev, GLOBAL_CW_VENDOR_INT_FLAGS);
+	if (reg & 0x1000)
+		return 1;
+
+	return 0;
+}
+
 static int aqr105_match_phy_device(struct phy_device *phydev)
 {
 	return (phydev->c45_ids.device_ids[1] & 0xfffffff0) == PHY_ID_AQR105;
@@ -77,8 +129,12 @@ static struct phy_driver aqr105_driver[] = {
 	.phy_id			= 0,
 	.phy_id_mask		= 0,
 	.name			= "Aquantia aqr105",
+	.flags			= PHY_HAS_INTERRUPT,
 	.config_aneg		= aqr105_config_aneg,
 	.read_status		= aqr105_read_status,
+	.ack_interrupt		= aqr105_ack_interrupt,
+	.config_intr		= aqr105_config_intr,
+	.did_interrupt		= aqr105_did_interrupt,
 	.match_phy_device 	= aqr105_match_phy_device,
 	.driver			= {
 		.owner = THIS_MODULE,
-- 
2.6.2

