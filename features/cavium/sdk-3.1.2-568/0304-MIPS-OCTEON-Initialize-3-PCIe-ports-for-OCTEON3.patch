From da245d2b058f392092e1a883f10763d7444b1539 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Wed, 25 Sep 2013 10:29:21 -0700
Subject: [PATCH 304/974] MIPS: OCTEON: Initialize 3 PCIe ports for OCTEON3.

Added PCIe enumeration to check for 3rd PCIe device.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/pci/pcie-octeon.c | 43 ++++++++++++++++++++++++++++++++++++-------
 1 file changed, 36 insertions(+), 7 deletions(-)

diff --git a/arch/mips/pci/pcie-octeon.c b/arch/mips/pci/pcie-octeon.c
index 5950801..e20a2fd 100644
--- a/arch/mips/pci/pcie-octeon.c
+++ b/arch/mips/pci/pcie-octeon.c
@@ -20,6 +20,7 @@
 #include <asm/octeon/cvmx-pexp-defs.h>
 #include <asm/octeon/cvmx-pemx-defs.h>
 #include <asm/octeon/cvmx-dpi-defs.h>
+#include <asm/octeon/cvmx-rst-defs.h>
 #include <asm/octeon/cvmx-sli-defs.h>
 #include <asm/octeon/cvmx-sriox-defs.h>
 #include <asm/octeon/cvmx-helper-errata.h>
@@ -29,10 +30,8 @@
 static int pcie_disable;
 module_param(pcie_disable, int, S_IRUGO);
 
-#define OCTEON_PCIE_PORTS	2
-
 static int enable_pcie_14459_war;
-static int enable_pcie_bus_num_war[OCTEON_PCIE_PORTS];
+static int enable_pcie_bus_num_war[CVMX_PCIE_MAX_PORTS];
 
 /**
  * Map a PCI device to the appropriate interrupt line
@@ -374,10 +373,13 @@ static struct pci_controller octeon_pcie##PORT##_controller = {	\
 
 OCTEON_PCIE_MEM_RESOURCE(0)
 OCTEON_PCIE_MEM_RESOURCE(1)
+OCTEON_PCIE_MEM_RESOURCE(2)
 OCTEON_PCIE_IO_RESOURCE(0)
 OCTEON_PCIE_IO_RESOURCE(1)
+OCTEON_PCIE_IO_RESOURCE(2)
 OCTEON_PCIE_CONTROLLER(0)
 OCTEON_PCIE_CONTROLLER(1)
+OCTEON_PCIE_CONTROLLER(2)
 
 static struct pci_ops octeon_dummy_ops = {
 	octeon_dummy_read_config,
@@ -444,7 +446,7 @@ static int __init octeon_pcie_setup(void)
 	set_io_port_base(CVMX_ADD_IO_SEG(cvmx_pcie_get_io_base_address(0)));
 	ioport_resource.start = 0;
 	ioport_resource.end =
-		cvmx_pcie_get_io_base_address(1) -
+		cvmx_pcie_get_io_base_address(CVMX_PCIE_PORTS) -
 		cvmx_pcie_get_io_base_address(0) + cvmx_pcie_get_io_size(1) - 1;
 
 	/*
@@ -458,7 +460,7 @@ static int __init octeon_pcie_setup(void)
 	octeon_dummy_controller.mem_resource->end = (1ull<<48);
 	register_pci_controller(&octeon_dummy_controller);
 
-	for (port = 0; port < OCTEON_PCIE_PORTS; port++) {
+	for (port = 0; port < CVMX_PCIE_PORTS; port++) {
 		if (octeon_has_feature(OCTEON_FEATURE_NPEI)) {
 			if (port == 1) {
 				host_mode = 1;
@@ -481,7 +483,10 @@ static int __init octeon_pcie_setup(void)
 			}
 		} else {
 			union cvmx_mio_rst_ctlx mio_rst_ctl;
-			mio_rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CTLX(port));
+			if (OCTEON_IS_OCTEON3())
+				mio_rst_ctl.u64 = cvmx_read_csr(CVMX_RST_CTLX(port));
+			else
+				mio_rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CTLX(port));
 			host_mode = mio_rst_ctl.s.host_mode;
 			if (port == 0)
 				octeon_dma_bar_type = OCTEON_DMA_BAR_TYPE_PCIE2;
@@ -572,6 +577,30 @@ static int __init octeon_pcie_setup(void)
 				octeon_pcie1_controller.index = 1;
 				register_pci_controller(&octeon_pcie1_controller);
 				break;
+			case 2:
+				octeon_pcie2_controller.mem_offset =
+					cvmx_pcie_get_mem_base_address(2);
+				octeon_pcie2_controller.io_map_base =
+					CVMX_ADD_IO_SEG(cvmx_pcie_get_io_base_address(0));
+				octeon_pcie2_controller.mem_resource->start =
+					cvmx_pcie_get_mem_base_address(2) +
+					(4ul << 30) - (OCTEON_PCI_BAR1_HOLE_SIZE << 20);
+				octeon_pcie2_controller.mem_resource->end =
+					cvmx_pcie_get_mem_base_address(2) +
+					cvmx_pcie_get_mem_size(2) - 1;
+				octeon_pcie2_controller.io_offset =
+					cvmx_pcie_get_io_base_address(2) -
+					cvmx_pcie_get_io_base_address(1);
+				octeon_pcie2_controller.io_resource->start =
+					cvmx_pcie_get_io_base_address(2) -
+					cvmx_pcie_get_io_base_address(1);
+				octeon_pcie2_controller.io_resource->end =
+					octeon_pcie2_controller.io_resource->start +
+					cvmx_pcie_get_io_size(2) - 1;
+				msleep(100); /* Some devices need extra time */
+				octeon_pcie2_controller.index = 2;
+				register_pci_controller(&octeon_pcie2_controller);
+				break;
 			default:
 				break;
 			}
@@ -594,7 +623,7 @@ static int __init octeon_pcie_setup(void)
 	 * all of PCIe Macs SLI_CTL_PORT*[INT*_MAP] to different value
 	 * from the previous set values
 	 */
-	for (port = 0; port < OCTEON_PCIE_PORTS; port++) {
+	for (port = 0; port < CVMX_PCIE_PORTS; port++) {
 		if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X) ||
 		    OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_0)) {
 			if (srio_war15205 == 1) {
-- 
2.6.2

