From b8d03aa64f77143580805056db0668a42ab1e32b Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@cavium.com>
Date: Sat, 31 Oct 2015 00:50:10 -0700
Subject: [PATCH 958/974] mips: i2c-octeon: faster operation when IFLG signals
 late

Some versions can deliver low-level twsi irq before twsi_ctl.iflg
is set, leading to timeout-driven i/o.
When an irq signals event, but woken task does not see the expected
twsi_ctl.iflg, re-check about 80uS later.

EEPROM reads on 100kHz i2c now measure ~5.2kB/s, about 1/2 what's
achievable, and much better than the worst-case 100 bytes/sec before

Signed-off-by: Peter Swain <pswain@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/i2c/busses/i2c-octeon.c | 35 +++++++++++++++++++++++++++++++++--
 1 file changed, 33 insertions(+), 2 deletions(-)

diff --git a/drivers/i2c/busses/i2c-octeon.c b/drivers/i2c/busses/i2c-octeon.c
index 6c7a0a2..43a7789 100644
--- a/drivers/i2c/busses/i2c-octeon.c
+++ b/drivers/i2c/busses/i2c-octeon.c
@@ -129,6 +129,15 @@ struct octeon_i2c {
 static int timeout = 2;
 module_param(timeout, int, 0444);
 MODULE_PARM_DESC(timeout, "low-level device timeout (mS)");
+
+/*
+ * on some hardware IFLG is not visible in TWSI_CTL until after
+ * low-level IRQ, so re-sample CTL a short time later to avoid stalls
+ */
+static int irq_early_us = 80;
+module_param(irq_early_us, int, 0644);
+MODULE_PARM_DESC(irq_early_us, "re-poll for IFLG after IRQ (uS)");
+
 static int octeon_i2c_initlowlevel(struct octeon_i2c *i2c);
 static int octeon_i2c_enable_hlc(struct octeon_i2c *i2c);
 static int octeon_i2c_disable_hlc(struct octeon_i2c *i2c);
@@ -359,6 +368,27 @@ static inline int octeon_i2c_test_iflg(struct octeon_i2c *i2c)
 	return (octeon_i2c_read_ctl(i2c) & TWSI_CTL_IFLG) != 0;
 }
 
+/*
+ * poll_iflg - a wait-helper which addresses the delayed-IFLAG problem
+ * by re-polling for missing TWSI_CTL[IFLG] a few uS later,
+ * when irq has signalled an event, but none found.
+ * Skip this re-poll on the first (non-wakeup) call
+ */
+static bool poll_iflg(struct octeon_i2c *i2c, bool *first_p)
+{
+	int iflg = octeon_i2c_test_iflg(i2c);
+
+	if (iflg)
+		return true;
+	if (*first_p) {
+		*first_p = false;
+	} else {
+		usleep_range(irq_early_us, 2 * irq_early_us);
+		iflg = octeon_i2c_test_iflg(i2c);
+	}
+	return iflg;
+}
+
 /**
  * octeon_i2c_wait - wait for the IFLG to be set.
  * @i2c: The struct octeon_i2c.
@@ -367,6 +397,7 @@ static inline int octeon_i2c_test_iflg(struct octeon_i2c *i2c)
  */
 static int octeon_i2c_wait(struct octeon_i2c *i2c)
 {
+	bool first = true;
 	int result;
 
 	if (i2c->broken_irq_mode) {
@@ -386,8 +417,8 @@ static int octeon_i2c_wait(struct octeon_i2c *i2c)
 	i2c->int_en(i2c);
 
 	result = wait_event_timeout(i2c->queue,
-					octeon_i2c_test_iflg(i2c),
-					i2c->adap.timeout);
+				    poll_iflg(i2c, &first),
+				    i2c->adap.timeout);
 
 	i2c->int_dis(i2c);
 
-- 
2.6.2

