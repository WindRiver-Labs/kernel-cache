From d10edabe1fe43ff292f1b0df109f26e361a99f5b Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Thu, 31 Oct 2013 15:41:19 -0700
Subject: [PATCH 370/974] MIPS: OCTEON: Sync-up SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../cavium-octeon/executive/cvmx-error-trees.c     |  15 +--
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |  15 ++-
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       | 123 ++++++++++++++-------
 arch/mips/cavium-octeon/executive/cvmx-srio.c      |   4 +-
 arch/mips/include/asm/octeon/cvmx-core.h           |  29 +++--
 arch/mips/include/asm/octeon/cvmx-qlm.h            |   6 +-
 6 files changed, 117 insertions(+), 75 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-error-trees.c b/arch/mips/cavium-octeon/executive/cvmx-error-trees.c
index 831e8fe..0e8d81c 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-error-trees.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-error-trees.c
@@ -3687,10 +3687,7 @@ static struct cvmx_error_muxchild error_tree_cn56xx =
 static struct cvmx_error_muxchild error_tree_cn70xx =
 	{0x0000000000000000ull /* CVMX_ROOT */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 		{1, 0 /* root */, (struct cvmx_error_muxchild[]){
-			{CVMX_ADD_IO_SEG(0x0001070000000000ull) + ((0) & 63) * 8 /* CVMX_CIU_INTX_SUM0(0) */, 0, (struct cvmx_error_regbit[]){
-					{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "CIU_INTX_SUM0(0)[GPIO]"},
-					{0}},
-				(struct cvmx_error_childbit[]){
+			{CVMX_ADD_IO_SEG(0x0001070000000000ull) + ((0) & 63) * 8 /* CVMX_CIU_INTX_SUM0(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 60 /* powiq */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000238ull) /* CVMX_POW_IQ_INT */, CVMX_ADD_IO_SEG(0x0001670000000240ull) /* CVMX_POW_IQ_INT_EN */, (struct cvmx_error_regbit[]){
 							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_IQ_INT[IQ_INT]"},
@@ -8787,10 +8784,7 @@ static struct cvmx_error_muxchild error_tree_cn52xx =
 static struct cvmx_error_muxchild error_tree_cn61xx =
 	{0x0000000000000000ull /* CVMX_ROOT */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 		{1, 0 /* root */, (struct cvmx_error_muxchild[]){
-			{CVMX_ADD_IO_SEG(0x0001070000000000ull) + ((0) & 63) * 8 /* CVMX_CIU_INTX_SUM0(0) */, 0, (struct cvmx_error_regbit[]){
-					{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "CIU_INTX_SUM0(0)[GPIO]"},
-					{0}},
-				(struct cvmx_error_childbit[]){
+			{CVMX_ADD_IO_SEG(0x0001070000000000ull) + ((0) & 63) * 8 /* CVMX_CIU_INTX_SUM0(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 60 /* powiq */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000238ull) /* CVMX_POW_IQ_INT */, CVMX_ADD_IO_SEG(0x0001670000000240ull) /* CVMX_POW_IQ_INT_EN */, (struct cvmx_error_regbit[]){
 							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_IQ_INT[IQ_INT]"},
@@ -9583,10 +9577,7 @@ static struct cvmx_error_muxchild error_tree_cn61xx =
 static struct cvmx_error_muxchild error_tree_cnf71xx =
 	{0x0000000000000000ull /* CVMX_ROOT */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 		{1, 0 /* root */, (struct cvmx_error_muxchild[]){
-			{CVMX_ADD_IO_SEG(0x0001070000000000ull) + ((0) & 63) * 8 /* CVMX_CIU_INTX_SUM0(0) */, 0, (struct cvmx_error_regbit[]){
-					{1, 1, CVMX_ERROR_GROUP_INTERNAL, 16, 0, "CIU_INTX_SUM0(0)[GPIO]"},
-					{0}},
-				(struct cvmx_error_childbit[]){
+			{CVMX_ADD_IO_SEG(0x0001070000000000ull) + ((0) & 63) * 8 /* CVMX_CIU_INTX_SUM0(0) */, 0, NULL /* cvmx_error_regbit */, (struct cvmx_error_childbit[]){
 				{1, 60 /* powiq */, (struct cvmx_error_muxchild[]){
 					{CVMX_ADD_IO_SEG(0x0001670000000238ull) /* CVMX_POW_IQ_INT */, CVMX_ADD_IO_SEG(0x0001670000000240ull) /* CVMX_POW_IQ_INT_EN */, (struct cvmx_error_regbit[]){
 							{1, 1, CVMX_ERROR_GROUP_INTERNAL, 0, 0, "POW_IQ_INT[IQ_INT]"},
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index 44da70f..e7dcf94 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 89912 $<hr>
+ * <hr>$Revision: 90025 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -888,7 +888,13 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 	}
 
 	/* Make sure this interface is PCIe */
-	if (octeon_has_feature(OCTEON_FEATURE_PCIE)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
+		if (cvmx_qlm_get_dlm_mode(1, pcie_port) == CVMX_QLM_MODE_DISABLED) {
+			cvmx_dprintf("PCIe: Port %d not in PCIe mode, skipping\n",
+						pcie_port);
+			return -1;
+		}
+	} else if (octeon_has_feature(OCTEON_FEATURE_PCIE)) {
 		/* Requires reading the MIO_QLMX_CFG register to figure
 		   out the port type. */
 		if (OCTEON_IS_MODEL(OCTEON_CN68XX))
@@ -903,8 +909,7 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		   2 PCIe ports in x1 */
 		else if (OCTEON_IS_MODEL(OCTEON_CNF71XX))
 			qlm = 1;
-		else if (OCTEON_IS_MODEL(OCTEON_CN70XX))
-			qlm = (pcie_port == 0) ? 1 : 2;
+
 		mode = cvmx_qlm_get_mode(qlm);
 		if (mode == CVMX_QLM_MODE_SRIO_1X4 ||
 		    mode == CVMX_QLM_MODE_SRIO_2X2 ||
@@ -922,8 +927,6 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 			cvmx_dprintf("PCIe: Port %d is ILK, skipping.\n", pcie_port);
 			return -1;
 		} else if (mode != CVMX_QLM_MODE_PCIE &&
-			   mode != CVMX_QLM_MODE_PCIE_1X2_SATA_2X1 &&
-			   mode != CVMX_QLM_MODE_PCIE_2X1_SATA_2X1 &&
 			   mode != CVMX_QLM_MODE_PCIE_1X2 &&
 			   mode != CVMX_QLM_MODE_PCIE_2X1 &&
 			   mode != CVMX_QLM_MODE_PCIE_1X1) {
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index baaed62..bf9dfb7 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 89912 $<hr>
+ * <hr>$Revision: 90025 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -807,33 +807,27 @@ static enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn70xx(int qlm)
 			pem1_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(1));
 			pem2_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(2));
 
+			if (sata_cfg.s.sata_en)
+				return CVMX_QLM_MODE_SATA_2X1;
 			if (pem0_cfg.cn70xx.md == CVMX_PEM_MD_GEN2_4LANE
 			    || pem0_cfg.cn70xx.md == CVMX_PEM_MD_GEN1_4LANE)
 				return CVMX_QLM_MODE_PCIE;
 			if (pem1_cfg.cn70xx.md == CVMX_PEM_MD_GEN2_2LANE
 			    || pem1_cfg.cn70xx.md == CVMX_PEM_MD_GEN1_2LANE) {
-				if (sata_cfg.s.sata_en)
-					return CVMX_QLM_MODE_PCIE_1X2_SATA_2X1;
-				else
-					return CVMX_QLM_MODE_PCIE_1X2;
+				return CVMX_QLM_MODE_PCIE_1X2;
 			}
 			if (pem1_cfg.cn70xx.md == CVMX_PEM_MD_GEN2_1LANE
 			    || pem1_cfg.cn70xx.md == CVMX_PEM_MD_GEN1_1LANE) {
 				if (pem2_cfg.cn70xx.md == CVMX_PEM_MD_GEN2_1LANE
 				    || pem2_cfg.cn70xx.md == CVMX_PEM_MD_GEN1_1LANE) {
-					if (sata_cfg.s.sata_en)
-						return CVMX_QLM_MODE_PCIE_2X1_SATA_2X1;
-					else
-						return CVMX_QLM_MODE_PCIE_2X1;
+					return CVMX_QLM_MODE_PCIE_2X1;
 				} else
-						return CVMX_QLM_MODE_PCIE_1X1;
+					return CVMX_QLM_MODE_PCIE_1X1;
 			}
 			if (pem2_cfg.cn70xx.md == CVMX_PEM_MD_GEN2_1LANE
 			    || pem2_cfg.cn70xx.md == CVMX_PEM_MD_GEN1_1LANE)
 				return CVMX_QLM_MODE_PCIE_2X1;
 			return CVMX_QLM_MODE_DISABLED;
-			if (sata_cfg.s.sata_en)
-				return CVMX_QLM_MODE_SATA_2X1;
 		}
 	default:
 		return CVMX_QLM_MODE_DISABLED;
@@ -842,41 +836,90 @@ static enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn70xx(int qlm)
 	return CVMX_QLM_MODE_DISABLED;
 }
 
-enum cvmx_qlm_mode cvmx_qlm_get_dlm_mode(int qlm, int interface)
+/*
+ * Get the DLM mode for the interface based on the interface type.
+ *
+ * @param interface_type   0 - SGMII/QSGMII/RXAUI interface
+ *                         1 - PCIe
+ *                         2 - SATA
+ * @param interface        interface to use
+ * @return  the qlm mode the interface is
+ */
+enum cvmx_qlm_mode cvmx_qlm_get_dlm_mode(int interface_type, int interface)
 {
-	enum cvmx_qlm_mode qlm_mode = __cvmx_qlm_get_mode_cn70xx(qlm);
-
-	switch (interface) {
-	case 0:
-		switch (qlm_mode) {
-		case CVMX_QLM_MODE_SGMII_SGMII:
-		case CVMX_QLM_MODE_SGMII_DISABLED:
-		case CVMX_QLM_MODE_SGMII_QSGMII:
-			return CVMX_QLM_MODE_SGMII;
-		case CVMX_QLM_MODE_QSGMII_QSGMII:
-		case CVMX_QLM_MODE_QSGMII_DISABLED:
-		case CVMX_QLM_MODE_QSGMII_SGMII:
-			return CVMX_QLM_MODE_QSGMII;
-		case CVMX_QLM_MODE_RXAUI_1X2:
-			return CVMX_QLM_MODE_RXAUI;
+	switch (interface_type) {
+	case 0:  /* SGMII/QSGMII/RXAUI */
+	{
+		enum cvmx_qlm_mode qlm_mode = __cvmx_qlm_get_mode_cn70xx(0);
+		switch (interface) {
+		case 0:
+			switch (qlm_mode) {
+			case CVMX_QLM_MODE_SGMII_SGMII:
+			case CVMX_QLM_MODE_SGMII_DISABLED:
+			case CVMX_QLM_MODE_SGMII_QSGMII:
+				return CVMX_QLM_MODE_SGMII;
+			case CVMX_QLM_MODE_QSGMII_QSGMII:
+			case CVMX_QLM_MODE_QSGMII_DISABLED:
+			case CVMX_QLM_MODE_QSGMII_SGMII:
+				return CVMX_QLM_MODE_QSGMII;
+			case CVMX_QLM_MODE_RXAUI_1X2:
+				return CVMX_QLM_MODE_RXAUI;
+			default:
+				return CVMX_QLM_MODE_DISABLED;
+			}
+		case 1:
+			switch (qlm_mode) {
+			case CVMX_QLM_MODE_SGMII_SGMII:
+			case CVMX_QLM_MODE_DISABLED_SGMII:
+			case CVMX_QLM_MODE_QSGMII_SGMII:
+				return CVMX_QLM_MODE_SGMII;
+			case CVMX_QLM_MODE_QSGMII_QSGMII:
+			case CVMX_QLM_MODE_DISABLED_QSGMII:
+			case CVMX_QLM_MODE_SGMII_QSGMII:
+				return CVMX_QLM_MODE_QSGMII;
+			default:
+				return CVMX_QLM_MODE_DISABLED;
+			}
 		default:
-			return CVMX_QLM_MODE_DISABLED;
+			return qlm_mode;
 		}
-	case 1:
-		switch (qlm_mode) {
-		case CVMX_QLM_MODE_SGMII_SGMII:
-		case CVMX_QLM_MODE_DISABLED_SGMII:
-		case CVMX_QLM_MODE_QSGMII_SGMII:
-			return CVMX_QLM_MODE_SGMII;
-		case CVMX_QLM_MODE_QSGMII_QSGMII:
-		case CVMX_QLM_MODE_DISABLED_QSGMII:
-		case CVMX_QLM_MODE_SGMII_QSGMII:
-			return CVMX_QLM_MODE_QSGMII;
+	}
+	case 1:  /* PCIe */
+	{
+		enum cvmx_qlm_mode qlm_mode1 = __cvmx_qlm_get_mode_cn70xx(1);
+		enum cvmx_qlm_mode qlm_mode2 = __cvmx_qlm_get_mode_cn70xx(2);
+
+		switch (interface) {
+		case 0: /* PCIe0 can be DLM1 with 1, 2 or 4 lanes */
+			return qlm_mode1;
+		case 1: /* PCIe1 can be in DLM1 1 lane(1), DLM2 1 lane(0) or 2 lanes(0-1) */
+			if (qlm_mode1 == CVMX_QLM_MODE_PCIE_2X1)
+				return CVMX_QLM_MODE_PCIE_2X1;
+			else if (qlm_mode2 == CVMX_QLM_MODE_PCIE_1X2 ||
+				 qlm_mode2 == CVMX_QLM_MODE_PCIE_2X1)
+				return qlm_mode2;
+			else
+				return CVMX_QLM_MODE_DISABLED;
+		case 2: /* PCIe2 can be DLM2 1 lanes(1) */
+			if (qlm_mode2 == CVMX_QLM_MODE_PCIE_2X1)
+				return qlm_mode2;
+			else
+				return CVMX_QLM_MODE_DISABLED;
 		default:
 			return CVMX_QLM_MODE_DISABLED;
 		}
+	}
+	case 2:  /* SATA */
+	{
+		enum cvmx_qlm_mode qlm_mode = __cvmx_qlm_get_mode_cn70xx(2);
+
+		if (qlm_mode == CVMX_QLM_MODE_SATA_2X1)
+			return CVMX_QLM_MODE_SATA_2X1;
+		else
+			return CVMX_QLM_MODE_DISABLED;
+	}
 	default:
-		return qlm_mode;
+		return CVMX_QLM_MODE_DISABLED;
 	}
 }
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-srio.c b/arch/mips/cavium-octeon/executive/cvmx-srio.c
index 48ec438..88a4563 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-srio.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-srio.c
@@ -714,9 +714,7 @@ int cvmx_srio_initialize(int srio_port, cvmx_srio_initialize_flags_t flags)
 	cvmx_write_csr(CVMX_SRIOX_INT_REG(srio_port), cvmx_read_csr(CVMX_SRIOX_INT_REG(srio_port)));
 
 	/* Enable error reporting */
-#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	octeon_error_tree_enable(CVMX_ERROR_GROUP_SRIO, srio_port);
-#elif !defined(CVMX_BUILD_FOR_LINUX_HOST)
+#if defined(CVMX_BUILD_FOR_STANDALONE)
 	cvmx_error_enable_group(CVMX_ERROR_GROUP_SRIO, srio_port);
 #endif
 
diff --git a/arch/mips/include/asm/octeon/cvmx-core.h b/arch/mips/include/asm/octeon/cvmx-core.h
index 8bee2e6..848498f 100644
--- a/arch/mips/include/asm/octeon/cvmx-core.h
+++ b/arch/mips/include/asm/octeon/cvmx-core.h
@@ -42,7 +42,7 @@
  *
  * Module to support operations on core such as TLB config, etc.
  *
- * <hr>$Revision: 84158 $<hr>
+ * <hr>$Revision: 90021 $<hr>
  *
  */
 
@@ -208,20 +208,20 @@ typedef enum cvmx_core_perf {
 	CVMX_CORE_PERF_FPADDSUB = 87,
 				     /**< Number of retired FP ADD.fmt and SUB.fmt instructions */
 	CVMX_CORE_PERF_FPCVT = 88,
-				     /**< Number of retired FP ormat conversion instructions (e.g., CVT.S.D) */
+				     /**< Number of retired FP format conversion instructions (e.g., CVT.S.D) */
 	CVMX_CORE_PERF_FPMUL = 89,
 				     /**< Number of retired FP MUL.fmt instructions */
-	CVMX_CORE_PERF_FPMADD = 96,
+	CVMX_CORE_PERF_FPMADD = 90,
 				     /**< Number of retired FP MADD.fmt variant instructions */
-	CVMX_CORE_PERF_FPDIVRECIP = 97,
+	CVMX_CORE_PERF_FPDIVRECIP = 91,
 				     /**< Number of retired FP DIV.fmt and RECIP.fmt instructions */
-	CVMX_CORE_PERF_FPSQRTRSQRT = 98,
+	CVMX_CORE_PERF_FPSQRTRSQRT = 92,
 				     /**< Number of retired FP SQRT.fmt and RSQRT.fmt instructions */
-	CVMX_CORE_PERF_FPLOAD = 99,
+	CVMX_CORE_PERF_FPLOAD = 93,
 				     /**< Number of retired FP load instructions */
-	CVMX_CORE_PERF_FPSTORE = 100,
+	CVMX_CORE_PERF_FPSTORE = 94,
 				     /**< Number of retired FP store instructions */
-	CVMX_CORE_PERF_FPALL = 101,
+	CVMX_CORE_PERF_FPALL = 95,
 				     /**< Number of retired FP instructions(all) */
 	CVMX_CORE_PERF_MAX	     /**< This not a counter, just a marker for the highest number */
 } cvmx_core_perf_t;
@@ -234,7 +234,14 @@ typedef union cvmx_core_perf_control {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint32_t m:1;	     /**< Set to 1 for sel 0 and 0 for sel 2, indicating there are two performance counters */
 		uint32_t w:1;	     /**< Set to 1 indicating counters are 64 bit */
-		uint32_t reserved_11_29:15;
+		uint32_t reserved_25_29:5;
+		uint32_t ec:2;       /**< Event Class
+					  0x0 = root events counted; active in root context
+					  0x1 = root intervention events counted; active in root context
+					  0x2 = guest events counted; active in guest context
+					  0x3 = guest events plus root intervention events counted; active in guest
+context */
+		uint32_t reserved_15_22:8;
 		cvmx_core_perf_t event:10;
 				     /**< Selects the event to be counted by the corresponding Counter Register */
 		uint32_t ie:1;
@@ -251,7 +258,9 @@ typedef union cvmx_core_perf_control {
 		uint32_t u:1;
 		uint32_t ie:1;
 		uint32_t event:10;
-		uint32_t reserved_11_29:15;
+		uint32_t reserved_15_22:8;
+		uint32_t ec:2;
+		uint32_t reserved_25_29:5;
 		uint32_t w:1;
 		uint32_t m:1;
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-qlm.h b/arch/mips/include/asm/octeon/cvmx-qlm.h
index 3690ac6..7c8dc18 100644
--- a/arch/mips/include/asm/octeon/cvmx-qlm.h
+++ b/arch/mips/include/asm/octeon/cvmx-qlm.h
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 89912 $<hr>
+ * <hr>$Revision: 90025 $<hr>
  */
 
 #ifndef __CVMX_QLM_H__
@@ -185,8 +185,6 @@ enum cvmx_qlm_mode {
 	CVMX_QLM_MODE_QSGMII_SGMII,
 	CVMX_QLM_MODE_RXAUI_1X2,
 	CVMX_QLM_MODE_SATA_2X1,
-	CVMX_QLM_MODE_PCIE_2X1_SATA_2X1,
-	CVMX_QLM_MODE_PCIE_1X2_SATA_2X1,
 };
 
 enum cvmx_gmx_inf_mode {
@@ -221,7 +219,7 @@ enum cvmx_pemx_cfg_mode {
  * Read QLM and return mode.
  */
 extern enum cvmx_qlm_mode cvmx_qlm_get_mode(int qlm);
-extern enum cvmx_qlm_mode cvmx_qlm_get_dlm_mode(int qlm, int interface);
+extern enum cvmx_qlm_mode cvmx_qlm_get_dlm_mode(int dlm_mode, int interface);
 
 extern void cvmx_qlm_display_registers(int qlm);
 
-- 
2.6.2

