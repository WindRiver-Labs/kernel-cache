From 0c1f9eac382f19a5f4703304b29452518ee88607 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Fri, 13 Nov 2015 17:08:14 -0800
Subject: [PATCH 971/974] MIPS:OCTEON: Sync-up SE files -r128119

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bootmem.c   |   20 +-
 .../mips/cavium-octeon/executive/cvmx-dma-engine.c |   10 +-
 .../executive/cvmx-global-resources.c              |   45 +
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |   65 +-
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c |   30 +-
 .../mips/cavium-octeon/executive/cvmx-helper-ilk.c |  183 +-
 .../mips/cavium-octeon/executive/cvmx-helper-ipd.c |   14 +-
 .../mips/cavium-octeon/executive/cvmx-helper-pki.c |   85 +-
 .../cavium-octeon/executive/cvmx-helper-pko3.c     |  130 +-
 arch/mips/cavium-octeon/executive/cvmx-ila.c       |   25 +-
 arch/mips/cavium-octeon/executive/cvmx-ilk.c       |   67 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |    4 +-
 arch/mips/cavium-octeon/executive/cvmx-pki.c       | 1414 +++++-----
 .../cavium-octeon/executive/cvmx-pko3-resources.c  |    5 +-
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      |   10 +-
 .../mips/cavium-octeon/executive/cvmx-qlm-tables.c |   45 +
 arch/mips/cavium-octeon/executive/cvmx-srio.c      |    2 +-
 arch/mips/include/asm/octeon/cvmx-agl-defs.h       |   14 +-
 arch/mips/include/asm/octeon/cvmx-app-init.h       |   10 +-
 arch/mips/include/asm/octeon/cvmx-ase-defs.h       |  129 +-
 arch/mips/include/asm/octeon/cvmx-bch-defs.h       |    2 +-
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      |  434 ++-
 arch/mips/include/asm/octeon/cvmx-bootmem.h        |   17 +-
 arch/mips/include/asm/octeon/cvmx-ciu-defs.h       |   70 +-
 arch/mips/include/asm/octeon/cvmx-ciu3-defs.h      |   42 +-
 arch/mips/include/asm/octeon/cvmx-coremask.h       |    6 +-
 arch/mips/include/asm/octeon/cvmx-dpi-defs.h       |  183 +-
 arch/mips/include/asm/octeon/cvmx-dtx-defs.h       |  418 ++-
 arch/mips/include/asm/octeon/cvmx-fpa-defs.h       |  123 +-
 .../include/asm/octeon/cvmx-global-resources.h     |   45 +
 arch/mips/include/asm/octeon/cvmx-gmxx-defs.h      |    2 +-
 arch/mips/include/asm/octeon/cvmx-gpio-defs.h      |   39 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     |  397 ++-
 arch/mips/include/asm/octeon/cvmx-helper-cfg.h     |    4 +-
 arch/mips/include/asm/octeon/cvmx-helper-ilk.h     |    4 +-
 arch/mips/include/asm/octeon/cvmx-helper-pki.h     |   32 +-
 arch/mips/include/asm/octeon/cvmx-helper-pko3.h    |    7 +
 arch/mips/include/asm/octeon/cvmx-helper-util.h    |    2 +-
 arch/mips/include/asm/octeon/cvmx-hna-defs.h       |  162 +-
 arch/mips/include/asm/octeon/cvmx-ila-defs.h       |   89 +-
 arch/mips/include/asm/octeon/cvmx-ila.h            |    5 +
 arch/mips/include/asm/octeon/cvmx-ilk-defs.h       |   87 +-
 arch/mips/include/asm/octeon/cvmx-ilk.h            |   11 +-
 arch/mips/include/asm/octeon/cvmx-iobn-defs.h      |   23 +-
 arch/mips/include/asm/octeon/cvmx-iobp-defs.h      |   10 +-
 arch/mips/include/asm/octeon/cvmx-l2c-defs.h       |  290 +-
 arch/mips/include/asm/octeon/cvmx-lapx-defs.h      |   32 +-
 arch/mips/include/asm/octeon/cvmx-lbk-defs.h       |   13 +-
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h      | 1065 +++----
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       |  459 +--
 arch/mips/include/asm/octeon/cvmx-mixx-defs.h      |   14 +
 arch/mips/include/asm/octeon/cvmx-mpi-defs.h       |   13 +-
 arch/mips/include/asm/octeon/cvmx-oclax-defs.h     |   41 +-
 arch/mips/include/asm/octeon/cvmx-ocx-defs.h       |  124 +-
 arch/mips/include/asm/octeon/cvmx-osm-defs.h       |  164 +-
 arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h | 1640 +----------
 arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h   | 1129 ++++++--
 arch/mips/include/asm/octeon/cvmx-pciercx-defs.h   |  763 ++++-
 arch/mips/include/asm/octeon/cvmx-pcsx-defs.h      |    4 +-
 arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h     |    8 +-
 arch/mips/include/asm/octeon/cvmx-pemx-defs.h      |  574 ++--
 arch/mips/include/asm/octeon/cvmx-pexp-defs.h      |  890 ++++--
 arch/mips/include/asm/octeon/cvmx-pki-cluster.h    |   45 +
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |  931 ++++---
 arch/mips/include/asm/octeon/cvmx-pki.h            | 1154 ++++----
 arch/mips/include/asm/octeon/cvmx-pko-defs.h       | 2279 ++++++---------
 arch/mips/include/asm/octeon/cvmx-pko3.h           |   56 +-
 arch/mips/include/asm/octeon/cvmx-pow.h            | 2921 ++++++++++----------
 arch/mips/include/asm/octeon/cvmx-rnm-defs.h       |   10 +-
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |   47 +-
 arch/mips/include/asm/octeon/cvmx-sata-defs.h      |  233 +-
 arch/mips/include/asm/octeon/cvmx-sli-defs.h       | 1371 ++++++---
 arch/mips/include/asm/octeon/cvmx-smix-defs.h      |   60 +-
 arch/mips/include/asm/octeon/cvmx-spemx-defs.h     |  162 +-
 .../mips/include/asm/octeon/cvmx-sriomaintx-defs.h |   18 +-
 arch/mips/include/asm/octeon/cvmx-sriox-defs.h     |  114 +-
 arch/mips/include/asm/octeon/cvmx-sso-defs.h       |  244 +-
 arch/mips/include/asm/octeon/cvmx-uahcx-defs.h     |  262 +-
 arch/mips/include/asm/octeon/cvmx-uctlx-defs.h     |  128 +-
 arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h   |  506 +---
 arch/mips/include/asm/octeon/cvmx-xcv-defs.h       |   20 +-
 arch/mips/include/asm/octeon/octeon-model.h        |    5 +-
 82 files changed, 11565 insertions(+), 10745 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
index 7ad99a0..1edfa0e 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
@@ -43,7 +43,7 @@
  * Simple allocate only memory allocator.  Used to allocate memory at
  * application start time.
  *
- * <hr>$Revision: 112705 $<hr>
+ * <hr>$Revision: 127530 $<hr>
  *
  */
 
@@ -227,7 +227,6 @@ static inline uint64_t __cvmx_bootmem_get_lock_addr(void)
  */
 static void CVMX_BOOTMEM_NAMED_GET_NAME(uint64_t addr, char *str, int len)
 {
-#ifndef CVMX_BUILD_FOR_LINUX_HOST
 	int l = len;
 	char *ptr = str;
 	addr |= (1ull << 63);
@@ -247,14 +246,6 @@ static void CVMX_BOOTMEM_NAMED_GET_NAME(uint64_t addr, char *str, int len)
 		}
 	}
 	str[len] = 0;
-#else
-	extern void octeon_remote_read_mem(void *buffer,
-					   uint64_t physical_address,
-				    int length);
-	addr += offsetof(cvmx_bootmem_named_block_desc_t, name);
-	octeon_remote_read_mem(str, addr, len);
-	str[len] = 0;
-#endif
 }
 
 /**
@@ -269,7 +260,6 @@ static void CVMX_BOOTMEM_NAMED_GET_NAME(uint64_t addr, char *str, int len)
  */
 void CVMX_BOOTMEM_NAMED_SET_NAME(uint64_t addr, const char *str, int len)
 {
-#ifndef CVMX_BUILD_FOR_LINUX_HOST
 	int l = len;
 	addr |= (1ull << 63);
 	addr += offsetof(cvmx_bootmem_named_block_desc_t, name);
@@ -292,14 +282,6 @@ void CVMX_BOOTMEM_NAMED_SET_NAME(uint64_t addr, const char *str, int len)
 		cvmx_write64_uint64(addr, blob);
 		addr += sizeof(uint64_t);
 	}
-#else
-	extern void octeon_remote_write_mem(uint64_t physical_address,
-					    const void *buffer, int length);
-	char zero = 0;
-	addr += offsetof(cvmx_bootmem_named_block_desc_t, name);
-	octeon_remote_write_mem(addr, str, len - 1);
-	octeon_remote_write_mem(addr + len - 1, &zero, 1);
-#endif
 }
 
 /* See header file for descriptions of functions */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c b/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c
index 0627c21..497f9b9 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-dma-engine.c
@@ -43,7 +43,7 @@
  * Interface to the PCI / PCIe DMA engines. These are only avialable
  * on chips with PCI / PCIe.
  *
- * <hr>$Revision: 112023 $<hr>
+ * <hr>$Revision: 127394 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <linux/export.h>
@@ -111,6 +111,14 @@ int cvmx_dma_engine_initialize(void)
 	}
 #endif
 
+	/* For OCTEON3 configure the AURA before initial buffer addresses */
+	if (octeon_has_feature(OCTEON_FEATURE_FPA3)) {
+		cvmx_dpi_dma_control_t dma_control;
+		dma_control.u64 = cvmx_read_csr(CVMX_DPI_DMA_CONTROL);
+		dma_control.cn78xx.aura_ichk = pool;
+		cvmx_write_csr(CVMX_DPI_DMA_CONTROL, dma_control.u64);
+	}
+
 	for (engine = 0; engine < cvmx_dma_engine_get_num(); engine++) {
 		cvmx_cmd_queue_result_t result;
 		result = cvmx_cmd_queue_initialize(CVMX_CMD_QUEUE_DMA(engine), 0, pool, pool_size);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-global-resources.c b/arch/mips/cavium-octeon/executive/cvmx-global-resources.c
index 7892a68..4b77744 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-global-resources.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-global-resources.c
@@ -1,3 +1,48 @@
+/***********************license start***************
+ * Copyright (c) 2012-2015  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * <hr>$Revision: 115744 $<hr>
+ */
+
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <linux/types.h>
 #include <linux/export.h>
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index c40325e..2fd823d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -67,6 +67,37 @@
 static const int debug = 0;
 
 /**
+ * Delay after enabling an interface based on the mode.  Different modes take
+ * different amounts of time.
+ */
+static void
+__cvmx_helper_bgx_interface_enable_delay(cvmx_helper_interface_mode_t mode)
+{
+	/* Don't delay if we running under the simulator. */
+	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM)
+		return;
+
+	switch (mode) {
+	case CVMX_HELPER_INTERFACE_MODE_10G_KR:
+	case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
+	case CVMX_HELPER_INTERFACE_MODE_XLAUI:
+	case CVMX_HELPER_INTERFACE_MODE_XFI:
+		cvmx_wait_usec(250000);
+		break;
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+	case CVMX_HELPER_INTERFACE_MODE_XAUI:
+		cvmx_wait_usec(100000);
+		break;
+	case CVMX_HELPER_INTERFACE_MODE_SGMII:
+		cvmx_wait_usec(50000);
+		break;
+	default:
+		cvmx_wait_usec(50000);
+		break;
+	}
+}
+
+/**
  * @INTERNAL
  *
  * Returns number of ports based on interface
@@ -913,10 +944,10 @@ int __cvmx_helper_bgx_sgmii_link_set(int xipd_port,
 				    cmr_config.u64);
 		/* Apply workaround for errata BGX-22429 */
 		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && index) {
-			cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(0, iface));
-			cmr_config.s.enable = 1;
-			cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(0, iface),
-					    cmr_config.u64);
+			cvmx_bgxx_cmrx_config_t cmr0;
+			cmr0.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(0, iface));
+			cmr0.s.enable = 1;
+			cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(0, iface), cmr0.u64);
 		}
 		__cvmx_helper_bgx_sgmii_hardware_init_link(xiface, index);
 	} else if (cvmx_helper_bgx_is_rgmii(xi.interface, index)) {
@@ -1099,6 +1130,13 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, xi.interface));
 		cmr_config.s.enable = 1;
 		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, xi.interface), cmr_config.u64);
+		/* Apply workaround for errata BGX-22429 */
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && index) {
+			cvmx_bgxx_cmrx_config_t cmr0;
+			cmr0.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(0, xi.interface));
+			cmr0.s.enable = 1;
+			cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(0, xi.interface), cmr0.u64);
+		}
 
 		spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, xi.interface));
 		spu_control1.s.lo_pwr = 0;
@@ -1129,6 +1167,8 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 		dbg_control.s.us_clk_period = clock_mhz - 1;
 		cvmx_write_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(xi.interface), dbg_control.u64);
 	}
+	/* The PHY often takes at least 100ms to stabilize */
+	__cvmx_helper_bgx_interface_enable_delay(mode);
 	return 0;
 }
 
@@ -1614,6 +1654,7 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_xaui_link_get(int xipd_port)
 	cvmx_bgxx_smux_rx_ctl_t smu_rx_ctl;
 	cvmx_bgxx_cmrx_config_t cmr_config;
 	cvmx_helper_link_info_t result;
+	cvmx_helper_interface_mode_t mode;
 
 	result.u64 = 0;
 
@@ -1621,6 +1662,10 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_xaui_link_get(int xipd_port)
 		cvmx_dprintf("%s: interface %u:%d/%d\n",
 		__func__, xi.node, xi.interface, index);
 
+	mode = cvmx_helper_bgx_get_mode(xiface, index);
+	if (mode == CVMX_HELPER_INTERFACE_MODE_RGMII)
+		return __cvmx_helper_bgx_sgmii_link_get(xipd_port);
+
 	spu_status1.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_SPUX_STATUS1(index, xi.interface));
 	smu_tx_ctl.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_SMUX_TX_CTL(index, xi.interface));
 	smu_rx_ctl.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_SMUX_RX_CTL(index, xi.interface));
@@ -1687,11 +1732,16 @@ int __cvmx_helper_bgx_xaui_link_set(int xipd_port, cvmx_helper_link_info_t link_
 	cvmx_bgxx_smux_tx_ctl_t smu_tx_ctl;
 	cvmx_bgxx_smux_rx_ctl_t smu_rx_ctl;
 	cvmx_bgxx_spux_status1_t spu_status1;
+	cvmx_helper_interface_mode_t mode;
 
 	if (debug)
 		cvmx_dprintf("%s: interface %u:%d/%d\n",
 		__func__, xi.node, xi.interface, index);
 
+	mode = cvmx_helper_bgx_get_mode(xiface, index);
+	if (mode == CVMX_HELPER_INTERFACE_MODE_RGMII)
+		return __cvmx_helper_bgx_sgmii_link_set(xipd_port, link_info);
+
 	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, xi.interface));
 	smu_rx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(index, xi.interface));
 	spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(index, xi.interface));
@@ -2060,6 +2110,13 @@ void cvmx_helper_bgx_set_mac(int xipd_port, int bcst, int mcst, uint64_t mac)
 	cmr_config.s.data_pkt_tx_en = saved_state;
 	cmr_config.s.data_pkt_rx_en = 1;
 	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, xi.interface), cmr_config.u64);
+
+	/* Wait 100ms after bringing up the link to give the PHY some time */
+	if (cmr_config.s.enable) {
+		cvmx_helper_interface_mode_t mode;
+		mode = cvmx_helper_bgx_get_mode(xiface, index);
+		__cvmx_helper_bgx_interface_enable_delay(mode);
+	}
 }
 
 /**
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index 8197031..3321e3a 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -236,7 +236,6 @@ int cvmx_pko_queue_grp_alloc(uint64_t start, uint64_t end, uint64_t count)
 {
 	uint64_t port;
 	int ret_val;
-
 	for (port = start; port < end; port++) {
 		ret_val = cvmx_pko_queue_alloc(port, count);
 		if (ret_val == -1)
@@ -267,6 +266,18 @@ int cvmx_pko_queue_init_from_cvmx_config_non_pknd(void)
 	if (ret_val != 0)
 		return -1;
 
+        if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
+		/* Interface 4: AGL, PKO port 24 only, DPI 32-35 */
+		start = 24;
+		end = start + 1;
+		count = __cvmx_pko_queue_static_config.non_pknd.pko_queues_per_port_interface[4];
+		ret_val = cvmx_pko_queue_grp_alloc(start,end,count);
+
+		if (ret_val != 0)
+			return -1;
+		end = 32;	/* DPI first PKO poty */
+	}
+
 	start = end; end = 36 ; count = __cvmx_pko_queue_static_config.non_pknd.pko_queues_per_port_pci;
 	cvmx_pko_queue_grp_alloc(start,end,count);
 	if (ret_val != 0)
@@ -330,6 +341,7 @@ static int cvmx_pko_queue_alloc(uint64_t port, int count)
 {
     int ret_val = -1;
     int highest_queue;
+    const int debug = 0;
 
     init_cvmx_pko_que_range();
 
@@ -351,7 +363,11 @@ static int cvmx_pko_queue_alloc(uint64_t port, int count)
 
     ret_val = cvmx_allocate_global_resource_range(CVMX_GR_TAG_PKO_QUEUES,
 	port, count, 1);
-    //cvmx_dprintf("allocated pko que : port=%02d base=%02d count=%02d \n", (int) port, ret_val, (int) count);
+
+    if (debug)
+	    cvmx_dprintf("%s: pko_e_port=%i q_base=%i q_count=%i \n", 
+		__func__, (int) port, ret_val, (int) count);
+
     if (ret_val == -1)
         return ret_val;
     cvmx_pko_queue_table[port].ccppp_queue_base = ret_val;
@@ -1052,7 +1068,13 @@ int __cvmx_helper_init_port_config_data(int node)
 		for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
 			int xiface = cvmx_helper_node_interface_to_xiface(node, i);
 			n = cvmx_helper_interface_enumerate(xiface);
-			if (cvmx_helper_interface_get_mode(xiface) != CVMX_HELPER_INTERFACE_MODE_NPI) {
+			/* Assign 8 pknds to ILK interface, these pknds will be
+		           distributed amoung the channels configured */
+			if (cvmx_helper_interface_get_mode(xiface) == CVMX_HELPER_INTERFACE_MODE_ILK) {
+				if (n > 8)
+					n = 8;
+			}
+ 			if (cvmx_helper_interface_get_mode(xiface) != CVMX_HELPER_INTERFACE_MODE_NPI) {
 				for (j = 0; j < n; j++) {
 					cvmx_cfg_port[node][i][j].ccpp_pknd = pknd++;
 					cvmx_cfg_port[node][i][j].ccpp_bpid = bpid++;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c b/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c
index 019b917..bfc5c96 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-ilk.c
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2010-2014  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2010-2015  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -58,12 +58,14 @@
 #include <asm/octeon/cvmx-hwpko.h>
 #include <asm/octeon/cvmx-qlm.h>
 #include <asm/octeon/cvmx-ilk-defs.h>
+#include <asm/octeon/cvmx-pki.h>
 #else
 #include "cvmx.h"
 #include "cvmx-error.h"
 #include "cvmx-helper.h"
 #include "cvmx-helper-cfg.h"
 #include "cvmx-ilk.h"
+#include "cvmx-pki.h"
 #include "cvmx-bootmem.h"
 #include "cvmx-hwpko.h"
 #include "cvmx-qlm.h"
@@ -87,7 +89,7 @@ int __cvmx_helper_ilk_enumerate(int xiface)
  *
  * @param intf Interface whose calendar are to be initialized.
  */
-void __cvmx_ilk_init_cal_cn78xx(int intf)
+static void __cvmx_ilk_clear_cal_cn78xx(int intf)
 {
 	cvmx_ilk_txx_cal_entryx_t	tx_entry;
 	cvmx_ilk_rxx_cal_entryx_t	rx_entry;
@@ -98,7 +100,7 @@ void __cvmx_ilk_init_cal_cn78xx(int intf)
 	/* Initialize all tx calendar entries to off */
 	tx_entry.u64 = 0;
 	tx_entry.s.ctl = XOFF;
-	for (i = 0; i < CVMX_ILK_MAX_CAL_IDX; i++) {
+	for (i = 0; i < CVMX_ILK_MAX_CAL; i++) {
 		cvmx_write_csr_node(node, CVMX_ILK_TXX_CAL_ENTRYX(i, interface),
 			       tx_entry.u64);
 	}
@@ -106,7 +108,7 @@ void __cvmx_ilk_init_cal_cn78xx(int intf)
 	/* Initialize all rx calendar entries to on */
 	rx_entry.u64 = 0;
 	rx_entry.s.ctl = XOFF;
-	for (i = 0; i < CVMX_ILK_MAX_CAL_IDX; i++) {
+	for (i = 0; i < CVMX_ILK_MAX_CAL; i++) {
 		cvmx_write_csr_node(node, CVMX_ILK_RXX_CAL_ENTRYX(i, interface),
 			       rx_entry.u64);
 	}
@@ -122,7 +124,7 @@ void __cvmx_ilk_init_cal_cn78xx(int intf)
  *
  * @param interface Interface whose calendar are to be initialized.
  */
-void __cvmx_ilk_init_cal_cn68xx(int interface)
+static void __cvmx_ilk_clear_cal_cn68xx(int interface)
 {
 	cvmx_ilk_txx_idx_cal_t	tx_idx;
 	cvmx_ilk_txx_mem_cal0_t tx_cal0;
@@ -193,12 +195,12 @@ void __cvmx_ilk_init_cal_cn68xx(int interface)
  *
  * @param interface Interface whose calendar is to be initialized.
  */
-void __cvmx_ilk_init_cal(int interface)
+void __cvmx_ilk_clear_cal(int interface)
 {
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
-		__cvmx_ilk_init_cal_cn68xx(interface);
+		__cvmx_ilk_clear_cal_cn68xx(interface);
 	else if (OCTEON_IS_MODEL(OCTEON_CN78XX))
-		__cvmx_ilk_init_cal_cn78xx(interface);
+		__cvmx_ilk_clear_cal_cn78xx(interface);
 }
 
 void __cvmx_ilk_write_tx_cal_entry_cn68xx(int interface,
@@ -310,7 +312,7 @@ void __cvmx_ilk_write_tx_cal_entry_cn78xx(int intf,
 	tx_cal.s.channel = channel;
 	cvmx_write_csr_node(node, CVMX_ILK_TXX_CAL_ENTRYX(index, interface), tx_cal.u64);
 }
-	
+
 /**
  * @INTERNAL
  * Setup the channel's tx calendar entry.
@@ -480,8 +482,6 @@ int __cvmx_helper_ilk_probe(int xiface)
 	if (interface >= CVMX_NUM_ILK_INTF)
 		return 0;
 
-
-
 	/* the configuration should be done only once */
 	if (cvmx_ilk_get_intf_ena(xiface))
 		return cvmx_ilk_chans[xi.node][interface];
@@ -497,7 +497,7 @@ int __cvmx_helper_ilk_probe(int xiface)
 	return res;
 }
 
-static int __cvmx_helper_ilk_init_port(int xiface)
+static int __cvmx_helper_ilk_init_port_cn68xx(int xiface)
 {
 	int i, j, res = -1;
 	static int pipe_base = 0, pknd_base = 0;
@@ -508,59 +508,58 @@ static int __cvmx_helper_ilk_init_port(int xiface)
 	int interface;
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int intf;
+	int num_chans;
 
 	interface = xi.interface - CVMX_ILK_GBL_BASE();
 	intf = (xi.node << 4) | interface;
 	if (interface >= CVMX_NUM_ILK_INTF)
 		return 0;
 
+	num_chans = cvmx_ilk_chans[0][interface];
+
 	/* set up channel to pkind mapping */
 	if (pknd_base == 0)
 		pknd_base = cvmx_helper_get_pknd(xiface, 0);
 
 	/* set up the group of pipes available to ilk */
-	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
-		if (pipe_base == 0)
-			pipe_base = __cvmx_pko_get_pipe(interface + CVMX_ILK_GBL_BASE(), 0);
+	if (pipe_base == 0)
+		pipe_base = __cvmx_pko_get_pipe(interface + CVMX_ILK_GBL_BASE(), 0);
 
-		if (pipe_base == -1) {
-			pipe_base = 0;
-			return 0;
-		}
+	if (pipe_base == -1) {
+		pipe_base = 0;
+		return 0;
+	}
 
-		res = cvmx_ilk_set_pipe(xiface, pipe_base, cvmx_ilk_chans[0][interface]);
-		if (res < 0)
-			return 0;
+	res = cvmx_ilk_set_pipe(xiface, pipe_base, cvmx_ilk_chans[0][interface]);
+	if (res < 0)
+		return 0;
 
-		/* set up pipe to channel mapping */
-		i = pipe_base;
-		if (pch == NULL) {
-			pch = (cvmx_ilk_pipe_chan_t *)
+	/* set up pipe to channel mapping */
+	i = pipe_base;
+	if (pch == NULL) {
+		pch = (cvmx_ilk_pipe_chan_t *)
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-			    kmalloc(CVMX_ILK_MAX_CHANS * sizeof(cvmx_ilk_pipe_chan_t), GFP_KERNEL);
+			kmalloc(num_chans * sizeof(cvmx_ilk_pipe_chan_t), GFP_KERNEL);
 #else
-			    cvmx_bootmem_alloc(CVMX_ILK_MAX_CHANS * sizeof(cvmx_ilk_pipe_chan_t), sizeof(cvmx_ilk_pipe_chan_t));
+		cvmx_bootmem_alloc(num_chans * sizeof(cvmx_ilk_pipe_chan_t), sizeof(cvmx_ilk_pipe_chan_t));
 #endif
-			if (pch == NULL)
-				return 0;
-		}
-
-		memset(pch, 0, CVMX_ILK_MAX_CHANS * sizeof(cvmx_ilk_pipe_chan_t));
-		tmp = pch;
-		for (j = 0; j < cvmx_ilk_chans[0][interface]; j++) {
-			tmp->pipe = i++;
-			tmp->chan = cvmx_ilk_chan_map[interface][j];
-			tmp++;
-		}
-		res = cvmx_ilk_tx_set_channel(interface, pch, cvmx_ilk_chans[0][interface]);
-		if (res < 0) {
-			res = 0;
-			goto err_free_pch;
-		}
-		pipe_base += cvmx_ilk_chans[0][interface];
-	} else if (OCTEON_IS_MODEL(OCTEON_CN78XX))
-		pipe_base = pknd_base + cvmx_ilk_chans[xi.node][interface];
+		if (pch == NULL)
+			return 0;
+	}
 
+	memset(pch, 0, num_chans * sizeof(cvmx_ilk_pipe_chan_t));
+	tmp = pch;
+	for (j = 0; j < num_chans; j++) {
+		tmp->pipe = i++;
+		tmp->chan = j;
+		tmp++;
+	}
+	res = cvmx_ilk_tx_set_channel(interface, pch, cvmx_ilk_chans[0][interface]);
+	if (res < 0) {
+		res = 0;
+		goto err_free_pch;
+	}
+	pipe_base += cvmx_ilk_chans[0][interface];
 	i = pknd_base;
 	if (chpknd == NULL) {
 		chpknd = (cvmx_ilk_chan_pknd_t *)
@@ -579,7 +578,7 @@ static int __cvmx_helper_ilk_init_port(int xiface)
 	memset(chpknd, 0, CVMX_ILK_MAX_PKNDS * sizeof(cvmx_ilk_chan_pknd_t));
 	tmp1 = chpknd;
 	for (j = 0; j < cvmx_ilk_chans[xi.node][interface]; j++) {
-		tmp1->chan = cvmx_ilk_chan_map[interface][j];
+		tmp1->chan = j;
 		tmp1->pknd = i++;
 		tmp1++;
 	}
@@ -627,24 +626,25 @@ static int __cvmx_helper_ilk_init_port(int xiface)
 
 	/* set up rx calendar. allocated memory can be reused.
 	 * this is because max pkind is always less than max pipe */
-	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
-		memset(calent, 0, CVMX_ILK_MAX_PIPES * sizeof(cvmx_ilk_cal_entry_t));
-		tmp = pch;
-		tmp2 = calent;
-		for (j = 0; j < cvmx_ilk_chans[0][interface]; j++) {
-			tmp2->pipe_bpid = tmp->pipe;
-			tmp2->ent_ctrl = PIPE_BPID;
-			tmp++;
-			tmp2++;
-		}
-		if (cvmx_ilk_use_la_mode(interface, 0))
-			enable_rx_cal = cvmx_ilk_la_mode_enable_rx_calendar(interface);
-		else
-			enable_rx_cal = 1;
+	memset(calent, 0, CVMX_ILK_MAX_PIPES * sizeof(cvmx_ilk_cal_entry_t));
+	tmp = pch;
+	tmp2 = calent;
+	for (j = 0; j < cvmx_ilk_chans[0][interface]; j++) {
+		tmp2->pipe_bpid = tmp->pipe;
+		tmp2->ent_ctrl = PIPE_BPID;
+		tmp++;
+		tmp2++;
 	}
+	if (cvmx_ilk_use_la_mode(interface, 0))
+		enable_rx_cal = cvmx_ilk_la_mode_enable_rx_calendar(interface);
+	else
+		enable_rx_cal = 1;
+
+#if 0
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
 		enable_rx_cal = 1;
 	}
+#endif
 	res = cvmx_ilk_cal_setup_rx(intf, cvmx_ilk_chans[xi.node][interface], calent, CVMX_ILK_RX_FIFO_WM, enable_rx_cal);
 	if (res < 0) {
 		pipe_base -= cvmx_ilk_chans[xi.node][interface];
@@ -678,6 +678,55 @@ out:
 	return res;
 }
 
+static int __cvmx_helper_ilk_init_port_cn78xx(int xiface)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	int interface;
+	int intf;
+
+	interface = xi.interface - CVMX_ILK_GBL_BASE();
+	intf = (xi.node << 4) | interface;
+	if (interface >= CVMX_NUM_ILK_INTF)
+		return 0;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		struct cvmx_pki_style_config style_cfg;
+		int num_channels = cvmx_ilk_chans[xi.node][interface];
+		int index, i;
+
+		for (i = 0; i < num_channels; i++) {
+			int pknd;
+			index = (i % 8);
+
+			/* Set jabber to allow max sized packets */
+			if (i == 0)
+				cvmx_write_csr_node(xi.node, CVMX_ILK_RXX_JABBER(interface), 0xfff8);
+
+			/* Setup PKND */
+			pknd = cvmx_helper_get_pknd(xiface, index);
+			cvmx_write_csr_node(xi.node, CVMX_ILK_RXX_CHAX(i, interface), pknd);
+			cvmx_pki_read_style_config(0, pknd, CVMX_PKI_CLUSTER_ALL, &style_cfg);
+			style_cfg.parm_cfg.qpg_port_sh = 0;
+			/* 256 channels */
+			style_cfg.parm_cfg.qpg_port_msb = 8;
+			cvmx_pki_write_style_config(0, pknd, CVMX_PKI_CLUSTER_ALL, &style_cfg);
+		}
+
+		cvmx_ilk_cal_setup_tx(intf, num_channels, NULL, 1);
+		cvmx_ilk_cal_setup_rx(intf, num_channels, NULL, CVMX_ILK_RX_FIFO_WM, 1);
+	}
+	return 0;
+}
+
+
+static int __cvmx_helper_ilk_init_port(int xiface)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return __cvmx_helper_ilk_init_port_cn68xx(xiface);
+	else
+		return __cvmx_helper_ilk_init_port_cn78xx(xiface);
+}
+
 /**
  * @INTERNAL
  * Bringup and enable ILK interface. After this call packet
@@ -883,16 +932,14 @@ int __cvmx_helper_ilk_link_set(int ipd_port, cvmx_helper_link_info_t link_info)
 void __cvmx_helper_ilk_show_stats(void)
 {
 	int i, j;
-	unsigned char *pchans, num_chans;
-	unsigned int chan_tmp[CVMX_ILK_MAX_CHANS];
+	int chan_tmp[CVMX_ILK_MAX_CHANS];
 	cvmx_ilk_stats_ctrl_t ilk_stats_ctrl;
 
 	for (i = 0; i < CVMX_NUM_ILK_INTF; i++) {
-		cvmx_ilk_get_chan_info(i, &pchans, &num_chans);
-
-		memset(chan_tmp, 0, CVMX_ILK_MAX_CHANS * sizeof(int));
+		int num_chans = cvmx_ilk_chans[0][i];
+		memset(chan_tmp, 0, num_chans * sizeof(int));
 		for (j = 0; j < num_chans; j++)
-			chan_tmp[j] = pchans[j];
+			chan_tmp[j] = j;
 
 		ilk_stats_ctrl.chan_list = chan_tmp;
 		ilk_stats_ctrl.num_chans = num_chans;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-ipd.c b/arch/mips/cavium-octeon/executive/cvmx-helper-ipd.c
index 2f23c75..3695bb2 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-ipd.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-ipd.c
@@ -109,18 +109,18 @@ int __cvmx_helper_ipd_global_setup(void)
 /**
  * Enable or disable FCS stripping for all the ports on an interface.
  *
- * @param interface
+ * @param xiface
  * @param nports number of ports
  * @param has_fcs 0 for disable and !0 for enable
  */
-static int cvmx_helper_fcs_op(int interface, int nports, int has_fcs)
+static int cvmx_helper_fcs_op(int xiface, int nports, int has_fcs)
 {
 	uint64_t port_bit;
 	int index;
 	int pknd;
 	union cvmx_pip_sub_pkind_fcsx pkind_fcsx;
 	union cvmx_pip_prt_cfgx port_cfg;
-	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(interface);
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 
 	if (!octeon_has_feature(OCTEON_FEATURE_PKND))
 		return 0;
@@ -131,7 +131,7 @@ static int cvmx_helper_fcs_op(int interface, int nports, int has_fcs)
 
 	port_bit = 0;
 	for (index = 0; index < nports; index++)
-		port_bit |= ((uint64_t) 1 << cvmx_helper_get_pknd(interface, index));
+		port_bit |= ((uint64_t) 1 << cvmx_helper_get_pknd(xiface, index));
 
 	pkind_fcsx.u64 = cvmx_read_csr(CVMX_PIP_SUB_PKIND_FCSX(0));
 	if (has_fcs)
@@ -169,12 +169,12 @@ static int __cvmx_helper_ipd_port_setup(int ipd_port)
 	union cvmx_pip_prt_tagx tag_config;
 
 	if (octeon_has_feature(OCTEON_FEATURE_PKND)) {
-		int interface, index, pknd;
+		int xiface, index, pknd;
 		union cvmx_pip_prt_cfgbx prt_cfgbx;
 
-		interface = cvmx_helper_get_interface_num(ipd_port);
+		xiface = cvmx_helper_get_interface_num(ipd_port);
 		index = cvmx_helper_get_interface_index_num(ipd_port);
-		pknd = cvmx_helper_get_pknd(interface, index);
+		pknd = cvmx_helper_get_pknd(xiface, index);
 
 		port_config.u64 = cvmx_read_csr(CVMX_PIP_PRT_CFGX(pknd));
 		tag_config.u64 = cvmx_read_csr(CVMX_PIP_PRT_TAGX(pknd));
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
index 1670967..814d4b4 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
@@ -397,17 +397,17 @@ static int __cvmx_helper_setup_pki_qpg_table(int node)
 
 int __cvmx_helper_pki_port_setup(int node, int ipd_port)
 {
-	int interface, index;
+	int xiface, index;
 	int pknd, style_num;
 	int rs;
 	struct cvmx_pki_pkind_config pkind_cfg;
 
 	if (!cvmx_pki_dflt_init[node])
 		return 0;
-	interface = cvmx_helper_get_interface_num(ipd_port);
+	xiface = cvmx_helper_get_interface_num(ipd_port);
 	index = cvmx_helper_get_interface_index_num(ipd_port);
 
-	pknd = cvmx_helper_get_pknd(interface, index);
+	pknd = cvmx_helper_get_pknd(xiface, index);
 	style_num = pkind_style_map[node][pknd];
 
 	/* try to reserve the style, if it is not configured already, reserve
@@ -1468,20 +1468,20 @@ int cvmx_helper_pki_init_interface(const int xiface, struct cvmx_pki_intf_schd *
 /**
  * This function gets all the PKI parameters related to that
  * particular port from hardware.
- * @param ipd_port	ipd port number with node to get parameter of
+ * @param xipd_port	xipd_port port number with node to get parameter of
  * @param port_cfg	pointer to structure where to store read parameters
  */
-void cvmx_pki_get_port_config(int ipd_port, struct cvmx_pki_port_config *port_cfg)
+void cvmx_pki_get_port_config(int xipd_port, struct cvmx_pki_port_config *port_cfg)
 {
-	int interface, index, pknd;
+	int xiface, index, pknd;
 	int style, cl_mask;
 	cvmx_pki_icgx_cfg_t pki_cl_msk;
-	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(ipd_port);
+	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
 
 	/* get the pkind used by this ipd port */
-	interface = cvmx_helper_get_interface_num(ipd_port);
-	index = cvmx_helper_get_interface_index_num(ipd_port);
-	pknd = cvmx_helper_get_pknd(interface, index);
+	xiface = cvmx_helper_get_interface_num(xipd_port);
+	index = cvmx_helper_get_interface_index_num(xipd_port);
+	pknd = cvmx_helper_get_pknd(xiface, index);
 
 	cvmx_pki_read_pkind_config(xp.node, pknd, &port_cfg->pkind_cfg);
 	style = port_cfg->pkind_cfg.initial_style;
@@ -1494,20 +1494,20 @@ EXPORT_SYMBOL(cvmx_pki_get_port_config);
 /**
  * This function sets all the PKI parameters related to that
  * particular port in hardware.
- * @param ipd_port	ipd port number with node to get parameter of
+ * @param xipd_port	ipd port number with node to get parameter of
  * @param port_cfg	pointer to structure containing port parameters
  */
-void cvmx_pki_set_port_config(int ipd_port, struct cvmx_pki_port_config *port_cfg)
+void cvmx_pki_set_port_config(int xipd_port, struct cvmx_pki_port_config *port_cfg)
 {
-	int interface, index, pknd;
+	int xiface, index, pknd;
 	int style, cl_mask;
 	cvmx_pki_icgx_cfg_t pki_cl_msk;
-	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(ipd_port);
+	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
 
 	/* get the pkind used by this ipd port */
-	interface = cvmx_helper_get_interface_num(ipd_port);
-	index = cvmx_helper_get_interface_index_num(ipd_port);
-	pknd = cvmx_helper_get_pknd(interface, index);
+	xiface = cvmx_helper_get_interface_num(xipd_port);
+	index = cvmx_helper_get_interface_index_num(xipd_port);
+	pknd = cvmx_helper_get_pknd(xiface, index);
 
 	if (cvmx_pki_write_pkind_config(xp.node, pknd, &port_cfg->pkind_cfg))
 		return;
@@ -1521,17 +1521,17 @@ EXPORT_SYMBOL(cvmx_pki_set_port_config);
 /**
  * This function displays all the PKI parameters related to that
  * particular port.
- * @param ipd_port	ipd port number to display parameter of
+ * @param xipd_port	ipd port number to display parameter of
  */
-void cvmx_helper_pki_show_port_config(int ipd_port)
+void cvmx_helper_pki_show_port_config(int xipd_port)
 {
-	int interface, index, pknd;
-	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(ipd_port);
+	int xiface, index, pknd;
+	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
 
-	interface = cvmx_helper_get_interface_num(ipd_port);
-	index = cvmx_helper_get_interface_index_num(ipd_port);
-	pknd = cvmx_helper_get_pknd(interface, index);
-	cvmx_dprintf("Showing stats for intf 0x%x port %d------------------\n", interface, index);
+	xiface = cvmx_helper_get_interface_num(xipd_port);
+	index = cvmx_helper_get_interface_index_num(xipd_port);
+	pknd = cvmx_helper_get_pknd(xiface, index);
+	cvmx_dprintf("Showing stats for intf 0x%x port %d------------------\n", xiface, index);
 	cvmx_pki_show_pkind_attributes(xp.node, pknd);
 	cvmx_dprintf("END STAUS------------------------\n\n");
 }
@@ -1690,7 +1690,7 @@ void cvmx_pki_dump_wqe(const cvmx_wqe_78xx_t *wqp)
  * Modifies maximum frame length to check.
  * It modifies the global frame length set used by this port, any other
  * port using the same set will get affected too.
- * @param ipd_port	ipd port for which to modify max len.
+ * @param xipd_port	ipd port for which to modify max len.
  * @param max_size	maximum frame length
  */
 void cvmx_pki_set_max_frm_len(int ipd_port, uint32_t max_size)
@@ -1698,7 +1698,7 @@ void cvmx_pki_set_max_frm_len(int ipd_port, uint32_t max_size)
 	/* On CN78XX frame check is enabled for a style n and
 	PKI_CLX_STYLE_CFG[minmax_sel] selects which set of
 	MAXLEN/MINLEN to use. */
-	int interface, index, pknd;
+	int xiface, index, pknd;
 	cvmx_pki_clx_stylex_cfg_t style_cfg;
 	cvmx_pki_frm_len_chkx_t frame_len;
 	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(ipd_port);
@@ -1707,9 +1707,9 @@ void cvmx_pki_set_max_frm_len(int ipd_port, uint32_t max_size)
 	int sel;
 
 	/* get the pkind used by this ipd port */
-	interface = cvmx_helper_get_interface_num(ipd_port);
+	xiface = cvmx_helper_get_interface_num(ipd_port);
 	index = cvmx_helper_get_interface_index_num(ipd_port);
-	pknd = cvmx_helper_get_pknd(interface, index);
+	pknd = cvmx_helper_get_pknd(xiface, index);
 
 	style = cvmx_pki_get_pkind_style(xp.node, pknd);
 	style_cfg.u64 = cvmx_read_csr_node(xp.node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
@@ -1731,13 +1731,14 @@ void cvmx_pki_set_max_frm_len(int ipd_port, uint32_t max_size)
  */
 void cvmx_helper_pki_set_fcs_op(int node, int interface, int nports, int has_fcs)
 {
-	int index;
+	int xiface, index;
 	int pknd;
 	unsigned cluster = 0;
 	cvmx_pki_clx_pkindx_cfg_t pkind_cfg;
 
+	xiface = cvmx_helper_node_interface_to_xiface(node, interface);
 	for (index = 0; index < nports; index++) {
-		pknd = cvmx_helper_get_pknd(interface, index);
+		pknd = cvmx_helper_get_pknd(xiface, index);
 		while (cluster < CVMX_PKI_NUM_CLUSTER) {
 			/*find the cluster in use pass2*/
 			pkind_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_CFG(pknd, cluster));
@@ -1768,7 +1769,7 @@ void cvmx_helper_pki_set_fcs_op(int node, int interface, int nports, int has_fcs
  */
 void cvmx_helper_pki_set_wqe_mode(int node, bool pkt_outside_wqe)
 {
-	int interface, port, pknd;
+	int interface, xiface, port, pknd;
 	int num_intf, num_ports;
 	uint64_t style;
 
@@ -1779,8 +1780,9 @@ void cvmx_helper_pki_set_wqe_mode(int node, bool pkt_outside_wqe)
 		/*Skip invalid/disabled interfaces */
 		if (num_ports <= 0)
 			continue;
+		xiface = cvmx_helper_node_interface_to_xiface(node, interface);
 		for (port = 0; port < num_ports; port++) {
-			pknd = cvmx_helper_get_pknd(interface, port);
+			pknd = cvmx_helper_get_pknd(xiface, port);
 			style = cvmx_pki_get_pkind_style(node, pknd);
 			cvmx_pki_set_wqe_mode(node, style, pkt_outside_wqe);
 		}
@@ -1796,7 +1798,7 @@ void cvmx_helper_pki_set_wqe_mode(int node, bool pkt_outside_wqe)
  */
 void cvmx_helper_pki_set_little_endian(int node)
 {
-	int interface, port, pknd;
+	int interface, xiface, port, pknd;
 	int num_intf, num_ports;
 	uint64_t style;
 
@@ -1807,8 +1809,9 @@ void cvmx_helper_pki_set_little_endian(int node)
 		/*Skip invalid/disabled interfaces */
 		if (num_ports <= 0)
 			continue;
+		xiface = cvmx_helper_node_interface_to_xiface(node, interface);
 		for (port = 0; port < num_ports; port++) {
-			pknd = cvmx_helper_get_pknd(interface, port);
+			pknd = cvmx_helper_get_pknd(xiface, port);
 			style = cvmx_pki_get_pkind_style(node, pknd);
 			cvmx_pki_set_little_endian(node, style);
 		}
@@ -1822,14 +1825,14 @@ void cvmx_helper_pki_set_little_endian(int node)
  * @param grp_bad			sso group where errored packets are routed
  * NOTE: This function assumes that each port has its own style/profile and is not using qpg qos
  */
-void cvmx_helper_pki_modify_prtgrp(int ipd_port, int grp_ok, int grp_bad)
+void cvmx_helper_pki_modify_prtgrp(int xipd_port, int grp_ok, int grp_bad)
 {
-	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(ipd_port);
+	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
 	struct cvmx_pki_port_config port_cfg;
 	struct cvmx_pki_qpg_config qpg_cfg;
 	int index;
 
-	cvmx_pki_get_port_config(ipd_port, &port_cfg);
+	cvmx_pki_get_port_config(xipd_port, &port_cfg);
 	/* TODO: expand it to calculate index in other cases hrm:10.5.3*/
 	index = port_cfg.style_cfg.parm_cfg.qpg_base;
 	cvmx_pki_read_qpg_entry(xp.node, index, &qpg_cfg);
@@ -1994,7 +1997,7 @@ pcam_dmacl:
  * @return 			success: final style containing routed sso group
  *				fail: -1
  */
-int cvmx_helper_pki_route_prt_dmac(int ipd_port, uint64_t mac_addr, uint64_t mac_addr_mask, int grp)
+int cvmx_helper_pki_route_prt_dmac(int xipd_port, uint64_t mac_addr, uint64_t mac_addr_mask, int grp)
 {
 	int style;
 	int new_style;
@@ -2002,11 +2005,11 @@ int cvmx_helper_pki_route_prt_dmac(int ipd_port, uint64_t mac_addr, uint64_t mac
 	struct cvmx_pki_style_config st_cfg;
 	struct cvmx_pki_port_config port_cfg;
 	struct cvmx_pki_qpg_config qpg_cfg;
-	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(ipd_port);
+	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
 	int node = xp.node;
 
 	/* 1. Get the current/initial style config used by this port */
-	cvmx_pki_get_port_config(ipd_port, &port_cfg);
+	cvmx_pki_get_port_config(xipd_port, &port_cfg);
 	style = port_cfg.pkind_cfg.initial_style;
 	st_cfg = port_cfg.style_cfg;
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index 23bb11d..b8b99d7 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -964,6 +964,16 @@ int cvmx_helper_pko3_init_interface(int xiface)
 	else if (mode == CVMX_HELPER_INTERFACE_MODE_ILK) {
 		unsigned num_chans = __cvmx_helper_ilk_enumerate(xiface);
 		num_queues = 8; qos = true; pfc = false;
+
+		if (num_chans >= 128)
+		 	num_queues = 1;
+		else if (num_chans >= 64)
+			num_queues = 2;
+		else if (num_chans >= 32)
+			num_queues = 4;
+		else
+			num_queues = 8;
+
 		res = __cvmx_pko3_config_chan_interface(xiface, num_chans,
 				num_queues, qos);
 	}
@@ -1498,7 +1508,8 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 	chlvl.u64 = cvmx_read_csr_node(node, CVMX_PKO_CHANNEL_LEVEL);
 	shapercfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_SHAPER_CFG);
 	PARPRINT(0, "CC Level", "%*d\n", PKO_PRN_DPLEN(1), chlvl.s.cc_level + 2);
-	PARPRINT(0, "Color Aware", "%*s\n", PKO_PRN_DPLEN(1), (shapercfg.s.color_aware == 1) ? "Yes":"No");
+	PARPRINT(0, "Color Aware", "%*s\n", PKO_PRN_DPLEN(1),
+		(shapercfg.s.color_aware == 1) ? "Yes":"No");
 
 	/* Queues: */
 	cvmx_printf("%-*s%*s%*s%*s%*s%*s%*s%*s%*s\n", PKO_PRN_HEADLEN, "",
@@ -1632,7 +1643,7 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 		if (chlvl.s.cc_level == 0) { /* Level 2 as the Channel Level?*/
 			chcfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_L2_SQX_CHANNEL(l3top.s.parent));
 			sprintf(lines[2], "%s", "--");
-			sprintf(lines[3], "%d", chcfg.s.cc_channel);
+			sprintf(lines[3], "0x%X", chcfg.s.cc_channel);
 		}
 		else {
 			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
@@ -1692,9 +1703,12 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 				PKO_PRN_DPLEN(8), l2sch.s.rr_quantum, PKO_PRN_DPLEN(8), l1sch.s.rr_quantum,
 				PKO_PRN_DPLEN(8), "(hex)", PKO_PRN_DPLEN(8), "");
 			PARPRINT(2, "Len.Disable", "%*d%*d%*d%*d%*d%*d%*s%*s\n",
-				PKO_PRN_DPLEN(8), dqshape.s.length_disable, PKO_PRN_DPLEN(8), l5shape.s.length_disable,
-				PKO_PRN_DPLEN(8), l4shape.s.length_disable, PKO_PRN_DPLEN(8), l3shape.s.length_disable,
-				PKO_PRN_DPLEN(8), l2shape.s.length_disable, PKO_PRN_DPLEN(8), l1shape.s.length_disable,
+				PKO_PRN_DPLEN(8), dqshape.s.length_disable,
+				PKO_PRN_DPLEN(8), l5shape.s.length_disable,
+				PKO_PRN_DPLEN(8), l4shape.s.length_disable,
+				PKO_PRN_DPLEN(8), l3shape.s.length_disable,
+				PKO_PRN_DPLEN(8), l2shape.s.length_disable,
+				PKO_PRN_DPLEN(8), l1shape.s.length_disable,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
 			PARPRINT(2, "Len.Adjust", "%*d%*d%*d%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqshape.s.adjust, PKO_PRN_DPLEN(8), l5shape.s.adjust,
@@ -1703,13 +1717,17 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
 			if (ciren || piren) {
 				PARPRINT(2, "YELLOW Dis", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
-					PKO_PRN_DPLEN(8), dqshape.s.yellow_disable, PKO_PRN_DPLEN(8), l5shape.s.yellow_disable,
-					PKO_PRN_DPLEN(8), l4shape.s.yellow_disable, PKO_PRN_DPLEN(8), l3shape.s.yellow_disable,
+					PKO_PRN_DPLEN(8), dqshape.s.yellow_disable,
+					PKO_PRN_DPLEN(8), l5shape.s.yellow_disable,
+					PKO_PRN_DPLEN(8), l4shape.s.yellow_disable,
+					PKO_PRN_DPLEN(8), l3shape.s.yellow_disable,
 					PKO_PRN_DPLEN(8), l2shape.s.yellow_disable, PKO_PRN_DPLEN(8), "--",
 					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
 				PARPRINT(2, "RED Dis", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
-					PKO_PRN_DPLEN(8), dqshape.s.red_disable, PKO_PRN_DPLEN(8), l5shape.s.red_disable,
-					PKO_PRN_DPLEN(8), l4shape.s.red_disable, PKO_PRN_DPLEN(8), l3shape.s.red_disable,
+					PKO_PRN_DPLEN(8), dqshape.s.red_disable,
+					PKO_PRN_DPLEN(8), l5shape.s.red_disable,
+					PKO_PRN_DPLEN(8), l4shape.s.red_disable,
+					PKO_PRN_DPLEN(8), l3shape.s.red_disable,
 					PKO_PRN_DPLEN(8), l2shape.s.red_disable, PKO_PRN_DPLEN(8), "--",
 					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
 				PARPRINT(2, "RED Algo", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
@@ -1806,7 +1824,8 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 			PARPRINT(2, "Len.Disable", "%*d%*s%*s%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqshape.s.length_disable, PKO_PRN_DPLEN(8), "",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.length_disable,
-				PKO_PRN_DPLEN(8), l2shape.s.length_disable, PKO_PRN_DPLEN(8), l1shape.s.length_disable,
+				PKO_PRN_DPLEN(8), l2shape.s.length_disable,
+				PKO_PRN_DPLEN(8), l1shape.s.length_disable,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
 			PARPRINT(2, "Len.Adjust", "%*d%*s%*s%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqshape.s.adjust, PKO_PRN_DPLEN(8), "",
@@ -1919,18 +1938,25 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 	return 0;
 }
 
-static int pko3_find_l1q_from_dq(int node, int dq)
+static int __cvmx_pko3_find_l1q_from_dq(int node, int dq)
 {
-	int queue, nqueues;
-	cvmx_pko_l1_sqx_pick_t l1pick;
+	cvmx_pko_dqx_topology_t dqtop;
+	cvmx_pko_l5_sqx_topology_t l5top;
+	cvmx_pko_l4_sqx_topology_t l4top;
+	cvmx_pko_l3_sqx_topology_t l3top;
+	cvmx_pko_l2_sqx_topology_t l2top;
 
-	nqueues = cvmx_pko3_num_level_queues(CVMX_PKO_PORT_QUEUES);
-	for (queue = 0; queue < nqueues; queue++) {
-		l1pick.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_PICK(queue));
-		if (l1pick.s.dq == dq)
-			return queue;
+	dqtop.u64 = cvmx_read_csr_node(node, CVMX_PKO_DQX_TOPOLOGY(dq));
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) { 
+		l5top.u64 = cvmx_read_csr_node(node, CVMX_PKO_L5_SQX_TOPOLOGY(dqtop.s.parent));
+		l4top.u64 = cvmx_read_csr_node(node, CVMX_PKO_L4_SQX_TOPOLOGY(l5top.s.parent));
+		l3top.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_SQX_TOPOLOGY(l4top.s.parent));
 	}
-	return -1;
+	else
+		l3top.u64 = cvmx_read_csr_node(node, CVMX_PKO_L3_SQX_TOPOLOGY(dqtop.s.parent));
+
+	l2top.u64 = cvmx_read_csr_node(node, CVMX_PKO_L2_SQX_TOPOLOGY(l3top.s.parent));
+	return l2top.s.parent;
 }
 
 #undef PKO_PRN_HEADLEN
@@ -1970,15 +1996,17 @@ int cvmx_helper_pko3_stats_dump(unsigned int node)
 		n = dq_pkts.s.count + dq_bytes.s.count + dq_drppkts.s.count + dq_drpbytes.s.count;
 		if (n == 0)
 			continue;
-		cvmx_printf("DQ%d => L1-SQ%d\n", queue, pko3_find_l1q_from_dq(node, queue));
+		cvmx_printf("DQ%d => L1-SQ%d\n", queue, __cvmx_pko3_find_l1q_from_dq(node, queue));
 		if (dq_pkts.s.count)
 			PARPRINT(4, "Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)dq_pkts.s.count);
 		if (dq_bytes.s.count)
 			PARPRINT(4, "Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)dq_bytes.s.count);
 		if (dq_drppkts.s.count)
-			PARPRINT(4, "Dropped Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)dq_drppkts.s.count);
+			PARPRINT(4, "Dropped Packets", "%*lld\n",
+				PKO_PRN_DPLEN(1), (long long)dq_drppkts.s.count);
 		if (dq_drpbytes.s.count)
-			PARPRINT(4, "Dropped Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)dq_drpbytes.s.count);
+			PARPRINT(4, "Dropped Bytes", "%*lld\n",
+				PKO_PRN_DPLEN(1), (long long)dq_drpbytes.s.count);
 	}
 	DLMPRINT("Port(L1) Queues:");
 	nqueues = cvmx_pko3_num_level_queues(CVMX_PKO_PORT_QUEUES);
@@ -1992,8 +2020,9 @@ int cvmx_helper_pko3_stats_dump(unsigned int node)
 		l1_redbytes.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_RED_BYTES(queue));
 		l1_drppkts.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_DROPPED_PACKETS(queue));
 		l1_drpbytes.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_DROPPED_BYTES(queue));
-		n = l1_grnpkts.s.count + l1_grnbytes.s.count + l1_yelpkts.s.count + l1_yelbytes.s.count +
-			l1_redpkts.s.count + l1_redbytes.s.count + l1_drppkts.s.count + l1_drpbytes.s.count;
+		n = l1_grnpkts.s.count + l1_grnbytes.s.count + l1_yelpkts.s.count +
+			l1_yelbytes.s.count + l1_redpkts.s.count + l1_redbytes.s.count +
+			l1_drppkts.s.count + l1_drpbytes.s.count;
 		if (n == 0)
 			continue;
 
@@ -2013,25 +2042,60 @@ int cvmx_helper_pko3_stats_dump(unsigned int node)
 				sprintf(lines[0], "%s", pko_macmap[l1top.s.link][2]);
 			maccfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_MACX_CFG(l1top.s.link));
 		}
-		cvmx_printf("L1-SQ%d => MAC%d (%s) => FIFO%d:\n", queue, l1top.s.link, lines[0], maccfg.s.fifo_num);
+		cvmx_printf("L1-SQ%d => MAC%d (%s) => FIFO%d:\n",
+			queue, l1top.s.link, lines[0], maccfg.s.fifo_num);
 		if (l1_grnpkts.s.count)
-			PARPRINT(4, "Green Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_grnpkts.s.count);
+			PARPRINT(4, "Green Packets", "%*lld\n",
+				PKO_PRN_DPLEN(1), (long long)l1_grnpkts.s.count);
 		if (l1_grnbytes.s.count)
-			PARPRINT(4, "Green Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_grnbytes.s.count);
+			PARPRINT(4, "Green Bytes", "%*lld\n",
+				PKO_PRN_DPLEN(1), (long long)l1_grnbytes.s.count);
 		if (l1_yelpkts.s.count)
-			PARPRINT(4, "Yellow Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_yelpkts.s.count);
+			PARPRINT(4, "Yellow Packets", "%*lld\n",
+				PKO_PRN_DPLEN(1), (long long)l1_yelpkts.s.count);
 		if (l1_yelbytes.s.count)
-			PARPRINT(4, "Yellow Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_yelbytes.s.count);
+			PARPRINT(4, "Yellow Bytes", "%*lld\n",
+				PKO_PRN_DPLEN(1), (long long)l1_yelbytes.s.count);
 		if (l1_redpkts.s.count)
-			PARPRINT(4, "Red Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_redpkts.s.count);
+			PARPRINT(4, "Red Packets", "%*lld\n",
+				PKO_PRN_DPLEN(1), (long long)l1_redpkts.s.count);
 		if (l1_redbytes.s.count)
-			PARPRINT(4, "Red Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_redbytes.s.count);
+			PARPRINT(4, "Red Bytes", "%*lld\n",
+				PKO_PRN_DPLEN(1), (long long)l1_redbytes.s.count);
 		if (l1_drppkts.s.count)
-			PARPRINT(4, "Dropped Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_drppkts.s.count);
+			PARPRINT(4, "Dropped Packets", "%*lld\n",
+				PKO_PRN_DPLEN(1), (long long)l1_drppkts.s.count);
 		if (l1_drpbytes.s.count)
-			PARPRINT(4, "Dropped Bytes", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_drpbytes.s.count);
+			PARPRINT(4, "Dropped Bytes", "%*lld\n",
+				PKO_PRN_DPLEN(1), (long long)l1_drpbytes.s.count);
 	}
 	return 0;
 }
+void cvmx_helper_pko3_stats_clear(unsigned int node)
+{
+	int queue, nqueues;
+
+	nqueues = cvmx_pko3_num_level_queues(CVMX_PKO_DESCR_QUEUES);
+	for (queue = 0; queue < nqueues; queue++) {
+		cvmx_write_csr_node(node, CVMX_PKO_DQX_PACKETS(queue), 0ull);
+		cvmx_write_csr_node(node, CVMX_PKO_DQX_BYTES(queue), 0ull);
+		cvmx_write_csr_node(node, CVMX_PKO_DQX_DROPPED_PACKETS(queue), 0ull);
+		cvmx_write_csr_node(node, CVMX_PKO_DQX_DROPPED_BYTES(queue), 0ull);
+	}
+	nqueues = cvmx_pko3_num_level_queues(CVMX_PKO_PORT_QUEUES);
+	for (queue = 0; queue < nqueues; queue++) {
+		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_GREEN_PACKETS(queue), 0ull);
+		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_GREEN_BYTES(queue), 0ull);
+		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_YELLOW_PACKETS(queue), 0ull);
+		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_YELLOW_BYTES(queue), 0ull);
+		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_RED_PACKETS(queue), 0ull);
+		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_RED_BYTES(queue), 0ull);
+		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_DROPPED_PACKETS(queue), 0ull);
+		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_DROPPED_BYTES(queue), 0ull);
+	}
+	cvmx_write_csr_node(node, CVMX_PKO_PEB_ERR_INT, ~0ull);
+	cvmx_write_csr_node(node, CVMX_PKO_NCB_INT, ~0ull);
+}
+
 #endif /* CVMX_DUMP_PKO */
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-ila.c b/arch/mips/cavium-octeon/executive/cvmx-ila.c
index e45c50b..1401a0c 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-ila.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-ila.c
@@ -47,6 +47,7 @@
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <linux/slab.h>
 #include <linux/export.h>
+#include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx.h>
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-ila.h>
@@ -167,7 +168,10 @@ retry:
 		goto retry;
 	}
 
-#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	/* Enable error interrupts, now link is up */
+	octeon_error3_tree_enable(CVMX_ERROR_GROUP_ILA, 0);
+#else
 	/* Enable error interrupts, now link is up */
 	cvmx_error_enable_group(CVMX_ERROR_GROUP_ILA, 0);
 #endif
@@ -186,7 +190,10 @@ fail:
 		rx_cfg1.s.pkt_ena = 0;
 		cvmx_write_csr_node(node, CVMX_ILA_RXX_CFG1(0), rx_cfg1.u64);
 
-#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+		/* Disable error interrupts */
+		octeon_error3_tree_disable(CVMX_ERROR_GROUP_ILA, 0);
+#else
 		/* Disable error interrupts */
 		cvmx_error_disable_group(CVMX_ERROR_GROUP_ILA, 0);
 #endif
@@ -314,3 +321,17 @@ cvmx_ila_header_t cvmx_ila_configure_header(int channel, int mode)
 	return ila_header;
 }
 EXPORT_SYMBOL(cvmx_ila_configure_header);
+
+/**
+ * Reset ILA interface
+ */
+void cvmx_ila_reset(void)
+{
+	cvmx_ila_gbl_cfg_t gbl_cfg;
+	int node = cvmx_get_node_num();
+
+	gbl_cfg.u64 = cvmx_read_csr_node(node, CVMX_ILA_GBL_CFG);
+	gbl_cfg.s.reset = 1;
+	cvmx_write_csr_node(node, CVMX_ILA_GBL_CFG, gbl_cfg.u64);
+}
+EXPORT_SYMBOL(cvmx_ila_reset);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-ilk.c b/arch/mips/cavium-octeon/executive/cvmx-ilk.c
index 7e2952c..84f2758 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-ilk.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-ilk.c
@@ -80,15 +80,11 @@ CVMX_SHARED unsigned short cvmx_ilk_lane_mask[CVMX_MAX_NODES][CVMX_NUM_ILK_INTF]
  		{0x000f, 0x00f0}
 	};
 
-CVMX_SHARED unsigned char cvmx_ilk_chans[CVMX_MAX_NODES][CVMX_NUM_ILK_INTF] =
+CVMX_SHARED int cvmx_ilk_chans[CVMX_MAX_NODES][CVMX_NUM_ILK_INTF] =
 	{[0 ... CVMX_MAX_NODES - 1] =
 		 {8,8}
 	};
 
-unsigned char cvmx_ilk_chan_map[CVMX_NUM_ILK_INTF][CVMX_ILK_MAX_CHANS] = { {0, 1, 2, 3, 4, 5, 6, 7},
-{0, 1, 2, 3, 4, 5, 6, 7}
-};
-
 static cvmx_ilk_intf_t cvmx_ilk_intf_cfg[CVMX_MAX_NODES][CVMX_NUM_ILK_INTF];
 
 CVMX_SHARED cvmx_ilk_LA_mode_t cvmx_ilk_LA_mode[CVMX_NUM_ILK_INTF] = {{0, 0},
@@ -290,7 +286,7 @@ int cvmx_ilk_start_interface(int interface, unsigned short lane_mask)
 	}
 
 	/* Initialize all calendar entries to xoff state */
-	__cvmx_ilk_init_cal((node << 4) | interface);
+	__cvmx_ilk_clear_cal((node << 4) | interface);
 
 	/* Enable ILK LA mode if configured. */
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
@@ -455,7 +451,7 @@ int cvmx_ilk_rx_set_pknd(int xiface, cvmx_ilk_chan_pknd_t * chpknd, unsigned int
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int interface = xi.interface - CVMX_ILK_GBL_BASE();
 
-	if (!octeon_has_feature(OCTEON_FEATURE_ILK))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX)))
 		return res;
 
 	if (interface >= CVMX_NUM_ILK_INTF)
@@ -467,24 +463,20 @@ int cvmx_ilk_rx_set_pknd(int xiface, cvmx_ilk_chan_pknd_t * chpknd, unsigned int
 	res = 0;
 
 	for (i = 0; i < num_pknd; i++) {
-		if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
-			ilk_rxf_idx_pmap.u64 = 0;
-			/* write the pair to ilk rx. note the channels for different interfaces
-			 * are given in *chpknd and interface is not used as a param */
-			if ((chpknd->chan < 2) && cvmx_ilk_use_la_mode(interface, chpknd->chan)) {
-				ilk_rxf_idx_pmap.s.index = interface * 256 + 128 + chpknd->chan;
-				cvmx_write_csr(CVMX_ILK_RXF_IDX_PMAP, ilk_rxf_idx_pmap.u64);
-				cvmx_write_csr(CVMX_ILK_RXF_MEM_PMAP, chpknd->pknd);
-			}
-			ilk_rxf_idx_pmap.s.index = interface * 256 + chpknd->chan;
+		ilk_rxf_idx_pmap.u64 = 0;
+		/* write the pair to ilk rx. note the channels for different interfaces
+		 * are given in *chpknd and interface is not used as a param */
+		if ((chpknd->chan < 2) && cvmx_ilk_use_la_mode(interface, chpknd->chan)) {
+			ilk_rxf_idx_pmap.s.index = interface * 256 + 128 + chpknd->chan;
 			cvmx_write_csr(CVMX_ILK_RXF_IDX_PMAP, ilk_rxf_idx_pmap.u64);
 			cvmx_write_csr(CVMX_ILK_RXF_MEM_PMAP, chpknd->pknd);
 		}
-		if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
-			cvmx_write_csr_node(xi.node, CVMX_ILK_RXX_CHAX(chpknd->chan, interface), chpknd->pknd);
-		}
+		ilk_rxf_idx_pmap.s.index = interface * 256 + chpknd->chan;
+		cvmx_write_csr(CVMX_ILK_RXF_IDX_PMAP, ilk_rxf_idx_pmap.u64);
+		cvmx_write_csr(CVMX_ILK_RXF_MEM_PMAP, chpknd->pknd);
 		chpknd++;
 	}
+
 	return res;
 }
 
@@ -514,7 +506,9 @@ int cvmx_ilk_rx_cal_conf(int intf, int cal_depth, cvmx_ilk_cal_entry_t * pent)
 	if (interface >= CVMX_NUM_ILK_INTF)
 		return res;
 
-	if (cal_depth < CVMX_ILK_RX_MIN_CAL || cal_depth > CVMX_ILK_MAX_CAL || pent == NULL)
+	if (cal_depth < CVMX_ILK_RX_MIN_CAL
+	    || cal_depth > CVMX_ILK_MAX_CAL
+	    || (OCTEON_IS_MODEL(OCTEON_CN68XX) && pent == NULL))
 		return res;
 
 	/* mandatory link-level fc as workarounds for ILK-15397 and ILK-15479 */
@@ -558,8 +552,7 @@ int cvmx_ilk_rx_cal_conf(int intf, int cal_depth, cvmx_ilk_cal_entry_t * pent)
 		cvmx_write_csr_node(node, CVMX_ILK_RXX_CFG0(interface), ilk_rxx_cfg0.u64);
 
 		for (i = 0; i < cal_depth; i++) {
-				__cvmx_ilk_write_rx_cal_entry(intf, i,
-							      pent[i].pipe_bpid);
+				__cvmx_ilk_write_rx_cal_entry(intf, i, 0);
 		}
 
 		ilk_rxx_cfg0.u64 = cvmx_read_csr_node(node, CVMX_ILK_RXX_CFG0(interface));
@@ -705,7 +698,9 @@ int cvmx_ilk_tx_cal_conf(int intf, int cal_depth, cvmx_ilk_cal_entry_t * pent)
 	if (interface >= CVMX_NUM_ILK_INTF)
 		return res;
 
-	if (cal_depth < CVMX_ILK_TX_MIN_CAL || cal_depth > CVMX_ILK_MAX_CAL || pent == NULL)
+	if (cal_depth < CVMX_ILK_TX_MIN_CAL
+	    || cal_depth > CVMX_ILK_MAX_CAL
+	    || (OCTEON_IS_MODEL(OCTEON_CN68XX) && pent == NULL))
 		return res;
 
 	/* mandatory link-level fc as workarounds for ILK-15397 and ILK-15479 */
@@ -740,9 +735,7 @@ int cvmx_ilk_tx_cal_conf(int intf, int cal_depth, cvmx_ilk_cal_entry_t * pent)
 		cvmx_write_csr_node(node, CVMX_ILK_TXX_CFG0(interface), ilk_txx_cfg0.u64);
 
 		for (i = 0; i < cal_depth; i++) {
-			__cvmx_ilk_write_tx_cal_entry(intf, i,
-						      pent[i].pipe_bpid);
-			pent++;
+			__cvmx_ilk_write_tx_cal_entry(intf, i, 0);
 		}
 
 		ilk_txx_cfg0.u64 = cvmx_read_csr_node(node, CVMX_ILK_TXX_CFG0(interface));
@@ -1222,24 +1215,6 @@ int cvmx_ilk_get_intf_ena(int xiface)
 }
 
 /**
- * Provide channel info
- *
- * @param interface The identifier of the packet interface to disable. cn68xx
- *                  has 2 interfaces: ilk0 and ilk1.
- * @param chans    A pointer to a channel array
- * @param num_chan A pointer to the number of channels
- *
- * @return Zero on success, negative on failure.
- */
-int cvmx_ilk_get_chan_info(int interface, unsigned char **chans, unsigned char *num_chan)
-{
-	*chans = cvmx_ilk_chan_map[interface];
-	*num_chan = cvmx_ilk_chans[0][interface];
-
-	return 0;
-}
-
-/**
  * Enable or disable LA mode in ILK header.
  * For normal ILK mode, enable CRC and skip = 0.
  * For ILK LA mode, disable CRC and set skip to size of ILK header.
@@ -1358,7 +1333,7 @@ void cvmx_ilk_show_stats(int interface, cvmx_ilk_stats_ctrl_t * pstats)
 
 	/* discrete channels */
 	if (pstats->chan_list != NULL) {
-		unsigned int *chan_list = pstats->chan_list;
+		int *chan_list = pstats->chan_list;
 		for (i = 0; i < pstats->num_chans; i++) {
 			if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
 				/* get the number of rx packets */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index 8c8a6ad..7a69082 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 124105 $<hr>
+ * <hr>$Revision: 127467 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1407,6 +1407,8 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 			qlm_cfg.u64 = cvmx_read_csr(CVMX_MIO_QLMX_CFG(1));
 			if (qlm_cfg.s.qlm_cfg == 1)
 				qlm = 1;
+			else
+				qlm = pcie_port;
 		}
 		/* PCIe is allowed only in QLM1, 1 PCIe port in x2 or
 		 * 2 PCIe ports in x1
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pki.c b/arch/mips/cavium-octeon/executive/cvmx-pki.c
index fc936d4c..97152b4 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pki.c
@@ -61,68 +61,67 @@
 #include "cvmx-pki-resources.h"
 #endif
 
-
 /**
- * This function enables pki
- * @param node	node to enable pki in.
+ * This function enables PKI
+ *
+ * @param node  Node to enable PKI.
  */
 void cvmx_pki_enable(int node)
 {
+	cvmx_pki_sft_rst_t sft_rst;
+	cvmx_pki_buf_ctl_t buf_ctl;
 
-	cvmx_pki_sft_rst_t pki_sft_rst;
-	cvmx_pki_buf_ctl_t pki_en;
-
-	pki_sft_rst.u64 = cvmx_read_csr_node(node, CVMX_PKI_SFT_RST);
-
-	while (pki_sft_rst.s.busy != 0)
-		pki_sft_rst.u64 = cvmx_read_csr_node(node, CVMX_PKI_SFT_RST);
+	sft_rst.u64 = cvmx_read_csr_node(node, CVMX_PKI_SFT_RST);
+	while (sft_rst.s.busy != 0)
+		sft_rst.u64 = cvmx_read_csr_node(node, CVMX_PKI_SFT_RST);
 
-	pki_en.u64 = cvmx_read_csr_node(node, CVMX_PKI_BUF_CTL);
-	if (pki_en.s.pki_en)
+	buf_ctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_BUF_CTL);
+	if (buf_ctl.s.pki_en)
 		cvmx_dprintf("Warning: Enabling PKI when PKI already enabled.\n");
 
-	pki_en.s.pki_en = 1;
-
-	cvmx_write_csr_node(node, CVMX_PKI_BUF_CTL, pki_en.u64);
+	buf_ctl.s.pki_en = 1;
+	cvmx_write_csr_node(node, CVMX_PKI_BUF_CTL, buf_ctl.u64);
 
 }
 EXPORT_SYMBOL(cvmx_pki_enable);
 
 /**
- * This function disables pki
- * @param node	node to disable pki in.
+ * This function disables PKI.
+ *
+ * @param node  Node to disable PKI.
  */
 void cvmx_pki_disable(int node)
 {
-	cvmx_pki_buf_ctl_t pki_en;
-	pki_en.u64 = cvmx_read_csr_node(node, CVMX_PKI_BUF_CTL);
-	pki_en.s.pki_en = 0;
-	cvmx_write_csr_node(node, CVMX_PKI_BUF_CTL, pki_en.u64);
-
+	cvmx_pki_buf_ctl_t buf_ctl;
+	buf_ctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_BUF_CTL);
+	buf_ctl.s.pki_en = 0;
+	cvmx_write_csr_node(node, CVMX_PKI_BUF_CTL, buf_ctl.u64);
 }
 EXPORT_SYMBOL(cvmx_pki_disable);
 
 /**
- * This function soft resets pki
- * @param node	node to enable pki in.
+ * This function soft resets PKI.
+ *
+ * @param node  Node to enable PKI.
  */
 void cvmx_pki_reset(int node)
 {
-	cvmx_pki_sft_rst_t pki_sft_rst;
+	cvmx_pki_sft_rst_t sft_rst;
 
-	pki_sft_rst.u64 = cvmx_read_csr_node(node, CVMX_PKI_SFT_RST);
+	sft_rst.u64 = cvmx_read_csr_node(node, CVMX_PKI_SFT_RST);
+	while (sft_rst.s.active != 0)
+		sft_rst.u64 = cvmx_read_csr_node(node, CVMX_PKI_SFT_RST);
 
-	while (pki_sft_rst.s.active != 0)
-		pki_sft_rst.u64 = cvmx_read_csr_node(node, CVMX_PKI_SFT_RST);
-	pki_sft_rst.s.rst = 1;
-	cvmx_write_csr_node(node, CVMX_PKI_SFT_RST, pki_sft_rst.u64);
-	while (pki_sft_rst.s.busy != 0)
-		pki_sft_rst.u64 = cvmx_read_csr_node(node, CVMX_PKI_SFT_RST);
+	sft_rst.s.rst = 1;
+	cvmx_write_csr_node(node, CVMX_PKI_SFT_RST, sft_rst.u64);
+	while (sft_rst.s.busy != 0)
+		sft_rst.u64 = cvmx_read_csr_node(node, CVMX_PKI_SFT_RST);
 }
 
 /**
- * This function sets the clusters in PKI
- * @param node	node to set clusters in.
+ * This function sets the clusters in PKI.
+ *
+ * @param node  Node to set clusters.
  */
 int cvmx_pki_setup_clusters(int node)
 {
@@ -137,36 +136,36 @@ EXPORT_SYMBOL(cvmx_pki_setup_clusters);
 
 /**
  * @INTERNAL
- * This function is called by cvmx_helper_shutdown() to extract
- * all FPA buffers out of the PKI. After this function
- * completes, all FPA buffers that were prefetched by PKI
- * wil be in the apropriate FPA pool. This functions does not reset
- * PKI.
- * WARNING: It is very important that PKI be
- * reset soon after a call to this function.
+ * This function is called by cvmx_helper_shutdown() to extract all FPA buffers
+ * out of the PKI. After this function completes, all FPA buffers that were
+ * prefetched by PKI will be in the apropriate FPA pool. This functions does
+ * not reset PKI.
+ * WARNING: It is very important that PKI be reset soon after a call to this function.
  */
 void __cvmx_pki_free_ptr(int node)
 {
 	cvmx_pki_buf_ctl_t buf_ctl;
+
 	buf_ctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_BUF_CTL);
-	/*Disable buffering any data*/
+	/* Disable buffering any data. */
 	buf_ctl.s.pkt_off = 1;
-	/*diable caching of any data and return all the prefetched buffers to fpa*/
+	/* Disable caching of any data and return all the prefetched buffers to FPA. */
 	buf_ctl.s.fpa_cac_dis = 1;
 	cvmx_write_csr_node(node, CVMX_PKI_BUF_CTL, buf_ctl.u64);
 }
 
 /**
  * This function reads global configuration of PKI block.
- * @param node		      node number.
- * @param gbl_cfg	      pointer to struct to read global configuration
+ *
+ * @param node  Node number.
+ * @param gbl_cfg  Pointer to struct to read global configuration.
  */
 void cvmx_pki_read_global_config(int node, struct cvmx_pki_global_config *gbl_cfg)
 {
 	cvmx_pki_stat_ctl_t stat_ctl;
-	cvmx_pki_icgx_cfg_t pki_cl_grp;
-	cvmx_pki_gbl_pen_t gbl_pen_reg;
-	cvmx_pki_tag_secret_t tag_secret_reg;
+	cvmx_pki_icgx_cfg_t icg_cfg;
+	cvmx_pki_gbl_pen_t gbl_pen;
+	cvmx_pki_tag_secret_t tag_secret;
 	cvmx_pki_frm_len_chkx_t frm_len_chk;
 	cvmx_pki_buf_ctl_t buf_ctl;
 	unsigned cl_grp;
@@ -176,35 +175,32 @@ void cvmx_pki_read_global_config(int node, struct cvmx_pki_global_config *gbl_cf
 	gbl_cfg->stat_mode = stat_ctl.s.mode;
 
 	for (cl_grp = 0; cl_grp < CVMX_PKI_NUM_CLUSTER_GROUP; cl_grp++) {
-		pki_cl_grp.u64 = cvmx_read_csr_node(node,
-			CVMX_PKI_ICGX_CFG(cl_grp));
-		gbl_cfg->cluster_mask[cl_grp] = pki_cl_grp.s.clusters;
+		icg_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_ICGX_CFG(cl_grp));
+		gbl_cfg->cluster_mask[cl_grp] = icg_cfg.s.clusters;
 	}
-	gbl_pen_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_GBL_PEN);
-	gbl_cfg->gbl_pen.virt_pen = gbl_pen_reg.s.virt_pen;
-	gbl_cfg->gbl_pen.clg_pen = gbl_pen_reg.s.clg_pen;
-	gbl_cfg->gbl_pen.cl2_pen = gbl_pen_reg.s.cl2_pen;
-	gbl_cfg->gbl_pen.l4_pen = gbl_pen_reg.s.l4_pen;
-	gbl_cfg->gbl_pen.il3_pen = gbl_pen_reg.s.il3_pen;
-	gbl_cfg->gbl_pen.l3_pen = gbl_pen_reg.s.l3_pen;
-	gbl_cfg->gbl_pen.mpls_pen = gbl_pen_reg.s.mpls_pen;
-	gbl_cfg->gbl_pen.fulc_pen = gbl_pen_reg.s.fulc_pen;
-	gbl_cfg->gbl_pen.dsa_pen = gbl_pen_reg.s.dsa_pen;
-	gbl_cfg->gbl_pen.hg_pen = gbl_pen_reg.s.hg_pen;
-
-	tag_secret_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_SECRET);
-	gbl_cfg->tag_secret.dst6 = tag_secret_reg.s.dst6;
-	gbl_cfg->tag_secret.src6 = tag_secret_reg.s.src6;
-	gbl_cfg->tag_secret.dst = tag_secret_reg.s.dst;
-	gbl_cfg->tag_secret.src = tag_secret_reg.s.src;
+	gbl_pen.u64 = cvmx_read_csr_node(node, CVMX_PKI_GBL_PEN);
+	gbl_cfg->gbl_pen.virt_pen = gbl_pen.s.virt_pen;
+	gbl_cfg->gbl_pen.clg_pen = gbl_pen.s.clg_pen;
+	gbl_cfg->gbl_pen.cl2_pen = gbl_pen.s.cl2_pen;
+	gbl_cfg->gbl_pen.l4_pen = gbl_pen.s.l4_pen;
+	gbl_cfg->gbl_pen.il3_pen = gbl_pen.s.il3_pen;
+	gbl_cfg->gbl_pen.l3_pen = gbl_pen.s.l3_pen;
+	gbl_cfg->gbl_pen.mpls_pen = gbl_pen.s.mpls_pen;
+	gbl_cfg->gbl_pen.fulc_pen = gbl_pen.s.fulc_pen;
+	gbl_cfg->gbl_pen.dsa_pen = gbl_pen.s.dsa_pen;
+	gbl_cfg->gbl_pen.hg_pen = gbl_pen.s.hg_pen;
+
+	tag_secret.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_SECRET);
+	gbl_cfg->tag_secret.dst6 = tag_secret.s.dst6;
+	gbl_cfg->tag_secret.src6 = tag_secret.s.src6;
+	gbl_cfg->tag_secret.dst = tag_secret.s.dst;
+	gbl_cfg->tag_secret.src = tag_secret.s.src;
 
 	for (id = 0; id < CVMX_PKI_NUM_FRAME_CHECK; id++) {
-		frm_len_chk.u64 = cvmx_read_csr_node(node,
-			CVMX_PKI_FRM_LEN_CHKX(id));
+		frm_len_chk.u64 = cvmx_read_csr_node(node, CVMX_PKI_FRM_LEN_CHKX(id));
 		gbl_cfg->frm_len[id].maxlen = frm_len_chk.s.maxlen;
 		gbl_cfg->frm_len[id].minlen = frm_len_chk.s.minlen;
 	}
-
 	buf_ctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_BUF_CTL);
 	gbl_cfg->fpa_wait = buf_ctl.s.fpa_wait;
 }
@@ -213,10 +209,10 @@ void cvmx_pki_read_global_config(int node, struct cvmx_pki_global_config *gbl_cf
  * This function writes max and min frame lengths to hardware which can be used
  * to check the size of frame arrived.There are 2 possible combination which are
  * indicated by id field.
- * @param node		node number.
- * @param id		choose which frame len register to write to
- * @param len_chk	struct containing Byte count for max-sized/min-sized frame check.
  *
+ * @param node  Node number.
+ * @param id  Choose which frame len register to write to
+ * @param len_chk  Struct containing byte count for max-sized/min-sized frame check.
  */
 static void cvmx_pki_write_frame_len(int node, int id,
 	struct cvmx_pki_frame_len len_chk)
@@ -230,8 +226,9 @@ static void cvmx_pki_write_frame_len(int node, int id,
 
 /**
  * This function writes global configuration of PKI into hw.
- * @param node		      node number.
- * @param gbl_cfg	      pointer to struct to global configuration
+ *
+ * @param node  Node number.
+ * @param gbl_cfg  Pointer to struct to global configuration.
  */
 void cvmx_pki_write_global_config(int node, struct cvmx_pki_global_config *gbl_cfg)
 {
@@ -258,174 +255,167 @@ void cvmx_pki_write_global_config(int node, struct cvmx_pki_global_config *gbl_c
 
 /**
  * This function reads per pkind parameters in hardware which defines how
-  the incoming packet is processed.
- * @param node		      node number.
- * @param pkind               PKI supports a large number of incoming interfaces
- *                            and packets arriving on different interfaces or channels
- *                            may want to be processed differently. PKI uses the pkind to
- *                            determine how the incoming packet is processed.
- * @param pkind_cfg	      pointer to struct conatining pkind configuration read from hw
+ * the incoming packet is processed.
+ *
+ * @param node  Node number.
+ * @param pkind  PKI supports a large number of incoming interfaces and packets
+ *     arriving on different interfaces or channels may want to be processed
+ *     differently. PKI uses the pkind to determine how the incoming packet
+ *     is processed.
+ * @param pkind_cfg  Pointer to struct conatining pkind configuration read
+ *     from the hardware.
  */
-int cvmx_pki_read_pkind_config(int node, int pkind, struct cvmx_pki_pkind_config *pkind_cfg)
+int cvmx_pki_read_pkind_config(int node, int pkind,
+	struct cvmx_pki_pkind_config *pkind_cfg)
 {
 	int cluster = 0;
 	uint64_t cl_mask;
-	cvmx_pki_pkindx_icgsel_t pkind_clsel;
-	cvmx_pki_clx_pkindx_style_t pkind_cfg_style;
-	cvmx_pki_icgx_cfg_t pki_cl_grp;
-	cvmx_pki_clx_pkindx_cfg_t pknd_cfg_reg;
-	cvmx_pki_clx_pkindx_skip_t pknd_skip_reg;
-
-	pkind_clsel.u64 = cvmx_read_csr_node(node,
-		CVMX_PKI_PKINDX_ICGSEL(pkind));
-	pki_cl_grp.u64 = cvmx_read_csr_node(node,
-		CVMX_PKI_ICGX_CFG(pkind_clsel.s.icg));
-	pkind_cfg->cluster_grp = (uint8_t)pkind_clsel.s.icg;
-	cl_mask = (uint64_t)pki_cl_grp.s.clusters;
+	cvmx_pki_pkindx_icgsel_t icgsel;
+	cvmx_pki_clx_pkindx_style_t pstyle;
+	cvmx_pki_icgx_cfg_t icg_cfg;
+	cvmx_pki_clx_pkindx_cfg_t pcfg;
+	cvmx_pki_clx_pkindx_skip_t skip;
+
+	icgsel.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKINDX_ICGSEL(pkind));
+	icg_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_ICGX_CFG(icgsel.s.icg));
+	pkind_cfg->cluster_grp = (uint8_t)icgsel.s.icg;
+	cl_mask = (uint64_t)icg_cfg.s.clusters;
 	cluster = __builtin_ffsll(cl_mask) - 1;
 
-	pkind_cfg_style.u64 = cvmx_read_csr_node(node,
-		CVMX_PKI_CLX_PKINDX_STYLE(pkind, cluster));
-	pkind_cfg->initial_parse_mode = pkind_cfg_style.s.pm;
-	pkind_cfg->initial_style = pkind_cfg_style.s.style;
-
-	pknd_cfg_reg.u64 = cvmx_read_csr_node(node,
-		CVMX_PKI_CLX_PKINDX_CFG(pkind, cluster));
-	pkind_cfg->fcs_pres = pknd_cfg_reg.s.fcs_pres;
-	pkind_cfg->parse_en.inst_hdr = pknd_cfg_reg.s.inst_hdr;
-	pkind_cfg->parse_en.mpls_en = pknd_cfg_reg.s.mpls_en;
-	pkind_cfg->parse_en.lg_custom = pknd_cfg_reg.s.lg_custom;
-	pkind_cfg->parse_en.fulc_en = pknd_cfg_reg.s.fulc_en;
-	pkind_cfg->parse_en.dsa_en = pknd_cfg_reg.s.dsa_en;
-	pkind_cfg->parse_en.hg2_en = pknd_cfg_reg.s.hg2_en;
-	pkind_cfg->parse_en.hg_en = pknd_cfg_reg.s.hg_en;
-
-	pknd_skip_reg.u64 = cvmx_read_csr_node(node,
-		CVMX_PKI_CLX_PKINDX_SKIP(pkind, cluster));
-	pkind_cfg->fcs_skip = pknd_skip_reg.s.fcs_skip;
-	pkind_cfg->inst_skip = pknd_skip_reg.s.inst_skip;
-
+	pstyle.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pkind, cluster));
+	pkind_cfg->initial_parse_mode = pstyle.s.pm;
+	pkind_cfg->initial_style = pstyle.s.style;
+
+	pcfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_CFG(pkind, cluster));
+	pkind_cfg->fcs_pres = pcfg.s.fcs_pres;
+	pkind_cfg->parse_en.inst_hdr = pcfg.s.inst_hdr;
+	pkind_cfg->parse_en.mpls_en = pcfg.s.mpls_en;
+	pkind_cfg->parse_en.lg_custom = pcfg.s.lg_custom;
+	pkind_cfg->parse_en.fulc_en = pcfg.s.fulc_en;
+	pkind_cfg->parse_en.dsa_en = pcfg.s.dsa_en;
+	pkind_cfg->parse_en.hg2_en = pcfg.s.hg2_en;
+	pkind_cfg->parse_en.hg_en = pcfg.s.hg_en;
+
+	skip.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_SKIP(pkind, cluster));
+	pkind_cfg->fcs_skip = skip.s.fcs_skip;
+	pkind_cfg->inst_skip = skip.s.inst_skip;
 	return 0;
 }
 
 /**
  * This function writes per pkind parameters in hardware which defines how
-  the incoming packet is processed.
- * @param node		node number.
- * @param pkind		PKI supports a large number of incoming interfaces
- *			and packets arriving on different interfaces or channels
- *			may want to be processed differently. PKI uses the pkind to
- *			determine how the incoming packet is processed.
- * @param pkind_cfg	pointer to struct conatining pkind configuration
- * 			need to be written in hw
+ * the incoming packet is processed.
+ *
+ * @param node  Node number.
+ * @param pkind  PKI supports a large number of incoming interfaces and packets
+ *     arriving on different interfaces or channels may want to be processed
+ *     differently. PKI uses the pkind to determine how the incoming
+ *     packet is processed.
+ * @param pkind_cfg  Pointer to struct conatining pkind configuration need
+ *     to be written in the hardware.
  */
-int cvmx_pki_write_pkind_config(int node, int pkind, struct cvmx_pki_pkind_config *pkind_cfg)
+int cvmx_pki_write_pkind_config(int node, int pkind,
+	struct cvmx_pki_pkind_config *pkind_cfg)
 {
 	unsigned cluster = 0;
 	uint64_t cluster_mask;
-
-	cvmx_pki_pkindx_icgsel_t pkind_clsel;
-	cvmx_pki_clx_pkindx_style_t pkind_cfg_style;
-	cvmx_pki_icgx_cfg_t pki_cl_grp;
-	cvmx_pki_clx_pkindx_cfg_t pknd_cfg_reg;
-	cvmx_pki_clx_pkindx_skip_t pknd_skip_reg;
-
-
-	if (pkind >= CVMX_PKI_NUM_PKIND || pkind_cfg->cluster_grp >= CVMX_PKI_NUM_CLUSTER_GROUP
-		  || pkind_cfg->initial_style >= CVMX_PKI_NUM_FINAL_STYLE) {
+	cvmx_pki_pkindx_icgsel_t icgsel;
+	cvmx_pki_clx_pkindx_style_t pstyle;
+	cvmx_pki_icgx_cfg_t icg_cfg;
+	cvmx_pki_clx_pkindx_cfg_t pcfg;
+	cvmx_pki_clx_pkindx_skip_t skip;
+
+	if (pkind >= CVMX_PKI_NUM_PKIND ||
+		pkind_cfg->cluster_grp >= CVMX_PKI_NUM_CLUSTER_GROUP ||
+		pkind_cfg->initial_style >= CVMX_PKI_NUM_FINAL_STYLE) {
 		cvmx_dprintf("ERROR: Configuring PKIND pkind = %d cluster_group = %d style = %d\n",
 			     pkind, pkind_cfg->cluster_grp, pkind_cfg->initial_style);
 		return -1;
 	}
-	pkind_clsel.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKINDX_ICGSEL(pkind));
-	pkind_clsel.s.icg = pkind_cfg->cluster_grp;
-	cvmx_write_csr_node(node, CVMX_PKI_PKINDX_ICGSEL(pkind), pkind_clsel.u64);
+	icgsel.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKINDX_ICGSEL(pkind));
+	icgsel.s.icg = pkind_cfg->cluster_grp;
+	cvmx_write_csr_node(node, CVMX_PKI_PKINDX_ICGSEL(pkind), icgsel.u64);
 
-	pki_cl_grp.u64 = cvmx_read_csr_node(node, CVMX_PKI_ICGX_CFG(pkind_cfg->cluster_grp));
-	cluster_mask = (uint64_t)pki_cl_grp.s.clusters;
+	icg_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_ICGX_CFG(pkind_cfg->cluster_grp));
+	cluster_mask = (uint64_t)icg_cfg.s.clusters;
 	while (cluster < CVMX_PKI_NUM_CLUSTER) {
 		if (cluster_mask & (0x01L << cluster)) {
-			pkind_cfg_style.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pkind, cluster));
-			pkind_cfg_style.s.pm = pkind_cfg->initial_parse_mode;
-			pkind_cfg_style.s.style = pkind_cfg->initial_style;
-			cvmx_write_csr_node(node,
-				CVMX_PKI_CLX_PKINDX_STYLE(pkind, cluster),
-				pkind_cfg_style.u64);
-			pknd_cfg_reg.u64 = cvmx_read_csr_node(node,
-				CVMX_PKI_CLX_PKINDX_CFG(pkind, cluster));
-			pknd_cfg_reg.s.fcs_pres = pkind_cfg->fcs_pres;
-			pknd_cfg_reg.s.inst_hdr = pkind_cfg->parse_en.inst_hdr;
-			pknd_cfg_reg.s.mpls_en = pkind_cfg->parse_en.mpls_en;
-			pknd_cfg_reg.s.lg_custom = pkind_cfg->parse_en.lg_custom;
-			pknd_cfg_reg.s.fulc_en = pkind_cfg->parse_en.fulc_en;
-			pknd_cfg_reg.s.dsa_en = pkind_cfg->parse_en.dsa_en;
-			pknd_cfg_reg.s.hg2_en = pkind_cfg->parse_en.hg2_en;
-			pknd_cfg_reg.s.hg_en = pkind_cfg->parse_en.hg_en;
-			cvmx_write_csr_node(node,
-				CVMX_PKI_CLX_PKINDX_CFG(pkind, cluster),
-				pknd_cfg_reg.u64);
-			pknd_skip_reg.u64 = cvmx_read_csr_node(node,
-				CVMX_PKI_CLX_PKINDX_SKIP(pkind, cluster));
-			pknd_skip_reg.s.fcs_skip = pkind_cfg->fcs_skip;
-			pknd_skip_reg.s.inst_skip = pkind_cfg->inst_skip;
-			cvmx_write_csr_node(node,
-				CVMX_PKI_CLX_PKINDX_SKIP(pkind, cluster),
-				pknd_skip_reg.u64);
+			pstyle.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pkind, cluster));
+			pstyle.s.pm = pkind_cfg->initial_parse_mode;
+			pstyle.s.style = pkind_cfg->initial_style;
+			cvmx_write_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pkind, cluster), pstyle.u64);
+
+			pcfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_CFG(pkind, cluster));
+			pcfg.s.fcs_pres = pkind_cfg->fcs_pres;
+			pcfg.s.inst_hdr = pkind_cfg->parse_en.inst_hdr;
+			pcfg.s.mpls_en = pkind_cfg->parse_en.mpls_en;
+			pcfg.s.lg_custom = pkind_cfg->parse_en.lg_custom;
+			pcfg.s.fulc_en = pkind_cfg->parse_en.fulc_en;
+			pcfg.s.dsa_en = pkind_cfg->parse_en.dsa_en;
+			pcfg.s.hg2_en = pkind_cfg->parse_en.hg2_en;
+			pcfg.s.hg_en = pkind_cfg->parse_en.hg_en;
+			cvmx_write_csr_node(node, CVMX_PKI_CLX_PKINDX_CFG(pkind, cluster), pcfg.u64);
+
+			skip.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_SKIP(pkind, cluster));
+			skip.s.fcs_skip = pkind_cfg->fcs_skip;
+			skip.s.inst_skip = pkind_cfg->inst_skip;
+			cvmx_write_csr_node(node, CVMX_PKI_CLX_PKINDX_SKIP(pkind, cluster), skip.u64);
 		}
 		cluster++;
 	}
 	return 0;
 }
 
- /**
+/**
  * This function reads parameters associated with tag configuration in hardware.
  * Only first cluster in the group is used.
- * @param node		node number.
- * @param style		style to configure tag for
+ *
+ * @param node  Node number.
+ * @param style  Style to configure tag for.
  * @param cluster_mask	Mask of clusters to configure the style for.
- * @param tag_cfg	pointer to tag configuration struct.
+ * @param tag_cfg  Pointer to tag configuration struct.
  */
 void cvmx_pki_read_tag_config(int node, int style, uint64_t cluster_mask,
 	struct cvmx_pki_style_tag_cfg *tag_cfg)
 {
 	int mask, tag_idx, index;
-	cvmx_pki_clx_stylex_cfg2_t style_cfg2_reg;
-	cvmx_pki_clx_stylex_alg_t style_alg_reg;
+	cvmx_pki_clx_stylex_cfg2_t style_cfg2;
+	cvmx_pki_clx_stylex_alg_t style_alg;
 	cvmx_pki_stylex_tag_sel_t tag_sel;
 	cvmx_pki_tag_incx_ctl_t tag_ctl;
 	cvmx_pki_tag_incx_mask_t tag_mask;
 	int cluster = __builtin_ffsll(cluster_mask) - 1;
 
-	style_cfg2_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
-	style_alg_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
+	style_cfg2.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
+	style_alg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
 
 	/* 7-Tuple Tag: */
-	tag_cfg->tag_fields.layer_g_src = style_cfg2_reg.s.tag_src_lg;
-	tag_cfg->tag_fields.layer_f_src = style_cfg2_reg.s.tag_src_lf;
-	tag_cfg->tag_fields.layer_e_src = style_cfg2_reg.s.tag_src_le;
-	tag_cfg->tag_fields.layer_d_src = style_cfg2_reg.s.tag_src_ld;
-	tag_cfg->tag_fields.layer_c_src = style_cfg2_reg.s.tag_src_lc;
-	tag_cfg->tag_fields.layer_b_src = style_cfg2_reg.s.tag_src_lb;
-	tag_cfg->tag_fields.layer_g_dst = style_cfg2_reg.s.tag_dst_lg;
-	tag_cfg->tag_fields.layer_f_dst = style_cfg2_reg.s.tag_dst_lf;
-	tag_cfg->tag_fields.layer_e_dst = style_cfg2_reg.s.tag_dst_le;
-	tag_cfg->tag_fields.layer_d_dst = style_cfg2_reg.s.tag_dst_ld;
-	tag_cfg->tag_fields.layer_c_dst = style_cfg2_reg.s.tag_dst_lc;
-	tag_cfg->tag_fields.layer_b_dst = style_cfg2_reg.s.tag_dst_lb;
-	tag_cfg->tag_fields.tag_vni = style_alg_reg.s.tag_vni;
-	tag_cfg->tag_fields.tag_gtp = style_alg_reg.s.tag_gtp;
-	tag_cfg->tag_fields.tag_spi = style_alg_reg.s.tag_spi;
-	tag_cfg->tag_fields.tag_sync = style_alg_reg.s.tag_syn;
-	tag_cfg->tag_fields.ip_prot_nexthdr = style_alg_reg.s.tag_pctl;
-	tag_cfg->tag_fields.second_vlan = style_alg_reg.s.tag_vs1;
-	tag_cfg->tag_fields.first_vlan = style_alg_reg.s.tag_vs0;
-	tag_cfg->tag_fields.mpls_label = style_alg_reg.s.tag_mpls0;
-	tag_cfg->tag_fields.input_port = style_alg_reg.s.tag_prt;
+	tag_cfg->tag_fields.layer_g_src = style_cfg2.s.tag_src_lg;
+	tag_cfg->tag_fields.layer_f_src = style_cfg2.s.tag_src_lf;
+	tag_cfg->tag_fields.layer_e_src = style_cfg2.s.tag_src_le;
+	tag_cfg->tag_fields.layer_d_src = style_cfg2.s.tag_src_ld;
+	tag_cfg->tag_fields.layer_c_src = style_cfg2.s.tag_src_lc;
+	tag_cfg->tag_fields.layer_b_src = style_cfg2.s.tag_src_lb;
+	tag_cfg->tag_fields.layer_g_dst = style_cfg2.s.tag_dst_lg;
+	tag_cfg->tag_fields.layer_f_dst = style_cfg2.s.tag_dst_lf;
+	tag_cfg->tag_fields.layer_e_dst = style_cfg2.s.tag_dst_le;
+	tag_cfg->tag_fields.layer_d_dst = style_cfg2.s.tag_dst_ld;
+	tag_cfg->tag_fields.layer_c_dst = style_cfg2.s.tag_dst_lc;
+	tag_cfg->tag_fields.layer_b_dst = style_cfg2.s.tag_dst_lb;
+	tag_cfg->tag_fields.tag_vni = style_alg.s.tag_vni;
+	tag_cfg->tag_fields.tag_gtp = style_alg.s.tag_gtp;
+	tag_cfg->tag_fields.tag_spi = style_alg.s.tag_spi;
+	tag_cfg->tag_fields.tag_sync = style_alg.s.tag_syn;
+	tag_cfg->tag_fields.ip_prot_nexthdr = style_alg.s.tag_pctl;
+	tag_cfg->tag_fields.second_vlan = style_alg.s.tag_vs1;
+	tag_cfg->tag_fields.first_vlan = style_alg.s.tag_vs0;
+	tag_cfg->tag_fields.mpls_label = style_alg.s.tag_mpls0;
+	tag_cfg->tag_fields.input_port = style_alg.s.tag_prt;
 
 	/* Custom-Mask Tag: */
 	tag_sel.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_TAG_SEL(style));
 	for (mask = 0; mask < 4; mask++) {
-		tag_cfg->mask_tag[mask].enable = (style_cfg2_reg.s.tag_inc & (1 << mask)) != 0;
+		tag_cfg->mask_tag[mask].enable = (style_cfg2.s.tag_inc & (1 << mask)) != 0;
 		switch (mask) {
 		case 0: tag_idx = tag_sel.s.tag_idx0; break;
 		case 1: tag_idx = tag_sel.s.tag_idx1; break;
@@ -441,22 +431,23 @@ void cvmx_pki_read_tag_config(int node, int style, uint64_t cluster_mask,
 	}
 }
 
- /**
- * This function writes/configures parameters associated with tag configuration in hardware.
- * In Custom-Mask Tagging, all four masks use the same base index to access Tag Control and
- * Tag Mask registers.
- * @param node	              node number.
- * @param style		      style to configure tag for
- * @param cluster_mask	      Mask of clusters to configure the style for.
- * @param tag_cfg	      pointer to taf configuration struct.
+/**
+ * This function writes/configures parameters associated with tag configuration in
+ * hardware. In Custom-Mask Tagging, all four masks use the same base index
+ * to access Tag Control and Tag Mask registers.
+ *
+ * @param node  Node number.
+ * @param style  Style to configure tag for.
+ * @param cluster_mask  Mask of clusters to configure the style for.
+ * @param tag_cfg  Pointer to taf configuration struct.
  */
 void cvmx_pki_write_tag_config(int node, int style, uint64_t cluster_mask,
 			       struct cvmx_pki_style_tag_cfg *tag_cfg)
 {
 	int mask, index, tag_idx, mtag_en = 0;
 	unsigned cluster = 0;
-	cvmx_pki_clx_stylex_cfg2_t style_cfg2_reg;
-	cvmx_pki_clx_stylex_alg_t style_alg_reg;
+	cvmx_pki_clx_stylex_cfg2_t scfg2;
+	cvmx_pki_clx_stylex_alg_t style_alg;
 	cvmx_pki_tag_incx_ctl_t tag_ctl;
 	cvmx_pki_tag_incx_mask_t tag_mask;
 	cvmx_pki_stylex_tag_sel_t tag_sel;
@@ -464,32 +455,32 @@ void cvmx_pki_write_tag_config(int node, int style, uint64_t cluster_mask,
 	while (cluster < CVMX_PKI_NUM_CLUSTER) {
 		if (cluster_mask & (0x01L << cluster)) {
 			/* 7-Tuple Tag: */
-			style_cfg2_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
-			style_cfg2_reg.s.tag_src_lg = tag_cfg->tag_fields.layer_g_src;
-			style_cfg2_reg.s.tag_src_lf = tag_cfg->tag_fields.layer_f_src;
-			style_cfg2_reg.s.tag_src_le = tag_cfg->tag_fields.layer_e_src;
-			style_cfg2_reg.s.tag_src_ld = tag_cfg->tag_fields.layer_d_src;
-			style_cfg2_reg.s.tag_src_lc = tag_cfg->tag_fields.layer_c_src;
-			style_cfg2_reg.s.tag_src_lb = tag_cfg->tag_fields.layer_b_src;
-			style_cfg2_reg.s.tag_dst_lg = tag_cfg->tag_fields.layer_g_dst;
-			style_cfg2_reg.s.tag_dst_lf = tag_cfg->tag_fields.layer_f_dst;
-			style_cfg2_reg.s.tag_dst_le = tag_cfg->tag_fields.layer_e_dst;
-			style_cfg2_reg.s.tag_dst_ld = tag_cfg->tag_fields.layer_d_dst;
-			style_cfg2_reg.s.tag_dst_lc = tag_cfg->tag_fields.layer_c_dst;
-			style_cfg2_reg.s.tag_dst_lb = tag_cfg->tag_fields.layer_b_dst;
-			cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster), style_cfg2_reg.u64);
-
-			style_alg_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
-			style_alg_reg.s.tag_vni = tag_cfg->tag_fields.tag_vni;
-			style_alg_reg.s.tag_gtp = tag_cfg->tag_fields.tag_gtp;
-			style_alg_reg.s.tag_spi = tag_cfg->tag_fields.tag_spi;
-			style_alg_reg.s.tag_syn = tag_cfg->tag_fields.tag_sync;
-			style_alg_reg.s.tag_pctl = tag_cfg->tag_fields.ip_prot_nexthdr;
-			style_alg_reg.s.tag_vs1 = tag_cfg->tag_fields.second_vlan;
-			style_alg_reg.s.tag_vs0 = tag_cfg->tag_fields.first_vlan;
-			style_alg_reg.s.tag_mpls0 = tag_cfg->tag_fields.mpls_label;
-			style_alg_reg.s.tag_prt = tag_cfg->tag_fields.input_port;
-			cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster), style_alg_reg.u64);
+			scfg2.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
+			scfg2.s.tag_src_lg = tag_cfg->tag_fields.layer_g_src;
+			scfg2.s.tag_src_lf = tag_cfg->tag_fields.layer_f_src;
+			scfg2.s.tag_src_le = tag_cfg->tag_fields.layer_e_src;
+			scfg2.s.tag_src_ld = tag_cfg->tag_fields.layer_d_src;
+			scfg2.s.tag_src_lc = tag_cfg->tag_fields.layer_c_src;
+			scfg2.s.tag_src_lb = tag_cfg->tag_fields.layer_b_src;
+			scfg2.s.tag_dst_lg = tag_cfg->tag_fields.layer_g_dst;
+			scfg2.s.tag_dst_lf = tag_cfg->tag_fields.layer_f_dst;
+			scfg2.s.tag_dst_le = tag_cfg->tag_fields.layer_e_dst;
+			scfg2.s.tag_dst_ld = tag_cfg->tag_fields.layer_d_dst;
+			scfg2.s.tag_dst_lc = tag_cfg->tag_fields.layer_c_dst;
+			scfg2.s.tag_dst_lb = tag_cfg->tag_fields.layer_b_dst;
+			cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster), scfg2.u64);
+
+			style_alg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
+			style_alg.s.tag_vni = tag_cfg->tag_fields.tag_vni;
+			style_alg.s.tag_gtp = tag_cfg->tag_fields.tag_gtp;
+			style_alg.s.tag_spi = tag_cfg->tag_fields.tag_spi;
+			style_alg.s.tag_syn = tag_cfg->tag_fields.tag_sync;
+			style_alg.s.tag_pctl = tag_cfg->tag_fields.ip_prot_nexthdr;
+			style_alg.s.tag_vs1 = tag_cfg->tag_fields.second_vlan;
+			style_alg.s.tag_vs0 = tag_cfg->tag_fields.first_vlan;
+			style_alg.s.tag_mpls0 = tag_cfg->tag_fields.mpls_label;
+			style_alg.s.tag_prt = tag_cfg->tag_fields.input_port;
+			cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster), style_alg.u64);
 
 			/* Custom-Mask Tag (Part 1): */
 			for (mask = 0; mask < 4; mask++) {
@@ -497,13 +488,13 @@ void cvmx_pki_write_tag_config(int node, int style, uint64_t cluster_mask,
 					mtag_en++;
 			}
 			if (mtag_en) {
-				style_cfg2_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
-				style_cfg2_reg.s.tag_inc = 0;
+				scfg2.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
+				scfg2.s.tag_inc = 0;
 				for (mask = 0; mask < 4; mask++) {
 					if (tag_cfg->mask_tag[mask].enable)
-						style_cfg2_reg.s.tag_inc |= 1 << mask;
+						scfg2.s.tag_inc |= 1 << mask;
 				}
-				cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster), style_cfg2_reg.u64);
+				cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster), scfg2.u64);
 			}
 		}
 		cluster++;
@@ -527,7 +518,7 @@ void cvmx_pki_write_tag_config(int node, int style, uint64_t cluster_mask,
 				tag_mask.s.en = tag_cfg->mask_tag[mask].val;
 				cvmx_write_csr_node(node, CVMX_PKI_TAG_INCX_MASK(index), tag_mask.u64);
 
-   				tag_ctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_INCX_CTL(index));
+				tag_ctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_INCX_CTL(index));
 				tag_ctl.s.ptr_sel = tag_cfg->mask_tag[mask].base;
 				tag_ctl.s.offset = tag_cfg->mask_tag[mask].offset;
 				cvmx_write_csr_node(node, CVMX_PKI_TAG_INCX_CTL(index), tag_ctl.u64);
@@ -539,162 +530,159 @@ void cvmx_pki_write_tag_config(int node, int style, uint64_t cluster_mask,
 
 /**
  * This function reads parameters associated with style in hardware.
- * @param node		node number.
- * @param style		style to read from.
+ *
+ * @param node  Node number.
+ * @param style 	Style to read from.
  * @param cluster_mask	Mask of clusters style belongs to.
- * @param style_cfg	pointer to style config struct.
+ * @param style_cfg	 Pointer to style config struct.
  */
 void cvmx_pki_read_style_config(int node, int style, uint64_t cluster_mask,
 	struct cvmx_pki_style_config *style_cfg)
 {
-	cvmx_pki_clx_stylex_cfg_t style_cfg_reg;
-	cvmx_pki_clx_stylex_cfg2_t style_cfg2_reg;
-	cvmx_pki_clx_stylex_alg_t style_alg_reg;
-	cvmx_pki_stylex_buf_t style_buf_reg;
+	cvmx_pki_clx_stylex_cfg_t scfg;
+	cvmx_pki_clx_stylex_cfg2_t scfg2;
+	cvmx_pki_clx_stylex_alg_t style_alg;
+	cvmx_pki_stylex_buf_t style_buf;
 	int cluster = __builtin_ffsll(cluster_mask) - 1;
 
-	style_cfg_reg.u64 = cvmx_read_csr_node(node,
-		CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
-	style_cfg2_reg.u64 = cvmx_read_csr_node(node,
-		CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
-	style_alg_reg.u64 = cvmx_read_csr_node(node,
-		CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
-	style_buf_reg.u64 = cvmx_read_csr_node(node,
-		CVMX_PKI_STYLEX_BUF(style));
-
-	style_cfg->parm_cfg.ip6_udp_opt = style_cfg_reg.s.ip6_udp_opt;
-	style_cfg->parm_cfg.lenerr_en = style_cfg_reg.s.lenerr_en;
-	style_cfg->parm_cfg.lenerr_eqpad = style_cfg_reg.s.lenerr_eqpad;
-	style_cfg->parm_cfg.maxerr_en = style_cfg_reg.s.maxerr_en;
-	style_cfg->parm_cfg.minerr_en = style_cfg_reg.s.minerr_en;
-	style_cfg->parm_cfg.fcs_chk = style_cfg_reg.s.fcs_chk;
-	style_cfg->parm_cfg.fcs_strip = style_cfg_reg.s.fcs_strip;
-	style_cfg->parm_cfg.minmax_sel = style_cfg_reg.s.minmax_sel;
-	style_cfg->parm_cfg.qpg_base = style_cfg_reg.s.qpg_base;
-	style_cfg->parm_cfg.qpg_dis_padd = style_cfg_reg.s.qpg_dis_padd;
-	style_cfg->parm_cfg.qpg_dis_aura = style_cfg_reg.s.qpg_dis_aura;
-	style_cfg->parm_cfg.qpg_dis_grp = style_cfg_reg.s.qpg_dis_grp;
-	style_cfg->parm_cfg.qpg_dis_grptag = style_cfg_reg.s.qpg_dis_grptag;
-	style_cfg->parm_cfg.rawdrp = style_cfg_reg.s.rawdrp;
-	style_cfg->parm_cfg.force_drop = style_cfg_reg.s.drop;
-	style_cfg->parm_cfg.nodrop = style_cfg_reg.s.nodrop;
-
-	style_cfg->parm_cfg.len_lg = style_cfg2_reg.s.len_lg;
-	style_cfg->parm_cfg.len_lf = style_cfg2_reg.s.len_lf;
-	style_cfg->parm_cfg.len_le = style_cfg2_reg.s.len_le;
-	style_cfg->parm_cfg.len_ld = style_cfg2_reg.s.len_ld;
-	style_cfg->parm_cfg.len_lc = style_cfg2_reg.s.len_lc;
-	style_cfg->parm_cfg.len_lb = style_cfg2_reg.s.len_lb;
-	style_cfg->parm_cfg.csum_lg = style_cfg2_reg.s.csum_lg;
-	style_cfg->parm_cfg.csum_lf = style_cfg2_reg.s.csum_lf;
-	style_cfg->parm_cfg.csum_le = style_cfg2_reg.s.csum_le;
-	style_cfg->parm_cfg.csum_ld = style_cfg2_reg.s.csum_ld;
-	style_cfg->parm_cfg.csum_lc = style_cfg2_reg.s.csum_lc;
-	style_cfg->parm_cfg.csum_lb = style_cfg2_reg.s.csum_lb;
-
-	style_cfg->parm_cfg.qpg_qos = style_alg_reg.s.qpg_qos;
-	style_cfg->parm_cfg.tag_type = style_alg_reg.s.tt;
-	style_cfg->parm_cfg.apad_nip = style_alg_reg.s.apad_nip;
-	style_cfg->parm_cfg.qpg_port_sh = style_alg_reg.s.qpg_port_sh;
-	style_cfg->parm_cfg.qpg_port_msb = style_alg_reg.s.qpg_port_msb;
-	style_cfg->parm_cfg.wqe_vs = style_alg_reg.s.wqe_vs;
-
-	style_cfg->parm_cfg.pkt_lend = style_buf_reg.s.pkt_lend;
-	style_cfg->parm_cfg.wqe_hsz = style_buf_reg.s.wqe_hsz;
-	style_cfg->parm_cfg.wqe_skip = style_buf_reg.s.wqe_skip * 128;
-	style_cfg->parm_cfg.first_skip = style_buf_reg.s.first_skip * 8;
-	style_cfg->parm_cfg.later_skip = style_buf_reg.s.later_skip * 8;
-	style_cfg->parm_cfg.cache_mode = style_buf_reg.s.opc_mode;
-	style_cfg->parm_cfg.mbuff_size = style_buf_reg.s.mb_size * 8;
-	style_cfg->parm_cfg.dis_wq_dat = style_buf_reg.s.dis_wq_dat;
+	scfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
+	scfg2.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
+	style_alg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
+	style_buf.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_BUF(style));
+
+	style_cfg->parm_cfg.ip6_udp_opt = scfg.s.ip6_udp_opt;
+	style_cfg->parm_cfg.lenerr_en = scfg.s.lenerr_en;
+	style_cfg->parm_cfg.lenerr_eqpad = scfg.s.lenerr_eqpad;
+	style_cfg->parm_cfg.maxerr_en = scfg.s.maxerr_en;
+	style_cfg->parm_cfg.minerr_en = scfg.s.minerr_en;
+	style_cfg->parm_cfg.fcs_chk = scfg.s.fcs_chk;
+	style_cfg->parm_cfg.fcs_strip = scfg.s.fcs_strip;
+	style_cfg->parm_cfg.minmax_sel = scfg.s.minmax_sel;
+	style_cfg->parm_cfg.qpg_base = scfg.s.qpg_base;
+	style_cfg->parm_cfg.qpg_dis_padd = scfg.s.qpg_dis_padd;
+	style_cfg->parm_cfg.qpg_dis_aura = scfg.s.qpg_dis_aura;
+	style_cfg->parm_cfg.qpg_dis_grp = scfg.s.qpg_dis_grp;
+	style_cfg->parm_cfg.qpg_dis_grptag = scfg.s.qpg_dis_grptag;
+	style_cfg->parm_cfg.rawdrp = scfg.s.rawdrp;
+	style_cfg->parm_cfg.force_drop = scfg.s.drop;
+	style_cfg->parm_cfg.nodrop = scfg.s.nodrop;
+
+	style_cfg->parm_cfg.len_lg = scfg2.s.len_lg;
+	style_cfg->parm_cfg.len_lf = scfg2.s.len_lf;
+	style_cfg->parm_cfg.len_le = scfg2.s.len_le;
+	style_cfg->parm_cfg.len_ld = scfg2.s.len_ld;
+	style_cfg->parm_cfg.len_lc = scfg2.s.len_lc;
+	style_cfg->parm_cfg.len_lb = scfg2.s.len_lb;
+	style_cfg->parm_cfg.csum_lg = scfg2.s.csum_lg;
+	style_cfg->parm_cfg.csum_lf = scfg2.s.csum_lf;
+	style_cfg->parm_cfg.csum_le = scfg2.s.csum_le;
+	style_cfg->parm_cfg.csum_ld = scfg2.s.csum_ld;
+	style_cfg->parm_cfg.csum_lc = scfg2.s.csum_lc;
+	style_cfg->parm_cfg.csum_lb = scfg2.s.csum_lb;
+
+	style_cfg->parm_cfg.qpg_qos = style_alg.s.qpg_qos;
+	style_cfg->parm_cfg.tag_type = style_alg.s.tt;
+	style_cfg->parm_cfg.apad_nip = style_alg.s.apad_nip;
+	style_cfg->parm_cfg.qpg_port_sh = style_alg.s.qpg_port_sh;
+	style_cfg->parm_cfg.qpg_port_msb = style_alg.s.qpg_port_msb;
+	style_cfg->parm_cfg.wqe_vs = style_alg.s.wqe_vs;
+
+	style_cfg->parm_cfg.pkt_lend = style_buf.s.pkt_lend;
+	style_cfg->parm_cfg.wqe_hsz = style_buf.s.wqe_hsz;
+	style_cfg->parm_cfg.wqe_skip = style_buf.s.wqe_skip * 128;
+	style_cfg->parm_cfg.first_skip = style_buf.s.first_skip * 8;
+	style_cfg->parm_cfg.later_skip = style_buf.s.later_skip * 8;
+	style_cfg->parm_cfg.cache_mode = style_buf.s.opc_mode;
+	style_cfg->parm_cfg.mbuff_size = style_buf.s.mb_size * 8;
+	style_cfg->parm_cfg.dis_wq_dat = style_buf.s.dis_wq_dat;
 
 	cvmx_pki_read_tag_config(node, style, cluster_mask, &style_cfg->tag_cfg);
 }
 
-
 /**
  * This function writes/configures parameters associated with style in hardware.
- * @param node	              node number.
- * @param style		      style to configure.
- * @param cluster_mask	      Mask of clusters to configure the style for.
- * @param style_cfg	      pointer to style config struct.
+ *
+ * @param node  Node number.
+ * @param style  Style to configure.
+ * @param cluster_mask  Mask of clusters to configure the style for.
+ * @param style_cfg	 Pointer to style config struct.
  */
 void cvmx_pki_write_style_config(int node, uint64_t style, uint64_t cluster_mask,
-			    struct cvmx_pki_style_config *style_cfg)
+	struct cvmx_pki_style_config *style_cfg)
 {
-	cvmx_pki_clx_stylex_cfg_t style_cfg_reg;
-	cvmx_pki_clx_stylex_cfg2_t style_cfg2_reg;
-	cvmx_pki_clx_stylex_alg_t style_alg_reg;
-	cvmx_pki_stylex_buf_t     style_buf_reg;
+	cvmx_pki_clx_stylex_cfg_t scfg;
+	cvmx_pki_clx_stylex_cfg2_t scfg2;
+	cvmx_pki_clx_stylex_alg_t style_alg;
+	cvmx_pki_stylex_buf_t style_buf;
 	unsigned cluster = 0;
 
 	while (cluster < CVMX_PKI_NUM_CLUSTER) {
 		if (cluster_mask & (0x01L << cluster)) {
-			style_cfg_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
-			style_cfg_reg.s.ip6_udp_opt = style_cfg->parm_cfg.ip6_udp_opt;
-			style_cfg_reg.s.lenerr_en = style_cfg->parm_cfg.lenerr_en;
-			style_cfg_reg.s.lenerr_eqpad = style_cfg->parm_cfg.lenerr_eqpad;
-			style_cfg_reg.s.maxerr_en = style_cfg->parm_cfg.maxerr_en;
-			style_cfg_reg.s.minerr_en = style_cfg->parm_cfg.minerr_en;
-			style_cfg_reg.s.fcs_chk = style_cfg->parm_cfg.fcs_chk;
-			style_cfg_reg.s.fcs_strip = style_cfg->parm_cfg.fcs_strip;
-			style_cfg_reg.s.minmax_sel = style_cfg->parm_cfg.minmax_sel;
-			style_cfg_reg.s.qpg_base = style_cfg->parm_cfg.qpg_base;
-			style_cfg_reg.s.qpg_dis_padd = style_cfg->parm_cfg.qpg_dis_padd;
-			style_cfg_reg.s.qpg_dis_aura = style_cfg->parm_cfg.qpg_dis_aura;
-			style_cfg_reg.s.qpg_dis_grp = style_cfg->parm_cfg.qpg_dis_grp;
-			style_cfg_reg.s.qpg_dis_grptag = style_cfg->parm_cfg.qpg_dis_grptag;
-			style_cfg_reg.s.rawdrp = style_cfg->parm_cfg.rawdrp;
-			style_cfg_reg.s.drop = style_cfg->parm_cfg.force_drop;
-			style_cfg_reg.s.nodrop = style_cfg->parm_cfg.nodrop;
-			cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster), style_cfg_reg.u64);
-
-			style_cfg2_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
-			style_cfg2_reg.s.len_lg = style_cfg->parm_cfg.len_lg;
-			style_cfg2_reg.s.len_lf = style_cfg->parm_cfg.len_lf;
-			style_cfg2_reg.s.len_le = style_cfg->parm_cfg.len_le;
-			style_cfg2_reg.s.len_ld = style_cfg->parm_cfg.len_ld;
-			style_cfg2_reg.s.len_lc = style_cfg->parm_cfg.len_lc;
-			style_cfg2_reg.s.len_lb = style_cfg->parm_cfg.len_lb;
-			style_cfg2_reg.s.csum_lg = style_cfg->parm_cfg.csum_lg;
-			style_cfg2_reg.s.csum_lf = style_cfg->parm_cfg.csum_lf;
-			style_cfg2_reg.s.csum_le = style_cfg->parm_cfg.csum_le;
-			style_cfg2_reg.s.csum_ld = style_cfg->parm_cfg.csum_ld;
-			style_cfg2_reg.s.csum_lc = style_cfg->parm_cfg.csum_lc;
-			style_cfg2_reg.s.csum_lb = style_cfg->parm_cfg.csum_lb;
-			cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster), style_cfg2_reg.u64);
-
-			style_alg_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
-			style_alg_reg.s.qpg_qos = style_cfg->parm_cfg.qpg_qos;
-			style_alg_reg.s.tt = style_cfg->parm_cfg.tag_type;
-			style_alg_reg.s.apad_nip = style_cfg->parm_cfg.apad_nip;
-			style_alg_reg.s.qpg_port_sh = style_cfg->parm_cfg.qpg_port_sh;
-			style_alg_reg.s.qpg_port_msb = style_cfg->parm_cfg.qpg_port_msb;
-			style_alg_reg.s.wqe_vs = style_cfg->parm_cfg.wqe_vs;
-			cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster), style_alg_reg.u64);
+			scfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
+			scfg.s.ip6_udp_opt = style_cfg->parm_cfg.ip6_udp_opt;
+			scfg.s.lenerr_en = style_cfg->parm_cfg.lenerr_en;
+			scfg.s.lenerr_eqpad = style_cfg->parm_cfg.lenerr_eqpad;
+			scfg.s.maxerr_en = style_cfg->parm_cfg.maxerr_en;
+			scfg.s.minerr_en = style_cfg->parm_cfg.minerr_en;
+			scfg.s.fcs_chk = style_cfg->parm_cfg.fcs_chk;
+			scfg.s.fcs_strip = style_cfg->parm_cfg.fcs_strip;
+			scfg.s.minmax_sel = style_cfg->parm_cfg.minmax_sel;
+			scfg.s.qpg_base = style_cfg->parm_cfg.qpg_base;
+			scfg.s.qpg_dis_padd = style_cfg->parm_cfg.qpg_dis_padd;
+			scfg.s.qpg_dis_aura = style_cfg->parm_cfg.qpg_dis_aura;
+			scfg.s.qpg_dis_grp = style_cfg->parm_cfg.qpg_dis_grp;
+			scfg.s.qpg_dis_grptag = style_cfg->parm_cfg.qpg_dis_grptag;
+			scfg.s.rawdrp = style_cfg->parm_cfg.rawdrp;
+			scfg.s.drop = style_cfg->parm_cfg.force_drop;
+			scfg.s.nodrop = style_cfg->parm_cfg.nodrop;
+			cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster), scfg.u64);
+
+			scfg2.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
+			scfg2.s.len_lg = style_cfg->parm_cfg.len_lg;
+			scfg2.s.len_lf = style_cfg->parm_cfg.len_lf;
+			scfg2.s.len_le = style_cfg->parm_cfg.len_le;
+			scfg2.s.len_ld = style_cfg->parm_cfg.len_ld;
+			scfg2.s.len_lc = style_cfg->parm_cfg.len_lc;
+			scfg2.s.len_lb = style_cfg->parm_cfg.len_lb;
+			scfg2.s.csum_lg = style_cfg->parm_cfg.csum_lg;
+			scfg2.s.csum_lf = style_cfg->parm_cfg.csum_lf;
+			scfg2.s.csum_le = style_cfg->parm_cfg.csum_le;
+			scfg2.s.csum_ld = style_cfg->parm_cfg.csum_ld;
+			scfg2.s.csum_lc = style_cfg->parm_cfg.csum_lc;
+			scfg2.s.csum_lb = style_cfg->parm_cfg.csum_lb;
+			cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster), scfg2.u64);
+
+			style_alg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
+			style_alg.s.qpg_qos = style_cfg->parm_cfg.qpg_qos;
+			style_alg.s.tt = style_cfg->parm_cfg.tag_type;
+			style_alg.s.apad_nip = style_cfg->parm_cfg.apad_nip;
+			style_alg.s.qpg_port_sh = style_cfg->parm_cfg.qpg_port_sh;
+			style_alg.s.qpg_port_msb = style_cfg->parm_cfg.qpg_port_msb;
+			style_alg.s.wqe_vs = style_cfg->parm_cfg.wqe_vs;
+			cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster), style_alg.u64);
 		}
 		cluster++;
 	}
-	style_buf_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_BUF(style));
-	style_buf_reg.s.pkt_lend = style_cfg->parm_cfg.pkt_lend;
-	style_buf_reg.s.wqe_hsz = style_cfg->parm_cfg.wqe_hsz;
-	style_buf_reg.s.wqe_skip = (style_cfg->parm_cfg.wqe_skip)/128;
-	style_buf_reg.s.first_skip = (style_cfg->parm_cfg.first_skip)/8;
-	style_buf_reg.s.later_skip = style_cfg->parm_cfg.later_skip/8;
-	style_buf_reg.s.opc_mode = style_cfg->parm_cfg.cache_mode;
-	style_buf_reg.s.mb_size = (style_cfg->parm_cfg.mbuff_size)/8;
-	style_buf_reg.s.dis_wq_dat = style_cfg->parm_cfg.dis_wq_dat;
-	cvmx_write_csr_node(node, CVMX_PKI_STYLEX_BUF(style), style_buf_reg.u64);
+	style_buf.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_BUF(style));
+	style_buf.s.pkt_lend = style_cfg->parm_cfg.pkt_lend;
+	style_buf.s.wqe_hsz = style_cfg->parm_cfg.wqe_hsz;
+	style_buf.s.wqe_skip = (style_cfg->parm_cfg.wqe_skip)/128;
+	style_buf.s.first_skip = (style_cfg->parm_cfg.first_skip)/8;
+	style_buf.s.later_skip = style_cfg->parm_cfg.later_skip/8;
+	style_buf.s.opc_mode = style_cfg->parm_cfg.cache_mode;
+	style_buf.s.mb_size = (style_cfg->parm_cfg.mbuff_size)/8;
+	style_buf.s.dis_wq_dat = style_cfg->parm_cfg.dis_wq_dat;
+	cvmx_write_csr_node(node, CVMX_PKI_STYLEX_BUF(style), style_buf.u64);
 
 	cvmx_pki_write_tag_config(node, style, cluster_mask, &style_cfg->tag_cfg);
 }
 
 /**
- * This function reads qpg entry at specified offset from qpg table
+ * This function reads qpg entry at specified offset from qpg table.
  *
- * @param node		node number
- * @param offset	offset in qpg table to read from.
- * @param qpg_cfg	pointer to structure containing qpg values
+ * @param node  Node number.
+ * @param offset  Offset in qpg table to read from.
+ * @param qpg_cfg  Pointer to structure containing qpg values.
  */
 int cvmx_pki_read_qpg_entry(int node, int offset, struct cvmx_pki_qpg_config *qpg_cfg)
 {
@@ -714,11 +702,11 @@ int cvmx_pki_read_qpg_entry(int node, int offset, struct cvmx_pki_qpg_config *qp
 }
 
 /**
- * This function writes qpg entry at specified offset in qpg table
+ * This function writes qpg entry at specified offset in qpg table.
  *
- * @param node		node number
- * @param offset	offset in qpg table to write to.
- * @param qpg_cfg	pointer to stricture containing qpg values
+ * @param node  Node number.
+ * @param offset  Offset in qpg table to read from.
+ * @param qpg_cfg  Pointer to structure containing qpg values.
  */
 void cvmx_pki_write_qpg_entry(int node, int offset, struct cvmx_pki_qpg_config *qpg_cfg)
 {
@@ -733,54 +721,54 @@ void cvmx_pki_write_qpg_entry(int node, int offset, struct cvmx_pki_qpg_config *
 	cvmx_write_csr_node(node, CVMX_PKI_QPG_TBLX(offset), qpg_tbl.u64);
 }
 
-
 /**
  * This function writes pcam entry at given offset in pcam table in hardware
  *
- * @param node		node number.
- * @param index		offset in pcam table.
+ * @param node  Node number.
+ * @param index  Offset in pcam table.
  * @param cluster_mask	Mask of clusters in which to write pcam entry.
- * @param input 	input keys to pcam match passed as struct.
- * @param action	pcam match action passed as struct
- *
+ * @param input  Input keys to pcam match passed as struct.
+ * @param action  PCAM match action passed as struct.
  */
 int cvmx_pki_pcam_write_entry(int node, int index, uint64_t cluster_mask,
 	struct cvmx_pki_pcam_input input, struct cvmx_pki_pcam_action action)
 {
 	int bank;
 	unsigned cluster = 0;
-	cvmx_pki_clx_pcamx_termx_t	pcam_term;
-	cvmx_pki_clx_pcamx_matchx_t	pcam_match;
-	cvmx_pki_clx_pcamx_actionx_t	pcam_action;
+	cvmx_pki_clx_pcamx_termx_t	term;
+	cvmx_pki_clx_pcamx_matchx_t	match;
+	cvmx_pki_clx_pcamx_actionx_t act;
 
 	if (index >= CVMX_PKI_TOTAL_PCAM_ENTRY) {
-		cvmx_dprintf("\nERROR: Invalid pcam entry %d", index);
+		cvmx_dprintf("\nERROR: Invalid pcam entry %d\n", index);
 		return -1;
 	}
 	bank = (int)(input.field & 0x01);
 	while (cluster < CVMX_PKI_NUM_CLUSTER) {
 		if (cluster_mask & (0x01L << cluster)) {
-			pcam_term.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PCAMX_TERMX(cluster, bank, index));
-			pcam_term.s.valid = 0;
-			cvmx_write_csr_node(node, CVMX_PKI_CLX_PCAMX_TERMX(cluster, bank, index), pcam_term.u64);
-			pcam_match.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PCAMX_MATCHX(cluster, bank, index));
-			pcam_match.s.data1 = input.data & input.data_mask;
-			pcam_match.s.data0 = (~input.data) & input.data_mask;
-			cvmx_write_csr_node(node, CVMX_PKI_CLX_PCAMX_MATCHX(cluster, bank, index), pcam_match.u64);
-			pcam_action.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PCAMX_ACTIONX(cluster, bank, index));
-			pcam_action.s.pmc = action.parse_mode_chg;
-			pcam_action.s.style_add = action.style_add;
-			pcam_action.s.pf = action.parse_flag_set;
-			pcam_action.s.setty = action.layer_type_set;
-			pcam_action.s.advance = action.pointer_advance;
-			cvmx_write_csr_node(node, CVMX_PKI_CLX_PCAMX_ACTIONX(cluster, bank, index), pcam_action.u64);
-			pcam_term.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PCAMX_TERMX(cluster, bank, index));
-			pcam_term.s.term1 = input.field & input.field_mask;
-			pcam_term.s.term0 = (~input.field) & input.field_mask;
-			pcam_term.s.style1 = input.style & input.style_mask;
-			pcam_term.s.style0 = (~input.style) & input.style_mask;
-			pcam_term.s.valid = 1;
-			cvmx_write_csr_node(node, CVMX_PKI_CLX_PCAMX_TERMX(cluster, bank, index), pcam_term.u64);
+			term.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PCAMX_TERMX(cluster, bank, index));
+			term.s.valid = 0;
+			cvmx_write_csr_node(node, CVMX_PKI_CLX_PCAMX_TERMX(cluster, bank, index), term.u64);
+			match.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PCAMX_MATCHX(cluster, bank, index));
+			match.s.data1 = input.data & input.data_mask;
+			match.s.data0 = (~input.data) & input.data_mask;
+			cvmx_write_csr_node(node, CVMX_PKI_CLX_PCAMX_MATCHX(cluster, bank, index), match.u64);
+
+			act.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PCAMX_ACTIONX(cluster, bank, index));
+			act.s.pmc = action.parse_mode_chg;
+			act.s.style_add = action.style_add;
+			act.s.pf = action.parse_flag_set;
+			act.s.setty = action.layer_type_set;
+			act.s.advance = action.pointer_advance;
+			cvmx_write_csr_node(node, CVMX_PKI_CLX_PCAMX_ACTIONX(cluster, bank, index), act.u64);
+
+			term.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PCAMX_TERMX(cluster, bank, index));
+			term.s.term1 = input.field & input.field_mask;
+			term.s.term0 = (~input.field) & input.field_mask;
+			term.s.style1 = input.style & input.style_mask;
+			term.s.style0 = (~input.style) & input.style_mask;
+			term.s.valid = 1;
+			cvmx_write_csr_node(node, CVMX_PKI_CLX_PCAMX_TERMX(cluster, bank, index), term.u64);
 		}
 		cluster++;
 	}
@@ -788,48 +776,48 @@ int cvmx_pki_pcam_write_entry(int node, int index, uint64_t cluster_mask,
 }
 
 /**
- * Enables/Disabled QoS (RED Drop, Tail Drop & backpressure) for the
- * PKI aura.
- * @param node		node number
- * @param aura		to enable/disable QoS on.
- * @param ena_red	Enable/Disable RED drop between pass and drop level
- *			1-enable 0-disable
- * @param ena_drop	Enable/disable tail drop when max drop level exceeds
- *			1-enable 0-disable
- * @param ena_bp 	Enable/Disable asserting backpressure on bpid when
- *			max DROP level exceeds.
- *			1-enable 0-disable
+ * Enables/Disabled QoS (RED Drop, Tail Drop & backpressure) for the PKI aura.
+ *
+ * @param node  Node number
+ * @param aura  To enable/disable QoS on.
+ * @param ena_red  Enable/Disable RED drop between pass and drop level
+ *    1-enable 0-disable
+ * @param ena_drop  Enable/disable tail drop when max drop level exceeds
+ *    1-enable 0-disable
+ * @param ena_bp  Enable/Disable asserting backpressure on bpid when max
+ *    DROP level exceeds.
+ *    1-enable 0-disable
  */
 int cvmx_pki_enable_aura_qos(int node, int aura, bool ena_red,
 	bool ena_drop, bool ena_bp)
 {
-	cvmx_pki_aurax_cfg_t pki_aura_cfg;
+	cvmx_pki_aurax_cfg_t aura_cfg;
 
 	if (aura >= CVMX_PKI_NUM_AURA) {
-		cvmx_dprintf("ERROR: PKI config aura_qos aura = %d", aura);
+		cvmx_dprintf("ERROR: %s aura = %d\n", __func__, aura);
 		return -1;
 	}
-	pki_aura_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_AURAX_CFG(aura));
-	pki_aura_cfg.s.ena_red = ena_red;
-	pki_aura_cfg.s.ena_drop = ena_drop;
-	pki_aura_cfg.s.ena_bp = ena_bp;
-	cvmx_write_csr_node(node, CVMX_PKI_AURAX_CFG(aura), pki_aura_cfg.u64);
+	aura_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_AURAX_CFG(aura));
+	aura_cfg.s.ena_red = ena_red;
+	aura_cfg.s.ena_drop = ena_drop;
+	aura_cfg.s.ena_bp = ena_bp;
+	cvmx_write_csr_node(node, CVMX_PKI_AURAX_CFG(aura), aura_cfg.u64);
 	return 0;
 }
 
 /**
- * Configures the bpid on which, specified aura will
- * assert backpressure.
+ * Configures the bpid on which, specified aura will assert backpressure.
  * Each bpid receives backpressure from auras.
  * Multiple auras can backpressure single bpid.
- * @param node   node number
- * @param aura   number which will assert backpressure on that bpid.
- * @param bpid   to assert backpressure on.
+ *
+ * @param node  Node number.
+ * @param aura  Number which will assert backpressure on that bpid.
+ * @param bpid  To assert backpressure on.
  */
 int cvmx_pki_write_aura_bpid(int node, int aura, int bpid)
 {
 	int i, cnt, ena_bp;
-	cvmx_pki_aurax_cfg_t pki_aura_cfg;
+	cvmx_pki_aurax_cfg_t aura_cfg;
 
 	if (aura >= CVMX_PKI_NUM_AURA || bpid >= CVMX_PKI_NUM_BPID) {
 		cvmx_dprintf("ERROR: aura=%d or bpid=%d is out or range\n", aura, bpid);
@@ -840,13 +828,13 @@ int cvmx_pki_write_aura_bpid(int node, int aura, int bpid)
 		 * Inform about assigning the same BPID to multiple auras
 		 * having different ENA_BP.
 		 */
-		pki_aura_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_AURAX_CFG(aura));
-		ena_bp = pki_aura_cfg.s.ena_bp;
+		aura_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_AURAX_CFG(aura));
+		ena_bp = aura_cfg.s.ena_bp;
 		for (i = 0, cnt = 1; i < CVMX_PKI_NUM_AURA; i++) {
 			if (i == aura)
 				continue;
-			pki_aura_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_AURAX_CFG(i));
-			if (pki_aura_cfg.s.bpid == bpid && pki_aura_cfg.s.ena_bp != ena_bp)
+			aura_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_AURAX_CFG(i));
+			if (aura_cfg.s.bpid == bpid && aura_cfg.s.ena_bp != ena_bp)
 				cnt++;
 		}
 		if (cnt > 1)
@@ -854,9 +842,9 @@ int cvmx_pki_write_aura_bpid(int node, int aura, int bpid)
 				"\tEnable|disable backpressure for all AURAs on this BPID.\n",
 				bpid, cnt);
 	}
-	pki_aura_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_AURAX_CFG(aura));
-	pki_aura_cfg.s.bpid = bpid;
-	cvmx_write_csr_node(node, CVMX_PKI_AURAX_CFG(aura), pki_aura_cfg.u64);
+	aura_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_AURAX_CFG(aura));
+	aura_cfg.s.bpid = bpid;
+	cvmx_write_csr_node(node, CVMX_PKI_AURAX_CFG(aura), aura_cfg.u64);
 	return 0;
 }
 
@@ -865,181 +853,172 @@ int cvmx_pki_write_aura_bpid(int node, int aura, int bpid)
  * from the specified bpid.
  * Each channel listens for backpressure on a specific bpid.
  * Each bpid can backpressure multiple channels.
- * @param node	node number
- * @param bpid	bpid from which, channel will receive backpressure.
- * @param channel channel numner to receive backpressue.
+ *
+ * @param node  Node number.
+ * @param bpid  BPID from which, channel will receive backpressure.
+ * @param channel  Channel number to receive backpressue.
  */
 int cvmx_pki_write_channel_bpid(int node, int channel, int bpid)
 {
-	cvmx_pki_chanx_cfg_t pki_chan_cfg;
+	cvmx_pki_chanx_cfg_t chan_cfg;
 
 	if (channel >= CVMX_PKI_NUM_CHANNEL || bpid >= CVMX_PKI_NUM_BPID) {
-		cvmx_dprintf("ERROR: PKI config channel_bp channel = %d bpid = %d",
-			channel, bpid);
+		cvmx_dprintf("ERROR: %s channel = %d bpid = %d\n", __func__, channel, bpid);
 		return -1;
 	}
-
-	pki_chan_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CHANX_CFG(channel));
-	pki_chan_cfg.s.bpid = bpid;
-	cvmx_write_csr_node(node, CVMX_PKI_CHANX_CFG(channel), pki_chan_cfg.u64);
+	chan_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CHANX_CFG(channel));
+	chan_cfg.s.bpid = bpid;
+	cvmx_write_csr_node(node, CVMX_PKI_CHANX_CFG(channel), chan_cfg.u64);
 	return 0;
 }
 
 /**
  * This function gives the initial style used by that pkind.
- * @param node	node number.
- * @param pkind	pkind number.
+ *
+ * @param node	Node number.
+ * @param pkind	PKIND number.
  */
 int cvmx_pki_get_pkind_style(int node, int pkind)
 {
 	int cluster = 0;
+	cvmx_pki_clx_pkindx_style_t style;
 
-	cvmx_pki_clx_pkindx_style_t pkind_style;
-
-	pkind_style.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pkind, cluster));
-
-	return pkind_style.s.style;
+	style.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pkind, cluster));
+	return style.s.style;
 }
 
 /**
- * This function sets the wqe buffer mode. First packet data buffer can reside
- * either in same buffer as wqe OR it can go in separate buffer. If used the later mode,
- * make sure software allocate enough buffers to now have wqe separate from packet data.
- * @param node		node number.
- * @param style		style to configure.
+ * This function sets the wqe buffer mode. First packet data buffer can
+ * reside either in same buffer as wqe OR it can go in separate buffer.
+ * If used the later mode, make sure software allocate enough buffers to
+ * now have wqe separate from packet data.
+ *
+ * @param node  Node number.
+ * @param style	 Style to configure.
  * @param pkt_outside_wqe	0 = The packet link pointer will be at word [FIRST_SKIP]
- *				immediately followed by packet data, in the same buffer
- *				as the work queue entry.
- *				1 = The packet link pointer will be at word [FIRST_SKIP] in a new
- *				buffer separate from the work queue entry. Words following the
- *				WQE in the same cache line will be zeroed, other lines in the
- *				buffer will not be modified and will retain stale data (from the
- * 				buffer’s previous use). This setting may decrease the peak PKI
- *				performance by up to half on small packets.
+ *    immediately followed by packet data, in the same buffer as the work queue entry.
+ *    1 = The packet link pointer will be at word [FIRST_SKIP] in a new buffer
+ *    separate from the work queue entry. Words following the WQE in the same
+ *    cache line will be zeroed, other lines in the buffer will not be modified
+ *    and will retain stale data (from the buffer’s previous use). This setting may
+ *    decrease the peak PKI performance by up to half on small packets.
  */
 void cvmx_pki_set_wqe_mode(int node, uint64_t style, bool pkt_outside_wqe)
 {
-	cvmx_pki_stylex_buf_t style_buf_reg;
+	cvmx_pki_stylex_buf_t style_buf;
 
-	style_buf_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_BUF(style));
-	style_buf_reg.s.dis_wq_dat = pkt_outside_wqe;
-	cvmx_write_csr_node(node, CVMX_PKI_STYLEX_BUF(style), style_buf_reg.u64);
+	style_buf.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_BUF(style));
+	style_buf.s.dis_wq_dat = pkt_outside_wqe;
+	cvmx_write_csr_node(node, CVMX_PKI_STYLEX_BUF(style), style_buf.u64);
 }
 
 /**
  * This function sets the Packet mode of all ports and styles to little-endian.
- * It Changes write operations of packet data to L2C to
- * be in little-endian. Does not change the WQE header format, which is
- * properly endian neutral.
- * @param node		node number.
- * @param style 	style to configure.
+ * It Changes write operations of packet data to L2C to be in little-endian.
+ * Does not change the WQE header format, which is properly endian neutral.
+ *
+ * @param node  Node number.
+ * @param style  Style to configure.
  */
 void cvmx_pki_set_little_endian(int node, uint64_t style)
 {
-	cvmx_pki_stylex_buf_t style_buf_reg;
+	cvmx_pki_stylex_buf_t style_buf;
 
-	style_buf_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_BUF(style));
-	style_buf_reg.s.pkt_lend = 1;
-	cvmx_write_csr_node(node, CVMX_PKI_STYLEX_BUF(style), style_buf_reg.u64);
+	style_buf.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_BUF(style));
+	style_buf.s.pkt_lend = 1;
+	cvmx_write_csr_node(node, CVMX_PKI_STYLEX_BUF(style), style_buf.u64);
 }
 
 /**
  * Enables/Disables fcs check and fcs stripping on the pkind.
- * @param node		node number
- * @param pknd		pkind to apply settings on.
- * @param fcs_chk	enable/disable fcs check.
- *			1 -- enable fcs error check.
- *			0 -- disable fcs error check.
- * @param fcs_strip	Strip L2 FCS bytes from packet, decrease WQE[LEN] by 4 bytes
- *			1 -- strip L2 FCS.
- *			0 -- Do not strip L2 FCS.
+ *
+ * @param node  Node number
+ * @param pknd  PKIND to apply settings on.
+ * @param fcs_chk  Enable/disable fcs check.
+ *    1 = enable fcs error check.
+ *    0 = disable fcs error check.
+ * @param fcs_strip	 Strip L2 FCS bytes from packet, decrease WQE[LEN] by 4 bytes
+ *    1 = strip L2 FCS.
+ *    0 = Do not strip L2 FCS.
  */
 void cvmx_pki_endis_fcs_check(int node, int pknd, bool fcs_chk, bool fcs_strip)
 {
 	int style;
 	unsigned cluster = 0;
-	cvmx_pki_clx_pkindx_style_t pkind_style;
+	cvmx_pki_clx_pkindx_style_t pstyle;
 	cvmx_pki_clx_stylex_cfg_t style_cfg;
 
 	while (cluster < CVMX_PKI_NUM_CLUSTER) {
-		pkind_style.u64 = cvmx_read_csr_node(node,
-			CVMX_PKI_CLX_PKINDX_STYLE(pknd, cluster));
-		style = pkind_style.s.style;
-		style_cfg.u64 = cvmx_read_csr_node(node,
-			CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
+		pstyle.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pknd, cluster));
+		style = pstyle.s.style;
+		style_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
 		style_cfg.s.fcs_chk = fcs_chk;
 		style_cfg.s.fcs_strip = fcs_strip;
-		cvmx_write_csr_node(node,
-			CVMX_PKI_CLX_STYLEX_CFG(style, cluster), style_cfg.u64);
+		cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster), style_cfg.u64);
 		cluster++;
 	}
 }
 
 /**
  * Enables/Disables l2 length error check and max & min frame length checks
- * @param node		node number
- * @param pknd		pkind to disable error for.
- * @param l2len_err	L2 length error check enable.
- * @param maxframe_err	Max frame error check enable.
- * @param minframe_err	Min frame error check enable.
- *			1 -- Enabel err checks
- *			0 -- Disable error checks
+ *
+ * @param node  Node number
+ * @param pknd  PKIND to disable error for.
+ * @param l2len_err  L2 length error check enable.
+ * @param maxframe_err  Max frame error check enable.
+ * @param minframe_err  Min frame error check enable.
+ *    1 = Enabel err checks
+ *    0 = Disable error checks
  */
 void cvmx_pki_endis_l2_errs(int node, int pknd, bool l2len_err,
 			 bool maxframe_err, bool minframe_err)
 {
 	int style;
 	unsigned cluster = 0;
-	cvmx_pki_clx_pkindx_style_t pkind_style;
+	cvmx_pki_clx_pkindx_style_t pstyle;
 	cvmx_pki_clx_stylex_cfg_t style_cfg;
 
 	while (cluster < CVMX_PKI_NUM_CLUSTER) {
-		pkind_style.u64 = cvmx_read_csr_node(node,
-			CVMX_PKI_CLX_PKINDX_STYLE(pknd, cluster));
-		style = pkind_style.s.style;
-		style_cfg.u64 = cvmx_read_csr_node(node,
-			CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
+		pstyle.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pknd, cluster));
+		style = pstyle.s.style;
+		style_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
 		style_cfg.s.lenerr_en = l2len_err;
 		style_cfg.s.maxerr_en = maxframe_err;
 		style_cfg.s.minerr_en = minframe_err;
-		cvmx_write_csr_node(node,
-			CVMX_PKI_CLX_STYLEX_CFG(style, cluster), style_cfg.u64);
+		cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster), style_cfg.u64);
 		cluster++;
 	}
 }
 
 /**
  * Disables maximum & minimum frame length checks
- * @param node   node number
- * @param pknd	 pkind to disable error for.
+ *
+ * @param node  Node number.
+ * @param pknd  PKIND to disable error for.
  */
 void cvmx_pki_dis_frame_len_chk(int node, int pknd)
 {
 	int style;
 	unsigned cluster = 0;
-	cvmx_pki_clx_pkindx_style_t pkind_style;
+	cvmx_pki_clx_pkindx_style_t pstyle;
 	cvmx_pki_clx_stylex_cfg_t style_cfg;
 
 	while (cluster < CVMX_PKI_NUM_CLUSTER) {
-		pkind_style.u64 = cvmx_read_csr_node(node,
-			CVMX_PKI_CLX_PKINDX_STYLE(pknd, cluster));
-		style = pkind_style.s.style;
-		style_cfg.u64 = cvmx_read_csr_node(node,
-			CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
+		pstyle.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pknd, cluster));
+		style = pstyle.s.style;
+		style_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
 		style_cfg.s.maxerr_en = 0;
 		style_cfg.s.minerr_en = 0;
-		cvmx_write_csr_node(node,
-			CVMX_PKI_CLX_STYLEX_CFG(style, cluster), style_cfg.u64);
+		cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster), style_cfg.u64);
 		cluster++;
 	}
 }
 
-
 /**
- * This function shows the qpg table entries,
- * read directly from hardware.
- * @param node	node number
- * @param num_entry number of entries to show
+ * This function shows the qpg table entries, read directly from hardware.
+ *
+ * @param node	Node number
+ * @param num_entry  Number of entries to show
  */
 void cvmx_pki_show_qpg_entries(int node, uint16_t num_entry)
 {
@@ -1051,21 +1030,18 @@ void cvmx_pki_show_qpg_entries(int node, uint16_t num_entry)
 	for (index = 0; index < num_entry; index++) {
 		qpg_tbl.u64 = cvmx_read_csr_node(node, CVMX_PKI_QPG_TBLX(index));
 		cvmx_dprintf("\n%d	", index);
-		cvmx_dprintf("PADD %-16lu",
-			(unsigned long)qpg_tbl.s.padd);
-		cvmx_dprintf("GRP_OK %-16lu",
-			(unsigned long)qpg_tbl.s.grp_ok);
-		cvmx_dprintf("GRP_BAD %-16lu",
-			(unsigned long)qpg_tbl.s.grp_bad);
-		cvmx_dprintf("LAURA %-16lu",
-			(unsigned long)qpg_tbl.s.laura);
+		cvmx_dprintf("PADD %-16lu", (unsigned long)qpg_tbl.s.padd);
+		cvmx_dprintf("GRP_OK %-16lu", (unsigned long)qpg_tbl.s.grp_ok);
+		cvmx_dprintf("GRP_BAD %-16lu", (unsigned long)qpg_tbl.s.grp_bad);
+		cvmx_dprintf("LAURA %-16lu", (unsigned long)qpg_tbl.s.laura);
 	}
 }
 
 /**
  * This function shows the pcam table in raw format,
  * read directly from hardware.
- * @param node    node number
+ *
+ * @param node  Node number
  */
 void cvmx_pki_show_pcam_entries(int node)
 {
@@ -1075,17 +1051,20 @@ void cvmx_pki_show_pcam_entries(int node)
 
 	for (cluster = 0; cluster < 4; cluster++) {
 		for (bank = 0; bank < 2; bank++) {
-			cvmx_dprintf("\n--------------Cluster %1d Bank %1d-------------\n", cluster, bank);
+			cvmx_dprintf("\n--------------Cluster %1d Bank %1d-------------\n",
+				cluster, bank);
 			cvmx_dprintf("index         TERM                 DATA,                ACTION");
 			for (index = 0; index < CVMX_PKI_NUM_PCAM_ENTRY; index++) {
 				cvmx_dprintf("\n%d", index);
 				cvmx_dprintf("             %-16lx",
-				    (unsigned long)cvmx_read_csr_node(node,
-					CVMX_PKI_CLX_PCAMX_TERMX(cluster, bank, index)));
+					(unsigned long)cvmx_read_csr_node(node,
+						CVMX_PKI_CLX_PCAMX_TERMX(cluster, bank, index)));
 				cvmx_dprintf("     %-16lx",
-				     (unsigned long)cvmx_read_csr_node(node, CVMX_PKI_CLX_PCAMX_MATCHX(cluster, bank, index)));
+					(unsigned long)cvmx_read_csr_node(node,
+						CVMX_PKI_CLX_PCAMX_MATCHX(cluster, bank, index)));
 				cvmx_dprintf("     %-16lx",
-				     (unsigned long)cvmx_read_csr_node(node, CVMX_PKI_CLX_PCAMX_ACTIONX(cluster, bank, index)));
+					(unsigned long)cvmx_read_csr_node(node,
+						CVMX_PKI_CLX_PCAMX_ACTIONX(cluster, bank, index)));
 			}
 		}
 	}
@@ -1094,37 +1073,40 @@ void cvmx_pki_show_pcam_entries(int node)
 /**
  * This function shows the valid entries in readable format,
  * read directly from hardware.
- * @param node    node number
+ *
+ * @param node  Node number.
  */
 void cvmx_pki_show_valid_pcam_entries(int node)
 {
 	int cluster;
 	int index;
 	int bank;
-	cvmx_pki_clx_pcamx_termx_t	pcam_term;
-	cvmx_pki_clx_pcamx_matchx_t	pcam_match;
-	cvmx_pki_clx_pcamx_actionx_t	pcam_action;
+	cvmx_pki_clx_pcamx_termx_t	term;
+	cvmx_pki_clx_pcamx_matchx_t	match;
+	cvmx_pki_clx_pcamx_actionx_t act;
 
 	for (cluster = 0; cluster < 4; cluster++) {
 		for (bank = 0; bank < 2; bank++) {
-			cvmx_dprintf("\n--------------Cluster %1d Bank %1d---------------------\n", cluster, bank);
+			cvmx_dprintf("\n--------------Cluster %1d Bank %1d---------------------\n",
+				cluster, bank);
 			cvmx_dprintf("%-10s%-17s%-19s%-18s", "index",
-				     "TERM1:TERM0", "Style1:Style0", "Data1:Data0");
+				"TERM1:TERM0", "Style1:Style0", "Data1:Data0");
 			cvmx_dprintf("%-6s", "ACTION[pmc:style_add:pf:setty:advance]");
 			for (index = 0; index < CVMX_PKI_NUM_PCAM_ENTRY; index++) {
-				pcam_term.u64 = cvmx_read_csr_node(node,
+				term.u64 = cvmx_read_csr_node(node,
 						CVMX_PKI_CLX_PCAMX_TERMX(cluster, bank, index));
-				if (pcam_term.s.valid) {
-					pcam_match.u64 = cvmx_read_csr_node(node,
+				if (term.s.valid) {
+					match.u64 = cvmx_read_csr_node(node,
 							CVMX_PKI_CLX_PCAMX_MATCHX(cluster, bank, index));
-					pcam_action.u64 = cvmx_read_csr_node(node,
+					act.u64 = cvmx_read_csr_node(node,
 							CVMX_PKI_CLX_PCAMX_ACTIONX(cluster, bank, index));
 					cvmx_dprintf("\n%-13d", index);
-					cvmx_dprintf("%-2x:%x", pcam_term.s.term1, pcam_term.s.term0);
-					cvmx_dprintf("     	      %-2x:%x", pcam_term.s.style1, pcam_term.s.style0);
-					cvmx_dprintf("        %-8x:%x", pcam_match.s.data1, pcam_match.s.data0);
+					cvmx_dprintf("%-2x:%x", term.s.term1, term.s.term0);
+					cvmx_dprintf("     	      %-2x:%x",
+						term.s.style1, term.s.style0);
+					cvmx_dprintf("        %-8x:%x", match.s.data1, match.s.data0);
 					cvmx_dprintf("            %-2x:%-2x       :%-1x :%2x   :%-2x",
-						pcam_action.s.pmc, pcam_action.s.style_add, pcam_action.s.pf, pcam_action.s.setty, pcam_action.s.advance);
+						act.s.pmc, act.s.style_add, act.s.pf, act.s.setty, act.s.advance);
 
 				}
 			}
@@ -1135,16 +1117,17 @@ void cvmx_pki_show_valid_pcam_entries(int node)
 /**
  * This function shows the pkind attributes in readable format,
  * read directly from hardware.
- * @param node    node number
- * @param pkind   pkind info to print
+ *
+ * @param node  Node number
+ * @param pkind  PKIND info to print
  */
 void cvmx_pki_show_pkind_attributes(int node, int pkind)
 {
 	unsigned cluster = 0;
 	int index;
-	cvmx_pki_pkindx_icgsel_t pkind_clsel;
-	cvmx_pki_clx_pkindx_style_t pkind_cfg_style;
-	cvmx_pki_icgx_cfg_t pki_cl_grp;
+	cvmx_pki_pkindx_icgsel_t icgsel;
+	cvmx_pki_clx_pkindx_style_t pstyle;
+	cvmx_pki_icgx_cfg_t icg_cfg;
 	cvmx_pki_clx_stylex_cfg_t style_cfg;
 	cvmx_pki_clx_stylex_alg_t style_alg;
 
@@ -1153,29 +1136,32 @@ void cvmx_pki_show_pkind_attributes(int node, int pkind)
 		return;
 	}
 	cvmx_dprintf("Showing stats for pkind %d------------------\n", pkind);
-	pkind_clsel.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKINDX_ICGSEL(pkind));
-	cvmx_dprintf("cluster group:	%d\n", pkind_clsel.s.icg);
-	pki_cl_grp.u64 = cvmx_read_csr_node(node, CVMX_PKI_ICGX_CFG(pkind_clsel.s.icg));
-	cvmx_dprintf("cluster mask of the group:	0x%x\n", pki_cl_grp.s.clusters);
+	icgsel.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKINDX_ICGSEL(pkind));
+	cvmx_dprintf("cluster group:	%d\n", icgsel.s.icg);
+	icg_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_ICGX_CFG(icgsel.s.icg));
+	cvmx_dprintf("cluster mask of the group:	0x%x\n", icg_cfg.s.clusters);
 
 	while (cluster < CVMX_PKI_NUM_CLUSTER) {
-		if (pki_cl_grp.s.clusters & (0x01L << cluster)) {
-			cvmx_dprintf("pkind %d config 0x%llx\n",
-				pkind,
+		if (icg_cfg.s.clusters & (0x01L << cluster)) {
+			cvmx_dprintf("pkind %d config 0x%llx\n", pkind,
 				(unsigned long long)cvmx_read_csr_node(node,
-				CVMX_PKI_CLX_PKINDX_CFG(pkind, cluster)));
-			pkind_cfg_style.u64 = cvmx_read_csr_node(node,
+					CVMX_PKI_CLX_PKINDX_CFG(pkind, cluster)));
+			pstyle.u64 = cvmx_read_csr_node(node,
 				CVMX_PKI_CLX_PKINDX_STYLE(pkind, cluster));
-			cvmx_dprintf("initial parse Mode: %d\n", pkind_cfg_style.s.pm);
-			cvmx_dprintf("initial_style: %d\n", pkind_cfg_style.s.style);
-			style_alg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(pkind_cfg_style.s.style, cluster));
+			cvmx_dprintf("initial parse Mode: %d\n", pstyle.s.pm);
+			cvmx_dprintf("initial_style: %d\n", pstyle.s.style);
+			style_alg.u64 = cvmx_read_csr_node(node,
+				CVMX_PKI_CLX_STYLEX_ALG(pstyle.s.style, cluster));
 			cvmx_dprintf("style_alg: 0x%llx\n", (unsigned long long)style_alg.u64);
-			style_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(pkind_cfg_style.s.style, cluster));
+			style_cfg.u64 = cvmx_read_csr_node(node,
+				CVMX_PKI_CLX_STYLEX_CFG(pstyle.s.style, cluster));
 			cvmx_dprintf("style_cfg: 0x%llx\n", (unsigned long long)style_cfg.u64);
 			cvmx_dprintf("style_cfg2: 0x%llx\n",
-				(unsigned long long)cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(pkind_cfg_style.s.style, cluster)));
+				(unsigned long long)cvmx_read_csr_node(node,
+					CVMX_PKI_CLX_STYLEX_CFG2(pstyle.s.style, cluster)));
 			cvmx_dprintf("style_buf: 0x%llx\n",
-				(unsigned long long)cvmx_read_csr_node(node, CVMX_PKI_STYLEX_BUF(pkind_cfg_style.s.style)));
+				(unsigned long long)cvmx_read_csr_node(node,
+					CVMX_PKI_STYLEX_BUF(pstyle.s.style)));
 			break;
 		}
 	}
@@ -1183,7 +1169,8 @@ void cvmx_pki_show_pkind_attributes(int node, int pkind)
 	cvmx_dprintf("qpg qos: %d\n", style_alg.s.qpg_qos);
 	for (index = 0; index < 8; index++) {
 		cvmx_dprintf("qpg index %d: 0x%llx\n", (index+style_cfg.s.qpg_base),
-			(unsigned long long)cvmx_read_csr_node(node, CVMX_PKI_QPG_TBLX(style_cfg.s.qpg_base+index)));
+			(unsigned long long)cvmx_read_csr_node(node,
+				CVMX_PKI_QPG_TBLX(style_cfg.s.qpg_base+index)));
 	}
 }
 
@@ -1197,9 +1184,9 @@ void cvmx_pki_show_pkind_attributes(int node, int pkind)
 /**
  * Get the status counters for index from PKI.
  *
- * @param node	   node number
- * @param index    pkind number (if PKI_STATS_CTL:mode=0) or
- *		   style(flow) number (if PKI_STATS_CTL:mode=1)
+ * @param node  Node number
+ * @param index  PKIND number (if PKI_STATS_CTL:mode=0) or
+ *    style(flow) number (if PKI_STATS_CTL:mode=1)
  * @param status   Where to put the results.
  */
 void cvmx_pki_get_stats(int node, int index, struct cvmx_pki_port_stats *status)
@@ -1227,9 +1214,9 @@ void cvmx_pki_get_stats(int node, int index, struct cvmx_pki_port_stats *status)
 	cvmx_pki_statx_hist4_t hist4;
 	cvmx_pki_statx_hist5_t hist5;
 	cvmx_pki_statx_hist6_t hist6;
-	cvmx_pki_pkndx_inb_stat0_t pki_pknd_inb_stat0;
-	cvmx_pki_pkndx_inb_stat1_t pki_pknd_inb_stat1;
-	cvmx_pki_pkndx_inb_stat2_t pki_pknd_inb_stat2;
+	cvmx_pki_pkndx_inb_stat0_t inb_stat0;
+	cvmx_pki_pkndx_inb_stat1_t inb_stat1;
+	cvmx_pki_pkndx_inb_stat2_t inb_stat2;
 	int cnt;
 
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
@@ -1307,9 +1294,9 @@ void cvmx_pki_get_stats(int node, int index, struct cvmx_pki_port_stats *status)
 	hist6.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_HIST6(index));
 	READCORRECT(cnt, node, hist6.u64, CVMX_PKI_STATX_HIST6(index));
 
-	pki_pknd_inb_stat0.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT0(index));
-	pki_pknd_inb_stat1.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT1(index));
-	pki_pknd_inb_stat2.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT2(index));
+	inb_stat0.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT0(index));
+	inb_stat1.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT1(index));
+	inb_stat2.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT2(index));
 
 	status->dropped_octets = stat4.s.drp_octs;
 	status->dropped_packets = stat3.s.drp_pkts;
@@ -1334,9 +1321,9 @@ void cvmx_pki_get_stats(int node, int index, struct cvmx_pki_port_stats *status)
 	status->bcast_l2_red_packets = stat14.s.drp_bcast;
 	status->mcast_l3_red_packets = stat17.s.drp_mcast;
 	status->bcast_l3_red_packets = stat16.s.drp_bcast;
-	status->inb_packets = pki_pknd_inb_stat0.s.pkts;
-	status->inb_octets = pki_pknd_inb_stat1.s.octs;
-	status->inb_errors = pki_pknd_inb_stat2.s.errs;
+	status->inb_packets = inb_stat0.s.pkts;
+	status->inb_octets = inb_stat1.s.octs;
+	status->inb_errors = inb_stat2.s.errs;
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 	/* Enable SLI_INT_SUM[RML_TO] interrupt after clear the pending interrupt. */
 	cvmx_write_csr_node(node, CVMX_CIU3_ISCX_W1C(0x1f000), 1);
@@ -1348,16 +1335,16 @@ EXPORT_SYMBOL(cvmx_pki_get_stats);
 /**
  * Clear the statistics counters for a port.
  *
- * @param node	   node number
- * @param port Port number (ipd_port) to get statistics for.
- *		   Make sure PKI_STATS_CTL:mode is set to 0 for
- *		   collecting per port/pkind stats.
+ * @param node  Node number
+ * @param port  Port number (ipd_port) to get statistics for.
+ *    Make sure PKI_STATS_CTL:mode is set to 0 for collecting per port/pkind stats.
  */
 void cvmx_pki_clear_port_stats(int node, uint64_t port)
 {
-	int interface = cvmx_helper_get_interface_num(port);
+	int iface = cvmx_helper_get_interface_num(port);
 	int index = cvmx_helper_get_interface_index_num(port);
-	int pknd = cvmx_helper_get_pknd(interface, index);
+	int xiface = cvmx_helper_node_interface_to_xiface(node, iface);
+	int pknd = cvmx_helper_get_pknd(xiface, index);
 
 	cvmx_pki_statx_stat0_t stat0;
 	cvmx_pki_statx_stat1_t stat1;
@@ -1382,9 +1369,9 @@ void cvmx_pki_clear_port_stats(int node, uint64_t port)
 	cvmx_pki_statx_hist4_t hist4;
 	cvmx_pki_statx_hist5_t hist5;
 	cvmx_pki_statx_hist6_t hist6;
-	cvmx_pki_pkndx_inb_stat0_t pki_pknd_inb_stat0;
-	cvmx_pki_pkndx_inb_stat1_t pki_pknd_inb_stat1;
-	cvmx_pki_pkndx_inb_stat2_t pki_pknd_inb_stat2;
+	cvmx_pki_pkndx_inb_stat0_t inb_stat0;
+	cvmx_pki_pkndx_inb_stat1_t inb_stat1;
+	cvmx_pki_pkndx_inb_stat2_t inb_stat2;
 
 	stat0.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT0(pknd));
 	stat1.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_STAT1(pknd));
@@ -1409,9 +1396,9 @@ void cvmx_pki_clear_port_stats(int node, uint64_t port)
 	hist4.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_HIST4(pknd));
 	hist5.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_HIST5(pknd));
 	hist6.u64 = cvmx_read_csr_node(node, CVMX_PKI_STATX_HIST6(pknd));
-	pki_pknd_inb_stat0.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT0(pknd));
-	pki_pknd_inb_stat1.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT1(pknd));
-	pki_pknd_inb_stat2.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT2(pknd));
+	inb_stat0.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT0(pknd));
+	inb_stat1.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT1(pknd));
+	inb_stat2.u64 = cvmx_read_csr_node(node, CVMX_PKI_PKNDX_INB_STAT2(pknd));
 
 	stat4.s.drp_octs = 0;
 	stat3.s.drp_pkts = 0;
@@ -1436,9 +1423,9 @@ void cvmx_pki_clear_port_stats(int node, uint64_t port)
 	stat14.s.drp_bcast = 0;
 	stat17.s.drp_mcast = 0;
 	stat16.s.drp_bcast = 0;
-	pki_pknd_inb_stat0.s.pkts = 0;
-	pki_pknd_inb_stat1.s.octs = 0;
-	pki_pknd_inb_stat2.s.errs = 0;
+	inb_stat0.s.pkts = 0;
+	inb_stat1.s.octs = 0;
+	inb_stat2.s.errs = 0;
 
 	cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT0(pknd), stat0.u64);
 	cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT1(pknd), stat1.u64);
@@ -1463,24 +1450,24 @@ void cvmx_pki_clear_port_stats(int node, uint64_t port)
 	cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST4(pknd), hist4.u64);
 	cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST5(pknd), hist5.u64);
 	cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST6(pknd), hist6.u64);
-	cvmx_write_csr_node(node, CVMX_PKI_PKNDX_INB_STAT0(pknd), pki_pknd_inb_stat0.u64);
-	cvmx_write_csr_node(node, CVMX_PKI_PKNDX_INB_STAT1(pknd), pki_pknd_inb_stat1.u64);
-	cvmx_write_csr_node(node, CVMX_PKI_PKNDX_INB_STAT2(pknd), pki_pknd_inb_stat2.u64);
+	cvmx_write_csr_node(node, CVMX_PKI_PKNDX_INB_STAT0(pknd), inb_stat0.u64);
+	cvmx_write_csr_node(node, CVMX_PKI_PKNDX_INB_STAT1(pknd), inb_stat1.u64);
+	cvmx_write_csr_node(node, CVMX_PKI_PKNDX_INB_STAT2(pknd), inb_stat2.u64);
 }
 EXPORT_SYMBOL(cvmx_pki_clear_port_stats);
 
 #ifdef CVMX_DUMP_PKI
 
-#define PKI_PRN_HEADLEN   28
-#define PKI_PRN_DATALEN   52
-#define PKI_PRN_LINELEN   (PKI_PRN_HEADLEN + PKI_PRN_DATALEN)
-#define PKI_PRN_DPLEN(__n)  (PKI_PRN_DATALEN / __n)
+#define PKI_PRN_HEADLEN 28
+#define PKI_PRN_DATALEN 52
+#define PKI_PRN_LINELEN (PKI_PRN_HEADLEN + PKI_PRN_DATALEN)
+#define PKI_PRN_DPLEN(__n) (PKI_PRN_DATALEN / __n)
 
 #ifndef MAX
 #define MAX(__a, __b) (((__a) > (__b)) ? (__a) : (__b))
 #endif
 
-static int pki_find_pkind_chans(int pkind, char *buf, int blen);
+static int pki_find_pkind_chans(int node, int pkind, char *buf, int blen);
 
 static int pki_get_num_bgxs(void)
 {
@@ -1501,7 +1488,8 @@ static void pki_flprint(int level, char *name, const char *format, ...)
 	va_start(args, format);
 	offs = level * 2;
 	vsnprintf(dbuf, PKI_PRN_DATALEN + 1, format, args);
-	cvmx_printf("%*s%-*s%*s\n", offs, "", PKI_PRN_HEADLEN - offs, name, PKI_PRN_DATALEN, dbuf);
+	cvmx_printf("%*s%-*s%*s\n",
+		offs, "", PKI_PRN_HEADLEN - offs, name, PKI_PRN_DATALEN, dbuf);
 	va_end(args);
 }
 /*
@@ -1613,19 +1601,23 @@ int cvmx_pki_config_dump(unsigned node)
 	cvmx_printf("   PKI Configuration (Node %d)\n", node);
 	cvmx_printf("%s\n", lines[0]);
 	pki_flprint(0, "PKI Enabled/Active", "%d/%d", ctl.s.pki_en, rst.s.active);
-	pki_flprint(0, "Packet buffering", "%*s", PKI_PRN_DATALEN, ctl.s.pkt_off ? "Disabled" : "Enabled");
-	pki_flprint(0, "FPA buffer policy", "%*s", PKI_PRN_DATALEN, ctl.s.fpa_wait ? "Wait" : "Drop");
-	pki_flprint(0, "BPID backpressure", "%*s", PKI_PRN_DATALEN, ctl.s.pbp_en ? "Enabled" : "Disabled");
-	pki_flprint(0, "", "%*s%*s%*s%*s", PKI_PRN_DPLEN(4), "DST6", PKI_PRN_DPLEN(4), "SRC6",
-		PKI_PRN_DPLEN(4), "DST", PKI_PRN_DPLEN(4), "SRC");
-	pki_flprint(0, "Tag secret words (hex)", "%*x%*x%*x%*x", PKI_PRN_DPLEN(4), secret.s.dst6,
-		PKI_PRN_DPLEN(4), secret.s.src6, PKI_PRN_DPLEN(4), secret.s.dst,
-		PKI_PRN_DPLEN(4), secret.s.src);
+	pki_flprint(0, "Packet buffering", "%*s",
+		PKI_PRN_DATALEN, ctl.s.pkt_off ? "Disabled" : "Enabled");
+	pki_flprint(0, "FPA buffer policy", "%*s",
+		PKI_PRN_DATALEN, ctl.s.fpa_wait ? "Wait" : "Drop");
+	pki_flprint(0, "BPID backpressure", "%*s",
+		PKI_PRN_DATALEN, ctl.s.pbp_en ? "Enabled" : "Disabled");
+	pki_flprint(0, "", "%*s%*s%*s%*s", PKI_PRN_DPLEN(4), "DST6",
+		PKI_PRN_DPLEN(4), "SRC6", PKI_PRN_DPLEN(4), "DST", PKI_PRN_DPLEN(4), "SRC");
+	pki_flprint(0, "Tag secret words (hex)", "%*x%*x%*x%*x",
+		PKI_PRN_DPLEN(4), secret.s.dst6, PKI_PRN_DPLEN(4), secret.s.src6,
+		PKI_PRN_DPLEN(4), secret.s.dst, PKI_PRN_DPLEN(4), secret.s.src);
 	cvmx_printf("%-30s %4s %4s %4s %4s %4s %4s %4s %4s %4s %4s\n", "",
 		"VIRT", "CLG", "CL2", "L4", "IL3", "L3", "MPLS", "FULC", "DSA", "HG");
 	cvmx_printf("%-30s %4d %4d %4d %4d %4d %4d %4d %4d %4d %4d\n", "Parsing enabled",
 		pen.s.virt_pen, pen.s.clg_pen, pen.s.cl2_pen, pen.s.l4_pen, pen.s.il3_pen,
 		pen.s.l3_pen, pen.s.mpls_pen, pen.s.fulc_pen, pen.s.dsa_pen, pen.s.hg_pen);
+
 	/* Show PKINDs.*/
 	for (pkind = 0, pcrc32 = 0, ibase = 0; pkind < CVMX_PKI_NUM_PKIND; pkind++) {
 		cvmx_pki_pkindx_icgsel_t cgsel;
@@ -1647,64 +1639,82 @@ int cvmx_pki_config_dump(unsigned node)
 		for (cluster = 0; cluster < nclusters; cluster++) {
 			if (((1 << cluster) & mask) == 0)
 				continue;
-			pkstyle[cluster].u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_STYLE(pkind, cluster));
-			pkcfg[cluster].u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_CFG(pkind, cluster));
-			pkskip[cluster].u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_SKIP(pkind, cluster));
-			pkl2cust[cluster].u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_L2_CUSTOM(pkind, cluster));
-			pklgcust[cluster].u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PKINDX_LG_CUSTOM(pkind, cluster));
+			pkstyle[cluster].u64 = cvmx_read_csr_node(node,
+				CVMX_PKI_CLX_PKINDX_STYLE(pkind, cluster));
+			pkcfg[cluster].u64 = cvmx_read_csr_node(node,
+				CVMX_PKI_CLX_PKINDX_CFG(pkind, cluster));
+			pkskip[cluster].u64 = cvmx_read_csr_node(node,
+				CVMX_PKI_CLX_PKINDX_SKIP(pkind, cluster));
+			pkl2cust[cluster].u64 = cvmx_read_csr_node(node,
+				CVMX_PKI_CLX_PKINDX_L2_CUSTOM(pkind, cluster));
+			pklgcust[cluster].u64 = cvmx_read_csr_node(node,
+				CVMX_PKI_CLX_PKINDX_LG_CUSTOM(pkind, cluster));
 			CVMX_MT_CRC_DWORD(pkstyle[cluster].u64 & ((1ull << 16) - 1));
 			CVMX_MT_CRC_DWORD(pkcfg[cluster].u64 & ((1ull << 16) - 1));
 			CVMX_MT_CRC_DWORD(pkskip[cluster].u64 & ((1ull << 16) - 1));
 			CVMX_MT_CRC_DWORD(pkl2cust[cluster].u64 & ((1ull << 16) - 1));
 			CVMX_MT_CRC_DWORD(pklgcust[cluster].u64 & ((1ull << 8) - 1));
 		}
-		if (pki_find_pkind_chans(pkind, chans, PKI_PRN_DATALEN))
+		if (pki_find_pkind_chans(node, pkind, chans, PKI_PRN_DATALEN))
 			CVMX_MT_CRC_DWORD(pkind);
 		CVMX_MF_CRC_IV(crc32);
 		if (crc32 == pcrc32)
 			continue;
 		if (pkind > 0 && (pkind - 1) != ibase)
-			cvmx_printf("\nPKIND(s) %02d-%02d -- same as PKIND %02d\n", pkind - 1, ibase + 1, ibase);
+			cvmx_printf("\nPKIND(s) %02d-%02d -- same as PKIND %02d\n",
+				pkind - 1, ibase + 1, ibase);
 		pcrc32 = crc32;
 		ibase = pkind;
-        
+
 		DLMPRINT("PKIND %02d:", pkind);
 		pki_flprint(0, "Channel", "%s", (chans[0] != 0) ? chans : "--");
 		NSPRINT(nclusters, __i, sprintf(lines[__i], "Cluster%d", __i));
-		NMPRINT(nclusters, mask, __i, 0, "", "%*s", lines[__i]);
+		NMPRINT(nclusters, ((1 << nclusters) - 1), __i, 0, "", "%*s", lines[__i]);
 		cvmx_printf("Mapping:\n");
 		pki_flprint(1, "Cluster Group", "%*d", PKI_PRN_DATALEN, cgsel.s.icg);
 		cvmx_printf("Parsing:\n");
 		NMPRINT(nclusters, mask, __i, 1, "Initial Style", "%*d", pkstyle[__i].s.style);
 		NSPRINT(nclusters, __i, sprintf(lines[__i], "%c%c%c%c%c%c%c",
-			(pkstyle[__i].s.pm & (1 << 0)) ? '-' : 'A', (pkstyle[__i].s.pm & (1 << 1)) ? '-' : 'B',
-			(pkstyle[__i].s.pm & (1 << 2)) ? '-' : 'C', (pkstyle[__i].s.pm & (1 << 3)) ? '-' : 'D',
-			(pkstyle[__i].s.pm & (1 << 4)) ? '-' : 'E', (pkstyle[__i].s.pm & (1 << 5)) ? '-' : 'F',
+			(pkstyle[__i].s.pm & (1 << 0)) ? '-' : 'A',
+			(pkstyle[__i].s.pm & (1 << 1)) ? '-' : 'B',
+			(pkstyle[__i].s.pm & (1 << 2)) ? '-' : 'C',
+			(pkstyle[__i].s.pm & (1 << 3)) ? '-' : 'D',
+			(pkstyle[__i].s.pm & (1 << 4)) ? '-' : 'E',
+			(pkstyle[__i].s.pm & (1 << 5)) ? '-' : 'F',
 			(pkstyle[__i].s.pm & (1 << 6)) ? '-' : 'G'));
 		NMPRINT(nclusters, mask, __i, 1, "Initial Parse Mode", "%*s", lines[__i]);
 		NMPRINT(nclusters, mask, __i, 1, "INST skip (bytes)", "%*d", pkskip[__i].s.inst_skip);
 		if (NMCMPEQ(0, pkcfg[__i].s.inst_hdr, nclusters, mask, __i) != 0)
-			NMPRINT(nclusters, mask, __i, 1, "INST Header present", "%*s", pkcfg[__i].s.inst_hdr ? "Yes" : "No");
+			NMPRINT(nclusters, mask, __i, 1, "INST Header present", "%*s",
+				pkcfg[__i].s.inst_hdr ? "Yes" : "No");
 		NMPRINT(nclusters, mask, __i, 1, "FCS skip (bytes)", "%*d", pkskip[__i].s.fcs_skip);
-		NMPRINT(nclusters, mask, __i, 1, "FCS present", "%*s", pkcfg[__i].s.fcs_pres ? "Yes" : "No");
+		NMPRINT(nclusters, mask, __i, 1, "FCS present", "%*s",
+			pkcfg[__i].s.fcs_pres ? "Yes" : "No");
 		if (NMCMPEQ(0, pkl2cust[__i].s.valid, nclusters, mask, __i) != 0) {
-			NMPRINT(nclusters, mask, __i, 1, "L2 custom match", "%*s", pkl2cust[__i].s.valid ? "On" : "Off");
+			NMPRINT(nclusters, mask, __i, 1, "L2 custom match", "%*s",
+				pkl2cust[__i].s.valid ? "On" : "Off");
 			NMPRINT(nclusters, mask, __i, 1, "L2 Custom offset", "%*d", pkl2cust[__i].s.offset);
 		}
 		if (NMCMPEQ(0, pkcfg[__i].s.lg_custom, nclusters, mask, __i) != 0) {
-			NMPRINT(nclusters, mask, __i, 1, "LG custom match", "%*s", pkcfg[__i].s.lg_custom ? "On" : "Off");
+			NMPRINT(nclusters, mask, __i, 1, "LG custom match", "%*s",
+				pkcfg[__i].s.lg_custom ? "On" : "Off");
 			NMPRINT(nclusters, mask, __i, 1, "LG Custom offset", "%*d", pklgcust[__i].s.offset);
 		}
 		if (NMCMPEQ(0, pkcfg[__i].s.mpls_en, nclusters, mask, __i) != 0)
-			NMPRINT(nclusters, mask, __i, 1, "MPLS parsing", "%*s", pkcfg[__i].s.mpls_en ? "On" : "Off");
+			NMPRINT(nclusters, mask, __i, 1, "MPLS parsing", "%*s",
+				pkcfg[__i].s.mpls_en ? "On" : "Off");
 		if (NMCMPEQ(0, pkcfg[__i].s.dsa_en, nclusters, mask, __i) != 0)
-			NMPRINT(nclusters, mask, __i, 1, "DSA parsing", "%*s", pkcfg[__i].s.dsa_en ? "On" : "Off");
+			NMPRINT(nclusters, mask, __i, 1, "DSA parsing", "%*s",
+				pkcfg[__i].s.dsa_en ? "On" : "Off");
 		if (NMCMPEQ(0, pkcfg[__i].s.hg_en, nclusters, mask, __i) != 0)
-			NMPRINT(nclusters, mask, __i, 1, "HG parsing", "%*s", pkcfg[__i].s.hg_en ? "On" : "Off");
+			NMPRINT(nclusters, mask, __i, 1, "HG parsing", "%*s",
+				pkcfg[__i].s.hg_en ? "On" : "Off");
 		if (NMCMPEQ(0, pkcfg[__i].s.hg2_en, nclusters, mask, __i) != 0)
-			NMPRINT(nclusters, mask, __i, 1, "HG2 parsing", "%*s", pkcfg[__i].s.hg2_en ? "On" : "Off");
+			NMPRINT(nclusters, mask, __i, 1, "HG2 parsing", "%*s",
+				pkcfg[__i].s.hg2_en ? "On" : "Off");
 		if (NMCMPEQ(0, pkcfg[__i].s.fulc_en, nclusters, mask, __i) != 0)
-			NMPRINT(nclusters, mask, __i, 1, "Fulcrum Header parsing", "%*s", pkcfg[__i].s.fulc_en ? "On" : "Off");
+			NMPRINT(nclusters, mask, __i, 1, "Fulcrum Header parsing", "%*s",
+				pkcfg[__i].s.fulc_en ? "On" : "Off");
 	}
 	if ((pkind - 1) != ibase)
 		cvmx_printf("\nPKIND(s) %02d-%02d -- same as PKIND %02d\n", pkind - 1, ibase + 1, ibase);
@@ -1729,10 +1739,14 @@ int cvmx_pki_config_dump(unsigned node)
 		CVMX_MT_CRC_DWORD(tagmask.u64 & ((1ull << 16) - 1));
 		mask = 0;
 		for (cluster = 0; cluster < nclusters; cluster++) {
-			stcfg[cluster].u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
-			stcfg2[cluster].u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
-			stalg[cluster].u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
-			qpgtx[cluster].u64 = cvmx_read_csr_node(node, CVMX_PKI_QPG_TBLX(stcfg[cluster].s.qpg_base));
+			stcfg[cluster].u64 = cvmx_read_csr_node(node,
+				CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
+			stcfg2[cluster].u64 = cvmx_read_csr_node(node,
+				CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
+			stalg[cluster].u64 = cvmx_read_csr_node(node,
+				CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
+			qpgtx[cluster].u64 = cvmx_read_csr_node(node,
+				CVMX_PKI_QPG_TBLX(stcfg[cluster].s.qpg_base));
 			CVMX_MT_CRC_DWORD(stcfg[cluster].u64 & 0x7FFF07FF);
 			CVMX_MT_CRC_DWORD(stcfg2[cluster].u64 & ((1ull << 32) - 1));
 			CVMX_MT_CRC_DWORD(stalg[cluster].u64 & ((1ull << 32) - 1));
@@ -1742,13 +1756,14 @@ int cvmx_pki_config_dump(unsigned node)
 		if (crc32 == pcrc32)
 			continue;
 		if (style > 0 && (style - 1) != ibase)
-			cvmx_printf("\nSTYLE(s) %02d-%02d -- same as STYLE %02d\n", style - 1, ibase + 1, ibase);
+			cvmx_printf("\nSTYLE(s) %02d-%02d -- same as STYLE %02d\n",
+				style - 1, ibase + 1, ibase);
 		pcrc32 = crc32;
 		ibase = style;
 
 		DLMPRINT("STYLE %02d:", style);
 		NSPRINT(nclusters, __i, sprintf(lines[__i], "Cluster%d", __i));
-		NMPRINT(nclusters, mask, __i, 0, "", "%*s", lines[__i]);
+		NMPRINT(nclusters, ((1 << nclusters) - 1), __i, 0, "", "%*s", lines[__i]);
 		cvmx_printf("Buffering:\n");
 		stbuf.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_BUF(style));
 		pki_flprint(1, "WQE header", "%s", stbuf.s.wqe_hsz ? "WORD0..5" : "WORD0..4");
@@ -1773,13 +1788,17 @@ int cvmx_pki_config_dump(unsigned node)
 			NMPRINT(nclusters, mask, __i, 1, "T-Tag <= Dest", "%*s", lines[__i]);
 		}
 		if (NMCMPEQ(0, stalg[__i].s.tag_pctl, 4, mask, __i) != 0)
-			NMPRINT(nclusters, mask, __i, 1, "T-Tag <= Proto", "%*s", stalg[__i].s.tag_pctl ? "On":"Off");
+			NMPRINT(nclusters, mask, __i, 1, "T-Tag <= Proto", "%*s",
+				stalg[__i].s.tag_pctl ? "On":"Off");
 		if (NMCMPEQ(0, stalg[__i].s.tag_vs0, 4, mask, __i) != 0)
-			NMPRINT(nclusters, mask, __i, 1, "T-Tag <= VLAN0", "%*s", stalg[__i].s.tag_vs0 ? "On":"Off");
+			NMPRINT(nclusters, mask, __i, 1, "T-Tag <= VLAN0", "%*s",
+				stalg[__i].s.tag_vs0 ? "On":"Off");
 		if (NMCMPEQ(0, stalg[__i].s.tag_vs1, 4, mask, __i) != 0)
-			NMPRINT(nclusters, mask, __i, 1, "T-Tag <= VLAN1", "%*s", stalg[__i].s.tag_vs1 ? "On":"Off");
+			NMPRINT(nclusters, mask, __i, 1, "T-Tag <= VLAN1", "%*s",
+				stalg[__i].s.tag_vs1 ? "On":"Off");
 		if (NMCMPEQ(0, stalg[__i].s.tag_prt, 4, mask, __i) != 0)
-			NMPRINT(nclusters, mask, __i, 1, "T-Tag <= Port", "%*s", stalg[__i].s.tag_prt ? "On":"Off");
+			NMPRINT(nclusters, mask, __i, 1, "T-Tag <= Port", "%*s",
+				stalg[__i].s.tag_prt ? "On":"Off");
 		if (NMCMPEQ(0, stcfg2[__i].s.tag_inc, 4, mask, __i) != 0) {
 			cvmx_pki_tag_incx_ctl_t tagctl;
 			cvmx_pki_tag_incx_mask_t incmask;
@@ -1797,7 +1816,8 @@ int cvmx_pki_config_dump(unsigned node)
 				tagctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_INCX_CTL(tagx));
 				incmask.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_INCX_MASK(tagx));
 				sprintf(lines[0], "M-Tag%d", i);
-				pki_flprint(2, lines[0], "%s:%d:%016llx", mtagptr_map[tagctl.s.ptr_sel], tagctl.s.offset, incmask.s.en);
+				pki_flprint(2, lines[0], "%s:%d:%016llx",
+					mtagptr_map[tagctl.s.ptr_sel], tagctl.s.offset, incmask.s.en);
 			}
 		}
 		if (NMCMPEQ(0, stcfg2[__i].s.tag_masken, 4, mask, __i) != 0) {
@@ -1839,7 +1859,7 @@ int cvmx_pki_config_dump(unsigned node)
 		if (mask == 0)
 			continue;
 
-		DLMPRINT("CLUSTER GROUP %d:", group);
+		DLMPRINT("CLUSTER GROUP %d (mask = 0x%x):", group, mask);
 		cvmx_printf("Action = {PMC(hex) : +STYLE(dec) : PF(hex) : SETTY(dec) : ADVANCE(dec)}\n");
 		pki_flprint(0, "Parsing", "%s", cgcfg.s.pena ? "Enabled" : "Disabled");
 		pki_flprint(0, "Entry", "%*s%*s", PKI_PRN_DPLEN(2), "PCAM0", PKI_PRN_DPLEN(2), "PCAM1");
@@ -1855,9 +1875,12 @@ int cvmx_pki_config_dump(unsigned node)
 			cvmx_printf("---------------- Cluster %d\n", cluster);
 			for (entry = 0; entry < CVMX_PKI_NUM_PCAM_ENTRY; entry++) {
 				for (pcam = 0; pcam < CVMX_PKI_NUM_PCAM_BANK; pcam++) {
-					term[pcam].u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PCAMX_TERMX(cluster, pcam, entry));
-					match[pcam].u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PCAMX_MATCHX(cluster, pcam, entry));
-					action[pcam].u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_PCAMX_ACTIONX(cluster, pcam, entry));
+					term[pcam].u64 = cvmx_read_csr_node(node,
+						CVMX_PKI_CLX_PCAMX_TERMX(cluster, pcam, entry));
+					match[pcam].u64 = cvmx_read_csr_node(node,
+						CVMX_PKI_CLX_PCAMX_MATCHX(cluster, pcam, entry));
+					action[pcam].u64 = cvmx_read_csr_node(node,
+						CVMX_PKI_CLX_PCAMX_ACTIONX(cluster, pcam, entry));
 				}
 				if ((term[0].s.valid + term[1].s.valid) == 0)
 					continue;
@@ -1885,9 +1908,10 @@ int cvmx_pki_config_dump(unsigned node)
 	cvmx_printf("%-*s%*s%*s%*s%*s%*s%*s%*s\n", n, "QPG", n, "PADD", n, "GRP_OK",
 		n, "GRP_BAD", n, "GTAG_OK", n, "GTAG_BAD", n, "NODE", n, "LAURA");
 	for (i = 0; i < CVMX_PKI_NUM_QPG_ENTRY; i++) {
-		cvmx_pki_qpg_tblx_t qpgt;
-		qpgt.u64 = cvmx_read_csr_node(node, CVMX_PKI_QPG_TBLX(i));
-		if (qpgt.u64 != 0) {
+		cvmx_pki_qpg_tblx_t qpgt, qpgt2;
+		qpgt2.u64 = qpgt.u64 = cvmx_read_csr_node(node, CVMX_PKI_QPG_TBLX(i));
+		qpgt2.s.aura_node = 0;
+		if (qpgt2.u64 != 0) {
 			sprintf(lines[0], "%d", i);
 			cvmx_printf("%-*s%*d%*d%*d%*d%*d%*d%*d\n", n, lines[0], n, qpgt.s.padd,
 				n, qpgt.s.grp_ok, n, qpgt.s.grp_bad, n, qpgt.s.grptag_ok,
@@ -1944,7 +1968,8 @@ int cvmx_pki_config_dump(unsigned node)
 			else
 				continue;
 			sprintf(lines[0], "%d(0x%x)", i, i);
-			cvmx_printf("%-*s%-*s%*s%*d\n", n * 2, lines[0], n * 2, lines[1], n * 3, "", n, chan.s.bpid);
+			cvmx_printf("%-*s%-*s%*s%*d\n",
+				n * 2, lines[0], n * 2, lines[1], n * 3, "", n, chan.s.bpid);
 		}
 	}
 	return 0;
@@ -1964,21 +1989,23 @@ int cvmx_pki_stats_dump(unsigned node)
 	char line[256];
 
 	memset(line, '*', PKI_PRN_LINELEN); line[PKI_PRN_LINELEN] = '\0';
-	cvmx_dprintf("\n%s\n", line);
-	cvmx_dprintf("PKI Statistics on Node %d:\n", node);
-	cvmx_dprintf("%s\n", line);
+	cvmx_printf("\n%s\n", line);
+	cvmx_printf("   PKI Statistics (Node %d)\n", node);
+	cvmx_printf("%s\n", line);
 	ctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_STAT_CTL);
 
 	for (pkind = 0; pkind < CVMX_PKI_NUM_PKIND; pkind++) {
 		cvmx_pki_get_stats(node, pkind, &stats);
 
 		if ((stats.inb_octets + stats.inb_errors) > 0) {
-			pki_find_pkind_chans(pkind, chans, PKI_PRN_DATALEN);
-			cvmx_dprintf("PKIND %d  <= %s\n", pkind, (chans[0] != 0) ? chans : "??");
-			if (stats.inb_octets)
-				pki_flprint(2, "Packets:", "%lld", stats.inb_packets);
+			pki_find_pkind_chans(node, pkind, chans, PKI_PRN_DATALEN);
+			cvmx_printf("PKIND %d  <= %s\n", pkind, (chans[0] != 0) ? chans : "??");
+			if (stats.inb_octets) {
+				pki_flprint(2, "Total good packets:", "%lld", stats.inb_packets);
+				pki_flprint(2, "Total good bytes:", "%lld", stats.inb_octets);
+			}
 			if (stats.inb_errors)
-				pki_flprint(2, "Err.packets:", "%lld", stats.inb_errors);
+				pki_flprint(2, "Total err.packets:", "%lld", stats.inb_errors);
 		}
 		count = stats.packets;
 		count += stats.len_64_packets;
@@ -1998,9 +2025,11 @@ int cvmx_pki_stats_dump(unsigned node)
 
 		if (count > 0) {
 			if (ctl.s.mode == 0x1)
-				cvmx_dprintf("STYLE %d\n", pkind);
-			if (stats.packets > 0)
+				cvmx_printf("STYLE %d\n", pkind);
+			if (stats.packets > 0) {
 				pki_flprint(2, "Non-dropped packets:", "%lld", stats.packets);
+				pki_flprint(2, "Non-dropped bytes:", "%lld", stats.octets);
+			}
 			if (stats.len_64_packets > 0)
 				pki_flprint(2, "64-byte packets:", "%lld", stats.len_64_packets);
 			if (stats.len_65_127_packets > 0)
@@ -2017,8 +2046,10 @@ int cvmx_pki_stats_dump(unsigned node)
 				pki_flprint(2, ">1519-byte packets:", "%lld", stats.len_1519_max_packets);
 			if (stats.pci_raw_packets > 0)
 				pki_flprint(2, "Raw packets:", "%lld", stats.pci_raw_packets);
-			if (stats.dropped_packets > 0)
+			if (stats.dropped_packets > 0) {
 				pki_flprint(2, "Dropped packets:", "%lld", stats.dropped_packets);
+				pki_flprint(2, "Dropped bytes:", "%lld", stats.dropped_octets);
+			}
 			if (stats.fcs_align_err_packets > 0)
 				pki_flprint(2, "FCS errors:", "%lld", stats.fcs_align_err_packets);
 			if (stats.runt_crc_packets > 0)
@@ -2034,9 +2065,59 @@ int cvmx_pki_stats_dump(unsigned node)
 	return 0;
 }
 
-int pki_find_pkind_chans(int pkind, char *buf, int blen)
+/*
+ * Clear PKI statistics.
+ * See function prototype in cvmx-pki.h
+ */
+void cvmx_pki_stats_clear(unsigned node)
+{
+	int i;
+
+	for (i = 0; i < CVMX_PKI_NUM_PKIND; i++) {
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT0(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT1(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT2(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT3(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT4(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT5(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT6(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT7(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT8(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT9(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT10(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT11(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT12(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT13(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT14(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT15(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT16(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT17(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_STAT18(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST0(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST1(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST2(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST3(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST4(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST5(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_STATX_HIST6(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_PKNDX_INB_STAT0(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_PKNDX_INB_STAT1(i), 0);
+		cvmx_write_csr_node(node, CVMX_PKI_PKNDX_INB_STAT2(i), 0);
+	}
+	cvmx_write_csr_node(node, CVMX_PKI_GEN_INT, ~0ull);
+	cvmx_write_csr_node(node, CVMX_PKI_ECC_INT0, ~0ull);
+	cvmx_write_csr_node(node, CVMX_PKI_ECC_INT1, ~0ull);
+	cvmx_write_csr_node(node, CVMX_PKI_ECC_INT2, ~0ull);
+
+	for (i = 0; i < (int)cvmx_pki_num_clusters(); i++) {
+		cvmx_write_csr_node(node, CVMX_PKI_CLX_INT(i), ~0ull);
+		cvmx_write_csr_node(node, CVMX_PKI_CLX_ECC_INT(i), ~0ull);
+	}
+}
+
+int pki_find_pkind_chans(int node, int pkind, char *buf, int blen)
 {
-	int node, bi, block, port, nbgxs, nchans;
+	int bi, block, port, nbgxs, nchans;
 	cvmx_bgxx_cmrx_rx_id_map_t bgxmap;
 	cvmx_lbk_chx_pkind_t lbkmap;
 	int bcheck_term(int bi, int blen) {
@@ -2050,7 +2131,6 @@ int pki_find_pkind_chans(int pkind, char *buf, int blen)
 	memset(buf, 0, blen);
 	if ((nbgxs = pki_get_num_bgxs()) == 0)
 		return 0;
-	node = cvmx_get_node_num();
 	/* BGX */
 	bi = nchans = 0;
 	for (block = 0; block < nbgxs; block++) {
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3-resources.c b/arch/mips/cavium-octeon/executive/cvmx-pko3-resources.c
index ec4a47e..d5d9c17 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3-resources.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3-resources.c
@@ -221,8 +221,9 @@ EXPORT_SYMBOL(cvmx_pko_free_queues);
  */
 int __cvmx_pko3_dq_param_setup(unsigned node)
 {
+#if !defined(__U_BOOT__)
 	cvmx_pko3_dq_params_t  *pParam;
-	char block_name[] = "cvmx_pko3_dq_param_0";
+	char block_name[] = "cvmx_pko3_dq_globl_param_0";
 	unsigned i;
 
 	pParam = __cvmx_pko3_dq_params[node];
@@ -247,7 +248,7 @@ int __cvmx_pko3_dq_param_setup(unsigned node)
 		return -1;
 
 	__cvmx_pko3_dq_params[node] = pParam;
-
+#endif	/* ! U_BOOT */
 	return 0;
 }
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index 769b76e..e9dae54 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -1498,7 +1498,7 @@ static int cvmx_pko3_pdesc_subdc_add(cvmx_pko3_pdesc_t *pdesc,
 	unsigned i;
 
 	/* Simple handling while fitting the command buffer */
-	if (cvmx_likely(pdesc->num_words <= 15 && pdesc->jump_buf == NULL)) {
+	if (cvmx_likely(pdesc->num_words < 15 && pdesc->jump_buf == NULL)) {
 		pdesc->word[ pdesc->num_words ] = subdc;
 		pdesc->num_words ++;
 		return pdesc->num_words;
@@ -1614,7 +1614,7 @@ int cvmx_pko3_pdesc_transmit(cvmx_pko3_pdesc_t *pdesc, uint16_t dq,
 
 	/* To preserve packet order, go atomic with DQ-specific tag */
 	if (tag != NULL)
-		cvmx_pow_tag_sw_nocheck(*tag ^ dq, CVMX_POW_TAG_TYPE_ATOMIC);
+		cvmx_pow_tag_sw(*tag ^ dq, CVMX_POW_TAG_TYPE_ATOMIC);
 
         /* Send the PKO3 command into the Descriptor Queue */
         pko_status = __cvmx_pko3_do_dma(port_node, dq,
@@ -1704,7 +1704,8 @@ int cvmx_pko3_pdesc_buf_append(cvmx_pko3_pdesc_t *pdesc, void *p_data,
 
 	hdr_s = (void *) &pdesc->word[0];
 
-	if(pdesc->last_aura == -1 && gaura != ((unsigned)-1)) {
+	if (gaura != (unsigned)-1) {
+	    if (pdesc->last_aura == -1 ) {
 		unsigned buf_sz = 128;
 
 		/* First mbuf, calculate headroom */
@@ -1715,7 +1716,7 @@ int cvmx_pko3_pdesc_buf_append(cvmx_pko3_pdesc_t *pdesc, void *p_data,
 #endif
 		pdesc->headroom = (unsigned long)p_data & (buf_sz-1);
 		pdesc->last_aura = hdr_s->s.aura = gaura;
-	} else if(pdesc->last_aura != (short) gaura) {
+	    } else if(pdesc->last_aura != (short) gaura) {
 		aura_s.s.aura = gaura;
 		aura_s.s.offset = 0;
 		aura_s.s.alg = AURAALG_NOP;
@@ -1725,6 +1726,7 @@ int cvmx_pko3_pdesc_buf_append(cvmx_pko3_pdesc_t *pdesc, void *p_data,
 		rc = cvmx_pko3_pdesc_subdc_add(pdesc, aura_s.u64);
 		if (rc < 0)
 			return -1;
+	    }
 	}
 
 	gather_s.u64 = 0;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm-tables.c b/arch/mips/cavium-octeon/executive/cvmx-qlm-tables.c
index 28b4a7c..f884710 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm-tables.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm-tables.c
@@ -1,3 +1,48 @@
+/***********************license start***************
+ * Copyright (c) 2011-2014  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * <hr>$Revision: 96756 $<hr>
+ */
+
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
 #include <asm/octeon/cvmx-qlm.h>
diff --git a/arch/mips/cavium-octeon/executive/cvmx-srio.c b/arch/mips/cavium-octeon/executive/cvmx-srio.c
index 5760e9d..a8be00a 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-srio.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-srio.c
@@ -381,7 +381,7 @@ static int __cvmx_srio_local_write32(int srio_port, uint32_t offset, uint32_t da
 }
 
 
-#ifdef CVMX_BUILD_FOR_STANDALONE
+#if (!defined(CVMX_BUILD_FOR_LINUX_KERNEL) && !defined(CVMX_BUILD_FOR_LINUX_HOST))
 /**
  * Convert an ipd port number to its sRIO link number per SoC model.
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-agl-defs.h b/arch/mips/include/asm/octeon/cvmx-agl-defs.h
index 56758e0..25d9dd9 100644
--- a/arch/mips/include/asm/octeon/cvmx-agl-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-agl-defs.h
@@ -5222,12 +5222,7 @@ union cvmx_agl_prtx_ctl {
                                                          order to reduce system cost, a 500MHz coprocessor clock can be divided down and remove the
                                                          requirements for the external oscillator.  Additionally, in some well defined systems, the
                                                          link partner may be able to source the RXC.  The RGMII would operate correctly in 1000Mbs
-                                                         mode only.  (INTERNAL: Some programming magic could allow for 10/100 operation if
-                                                         critical).
-                                                         0 = RGMII REFCLK
-                                                         1 = RGMII RXC (1000Mbs only) (INTERNAL: some programming restrictions apply for 10/100)
-                                                         2 = divided coprocessor clk
-                                                         3 = reserved */
+                                                         mode only.  ( */
 	uint64_t reserved_5_5                 : 1;
 	uint64_t dllrst                       : 1;  /**< DLL Reset */
 	uint64_t comp                         : 1;  /**< Compensation Enable */
@@ -5366,12 +5361,7 @@ union cvmx_agl_prtx_ctl {
                                                          order to reduce system cost, a 500MHz coprocessor clock can be divided down and remove the
                                                          requirements for the external oscillator.  Additionally, in some well defined systems, the
                                                          link partner may be able to source the RXC.  The RGMII would operate correctly in 1000Mbs
-                                                         mode only.  (INTERNAL: Some programming magic could allow for 10/100 operation if
-                                                         critical).
-                                                         0 = RGMII REFCLK
-                                                         1 = RGMII RXC (1000Mbs only) (INTERNAL: some programming restrictions apply for 10/100)
-                                                         2 = divided coprocessor clk
-                                                         3 = reserved */
+                                                         mode only.  ( */
 	uint64_t reserved_5_5                 : 1;
 	uint64_t dllrst                       : 1;  /**< DLL Reset */
 	uint64_t comp                         : 1;  /**< Compensation Enable */
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index 2ca2ea5..c01dbab 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -41,7 +41,7 @@
  * @file
  * Header file for simple executive application initialization.  This defines
  * part of the ABI between the bootloader and the application.
- * <hr>$Revision: 126111 $<hr>
+ * <hr>$Revision: 127966 $<hr>
  *
  */
 
@@ -314,11 +314,11 @@ enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_SWORDFISH = 72,
 	CVMX_BOARD_TYPE_SFF7800 = 73,	/* Embedded Planet board */
 	CVMX_BOARD_TYPE_WAVE2 = 74,
-	CVMX_BOARD_TYPE_NIAGARA830 = 75,
+	CVMX_BOARD_TYPE_NIAGARA83X = 75,
 	CVMX_BOARD_TYPE_EBB7304 = 76,
 	CVMX_BOARD_TYPE_NIC73 = 77,	/* Liquid I/O */
-	CVMX_BOARD_TYPE_NIAGARA830_IM13166 = 78,
 	CVMX_BOARD_TYPE_NIC25E = 79,
+	CVMX_BOARD_TYPE_NIC225E = 80,
 	CVMX_BOARD_TYPE_MAX,
 	/* NOTE:  256-257 are being used by a customer. */
 
@@ -461,11 +461,11 @@ static inline const char *cvmx_board_type_to_string(enum cvmx_board_types_enum t
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_SWORDFISH)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_SFF7800)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_WAVE2)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIAGARA830)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIAGARA83X)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB7304)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC73)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIAGARA830_IM13166)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC25E)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC225E)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
 
 		/* Customer boards listed here */
diff --git a/arch/mips/include/asm/octeon/cvmx-ase-defs.h b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
index 9170c0a..874b64c 100644
--- a/arch/mips/include/asm/octeon/cvmx-ase-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_ASE_BACKDOOR_REQ_CTL CVMX_ASE_BACKDOOR_REQ_CTL_FUNC()
 static inline uint64_t CVMX_ASE_BACKDOOR_REQ_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_BACKDOOR_REQ_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD000800ull);
 }
@@ -67,6 +67,7 @@ static inline uint64_t CVMX_ASE_BACKDOOR_REQ_CTL_FUNC(void)
 static inline uint64_t CVMX_ASE_BACKDOOR_REQ_DATAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ASE_BACKDOOR_REQ_DATAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800DD000880ull) + ((offset) & 15) * 8;
@@ -78,7 +79,7 @@ static inline uint64_t CVMX_ASE_BACKDOOR_REQ_DATAX(unsigned long offset)
 #define CVMX_ASE_BACKDOOR_RSP_CTL CVMX_ASE_BACKDOOR_RSP_CTL_FUNC()
 static inline uint64_t CVMX_ASE_BACKDOOR_RSP_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_BACKDOOR_RSP_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD000900ull);
 }
@@ -89,6 +90,7 @@ static inline uint64_t CVMX_ASE_BACKDOOR_RSP_CTL_FUNC(void)
 static inline uint64_t CVMX_ASE_BACKDOOR_RSP_DATAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ASE_BACKDOOR_RSP_DATAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800DD000980ull) + ((offset) & 7) * 8;
@@ -100,7 +102,7 @@ static inline uint64_t CVMX_ASE_BACKDOOR_RSP_DATAX(unsigned long offset)
 #define CVMX_ASE_BIST_STATUS0 CVMX_ASE_BIST_STATUS0_FUNC()
 static inline uint64_t CVMX_ASE_BIST_STATUS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_BIST_STATUS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD000008ull);
 }
@@ -111,7 +113,7 @@ static inline uint64_t CVMX_ASE_BIST_STATUS0_FUNC(void)
 #define CVMX_ASE_BIST_STATUS1 CVMX_ASE_BIST_STATUS1_FUNC()
 static inline uint64_t CVMX_ASE_BIST_STATUS1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_BIST_STATUS1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD000010ull);
 }
@@ -122,7 +124,7 @@ static inline uint64_t CVMX_ASE_BIST_STATUS1_FUNC(void)
 #define CVMX_ASE_CONFIG CVMX_ASE_CONFIG_FUNC()
 static inline uint64_t CVMX_ASE_CONFIG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_CONFIG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD000100ull);
 }
@@ -133,7 +135,7 @@ static inline uint64_t CVMX_ASE_CONFIG_FUNC(void)
 #define CVMX_ASE_ECC_CTL CVMX_ASE_ECC_CTL_FUNC()
 static inline uint64_t CVMX_ASE_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD000018ull);
 }
@@ -144,7 +146,7 @@ static inline uint64_t CVMX_ASE_ECC_CTL_FUNC(void)
 #define CVMX_ASE_ECC_INT CVMX_ASE_ECC_INT_FUNC()
 static inline uint64_t CVMX_ASE_ECC_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_ECC_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD000028ull);
 }
@@ -155,7 +157,7 @@ static inline uint64_t CVMX_ASE_ECC_INT_FUNC(void)
 #define CVMX_ASE_GEN_INT CVMX_ASE_GEN_INT_FUNC()
 static inline uint64_t CVMX_ASE_GEN_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_GEN_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD000020ull);
 }
@@ -166,7 +168,7 @@ static inline uint64_t CVMX_ASE_GEN_INT_FUNC(void)
 #define CVMX_ASE_LIP_CONFIG CVMX_ASE_LIP_CONFIG_FUNC()
 static inline uint64_t CVMX_ASE_LIP_CONFIG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LIP_CONFIG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD400000ull);
 }
@@ -177,7 +179,7 @@ static inline uint64_t CVMX_ASE_LIP_CONFIG_FUNC(void)
 #define CVMX_ASE_LIP_SPARE CVMX_ASE_LIP_SPARE_FUNC()
 static inline uint64_t CVMX_ASE_LIP_SPARE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LIP_SPARE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD7FFFF8ull);
 }
@@ -188,7 +190,7 @@ static inline uint64_t CVMX_ASE_LIP_SPARE_FUNC(void)
 #define CVMX_ASE_LOP_CONFIG CVMX_ASE_LOP_CONFIG_FUNC()
 static inline uint64_t CVMX_ASE_LOP_CONFIG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LOP_CONFIG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD800000ull);
 }
@@ -199,7 +201,7 @@ static inline uint64_t CVMX_ASE_LOP_CONFIG_FUNC(void)
 #define CVMX_ASE_LOP_SPARE CVMX_ASE_LOP_SPARE_FUNC()
 static inline uint64_t CVMX_ASE_LOP_SPARE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LOP_SPARE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DDBFFFF8ull);
 }
@@ -210,7 +212,7 @@ static inline uint64_t CVMX_ASE_LOP_SPARE_FUNC(void)
 #define CVMX_ASE_LUE_CONFIG CVMX_ASE_LUE_CONFIG_FUNC()
 static inline uint64_t CVMX_ASE_LUE_CONFIG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LUE_CONFIG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DDC00000ull);
 }
@@ -221,7 +223,7 @@ static inline uint64_t CVMX_ASE_LUE_CONFIG_FUNC(void)
 #define CVMX_ASE_LUE_DBG_CTL0 CVMX_ASE_LUE_DBG_CTL0_FUNC()
 static inline uint64_t CVMX_ASE_LUE_DBG_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LUE_DBG_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DDC00030ull);
 }
@@ -232,7 +234,7 @@ static inline uint64_t CVMX_ASE_LUE_DBG_CTL0_FUNC(void)
 #define CVMX_ASE_LUE_DBG_CTL1 CVMX_ASE_LUE_DBG_CTL1_FUNC()
 static inline uint64_t CVMX_ASE_LUE_DBG_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LUE_DBG_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DDC00038ull);
 }
@@ -243,7 +245,7 @@ static inline uint64_t CVMX_ASE_LUE_DBG_CTL1_FUNC(void)
 #define CVMX_ASE_LUE_ERROR_LOG CVMX_ASE_LUE_ERROR_LOG_FUNC()
 static inline uint64_t CVMX_ASE_LUE_ERROR_LOG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LUE_ERROR_LOG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DDC00018ull);
 }
@@ -254,7 +256,7 @@ static inline uint64_t CVMX_ASE_LUE_ERROR_LOG_FUNC(void)
 #define CVMX_ASE_LUE_ERROR_LOG_ENABLE CVMX_ASE_LUE_ERROR_LOG_ENABLE_FUNC()
 static inline uint64_t CVMX_ASE_LUE_ERROR_LOG_ENABLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LUE_ERROR_LOG_ENABLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DDC00010ull);
 }
@@ -265,7 +267,7 @@ static inline uint64_t CVMX_ASE_LUE_ERROR_LOG_ENABLE_FUNC(void)
 #define CVMX_ASE_LUE_PERFORMANCE_CONTROL0 CVMX_ASE_LUE_PERFORMANCE_CONTROL0_FUNC()
 static inline uint64_t CVMX_ASE_LUE_PERFORMANCE_CONTROL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LUE_PERFORMANCE_CONTROL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DDC00060ull);
 }
@@ -276,7 +278,7 @@ static inline uint64_t CVMX_ASE_LUE_PERFORMANCE_CONTROL0_FUNC(void)
 #define CVMX_ASE_LUE_PERFORMANCE_CONTROL1 CVMX_ASE_LUE_PERFORMANCE_CONTROL1_FUNC()
 static inline uint64_t CVMX_ASE_LUE_PERFORMANCE_CONTROL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LUE_PERFORMANCE_CONTROL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DDC00068ull);
 }
@@ -287,6 +289,7 @@ static inline uint64_t CVMX_ASE_LUE_PERFORMANCE_CONTROL1_FUNC(void)
 static inline uint64_t CVMX_ASE_LUE_PERFORMANCE_CONTROLX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset >= 2) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset >= 2) && (offset <= 3))))))
 		cvmx_warn("CVMX_ASE_LUE_PERFORMANCE_CONTROLX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800DDC00070ull) + ((offset) & 3) * 8 - 8*2;
@@ -298,6 +301,7 @@ static inline uint64_t CVMX_ASE_LUE_PERFORMANCE_CONTROLX(unsigned long offset)
 static inline uint64_t CVMX_ASE_LUE_PERFORMANCE_COUNTERX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_ASE_LUE_PERFORMANCE_COUNTERX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800DDC00080ull) + ((offset) & 3) * 8;
@@ -309,7 +313,7 @@ static inline uint64_t CVMX_ASE_LUE_PERFORMANCE_COUNTERX(unsigned long offset)
 #define CVMX_ASE_LUE_PERF_FILT CVMX_ASE_LUE_PERF_FILT_FUNC()
 static inline uint64_t CVMX_ASE_LUE_PERF_FILT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LUE_PERF_FILT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DDC00040ull);
 }
@@ -320,7 +324,7 @@ static inline uint64_t CVMX_ASE_LUE_PERF_FILT_FUNC(void)
 #define CVMX_ASE_LUE_SPARE CVMX_ASE_LUE_SPARE_FUNC()
 static inline uint64_t CVMX_ASE_LUE_SPARE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LUE_SPARE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DDFFFFF8ull);
 }
@@ -331,7 +335,7 @@ static inline uint64_t CVMX_ASE_LUE_SPARE_FUNC(void)
 #define CVMX_ASE_LUE_TWE_BWE_ENABLE CVMX_ASE_LUE_TWE_BWE_ENABLE_FUNC()
 static inline uint64_t CVMX_ASE_LUE_TWE_BWE_ENABLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LUE_TWE_BWE_ENABLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DDC00008ull);
 }
@@ -342,7 +346,7 @@ static inline uint64_t CVMX_ASE_LUE_TWE_BWE_ENABLE_FUNC(void)
 #define CVMX_ASE_LUF_ERROR_LOG CVMX_ASE_LUF_ERROR_LOG_FUNC()
 static inline uint64_t CVMX_ASE_LUF_ERROR_LOG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_LUF_ERROR_LOG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD000110ull);
 }
@@ -353,7 +357,7 @@ static inline uint64_t CVMX_ASE_LUF_ERROR_LOG_FUNC(void)
 #define CVMX_ASE_SFT_RST CVMX_ASE_SFT_RST_FUNC()
 static inline uint64_t CVMX_ASE_SFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_SFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD000000ull);
 }
@@ -364,7 +368,7 @@ static inline uint64_t CVMX_ASE_SFT_RST_FUNC(void)
 #define CVMX_ASE_SPARE CVMX_ASE_SPARE_FUNC()
 static inline uint64_t CVMX_ASE_SPARE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ASE_SPARE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DD3FFFF8ull);
 }
@@ -389,8 +393,7 @@ union cvmx_ase_backdoor_req_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t valid                        : 1;  /**< Valid. Writing 1 triggers CNT beats to be sent as a packet into ASE. */
 	uint64_t reserved_4_62                : 59;
-	uint64_t cnt                          : 4;  /**< Number of DATA beats to send. Valid values are 0x2 - 0xB.
-                                                         INTERNAL: Value of 0x0 will send 16 beats. */
+	uint64_t cnt                          : 4;  /**< Number of DATA beats to send. Valid values are 0x2 - 0xB. */
 #else
 	uint64_t cnt                          : 4;
 	uint64_t reserved_4_62                : 59;
@@ -641,15 +644,13 @@ union cvmx_ase_ecc_ctl {
 	uint64_t reserved_54_63               : 10;
 	uint64_t lue_kdt_ecc_flip_synd        : 2;  /**< Flip syndrome in LUE RMC key data transfer buffer. */
 	uint64_t lue_rul_ecc_flip_synd        : 2;  /**< Flip syndrome in LUE RMC buffer aligner wrapper rule FIFO. */
-	uint64_t lue_rft_ecc_flip_synd        : 2;  /**< Flip syndrome in LUE HST and RMC rule format tables.
-                                                         INTERNAL: RFT replicated 5 times for timing purposes, controls all copies. */
+	uint64_t lue_rft_ecc_flip_synd        : 2;  /**< Flip syndrome in LUE HST and RMC rule format tables. */
 	uint64_t lue_tat_ecc_flip_synd        : 2;  /**< Flip syndrome in LUE HST ruleDB access table. */
 	uint64_t lue_kdb_ecc_flip_synd        : 2;  /**< Flip syndrome in LUE KRQ key data buffer. */
 	uint64_t reserved_37_43               : 7;
 	uint64_t lue_kdt_ecc_dis              : 1;  /**< Disable ECC for LUE RMC key data transfer buffer. */
 	uint64_t lue_rul_ecc_dis              : 1;  /**< Disable ECC for LUE RMC buffer aligner wrapper rule FIFO. */
-	uint64_t lue_rft_ecc_dis              : 1;  /**< Disable ECC for LUE HST and RMC rule format tables.
-                                                         INTERNAL: RFT replicated 5 times for timing purposes, controls all copies. */
+	uint64_t lue_rft_ecc_dis              : 1;  /**< Disable ECC for LUE HST and RMC rule format tables. */
 	uint64_t lue_tat_ecc_dis              : 1;  /**< Disable ECC for LUE HST ruleDB access table. */
 	uint64_t lue_kdb_ecc_dis              : 1;  /**< Disable ECC for LUE KRQ key data buffer. */
 	uint64_t reserved_26_31               : 6;
@@ -723,13 +724,9 @@ union cvmx_ase_ecc_int {
 	uint64_t lue_rul_sbe                  : 1;  /**< Detected and corrected single-bit error on LUE RMC buffer aligner wrapper rule FIFO. */
 	uint64_t reserved_38_39               : 2;
 	uint64_t lue_rft_dbe                  : 1;  /**< Detected double-bit error on LUE HST and RMC rule format tables. This bit is not set for
-                                                         software accesses to the RFT; it is only set for lookup accesses.
-                                                         INTERNAL: RFT replicated 5 times for timing purposes, this indicates error for any of the
-                                                         RFT. */
+                                                         software accesses to the RFT; it is only set for lookup accesses. */
 	uint64_t lue_rft_sbe                  : 1;  /**< Detected and corrected single-bit error on LUE HST and RMC rule format tables. This bit is
-                                                         not set for software accesses to the RFT; it only gets set for lookup accesses.
-                                                         INTERNAL: RFT replicated 5 times for timing purposes, this indicates error for any of the
-                                                         RFT. */
+                                                         not set for software accesses to the RFT; it only gets set for lookup accesses. */
 	uint64_t lue_tat_dbe                  : 1;  /**< Detected double-bit error on LUE HST ruleDB access table. This bit is not set for software
                                                          accesses to the TAT; it only gets set for lookup accesses. It is expected that error
                                                          recovery will
@@ -802,19 +799,16 @@ union cvmx_ase_gen_int {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_40_63               : 24;
 	uint64_t lue_rme_fatal                : 1;  /**< One or more of the lookup engines detected a fatal error. It is expected that error
-                                                         recovery will require resetting the ASE and loading corrected software into OSM.
-                                                         INTERNAL: 'Lookup engine' refers to 'Rule Match Engine.' */
+                                                         recovery will require resetting the ASE and loading corrected software into OSM. */
 	uint64_t lue_invalid_req              : 1;  /**< Insufficient key data was provided for a new lookup request. It is expected that error
-                                                         recovery will require resetting the ASE and loading corrected software into OSM.
-                                                         INTERNAL: The cause could also be a remote request or migration request. */
+                                                         recovery will require resetting the ASE and loading corrected software into OSM. */
 	uint64_t lue_hr_err_log               : 1;  /**< An error occurred for a host request and generated a host response with error. */
 	uint64_t reserved_35_36               : 2;
 	uint64_t lue_tic_bad_write            : 1;  /**< A data load to the TIC was prevented that would have caused a wrap condition. Either the
                                                          TAT row pointed
                                                          to by the TIC entry was invalid, or the starting TAT row and the increment value pointed
                                                          beyond the end of the TAT. It is expected that error recovery will require loading
-                                                         correct software into the TIC.
-                                                         INTERNAL: Hardware will never set this bit in Pass 1.x. */
+                                                         correct software into the TIC. */
 	uint64_t lue_tic_multi_hit            : 1;  /**< A TIC lookup request resulted in multiple entries reporting a hit. It is expected that
                                                          error recovery will require resetting the ASE and loading corrected software into the TIC. */
 	uint64_t lue_tic_miss                 : 1;  /**< A TIC lookup request did not match a valid entry. It is expected that error recovery will
@@ -875,8 +869,7 @@ union cvmx_ase_lip_config {
 	struct cvmx_ase_lip_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t drop_xoff_en                 : 1;  /**< This feature should remain disabled.
-                                                         INTERNAL: Keep disabled, bug 18665. */
+	uint64_t drop_xoff_en                 : 1;  /**< This feature should remain disabled. */
 	uint64_t gen_xon_en                   : 1;  /**< If enabled, the LIP generates XON indication to the LAP when lookup requests are
                                                          backpressured. If disabled, the LIP does not assert XON. */
 	uint64_t reserved_1_1                 : 1;
@@ -932,10 +925,11 @@ union cvmx_ase_lop_config {
                                                          <6> = LUF table response.
                                                          <5> = LUE table response.
                                                          <4> = OSM write/read response.
-                                                         There are two priority levels per response type: 1 = higher priority;
-                                                         0 = lower priority. Round robin is used among the responses with higher priority to send
+                                                         There are two priority levels per response type:
+                                                         0 = Lower priority. Round robin is used among the responses with higher priority to send
                                                          back to the LAP or CSR. When there is no response with higher priority left, round robin
-                                                         is used to choose a response with lower priority to send back to LAP or CSR. */
+                                                         is used to choose a response with lower priority to send back to LAP or CSR.
+                                                         1 = Higher priority. */
 	uint64_t reserved_1_3                 : 3;
 	uint64_t rsp_dis                      : 1;  /**< If set, the LOP does not send response(s) to the LAP/CSR. It is only used for diagnosis
                                                          purposes. For example, it can be used to build up backpressure to LUE/LIP/LAP/OSM. In
@@ -1057,10 +1051,10 @@ union cvmx_ase_lue_dbg_ctl0 {
 	uint64_t reserved_2_7                 : 6;
 	uint64_t ctx_src_dbg                  : 2;  /**< Engine type from which context information will be made available in the ASE_LUE_CTX debug
                                                          field.
-                                                         0 = Tree Walk Engine
-                                                         1 = Bucket Walk Engine
-                                                         2 = Rule Walk Engine
-                                                         3 = Reserved */
+                                                         0 = Tree walk engine.
+                                                         1 = Bucket walk engine.
+                                                         2 = Rule walk engine.
+                                                         3 = Reserved. */
 #else
 	uint64_t ctx_src_dbg                  : 2;
 	uint64_t reserved_2_7                 : 6;
@@ -1340,12 +1334,9 @@ union cvmx_ase_lue_performance_controlx {
                                                          0x1 = Neg Edge.
                                                          0x2 = Level.
                                                          0x3 = One shot. */
-	uint64_t sel2                         : 8;  /**< Performance counter event select, third mux.
-                                                         INTERNAL: For details of mapping of events to selects, see lue.perf. */
-	uint64_t sel1                         : 8;  /**< Performance counter event select, second mux.
-                                                         INTERNAL: For details of mapping of events to selects, see lue.perf. */
-	uint64_t sel0                         : 8;  /**< Performance counter event select, first mux.
-                                                         INTERNAL: For details of mapping of events to selects, see lue.perf. */
+	uint64_t sel2                         : 8;  /**< Performance counter event select, third mux. */
+	uint64_t sel1                         : 8;  /**< Performance counter event select, second mux. */
+	uint64_t sel0                         : 8;  /**< Performance counter event select, first mux. */
 #else
 	uint64_t sel0                         : 8;
 	uint64_t sel1                         : 8;
@@ -1391,12 +1382,9 @@ union cvmx_ase_lue_performance_control0 {
                                                          0x1 = Neg edge.
                                                          0x2 = Level.
                                                          0x3 = One shot. */
-	uint64_t sel2                         : 8;  /**< Performance counter event select, third mux.
-                                                         INTERNAL: For details of mapping of events to selects, see lue.perf. */
-	uint64_t sel1                         : 8;  /**< Performance counter event select, second mux.
-                                                         INTERNAL: For details of mapping of events to selects, see lue.perf. */
-	uint64_t sel0                         : 8;  /**< Performance counter event select, first mux.
-                                                         INTERNAL: For details of mapping of events to selects, see lue.perf. */
+	uint64_t sel2                         : 8;  /**< Performance counter event select, third mux. */
+	uint64_t sel1                         : 8;  /**< Performance counter event select, second mux. */
+	uint64_t sel0                         : 8;  /**< Performance counter event select, first mux. */
 #else
 	uint64_t sel0                         : 8;
 	uint64_t sel1                         : 8;
@@ -1438,19 +1426,16 @@ union cvmx_ase_lue_performance_control1 {
 	uint64_t reserved_27_27               : 1;
 	uint64_t mode                         : 3;  /**< Performance counter mode.
                                                          Bit<24>:
-                                                         1 = Event counted SEL0 | SEL1 | SEL2
-                                                         0 = Event counted SEL0 & SEL1 & SEL2
+                                                         1 = Event counted SEL0 | SEL1 | SEL2.
+                                                         0 = Event counted SEL0 & SEL1 & SEL2.
                                                          Bits<26:25>:
                                                          0x0 = Pos Edge.
                                                          0x1 = Neg Edge.
                                                          0x2 = Level.
                                                          0x3 = One shot. */
-	uint64_t sel2                         : 8;  /**< Performance counter event select, third mux.
-                                                         INTERNAL: For details of mapping of events to selects, see lue.perf. */
-	uint64_t sel1                         : 8;  /**< Performance counter event select, second mux.
-                                                         INTERNAL: For details of mapping of events to selects, see lue.perf. */
-	uint64_t sel0                         : 8;  /**< Performance counter event select, first mux.
-                                                         INTERNAL: For details of mapping of events to selects, see lue.perf. */
+	uint64_t sel2                         : 8;  /**< Performance counter event select, third mux. */
+	uint64_t sel1                         : 8;  /**< Performance counter event select, second mux. */
+	uint64_t sel0                         : 8;  /**< Performance counter event select, first mux. */
 #else
 	uint64_t sel0                         : 8;
 	uint64_t sel1                         : 8;
diff --git a/arch/mips/include/asm/octeon/cvmx-bch-defs.h b/arch/mips/include/asm/octeon/cvmx-bch-defs.h
index ea834ee..bf3a6b0 100644
--- a/arch/mips/include/asm/octeon/cvmx-bch-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bch-defs.h
@@ -336,7 +336,7 @@ union cvmx_bch_eco {
 	struct cvmx_bch_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 32; /**< N/A */
 #else
 	uint64_t eco_rw                       : 32;
 	uint64_t reserved_32_63               : 32;
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index 9f51164e..826767e 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -57,6 +57,7 @@ static inline uint64_t CVMX_BGXX_CMRX_CONFIG(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_CONFIG(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -70,6 +71,7 @@ static inline uint64_t CVMX_BGXX_CMRX_INT(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -83,6 +85,7 @@ static inline uint64_t CVMX_BGXX_CMRX_PRT_CBFC_CTL(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_PRT_CBFC_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -96,6 +99,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_ADR_CTL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_ADR_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -109,6 +113,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_DROP(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_DROP(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -122,6 +127,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_OFF(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_OFF(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -135,6 +141,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_ON(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_ON(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -148,6 +155,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_BP_STATUS(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_BP_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -161,6 +169,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_FIFO_LEN(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_FIFO_LEN(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -174,6 +183,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_ID_MAP(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_ID_MAP(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -187,6 +197,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XOFF(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_LOGL_XOFF(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -200,6 +211,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_LOGL_XON(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_LOGL_XON(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -213,6 +225,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_PAUSE_DROP_TIME(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_PAUSE_DROP_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -226,6 +239,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT0(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT0(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -239,6 +253,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT1(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -252,6 +267,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT2(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -265,6 +281,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT3(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT3(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -278,6 +295,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT4(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT4(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -291,6 +309,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT5(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT5(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -304,6 +323,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT6(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT6(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -317,6 +337,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT7(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT7(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -330,6 +351,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_STAT8(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_STAT8(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -343,6 +365,7 @@ static inline uint64_t CVMX_BGXX_CMRX_RX_WEIGHT(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_RX_WEIGHT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -356,6 +379,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_CHANNEL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_CHANNEL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -369,6 +393,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_FIFO_LEN(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_FIFO_LEN(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -382,6 +407,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_HG2_STATUS(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_HG2_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -395,6 +421,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_OVR_BP(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_OVR_BP(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -408,6 +435,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT0(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT0(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -421,6 +449,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT1(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -434,6 +463,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT10(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT10(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -447,6 +477,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT11(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT11(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -460,6 +491,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT12(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT12(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -473,6 +505,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT13(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT13(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -486,6 +519,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT14(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT14(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -499,6 +533,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT15(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT15(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -512,6 +547,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT16(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT16(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -525,6 +561,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT17(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT17(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -538,6 +575,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT2(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -551,6 +589,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT3(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT3(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -564,6 +603,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT4(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT4(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -577,6 +617,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT5(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT5(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -590,6 +631,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT6(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT6(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -603,6 +645,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT7(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT7(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -616,6 +659,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT8(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT8(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -629,6 +673,7 @@ static inline uint64_t CVMX_BGXX_CMRX_TX_STAT9(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMRX_TX_STAT9(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -642,6 +687,7 @@ static inline uint64_t CVMX_BGXX_CMR_BAD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_BAD(%lu) is invalid on this chip\n", offset);
@@ -655,6 +701,7 @@ static inline uint64_t CVMX_BGXX_CMR_BIST_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_BIST_STATUS(%lu) is invalid on this chip\n", offset);
@@ -668,6 +715,7 @@ static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_AND(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_CHAN_MSK_AND(%lu) is invalid on this chip\n", offset);
@@ -681,6 +729,7 @@ static inline uint64_t CVMX_BGXX_CMR_CHAN_MSK_OR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_CHAN_MSK_OR(%lu) is invalid on this chip\n", offset);
@@ -707,6 +756,7 @@ static inline uint64_t CVMX_BGXX_CMR_GLOBAL_CONFIG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_GLOBAL_CONFIG(%lu) is invalid on this chip\n", offset);
@@ -720,6 +770,7 @@ static inline uint64_t CVMX_BGXX_CMR_MEM_CTRL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_MEM_CTRL(%lu) is invalid on this chip\n", offset);
@@ -733,6 +784,7 @@ static inline uint64_t CVMX_BGXX_CMR_MEM_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_MEM_INT(%lu) is invalid on this chip\n", offset);
@@ -746,6 +798,7 @@ static inline uint64_t CVMX_BGXX_CMR_NXC_ADR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_NXC_ADR(%lu) is invalid on this chip\n", offset);
@@ -759,6 +812,7 @@ static inline uint64_t CVMX_BGXX_CMR_RX_ADRX_CAM(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 31)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 31)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 31)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 31)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_CMR_RX_ADRX_CAM(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -772,6 +826,7 @@ static inline uint64_t CVMX_BGXX_CMR_RX_LMACS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_RX_LMACS(%lu) is invalid on this chip\n", offset);
@@ -785,6 +840,7 @@ static inline uint64_t CVMX_BGXX_CMR_RX_OVR_BP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_RX_OVR_BP(%lu) is invalid on this chip\n", offset);
@@ -798,6 +854,7 @@ static inline uint64_t CVMX_BGXX_CMR_TX_LMACS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_CMR_TX_LMACS(%lu) is invalid on this chip\n", offset);
@@ -811,6 +868,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_PRTX_CFG(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_PRTX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -824,6 +882,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_DECISION(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_DECISION(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -837,6 +896,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CHK(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_FRM_CHK(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -850,6 +910,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -863,6 +924,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_IFG(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_IFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -876,6 +938,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_INT(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -889,6 +952,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_JABBER(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_JABBER(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -902,6 +966,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_RXX_UDD_SKP(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_RXX_UDD_SKP(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -915,6 +980,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_SMACX(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_SMACX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -928,6 +994,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_APPEND(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_APPEND(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -941,6 +1008,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_BURST(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_BURST(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -954,6 +1022,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_CTL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -967,6 +1036,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_INT(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -980,6 +1050,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_MIN_PKT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -993,6 +1064,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(unsigned long of
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1006,6 +1078,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(unsigned long offset
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1019,6 +1092,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_TOGO(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_TOGO(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1032,6 +1106,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_PAUSE_ZERO(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_PAUSE_ZERO(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1045,6 +1120,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(unsigned long offset, uns
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SGMII_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1058,6 +1134,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SLOT(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SLOT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1071,6 +1148,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_SOFT_PAUSE(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_SOFT_PAUSE(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1084,6 +1162,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TXX_THRESH(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TXX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1097,6 +1176,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_COL_ATTEMPT(%lu) is invalid on this chip\n", offset);
@@ -1110,6 +1190,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_IFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_IFG(%lu) is invalid on this chip\n", offset);
@@ -1123,6 +1204,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_JAM(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_JAM(%lu) is invalid on this chip\n", offset);
@@ -1136,6 +1218,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_LFSR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_LFSR(%lu) is invalid on this chip\n", offset);
@@ -1149,6 +1232,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(%lu) is invalid on this chip\n", offset);
@@ -1162,6 +1246,7 @@ static inline uint64_t CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(%lu) is invalid on this chip\n", offset);
@@ -1175,6 +1260,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_ADV(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1188,6 +1274,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_EXT_ST(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_EXT_ST(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1201,6 +1288,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_LP_ABIL(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_LP_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1214,6 +1302,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_ANX_RESULTS(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_ANX_RESULTS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1227,6 +1316,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_INTX(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_INTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1240,6 +1330,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_LINKX_TIMER(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_LINKX_TIMER(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1253,6 +1344,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MISCX_CTL(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MISCX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1266,6 +1358,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_CONTROL(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MRX_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1279,6 +1372,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_MRX_STATUS(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_MRX_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1292,6 +1386,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_STATES(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_RXX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1305,6 +1400,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_RXX_SYNC(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_RXX_SYNC(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1318,6 +1414,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_SGMX_AN_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1331,6 +1428,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_SGMX_LP_ADV(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_SGMX_LP_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1344,6 +1442,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_TXX_STATES(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_TXX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1357,6 +1456,7 @@ static inline uint64_t CVMX_BGXX_GMP_PCS_TX_RXX_POLARITY(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_GMP_PCS_TX_RXX_POLARITY(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1370,6 +1470,7 @@ static inline uint64_t CVMX_BGXX_SMUX_CBFC_CTL(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_CBFC_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1383,6 +1484,7 @@ static inline uint64_t CVMX_BGXX_SMUX_CTRL(unsigned long offset, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1396,6 +1498,7 @@ static inline uint64_t CVMX_BGXX_SMUX_EXT_LOOPBACK(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_EXT_LOOPBACK(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1409,6 +1512,7 @@ static inline uint64_t CVMX_BGXX_SMUX_HG2_CONTROL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_HG2_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1422,6 +1526,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_HI(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_BAD_COL_HI(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1435,6 +1540,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_BAD_COL_LO(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_BAD_COL_LO(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1448,6 +1554,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_CTL(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1461,6 +1568,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_DECISION(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_DECISION(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1474,6 +1582,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CHK(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_FRM_CHK(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1487,6 +1596,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_FRM_CTL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_FRM_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1500,6 +1610,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_INT(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1513,6 +1624,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_JABBER(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_JABBER(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1526,6 +1638,7 @@ static inline uint64_t CVMX_BGXX_SMUX_RX_UDD_SKP(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_RX_UDD_SKP(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1539,6 +1652,7 @@ static inline uint64_t CVMX_BGXX_SMUX_SMAC(unsigned long offset, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_SMAC(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1552,6 +1666,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_APPEND(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_APPEND(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1565,6 +1680,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_CTL(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1578,6 +1694,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_IFG(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_IFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1591,6 +1708,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_INT(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1604,6 +1722,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_MIN_PKT(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_MIN_PKT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1617,6 +1736,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_DMAC(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_DMAC(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1630,6 +1750,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_INTERVAL(unsigned long offset
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_INTERVAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1643,6 +1764,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TIME(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_TIME(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1656,6 +1778,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_PKT_TYPE(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_PKT_TYPE(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1669,6 +1792,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_TOGO(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_TOGO(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1682,6 +1806,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_PAUSE_ZERO(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_PAUSE_ZERO(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1695,6 +1820,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_SOFT_PAUSE(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_SOFT_PAUSE(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1708,6 +1834,7 @@ static inline uint64_t CVMX_BGXX_SMUX_TX_THRESH(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SMUX_TX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1721,6 +1848,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_ADV(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_ADV(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1734,6 +1862,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_BP_STATUS(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_BP_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1747,6 +1876,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_CONTROL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1760,6 +1890,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_LP_BASE(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_LP_BASE(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1773,6 +1904,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_LP_XNP(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_LP_XNP(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1786,6 +1918,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_STATUS(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1799,6 +1932,7 @@ static inline uint64_t CVMX_BGXX_SPUX_AN_XNP_TX(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_AN_XNP_TX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1812,6 +1946,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_ALGN_STATUS(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_ALGN_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1825,6 +1960,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_BIP_ERR_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1838,6 +1974,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_LANE_MAP(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_LANE_MAP(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1851,6 +1988,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_CONTROL(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1864,6 +2002,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_CUP(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LD_CUP(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1877,6 +2016,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LD_REP(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LD_REP(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1890,6 +2030,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_CUP(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LP_CUP(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1903,6 +2044,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_LP_REP(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_LP_REP(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1916,6 +2058,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_PMD_STATUS(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_PMD_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1929,6 +2072,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS1(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_STATUS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1942,6 +2086,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_STATUS2(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_STATUS2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1955,6 +2100,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_TP_CONTROL(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_TP_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1968,6 +2114,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BR_TP_ERR_CNT(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BR_TP_ERR_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1981,6 +2128,7 @@ static inline uint64_t CVMX_BGXX_SPUX_BX_STATUS(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_BX_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1994,6 +2142,7 @@ static inline uint64_t CVMX_BGXX_SPUX_CONTROL1(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_CONTROL1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2007,6 +2156,7 @@ static inline uint64_t CVMX_BGXX_SPUX_CONTROL2(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_CONTROL2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2020,6 +2170,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_ABIL(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2033,6 +2184,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CONTROL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2046,6 +2198,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS01(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CORR_BLKS01(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2059,6 +2212,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_CORR_BLKS23(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_CORR_BLKS23(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2072,6 +2226,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS01(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_UNCORR_BLKS01(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2085,6 +2240,7 @@ static inline uint64_t CVMX_BGXX_SPUX_FEC_UNCORR_BLKS23(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_FEC_UNCORR_BLKS23(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2098,6 +2254,7 @@ static inline uint64_t CVMX_BGXX_SPUX_INT(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2111,6 +2268,7 @@ static inline uint64_t CVMX_BGXX_SPUX_LPCS_STATES(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_LPCS_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2124,6 +2282,7 @@ static inline uint64_t CVMX_BGXX_SPUX_MISC_CONTROL(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_MISC_CONTROL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2137,6 +2296,7 @@ static inline uint64_t CVMX_BGXX_SPUX_SPD_ABIL(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_SPD_ABIL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2150,6 +2310,7 @@ static inline uint64_t CVMX_BGXX_SPUX_STATUS1(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_STATUS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2163,6 +2324,7 @@ static inline uint64_t CVMX_BGXX_SPUX_STATUS2(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPUX_STATUS2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2176,6 +2338,7 @@ static inline uint64_t CVMX_BGXX_SPU_BIST_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_SPU_BIST_STATUS(%lu) is invalid on this chip\n", offset);
@@ -2189,6 +2352,7 @@ static inline uint64_t CVMX_BGXX_SPU_DBG_CONTROL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_SPU_DBG_CONTROL(%lu) is invalid on this chip\n", offset);
@@ -2202,6 +2366,7 @@ static inline uint64_t CVMX_BGXX_SPU_MEM_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_SPU_MEM_INT(%lu) is invalid on this chip\n", offset);
@@ -2215,6 +2380,7 @@ static inline uint64_t CVMX_BGXX_SPU_MEM_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_BGXX_SPU_MEM_STATUS(%lu) is invalid on this chip\n", offset);
@@ -2228,6 +2394,7 @@ static inline uint64_t CVMX_BGXX_SPU_SDSX_SKEW_STATUS(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPU_SDSX_SKEW_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2241,6 +2408,7 @@ static inline uint64_t CVMX_BGXX_SPU_SDSX_STATES(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_BGXX_SPU_SDSX_STATES(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2257,44 +2425,6 @@ static inline uint64_t CVMX_BGXX_SPU_SDSX_STATES(unsigned long offset, unsigned
  * maximum LMAC ID) that can be enabled by these registers is limited by
  * BGX()_CMR_RX_LMACS[LMACS] and BGX()_CMR_TX_LMACS[LMACS]. When multiple LMACs are
  * enabled, they must be configured with the same [LMAC_TYPE] value.
- *
- * INTERNAL:
- * <pre>
- * Typical configurations:
- *   ---------------------------------------------------------------------------
- *   Configuration           LMACS  Register             [ENABLE]    [LMAC_TYPE]
- *   ---------------------------------------------------------------------------
- *   1x40GBASE-R4            1      BGXn_CMR0_CONFIG     1           4
- *                                  BGXn_CMR1_CONFIG     0           --
- *                                  BGXn_CMR2_CONFIG     0           --
- *                                  BGXn_CMR3_CONFIG     0           --
- *   ---------------------------------------------------------------------------
- *   4x10GBASE-R             4      BGXn_CMR0_CONFIG     1           3
- *                                  BGXn_CMR1_CONFIG     1           3
- *                                  BGXn_CMR2_CONFIG     1           3
- *                                  BGXn_CMR3_CONFIG     1           3
- *   ---------------------------------------------------------------------------
- *   2xRXAUI                 2      BGXn_CMR0_CONFIG     1           2
- *                                  BGXn_CMR1_CONFIG     1           2
- *                                  BGXn_CMR2_CONFIG     0           --
- *                                  BGXn_CMR3_CONFIG     0           --
- *   ---------------------------------------------------------------------------
- *   1x10GBASE-X/XAUI/DXAUI  1      BGXn_CMR0_CONFIG     1           1
- *                                  BGXn_CMR1_CONFIG     0           --
- *                                  BGXn_CMR2_CONFIG     0           --
- *                                  BGXn_CMR3_CONFIG     0           --
- *   ---------------------------------------------------------------------------
- *   4xSGMII/1000BASE-X      4      BGXn_CMR0_CONFIG     1           0
- *                                  BGXn_CMR1_CONFIG     1           0
- *                                  BGXn_CMR2_CONFIG     1           0
- *                                  BGXn_CMR3_CONFIG     1           0
- *   ---------------------------------------------------------------------------
- *   3xSGMIII/1000BASE-X     4      BGXn_CMR0_CONFIG     1           5
- *   + 1xRGMII                      BGXn_CMR1_CONFIG     1           0
- *                                  BGXn_CMR2_CONFIG     1           0
- *                                  BGXn_CMR3_CONFIG     1           0
- *   ---------------------------------------------------------------------------
- * </pre>
  */
 union cvmx_bgxx_cmrx_config {
 	uint64_t u64;
@@ -3083,8 +3213,8 @@ union cvmx_bgxx_cmrx_tx_ovr_bp {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t tx_chan_bp                   : 16; /**< Per-channel backpressure status sent to PKO.
-                                                         0 = channel is available.
-                                                         1 = channel should be backpressured. */
+                                                         0 = Channel is available.
+                                                         1 = Channel is backpressured. */
 #else
 	uint64_t tx_chan_bp                   : 16;
 	uint64_t reserved_16_63               : 48;
@@ -3584,24 +3714,8 @@ union cvmx_bgxx_cmr_bist_status {
 	struct cvmx_bgxx_cmr_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
-	uint64_t status                       : 25; /**< "BIST results. Hardware sets a bit to 1 for memory that fails; 0 indicates pass or never
-                                                         run. INTERNAL:
-                                                         <0> = bgx#.rxb.infif_gmp
-                                                         <1> = bgx#.rxb.infif_smu
-                                                         <2> = bgx#.rxb.fif_bnk00
-                                                         <3> = bgx#.rxb.fif_bnk01
-                                                         <4> = bgx#.rxb.fif_bnk10
-                                                         <5> = bgx#.rxb.fif_bnk11
-                                                         <6> = bgx#.rxb.skd_fif
-                                                         <7> = bgx#.rxb_mix0_fif
-                                                         <8> = bgx#.rxb_mix1_fif
-                                                         <9> = RAZ
-                                                         <10> = bgx#.txb_fif_bnk0
-                                                         <11> = bgx#.txb_fif_bnk1
-                                                         <12> = bgx#.txb_skd_fif
-                                                         <13> = bgx#.txb_mix0_fif
-                                                         <14> = bgx#.txb_mix1_fif
-                                                         <24:15> = RAZ" */
+	uint64_t status                       : 25; /**< '"BIST results. Hardware sets a bit to 1 for memory that fails; 0 indicates pass or never
+                                                         run.' */
 #else
 	uint64_t status                       : 25;
 	uint64_t reserved_25_63               : 39;
@@ -3677,8 +3791,8 @@ union cvmx_bgxx_cmr_eco {
 	uint64_t u64;
 	struct cvmx_bgxx_cmr_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t eco_ro                       : 32; /**< INTERNAL: Reserved for ECO usage. */
-	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_ro                       : 32; /**< N/A */
+	uint64_t eco_rw                       : 32; /**< N/A */
 #else
 	uint64_t eco_rw                       : 32;
 	uint64_t eco_ro                       : 32;
@@ -3879,7 +3993,7 @@ union cvmx_bgxx_cmr_rx_adrx_cam {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
 	uint64_t id                           : 2;  /**< Logical MAC ID that this DMAC CAM address applies to. BGX has 32 DMAC CAM entries that can
-                                                         be accessed with the BGX*_CMR_RX_ADR_CAM() CSRs. These 32 DMAC entries can be used by
+                                                         be accessed with the BGX()_CMR_RX_ADR_CAM() CSRs. These 32 DMAC entries can be used by
                                                          any of the four SGMII MACs or the 10G/40G MACs using these register bits.
                                                          A typical configuration is to provide eight CAM entries per LMAC ID, which is configured
                                                          using the following settings:
@@ -4034,11 +4148,11 @@ union cvmx_bgxx_gmp_gmi_prtx_cfg {
 	uint64_t reserved_4_7                 : 4;
 	uint64_t slottime                     : 1;  /**< Slot time for half-duplex operation
                                                          (SGMII/1000Base-X only):
-                                                         0 = 512 bit times (10/100 Mb/s operation)
-                                                         1 = 4096 bit times (1000 Mb/s operation) */
+                                                         0 = 512 bit times (10/100 Mb/s operation).
+                                                         1 = 4096 bit times (1000 Mb/s operation). */
 	uint64_t duplex                       : 1;  /**< Duplex mode
                                                          (SGMII/1000Base-X only):
-                                                         0 = half-duplex (collisions/extensions/bursts):
+                                                         0 = half-duplex (collisions/extensions/bursts).
                                                          1 = full-duplex. */
 	uint64_t speed                        : 1;  /**< Link Speed LSB (SGMII/1000Base-X only):
                                                          _ [SPEED_MSB:SPEED] = 0x0: 100 Mb/s operation.
@@ -4074,28 +4188,6 @@ typedef union cvmx_bgxx_gmp_gmi_prtx_cfg cvmx_bgxx_gmp_gmi_prtx_cfg_t;
  * BGX()_GMP_GMI_RX()_DECISION[CNT]. In normal operation, the L2 header begins after the
  * PREAMBLE + SFD (BGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] = 1) and any optional UDD skip
  * data (BGX()_GMP_GMI_RX()_UDD_SKP[LEN]).
- *
- * INTERNAL: Notes:
- * As each byte in a packet is received by GMI, the L2 byte count is compared
- * against the BGX()_GMP_GMI_RX()_DECISION[CNT].  The L2 byte count is the number of bytes
- * from the beginning of the L2 header (DMAC).  In normal operation, the L2
- * header begins after the PREAMBLE+SFD (BGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]=1) and any
- * optional UDD skip data (BGX()_GMP_GMI_RX()_UDD_SKP[LEN]).
- * When BGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear, PREAMBLE+SFD are prepended to the
- * packet and would require UDD skip length to account for them.
- *
- * Full Duplex:
- * _   L2 Size <  BGX_RX_DECISION - Accept packet. No filtering is applied.
- * _   L2 Size >= BGX_RX_DECISION - Apply filter. Accept packet based on PAUSE packet filter.
- *
- * Half Duplex:
- * _   L2 Size <  BGX_RX_DECISION - Drop packet. Packet is unconditionally dropped.
- * _   L2 Size >= BGX_RX_DECISION - Accept packet.
- *
- * where L2_size = MAX(0, total_packet_size - BGX()_GMP_GMI_RX()_UDD_SKP[LEN] -
- *                        ((BGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]==1)*8))
- *
- * BGX()_GMP_GMI_RX()_DECISION = The byte count to decide when to accept or filter a packet.
  */
 union cvmx_bgxx_gmp_gmi_rxx_decision {
 	uint64_t u64;
@@ -4163,16 +4255,6 @@ typedef union cvmx_bgxx_gmp_gmi_rxx_frm_chk cvmx_bgxx_gmp_gmi_rxx_frm_chk_t;
  * These control bits should be set to CTL_BCK = 0,CTL_DRP = 0 in half-duplex mode. Since PAUSE
  * packets only apply to full duplex operation, any PAUSE packet would constitute an exception
  * which should be handled by the processing cores. PAUSE packets should not be forwarded.
- *
- * INTERNAL: Notes:
- * PRE_STRP
- * When PRE_CHK is set (indicating that the PREAMBLE will be sent), PRE_STRP
- * determines if the PREAMBLE+SFD bytes are thrown away or sent to the Octane
- * core as part of the packet.
- * In either mode, the PREAMBLE+SFD bytes are not counted toward the packet
- * size when checking against the MIN and MAX bounds.  Furthermore, the bytes
- * are skipped when locating the start of the L2 header for DMAC and Control
- * frame recognition.
  */
 union cvmx_bgxx_gmp_gmi_rxx_frm_ctl {
 	uint64_t u64;
@@ -4279,69 +4361,12 @@ typedef union cvmx_bgxx_gmp_gmi_rxx_ifg cvmx_bgxx_gmp_gmi_rxx_ifg_t;
 /**
  * cvmx_bgx#_gmp_gmi_rx#_int
  *
- * "These registers allow interrupts to be sent to the control processor.
+ * '"These registers allow interrupts to be sent to the control processor.
  * * Exception conditions <10:0> can also set the rcv/opcode in the received packet's work-queue
  * entry. BGX()_GMP_GMI_RX()_FRM_CHK provides a bit mask for configuring which conditions
  * set the error.
  * In half duplex operation, the expectation is that collisions will appear as either MINERR or
- * CAREXT errors.
- *
- * INTERNAL: Notes:
- * (2) exception conditions 10:0 can also set the rcv/opcode in the received
- * packet's workQ entry.  The BGX()_GMP_GMI_RX()_FRM_CHK register provides a bit mask
- * for configuring which conditions set the error.
- *
- * (3) in half duplex operation, the expectation is that collisions will appear
- * as either MINERR o r CAREXT errors.
- *
- * (4) JABBER An RX Jabber error indicates that a packet was received which
- * is longer than the maximum allowed packet as defined by the
- * system.  GMI will truncate the packet at the JABBER count.
- * Failure to do so could lead to system instabilty.
- *
- * (5) NIBERR This error is illegal at 1000Mbs speeds
- * (BGX()_GMP_GMI_RX()_PRT_CFG[SPEED]==0) and will never assert.
- *
- * (6) MAXERR for untagged frames, the total frame DA+SA+TL+DATA+PAD+FCS >
- * BGX()_GMP_GMI_RX()_FRM_MAX.  For tagged frames, DA+SA+VLAN+TL+DATA+PAD+FCS
- * > BGX()_GMP_GMI_RX()_FRM_MAX + 4*VLAN_VAL + 4*VLAN_STACKED.
- *
- * (7) MINERR total frame DA+SA+TL+DATA+PAD+FCS < 64
- *
- * (8) ALNERR Indicates that the packet received was not an integer number of
- * bytes.  If FCS checking is enabled, ALNERR will only assert if
- * the FCS is bad.  If FCS checking is disabled, ALNERR will
- * assert in all non-integer frame cases.
- *
- * (9) Collisions Collisions can only occur in half-duplex mode.  A collision
- * is assumed by the receiver when the slottime
- * (BGX()_GMP_GMI_PRT_CFG[SLOTTIME]) is not satisfied.  In 10/100 mode,
- * this will result in a frame < SLOTTIME.  In 1000 mode, it
- * could result either in frame < SLOTTIME or a carrier extend
- * error with the SLOTTIME.  These conditions are visible by...
- * . transfer ended before slottime COLDET
- * . carrier extend error           CAREXT
- *
- * (A) LENERR Length errors occur when the received packet does not match the
- * length field.  LENERR is only checked for packets between 64
- * and 1500 bytes.  For untagged frames, the length must exact
- * match.  For tagged frames the length or length+4 must match.
- *
- * (B) PCTERR checks that the frame begins with a valid PREAMBLE sequence.
- * Does not check the number of PREAMBLE cycles.
- *
- * (C) OVRERR
- * OVRERR is an architectural assertion check internal to GMI to
- * make sure no assumption was violated.  In a correctly operating
- * system, this interrupt can never fire.
- * GMI has an internal arbiter which selects which of 4 ports to
- * buffer in the main RX FIFO.  If we normally buffer 8 bytes,
- * then each port will typically push a tick every 8 cycles if
- * the packet interface is going as fast as possible.  If there
- * are four ports, they push every two cycles.  So that's the
- * assumption.  That the inbound module will always be able to
- * consume the tick before another is produced.  If that doesn't
- * happen that's when OVRERR will assert."
+ * CAREXT errors.'
  */
 union cvmx_bgxx_gmp_gmi_rxx_int {
 	uint64_t u64;
@@ -4425,30 +4450,6 @@ typedef union cvmx_bgxx_gmp_gmi_rxx_jabber cvmx_bgxx_gmp_gmi_rxx_jabber_t;
  *
  * This register specifies the amount of user-defined data (UDD) added before the start of the
  * L2C data.
- *
- * INTERNAL: Notes:
- * (1) The skip bytes are part of the packet and will be sent down the NCB
- * packet interface and will be handled by PKI.
- *
- * (2) The system can determine if the UDD bytes are included in the FCS check
- * by using the FCSSEL field - if the FCS check is enabled.
- *
- * (3) Assume that the preamble/sfd is always at the start of the frame - even
- * before UDD bytes.  In most cases, there will be no preamble in these
- * cases since it will be packet interface in direct communication to
- * another packet interface (MAC to MAC) without a PHY involved.
- *
- * (4) We can still do address filtering and control packet filtering is the
- * user desires.
- *
- * (5) UDD_SKP must be 0 in half-duplex operation unless
- * BGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear.  If BGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is
- * clear,
- * then UDD_SKP will normally be 8.
- *
- * (6) In all cases, the UDD bytes will be sent down the packet interface as
- * part of the packet.  The UDD bytes are never stripped from the actual
- * packet.
  */
 union cvmx_bgxx_gmp_gmi_rxx_udd_skp {
 	uint64_t u64;
@@ -4638,24 +4639,6 @@ typedef union cvmx_bgxx_gmp_gmi_txx_min_pkt cvmx_bgxx_gmp_gmi_txx_min_pkt_t;
  *
  * This register specifies how often PAUSE packets are sent.
  *
- * INTERNAL: Notes:
- * Choosing proper values of BGX()_GMP_GMI_TX_PAUSE_PKT_TIME[PTIME] and
- * BGX()_GMP_GMI_TX_PAUSE_PKT_INTERVAL[INTERVAL] can be challenging to the system
- * designer.  It is suggested that TIME be much greater than INTERVAL and
- * BGX()_GMP_GMI_TX_PAUSE_ZERO[SEND] be set.  This allows a periodic refresh of the PAUSE
- * count and then when the backpressure condition is lifted, a PAUSE packet
- * with TIME==0 will be sent indicating that Octane is ready for additional
- * data.
- *
- * If the system chooses to not set BGX()_GMP_GMI_TX_PAUSE_ZERO[SEND], then it is
- * suggested that TIME and INTERVAL are programmed such that they satisify the
- * following rule:
- *
- * _ INTERVAL <= TIME - (largest_pkt_size + IFG + pause_pkt_size)
- *
- * where largest_pkt_size is that largest packet that the system can send
- * (normally 1518B), IFG is the interframe gap and pause_pkt_size is the size
- * of the PAUSE packet (normally 64B).
  */
 union cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval {
 	uint64_t u64;
@@ -4664,7 +4647,8 @@ union cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval {
 	uint64_t reserved_16_63               : 48;
 	uint64_t interval                     : 16; /**< Arbitrate for a 802.3 PAUSE packet or CBFC PAUSE packet every (INTERVAL * 512) bit-times.
                                                          Normally, 0 < INTERVAL < BGX()_GMP_GMI_TX()_PAUSE_PKT_TIME[PTIME].
-                                                         INTERVAL = 0 only sends a single PAUSE packet for each backpressure event. */
+                                                         INTERVAL = 0 only sends a single PAUSE packet for each backpressure event.
+                                                         BGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND] must be 1 when INTERVAL = 0. */
 #else
 	uint64_t interval                     : 16;
 	uint64_t reserved_16_63               : 48;
@@ -5245,15 +5229,6 @@ typedef union cvmx_bgxx_gmp_pcs_linkx_timer cvmx_bgxx_gmp_pcs_linkx_timer_t;
 
 /**
  * cvmx_bgx#_gmp_pcs_misc#_ctl
- *
- * INTERNAL:
- * SGMII bit [12] is really a misnomer, it is a decode  of pi_qlm_cfg pins to indicate SGMII or
- * 1000Base-X modes.
- *
- * Note: The SGMII AN Advertisement Register above will be sent during Auto Negotiation if the
- * MAC_PHY mode bit in misc_ctl_reg is set (1=PHY mode). If the bit is not set (0=MAC mode), the
- * tx_config_reg[14] becomes ACK bit and [0] is always 1.
- * All other bits in tx_config_reg sent will be 0. The PHY dictates the Auto Negotiation results.
  */
 union cvmx_bgxx_gmp_pcs_miscx_ctl {
 	uint64_t u64;
@@ -5522,7 +5497,7 @@ union cvmx_bgxx_gmp_pcs_sgmx_an_adv {
 	uint64_t link                         : 1;  /**< Link status: 1 = Link up, 0 = Link down. */
 	uint64_t ack                          : 1;  /**< Autonegotiation acknowledgement. */
 	uint64_t reserved_13_13               : 1;
-	uint64_t dup                          : 1;  /**< Duplex mode: 1 = full duplex, 0 = half duplex */
+	uint64_t dup                          : 1;  /**< Duplex mode: 1 = full duplex, 0 = half duplex. */
 	uint64_t speed                        : 2;  /**< Link speed:
                                                          0x0 = 10 Mb/s.
                                                          0x1 = 100 Mb/s.
@@ -5561,7 +5536,7 @@ union cvmx_bgxx_gmp_pcs_sgmx_lp_adv {
 	uint64_t reserved_16_63               : 48;
 	uint64_t link                         : 1;  /**< Link status: 1 = Link up, 0 = Link down. */
 	uint64_t reserved_13_14               : 2;
-	uint64_t dup                          : 1;  /**< Duplex mode: 1 = Full duplex, 0 = Half duplex */
+	uint64_t dup                          : 1;  /**< Duplex mode: 1 = Full duplex, 0 = Half duplex. */
 	uint64_t speed                        : 2;  /**< Link speed:
                                                          0x0 = 10 Mb/s.
                                                          0x1 = 100 Mb/s.
@@ -6074,15 +6049,6 @@ typedef union cvmx_bgxx_smux_rx_int cvmx_bgxx_smux_rx_int_t;
  *
  * This register specifies the maximum size for packets, beyond which the SMU truncates. In
  * XAUI/RXAUI mode, port 0 is used for checking.
- *
- * INTERNAL:
- * The packet that will be sent to the packet input logic will have an
- * additionl 8 bytes if BGX()_SMU()_RX_FRM_CTL[PRE_CHK] is set and
- * BGX()_SMU()_RX_FRM_CTL[PRE_STRP] is clear.  The max packet that will be sent is
- * defined as:
- *
- * _ max_sized_packet = BGX()_SMU()_RX_JABBER[CNT]+((BGX()_SMU()_RX_FRM_CTL[PRE_CHK] &
- * !BGX()_SMU()_RX_FRM_CTL[PRE_STRP])*8)
  */
 union cvmx_bgxx_smux_rx_jabber {
 	uint64_t u64;
@@ -6109,26 +6075,6 @@ typedef union cvmx_bgxx_smux_rx_jabber cvmx_bgxx_smux_rx_jabber_t;
  *
  * This register specifies the amount of user-defined data (UDD) added before the start of the
  * L2C data.
- *
- * INTERNAL:
- *
- * (1) The skip bytes are part of the packet and will be sent down the NCB
- * packet interface and will be handled by PKI.
- *
- * (2) The system can determine if the UDD bytes are included in the FCS check
- * by using the FCSSEL field if the FCS check is enabled.
- *
- * (3) Assume that the preamble/sfd is always at the start of the frame even
- * before UDD bytes.  In most cases, there will be no preamble in these
- * cases since it will be packet interface in direct communication to
- * another packet interface (MAC to MAC) without a PHY involved.
- *
- * (4) We can still do address filtering and control packet filtering if the
- * user desires.
- *
- * (6) In all cases, the UDD bytes will be sent down the packet interface as
- * part of the packet.  The UDD bytes are never stripped from the actual
- * packet.
  */
 union cvmx_bgxx_smux_rx_udd_skp {
 	uint64_t u64;
@@ -6555,7 +6501,7 @@ union cvmx_bgxx_smux_tx_thresh {
                                                          _ BGX()_CMR_TX_PRTS = 0,1:  CNT maximum = 0x7FF.
                                                          _ BGX()_CMR_TX_PRTS = 2:    CNT maximum = 0x3FF.
                                                          _ BGX()_CMR_TX_PRTS = 3,4:  CNT maximum = 0x1FF.
-                                                         Additionally, cannot exceed corresponding PKO_MCI1_MAX_CRED(0..27)[MAX_CRED_LIM] - 9. */
+                                                         Additionally, cannot exceed corresponding PKO_MCI1_MAX_CRED()[MAX_CRED_LIM] - 9. */
 #else
 	uint64_t cnt                          : 11;
 	uint64_t reserved_11_63               : 53;
@@ -7284,7 +7230,7 @@ union cvmx_bgxx_spux_br_status1 {
 	uint64_t reserved_13_63               : 51;
 	uint64_t rcv_lnk                      : 1;  /**< BASE-R receive link status.
                                                          0 = BASE-R PCS receive-link down.
-                                                         1 = BASE-R PCS receive-link up
+                                                         1 = BASE-R PCS receive-link up.
                                                          This bit is a reflection of the PCS_status variable defined in Std 802.3 sections
                                                          49.2.14.1 and 82.3.1. */
 	uint64_t reserved_4_11                : 8;
@@ -7965,10 +7911,10 @@ union cvmx_bgxx_spux_misc_control {
                                                          RXAUI (BGX()_CMR()_CONFIG[LMAC_TYPE] = RXAUI), and has no effect otherwise. It
                                                          selects which disparity calculation to use when combining or splitting the RXAUI lanes, as
                                                          follows:
-                                                         _ 0 = Common running disparity. Common running disparity is computed for even and odd
-                                                         code-
-                                                         groups of an RXAUI lane, i.e. interleave lanes before PCS layer as described in the Dune
-                                                         Networks/Broadcom RXAUI v2.1 specification. This obeys 6.25GHz serdes disparity.
+                                                         _ 0 = Common running disparity. Common running disparity is computed for even
+                                                         and odd code-groups of an RXAUI lane, i.e. interleave lanes before PCS layer as
+                                                         described in the Dune Networks/Broadcom RXAUI v2.1 specification. This obeys
+                                                         6.25GHz serdes disparity.
                                                          _ 1 = Interleaved running disparity: Running disparity is computed separately for even and
                                                          odd code-groups of an RXAUI lane, i.e. interleave lanes after PCS layer as described in
                                                          the Marvell RXAUI Interface specification. This does not obey 6.25GHz SerDes disparity. */
diff --git a/arch/mips/include/asm/octeon/cvmx-bootmem.h b/arch/mips/include/asm/octeon/cvmx-bootmem.h
index 4a54038..7a748e0 100644
--- a/arch/mips/include/asm/octeon/cvmx-bootmem.h
+++ b/arch/mips/include/asm/octeon/cvmx-bootmem.h
@@ -42,7 +42,7 @@
  * Simple allocate only memory allocator.  Used to allocate memory at application
  * start time.
  *
- * <hr>$Revision: 125700 $<hr>
+ * <hr>$Revision: 127530 $<hr>
  *
  */
 
@@ -126,7 +126,6 @@ typedef struct cvmx_bootmem_named_block_desc cvmx_bootmem_named_block_desc_t;
 */
 typedef struct {
 	/* Linux compatible proxy for __BIG_ENDIAN */
-#if defined(__BIG_ENDIAN_BITFIELD) || defined(CVMX_BUILD_FOR_LINUX_HOST)
 	uint32_t lock;
 			    /**< spinlock to control access to list */
 	uint32_t flags;
@@ -146,20 +145,6 @@ typedef struct {
 					 /**< length of name array in bootmem blocks */
 	uint64_t named_block_array_addr;
 					 /**< address of named memory block descriptors */
-#else				/* __LITTLE_ENDIAN */
-	uint32_t flags;
-	uint32_t lock;
-	uint64_t head_addr;
-
-	uint32_t minor_version;
-	uint32_t major_version;
-	uint64_t app_data_addr;
-	uint64_t app_data_size;
-
-	uint32_t named_block_name_len;
-	uint32_t named_block_num_blocks;
-	uint64_t named_block_array_addr;
-#endif
 } cvmx_bootmem_desc_t;
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
index 3c18811..62f7317 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
@@ -219,6 +219,10 @@ static inline uint64_t CVMX_CIU_DINT_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x0001010000000180ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x0001010000000180ull);
 			return CVMX_ADD_IO_SEG(0x0001010000000180ull);
 			break;
 	}
@@ -247,6 +251,10 @@ static inline uint64_t CVMX_CIU_DINT_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001010000000180ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001010000000180ull);
 			return CVMX_ADD_IO_SEG(0x0001010000000180ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001010000000180ull);
@@ -443,6 +451,10 @@ static inline uint64_t CVMX_CIU_FUSE_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
 			return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
 			break;
 	}
@@ -471,6 +483,10 @@ static inline uint64_t CVMX_CIU_FUSE_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
 			return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00010100000001A0ull);
@@ -972,6 +988,10 @@ static inline uint64_t CVMX_CIU_PP_DBG_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x0001010000000120ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x0001010000000120ull);
 			return CVMX_ADD_IO_SEG(0x0001010000000120ull);
 			break;
 	}
@@ -1000,6 +1020,10 @@ static inline uint64_t CVMX_CIU_PP_DBG_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001010000000120ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001010000000120ull);
 			return CVMX_ADD_IO_SEG(0x0001010000000120ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001010000000120ull);
@@ -1048,8 +1072,13 @@ static inline uint64_t CVMX_CIU_PP_POKEX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001010000030000ull) + ((offset) & 15) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 47))
-				return CVMX_ADD_IO_SEG(0x0001010000030000ull) + ((offset) & 63) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 47))
+					return CVMX_ADD_IO_SEG(0x0001010000030000ull) + ((offset) & 63) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 47))
+					return CVMX_ADD_IO_SEG(0x0001010000030000ull) + ((offset) & 63) * 8;
+
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 31))
@@ -1086,7 +1115,11 @@ static inline uint64_t CVMX_CIU_PP_POKEX(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000030000ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001010000030000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001010000030000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001010000030000ull) + (offset) * 8;
+
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070100100200ull) + (offset) * 8;
 	}
@@ -1116,6 +1149,10 @@ static inline uint64_t CVMX_CIU_PP_RST_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x0001010000000100ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x0001010000000100ull);
 			return CVMX_ADD_IO_SEG(0x0001010000000100ull);
 			break;
 	}
@@ -1144,6 +1181,10 @@ static inline uint64_t CVMX_CIU_PP_RST_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001010000000100ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001010000000100ull);
 			return CVMX_ADD_IO_SEG(0x0001010000000100ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001010000000100ull);
@@ -1157,6 +1198,10 @@ static inline uint64_t CVMX_CIU_PP_RST_PENDING_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x0001010000000110ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x0001010000000110ull);
 			return CVMX_ADD_IO_SEG(0x0001010000000110ull);
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -1174,6 +1219,10 @@ static inline uint64_t CVMX_CIU_PP_RST_PENDING_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001010000000110ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001010000000110ull);
 			return CVMX_ADD_IO_SEG(0x0001010000000110ull);
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000740ull);
@@ -1515,8 +1564,13 @@ static inline uint64_t CVMX_CIU_WDOGX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001010000020000ull) + ((offset) & 15) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 47))
-				return CVMX_ADD_IO_SEG(0x0001010000020000ull) + ((offset) & 63) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 47))
+					return CVMX_ADD_IO_SEG(0x0001010000020000ull) + ((offset) & 63) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 47))
+					return CVMX_ADD_IO_SEG(0x0001010000020000ull) + ((offset) & 63) * 8;
+
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 31))
@@ -1553,7 +1607,11 @@ static inline uint64_t CVMX_CIU_WDOGX(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001010000020000ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001010000020000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001010000020000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001010000020000ull) + (offset) * 8;
+
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070100100000ull) + (offset) * 8;
 	}
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
index d05da67..96055d3 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_CIU3_BIST CVMX_CIU3_BIST_FUNC()
 static inline uint64_t CVMX_CIU3_BIST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_CIU3_BIST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010100000001C0ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_CIU3_BIST_FUNC(void)
 #define CVMX_CIU3_CONST CVMX_CIU3_CONST_FUNC()
 static inline uint64_t CVMX_CIU3_CONST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_CIU3_CONST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000220ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_CIU3_CONST_FUNC(void)
 #define CVMX_CIU3_CTL CVMX_CIU3_CTL_FUNC()
 static inline uint64_t CVMX_CIU3_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_CIU3_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010100000000E0ull);
 }
@@ -90,6 +90,7 @@ static inline uint64_t CVMX_CIU3_DESTX_IO_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_CIU3_DESTX_IO_INT(%lu) is invalid on this chip\n", offset);
@@ -103,6 +104,7 @@ static inline uint64_t CVMX_CIU3_DESTX_PP_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 47))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 143))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 143))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 47)))))
 		cvmx_warn("CVMX_CIU3_DESTX_PP_INT(%lu) is invalid on this chip\n", offset);
@@ -115,7 +117,7 @@ static inline uint64_t CVMX_CIU3_DESTX_PP_INT(unsigned long offset)
 #define CVMX_CIU3_GSTOP CVMX_CIU3_GSTOP_FUNC()
 static inline uint64_t CVMX_CIU3_GSTOP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_CIU3_GSTOP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000140ull);
 }
@@ -127,6 +129,7 @@ static inline uint64_t CVMX_CIU3_IDTX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_CIU3_IDTX_CTL(%lu) is invalid on this chip\n", offset);
@@ -140,6 +143,7 @@ static inline uint64_t CVMX_CIU3_IDTX_IO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_CIU3_IDTX_IO(%lu) is invalid on this chip\n", offset);
@@ -153,6 +157,7 @@ static inline uint64_t CVMX_CIU3_IDTX_PPX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset == 0)) && ((block_id <= 255)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id <= 255)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id <= 255)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset == 0)) && ((block_id <= 255))))))
 		cvmx_warn("CVMX_CIU3_IDTX_PPX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -165,7 +170,7 @@ static inline uint64_t CVMX_CIU3_IDTX_PPX(unsigned long offset, unsigned long bl
 #define CVMX_CIU3_INTR_RAM_ECC_CTL CVMX_CIU3_INTR_RAM_ECC_CTL_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_CIU3_INTR_RAM_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000260ull);
 }
@@ -176,7 +181,7 @@ static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_CTL_FUNC(void)
 #define CVMX_CIU3_INTR_RAM_ECC_ST CVMX_CIU3_INTR_RAM_ECC_ST_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_ST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_CIU3_INTR_RAM_ECC_ST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000280ull);
 }
@@ -187,7 +192,7 @@ static inline uint64_t CVMX_CIU3_INTR_RAM_ECC_ST_FUNC(void)
 #define CVMX_CIU3_INTR_READY CVMX_CIU3_INTR_READY_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_READY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_CIU3_INTR_READY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010100000002A0ull);
 }
@@ -198,7 +203,7 @@ static inline uint64_t CVMX_CIU3_INTR_READY_FUNC(void)
 #define CVMX_CIU3_INTR_SLOWDOWN CVMX_CIU3_INTR_SLOWDOWN_FUNC()
 static inline uint64_t CVMX_CIU3_INTR_SLOWDOWN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_CIU3_INTR_SLOWDOWN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000240ull);
 }
@@ -210,6 +215,7 @@ static inline uint64_t CVMX_CIU3_ISCX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1048575))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1048575)))))
 		cvmx_warn("CVMX_CIU3_ISCX_CTL(%lu) is invalid on this chip\n", offset);
@@ -223,6 +229,7 @@ static inline uint64_t CVMX_CIU3_ISCX_W1C(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1048575))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1048575)))))
 		cvmx_warn("CVMX_CIU3_ISCX_W1C(%lu) is invalid on this chip\n", offset);
@@ -236,6 +243,7 @@ static inline uint64_t CVMX_CIU3_ISCX_W1S(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1048575))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1048575))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1048575)))))
 		cvmx_warn("CVMX_CIU3_ISCX_W1S(%lu) is invalid on this chip\n", offset);
@@ -248,7 +256,7 @@ static inline uint64_t CVMX_CIU3_ISCX_W1S(unsigned long offset)
 #define CVMX_CIU3_NMI CVMX_CIU3_NMI_FUNC()
 static inline uint64_t CVMX_CIU3_NMI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_CIU3_NMI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001010000000160ull);
 }
@@ -260,6 +268,7 @@ static inline uint64_t CVMX_CIU3_SISCX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 191))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 191))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 191))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 191)))))
 		cvmx_warn("CVMX_CIU3_SISCX(%lu) is invalid on this chip\n", offset);
@@ -273,6 +282,7 @@ static inline uint64_t CVMX_CIU3_TIMX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 9))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 9))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 9))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 9)))))
 		cvmx_warn("CVMX_CIU3_TIMX(%lu) is invalid on this chip\n", offset);
@@ -290,16 +300,7 @@ union cvmx_ciu3_bist {
 	struct cvmx_ciu3_bist_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
-	uint64_t bist                         : 9;  /**< BIST results. Hardware sets a bit for each memory that fails BIST. INTERNAL:
-                                                         <8>= ncbo_crd_fif_mem0.
-                                                         <7> = ciu_nbt_rsp_ram.
-                                                         <6> = ciu_isc_ram2.
-                                                         <5> = ciu_isc_ram1.
-                                                         <4> = ciu_isc_ram0.
-                                                         <3> = ciu_sist_ram.
-                                                         <2> = ciu_idt_ram.
-                                                         <1> = csr req_mem.
-                                                         <0> = ciu3_wdg_ctl_mem. */
+	uint64_t bist                         : 9;  /**< BIST results. Hardware sets a bit for each memory that fails BIST. */
 #else
 	uint64_t bist                         : 9;
 	uint64_t reserved_9_63                : 55;
@@ -472,8 +473,7 @@ union cvmx_ciu3_idtx_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_52_63               : 12;
 	uint64_t intsn                        : 20; /**< Interrupt source number causing the current interrupt, or most recent interrupt if INTR is
-                                                         clear. INTERNAL: Hardware does not store the 20 bit INTSN here; it instead stores the
-                                                         sparse 12 bit PINTSN, and maps it to INTSN on a read. */
+                                                         clear. */
 	uint64_t reserved_4_31                : 28;
 	uint64_t intr                         : 1;  /**< Interrupt pending */
 	uint64_t newint                       : 1;  /**< New interrupt to be delivered. Internal state, for diagnostic use only. */
diff --git a/arch/mips/include/asm/octeon/cvmx-coremask.h b/arch/mips/include/asm/octeon/cvmx-coremask.h
index fa47ee4..3627fdf 100644
--- a/arch/mips/include/asm/octeon/cvmx-coremask.h
+++ b/arch/mips/include/asm/octeon/cvmx-coremask.h
@@ -60,7 +60,7 @@
  * provide future compatibility if more cores are added to future processors
  * or more nodes are supported.
  *
- * <hr>$Revision: 114431 $<hr>
+ * <hr>$Revision: 125834 $<hr>
  *
  */
 
@@ -511,11 +511,11 @@ static inline int cvmx_coremask_lowest_bit(cvmx_coremask_holder_t h)
 }
 
 /*
- * Returns the index of the highest bit in a coremask holder.
+ * Returns the 0-based index of the highest bit in a coremask holder.
  */
 static inline int cvmx_coremask_highest_bit(cvmx_coremask_holder_t h)
 {
-	return (64 - __builtin_clzll(h));
+	return (64 - __builtin_clzll(h) - 1);
 }
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
index b179f4c..70ad363 100644
--- a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_DPI_BIST_STATUS CVMX_DPI_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_DPI_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000000ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_DPI_BIST_STATUS_FUNC(void)
 #define CVMX_DPI_CTL CVMX_DPI_CTL_FUNC()
 static inline uint64_t CVMX_DPI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000040ull);
 }
@@ -84,6 +84,7 @@ static inline uint64_t CVMX_DPI_DMAX_COUNTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 7)))))
@@ -103,6 +104,7 @@ static inline uint64_t CVMX_DPI_DMAX_DBELL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 7)))))
@@ -121,6 +123,7 @@ static inline uint64_t CVMX_DPI_DMAX_ERR_RSP_STATUS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 7)))))
@@ -140,6 +143,7 @@ static inline uint64_t CVMX_DPI_DMAX_IBUFF_SADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 7)))))
@@ -158,6 +162,7 @@ static inline uint64_t CVMX_DPI_DMAX_IFLIGHT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 7)))))
@@ -177,6 +182,7 @@ static inline uint64_t CVMX_DPI_DMAX_NADDR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 7)))))
@@ -196,6 +202,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQBNK0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 7)))))
@@ -215,6 +222,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQBNK1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 7)))))
@@ -229,6 +237,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQQ_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_DPI_DMAX_REQQ_CTL(%lu) is invalid on this chip\n", offset);
@@ -241,7 +250,7 @@ static inline uint64_t CVMX_DPI_DMAX_REQQ_CTL(unsigned long offset)
 #define CVMX_DPI_DMA_CONTROL CVMX_DPI_DMA_CONTROL_FUNC()
 static inline uint64_t CVMX_DPI_DMA_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_DMA_CONTROL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000048ull);
 }
@@ -258,6 +267,7 @@ static inline uint64_t CVMX_DPI_DMA_ENGX_EN(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
@@ -287,8 +297,13 @@ static inline uint64_t CVMX_DPI_DMA_PPX_CNT(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + ((offset) & 15) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 47))
-				return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + ((offset) & 63) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 47))
+					return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + ((offset) & 63) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 47))
+					return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + ((offset) & 63) * 8;
+
 			break;
 	}
 	cvmx_warn("CVMX_DPI_DMA_PPX_CNT (offset = %lu) not supported on this chip\n", offset);
@@ -308,7 +323,11 @@ static inline uint64_t CVMX_DPI_DMA_PPX_CNT(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + (offset) * 8;
+
 	}
 	return CVMX_ADD_IO_SEG(0x0001DF0000000C00ull) + (offset) * 8;
 }
@@ -317,7 +336,7 @@ static inline uint64_t CVMX_DPI_DMA_PPX_CNT(unsigned long offset)
 #define CVMX_DPI_DMA_PP_INT CVMX_DPI_DMA_PP_INT_FUNC()
 static inline uint64_t CVMX_DPI_DMA_PP_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_DMA_PP_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000038ull);
 }
@@ -328,7 +347,7 @@ static inline uint64_t CVMX_DPI_DMA_PP_INT_FUNC(void)
 #define CVMX_DPI_ECC_CTL CVMX_DPI_ECC_CTL_FUNC()
 static inline uint64_t CVMX_DPI_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000018ull);
 }
@@ -339,7 +358,7 @@ static inline uint64_t CVMX_DPI_ECC_CTL_FUNC(void)
 #define CVMX_DPI_ECC_INT CVMX_DPI_ECC_INT_FUNC()
 static inline uint64_t CVMX_DPI_ECC_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_ECC_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000020ull);
 }
@@ -356,6 +375,7 @@ static inline uint64_t CVMX_DPI_ENGX_BUF(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
@@ -369,7 +389,7 @@ static inline uint64_t CVMX_DPI_ENGX_BUF(unsigned long offset)
 #define CVMX_DPI_INFO_REG CVMX_DPI_INFO_REG_FUNC()
 static inline uint64_t CVMX_DPI_INFO_REG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_INFO_REG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000980ull);
 }
@@ -391,7 +411,7 @@ static inline uint64_t CVMX_DPI_INT_EN_FUNC(void)
 #define CVMX_DPI_INT_REG CVMX_DPI_INT_REG_FUNC()
 static inline uint64_t CVMX_DPI_INT_REG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_INT_REG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000008ull);
 }
@@ -407,6 +427,7 @@ static inline uint64_t CVMX_DPI_NCBX_CFG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
@@ -420,7 +441,7 @@ static inline uint64_t CVMX_DPI_NCBX_CFG(unsigned long offset)
 #define CVMX_DPI_NCB_CTL CVMX_DPI_NCB_CTL_FUNC()
 static inline uint64_t CVMX_DPI_NCB_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_NCB_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000028ull);
 }
@@ -431,7 +452,7 @@ static inline uint64_t CVMX_DPI_NCB_CTL_FUNC(void)
 #define CVMX_DPI_PINT_INFO CVMX_DPI_PINT_INFO_FUNC()
 static inline uint64_t CVMX_DPI_PINT_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_PINT_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000830ull);
 }
@@ -442,7 +463,7 @@ static inline uint64_t CVMX_DPI_PINT_INFO_FUNC(void)
 #define CVMX_DPI_PKT_ERR_RSP CVMX_DPI_PKT_ERR_RSP_FUNC()
 static inline uint64_t CVMX_DPI_PKT_ERR_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_PKT_ERR_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000078ull);
 }
@@ -453,7 +474,7 @@ static inline uint64_t CVMX_DPI_PKT_ERR_RSP_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RSP CVMX_DPI_REQ_ERR_RSP_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000058ull);
 }
@@ -464,7 +485,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RSP_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RSP_EN CVMX_DPI_REQ_ERR_RSP_EN_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RSP_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RSP_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000068ull);
 }
@@ -475,7 +496,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RSP_EN_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RST CVMX_DPI_REQ_ERR_RST_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000060ull);
 }
@@ -486,7 +507,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RST_FUNC(void)
 #define CVMX_DPI_REQ_ERR_RST_EN CVMX_DPI_REQ_ERR_RST_EN_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_RST_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_RST_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000070ull);
 }
@@ -497,7 +518,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_RST_EN_FUNC(void)
 #define CVMX_DPI_REQ_ERR_SKIP_COMP CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC()
 static inline uint64_t CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_REQ_ERR_SKIP_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000838ull);
 }
@@ -508,7 +529,7 @@ static inline uint64_t CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC(void)
 #define CVMX_DPI_REQ_GBL_EN CVMX_DPI_REQ_GBL_EN_FUNC()
 static inline uint64_t CVMX_DPI_REQ_GBL_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_REQ_GBL_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000050ull);
 }
@@ -525,6 +546,7 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_CFG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
@@ -542,6 +564,12 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR(unsigned long offset)
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + ((offset) & 3) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + ((offset) & 3) * 8;
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + ((offset) & 3) * 8;
 			break;
@@ -579,6 +607,10 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR(unsigned long offset)
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
 			return CVMX_ADD_IO_SEG(0x0001DF0000000920ull) + (offset) * 8;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -608,6 +640,7 @@ static inline uint64_t CVMX_DPI_SLI_PRTX_ERR_INFO(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
@@ -643,7 +676,7 @@ static inline uint64_t CVMX_DPI_SRIO_RX_BELL_SEQX(unsigned long offset)
 #define CVMX_DPI_SWA_Q_VMID CVMX_DPI_SWA_Q_VMID_FUNC()
 static inline uint64_t CVMX_DPI_SWA_Q_VMID_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DPI_SWA_Q_VMID not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001DF0000000030ull);
 }
@@ -662,19 +695,7 @@ union cvmx_dpi_bist_status {
 	struct cvmx_dpi_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_57_63               : 7;
-	uint64_t bist                         : 57; /**< BIST results. Hardware sets a bit in BIST for memory that fails.
-                                                         INTERNAL:
-                                                           dpi.dma.csr.r_pkt__csr_bstatus_summary,    56    -- from the packet logic
-                                                           dpi.dma.csr.spi__csr_bist_status[7:0],     55:48
-                                                           dpi.dma.csr.r_rdb_buff__bist_status[23:0], 47:24
-                                                           dpi.dma.csr.rdb_tmem__bist_status,         23
-                                                           dpi.dma.csr.req_mem__bist_status[1:0],     22:21
-                                                           dpi.dma.csr.req_ctl__bist_status[1:0],     20:19 -- these bits are tied off to zero
-                                                           dpi.dma.csr.dsi1__bist_status[3:0],        18:15
-                                                           dpi.dma.csr.dsi0__bist_status[3:0],        14:11
-                                                           dpi.dma.csr.ncbo__bist_status[2:0],        10:8
-                                                           dpi.dma.csr.ncbib__csr_bist_status[3:0],    7:4
-                                                           dpi.dma.csr.ncbia__csr_bist_status[3:0]     3:0 */
+	uint64_t bist                         : 57; /**< BIST results. Hardware sets a bit in BIST for memory that fails. */
 #else
 	uint64_t bist                         : 57;
 	uint64_t reserved_57_63               : 7;
@@ -722,19 +743,7 @@ union cvmx_dpi_bist_status {
 	struct cvmx_dpi_bist_status_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_51_63               : 13;
-	uint64_t bist                         : 51; /**< BIST results. Hardware sets a bit in BIST for memory that fails.
-                                                         INTERNAL:
-                                                         dpi.dma.rdb.buff.bnk[2,5,8,11]
-                                                         dpi.dma.rdb.buff.bnk[0a,1a,3a,4a,6a,7a,9a,10a, 0b,1b,3b,4b,6b,7b,9b,10b]
-                                                         dpi.dma.rdb.slif.stm.tmem
-                                                         dpi.dma.req.mem.bnk[0,1]
-                                                         dpi.dma.spi.ipkt[0,1].inb_bnk1
-                                                         dpi.dma.spi.ipkt[0,1].inb_bnk0
-                                                         dpi.dma.dsi.dsi1.rspf.rsp_dpr_mem[0,1]
-                                                         dpi.dma.dsi.dsi0.rspf.rsp_dpr_mem[0,1]
-                                                         dpi.dma.ncbo.drf16x64m2_bist
-                                                         dpi.dma.ncbi.wrfif_bnk1
-                                                         dpi.dma.ncbi.wrfif_bnk0 */
+	uint64_t bist                         : 51; /**< BIST results. Hardware sets a bit in BIST for memory that fails. */
 #else
 	uint64_t bist                         : 51;
 	uint64_t reserved_51_63               : 13;
@@ -1855,38 +1864,7 @@ typedef union cvmx_dpi_ecc_ctl cvmx_dpi_ecc_ctl_t;
  * cvmx_dpi_ecc_int
  *
  * This register contains ECC error interrupt summary bits.
- * INTERNAL:
- * RAM[14] = dpi.pnl.pkt.sli_pkt_msix.msix_vfaddr
- * RAM[13] = dpi.pnl.pkt.sli_pkt_msix.msix_vfdata
- * RAM[12] = dpi.pnl.pkt.sli_pkt_csr.pcsr_in_done
- * RAM[11] = dpi.pnl.pkt.sli_pkt_csr.pcsr_instr_mem
- * RAM[10] = dpi.pnl.pkt.sli_pkt_csr.pcsr_pout_size
- * RAM[ 9] = dpi.pnl.pkt.sli_pkt_csr.pcsr_slist
- * RAM[ 8] = dpi.pnl.pkt.sli_pkt_csr.pout_int
- * RAM[ 7] = dpi.pnl.pkt.sli_pkt_msix.msix_mailbox
- * RAM[ 6] = dpi.pnl.pkt.sli_pkt_pof.sli_pkt_poi.poi_fifo
- * RAM[ 5] = dpi.pnl.pkt.sli_pkt_pof.sli_pkt_psf.psf_fifo
- * RAM[ 4] = dpi.pnl.pkt.sli_pkt_pof.sli_pkt_pdf.pdf_fifo
- * RAM[ 3] = dpi.pnl.pkt.sli_pkt_pop.sli_pkt_pbn.pbn_fifo
- * RAM[ 2] = dpi.pnl.pkt.sli_pkt_pop.sli_pkt_pfp.pfp_fifo
- * RAM[ 1] = dpi.pnl.pkt.sli_pkt_pop.pop_fifos.pop_mem1
- * RAM[ 1] = dpi.pnl.pkt.sli_pkt_pop.pop_fifos.pop_mem0
- * RAM[ 0] = dpi.dma.rdb.buff.bnk0a
- * RAM[ 0] = dpi.dma.rdb.buff.bnk0b
- * RAM[ 0] = dpi.dma.rdb.buff.bnk1a
- * RAM[ 0] = dpi.dma.rdb.buff.bnk1b
- * RAM[ 0] = dpi.dma.rdb.buff.bnk3a
- * RAM[ 0] = dpi.dma.rdb.buff.bnk3b
- * RAM[ 0] = dpi.dma.rdb.buff.bnk4a
- * RAM[ 0] = dpi.dma.rdb.buff.bnk4b
- * RAM[ 0] = dpi.dma.rdb.buff.bnk6a
- * RAM[ 0] = dpi.dma.rdb.buff.bnk6b
- * RAM[ 0] = dpi.dma.rdb.buff.bnk7a
- * RAM[ 0] = dpi.dma.rdb.buff.bnk7b
- * RAM[ 0] = dpi.dma.rdb.buff.bnk9a
- * RAM[ 0] = dpi.dma.rdb.buff.bnk9b
- * RAM[ 0] = dpi.dma.rdb.buff.bnk10a
- * RAM[ 0] = dpi.dma.rdb.buff.bnk10b
+ *
  */
 union cvmx_dpi_ecc_int {
 	uint64_t u64;
@@ -2240,12 +2218,7 @@ union cvmx_dpi_int_reg {
 	uint64_t reserved_23_23               : 1;
 	uint64_t req_badfil                   : 1;  /**< Unexpected fill error. This bit is set when an instruction fill is received when there is
                                                          no outstanding request. Throws DPI_INTSN_E::DPI_INT_REQ_BADFIL. */
-	uint64_t req_inull                    : 1;  /**< Interrupt should be ignored. INTERNAL: The interrupt means that the DPI unit
-                                                         received fill data in which one or more or the 64-bit instruction words was all
-                                                         0's. In previous DPI implementations, there was never a case in which a valid
-                                                         instruction stream would have all 0's. In the new dual-instruction word scheme,
-                                                         the 2nd word could be zero. For example, if no completion operation is requested
-                                                         on the instruction and both PTR and DEALLOCV are zero. */
+	uint64_t req_inull                    : 1;  /**< Interrupt should be ignored. */
 	uint64_t req_anull                    : 1;  /**< Instruction bad error. This bit is set when a fetched instruction word was 0x0. Throws
                                                          DPI_INTSN_E::DPI_INT_REQ_ANULL. */
 	uint64_t req_undflw                   : 1;  /**< Instruction FIFO underflow error. This bit is set when the instruction FIFO underflows.
@@ -2355,12 +2328,7 @@ union cvmx_dpi_int_reg {
 	uint64_t reserved_23_63               : 41;
 	uint64_t req_badfil                   : 1;  /**< Unexpected fill error. This bit is set when an instruction fill is received when there is
                                                          no outstanding request. Throws DPI_INTSN_E::DPI_INT_REQ_BADFIL. */
-	uint64_t req_inull                    : 1;  /**< Interrupt should be ignored. INTERNAL: The interrupt means that the DPI unit
-                                                         received fill data in which one or more or the 64-bit instruction words was all
-                                                         0's. In previous DPI implementations, there was never a case in which a valid
-                                                         instruction stream would have all 0's. In the new dual-instruction word scheme,
-                                                         the 2nd word could be zero. For example, if no completion operation is requested
-                                                         on the instruction and both PTR and DEALLOCV are zero. */
+	uint64_t req_inull                    : 1;  /**< Interrupt should be ignored. */
 	uint64_t req_anull                    : 1;  /**< Instruction bad error. This bit is set when a fetched instruction word was 0x0. Throws
                                                          DPI_INTSN_E::DPI_INT_REQ_ANULL. */
 	uint64_t req_undflw                   : 1;  /**< Instruction FIFO underflow error. This bit is set when the instruction FIFO underflows.
@@ -2449,15 +2417,15 @@ union cvmx_dpi_ncb_ctl {
 	uint64_t reserved_21_23               : 3;
 	uint64_t ncbsel_zbw                   : 1;  /**< Selects the IOBI/NCBI bus DPI uses for byte status writes by any DPI_HDR_PT_E::ZBW_CA,
                                                          DPI_HDR_PT_E::ZBW_NC, or DPI_HDR_PT_E::WQP DPI DMA instructions.
-                                                         0 = DPI uses IOBI2/NCBI2 for all byte status writes
-                                                         1 = DPI uses IOBI3/NCBI3 for all byte status writes */
+                                                         0 = DPI uses IOBI2/NCBI2 for all byte status writes.
+                                                         1 = DPI uses IOBI3/NCBI3 for all byte status writes. */
 	uint64_t reserved_17_19               : 3;
 	uint64_t ncbsel_req                   : 1;  /**< Selects the IOB/NCB bus DPI uses for fetching the DPI_DMA_INSTR_HDR_S's,
                                                          the first pointers, and the last pointers. DPI does not read the source data of
                                                          the DPI DMA instruction via [NCBSEL_REQ] - see DPI_SLI_PRT()_CFG[NCBSEL] and
                                                          [NCBSEL_SRC].
-                                                         0 = DPI uses IOBI2/IOBO2 (aka NCBI2/NCBO2) for all DPI_DMA_INSTR_HDR_S and pointer reads
-                                                         1 = DPI uses IOBI3/IOBO3 (aka NCBI3/NCBO3) for all DPI_DMA_INSTR_HDR_S and pointer reads */
+                                                         0 = DPI uses IOBI2/IOBO2 (aka NCBI2/NCBO2) for all DPI_DMA_INSTR_HDR_S and pointer reads.
+                                                         1 = DPI uses IOBI3/IOBO3 (aka NCBI3/NCBO3) for all DPI_DMA_INSTR_HDR_S and pointer reads. */
 	uint64_t reserved_13_15               : 3;
 	uint64_t ncbsel_dst                   : 1;  /**< The default IOI/NCB that DPI uses for DPI_HDR_XTYPE_E::INTERNAL_ONLY L2/DRAM data
                                                          writes.
@@ -2514,15 +2482,15 @@ union cvmx_dpi_ncb_ctl {
 	uint64_t reserved_21_23               : 3;
 	uint64_t ncbsel_zbw                   : 1;  /**< Selects the IOBI/NCBI bus DPI uses for byte status writes by any DPI_HDR_PT_E::ZBW_CA,
                                                          DPI_HDR_PT_E::ZBW_NC, or DPI_HDR_PT_E::WQP DPI DMA instructions.
-                                                         0 = DPI uses IOBI2/NCBI2 for all byte status writes
-                                                         1 = DPI uses IOBI3/NCBI3 for all byte status writes */
+                                                         0 = DPI uses IOBI2/NCBI2 for all byte status writes.
+                                                         1 = DPI uses IOBI3/NCBI3 for all byte status writes. */
 	uint64_t reserved_17_19               : 3;
 	uint64_t ncbsel_req                   : 1;  /**< Selects the IOB/NCB bus DPI uses for fetching the DPI_DMA_INSTR_HDR_S's,
                                                          the first pointers, and the last pointers. DPI does not read the source data of
                                                          the DPI DMA instruction via [NCBSEL_REQ] - see DPI_SLI_PRT()_CFG[NCBSEL] and
                                                          [NCBSEL_SRC].
-                                                         0 = DPI uses IOBI2/IOBO2 (aka NCBI2/NCBO2) for all DPI_DMA_INSTR_HDR_S and pointer reads
-                                                         1 = DPI uses IOBI3/IOBO3 (aka NCBI3/NCBO3) for all DPI_DMA_INSTR_HDR_S and pointer reads */
+                                                         0 = DPI uses IOBI2/IOBO2 (aka NCBI2/NCBO2) for all DPI_DMA_INSTR_HDR_S and pointer reads.
+                                                         1 = DPI uses IOBI3/IOBO3 (aka NCBI3/NCBO3) for all DPI_DMA_INSTR_HDR_S and pointer reads. */
 	uint64_t reserved_13_15               : 3;
 	uint64_t ncbsel_dst                   : 1;  /**< The default IOI/NCB that DPI uses for DPI_HDR_XTYPE_E::INTERNAL_ONLY L2/DRAM data
                                                          writes.
@@ -3132,16 +3100,7 @@ union cvmx_dpi_sli_prtx_cfg {
                                                          If the port is a PCIe port, the HW reads on a
                                                          4B granularity.  In this mode, the HW may break
                                                          a given read into 3 operations to satisify
-                                                         PCIe rules.
-                                                         INTERNAL: If the port is a SRIO port, the HW follows the
-                                                         SRIO read rules from the SRIO specification and
-                                                         only issues 32*n, 16, and 8 byte  operations
-                                                         on the SRIO bus.
-                                                         1=Block Mode
-                                                         The HW will read more data than requested in
-                                                         order to minimize the number of operations
-                                                         necessary to complete the operation.
-                                                         The memory region must be memory like. */
+                                                         PCIe rules. */
 	uint64_t reserved_14_15               : 2;
 	uint64_t molr                         : 6;  /**< Max Outstanding Load Requests
                                                          Limits the number of oustanding load requests on
@@ -3171,8 +3130,7 @@ union cvmx_dpi_sli_prtx_cfg {
                                                          0 = 128B
                                                          1 = 256B
                                                          For PCIe MACs, this MPS size must not exceed
-                                                         the size selected by PCIE*_CFG030[MPS].
-                                                         INTERNAL: For sRIO MACs, all MPS values are allowed. */
+                                                         the size selected by PCIE*_CFG030[MPS]. */
 	uint64_t mrrs_lim                     : 1;  /**< MAC memory space read requests cannot cross the
                                                          (naturally-aligned) MRRS boundary.
                                                          When clear, DPI is allowed to issue a MAC memory
@@ -3190,8 +3148,7 @@ union cvmx_dpi_sli_prtx_cfg {
                                                          2 = 512B
                                                          3 = 1024B
                                                          For PCIe MACs, this MRRS size must not exceed
-                                                         the size selected by PCIE*_CFG030[MRRS].
-                                                         INTERNAL: For sRIO MACs, this MRRS size must be <= 256B. */
+                                                         the size selected by PCIE*_CFG030[MRRS]. */
 #else
 	uint64_t mrrs                         : 2;
 	uint64_t reserved_2_2                 : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
index 0b35f48..2d52cb2 100644
--- a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
@@ -111,7 +111,7 @@ static inline uint64_t CVMX_DTX_AGL_SELX(unsigned long offset)
 #define CVMX_DTX_ASE_BCST_RSP CVMX_DTX_ASE_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_ASE_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_ASE_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE6E8080ull);
 }
@@ -122,7 +122,7 @@ static inline uint64_t CVMX_DTX_ASE_BCST_RSP_FUNC(void)
 #define CVMX_DTX_ASE_CTL CVMX_DTX_ASE_CTL_FUNC()
 static inline uint64_t CVMX_DTX_ASE_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_ASE_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE6E8060ull);
 }
@@ -133,6 +133,7 @@ static inline uint64_t CVMX_DTX_ASE_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_ASE_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ASE_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE6E8040ull) + ((offset) & 1) * 8;
@@ -144,6 +145,7 @@ static inline uint64_t CVMX_DTX_ASE_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ASE_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ASE_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE6E8020ull) + ((offset) & 1) * 8;
@@ -155,6 +157,7 @@ static inline uint64_t CVMX_DTX_ASE_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ASE_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ASE_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE6E8000ull) + ((offset) & 1) * 8;
@@ -390,6 +393,7 @@ static inline uint64_t CVMX_DTX_BGXX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_DTX_BGXX_BCST_RSP(%lu) is invalid on this chip\n", offset);
@@ -403,6 +407,7 @@ static inline uint64_t CVMX_DTX_BGXX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_DTX_BGXX_CTL(%lu) is invalid on this chip\n", offset);
@@ -416,6 +421,7 @@ static inline uint64_t CVMX_DTX_BGXX_DATX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_BGXX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -429,6 +435,7 @@ static inline uint64_t CVMX_DTX_BGXX_ENAX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_BGXX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -442,6 +449,7 @@ static inline uint64_t CVMX_DTX_BGXX_SELX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 5)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_BGXX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -454,7 +462,7 @@ static inline uint64_t CVMX_DTX_BGXX_SELX(unsigned long offset, unsigned long bl
 #define CVMX_DTX_BROADCAST_CTL CVMX_DTX_BROADCAST_CTL_FUNC()
 static inline uint64_t CVMX_DTX_BROADCAST_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_BROADCAST_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE7F0060ull);
 }
@@ -467,6 +475,7 @@ static inline uint64_t CVMX_DTX_BROADCAST_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_BROADCAST_ENAX(%lu) is invalid on this chip\n", offset);
@@ -481,6 +490,7 @@ static inline uint64_t CVMX_DTX_BROADCAST_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_BROADCAST_SELX(%lu) is invalid on this chip\n", offset);
@@ -548,7 +558,7 @@ static inline uint64_t CVMX_DTX_BTS_SELX(unsigned long offset)
 #define CVMX_DTX_CIU_BCST_RSP CVMX_DTX_CIU_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_CIU_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_CIU_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE808080ull);
 }
@@ -559,7 +569,7 @@ static inline uint64_t CVMX_DTX_CIU_BCST_RSP_FUNC(void)
 #define CVMX_DTX_CIU_CTL CVMX_DTX_CIU_CTL_FUNC()
 static inline uint64_t CVMX_DTX_CIU_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_CIU_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE808060ull);
 }
@@ -571,6 +581,7 @@ static inline uint64_t CVMX_DTX_CIU_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_CIU_DATX(%lu) is invalid on this chip\n", offset);
@@ -584,6 +595,7 @@ static inline uint64_t CVMX_DTX_CIU_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_CIU_ENAX(%lu) is invalid on this chip\n", offset);
@@ -597,6 +609,7 @@ static inline uint64_t CVMX_DTX_CIU_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_CIU_SELX(%lu) is invalid on this chip\n", offset);
@@ -664,7 +677,7 @@ static inline uint64_t CVMX_DTX_DENC_SELX(unsigned long offset)
 #define CVMX_DTX_DFA_BCST_RSP CVMX_DTX_DFA_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_DFA_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_DFA_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8080ull);
 }
@@ -675,7 +688,7 @@ static inline uint64_t CVMX_DTX_DFA_BCST_RSP_FUNC(void)
 #define CVMX_DTX_DFA_CTL CVMX_DTX_DFA_CTL_FUNC()
 static inline uint64_t CVMX_DTX_DFA_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_DFA_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8060ull);
 }
@@ -688,6 +701,7 @@ static inline uint64_t CVMX_DTX_DFA_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DFA_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8040ull) + ((offset) & 1) * 8;
@@ -701,6 +715,7 @@ static inline uint64_t CVMX_DTX_DFA_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DFA_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8020ull) + ((offset) & 1) * 8;
@@ -714,6 +729,7 @@ static inline uint64_t CVMX_DTX_DFA_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DFA_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1B8000ull) + ((offset) & 1) * 8;
@@ -780,7 +796,7 @@ static inline uint64_t CVMX_DTX_DLFE_SELX(unsigned long offset)
 #define CVMX_DTX_DPI_BCST_RSP CVMX_DTX_DPI_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_DPI_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_DPI_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8080ull);
 }
@@ -791,7 +807,7 @@ static inline uint64_t CVMX_DTX_DPI_BCST_RSP_FUNC(void)
 #define CVMX_DTX_DPI_CTL CVMX_DTX_DPI_CTL_FUNC()
 static inline uint64_t CVMX_DTX_DPI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_DPI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEEF8060ull);
 }
@@ -804,6 +820,7 @@ static inline uint64_t CVMX_DTX_DPI_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DPI_DATX(%lu) is invalid on this chip\n", offset);
@@ -818,6 +835,7 @@ static inline uint64_t CVMX_DTX_DPI_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DPI_ENAX(%lu) is invalid on this chip\n", offset);
@@ -832,6 +850,7 @@ static inline uint64_t CVMX_DTX_DPI_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_DPI_SELX(%lu) is invalid on this chip\n", offset);
@@ -903,6 +922,10 @@ static inline uint64_t CVMX_DTX_FPA_BCST_RSP_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
 			return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -920,6 +943,10 @@ static inline uint64_t CVMX_DTX_FPA_BCST_RSP_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
 			return CVMX_ADD_IO_SEG(0x00011800FE940080ull);
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140080ull);
@@ -935,6 +962,10 @@ static inline uint64_t CVMX_DTX_FPA_CTL_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
 			return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -952,6 +983,10 @@ static inline uint64_t CVMX_DTX_FPA_CTL_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
 			return CVMX_ADD_IO_SEG(0x00011800FE940060ull);
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140060ull);
@@ -966,6 +1001,12 @@ static inline uint64_t CVMX_DTX_FPA_DATX(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + ((offset) & 1) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + ((offset) & 1) * 8;
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + ((offset) & 1) * 8;
 			break;
@@ -984,6 +1025,10 @@ static inline uint64_t CVMX_DTX_FPA_DATX(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + (offset) * 8;
 			return CVMX_ADD_IO_SEG(0x00011800FE940040ull) + (offset) * 8;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140040ull) + (offset) * 8;
@@ -998,6 +1043,12 @@ static inline uint64_t CVMX_DTX_FPA_ENAX(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + ((offset) & 1) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + ((offset) & 1) * 8;
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + ((offset) & 1) * 8;
 			break;
@@ -1016,6 +1067,10 @@ static inline uint64_t CVMX_DTX_FPA_ENAX(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + (offset) * 8;
 			return CVMX_ADD_IO_SEG(0x00011800FE940020ull) + (offset) * 8;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140020ull) + (offset) * 8;
@@ -1030,6 +1085,12 @@ static inline uint64_t CVMX_DTX_FPA_SELX(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + ((offset) & 1) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + ((offset) & 1) * 8;
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + ((offset) & 1) * 8;
 			break;
@@ -1048,6 +1109,10 @@ static inline uint64_t CVMX_DTX_FPA_SELX(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + (offset) * 8;
 			return CVMX_ADD_IO_SEG(0x00011800FE940000ull) + (offset) * 8;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE140000ull) + (offset) * 8;
@@ -1115,6 +1180,7 @@ static inline uint64_t CVMX_DTX_GSERX_BCST_RSP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_DTX_GSERX_BCST_RSP(%lu) is invalid on this chip\n", offset);
@@ -1128,6 +1194,7 @@ static inline uint64_t CVMX_DTX_GSERX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_DTX_GSERX_CTL(%lu) is invalid on this chip\n", offset);
@@ -1141,6 +1208,7 @@ static inline uint64_t CVMX_DTX_GSERX_DATX(unsigned long offset, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_DTX_GSERX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1154,6 +1222,7 @@ static inline uint64_t CVMX_DTX_GSERX_ENAX(unsigned long offset, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_DTX_GSERX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1167,6 +1236,7 @@ static inline uint64_t CVMX_DTX_GSERX_SELX(unsigned long offset, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_DTX_GSERX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1179,7 +1249,7 @@ static inline uint64_t CVMX_DTX_GSERX_SELX(unsigned long offset, unsigned long b
 #define CVMX_DTX_HNA_BCST_RSP CVMX_DTX_HNA_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_HNA_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_HNA_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE238080ull);
 }
@@ -1190,7 +1260,7 @@ static inline uint64_t CVMX_DTX_HNA_BCST_RSP_FUNC(void)
 #define CVMX_DTX_HNA_CTL CVMX_DTX_HNA_CTL_FUNC()
 static inline uint64_t CVMX_DTX_HNA_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_HNA_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE238060ull);
 }
@@ -1202,6 +1272,7 @@ static inline uint64_t CVMX_DTX_HNA_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_HNA_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE238040ull) + ((offset) & 1) * 8;
@@ -1214,6 +1285,7 @@ static inline uint64_t CVMX_DTX_HNA_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_HNA_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE238020ull) + ((offset) & 1) * 8;
@@ -1226,6 +1298,7 @@ static inline uint64_t CVMX_DTX_HNA_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_HNA_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE238000ull) + ((offset) & 1) * 8;
@@ -1237,7 +1310,7 @@ static inline uint64_t CVMX_DTX_HNA_SELX(unsigned long offset)
 #define CVMX_DTX_ILA_BCST_RSP CVMX_DTX_ILA_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_ILA_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_ILA_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE0B8080ull);
 }
@@ -1248,7 +1321,7 @@ static inline uint64_t CVMX_DTX_ILA_BCST_RSP_FUNC(void)
 #define CVMX_DTX_ILA_CTL CVMX_DTX_ILA_CTL_FUNC()
 static inline uint64_t CVMX_DTX_ILA_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_ILA_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE0B8060ull);
 }
@@ -1259,6 +1332,7 @@ static inline uint64_t CVMX_DTX_ILA_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_ILA_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ILA_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE0B8040ull) + ((offset) & 1) * 8;
@@ -1270,6 +1344,7 @@ static inline uint64_t CVMX_DTX_ILA_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ILA_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ILA_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE0B8020ull) + ((offset) & 1) * 8;
@@ -1281,6 +1356,7 @@ static inline uint64_t CVMX_DTX_ILA_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ILA_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ILA_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE0B8000ull) + ((offset) & 1) * 8;
@@ -1292,7 +1368,7 @@ static inline uint64_t CVMX_DTX_ILA_SELX(unsigned long offset)
 #define CVMX_DTX_ILK_BCST_RSP CVMX_DTX_ILK_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_ILK_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_ILK_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE0A0080ull);
 }
@@ -1303,7 +1379,7 @@ static inline uint64_t CVMX_DTX_ILK_BCST_RSP_FUNC(void)
 #define CVMX_DTX_ILK_CTL CVMX_DTX_ILK_CTL_FUNC()
 static inline uint64_t CVMX_DTX_ILK_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_ILK_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE0A0060ull);
 }
@@ -1314,6 +1390,7 @@ static inline uint64_t CVMX_DTX_ILK_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_ILK_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ILK_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE0A0040ull) + ((offset) & 1) * 8;
@@ -1325,6 +1402,7 @@ static inline uint64_t CVMX_DTX_ILK_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ILK_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ILK_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE0A0020ull) + ((offset) & 1) * 8;
@@ -1336,6 +1414,7 @@ static inline uint64_t CVMX_DTX_ILK_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_ILK_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ILK_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE0A0000ull) + ((offset) & 1) * 8;
@@ -1347,7 +1426,7 @@ static inline uint64_t CVMX_DTX_ILK_SELX(unsigned long offset)
 #define CVMX_DTX_IOBN_BCST_RSP CVMX_DTX_IOBN_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_IOBN_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_IOBN_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE780080ull);
 }
@@ -1358,7 +1437,7 @@ static inline uint64_t CVMX_DTX_IOBN_BCST_RSP_FUNC(void)
 #define CVMX_DTX_IOBN_CTL CVMX_DTX_IOBN_CTL_FUNC()
 static inline uint64_t CVMX_DTX_IOBN_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_IOBN_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE780060ull);
 }
@@ -1370,6 +1449,7 @@ static inline uint64_t CVMX_DTX_IOBN_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBN_DATX(%lu) is invalid on this chip\n", offset);
@@ -1383,6 +1463,7 @@ static inline uint64_t CVMX_DTX_IOBN_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBN_ENAX(%lu) is invalid on this chip\n", offset);
@@ -1396,6 +1477,7 @@ static inline uint64_t CVMX_DTX_IOBN_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBN_SELX(%lu) is invalid on this chip\n", offset);
@@ -1408,7 +1490,7 @@ static inline uint64_t CVMX_DTX_IOBN_SELX(unsigned long offset)
 #define CVMX_DTX_IOBP_BCST_RSP CVMX_DTX_IOBP_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_IOBP_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_IOBP_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0080ull);
 }
@@ -1419,7 +1501,7 @@ static inline uint64_t CVMX_DTX_IOBP_BCST_RSP_FUNC(void)
 #define CVMX_DTX_IOBP_CTL CVMX_DTX_IOBP_CTL_FUNC()
 static inline uint64_t CVMX_DTX_IOBP_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_IOBP_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE7A0060ull);
 }
@@ -1431,6 +1513,7 @@ static inline uint64_t CVMX_DTX_IOBP_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBP_DATX(%lu) is invalid on this chip\n", offset);
@@ -1444,6 +1527,7 @@ static inline uint64_t CVMX_DTX_IOBP_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBP_ENAX(%lu) is invalid on this chip\n", offset);
@@ -1457,6 +1541,7 @@ static inline uint64_t CVMX_DTX_IOBP_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_IOBP_SELX(%lu) is invalid on this chip\n", offset);
@@ -1579,7 +1664,7 @@ static inline uint64_t CVMX_DTX_IPD_SELX(unsigned long offset)
 #define CVMX_DTX_KEY_BCST_RSP CVMX_DTX_KEY_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_KEY_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_KEY_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE100080ull);
 }
@@ -1590,7 +1675,7 @@ static inline uint64_t CVMX_DTX_KEY_BCST_RSP_FUNC(void)
 #define CVMX_DTX_KEY_CTL CVMX_DTX_KEY_CTL_FUNC()
 static inline uint64_t CVMX_DTX_KEY_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_KEY_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE100060ull);
 }
@@ -1603,6 +1688,7 @@ static inline uint64_t CVMX_DTX_KEY_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_KEY_DATX(%lu) is invalid on this chip\n", offset);
@@ -1617,6 +1703,7 @@ static inline uint64_t CVMX_DTX_KEY_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_KEY_ENAX(%lu) is invalid on this chip\n", offset);
@@ -1631,6 +1718,7 @@ static inline uint64_t CVMX_DTX_KEY_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_KEY_SELX(%lu) is invalid on this chip\n", offset);
@@ -1645,6 +1733,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_BCST_RSP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_BCST_RSP(%lu) is invalid on this chip\n", offset);
@@ -1659,6 +1748,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_CTL(%lu) is invalid on this chip\n", offset);
@@ -1673,6 +1763,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_DATX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1687,6 +1778,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_ENAX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1701,6 +1793,7 @@ static inline uint64_t CVMX_DTX_L2C_CBCX_SELX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_L2C_CBCX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1715,6 +1808,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_BCST_RSP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_BCST_RSP(%lu) is invalid on this chip\n", offset);
@@ -1729,6 +1823,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_CTL(%lu) is invalid on this chip\n", offset);
@@ -1743,6 +1838,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_DATX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1757,6 +1853,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_ENAX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1771,6 +1868,7 @@ static inline uint64_t CVMX_DTX_L2C_MCIX_SELX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_L2C_MCIX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1785,6 +1883,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_BCST_RSP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_BCST_RSP(%lu) is invalid on this chip\n", offset);
@@ -1799,6 +1898,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_CTL(%lu) is invalid on this chip\n", offset);
@@ -1813,6 +1913,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_DATX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 7)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1827,6 +1928,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_ENAX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 7)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1841,6 +1943,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_SELX(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 7)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 7)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_DTX_L2C_TADX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1853,6 +1956,7 @@ static inline uint64_t CVMX_DTX_L2C_TADX_SELX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_DTX_LAPX_BCST_RSP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LAPX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE060080ull) + ((offset) & 1) * 32768;
@@ -1864,6 +1968,7 @@ static inline uint64_t CVMX_DTX_LAPX_BCST_RSP(unsigned long offset)
 static inline uint64_t CVMX_DTX_LAPX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LAPX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE060060ull) + ((offset) & 1) * 32768;
@@ -1875,6 +1980,7 @@ static inline uint64_t CVMX_DTX_LAPX_CTL(unsigned long offset)
 static inline uint64_t CVMX_DTX_LAPX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_LAPX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE060040ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
@@ -1886,6 +1992,7 @@ static inline uint64_t CVMX_DTX_LAPX_DATX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_DTX_LAPX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_LAPX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE060020ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
@@ -1897,6 +2004,7 @@ static inline uint64_t CVMX_DTX_LAPX_ENAX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_DTX_LAPX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_LAPX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE060000ull) + (((offset) & 1) + ((block_id) & 1) * 0x1000ull) * 8;
@@ -1908,7 +2016,7 @@ static inline uint64_t CVMX_DTX_LAPX_SELX(unsigned long offset, unsigned long bl
 #define CVMX_DTX_LBK_BCST_RSP CVMX_DTX_LBK_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_LBK_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_LBK_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE090080ull);
 }
@@ -1919,7 +2027,7 @@ static inline uint64_t CVMX_DTX_LBK_BCST_RSP_FUNC(void)
 #define CVMX_DTX_LBK_CTL CVMX_DTX_LBK_CTL_FUNC()
 static inline uint64_t CVMX_DTX_LBK_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_LBK_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE090060ull);
 }
@@ -1931,6 +2039,7 @@ static inline uint64_t CVMX_DTX_LBK_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LBK_DATX(%lu) is invalid on this chip\n", offset);
@@ -1944,6 +2053,7 @@ static inline uint64_t CVMX_DTX_LBK_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LBK_ENAX(%lu) is invalid on this chip\n", offset);
@@ -1957,6 +2067,7 @@ static inline uint64_t CVMX_DTX_LBK_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LBK_SELX(%lu) is invalid on this chip\n", offset);
@@ -1971,6 +2082,7 @@ static inline uint64_t CVMX_DTX_LMCX_BCST_RSP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LMCX_BCST_RSP(%lu) is invalid on this chip\n", offset);
@@ -1985,6 +2097,7 @@ static inline uint64_t CVMX_DTX_LMCX_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_LMCX_CTL(%lu) is invalid on this chip\n", offset);
@@ -1999,6 +2112,7 @@ static inline uint64_t CVMX_DTX_LMCX_DATX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_LMCX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2013,6 +2127,7 @@ static inline uint64_t CVMX_DTX_LMCX_ENAX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_LMCX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2027,6 +2142,7 @@ static inline uint64_t CVMX_DTX_LMCX_SELX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_LMCX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2149,7 +2265,7 @@ static inline uint64_t CVMX_DTX_MHBW_SELX(unsigned long offset)
 #define CVMX_DTX_MIO_BCST_RSP CVMX_DTX_MIO_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_MIO_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_MIO_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE000080ull);
 }
@@ -2160,7 +2276,7 @@ static inline uint64_t CVMX_DTX_MIO_BCST_RSP_FUNC(void)
 #define CVMX_DTX_MIO_CTL CVMX_DTX_MIO_CTL_FUNC()
 static inline uint64_t CVMX_DTX_MIO_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_MIO_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE000060ull);
 }
@@ -2173,6 +2289,7 @@ static inline uint64_t CVMX_DTX_MIO_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_MIO_DATX(%lu) is invalid on this chip\n", offset);
@@ -2187,6 +2304,7 @@ static inline uint64_t CVMX_DTX_MIO_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_MIO_ENAX(%lu) is invalid on this chip\n", offset);
@@ -2201,6 +2319,7 @@ static inline uint64_t CVMX_DTX_MIO_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_MIO_SELX(%lu) is invalid on this chip\n", offset);
@@ -2213,7 +2332,7 @@ static inline uint64_t CVMX_DTX_MIO_SELX(unsigned long offset)
 #define CVMX_DTX_OCX_BOT_BCST_RSP CVMX_DTX_OCX_BOT_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_OCX_BOT_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_OCX_BOT_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE198080ull);
 }
@@ -2224,7 +2343,7 @@ static inline uint64_t CVMX_DTX_OCX_BOT_BCST_RSP_FUNC(void)
 #define CVMX_DTX_OCX_BOT_CTL CVMX_DTX_OCX_BOT_CTL_FUNC()
 static inline uint64_t CVMX_DTX_OCX_BOT_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_OCX_BOT_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE198060ull);
 }
@@ -2235,6 +2354,7 @@ static inline uint64_t CVMX_DTX_OCX_BOT_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_OCX_BOT_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_OCX_BOT_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE198040ull) + ((offset) & 1) * 8;
@@ -2246,6 +2366,7 @@ static inline uint64_t CVMX_DTX_OCX_BOT_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_BOT_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_OCX_BOT_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE198020ull) + ((offset) & 1) * 8;
@@ -2257,6 +2378,7 @@ static inline uint64_t CVMX_DTX_OCX_BOT_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_BOT_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_OCX_BOT_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE198000ull) + ((offset) & 1) * 8;
@@ -2268,6 +2390,7 @@ static inline uint64_t CVMX_DTX_OCX_BOT_SELX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_LNKX_BCST_RSP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_DTX_OCX_LNKX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE180080ull) + ((offset) & 3) * 32768;
@@ -2279,6 +2402,7 @@ static inline uint64_t CVMX_DTX_OCX_LNKX_BCST_RSP(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_LNKX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_DTX_OCX_LNKX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE180060ull) + ((offset) & 3) * 32768;
@@ -2290,6 +2414,7 @@ static inline uint64_t CVMX_DTX_OCX_LNKX_CTL(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_LNKX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_DTX_OCX_LNKX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE180040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -2301,6 +2426,7 @@ static inline uint64_t CVMX_DTX_OCX_LNKX_DATX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_DTX_OCX_LNKX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_DTX_OCX_LNKX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE180020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -2312,6 +2438,7 @@ static inline uint64_t CVMX_DTX_OCX_LNKX_ENAX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_DTX_OCX_LNKX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_DTX_OCX_LNKX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE180000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -2323,6 +2450,7 @@ static inline uint64_t CVMX_DTX_OCX_LNKX_SELX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_DTX_OCX_OLEX_BCST_RSP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_DTX_OCX_OLEX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1A0080ull) + ((offset) & 3) * 32768;
@@ -2334,6 +2462,7 @@ static inline uint64_t CVMX_DTX_OCX_OLEX_BCST_RSP(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_OLEX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_DTX_OCX_OLEX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1A0060ull) + ((offset) & 3) * 32768;
@@ -2345,6 +2474,7 @@ static inline uint64_t CVMX_DTX_OCX_OLEX_CTL(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_OLEX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_DTX_OCX_OLEX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE1A0040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -2356,6 +2486,7 @@ static inline uint64_t CVMX_DTX_OCX_OLEX_DATX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_DTX_OCX_OLEX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_DTX_OCX_OLEX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE1A0020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -2367,6 +2498,7 @@ static inline uint64_t CVMX_DTX_OCX_OLEX_ENAX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_DTX_OCX_OLEX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_DTX_OCX_OLEX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE1A0000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
@@ -2378,7 +2510,7 @@ static inline uint64_t CVMX_DTX_OCX_OLEX_SELX(unsigned long offset, unsigned lon
 #define CVMX_DTX_OCX_TOP_BCST_RSP CVMX_DTX_OCX_TOP_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_OCX_TOP_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_OCX_TOP_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE088080ull);
 }
@@ -2389,7 +2521,7 @@ static inline uint64_t CVMX_DTX_OCX_TOP_BCST_RSP_FUNC(void)
 #define CVMX_DTX_OCX_TOP_CTL CVMX_DTX_OCX_TOP_CTL_FUNC()
 static inline uint64_t CVMX_DTX_OCX_TOP_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_OCX_TOP_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE088060ull);
 }
@@ -2400,6 +2532,7 @@ static inline uint64_t CVMX_DTX_OCX_TOP_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_OCX_TOP_DATX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_OCX_TOP_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE088040ull) + ((offset) & 1) * 8;
@@ -2411,6 +2544,7 @@ static inline uint64_t CVMX_DTX_OCX_TOP_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_TOP_ENAX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_OCX_TOP_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE088020ull) + ((offset) & 1) * 8;
@@ -2422,6 +2556,7 @@ static inline uint64_t CVMX_DTX_OCX_TOP_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OCX_TOP_SELX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_OCX_TOP_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE088000ull) + ((offset) & 1) * 8;
@@ -2434,12 +2569,16 @@ static inline uint64_t CVMX_DTX_OCX_TOP_SELX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OSM_BCST_RSP_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
+
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0080ull);
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
-			break;
 	}
 	cvmx_warn("CVMX_DTX_OSM_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
@@ -2449,10 +2588,14 @@ static inline uint64_t CVMX_DTX_OSM_BCST_RSP_FUNC(void)
 static inline uint64_t CVMX_DTX_OSM_BCST_RSP_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
+
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0080ull);
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0080ull);
 }
@@ -2462,12 +2605,16 @@ static inline uint64_t CVMX_DTX_OSM_BCST_RSP_FUNC(void)
 static inline uint64_t CVMX_DTX_OSM_CTL_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
+
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0060ull);
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
-			break;
 	}
 	cvmx_warn("CVMX_DTX_OSM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
@@ -2477,10 +2624,14 @@ static inline uint64_t CVMX_DTX_OSM_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_OSM_CTL_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
+
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0060ull);
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0060ull);
 }
@@ -2489,14 +2640,19 @@ static inline uint64_t CVMX_DTX_OSM_CTL_FUNC(void)
 static inline uint64_t CVMX_DTX_OSM_DATX(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + ((offset) & 1) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + ((offset) & 1) * 8;
+
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEEE0040ull) + ((offset) & 1) * 8;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + ((offset) & 1) * 8;
-			break;
 	}
 	cvmx_warn("CVMX_DTX_OSM_DATX (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + ((offset) & 1) * 8;
@@ -2505,10 +2661,14 @@ static inline uint64_t CVMX_DTX_OSM_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OSM_DATX(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + (offset) * 8;
+
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0040ull) + (offset) * 8;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0040ull) + (offset) * 8;
 }
@@ -2517,14 +2677,19 @@ static inline uint64_t CVMX_DTX_OSM_DATX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OSM_ENAX(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + ((offset) & 1) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + ((offset) & 1) * 8;
+
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEEE0020ull) + ((offset) & 1) * 8;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + ((offset) & 1) * 8;
-			break;
 	}
 	cvmx_warn("CVMX_DTX_OSM_ENAX (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + ((offset) & 1) * 8;
@@ -2533,10 +2698,14 @@ static inline uint64_t CVMX_DTX_OSM_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OSM_ENAX(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + (offset) * 8;
+
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0020ull) + (offset) * 8;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0020ull) + (offset) * 8;
 }
@@ -2545,14 +2714,19 @@ static inline uint64_t CVMX_DTX_OSM_ENAX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OSM_SELX(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + ((offset) & 1) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + ((offset) & 1) * 8;
+
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEEE0000ull) + ((offset) & 1) * 8;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 1))
-				return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + ((offset) & 1) * 8;
-			break;
 	}
 	cvmx_warn("CVMX_DTX_OSM_SELX (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + ((offset) & 1) * 8;
@@ -2561,10 +2735,14 @@ static inline uint64_t CVMX_DTX_OSM_SELX(unsigned long offset)
 static inline uint64_t CVMX_DTX_OSM_SELX(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + (offset) * 8;
+
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FEEE0000ull) + (offset) * 8;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800FE6E0000ull) + (offset) * 8;
 }
@@ -2630,6 +2808,7 @@ static inline uint64_t CVMX_DTX_PEMX_BCST_RSP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PEMX_BCST_RSP(%lu) is invalid on this chip\n", offset);
@@ -2644,6 +2823,7 @@ static inline uint64_t CVMX_DTX_PEMX_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PEMX_CTL(%lu) is invalid on this chip\n", offset);
@@ -2658,6 +2838,7 @@ static inline uint64_t CVMX_DTX_PEMX_DATX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && (((block_id >= 1) && (block_id <= 3))))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_PEMX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2672,6 +2853,7 @@ static inline uint64_t CVMX_DTX_PEMX_ENAX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && (((block_id >= 1) && (block_id <= 3))))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_PEMX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2686,6 +2868,7 @@ static inline uint64_t CVMX_DTX_PEMX_SELX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && (((block_id >= 1) && (block_id <= 3))))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_PEMX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2753,7 +2936,7 @@ static inline uint64_t CVMX_DTX_PIP_SELX(unsigned long offset)
 #define CVMX_DTX_PKI_PBE_BCST_RSP CVMX_DTX_PKI_PBE_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PBE_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_PKI_PBE_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE228080ull);
 }
@@ -2764,7 +2947,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_BCST_RSP_FUNC(void)
 #define CVMX_DTX_PKI_PBE_CTL CVMX_DTX_PKI_PBE_CTL_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PBE_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_PKI_PBE_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE228060ull);
 }
@@ -2776,6 +2959,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PBE_DATX(%lu) is invalid on this chip\n", offset);
@@ -2789,6 +2973,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PBE_ENAX(%lu) is invalid on this chip\n", offset);
@@ -2802,6 +2987,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PBE_SELX(%lu) is invalid on this chip\n", offset);
@@ -2814,7 +3000,7 @@ static inline uint64_t CVMX_DTX_PKI_PBE_SELX(unsigned long offset)
 #define CVMX_DTX_PKI_PFE_BCST_RSP CVMX_DTX_PKI_PFE_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PFE_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_PKI_PFE_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE220080ull);
 }
@@ -2825,7 +3011,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_BCST_RSP_FUNC(void)
 #define CVMX_DTX_PKI_PFE_CTL CVMX_DTX_PKI_PFE_CTL_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PFE_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_PKI_PFE_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE220060ull);
 }
@@ -2837,6 +3023,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PFE_DATX(%lu) is invalid on this chip\n", offset);
@@ -2850,6 +3037,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PFE_ENAX(%lu) is invalid on this chip\n", offset);
@@ -2863,6 +3051,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PFE_SELX(%lu) is invalid on this chip\n", offset);
@@ -2875,7 +3064,7 @@ static inline uint64_t CVMX_DTX_PKI_PFE_SELX(unsigned long offset)
 #define CVMX_DTX_PKI_PIX_BCST_RSP CVMX_DTX_PKI_PIX_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PIX_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_PKI_PIX_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE230080ull);
 }
@@ -2886,7 +3075,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_BCST_RSP_FUNC(void)
 #define CVMX_DTX_PKI_PIX_CTL CVMX_DTX_PKI_PIX_CTL_FUNC()
 static inline uint64_t CVMX_DTX_PKI_PIX_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_PKI_PIX_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE230060ull);
 }
@@ -2898,6 +3087,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PIX_DATX(%lu) is invalid on this chip\n", offset);
@@ -2911,6 +3101,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PIX_ENAX(%lu) is invalid on this chip\n", offset);
@@ -2924,6 +3115,7 @@ static inline uint64_t CVMX_DTX_PKI_PIX_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PKI_PIX_SELX(%lu) is invalid on this chip\n", offset);
@@ -2940,6 +3132,10 @@ static inline uint64_t CVMX_DTX_PKO_BCST_RSP_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -2957,6 +3153,10 @@ static inline uint64_t CVMX_DTX_PKO_BCST_RSP_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0080ull);
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280080ull);
@@ -2972,6 +3172,10 @@ static inline uint64_t CVMX_DTX_PKO_CTL_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -2989,6 +3193,10 @@ static inline uint64_t CVMX_DTX_PKO_CTL_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0060ull);
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280060ull);
@@ -3003,6 +3211,12 @@ static inline uint64_t CVMX_DTX_PKO_DATX(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + ((offset) & 1) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + ((offset) & 1) * 8;
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + ((offset) & 1) * 8;
 			break;
@@ -3021,6 +3235,10 @@ static inline uint64_t CVMX_DTX_PKO_DATX(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + (offset) * 8;
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0040ull) + (offset) * 8;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280040ull) + (offset) * 8;
@@ -3035,6 +3253,12 @@ static inline uint64_t CVMX_DTX_PKO_ENAX(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + ((offset) & 1) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + ((offset) & 1) * 8;
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + ((offset) & 1) * 8;
 			break;
@@ -3053,6 +3277,10 @@ static inline uint64_t CVMX_DTX_PKO_ENAX(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + (offset) * 8;
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0020ull) + (offset) * 8;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280020ull) + (offset) * 8;
@@ -3067,6 +3295,12 @@ static inline uint64_t CVMX_DTX_PKO_SELX(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + ((offset) & 1) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + ((offset) & 1) * 8;
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + ((offset) & 1) * 8;
 			break;
@@ -3085,6 +3319,10 @@ static inline uint64_t CVMX_DTX_PKO_SELX(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + (offset) * 8;
 			return CVMX_ADD_IO_SEG(0x00011800FEAA0000ull) + (offset) * 8;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800FE280000ull) + (offset) * 8;
@@ -3371,7 +3609,7 @@ static inline uint64_t CVMX_DTX_PSM_SELX(unsigned long offset)
 #define CVMX_DTX_RAD_BCST_RSP CVMX_DTX_RAD_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_RAD_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_RAD_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE380080ull);
 }
@@ -3382,7 +3620,7 @@ static inline uint64_t CVMX_DTX_RAD_BCST_RSP_FUNC(void)
 #define CVMX_DTX_RAD_CTL CVMX_DTX_RAD_CTL_FUNC()
 static inline uint64_t CVMX_DTX_RAD_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_RAD_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE380060ull);
 }
@@ -3394,6 +3632,7 @@ static inline uint64_t CVMX_DTX_RAD_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RAD_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE380040ull) + ((offset) & 1) * 8;
@@ -3406,6 +3645,7 @@ static inline uint64_t CVMX_DTX_RAD_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RAD_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE380020ull) + ((offset) & 1) * 8;
@@ -3418,6 +3658,7 @@ static inline uint64_t CVMX_DTX_RAD_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RAD_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE380000ull) + ((offset) & 1) * 8;
@@ -3594,7 +3835,7 @@ static inline uint64_t CVMX_DTX_RMAP_SELX(unsigned long offset)
 #define CVMX_DTX_RNM_BCST_RSP CVMX_DTX_RNM_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_RNM_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_RNM_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE200080ull);
 }
@@ -3605,7 +3846,7 @@ static inline uint64_t CVMX_DTX_RNM_BCST_RSP_FUNC(void)
 #define CVMX_DTX_RNM_CTL CVMX_DTX_RNM_CTL_FUNC()
 static inline uint64_t CVMX_DTX_RNM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_RNM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE200060ull);
 }
@@ -3617,6 +3858,7 @@ static inline uint64_t CVMX_DTX_RNM_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RNM_DATX(%lu) is invalid on this chip\n", offset);
@@ -3630,6 +3872,7 @@ static inline uint64_t CVMX_DTX_RNM_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RNM_ENAX(%lu) is invalid on this chip\n", offset);
@@ -3643,6 +3886,7 @@ static inline uint64_t CVMX_DTX_RNM_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RNM_SELX(%lu) is invalid on this chip\n", offset);
@@ -3655,7 +3899,7 @@ static inline uint64_t CVMX_DTX_RNM_SELX(unsigned long offset)
 #define CVMX_DTX_RST_BCST_RSP CVMX_DTX_RST_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_RST_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_RST_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE030080ull);
 }
@@ -3666,7 +3910,7 @@ static inline uint64_t CVMX_DTX_RST_BCST_RSP_FUNC(void)
 #define CVMX_DTX_RST_CTL CVMX_DTX_RST_CTL_FUNC()
 static inline uint64_t CVMX_DTX_RST_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_RST_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE030060ull);
 }
@@ -3679,6 +3923,7 @@ static inline uint64_t CVMX_DTX_RST_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RST_DATX(%lu) is invalid on this chip\n", offset);
@@ -3693,6 +3938,7 @@ static inline uint64_t CVMX_DTX_RST_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RST_ENAX(%lu) is invalid on this chip\n", offset);
@@ -3707,6 +3953,7 @@ static inline uint64_t CVMX_DTX_RST_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_RST_SELX(%lu) is invalid on this chip\n", offset);
@@ -3777,7 +4024,7 @@ static inline uint64_t CVMX_DTX_SATA_SELX(unsigned long offset)
 #define CVMX_DTX_SLI_BCST_RSP CVMX_DTX_SLI_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_SLI_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_SLI_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8080ull);
 }
@@ -3788,7 +4035,7 @@ static inline uint64_t CVMX_DTX_SLI_BCST_RSP_FUNC(void)
 #define CVMX_DTX_SLI_CTL CVMX_DTX_SLI_CTL_FUNC()
 static inline uint64_t CVMX_DTX_SLI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_SLI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE8F8060ull);
 }
@@ -3801,6 +4048,7 @@ static inline uint64_t CVMX_DTX_SLI_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SLI_DATX(%lu) is invalid on this chip\n", offset);
@@ -3815,6 +4063,7 @@ static inline uint64_t CVMX_DTX_SLI_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SLI_ENAX(%lu) is invalid on this chip\n", offset);
@@ -3829,6 +4078,7 @@ static inline uint64_t CVMX_DTX_SLI_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SLI_SELX(%lu) is invalid on this chip\n", offset);
@@ -3951,7 +4201,7 @@ static inline uint64_t CVMX_DTX_SRIOX_SELX(unsigned long offset, unsigned long b
 #define CVMX_DTX_SSO_BCST_RSP CVMX_DTX_SSO_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_SSO_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_SSO_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEB38080ull);
 }
@@ -3962,7 +4212,7 @@ static inline uint64_t CVMX_DTX_SSO_BCST_RSP_FUNC(void)
 #define CVMX_DTX_SSO_CTL CVMX_DTX_SSO_CTL_FUNC()
 static inline uint64_t CVMX_DTX_SSO_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_SSO_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FEB38060ull);
 }
@@ -3974,6 +4224,7 @@ static inline uint64_t CVMX_DTX_SSO_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SSO_DATX(%lu) is invalid on this chip\n", offset);
@@ -3987,6 +4238,7 @@ static inline uint64_t CVMX_DTX_SSO_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SSO_ENAX(%lu) is invalid on this chip\n", offset);
@@ -4000,6 +4252,7 @@ static inline uint64_t CVMX_DTX_SSO_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_SSO_SELX(%lu) is invalid on this chip\n", offset);
@@ -4067,7 +4320,7 @@ static inline uint64_t CVMX_DTX_TDEC_SELX(unsigned long offset)
 #define CVMX_DTX_TIM_BCST_RSP CVMX_DTX_TIM_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_TIM_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_TIM_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0080ull);
 }
@@ -4078,7 +4331,7 @@ static inline uint64_t CVMX_DTX_TIM_BCST_RSP_FUNC(void)
 #define CVMX_DTX_TIM_CTL CVMX_DTX_TIM_CTL_FUNC()
 static inline uint64_t CVMX_DTX_TIM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_DTX_TIM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE2C0060ull);
 }
@@ -4091,6 +4344,7 @@ static inline uint64_t CVMX_DTX_TIM_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_TIM_DATX(%lu) is invalid on this chip\n", offset);
@@ -4105,6 +4359,7 @@ static inline uint64_t CVMX_DTX_TIM_ENAX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_TIM_ENAX(%lu) is invalid on this chip\n", offset);
@@ -4119,6 +4374,7 @@ static inline uint64_t CVMX_DTX_TIM_SELX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_TIM_SELX(%lu) is invalid on this chip\n", offset);
@@ -4251,6 +4507,7 @@ static inline uint64_t CVMX_DTX_USBDRDX_SELX(unsigned long offset, unsigned long
 static inline uint64_t CVMX_DTX_USBHX_BCST_RSP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_DTX_USBHX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE340080ull);
@@ -4262,6 +4519,7 @@ static inline uint64_t CVMX_DTX_USBHX_BCST_RSP(unsigned long offset)
 static inline uint64_t CVMX_DTX_USBHX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_DTX_USBHX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE340060ull);
@@ -4273,6 +4531,7 @@ static inline uint64_t CVMX_DTX_USBHX_CTL(unsigned long offset)
 static inline uint64_t CVMX_DTX_USBHX_DATX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_USBHX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340040ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
@@ -4284,6 +4543,7 @@ static inline uint64_t CVMX_DTX_USBHX_DATX(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_DTX_USBHX_ENAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_USBHX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340020ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
@@ -4295,6 +4555,7 @@ static inline uint64_t CVMX_DTX_USBHX_ENAX(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_DTX_USBHX_SELX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_DTX_USBHX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE340000ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
@@ -4749,7 +5010,7 @@ static inline uint64_t CVMX_DTX_XSX_SELX(unsigned long offset)
 #define CVMX_DTX_ZIP_BCST_RSP CVMX_DTX_ZIP_BCST_RSP_FUNC()
 static inline uint64_t CVMX_DTX_ZIP_BCST_RSP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_ZIP_BCST_RSP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0080ull);
 }
@@ -4760,7 +5021,7 @@ static inline uint64_t CVMX_DTX_ZIP_BCST_RSP_FUNC(void)
 #define CVMX_DTX_ZIP_CTL CVMX_DTX_ZIP_CTL_FUNC()
 static inline uint64_t CVMX_DTX_ZIP_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_DTX_ZIP_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0060ull);
 }
@@ -4772,6 +5033,7 @@ static inline uint64_t CVMX_DTX_ZIP_DATX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ZIP_DATX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0040ull) + ((offset) & 1) * 8;
@@ -4784,6 +5046,7 @@ static inline uint64_t CVMX_DTX_ZIP_ENAX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ZIP_ENAX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0020ull) + ((offset) & 1) * 8;
@@ -4796,6 +5059,7 @@ static inline uint64_t CVMX_DTX_ZIP_SELX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_ZIP_SELX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE1C0000ull) + ((offset) & 1) * 8;
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
index 342c855..e05569c 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
@@ -67,6 +67,10 @@ static inline uint64_t CVMX_FPA_ADDR_RANGE_ERROR_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x0001280000000458ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x0001280000000458ull);
 			return CVMX_ADD_IO_SEG(0x0001280000000458ull);
 			break;
 	}
@@ -87,6 +91,10 @@ static inline uint64_t CVMX_FPA_ADDR_RANGE_ERROR_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001280000000458ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001280000000458ull);
 			return CVMX_ADD_IO_SEG(0x0001280000000458ull);
 	}
 	return CVMX_ADD_IO_SEG(0x0001280000000458ull);
@@ -97,6 +105,7 @@ static inline uint64_t CVMX_FPA_AURAX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_FPA_AURAX_CFG(%lu) is invalid on this chip\n", offset);
@@ -110,6 +119,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT(%lu) is invalid on this chip\n", offset);
@@ -123,6 +133,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_ADD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_ADD(%lu) is invalid on this chip\n", offset);
@@ -136,6 +147,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_LEVELS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_LEVELS(%lu) is invalid on this chip\n", offset);
@@ -149,6 +161,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_LIMIT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_LIMIT(%lu) is invalid on this chip\n", offset);
@@ -162,6 +175,7 @@ static inline uint64_t CVMX_FPA_AURAX_CNT_THRESHOLD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_FPA_AURAX_CNT_THRESHOLD(%lu) is invalid on this chip\n", offset);
@@ -175,6 +189,7 @@ static inline uint64_t CVMX_FPA_AURAX_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_FPA_AURAX_INT(%lu) is invalid on this chip\n", offset);
@@ -188,6 +203,7 @@ static inline uint64_t CVMX_FPA_AURAX_POOL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_FPA_AURAX_POOL(%lu) is invalid on this chip\n", offset);
@@ -201,6 +217,7 @@ static inline uint64_t CVMX_FPA_AURAX_POOL_LEVELS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_FPA_AURAX_POOL_LEVELS(%lu) is invalid on this chip\n", offset);
@@ -232,6 +249,10 @@ static inline uint64_t CVMX_FPA_BIST_STATUS_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00012800000000E8ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00012800000000E8ull);
 			return CVMX_ADD_IO_SEG(0x00012800000000E8ull);
 			break;
 	}
@@ -260,6 +281,10 @@ static inline uint64_t CVMX_FPA_BIST_STATUS_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00012800000000E8ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00012800000000E8ull);
 			return CVMX_ADD_IO_SEG(0x00012800000000E8ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00012800000000E8ull);
@@ -269,7 +294,7 @@ static inline uint64_t CVMX_FPA_BIST_STATUS_FUNC(void)
 #define CVMX_FPA_CLK_COUNT CVMX_FPA_CLK_COUNT_FUNC()
 static inline uint64_t CVMX_FPA_CLK_COUNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_FPA_CLK_COUNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00012800000000F0ull);
 }
@@ -281,7 +306,7 @@ static inline uint64_t CVMX_FPA_CLK_COUNT_FUNC(void)
 #define CVMX_FPA_ECC_CTL CVMX_FPA_ECC_CTL_FUNC()
 static inline uint64_t CVMX_FPA_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_FPA_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000058ull);
 }
@@ -292,7 +317,7 @@ static inline uint64_t CVMX_FPA_ECC_CTL_FUNC(void)
 #define CVMX_FPA_ECC_INT CVMX_FPA_ECC_INT_FUNC()
 static inline uint64_t CVMX_FPA_ECC_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_FPA_ECC_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000068ull);
 }
@@ -303,7 +328,7 @@ static inline uint64_t CVMX_FPA_ECC_INT_FUNC(void)
 #define CVMX_FPA_ERR_INT CVMX_FPA_ERR_INT_FUNC()
 static inline uint64_t CVMX_FPA_ERR_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_FPA_ERR_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000040ull);
 }
@@ -403,7 +428,7 @@ static inline uint64_t CVMX_FPA_FPFX_SIZE(unsigned long offset)
 #define CVMX_FPA_GEN_CFG CVMX_FPA_GEN_CFG_FUNC()
 static inline uint64_t CVMX_FPA_GEN_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_FPA_GEN_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000050ull);
 }
@@ -428,6 +453,7 @@ static inline uint64_t CVMX_FPA_POOLX_AVAILABLE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_FPA_POOLX_AVAILABLE(%lu) is invalid on this chip\n", offset);
@@ -441,6 +467,7 @@ static inline uint64_t CVMX_FPA_POOLX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_FPA_POOLX_CFG(%lu) is invalid on this chip\n", offset);
@@ -470,8 +497,13 @@ static inline uint64_t CVMX_FPA_POOLX_END_ADDR(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001280010600000ull) + ((offset) & 31) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x0001280010600000ull) + ((offset) & 63) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x0001280010600000ull) + ((offset) & 63) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x0001280010600000ull) + ((offset) & 63) * 8;
+
 			break;
 	}
 	cvmx_warn("CVMX_FPA_POOLX_END_ADDR (offset = %lu) not supported on this chip\n", offset);
@@ -492,7 +524,11 @@ static inline uint64_t CVMX_FPA_POOLX_END_ADDR(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010600000ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001280010600000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001280010600000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001280010600000ull) + (offset) * 8;
+
 	}
 	return CVMX_ADD_IO_SEG(0x0001280010600000ull) + (offset) * 8;
 }
@@ -502,6 +538,7 @@ static inline uint64_t CVMX_FPA_POOLX_FPF_MARKS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_FPA_POOLX_FPF_MARKS(%lu) is invalid on this chip\n", offset);
@@ -515,6 +552,7 @@ static inline uint64_t CVMX_FPA_POOLX_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_FPA_POOLX_INT(%lu) is invalid on this chip\n", offset);
@@ -528,6 +566,7 @@ static inline uint64_t CVMX_FPA_POOLX_OP_PC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_FPA_POOLX_OP_PC(%lu) is invalid on this chip\n", offset);
@@ -541,6 +580,7 @@ static inline uint64_t CVMX_FPA_POOLX_STACK_ADDR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_FPA_POOLX_STACK_ADDR(%lu) is invalid on this chip\n", offset);
@@ -554,6 +594,7 @@ static inline uint64_t CVMX_FPA_POOLX_STACK_BASE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_FPA_POOLX_STACK_BASE(%lu) is invalid on this chip\n", offset);
@@ -567,6 +608,7 @@ static inline uint64_t CVMX_FPA_POOLX_STACK_END(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_FPA_POOLX_STACK_END(%lu) is invalid on this chip\n", offset);
@@ -596,8 +638,13 @@ static inline uint64_t CVMX_FPA_POOLX_START_ADDR(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001280010500000ull) + ((offset) & 31) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x0001280010500000ull) + ((offset) & 63) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x0001280010500000ull) + ((offset) & 63) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x0001280010500000ull) + ((offset) & 63) * 8;
+
 			break;
 	}
 	cvmx_warn("CVMX_FPA_POOLX_START_ADDR (offset = %lu) not supported on this chip\n", offset);
@@ -618,7 +665,11 @@ static inline uint64_t CVMX_FPA_POOLX_START_ADDR(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010500000ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001280010500000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001280010500000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001280010500000ull) + (offset) * 8;
+
 	}
 	return CVMX_ADD_IO_SEG(0x0001280010500000ull) + (offset) * 8;
 }
@@ -645,8 +696,13 @@ static inline uint64_t CVMX_FPA_POOLX_THRESHOLD(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001280010400000ull) + ((offset) & 31) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x0001280010400000ull) + ((offset) & 63) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x0001280010400000ull) + ((offset) & 63) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x0001280010400000ull) + ((offset) & 63) * 8;
+
 			break;
 	}
 	cvmx_warn("CVMX_FPA_POOLX_THRESHOLD (offset = %lu) not supported on this chip\n", offset);
@@ -668,7 +724,11 @@ static inline uint64_t CVMX_FPA_POOLX_THRESHOLD(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001280010400000ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001280010400000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001280010400000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001280010400000ull) + (offset) * 8;
+
 	}
 	return CVMX_ADD_IO_SEG(0x0001280010400000ull) + (offset) * 8;
 }
@@ -744,7 +804,7 @@ static inline uint64_t CVMX_FPA_QUEX_PAGE_INDEX(unsigned long offset)
 #define CVMX_FPA_RD_LATENCY_PC CVMX_FPA_RD_LATENCY_PC_FUNC()
 static inline uint64_t CVMX_FPA_RD_LATENCY_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_FPA_RD_LATENCY_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000610ull);
 }
@@ -755,7 +815,7 @@ static inline uint64_t CVMX_FPA_RD_LATENCY_PC_FUNC(void)
 #define CVMX_FPA_RD_REQ_PC CVMX_FPA_RD_REQ_PC_FUNC()
 static inline uint64_t CVMX_FPA_RD_REQ_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_FPA_RD_REQ_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000600ull);
 }
@@ -766,7 +826,7 @@ static inline uint64_t CVMX_FPA_RD_REQ_PC_FUNC(void)
 #define CVMX_FPA_RED_DELAY CVMX_FPA_RED_DELAY_FUNC()
 static inline uint64_t CVMX_FPA_RED_DELAY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_FPA_RED_DELAY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000100ull);
 }
@@ -777,7 +837,7 @@ static inline uint64_t CVMX_FPA_RED_DELAY_FUNC(void)
 #define CVMX_FPA_SFT_RST CVMX_FPA_SFT_RST_FUNC()
 static inline uint64_t CVMX_FPA_SFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_FPA_SFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001280000000000ull);
 }
@@ -890,11 +950,12 @@ union cvmx_fpa_aurax_cfg {
                                                          Note specific requests to change the count, including FPA_AURA()_CNT_ADD,
                                                          PKO_SEND_AURA_S, or PKI_AURA()_CFG[PKT_ADD] will be applied regardless of the
                                                          setting of this bit. */
-	uint64_t avg_con                      : 9;  /**< This value controls how much of each present average resource level is used to calculate
-                                                         the new resource level. The value is a number from 0 to 256, which represents AVG_CON/256
-                                                         of the average resource level that will be used in the calculation:
-                                                         _  next_LEVEL = (AVG_CON/256) * prev_LEVEL
-                                                         _  + (1-(AVG_CON/256)) * count
+	uint64_t avg_con                      : 9;  /**< This value controls how much of each present average resource level is used to
+                                                         calculate the new resource level. The value is a number from 0 to 256, which
+                                                         represents [AVG_CON]/256 of the average resource level that will be used in the
+                                                         calculation:
+                                                         _  next_LEVEL = ([AVG_CON]/256) * prev_LEVEL
+                                                         _  + (1-([AVG_CON]/256)) * count
                                                          Note setting this value to zero will disable averaging, and always use the most immediate
                                                          levels. FPA_GEN_CFG[AVG_EN] must be set and FPA_GEN_CFG[LVL_DLY] must be nonzero to
                                                          globally enable averaging. FPA_RED_DELAY[AVG_DLY] controls the periodicity of the level
@@ -3294,8 +3355,7 @@ union cvmx_fpa_poolx_available {
 	struct cvmx_fpa_poolx_available_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t count                        : 36; /**< The number of free pages available in this pool. INTERNAL: Sized for 41 bit address - 7
-                                                         bit cache line. */
+	uint64_t count                        : 36; /**< The number of free pages available in this pool. */
 #else
 	uint64_t count                        : 36;
 	uint64_t reserved_36_63               : 28;
@@ -3338,9 +3398,10 @@ union cvmx_fpa_poolx_cfg {
                                                          1 = use STT. */
 	uint64_t nat_align                    : 1;  /**< Returning buffers should be rounded to the nearest natural alignment specified with
                                                          [BUF_SIZE]. */
-	uint64_t ena                          : 1;  /**< Enable. Must be set after writing pool configuration, if clear any allocations will fail
-                                                         and returns will be dropped. If any pool configuration is changed after writing this bit,
-                                                         the FPA may operate incorrectly. */
+	uint64_t ena                          : 1;  /**< Enable. Must be set after writing pool configuration, if clear any allocations
+                                                         will fail and returns will be dropped. If any pool configuration is changed
+                                                         while this bit is set (or until traffic is quiesced after clearing), the FPA may
+                                                         operate incorrectly. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t nat_align                    : 1;
@@ -3425,9 +3486,7 @@ union cvmx_fpa_poolx_fpf_marks {
                                                          _  where, fpf_sz = 108 * 2^FPA_GEN_CFG[POOLS].
                                                          The maximum value is fpf_sz - 48.
                                                          It is recommended that software APIs represent this value as a percentage of fpf_sz, as
-                                                         fpf_sz may vary between products.
-                                                         INTERNAL: The worse case buffer requirement is:
-                                                         (memory_latency + 16 * (num_pools_active - 1) / cycles_per_alloc */
+                                                         fpf_sz may vary between products. */
 	uint64_t reserved_11_15               : 5;
 	uint64_t fpf_level                    : 11; /**< The current number of free-page pointers in the pool, in entries. For diagnostic use. */
 #else
@@ -3925,7 +3984,7 @@ union cvmx_fpa_red_delay {
                                                          100 M packets/sec, 1.2 GHz coprocessor clock, approximately 160 packets may arrive between
                                                          average calculations.
                                                          Larger FPA_GEN_CFG[LVL_DLY] values cause the backpressure indications and moving averages
-                                                         of all aura levels to track changes in the actual free space more slowly. Larger AVG_DLY
+                                                         of all aura levels to track changes in the actual free space more slowly. Larger [AVG_DLY]
                                                          also causes the moving averages of all aura levels to track changes in the actual free
                                                          space more slowly, but does not affect backpressure. Larger
                                                          FPA_AURA()_CFG[AVG_CON]) values causes a specific aura to track more slowly, but
diff --git a/arch/mips/include/asm/octeon/cvmx-global-resources.h b/arch/mips/include/asm/octeon/cvmx-global-resources.h
index 4d7bea9..a450bda 100644
--- a/arch/mips/include/asm/octeon/cvmx-global-resources.h
+++ b/arch/mips/include/asm/octeon/cvmx-global-resources.h
@@ -1,3 +1,48 @@
+/***********************license start***************
+ * Copyright (c) 2012-2015  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * <hr>$Revision: 121767 $<hr>
+ */
+
 #ifndef _CVMX_GLOBAL_RESOURCES_T_
 #define _CVMX_GLOBAL_RESOURCES_T_
 
diff --git a/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h b/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h
index 13b1d79..7e1a2761 100644
--- a/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h
@@ -10627,7 +10627,7 @@ typedef union cvmx_gmxx_txx_append cvmx_gmxx_txx_append_t;
  * cvmx_gmx#_tx#_bck_crdt
  *
  * gmi_tx_bck to gmi_tx_out credit count register
- * INTERNAL: Do not add this register to the HRM
+ *
  */
 union cvmx_gmxx_txx_bck_crdt {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
index d058df9..4da558f 100644
--- a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
@@ -78,8 +78,13 @@ static inline uint64_t CVMX_GPIO_BIT_CFGX(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001070000000900ull) + ((offset) & 31) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 19))
-				return CVMX_ADD_IO_SEG(0x0001070000000900ull) + ((offset) & 31) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 19))
+					return CVMX_ADD_IO_SEG(0x0001070000000900ull) + ((offset) & 31) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 19))
+					return CVMX_ADD_IO_SEG(0x0001070000000900ull) + ((offset) & 31) * 8;
+
 			break;
 	}
 	cvmx_warn("CVMX_GPIO_BIT_CFGX (offset = %lu) not supported on this chip\n", offset);
@@ -107,7 +112,11 @@ static inline uint64_t CVMX_GPIO_BIT_CFGX(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070000000900ull) + (offset) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001070000000900ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001070000000900ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001070000000900ull) + (offset) * 8;
+
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000900ull) + (offset) * 8;
 }
@@ -135,6 +144,7 @@ static inline uint64_t CVMX_GPIO_CLK_GENX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
@@ -165,6 +175,7 @@ static inline uint64_t CVMX_GPIO_CLK_SYNCEX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_GPIO_CLK_SYNCEX(%lu) is invalid on this chip\n", offset);
@@ -177,7 +188,7 @@ static inline uint64_t CVMX_GPIO_CLK_SYNCEX(unsigned long offset)
 #define CVMX_GPIO_COMP CVMX_GPIO_COMP_FUNC()
 static inline uint64_t CVMX_GPIO_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_GPIO_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000D00ull);
 }
@@ -200,6 +211,7 @@ static inline uint64_t CVMX_GPIO_INTRX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_GPIO_INTRX(%lu) is invalid on this chip\n", offset);
@@ -214,6 +226,7 @@ static inline uint64_t CVMX_GPIO_MC_INTRX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 4) && (offset <= 7)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset >= 4) && (offset <= 7)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset >= 4) && (offset <= 7)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset >= 4) && (offset <= 7))))))
 		cvmx_warn("CVMX_GPIO_MC_INTRX(%lu) is invalid on this chip\n", offset);
@@ -239,7 +252,7 @@ static inline uint64_t CVMX_GPIO_MC_INTRX_W1S(unsigned long offset)
 #define CVMX_GPIO_MULTI_CAST CVMX_GPIO_MULTI_CAST_FUNC()
 static inline uint64_t CVMX_GPIO_MULTI_CAST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_GPIO_MULTI_CAST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010700000008B0ull);
 }
@@ -250,7 +263,7 @@ static inline uint64_t CVMX_GPIO_MULTI_CAST_FUNC(void)
 #define CVMX_GPIO_OCLA_EXTEN_TRIG CVMX_GPIO_OCLA_EXTEN_TRIG_FUNC()
 static inline uint64_t CVMX_GPIO_OCLA_EXTEN_TRIG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_GPIO_OCLA_EXTEN_TRIG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010700000008B8ull);
 }
@@ -307,7 +320,7 @@ static inline uint64_t CVMX_GPIO_SATA_LAB_LB_FUNC(void)
 #define CVMX_GPIO_TIM_CTL CVMX_GPIO_TIM_CTL_FUNC()
 static inline uint64_t CVMX_GPIO_TIM_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_GPIO_TIM_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00010700000008A0ull);
 }
@@ -337,7 +350,11 @@ static inline uint64_t CVMX_GPIO_USBH_CTL_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00010700000008A0ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001070000000898ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x0001070000000898ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x0001070000000898ull);
+
 			break;
 	}
 	cvmx_warn("CVMX_GPIO_USBH_CTL not supported on this chip\n");
@@ -351,7 +368,11 @@ static inline uint64_t CVMX_GPIO_USBH_CTL_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00010700000008A0ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001070000000898ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001070000000898ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001070000000898ull);
+
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000898ull);
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index d3a2e0f..a028651 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -57,6 +57,7 @@ static inline uint64_t CVMX_GSERX_ANA_ATEST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_ANA_ATEST(%lu) is invalid on this chip\n", offset);
@@ -70,6 +71,7 @@ static inline uint64_t CVMX_GSERX_ANA_SEL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_ANA_SEL(%lu) is invalid on this chip\n", offset);
@@ -83,6 +85,7 @@ static inline uint64_t CVMX_GSERX_BR_RXX_CTL(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_BR_RXX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -96,6 +99,7 @@ static inline uint64_t CVMX_GSERX_BR_RXX_EER(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_BR_RXX_EER(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -109,6 +113,7 @@ static inline uint64_t CVMX_GSERX_BR_TXX_CTL(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_BR_TXX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -122,6 +127,7 @@ static inline uint64_t CVMX_GSERX_BR_TXX_CUR(unsigned long offset, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_BR_TXX_CUR(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -159,6 +165,7 @@ static inline uint64_t CVMX_GSERX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_CFG(%lu) is invalid on this chip\n", offset);
@@ -172,6 +179,7 @@ static inline uint64_t CVMX_GSERX_DBG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_DBG(%lu) is invalid on this chip\n", offset);
@@ -537,6 +545,7 @@ static inline uint64_t CVMX_GSERX_EQ_WAIT_TIME(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_EQ_WAIT_TIME(%lu) is invalid on this chip\n", offset);
@@ -550,6 +559,7 @@ static inline uint64_t CVMX_GSERX_GLBL_MISC_CONFIG_1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_GLBL_MISC_CONFIG_1(%lu) is invalid on this chip\n", offset);
@@ -563,6 +573,7 @@ static inline uint64_t CVMX_GSERX_GLBL_PLL_CFG_0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_GLBL_PLL_CFG_0(%lu) is invalid on this chip\n", offset);
@@ -576,6 +587,7 @@ static inline uint64_t CVMX_GSERX_GLBL_PLL_CFG_1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_GLBL_PLL_CFG_1(%lu) is invalid on this chip\n", offset);
@@ -589,6 +601,7 @@ static inline uint64_t CVMX_GSERX_GLBL_PLL_CFG_2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_GLBL_PLL_CFG_2(%lu) is invalid on this chip\n", offset);
@@ -602,6 +615,7 @@ static inline uint64_t CVMX_GSERX_GLBL_PLL_CFG_3(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_GLBL_PLL_CFG_3(%lu) is invalid on this chip\n", offset);
@@ -615,6 +629,7 @@ static inline uint64_t CVMX_GSERX_GLBL_PLL_MONITOR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_GLBL_PLL_MONITOR(%lu) is invalid on this chip\n", offset);
@@ -628,6 +643,7 @@ static inline uint64_t CVMX_GSERX_GLBL_TAD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_GLBL_TAD(%lu) is invalid on this chip\n", offset);
@@ -641,6 +657,7 @@ static inline uint64_t CVMX_GSERX_GLBL_TM_ADMON(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_GLBL_TM_ADMON(%lu) is invalid on this chip\n", offset);
@@ -654,6 +671,7 @@ static inline uint64_t CVMX_GSERX_IDDQ_MODE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_IDDQ_MODE(%lu) is invalid on this chip\n", offset);
@@ -667,6 +685,7 @@ static inline uint64_t CVMX_GSERX_LANEX_LBERT_CFG(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_LBERT_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -680,6 +699,7 @@ static inline uint64_t CVMX_GSERX_LANEX_LBERT_ECNT(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_LBERT_ECNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -693,6 +713,7 @@ static inline uint64_t CVMX_GSERX_LANEX_LBERT_PAT_CFG(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_LBERT_PAT_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -706,6 +727,7 @@ static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_0(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_MISC_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -719,6 +741,7 @@ static inline uint64_t CVMX_GSERX_LANEX_MISC_CFG_1(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_MISC_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -732,6 +755,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_0(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -745,6 +769,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_1(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -758,6 +783,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_CTLIFC_2(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_CTLIFC_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -771,6 +797,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PCS_MACIFC_MON_2(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PCS_MACIFC_MON_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -784,6 +811,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(unsigned long offset,
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -797,6 +825,7 @@ static inline uint64_t CVMX_GSERX_LANEX_PWR_CTRL(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_PWR_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -810,6 +839,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_0(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -823,6 +853,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_1(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -836,6 +867,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_2(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_AEQ_OUT_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -849,6 +881,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_1(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_CTRL_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -862,6 +895,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_CTRL_2(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_CTRL_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -875,6 +909,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_MISC_CTRL_0(unsigned long offset,
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_MISC_CTRL_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -888,6 +923,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_1(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_STATUS_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -901,6 +937,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CDR_STATUS_2(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CDR_STATUS_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -914,6 +951,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_0(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -927,6 +965,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_1(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -940,6 +979,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_2(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -953,6 +993,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_3(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_3(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -966,6 +1007,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_4(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_4(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -979,6 +1021,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CFG_5(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CFG_5(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -992,6 +1035,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CTLE_CTRL(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_CTLE_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1005,6 +1049,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_LOOP_CTRL(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_LOOP_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1018,6 +1063,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_MISC_OVRRD(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_MISC_OVRRD(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1031,6 +1077,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_CTRL(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_PRECORR_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1044,6 +1091,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_VAL(unsigned long offset, uns
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_PRECORR_VAL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1057,6 +1105,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_0(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VALBBD_CTRL_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1070,6 +1119,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_1(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VALBBD_CTRL_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1083,6 +1133,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VALBBD_CTRL_2(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VALBBD_CTRL_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1096,6 +1147,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_CTRL(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1109,6 +1161,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_0(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_STATUS_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1122,6 +1175,7 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_VMA_STATUS_1(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_RX_VMA_STATUS_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1174,6 +1228,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_0(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1187,6 +1242,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_1(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1200,6 +1256,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_2(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1213,6 +1270,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_CFG_3(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_CFG_3(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1226,6 +1284,7 @@ static inline uint64_t CVMX_GSERX_LANEX_TX_PRE_EMPHASIS(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANEX_TX_PRE_EMPHASIS(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1239,6 +1298,7 @@ static inline uint64_t CVMX_GSERX_LANE_LPBKEN(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_LANE_LPBKEN(%lu) is invalid on this chip\n", offset);
@@ -1252,6 +1312,7 @@ static inline uint64_t CVMX_GSERX_LANE_MODE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_LANE_MODE(%lu) is invalid on this chip\n", offset);
@@ -1265,6 +1326,7 @@ static inline uint64_t CVMX_GSERX_LANE_POFF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_LANE_POFF(%lu) is invalid on this chip\n", offset);
@@ -1278,6 +1340,7 @@ static inline uint64_t CVMX_GSERX_LANE_PX_MODE_0(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 11)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 11)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANE_PX_MODE_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1291,6 +1354,7 @@ static inline uint64_t CVMX_GSERX_LANE_PX_MODE_1(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 11)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 11)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_LANE_PX_MODE_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1304,6 +1368,7 @@ static inline uint64_t CVMX_GSERX_LANE_SRST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_LANE_SRST(%lu) is invalid on this chip\n", offset);
@@ -1317,6 +1382,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_0(%lu) is invalid on this chip\n", offset);
@@ -1330,6 +1396,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_1(%lu) is invalid on this chip\n", offset);
@@ -1343,6 +1410,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_COARSE_CTRL_2(%lu) is invalid on this chip\n", offset);
@@ -1356,6 +1424,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_0(%lu) is invalid on this chip\n", offset);
@@ -1369,6 +1438,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_1(%lu) is invalid on this chip\n", offset);
@@ -1382,6 +1452,7 @@ static inline uint64_t CVMX_GSERX_LANE_VMA_FINE_CTRL_2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_LANE_VMA_FINE_CTRL_2(%lu) is invalid on this chip\n", offset);
@@ -1769,6 +1840,7 @@ static inline uint64_t CVMX_GSERX_PHY_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_PHY_CTL(%lu) is invalid on this chip\n", offset);
@@ -1782,6 +1854,7 @@ static inline uint64_t CVMX_GSERX_PIPE_LPBK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_PIPE_LPBK(%lu) is invalid on this chip\n", offset);
@@ -1795,6 +1868,7 @@ static inline uint64_t CVMX_GSERX_PLL_PX_MODE_0(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 11)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 11)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_PLL_PX_MODE_0(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1808,6 +1882,7 @@ static inline uint64_t CVMX_GSERX_PLL_PX_MODE_1(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 11)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 11)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 11)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 11)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_PLL_PX_MODE_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1821,6 +1896,7 @@ static inline uint64_t CVMX_GSERX_PLL_STAT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_PLL_STAT(%lu) is invalid on this chip\n", offset);
@@ -1834,6 +1910,7 @@ static inline uint64_t CVMX_GSERX_QLM_STAT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_QLM_STAT(%lu) is invalid on this chip\n", offset);
@@ -1847,6 +1924,7 @@ static inline uint64_t CVMX_GSERX_RDET_TIME(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_RDET_TIME(%lu) is invalid on this chip\n", offset);
@@ -1886,6 +1964,7 @@ static inline uint64_t CVMX_GSERX_REFCLK_SEL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_REFCLK_SEL(%lu) is invalid on this chip\n", offset);
@@ -1899,6 +1978,7 @@ static inline uint64_t CVMX_GSERX_RX_COAST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_RX_COAST(%lu) is invalid on this chip\n", offset);
@@ -1912,6 +1992,7 @@ static inline uint64_t CVMX_GSERX_RX_EIE_DETEN(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_RX_EIE_DETEN(%lu) is invalid on this chip\n", offset);
@@ -1925,6 +2006,7 @@ static inline uint64_t CVMX_GSERX_RX_EIE_DETSTS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_RX_EIE_DETSTS(%lu) is invalid on this chip\n", offset);
@@ -1938,6 +2020,7 @@ static inline uint64_t CVMX_GSERX_RX_EIE_FILTER(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_RX_EIE_FILTER(%lu) is invalid on this chip\n", offset);
@@ -1951,6 +2034,7 @@ static inline uint64_t CVMX_GSERX_RX_POLARITY(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_RX_POLARITY(%lu) is invalid on this chip\n", offset);
@@ -1964,6 +2048,7 @@ static inline uint64_t CVMX_GSERX_RX_PWR_CTRL_P1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_RX_PWR_CTRL_P1(%lu) is invalid on this chip\n", offset);
@@ -1977,6 +2062,7 @@ static inline uint64_t CVMX_GSERX_RX_PWR_CTRL_P2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_RX_PWR_CTRL_P2(%lu) is invalid on this chip\n", offset);
@@ -1986,12 +2072,27 @@ static inline uint64_t CVMX_GSERX_RX_PWR_CTRL_P2(unsigned long offset)
 #define CVMX_GSERX_RX_PWR_CTRL_P2(offset) (CVMX_ADD_IO_SEG(0x00011800904600B8ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_RX_TXDIR_CTRL_0(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
+		cvmx_warn("CVMX_GSERX_RX_TXDIR_CTRL_0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800904600E8ull) + ((offset) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_RX_TXDIR_CTRL_0(offset) (CVMX_ADD_IO_SEG(0x00011800904600E8ull) + ((offset) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_RX_TXDIR_CTRL_1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 13)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_RX_TXDIR_CTRL_1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800904600F0ull) + ((offset) & 15) * 0x1000000ull;
 }
@@ -1999,6 +2100,20 @@ static inline uint64_t CVMX_GSERX_RX_TXDIR_CTRL_1(unsigned long offset)
 #define CVMX_GSERX_RX_TXDIR_CTRL_1(offset) (CVMX_ADD_IO_SEG(0x00011800904600F0ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_RX_TXDIR_CTRL_2(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
+		cvmx_warn("CVMX_GSERX_RX_TXDIR_CTRL_2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800904600F8ull) + ((offset) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_RX_TXDIR_CTRL_2(offset) (CVMX_ADD_IO_SEG(0x00011800904600F8ull) + ((offset) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SATA_CFG(unsigned long offset)
 {
 	if (!(
@@ -2239,6 +2354,7 @@ static inline uint64_t CVMX_GSERX_SCRATCH(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_SCRATCH(%lu) is invalid on this chip\n", offset);
@@ -2252,6 +2368,7 @@ static inline uint64_t CVMX_GSERX_SLICEX_RX_SDLL_CTRL(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 8))))))
 		cvmx_warn("CVMX_GSERX_SLICEX_RX_SDLL_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -2265,6 +2382,7 @@ static inline uint64_t CVMX_GSERX_SLICE_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_SLICE_CFG(%lu) is invalid on this chip\n", offset);
@@ -2278,6 +2396,7 @@ static inline uint64_t CVMX_GSERX_SPD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_SPD(%lu) is invalid on this chip\n", offset);
@@ -2313,6 +2432,7 @@ static inline uint64_t CVMX_GSERX_SRST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_SRST(%lu) is invalid on this chip\n", offset);
@@ -2352,6 +2472,7 @@ static inline uint64_t CVMX_GSERX_TX_VBOOST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_TX_VBOOST(%lu) is invalid on this chip\n", offset);
@@ -2686,21 +2807,16 @@ union cvmx_gserx_cfg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t rmac_pipe                    : 1;  /**< When set, indicates the RMAC is configured for PIPE mode - the two lanes of
-                                                         the DLM are used in PIPE mode. [RMAC_PIPE] must only be set when [RMAC] is set.
-                                                         INTERNAL: The hardware ignores [RMAC_PIPE] when [RMAC] is clear. */
+                                                         the DLM are used in PIPE mode. [RMAC_PIPE] must only be set when [RMAC] is set. */
 	uint64_t rmac                         : 1;  /**< When set, indicates the GSER is configured for RMAC mode. [RMAC] must not be set
                                                          when any of [BGX,PCIE,SRIO] are set. [RMAC] must only be set for DLM6, DLM7, and
                                                          DLM8 (i.e. GSER6, GSER7, and GSER8). */
 	uint64_t srio                         : 1;  /**< When set, indicates the GSER is configured for SRIO mode. [SRIO] must not be set
-                                                         when any of [BGX,PCIE,RMAC] are set. [BGX] must only be set for QLM2 and QLM3
+                                                         when any of [BGX,PCIE,RMAC] are set. [SRIO] must only be set for QLM2 and QLM3
                                                          (i.e. GSER2 and GSER3). */
 	uint64_t sata                         : 1;  /**< Reserved. */
-	uint64_t bgx_quad                     : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         XAUI/DXAUI/XLAUI not supported on o75. */
-	uint64_t bgx_dual                     : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         RXAUI not supported on o75. */
+	uint64_t bgx_quad                     : 1;  /**< Reserved. */
+	uint64_t bgx_dual                     : 1;  /**< Reserved. */
 	uint64_t bgx                          : 1;  /**< When set, indicates the GSER is configured for BGX mode. [BGX] must not be set
                                                          when any of [SRIO,PCIE,RMAC] are set. [BGX] must only be set for DLM4 and DLM5
                                                          (i.e. GSER4 and GSER5). */
@@ -2730,19 +2846,13 @@ union cvmx_gserx_cfg {
                                                          set when [BGX] is set and [BGX_DUAL] is clear.
                                                          When [BGX_QUAD] is set, GSER bundles all four lanes for one BGX controller.
                                                          [BGX_QUAD] must only be set for the XAUI/DXAUI and XLAUI protocols.
-                                                         [BGX_QUAD] must not be set in a DLM.
-                                                         INTERNAL:
-                                                         There is hardware to pair DLM 5 and 6 together when [BGX_QUAD] is set in DLM5.
-                                                         But we currently do not support XAUI/DXAUI/XLAUI on DLM's. */
+                                                         [BGX_QUAD] must not be set in a DLM. */
 	uint64_t bgx_dual                     : 1;  /**< When set, indicates the QLM is in BGX dual aggregation mode. [BGX_DUAL] must only be
                                                          set when [BGX] is also set and [BGX_QUAD] is clear.
                                                          When [BGX_DUAL] is set, GSER bundles lanes 0 and 1 for one BGX controller and bundles
                                                          lanes 2 and 3 for another BGX controller. [BGX_DUAL] must only be set for the RXAUI
                                                          protocol.
-                                                         [BGX_DUAL] must not be set in a DLM.
-                                                         INTERNAL:
-                                                         [BGX_DUAL] should work in a DLM (lanes 0 and 1 bundled for one BGX controller), but
-                                                         we currently do not support RXAUI in a DLM. */
+                                                         [BGX_DUAL] must not be set in a DLM. */
 	uint64_t bgx                          : 1;  /**< When set, indicates the GSER is configured for BGX mode. [BGX] must not be set
                                                          when either of [SATA,PCIE] are set.
                                                          When [BGX] is set and both [BGX_DUAL,BGX_QUAD] are clear, GSER exposes each lane to an
@@ -2766,25 +2876,20 @@ union cvmx_gserx_cfg {
 	uint64_t bgx_quad                     : 1;  /**< When set, indicates the QLM is in BGX quad aggregation mode. [BGX_QUAD] must only be
                                                          set when [BGX] is set and [BGX_DUAL] is clear.
                                                          When [BGX_QUAD] is set, GSER bundles all four lanes for one BGX controller.
-                                                         [BGX_QUAD] must only be set for the XAUI/DXAUI and XLAUI protocols.
-                                                         INTERNAL: Not used in CCPI QLMs. */
+                                                         [BGX_QUAD] must only be set for the XAUI/DXAUI and XLAUI protocols. */
 	uint64_t bgx_dual                     : 1;  /**< When set, indicates the QLM is in BGX dual aggregation mode. [BGX_DUAL] must only be
                                                          set when [BGX] is also set and [BGX_QUAD] is clear.
                                                          When [BGX_DUAL] is set, GSER bundles lanes 0 and 1 for one BGX controller and bundles
                                                          lanes 2 and 3 for another BGX controller. [BGX_DUAL] must only be set for the RXAUI
-                                                         protocol.
-                                                         INTERNAL: Not used in CCPI QLMs. */
+                                                         protocol. */
 	uint64_t bgx                          : 1;  /**< When set, indicates the GSER is configured for BGX mode. [BGX] must not be set
                                                          when either of [ILA,PCIE] are set. For CCPI links, [BGX] must be clear.
                                                          When [BGX] is set and both [BGX_DUAL,BGX_QUAD] are clear, GSER exposes each lane to an
-                                                         independent BGX controller.
-                                                         INTERNAL: Not used in CCPI QLMs. */
+                                                         independent BGX controller. */
 	uint64_t ila                          : 1;  /**< When set, indicates the GSER is configured for ILK/ILA/CCPI mode. [ILA] must not be set
-                                                         when either of [BGX,PCIE] are set. For CCPI QLMs, [ILA] must be set.
-                                                         INTERNAL: [ILA] will be set for CCPI QLMs, but isn't used. */
+                                                         when either of [BGX,PCIE] are set. For CCPI QLMs, [ILA] must be set. */
 	uint64_t pcie                         : 1;  /**< When set, indicates the GSER is configured for PCIE mode. [PCIE] must not be
-                                                         set when either of [ILA,BGX] are set. For CCPI QLMs, [PCIE] must be clear.
-                                                         INTERNAL: Not used in CCPI QLMs. */
+                                                         set when either of [ILA,BGX] are set. For CCPI QLMs, [PCIE] must be clear. */
 #else
 	uint64_t pcie                         : 1;
 	uint64_t ila                          : 1;
@@ -4157,7 +4262,7 @@ union cvmx_gserx_lanex_lbert_cfg {
                                                          0x6 = lfsr11 = X^11 + X^9 + 1.
                                                          0x7 = lfsr7  = X^7 + X^6 + 1.
                                                          0x8 = Fixed word (PAT0).
-                                                         0x9 = DC-balanced word (PAT0, ~PAT0)
+                                                         0x9 = DC-balanced word (PAT0, ~PAT0).
                                                          0xA = Fixed Pattern (000, PAT0, 3ff, ~PAT0).
                                                          0xB-F = Reserved. */
 	uint64_t lbert_pm_en                  : 1;  /**< Enable LBERT pattern matcher. */
@@ -4618,16 +4723,11 @@ union cvmx_gserx_lanex_pcs_macifc_mon_2 {
 	struct cvmx_gserx_lanex_pcs_macifc_mon_2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t tx_coeff_req                 : 1;  /**< Indicates current state of the MAC to PCS Tx Coefficient Request input.
-                                                         INTERNAL: mac_pcs_txX_coeff_req. */
-	uint64_t tx_vboost_en                 : 1;  /**< Indicates current state of the MAC to PCS Tx Vboost Enable input.
-                                                         INTERNAL: mac_pcs_txX_vboost_en. */
-	uint64_t tx_swing                     : 5;  /**< Indicates current state of the MAC to PCS Tx Equalizer Swing<4:0> input.
-                                                         INTERNAL: mac_pcs_txX_swing[4:0]. */
-	uint64_t tx_pre                       : 4;  /**< Indicates current state of the MAC to PCS Tx Equalizer Pre Emphasis<3:0> input.
-                                                         INTERNAL: mac_pcs_txX_pre[3:0]. */
-	uint64_t tx_post                      : 5;  /**< Indicates current state of the MAC to PCS Tx Equalizer Post Emphasis<4:0> input.
-                                                         INTERNAL: mac_pcs_txX_post[4:0]. */
+	uint64_t tx_coeff_req                 : 1;  /**< Indicates current state of the MAC to PCS Tx Coefficient Request input. */
+	uint64_t tx_vboost_en                 : 1;  /**< Indicates current state of the MAC to PCS Tx Vboost Enable input. */
+	uint64_t tx_swing                     : 5;  /**< Indicates current state of the MAC to PCS Tx Equalizer Swing<4:0> input. */
+	uint64_t tx_pre                       : 4;  /**< Indicates current state of the MAC to PCS Tx Equalizer Pre Emphasis<3:0> input. */
+	uint64_t tx_post                      : 5;  /**< Indicates current state of the MAC to PCS Tx Equalizer Post Emphasis<4:0> input. */
 #else
 	uint64_t tx_post                      : 5;
 	uint64_t tx_pre                       : 4;
@@ -5232,11 +5332,11 @@ union cvmx_gserx_lanex_rx_cfg_2 {
                                                          are set.
                                                          <9:8>: Reserved.
                                                          <7:4>: Pre-CTLE (continuous time linear equalizer) gain (steps of approximately 0.75dB):
-                                                         _ 0x0 = -6dB
-                                                         _ 0x1 = -5dB
+                                                         _ 0x0 = -6dB.
+                                                         _ 0x1 = -5dB.
                                                          _ 0xF = +5dB.
                                                          <3:0>: Post-CTLE gain (steps of 0.0875):
-                                                         _ 0x0 = lowest
+                                                         _ 0x0 = lowest.
                                                          _ 0xF = lowest * 2.3125.
                                                          Recommended settings:
                                                          When auto-negotiated link training is not present, non-PCIe, and link speed <
@@ -5247,8 +5347,7 @@ union cvmx_gserx_lanex_rx_cfg_2 {
                                                          peaking.
                                                          The [RX_SDS_RX_AGC_MVAL] settings should be derived from signal integrity
                                                          simulations with the IBIS-AMI model supplied by Cavium when
-                                                         GSER()_LANE()_RX_CFG_5[RX_AGC_MEN_OVRRD_EN,RX_AGC_MEN_OVRRD_VAL] are set.
-                                                         INTERNAL: reset value may be reasonable default settings. */
+                                                         GSER()_LANE()_RX_CFG_5[RX_AGC_MEN_OVRRD_EN,RX_AGC_MEN_OVRRD_VAL] are set. */
 #else
 	uint64_t rx_sds_rx_agc_mval           : 10;
 	uint64_t reserved_10_10               : 1;
@@ -6396,7 +6495,7 @@ union cvmx_gserx_lanex_tx_cfg_1 {
                                                          0x1 = 1/2 data rate.
                                                          0x2 = 1/4 data rate.
                                                          0x3 = 1/8 data rate.
-                                                         0x4 = 1/18 data rate.
+                                                         0x4 = 1/16 data rate.
                                                          0x5-7 = Reserved. */
 	uint64_t tx_datarate_ovrrd_en         : 1;  /**< Override enable for RX Power state machine data rate signal. When set, rx_datarate is
                                                          specified from TX_DATA_RATE_OVRRD_VAL and the RX Power State Machine control signal is
@@ -6590,8 +6689,8 @@ union cvmx_gserx_lane_lpbken {
 	uint64_t reserved_4_63                : 60;
 	uint64_t lpbken                       : 4;  /**< For links that are not in PCIE nor SATA mode. When asserted in P0 state,
                                                          allows per lane TX-to-RX serial loopback activation.
-                                                         <3>: Lane 3.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
-                                                         <2>: Lane 2.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <3>: Lane 3.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <2>: Lane 2.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
                                                          <1>: Lane 1.
                                                          <0>: Lane 0. */
 #else
@@ -6674,8 +6773,8 @@ union cvmx_gserx_lane_px_mode_0 {
 	uint64_t reserved_15_63               : 49;
 	uint64_t ctle                         : 2;  /**< Continuous time linear equalizer pole configuration.
                                                          0x0 = ~5dB of peaking at 4 GHz (Minimum bandwidth).
-                                                         0x1 =~10dB of peaking at 5 GHz
-                                                         0x2 = ~15dB of peaking at 5.5 GHz
+                                                         0x1 =~10dB of peaking at 5 GHz.
+                                                         0x2 = ~15dB of peaking at 5.5 GHz.
                                                          0x3 = ~20dB of peaking at 6 GHz (Maximum bandwidth).
                                                          Recommended settings:
                                                          <pre>
@@ -6732,10 +6831,10 @@ union cvmx_gserx_lane_px_mode_0 {
                                                          </pre>
                                                          A 'NS' indicates that the rate is not supported at the specified reference clock. */
 	uint64_t rx_ldiv                      : 2;  /**< Configures clock divider used to determine the receive rate.
-                                                         0x0 = full data rate
-                                                         0x1 = 1/2 data rate
-                                                         0x2 = 1/4 data rate
-                                                         0x3 = 1/8 data rate
+                                                         0x0 = full data rate.
+                                                         0x1 = 1/2 data rate.
+                                                         0x2 = 1/4 data rate.
+                                                         0x3 = 1/8 data rate.
                                                          Recommended settings:
                                                          <pre>
                                                          _ R_25G_REFCLK100:          0x1
@@ -6754,11 +6853,11 @@ union cvmx_gserx_lane_px_mode_0 {
                                                          A 'NS' indicates that the rate is not supported at the specified reference clock. */
 	uint64_t srate                        : 3;  /**< Sample rate, used to generate strobe to effectively divide the clock down to a slower
                                                          rate.
-                                                         0x0 = Full rate
-                                                         0x1 = 1/2 data rate
-                                                         0x2 = 1/4 data rate
-                                                         0x3 = 1/8 data rate
-                                                         0x4 = 1/16 data rate
+                                                         0x0 = Full rate.
+                                                         0x1 = 1/2 data rate.
+                                                         0x2 = 1/4 data rate.
+                                                         0x3 = 1/8 data rate.
+                                                         0x4 = 1/16 data rate.
                                                          else = Reserved.
                                                          This field should always be cleared to zero (i.e. full rate selected). */
 	uint64_t reserved_4_4                 : 1;
@@ -7096,16 +7195,16 @@ union cvmx_gserx_lane_vma_fine_ctrl_2 {
 	struct cvmx_gserx_lane_vma_fine_ctrl_2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
-	uint64_t rx_prectle_peak_max_fine     : 4;  /**< RX PRE-CTLE peak maximum value in VMA fine mode (valid when
+	uint64_t rx_prectle_gain_max_fine     : 4;  /**< RX PRE-CTLE gain maximum value in VMA fine mode (valid when
                                                          GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
-	uint64_t rx_prectle_peak_min_fine     : 4;  /**< RX PRE-CTLE peak minimum value in VMA fine mode (valid when
+	uint64_t rx_prectle_gain_min_fine     : 4;  /**< RX PRE-CTLE gain minimum value in VMA fine mode (valid when
                                                          GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
-	uint64_t rx_prectle_peak_step_fine    : 2;  /**< RX PRE-CTLE peak step size in VMA fine mode (valid when
+	uint64_t rx_prectle_gain_step_fine    : 2;  /**< RX PRE-CTLE gain step size in VMA fine mode (valid when
                                                          GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
 #else
-	uint64_t rx_prectle_peak_step_fine    : 2;
-	uint64_t rx_prectle_peak_min_fine     : 4;
-	uint64_t rx_prectle_peak_max_fine     : 4;
+	uint64_t rx_prectle_gain_step_fine    : 2;
+	uint64_t rx_prectle_gain_min_fine     : 4;
+	uint64_t rx_prectle_gain_max_fine     : 4;
 	uint64_t reserved_10_63               : 54;
 #endif
 	} s;
@@ -8564,6 +8663,8 @@ typedef union cvmx_gserx_refclk_evt_ctrl cvmx_gserx_refclk_evt_ctrl_t;
  * This register selects the reference clock.
  * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
+ *
+ * Not used with GSER6, GSER7, and GSER8.
  */
 union cvmx_gserx_refclk_sel {
 	uint64_t u64;
@@ -8574,12 +8675,10 @@ union cvmx_gserx_refclk_sel {
                                                          PCIE0/2_REFCLK_125 at cold reset and indicates a 125 MHz reference clock when set. For
                                                          non-bootable PCIe links, this bit is set to zero at cold reset and indicates a 100 MHz
                                                          reference clock. It is not used for non-PCIe links. */
-	uint64_t com_clk_sel                  : 1;  /**< When set, the reference clock is sourced from the external clock mux. For bootable PCIe
-                                                         links, this bit is loaded with the PCIEn_COM0_CLK_EN pin at cold reset. */
+	uint64_t com_clk_sel                  : 1;  /**< When set, the reference clock is sourced from the external clock mux. */
 	uint64_t use_com1                     : 1;  /**< This bit controls the external mux select. When set, QLMC_REF_CLK1_N/P
                                                          are selected as the reference clock. When clear, QLMC_REF_CLK0_N/P are selected as the
-                                                         reference clock.
-                                                         INTERNAL: For non-CCPI links. */
+                                                         reference clock. */
 #else
 	uint64_t use_com1                     : 1;
 	uint64_t com_clk_sel                  : 1;
@@ -8611,8 +8710,8 @@ union cvmx_gserx_rx_coast {
                                                          exit (GSER()_RX_EIE_DETSTS[EIESTS]). Once the COAST signal deasserts, the CDR is
                                                          allowed to lock. In BGX mode, the BGX MAC can also control the COAST inputs to the PHY to
                                                          allow Auto-Negotiation for backplane Ethernet. For diagnostic use only.
-                                                         <3>: Lane 3.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
-                                                         <2>: Lane 2.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <3>: Lane 3.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <2>: Lane 2.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
                                                          <1>: Lane 1.
                                                          <0>: Lane 0. */
 #else
@@ -8643,8 +8742,8 @@ union cvmx_gserx_rx_eie_deten {
                                                          GSER()_RX_EIE_DETSTS[EIELTCH] is asserted. EIEDE defaults to the enabled state. Once
                                                          EIE has been detected, EIEDE must be disabled, and then enabled again to perform another
                                                          EIE detection.
-                                                         <3>: Lane 3.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
-                                                         <2>: Lane 2.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <3>: Lane 3.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <2>: Lane 2.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
                                                          <1>: Lane 1.
                                                          <0>: Lane 0. */
 #else
@@ -8671,8 +8770,8 @@ union cvmx_gserx_rx_eie_detsts {
                                                          lock. During this time, there may be RX bit errors. These bits will set when the CDR is
                                                          guaranteed to be locked. Note that link training can't start until the lane CDRLOCK is
                                                          set. Software can use CDRLOCK to determine when to expect error free RX data.
-                                                         <11>: Lane 3.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
-                                                         <10>: Lane 2.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <11>: Lane 3.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <10>: Lane 2.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
                                                          <9>: Lane 1.
                                                          <8>: Lane 0. */
 	uint64_t eiests                       : 4;  /**< When electrical idle exit detection is enabled (GSER()_RX_EIE_DETEN[EIEDE] is
@@ -8681,8 +8780,8 @@ union cvmx_gserx_rx_eie_detsts {
                                                          idle symbols) for data transitions to be detected and for EIESTS to stay set accordingly.
                                                          Under most conditions, EIESTS
                                                          will stay asserted until GSER()_RX_EIE_DETEN[EIEDE] is deasserted.
-                                                         <7>: Lane 3.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
-                                                         <6>: Lane 2.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <7>: Lane 3.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <6>: Lane 2.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
                                                          <5>: Lane 1.
                                                          <4>: Lane 0. */
 	uint64_t eieltch                      : 4;  /**< When electrical idle exit detection is enabled (GSER()_RX_EIE_DETEN[EIEDE] is
@@ -8691,8 +8790,8 @@ union cvmx_gserx_rx_eie_detsts {
                                                          GSER()_RX_EIE_DETEN[EIEDE] is deasserted. Note that there may be RX bit errors until
                                                          CDRLOCK
                                                          is set.
-                                                         <3>: Lane 3.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
-                                                         <2>: Lane 2.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <3>: Lane 3.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <2>: Lane 2.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
                                                          <1>: Lane 1.
                                                          <0>: Lane 0. */
 #else
@@ -8760,8 +8859,8 @@ union cvmx_gserx_rx_polarity {
 	uint64_t rx_inv                       : 4;  /**< For links that are not in PCIE mode, control signal to invert
                                                          the polarity of received data. When asserted, the polarity of the received data is
                                                          inverted.
-                                                         <3>: Lane 3.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
-                                                         <2>: Lane 2.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <3>: Lane 3.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <2>: Lane 2.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
                                                          <1>: Lane 1.
                                                          <0>: Lane 0. */
 #else
@@ -8879,6 +8978,52 @@ union cvmx_gserx_rx_pwr_ctrl_p2 {
 typedef union cvmx_gserx_rx_pwr_ctrl_p2 cvmx_gserx_rx_pwr_ctrl_p2_t;
 
 /**
+ * cvmx_gser#_rx_txdir_ctrl_0
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_rx_txdir_ctrl_0 {
+	uint64_t u64;
+	struct cvmx_gserx_rx_txdir_ctrl_0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_13_63               : 51;
+	uint64_t rx_boost_hi_thrs             : 4;  /**< The high threshold for RX Boost.
+                                                         The far-end TX POST direction output, pcs_mac_rx_txpost_dir, is set to
+                                                         INCREMENT if the local RX boost value from the VMA (after RX-EQ) is
+                                                         higher than this value, and the local RX tap1 value is higher than its
+                                                         high threshold GSER()_RX_TXDIR_CTRL_1[RX_TAP1_HI_THRS].
+                                                         Note, that if GSER()_RX_TXDIR_CTRL_1[RX_TAP1_CHG_DIR]=1 then
+                                                         the direction is DECREMENT. */
+	uint64_t rx_boost_lo_thrs             : 4;  /**< The low threshold for RX Boost.
+                                                         The far-end TX POST direction output, pcs_mac_rx_txpost_dir, is set to
+                                                         DECREMENT if the local RX boost value from the VMA (after RX-EQ) is
+                                                         lower than this value, and the local RX tap1 value is lower than its
+                                                         low threshold GSER()_RX_TXDIR_CTRL_1[RX_TAP1_LO_THRS].
+                                                         Note, that if GSER()_RX_TXDIR_CTRL_1[RX_TAP1_CHG_DIR]=1 then
+                                                         the direction is INCREMENT. */
+	uint64_t rx_boost_hi_val              : 5;  /**< The far-end TX POST direction output, pcs_mac_rx_txpost_dir,
+                                                         is set to INCREMENT if the local RX boost value from the VMA (after RX-EQ)
+                                                         equals RX_BOOST_HI_VAL.
+                                                         Note, that if GSER()_RX_TXDIR_CTRL_1[RX_TAP1_CHG_DIR]=1 then
+                                                         the direction is DECREMENT.
+                                                         To disable the check against RX_BOOST_HI_VAL, assert RX_BOOST_HI_VAL[4]. */
+#else
+	uint64_t rx_boost_hi_val              : 5;
+	uint64_t rx_boost_lo_thrs             : 4;
+	uint64_t rx_boost_hi_thrs             : 4;
+	uint64_t reserved_13_63               : 51;
+#endif
+	} s;
+	struct cvmx_gserx_rx_txdir_ctrl_0_s   cn73xx;
+	struct cvmx_gserx_rx_txdir_ctrl_0_s   cn78xx;
+	struct cvmx_gserx_rx_txdir_ctrl_0_s   cn78xxp2;
+	struct cvmx_gserx_rx_txdir_ctrl_0_s   cnf75xx;
+};
+typedef union cvmx_gserx_rx_txdir_ctrl_0 cvmx_gserx_rx_txdir_ctrl_0_t;
+
+/**
  * cvmx_gser#_rx_txdir_ctrl_1
  *
  * These registers are for diagnostic use only.
@@ -8894,16 +9039,18 @@ union cvmx_gserx_rx_txdir_ctrl_1 {
 	uint64_t rx_tap1_chg_dir              : 1;  /**< When asserted, the default direction output for the far-end TX Post is reversed. */
 	uint64_t rx_tap1_hi_thrs              : 5;  /**< The high threshold for the local RX Tap1 count.
                                                          The far-end TX POST direction output, pcs_mac_rx_txpost_dir,
-                                                         is set to INCREMENT if the local RX tap1 value from the VMA (after RX-EQ)
+                                                         is set to increment if the local RX tap1 value from the VMA (after RX-EQ)
                                                          is higher than this value, and the local RX boost value is higher than
-                                                         its high threshold (RX_BOOST_HI_THRS). Note that if RX_TAP1_CHG_DIR is asserted,
-                                                         then the direction is DECREMENT. */
+                                                         its high threshold GSER()_RX_TXDIR_CTRL_0[RX_BOOST_HI_THRS].
+                                                         If GSER()_RX_TXDIR_CTRL_1[RX_TAP1_CHG_DIR]=1 then
+                                                         the direction is decrement. */
 	uint64_t rx_tap1_lo_thrs              : 5;  /**< The low threshold for the local RX Tap1 count.
                                                          The far-end TX POST direction output, pcs_mac_rx_txpost_dir,
-                                                         is set to DECREMENT if the local RX tap1 value from the VMA (after RX-EQ)
+                                                         is set to decrement if the local RX tap1 value from the VMA (after RX-EQ)
                                                          is lower than this value, and the local RX boost value is lower than
-                                                         its low threshold (RX_BOOST_LO_THRS). Note that if RX_TAP1_CHG_DIR is asserted,
-                                                         then the direction is INCREMENT. */
+                                                         its low threshold GSER()_RX_TXDIR_CTRL_0[RX_BOOST_LO_THRS].
+                                                         If GSER()_RX_TXDIR_CTRL_1[RX_TAP1_CHG_DIR]=1 then
+                                                         the direction is increment. */
 #else
 	uint64_t rx_tap1_lo_thrs              : 5;
 	uint64_t rx_tap1_hi_thrs              : 5;
@@ -8920,6 +9067,43 @@ union cvmx_gserx_rx_txdir_ctrl_1 {
 typedef union cvmx_gserx_rx_txdir_ctrl_1 cvmx_gserx_rx_txdir_ctrl_1_t;
 
 /**
+ * cvmx_gser#_rx_txdir_ctrl_2
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_rx_txdir_ctrl_2 {
+	uint64_t u64;
+	struct cvmx_gserx_rx_txdir_ctrl_2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t rx_precorr_hi_thrs           : 8;  /**< High threshold for RX precursor correlation count.
+                                                         The far-end TX PRE direction output, pcs_mac_rx_txpre_dir, is set to
+                                                         DECREMENT if the local RX precursor correlation count from the VMA (after RX-EQ)
+                                                         is lower than this value.
+                                                         Note, that if GSER()_RX_TXDIR_CTRL_1[RX_PRECORR_CHG_DIR]=1 then
+                                                         the direction is INCREMENT. */
+	uint64_t rx_precorr_lo_thrs           : 8;  /**< Low threshold for RX precursor correlation count.
+                                                         The far-end TX PRE direction output, pcs_mac_rx_txpre_dir, is set to
+                                                         INCREMENT if the local RX precursor correlation count from the VMA (after RX-EQ)
+                                                         is lower than this value.
+                                                         Note, that if GSER()_RX_TXDIR_CTRL_1[RX_PRECORR_CHG_DIR]=1 then
+                                                         the direction is DECREMENT. */
+#else
+	uint64_t rx_precorr_lo_thrs           : 8;
+	uint64_t rx_precorr_hi_thrs           : 8;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_rx_txdir_ctrl_2_s   cn73xx;
+	struct cvmx_gserx_rx_txdir_ctrl_2_s   cn78xx;
+	struct cvmx_gserx_rx_txdir_ctrl_2_s   cn78xxp2;
+	struct cvmx_gserx_rx_txdir_ctrl_2_s   cnf75xx;
+};
+typedef union cvmx_gserx_rx_txdir_ctrl_2 cvmx_gserx_rx_txdir_ctrl_2_t;
+
+/**
  * cvmx_gser#_sata_cfg
  *
  * SATA Config Enable.
@@ -9499,24 +9683,29 @@ union cvmx_gserx_spd {
                                                          settings of the specific lane mode (LMODE) table entry to derive the correct link rate.
                                                          (changed for pass 2)
                                                          <pre>
-                                                         SPD   REFCLK      Link rate   LMODE
-                                                         0x0:  100 MHz     5 Gb        R_5G_REFCLK100
-                                                         0x1:  100 MHz     2.5 Gb      R_25G_REFCLK100
-                                                         0x2:  100 MHz     5 Gb        R_5G_REFCLK100
-                                                         0x3:  100 MHz     8 Gb        R_8G_REFCLK100
-                                                         0x4:  100 MHz     8 Gb        R_8G_REFCLK100
-                                                         0x5:  100 MHz     8 Gb        R_8G_REFCLK100
-                                                         0x6:  125 MHz     3.125 Gb    R_3125G_REFCLK15625_XAUI
-                                                         0x7:  125 MHz     5 Gb        R_5G_REFCLK125
-                                                         0x8:  125 MHz     6.25 Gb     R_625G_REFCLK15625_RXAUI
-                                                         0x9:  125 MHz     8 Gb        R_8G_REFCLK125
-                                                         0xA:  156.25 MHz  10.3125 Gb  R_103125G_REFCLK15625_KR
-                                                         0xB:  156.25 MHz  3.125 Gb    R_3125G_REFCLK15625_XAUI
-                                                         0xC:  156.25 MHz  5 Gb        R_5G_REFCLK125
-                                                         0xD:  156.25 MHz  6.25 Gb     R_625G_REFCLK15625_RXAUI
-                                                         0xE:  156.25 MHz  10.3125 Gb  R_103125G_REFCLK15625_KR
+                                                               REFCLK  Link Rate
+                                                         SPD   (Mhz)   (Gb)     Train  LMODE
+                                                         ----  ------  ------   -----  -----------------------
+                                                         0x0:  100     5        TS     R_5G_REFCLK100
+                                                         0x1:  100     2.5      --     R_25G_REFCLK100
+                                                         0x2:  100     5        --     R_5G_REFCLK100
+                                                         0x3:  100     8        --     R_8G_REFCLK100
+                                                         0x4:  100     8        TS     R_8G_REFCLK100
+                                                         0x5:  100     8        KR     R_8G_REFCLK100
+                                                         0x6:  125     3.125    --     R_3125G_REFCLK15625_XAUI
+                                                         0x7:  125     5        --     R_5G_REFCLK125
+                                                         0x8:  125     6.25     --     R_625G_REFCLK15625_RXAUI
+                                                         0x9:  125     8        --     R_8G_REFCLK125
+                                                         0xA:  156.25  10.3125  TS     R_103125G_REFCLK15625_KR
+                                                         0xB:  156.25  3.125    --     R_3125G_REFCLK15625_XAUI
+                                                         0xC:  156.25  5        TS     R_5G_REFCLK125
+                                                         0xD:  156.25  6.25     TS     R_625G_REFCLK15625_RXAUI
+                                                         0xE:  156.25  10.3125  KR     R_103125G_REFCLK15625_KR
                                                          0xF:                          SW_MODE
                                                          </pre>
+                                                         Train column indicates training method.  TS indicates short training, i.e., local Rx
+                                                         equalization only.  KR indicates KR training, i.e., local Rx equalization and link
+                                                         partner Tx equalizer adaptation.  -- indicates not applicable.
                                                          Note that a value of 0xF is called SW_MODE. The CCPI link does not come up configured in
                                                          SW_MODE.
                                                          (Software must do all the CCPI GSER configuration to use CCPI in the case of SW_MODE.)
@@ -9671,8 +9860,8 @@ union cvmx_gserx_tx_vboost {
 	uint64_t reserved_4_63                : 60;
 	uint64_t vboost                       : 4;  /**< For links that are not in PCIE mode, boosts the TX Vswing from
                                                          VDD to 1.0 VPPD.
-                                                         <3>: Lane 3.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
-                                                         <2>: Lane 2.  Not supported in GSER2, GSER3, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <3>: Lane 3.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
+                                                         <2>: Lane 2.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
                                                          <1>: Lane 1.
                                                          <0>: Lane 0. */
 #else
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
index 2ec9dd6..92a3115 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
@@ -193,8 +193,8 @@ typedef union cvmx_user_static_pko_queue_config
 	} pknd;
 	struct
 	{
-		uint8_t pko_ports_per_interface[2];
-		uint8_t pko_queues_per_port_interface[2];
+		uint8_t pko_ports_per_interface[5];
+		uint8_t pko_queues_per_port_interface[5];
 		uint8_t pko_queues_per_port_loop;
 		uint8_t pko_queues_per_port_pci;
 		uint8_t pko_queues_per_port_srio[4];
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-ilk.h b/arch/mips/include/asm/octeon/cvmx-helper-ilk.h
index 7697c63..7d7e179 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-ilk.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-ilk.h
@@ -52,12 +52,12 @@ extern int __cvmx_helper_ilk_enumerate(int interface);
 
 /**
  * @INTERNAL
- * Initialize all calendar entries to the xoff state. This
+ * Clear all calendar entries to the xoff state. This
  * means no data is sent or received.
  *
  * @param interface Interface whose calendar are to be initialized.
  */
-extern void __cvmx_ilk_init_cal(int interface);
+extern void __cvmx_ilk_clear_cal(int interface);
 
 /**
  * @INTERNAL
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-pki.h b/arch/mips/include/asm/octeon/cvmx-helper-pki.h
index 6bf02ab..f55224f 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-pki.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-pki.h
@@ -173,10 +173,10 @@ void cvmx_helper_pki_enable(int node);
  * This function frees up PKI resources consumed by that port.
  * This function should only be called if port resources
  * (fpa pools aura, style qpg entry pcam entry etc.) are not shared
- * @param ipd_port      ipd port number for which resources need to
+ * @param xipd_port     ipd port number for which resources need to
  *                      be freed.
  */
-int cvmx_helper_pki_port_shutdown(int ipd_port);
+int cvmx_helper_pki_port_shutdown(int xipd_port);
 
 /**
  * This function shuts down complete PKI hardware
@@ -247,11 +247,11 @@ int cvmx_helper_pki_set_gbl_schd(int node, struct cvmx_pki_global_schd *gblsch);
 /**
  * This function sets up scheduling parameters (pool, aura, sso group etc)
  * of an ipd port.
- * @param ipd_port      ipd port number
+ * @param xipd_port     ipd port number
  * @param prtsch        pointer to struct containing port's
  *                      scheduling parameters.
  */
-int cvmx_helper_pki_init_port(int ipd_port, struct cvmx_pki_prt_schd *prtsch);
+int cvmx_helper_pki_init_port(int xipd_port, struct cvmx_pki_prt_schd *prtsch);
 
 /**
  * This function sets up scheduling parameters (pool, aura, sso group etc)
@@ -268,34 +268,34 @@ int cvmx_helper_pki_init_interface(const int xiface,
 /**
  * This function gets all the PKI parameters related to that
  * particular port from hardware.
- * @param ipd_port      ipd port number to get parameter of
+ * @param xipd_port     ipd port number to get parameter of
  * @param port_cfg      pointer to structure where to store read parameters
  */
-void cvmx_pki_get_port_config(int ipd_port, struct cvmx_pki_port_config *port_cfg);
+void cvmx_pki_get_port_config(int xipd_port, struct cvmx_pki_port_config *port_cfg);
 
 /**
  * This function sets all the PKI parameters related to that
  * particular port in hardware.
- * @param ipd_port      ipd port number to get parameter of
+ * @param xipd_port     ipd port number to get parameter of
  * @param port_cfg      pointer to structure containing port parameters
  */
-void cvmx_pki_set_port_config(int ipd_port, struct cvmx_pki_port_config *port_cfg);
+void cvmx_pki_set_port_config(int xipd_port, struct cvmx_pki_port_config *port_cfg);
 
 /**
  * This function displays all the PKI parameters related to that
  * particular port.
- * @param ipd_port      ipd port number to display parameter of
+ * @param xipd_port      ipd port number to display parameter of
  */
-void cvmx_pki_show_port_config(int ipd_port);
+void cvmx_pki_show_port_config(int xipd_port);
 
 /**
  * Modifies maximum frame length to check.
  * It modifies the global frame length set used by this port, any other
  * port using the same set will get affected too.
- * @param ipd_port	ipd port for which to modify max len.
+ * @param xipd_port	ipd port for which to modify max len.
  * @param max_size	maximum frame length
  */
-void cvmx_pki_set_max_frm_len(int ipd_port, uint32_t max_size);
+void cvmx_pki_set_max_frm_len(int xipd_port, uint32_t max_size);
 
 /**
  * This function sets up all the ports of particular interface
@@ -355,17 +355,17 @@ void cvmx_helper_pki_set_dflt_bp_en(int node, bool bp_en);
 
 void cvmx_pki_dump_wqe(const cvmx_wqe_78xx_t *wqp);
 
-int __cvmx_helper_pki_port_setup(int node, int ipd_port);
+int __cvmx_helper_pki_port_setup(int node, int xipd_port);
 
 int __cvmx_helper_pki_global_setup(int node);
-void cvmx_helper_pki_show_port_config(int ipd_port);
+void cvmx_helper_pki_show_port_config(int xipd_port);
 
 int __cvmx_helper_pki_install_dflt_vlan(int node);
 void __cvmx_helper_pki_set_dflt_ltype_map(int node);
 int cvmx_helper_pki_route_dmac(int node, int style, uint64_t mac_addr, uint64_t mac_addr_mask, int final_style);
 int cvmx_pki_clone_style(int node, int style, uint64_t cluster_mask);
-void cvmx_helper_pki_modify_prtgrp(int ipd_port, int grp_ok, int grp_bad);
-int cvmx_helper_pki_route_prt_dmac(int ipd_port, uint64_t mac_addr, uint64_t mac_addr_mask, int grp);
+void cvmx_helper_pki_modify_prtgrp(int xipd_port, int grp_ok, int grp_bad);
+int cvmx_helper_pki_route_prt_dmac(int xipd_port, uint64_t mac_addr, uint64_t mac_addr_mask, int grp);
 
 void cvmx_helper_pki_errata(int node);
 
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-pko3.h b/arch/mips/include/asm/octeon/cvmx-helper-pko3.h
index 7a4dc3e..deec8e2 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-pko3.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-pko3.h
@@ -113,6 +113,13 @@ int cvmx_helper_pko3_config_dump(unsigned int node);
  */
 int cvmx_helper_pko3_stats_dump(unsigned int node);
 
+/**
+ * Clear PKO statistics.
+ *
+ * @param node	   node number
+ */
+void cvmx_helper_pko3_stats_clear(unsigned int node);
+
 #ifdef	__cplusplus
 /* *INDENT-OFF* */
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-util.h b/arch/mips/include/asm/octeon/cvmx-helper-util.h
index e2e31ea..da09162 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-util.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-util.h
@@ -42,7 +42,7 @@
  *
  * Small helper utilities.
  *
- * <hr>$Revision: 123112 $<hr>
+ * <hr>$Revision: 127654 $<hr>
  */
 
 #ifndef __CVMX_HELPER_UTIL_H__
diff --git a/arch/mips/include/asm/octeon/cvmx-hna-defs.h b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
index 3641bfe..c1fff88 100644
--- a/arch/mips/include/asm/octeon/cvmx-hna-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_HNA_BIST0 CVMX_HNA_BIST0_FUNC()
 static inline uint64_t CVMX_HNA_BIST0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_BIST0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470007F0ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_HNA_BIST0_FUNC(void)
 #define CVMX_HNA_BIST1 CVMX_HNA_BIST1_FUNC()
 static inline uint64_t CVMX_HNA_BIST1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_BIST1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470007F8ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_HNA_BIST1_FUNC(void)
 #define CVMX_HNA_CONFIG CVMX_HNA_CONFIG_FUNC()
 static inline uint64_t CVMX_HNA_CONFIG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_CONFIG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000000ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_HNA_CONFIG_FUNC(void)
 #define CVMX_HNA_CONTROL CVMX_HNA_CONTROL_FUNC()
 static inline uint64_t CVMX_HNA_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_CONTROL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000020ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_HNA_CONTROL_FUNC(void)
 #define CVMX_HNA_DBELL CVMX_HNA_DBELL_FUNC()
 static inline uint64_t CVMX_HNA_DBELL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_DBELL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001470000000000ull);
 }
@@ -111,7 +111,7 @@ static inline uint64_t CVMX_HNA_DBELL_FUNC(void)
 #define CVMX_HNA_DIFCTL CVMX_HNA_DIFCTL_FUNC()
 static inline uint64_t CVMX_HNA_DIFCTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_DIFCTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001470600000000ull);
 }
@@ -122,7 +122,7 @@ static inline uint64_t CVMX_HNA_DIFCTL_FUNC(void)
 #define CVMX_HNA_DIFRDPTR CVMX_HNA_DIFRDPTR_FUNC()
 static inline uint64_t CVMX_HNA_DIFRDPTR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_DIFRDPTR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001470200000000ull);
 }
@@ -144,7 +144,7 @@ static inline uint64_t CVMX_HNA_ECO_FUNC(void)
 #define CVMX_HNA_ERROR CVMX_HNA_ERROR_FUNC()
 static inline uint64_t CVMX_HNA_ERROR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_ERROR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000028ull);
 }
@@ -155,7 +155,7 @@ static inline uint64_t CVMX_HNA_ERROR_FUNC(void)
 #define CVMX_HNA_ERROR_CAPTURE_DATA CVMX_HNA_ERROR_CAPTURE_DATA_FUNC()
 static inline uint64_t CVMX_HNA_ERROR_CAPTURE_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_ERROR_CAPTURE_DATA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000038ull);
 }
@@ -166,7 +166,7 @@ static inline uint64_t CVMX_HNA_ERROR_CAPTURE_DATA_FUNC(void)
 #define CVMX_HNA_ERROR_CAPTURE_INFO CVMX_HNA_ERROR_CAPTURE_INFO_FUNC()
 static inline uint64_t CVMX_HNA_ERROR_CAPTURE_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_ERROR_CAPTURE_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000030ull);
 }
@@ -178,6 +178,7 @@ static inline uint64_t CVMX_HNA_HNC0_RAM1X(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_HNA_HNC0_RAM1X(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001470400000000ull) + ((offset) & 63) * 8;
@@ -190,6 +191,7 @@ static inline uint64_t CVMX_HNA_HNC0_RAM2X(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_HNA_HNC0_RAM2X(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001470400040000ull) + ((offset) & 63) * 8;
@@ -202,6 +204,7 @@ static inline uint64_t CVMX_HNA_HNC1_RAM1X(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_HNA_HNC1_RAM1X(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001470400400000ull) + ((offset) & 63) * 8;
@@ -214,6 +217,7 @@ static inline uint64_t CVMX_HNA_HNC1_RAM2X(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_HNA_HNC1_RAM2X(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001470400440000ull) + ((offset) & 63) * 8;
@@ -225,7 +229,7 @@ static inline uint64_t CVMX_HNA_HNC1_RAM2X(unsigned long offset)
 #define CVMX_HNA_HPU_CSR CVMX_HNA_HPU_CSR_FUNC()
 static inline uint64_t CVMX_HNA_HPU_CSR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_HPU_CSR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000010ull);
 }
@@ -236,7 +240,7 @@ static inline uint64_t CVMX_HNA_HPU_CSR_FUNC(void)
 #define CVMX_HNA_HPU_DBG CVMX_HNA_HPU_DBG_FUNC()
 static inline uint64_t CVMX_HNA_HPU_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_HPU_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000008ull);
 }
@@ -247,7 +251,7 @@ static inline uint64_t CVMX_HNA_HPU_DBG_FUNC(void)
 #define CVMX_HNA_HPU_EIR CVMX_HNA_HPU_EIR_FUNC()
 static inline uint64_t CVMX_HNA_HPU_EIR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_HPU_EIR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000018ull);
 }
@@ -258,7 +262,7 @@ static inline uint64_t CVMX_HNA_HPU_EIR_FUNC(void)
 #define CVMX_HNA_PFC0_CNT CVMX_HNA_PFC0_CNT_FUNC()
 static inline uint64_t CVMX_HNA_PFC0_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_PFC0_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000090ull);
 }
@@ -269,7 +273,7 @@ static inline uint64_t CVMX_HNA_PFC0_CNT_FUNC(void)
 #define CVMX_HNA_PFC0_CTL CVMX_HNA_PFC0_CTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC0_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_PFC0_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000088ull);
 }
@@ -280,7 +284,7 @@ static inline uint64_t CVMX_HNA_PFC0_CTL_FUNC(void)
 #define CVMX_HNA_PFC1_CNT CVMX_HNA_PFC1_CNT_FUNC()
 static inline uint64_t CVMX_HNA_PFC1_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_PFC1_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000A0ull);
 }
@@ -291,7 +295,7 @@ static inline uint64_t CVMX_HNA_PFC1_CNT_FUNC(void)
 #define CVMX_HNA_PFC1_CTL CVMX_HNA_PFC1_CTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC1_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_PFC1_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000098ull);
 }
@@ -302,7 +306,7 @@ static inline uint64_t CVMX_HNA_PFC1_CTL_FUNC(void)
 #define CVMX_HNA_PFC2_CNT CVMX_HNA_PFC2_CNT_FUNC()
 static inline uint64_t CVMX_HNA_PFC2_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_PFC2_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000B0ull);
 }
@@ -313,7 +317,7 @@ static inline uint64_t CVMX_HNA_PFC2_CNT_FUNC(void)
 #define CVMX_HNA_PFC2_CTL CVMX_HNA_PFC2_CTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC2_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_PFC2_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000A8ull);
 }
@@ -324,7 +328,7 @@ static inline uint64_t CVMX_HNA_PFC2_CTL_FUNC(void)
 #define CVMX_HNA_PFC3_CNT CVMX_HNA_PFC3_CNT_FUNC()
 static inline uint64_t CVMX_HNA_PFC3_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_PFC3_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000C0ull);
 }
@@ -335,7 +339,7 @@ static inline uint64_t CVMX_HNA_PFC3_CNT_FUNC(void)
 #define CVMX_HNA_PFC3_CTL CVMX_HNA_PFC3_CTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC3_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_PFC3_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800470000B8ull);
 }
@@ -346,7 +350,7 @@ static inline uint64_t CVMX_HNA_PFC3_CTL_FUNC(void)
 #define CVMX_HNA_PFC_GCTL CVMX_HNA_PFC_GCTL_FUNC()
 static inline uint64_t CVMX_HNA_PFC_GCTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_PFC_GCTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000080ull);
 }
@@ -357,7 +361,7 @@ static inline uint64_t CVMX_HNA_PFC_GCTL_FUNC(void)
 #define CVMX_HNA_SBD_DBG0 CVMX_HNA_SBD_DBG0_FUNC()
 static inline uint64_t CVMX_HNA_SBD_DBG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_SBD_DBG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000040ull);
 }
@@ -368,7 +372,7 @@ static inline uint64_t CVMX_HNA_SBD_DBG0_FUNC(void)
 #define CVMX_HNA_SBD_DBG1 CVMX_HNA_SBD_DBG1_FUNC()
 static inline uint64_t CVMX_HNA_SBD_DBG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_SBD_DBG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000048ull);
 }
@@ -379,7 +383,7 @@ static inline uint64_t CVMX_HNA_SBD_DBG1_FUNC(void)
 #define CVMX_HNA_SBD_DBG2 CVMX_HNA_SBD_DBG2_FUNC()
 static inline uint64_t CVMX_HNA_SBD_DBG2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_SBD_DBG2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000050ull);
 }
@@ -390,7 +394,7 @@ static inline uint64_t CVMX_HNA_SBD_DBG2_FUNC(void)
 #define CVMX_HNA_SBD_DBG3 CVMX_HNA_SBD_DBG3_FUNC()
 static inline uint64_t CVMX_HNA_SBD_DBG3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_HNA_SBD_DBG3 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180047000058ull);
 }
@@ -428,8 +432,28 @@ union cvmx_hna_bist0 {
 #endif
 	} s;
 	struct cvmx_hna_bist0_s               cn73xx;
-	struct cvmx_hna_bist0_s               cn78xx;
-	struct cvmx_hna_bist0_s               cn78xxp2;
+	struct cvmx_hna_bist0_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_58_63               : 6;
+	uint64_t hpc3                         : 10; /**< BIST results for HPC3 RAM(s) (per-HPU). */
+	uint64_t reserved_42_47               : 6;
+	uint64_t hpc2                         : 10; /**< BIST results for HPC2 RAM(s) (per-HPU). */
+	uint64_t reserved_26_31               : 6;
+	uint64_t hpc1                         : 10; /**< BIST results for HPC1 RAM(s) (per-HPU). */
+	uint64_t reserved_10_15               : 6;
+	uint64_t hpc0                         : 10; /**< BIST results for HPC0 RAM(s) (per-HPU). */
+#else
+	uint64_t hpc0                         : 10;
+	uint64_t reserved_10_15               : 6;
+	uint64_t hpc1                         : 10;
+	uint64_t reserved_26_31               : 6;
+	uint64_t hpc2                         : 10;
+	uint64_t reserved_42_47               : 6;
+	uint64_t hpc3                         : 10;
+	uint64_t reserved_58_63               : 6;
+#endif
+	} cn78xx;
+	struct cvmx_hna_bist0_cn78xx          cn78xxp2;
 };
 typedef union cvmx_hna_bist0 cvmx_hna_bist0_t;
 
@@ -524,7 +548,7 @@ union cvmx_hna_config {
                                                          cluster. Typically HPU_CLCRIP=0x0, which enables all HPUs within each cluster. However,
                                                          when the HNA performance counters are used, software may want to limit the number of HPUs
                                                          per cluster available, as there are only 4 parallel performance counters.
-                                                         0x0 = HPU[9:0]:ON, All engines enabled
+                                                         0x0 = HPU[9:0]:ON, All engines enabled.
                                                          0x1 = HPU[9]:OFF /HPU[8:0]:ON, (n-1) engines enabled.
                                                          0x2 = HPU[9:8]:OFF /HPU[7:0]:ON, (n-2) engines enabled.
                                                          0x2 = HPU[9:7]:OFF /HPU[6:0]:ON, (n-3) engines enabled.
@@ -538,11 +562,7 @@ union cvmx_hna_config {
                                                          crippled and only HPU numbers 0-8 are available.
                                                          Software NOTE: The MIO_FUS___HNA_NUMHPU_CRIPPLE[2:0] fuse bits are forced into this
                                                          register at reset. Any fuse bits that contain 1 are disallowed during a write and are
-                                                         always read as 1.
-                                                         INTERNAL: The encodings are done in such a way as to later be used with fuses (for future
-                                                         revisions which will disable some number of HPUs). Blowing a fuse has the effect that
-                                                         there will always be fewer HPUs available. [i.e: we never want a customer to blow
-                                                         additional fuses to get more HPUs]. */
+                                                         always read as 1. */
 	uint64_t hpuclkdis                    : 1;  /**< HNA clock disable source. When set, the HNA clocks for HPU (thread engine) operation are
                                                          disabled (to conserve overall chip clocking power when the HNA function is not used).
                                                          NOTE: When set, software must never issue NCB-direct CSR operations to the HNA (will
@@ -617,7 +637,7 @@ union cvmx_hna_config {
                                                          cluster. Typically HPU_CLCRIP=0x0, which enables all HPUs within each cluster. However,
                                                          when the HNA performance counters are used, software may want to limit the number of HPUs
                                                          per cluster available, as there are only 4 parallel performance counters.
-                                                         0x0 = HPU[9:0]:ON, All engines enabled
+                                                         0x0 = HPU[9:0]:ON, All engines enabled.
                                                          0x1 = HPU[9]:OFF /HPU[8:0]:ON, (n-1) engines enabled.
                                                          0x2 = HPU[9:8]:OFF /HPU[7:0]:ON, (n-2) engines enabled.
                                                          0x2 = HPU[9:7]:OFF /HPU[6:0]:ON, (n-3) engines enabled.
@@ -631,11 +651,7 @@ union cvmx_hna_config {
                                                          crippled and only HPU numbers 0-8 are available.
                                                          Software NOTE: The MIO_FUS___HNA_NUMHPU_CRIPPLE[2:0] fuse bits are forced into this
                                                          register at reset. Any fuse bits that contain 1 are disallowed during a write and are
-                                                         always read as 1.
-                                                         INTERNAL: The encodings are done in such a way as to later be used with fuses (for future
-                                                         revisions which will disable some number of HPUs). Blowing a fuse has the effect that
-                                                         there will always be fewer HPUs available. [i.e: we never want a customer to blow
-                                                         additional fuses to get more HPUs]. */
+                                                         always read as 1. */
 	uint64_t hpuclkdis                    : 1;  /**< HNA clock disable source. When set, the HNA clocks for HPU (thread engine) operation are
                                                          disabled (to conserve overall chip clocking power when the HNA function is not used).
                                                          NOTE: When set, software must never issue NCB-direct CSR operations to the HNA (will
@@ -679,14 +695,8 @@ union cvmx_hna_control {
 	uint64_t frcperr                      : 1;  /**< Force parity error during an OCM load. When set, a parity error is forced during the OCM
                                                          load instruction. Software can force a single line to contain a parity error by setting
                                                          this bit and performance a OCM load for a single line (DLEN=32), then clearing the bit. */
-	uint64_t sbdnum                       : 6;  /**< Reserved. SBD debug entry number.
-                                                         INTERNAL: HNA Scoreboard debug control. Selects which one of 48 HNA Scoreboard entries is
-                                                         latched into the HNA_SBD_DBG[0-3] registers. */
-	uint64_t sbdlck                       : 1;  /**< Reserved. HNA scoreboard lock strobe. INTERNAL: HNA Scoreboard debug control. When written
-                                                         with a '1', the HNA Scoreboard Debug registers (HNA_SBD_DBG[0-3]) are all locked down.
-                                                         This allows SW to lock down the contents of the entire SBD for a single instant in time.
-                                                         All subsequent reads of the HNA scoreboard registers will return the data from that
-                                                         instant in time. */
+	uint64_t sbdnum                       : 6;  /**< Reserved. SBD debug entry number. */
+	uint64_t sbdlck                       : 1;  /**< Reserved. HNA scoreboard lock strobe. */
 	uint64_t reserved_3_4                 : 2;
 	uint64_t pmode                        : 1;  /**< Reserved. NCB-NRP arbiter mode. (0=Fixed Priority [LP=DFF,HP=RGF]/1=RR
                                                          NOTE: This should only be written to a different value during power-on software
@@ -843,8 +853,7 @@ union cvmx_hna_eco {
 	struct cvmx_hna_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t eco_rw                       : 32; /**< Added in pass 2.
-                                                         INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 32; /**< Added in pass 2. */
 #else
 	uint64_t eco_rw                       : 32;
 	uint64_t reserved_32_63               : 32;
@@ -1124,17 +1133,12 @@ typedef union cvmx_hna_hnc1_ram2x cvmx_hna_hnc1_ram2x_t;
 
 /**
  * cvmx_hna_hpu_csr
- *
- * To read one of the HPU internal CSRs for debug (i.e. HPU_STATUS, DBG_CURSTK, DBG_GENERAL),
- * first a CSR write of the HNA_HPU_DBG is done to specify the HPU CSR number, cluster number =
- * CLID, and HPU number = HPUID, which is followed by a CSR read of the HPA_HPU_CSR which returns
- * the contents of the specified HPU CSR.
  */
 union cvmx_hna_hpu_csr {
 	uint64_t u64;
 	struct cvmx_hna_hpu_csr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t csrdat                       : 64; /**< HPU CSR contents specified by HNA_HPU_DBG. */
+	uint64_t csrdat                       : 64;
 #else
 	uint64_t csrdat                       : 64;
 #endif
@@ -1486,35 +1490,7 @@ union cvmx_hna_sbd_dbg0 {
 	uint64_t u64;
 	struct cvmx_hna_sbd_dbg0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sbd                          : 64; /**< HNA Scoreboard 0 data.
-                                                         INTERNAL:
-                                                         <pre>
-                                                         [63]       (1) Unused
-                                                         [62]       (1) llptr_gntd
-                                                         [61]       (1) llptr_fetch
-                                                         [60]       (1) spill_req_1a
-                                                         [59:54]    (6) hpu_svstk_lvl[5:0]
-                                                         [53:36]   (18) svstk_len[17:0]
-                                                         [35:20]   (16) Cumulative result write counter (for HDR write)
-                                                         [19]       (1) Unused
-                                                         [18:15]    (4) Completion code
-                                                         [14]       (1) Completion detected
-                                                         [13]       (1) Waiting for HDR RWrCmtRsp
-                                                         [12]       (1) 1st (of 2) RWORD0(HDR) writes (w/ DONE=0) has been issued
-                                                         [11]       (1) Waiting for HDR RWrReq
-                                                         [10]       (1) Waiting for RWrReq
-                                                         [9]        (1) Waiting for WQWrReq issue
-                                                         [8]        (1) Waiting for PRdRsp EOT
-                                                         [7]        (1) Waiting for PRdReq Issue (to NRQ)
-                                                         [6]        (1) Packet data valid
-                                                         [5]        (1) WQVLD
-                                                         [4]        (1) WQ done point (either WQWrReq issued (for WQPTR<>0)
-                                                                        OR HDR RWrCmtRsp completed)
-                                                         [3]        (1) Resultant write STF/P Mode
-                                                         [2]        (1) Packet data LDT mode
-                                                         [1]        (1) Unused
-                                                         [0]        (1) Valid
-                                                         </pre> */
+	uint64_t sbd                          : 64; /**< HNA Scoreboard 0 data. */
 #else
 	uint64_t sbd                          : 64;
 #endif
@@ -1588,21 +1564,7 @@ union cvmx_hna_sbd_dbg3 {
 	uint64_t u64;
 	struct cvmx_hna_sbd_dbg3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sbd                          : 64; /**< HNA Scoreboard 3 data.
-                                                         INTERNAL:
-                                                         <pre>
-                                                         [63:48]   (16) RESERVED
-                                                         [47]       (1) fill_start_1a
-                                                         [46]       (1) spill_start_1a
-                                                         [45]       (1) fill_en
-                                                         [44]       (1) chunk_ptr_addr_match_1a
-                                                         [43]       (1) rnstk_ptrupdate_1a
-                                                         [42]       (1) svllrd
-                                                         [41:38]    (4) state[3:0]
-                                                         [37:29]    (9) hpu_rnstk_lvl[8:0]
-                                                         [28:11]   (18) ext_rnstk_lvl[17:0]
-                                                         [10:0]    (11) rnstk_addr[10:0]
-                                                         </pre> */
+	uint64_t sbd                          : 64; /**< HNA Scoreboard 3 data. */
 #else
 	uint64_t sbd                          : 64;
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-ila-defs.h b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
index f4bbc32..7417ed2 100644
--- a/arch/mips/include/asm/octeon/cvmx-ila-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_ILA_BIST_SUM CVMX_ILA_BIST_SUM_FUNC()
 static inline uint64_t CVMX_ILA_BIST_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ILA_BIST_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180017000038ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_ILA_BIST_SUM_FUNC(void)
 #define CVMX_ILA_GBL_CFG CVMX_ILA_GBL_CFG_FUNC()
 static inline uint64_t CVMX_ILA_GBL_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ILA_GBL_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180017000000ull);
 }
@@ -78,6 +78,7 @@ static inline uint64_t CVMX_ILA_GBL_CFG_FUNC(void)
 static inline uint64_t CVMX_ILA_LNEX_TRN_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_LNEX_TRN_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800170380F0ull) + ((offset) & 7) * 1024;
@@ -89,6 +90,7 @@ static inline uint64_t CVMX_ILA_LNEX_TRN_CTL(unsigned long offset)
 static inline uint64_t CVMX_ILA_LNEX_TRN_LD(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_LNEX_TRN_LD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800170380E0ull) + ((offset) & 7) * 1024;
@@ -100,6 +102,7 @@ static inline uint64_t CVMX_ILA_LNEX_TRN_LD(unsigned long offset)
 static inline uint64_t CVMX_ILA_LNEX_TRN_LP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_LNEX_TRN_LP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800170380E8ull) + ((offset) & 7) * 1024;
@@ -111,7 +114,7 @@ static inline uint64_t CVMX_ILA_LNEX_TRN_LP(unsigned long offset)
 #define CVMX_ILA_LNE_DBG CVMX_ILA_LNE_DBG_FUNC()
 static inline uint64_t CVMX_ILA_LNE_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ILA_LNE_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180017030008ull);
 }
@@ -122,7 +125,7 @@ static inline uint64_t CVMX_ILA_LNE_DBG_FUNC(void)
 #define CVMX_ILA_LNE_STS_MSG CVMX_ILA_LNE_STS_MSG_FUNC()
 static inline uint64_t CVMX_ILA_LNE_STS_MSG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ILA_LNE_STS_MSG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180017030000ull);
 }
@@ -133,6 +136,7 @@ static inline uint64_t CVMX_ILA_LNE_STS_MSG_FUNC(void)
 static inline uint64_t CVMX_ILA_RXX_BYTE_CNTX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_ILA_RXX_BYTE_CNTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800170200A0ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
@@ -144,6 +148,7 @@ static inline uint64_t CVMX_ILA_RXX_BYTE_CNTX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_ILA_RXX_CFG0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_CFG0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020000ull);
@@ -155,6 +160,7 @@ static inline uint64_t CVMX_ILA_RXX_CFG0(unsigned long offset)
 static inline uint64_t CVMX_ILA_RXX_CFG1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_CFG1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020008ull);
@@ -166,6 +172,7 @@ static inline uint64_t CVMX_ILA_RXX_CFG1(unsigned long offset)
 static inline uint64_t CVMX_ILA_RXX_CHA_XON(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_CHA_XON(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020090ull);
@@ -177,6 +184,7 @@ static inline uint64_t CVMX_ILA_RXX_CHA_XON(unsigned long offset)
 static inline uint64_t CVMX_ILA_RXX_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020010ull);
@@ -188,6 +196,7 @@ static inline uint64_t CVMX_ILA_RXX_INT(unsigned long offset)
 static inline uint64_t CVMX_ILA_RXX_PKT_CNTX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_ILA_RXX_PKT_CNTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180017020080ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
@@ -199,6 +208,7 @@ static inline uint64_t CVMX_ILA_RXX_PKT_CNTX(unsigned long offset, unsigned long
 static inline uint64_t CVMX_ILA_RXX_STAT0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_STAT0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020020ull);
@@ -210,6 +220,7 @@ static inline uint64_t CVMX_ILA_RXX_STAT0(unsigned long offset)
 static inline uint64_t CVMX_ILA_RXX_STAT1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_STAT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020028ull);
@@ -221,6 +232,7 @@ static inline uint64_t CVMX_ILA_RXX_STAT1(unsigned long offset)
 static inline uint64_t CVMX_ILA_RXX_STAT2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_STAT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020030ull);
@@ -232,6 +244,7 @@ static inline uint64_t CVMX_ILA_RXX_STAT2(unsigned long offset)
 static inline uint64_t CVMX_ILA_RXX_STAT3(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_STAT3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020038ull);
@@ -243,6 +256,7 @@ static inline uint64_t CVMX_ILA_RXX_STAT3(unsigned long offset)
 static inline uint64_t CVMX_ILA_RXX_STAT4(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_STAT4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020040ull);
@@ -254,6 +268,7 @@ static inline uint64_t CVMX_ILA_RXX_STAT4(unsigned long offset)
 static inline uint64_t CVMX_ILA_RXX_STAT5(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_STAT5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020048ull);
@@ -265,6 +280,7 @@ static inline uint64_t CVMX_ILA_RXX_STAT5(unsigned long offset)
 static inline uint64_t CVMX_ILA_RXX_STAT6(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_STAT6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020050ull);
@@ -276,6 +292,7 @@ static inline uint64_t CVMX_ILA_RXX_STAT6(unsigned long offset)
 static inline uint64_t CVMX_ILA_RXX_STAT7(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_STAT7(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020058ull);
@@ -287,6 +304,7 @@ static inline uint64_t CVMX_ILA_RXX_STAT7(unsigned long offset)
 static inline uint64_t CVMX_ILA_RXX_STAT8(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_STAT8(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020060ull);
@@ -298,6 +316,7 @@ static inline uint64_t CVMX_ILA_RXX_STAT8(unsigned long offset)
 static inline uint64_t CVMX_ILA_RXX_STAT9(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_RXX_STAT9(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017020068ull);
@@ -309,6 +328,7 @@ static inline uint64_t CVMX_ILA_RXX_STAT9(unsigned long offset)
 static inline uint64_t CVMX_ILA_RX_LNEX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_RX_LNEX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017038000ull) + ((offset) & 7) * 1024;
@@ -320,6 +340,7 @@ static inline uint64_t CVMX_ILA_RX_LNEX_CFG(unsigned long offset)
 static inline uint64_t CVMX_ILA_RX_LNEX_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_RX_LNEX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017038008ull) + ((offset) & 7) * 1024;
@@ -331,6 +352,7 @@ static inline uint64_t CVMX_ILA_RX_LNEX_INT(unsigned long offset)
 static inline uint64_t CVMX_ILA_RX_LNEX_STAT0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_RX_LNEX_STAT0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017038018ull) + ((offset) & 7) * 1024;
@@ -342,6 +364,7 @@ static inline uint64_t CVMX_ILA_RX_LNEX_STAT0(unsigned long offset)
 static inline uint64_t CVMX_ILA_RX_LNEX_STAT1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_RX_LNEX_STAT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017038020ull) + ((offset) & 7) * 1024;
@@ -353,6 +376,7 @@ static inline uint64_t CVMX_ILA_RX_LNEX_STAT1(unsigned long offset)
 static inline uint64_t CVMX_ILA_RX_LNEX_STAT10(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_RX_LNEX_STAT10(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017038068ull) + ((offset) & 7) * 1024;
@@ -364,6 +388,7 @@ static inline uint64_t CVMX_ILA_RX_LNEX_STAT10(unsigned long offset)
 static inline uint64_t CVMX_ILA_RX_LNEX_STAT2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_RX_LNEX_STAT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017038028ull) + ((offset) & 7) * 1024;
@@ -375,6 +400,7 @@ static inline uint64_t CVMX_ILA_RX_LNEX_STAT2(unsigned long offset)
 static inline uint64_t CVMX_ILA_RX_LNEX_STAT3(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_RX_LNEX_STAT3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017038030ull) + ((offset) & 7) * 1024;
@@ -386,6 +412,7 @@ static inline uint64_t CVMX_ILA_RX_LNEX_STAT3(unsigned long offset)
 static inline uint64_t CVMX_ILA_RX_LNEX_STAT4(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_RX_LNEX_STAT4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017038038ull) + ((offset) & 7) * 1024;
@@ -397,6 +424,7 @@ static inline uint64_t CVMX_ILA_RX_LNEX_STAT4(unsigned long offset)
 static inline uint64_t CVMX_ILA_RX_LNEX_STAT5(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_RX_LNEX_STAT5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017038040ull) + ((offset) & 7) * 1024;
@@ -408,6 +436,7 @@ static inline uint64_t CVMX_ILA_RX_LNEX_STAT5(unsigned long offset)
 static inline uint64_t CVMX_ILA_RX_LNEX_STAT6(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_RX_LNEX_STAT6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017038048ull) + ((offset) & 7) * 1024;
@@ -419,6 +448,7 @@ static inline uint64_t CVMX_ILA_RX_LNEX_STAT6(unsigned long offset)
 static inline uint64_t CVMX_ILA_RX_LNEX_STAT7(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_RX_LNEX_STAT7(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017038050ull) + ((offset) & 7) * 1024;
@@ -430,6 +460,7 @@ static inline uint64_t CVMX_ILA_RX_LNEX_STAT7(unsigned long offset)
 static inline uint64_t CVMX_ILA_RX_LNEX_STAT8(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_RX_LNEX_STAT8(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017038058ull) + ((offset) & 7) * 1024;
@@ -441,6 +472,7 @@ static inline uint64_t CVMX_ILA_RX_LNEX_STAT8(unsigned long offset)
 static inline uint64_t CVMX_ILA_RX_LNEX_STAT9(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7)))))
 		cvmx_warn("CVMX_ILA_RX_LNEX_STAT9(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017038060ull) + ((offset) & 7) * 1024;
@@ -452,7 +484,7 @@ static inline uint64_t CVMX_ILA_RX_LNEX_STAT9(unsigned long offset)
 #define CVMX_ILA_SER_CFG CVMX_ILA_SER_CFG_FUNC()
 static inline uint64_t CVMX_ILA_SER_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ILA_SER_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180017000018ull);
 }
@@ -463,6 +495,7 @@ static inline uint64_t CVMX_ILA_SER_CFG_FUNC(void)
 static inline uint64_t CVMX_ILA_TXX_BYTE_CNTX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_ILA_TXX_BYTE_CNTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180017010040ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
@@ -474,6 +507,7 @@ static inline uint64_t CVMX_ILA_TXX_BYTE_CNTX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_ILA_TXX_CFG0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_TXX_CFG0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017010000ull);
@@ -485,6 +519,7 @@ static inline uint64_t CVMX_ILA_TXX_CFG0(unsigned long offset)
 static inline uint64_t CVMX_ILA_TXX_CFG1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_TXX_CFG1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017010008ull);
@@ -496,6 +531,7 @@ static inline uint64_t CVMX_ILA_TXX_CFG1(unsigned long offset)
 static inline uint64_t CVMX_ILA_TXX_CHA_XON(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_TXX_CHA_XON(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017010088ull);
@@ -507,6 +543,7 @@ static inline uint64_t CVMX_ILA_TXX_CHA_XON(unsigned long offset)
 static inline uint64_t CVMX_ILA_TXX_DBG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_TXX_DBG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017010090ull);
@@ -518,6 +555,7 @@ static inline uint64_t CVMX_ILA_TXX_DBG(unsigned long offset)
 static inline uint64_t CVMX_ILA_TXX_ERR_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_TXX_ERR_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800170100A0ull);
@@ -529,6 +567,7 @@ static inline uint64_t CVMX_ILA_TXX_ERR_CFG(unsigned long offset)
 static inline uint64_t CVMX_ILA_TXX_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_TXX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017010098ull);
@@ -540,6 +579,7 @@ static inline uint64_t CVMX_ILA_TXX_INT(unsigned long offset)
 static inline uint64_t CVMX_ILA_TXX_PKT_CNTX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_ILA_TXX_PKT_CNTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180017010020ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 8;
@@ -551,6 +591,7 @@ static inline uint64_t CVMX_ILA_TXX_PKT_CNTX(unsigned long offset, unsigned long
 static inline uint64_t CVMX_ILA_TXX_RMATCH(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_ILA_TXX_RMATCH(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180017010080ull);
@@ -633,7 +674,8 @@ union cvmx_ila_lnex_trn_ld {
 	uint64_t u64;
 	struct cvmx_ila_lnex_trn_ld_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_49_63               : 15;
+	uint64_t lp_manual                    : 1;  /**< Software must write LP_MANUAL=1 when performing manually training. */
+	uint64_t reserved_49_62               : 14;
 	uint64_t ld_cu_val                    : 1;  /**< Local device coefficient update field valid. */
 	uint64_t ld_cu_dat                    : 16; /**< Local device coefficient update field data. */
 	uint64_t reserved_17_31               : 15;
@@ -645,7 +687,8 @@ union cvmx_ila_lnex_trn_ld {
 	uint64_t reserved_17_31               : 15;
 	uint64_t ld_cu_dat                    : 16;
 	uint64_t ld_cu_val                    : 1;
-	uint64_t reserved_49_63               : 15;
+	uint64_t reserved_49_62               : 14;
+	uint64_t lp_manual                    : 1;
 #endif
 	} s;
 	struct cvmx_ila_lnex_trn_ld_s         cn78xx;
@@ -810,14 +853,14 @@ union cvmx_ila_rxx_cfg0 {
 	uint64_t lane_ena                     : 8;  /**< Lane enable mask. The link is enabled if any lane is enabled. The same lane should not be
                                                          enabled in multiple ILA_RXn_CFG0. Each bit of LANE_ENA maps to an RX lane (RLE) and a QLM
                                                          lane. Note that LANE_REV has no effect on this mapping.
-                                                         _ LANE_ENA[0] = RLE0 =  QLM2 lane 0
-                                                         _ LANE_ENA[1] = RLE1 =  QLM2 lane 1
-                                                         _ LANE_ENA[2] = RLE2 =  QLM2 lane 2
-                                                         _ LANE_ENA[3] = RLE3 =  QLM2 lane 3
-                                                         _ LANE_ENA[4] = RLE4 =  QLM3 lane 0
-                                                         _ LANE_ENA[5] = RLE5 =  QLM3 lane 1
-                                                         _ LANE_ENA[6] = RLE6 =  QLM3 lane 2
-                                                         _ LANE_ENA[7] = RLE7 =  QLM3 lane 3 */
+                                                         _ LANE_ENA[0] = RLE0 =  QLM2 lane 0.
+                                                         _ LANE_ENA[1] = RLE1 =  QLM2 lane 1.
+                                                         _ LANE_ENA[2] = RLE2 =  QLM2 lane 2.
+                                                         _ LANE_ENA[3] = RLE3 =  QLM2 lane 3.
+                                                         _ LANE_ENA[4] = RLE4 =  QLM3 lane 0.
+                                                         _ LANE_ENA[5] = RLE5 =  QLM3 lane 1.
+                                                         _ LANE_ENA[6] = RLE6 =  QLM3 lane 2.
+                                                         _ LANE_ENA[7] = RLE7 =  QLM3 lane 3. */
 #else
 	uint64_t lane_ena                     : 8;
 	uint64_t reserved_8_25                : 18;
@@ -1582,14 +1625,14 @@ union cvmx_ila_txx_cfg0 {
 	uint64_t lane_ena                     : 8;  /**< Lane enable mask. Link is enabled if any lane is enabled. The same lane should not be
                                                          enabled in multiple ILA_TX()_CFG0. Each bit of LANE_ENA maps to a TX lane (TLE) and a QLM
                                                          lane. Note that LANE_REV has no effect on this mapping.
-                                                         _ LANE_ENA[0] = TLE0  =  QLM2 lane 0
-                                                         _ LANE_ENA[1] = TLE1  =  QLM2 lane 1
-                                                         _ LANE_ENA[2] = TLE2  =  QLM2 lane 2
-                                                         _ LANE_ENA[3] = TLE3  =  QLM2 lane 3
-                                                         _ LANE_ENA[4] = TLE4  =  QLM3 lane 0
-                                                         _ LANE_ENA[5] = TLE5  =  QLM3 lane 1
-                                                         _ LANE_ENA[6] = TLE6  =  QLM3 lane 2
-                                                         _ LANE_ENA[7] = TLE7  =  QLM3 lane 3 */
+                                                         _ LANE_ENA[0] = TLE0  =  QLM2 lane 0.
+                                                         _ LANE_ENA[1] = TLE1  =  QLM2 lane 1.
+                                                         _ LANE_ENA[2] = TLE2  =  QLM2 lane 2.
+                                                         _ LANE_ENA[3] = TLE3  =  QLM2 lane 3.
+                                                         _ LANE_ENA[4] = TLE4  =  QLM3 lane 0.
+                                                         _ LANE_ENA[5] = TLE5  =  QLM3 lane 1.
+                                                         _ LANE_ENA[6] = TLE6  =  QLM3 lane 2.
+                                                         _ LANE_ENA[7] = TLE7  =  QLM3 lane 3. */
 #else
 	uint64_t lane_ena                     : 8;
 	uint64_t reserved_8_25                : 18;
diff --git a/arch/mips/include/asm/octeon/cvmx-ila.h b/arch/mips/include/asm/octeon/cvmx-ila.h
index f76844f..37aa348 100644
--- a/arch/mips/include/asm/octeon/cvmx-ila.h
+++ b/arch/mips/include/asm/octeon/cvmx-ila.h
@@ -121,6 +121,11 @@ extern cvmx_helper_link_info_t __cvmx_ila_link_get(int lane_mask);
  */
 extern cvmx_ila_header_t cvmx_ila_configure_header(int channel, int mode);
 
+/**
+ * Reset ILA interface
+ */
+extern void cvmx_ila_reset(void);
+
 #ifdef	__cplusplus
 /* *INDENT-OFF* */
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-ilk-defs.h b/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
index 90f34a7..f15c533 100644
--- a/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_ILK_BIST_SUM CVMX_ILK_BIST_SUM_FUNC()
 static inline uint64_t CVMX_ILK_BIST_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ILK_BIST_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180014000038ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_ILK_BIST_SUM_FUNC(void)
 #define CVMX_ILK_GBL_CFG CVMX_ILK_GBL_CFG_FUNC()
 static inline uint64_t CVMX_ILK_GBL_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ILK_GBL_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180014000000ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_ILK_GBL_CFG_FUNC(void)
 #define CVMX_ILK_GBL_ERR_CFG CVMX_ILK_GBL_ERR_CFG_FUNC()
 static inline uint64_t CVMX_ILK_GBL_ERR_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ILK_GBL_ERR_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180014000058ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_ILK_GBL_ERR_CFG_FUNC(void)
 #define CVMX_ILK_GBL_INT CVMX_ILK_GBL_INT_FUNC()
 static inline uint64_t CVMX_ILK_GBL_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ILK_GBL_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180014000008ull);
 }
@@ -122,6 +122,7 @@ static inline uint64_t CVMX_ILK_INT_SUM_FUNC(void)
 static inline uint64_t CVMX_ILK_LNEX_TRN_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_LNEX_TRN_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800140380F0ull) + ((offset) & 15) * 1024;
@@ -133,6 +134,7 @@ static inline uint64_t CVMX_ILK_LNEX_TRN_CTL(unsigned long offset)
 static inline uint64_t CVMX_ILK_LNEX_TRN_LD(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_LNEX_TRN_LD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800140380E0ull) + ((offset) & 15) * 1024;
@@ -144,6 +146,7 @@ static inline uint64_t CVMX_ILK_LNEX_TRN_LD(unsigned long offset)
 static inline uint64_t CVMX_ILK_LNEX_TRN_LP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_LNEX_TRN_LP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800140380E8ull) + ((offset) & 15) * 1024;
@@ -155,7 +158,7 @@ static inline uint64_t CVMX_ILK_LNEX_TRN_LP(unsigned long offset)
 #define CVMX_ILK_LNE_DBG CVMX_ILK_LNE_DBG_FUNC()
 static inline uint64_t CVMX_ILK_LNE_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ILK_LNE_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180014030008ull);
 }
@@ -166,7 +169,7 @@ static inline uint64_t CVMX_ILK_LNE_DBG_FUNC(void)
 #define CVMX_ILK_LNE_STS_MSG CVMX_ILK_LNE_STS_MSG_FUNC()
 static inline uint64_t CVMX_ILK_LNE_STS_MSG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ILK_LNE_STS_MSG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180014030000ull);
 }
@@ -177,7 +180,7 @@ static inline uint64_t CVMX_ILK_LNE_STS_MSG_FUNC(void)
 #define CVMX_ILK_RID_CFG CVMX_ILK_RID_CFG_FUNC()
 static inline uint64_t CVMX_ILK_RID_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ILK_RID_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180014000050ull);
 }
@@ -210,6 +213,7 @@ static inline uint64_t CVMX_ILK_RXF_MEM_PMAP_FUNC(void)
 static inline uint64_t CVMX_ILK_RXX_BYTE_CNTX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 255)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 255)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_ILK_RXX_BYTE_CNTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180014023000ull) + (((offset) & 255) + ((block_id) & 1) * 0x800ull) * 8;
@@ -221,6 +225,7 @@ static inline uint64_t CVMX_ILK_RXX_BYTE_CNTX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_ILK_RXX_CAL_ENTRYX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 287)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 287)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_ILK_RXX_CAL_ENTRYX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180014021000ull) + (((offset) & 511) + ((block_id) & 1) * 0x800ull) * 8;
@@ -233,6 +238,7 @@ static inline uint64_t CVMX_ILK_RXX_CFG0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_CFG0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014020000ull) + ((offset) & 1) * 16384;
@@ -245,6 +251,7 @@ static inline uint64_t CVMX_ILK_RXX_CFG1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_CFG1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014020008ull) + ((offset) & 1) * 16384;
@@ -256,6 +263,7 @@ static inline uint64_t CVMX_ILK_RXX_CFG1(unsigned long offset)
 static inline uint64_t CVMX_ILK_RXX_CHAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 255)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 255)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_ILK_RXX_CHAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180014002000ull) + (((offset) & 255) + ((block_id) & 1) * 0x200ull) * 8;
@@ -267,6 +275,7 @@ static inline uint64_t CVMX_ILK_RXX_CHAX(unsigned long offset, unsigned long blo
 static inline uint64_t CVMX_ILK_RXX_CHA_XONX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_ILK_RXX_CHA_XONX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180014020400ull) + (((offset) & 3) + ((block_id) & 1) * 0x800ull) * 8;
@@ -278,6 +287,7 @@ static inline uint64_t CVMX_ILK_RXX_CHA_XONX(unsigned long offset, unsigned long
 static inline uint64_t CVMX_ILK_RXX_ERR_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_ERR_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800140200E0ull) + ((offset) & 1) * 16384;
@@ -345,6 +355,7 @@ static inline uint64_t CVMX_ILK_RXX_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014020010ull) + ((offset) & 1) * 16384;
@@ -368,6 +379,7 @@ static inline uint64_t CVMX_ILK_RXX_JABBER(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_JABBER(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800140200B8ull) + ((offset) & 1) * 16384;
@@ -423,6 +435,7 @@ static inline uint64_t CVMX_ILK_RXX_MEM_STAT1(unsigned long offset)
 static inline uint64_t CVMX_ILK_RXX_PKT_CNTX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 255)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 255)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_ILK_RXX_PKT_CNTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180014022000ull) + (((offset) & 255) + ((block_id) & 1) * 0x800ull) * 8;
@@ -435,6 +448,7 @@ static inline uint64_t CVMX_ILK_RXX_RID(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_RID(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800140200C0ull) + ((offset) & 1) * 16384;
@@ -447,6 +461,7 @@ static inline uint64_t CVMX_ILK_RXX_STAT0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_STAT0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014020020ull) + ((offset) & 1) * 16384;
@@ -459,6 +474,7 @@ static inline uint64_t CVMX_ILK_RXX_STAT1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_STAT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014020028ull) + ((offset) & 1) * 16384;
@@ -471,6 +487,7 @@ static inline uint64_t CVMX_ILK_RXX_STAT2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_STAT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014020030ull) + ((offset) & 1) * 16384;
@@ -483,6 +500,7 @@ static inline uint64_t CVMX_ILK_RXX_STAT3(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_STAT3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014020038ull) + ((offset) & 1) * 16384;
@@ -495,6 +513,7 @@ static inline uint64_t CVMX_ILK_RXX_STAT4(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_STAT4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014020040ull) + ((offset) & 1) * 16384;
@@ -507,6 +526,7 @@ static inline uint64_t CVMX_ILK_RXX_STAT5(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_STAT5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014020048ull) + ((offset) & 1) * 16384;
@@ -519,6 +539,7 @@ static inline uint64_t CVMX_ILK_RXX_STAT6(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_STAT6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014020050ull) + ((offset) & 1) * 16384;
@@ -531,6 +552,7 @@ static inline uint64_t CVMX_ILK_RXX_STAT7(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_STAT7(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014020058ull) + ((offset) & 1) * 16384;
@@ -543,6 +565,7 @@ static inline uint64_t CVMX_ILK_RXX_STAT8(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_STAT8(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014020060ull) + ((offset) & 1) * 16384;
@@ -555,6 +578,7 @@ static inline uint64_t CVMX_ILK_RXX_STAT9(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_RXX_STAT9(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014020068ull) + ((offset) & 1) * 16384;
@@ -567,6 +591,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_RX_LNEX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014038000ull) + ((offset) & 15) * 1024;
@@ -579,6 +604,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_RX_LNEX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((offset) & 15) * 1024;
@@ -602,6 +628,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_STAT0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_RX_LNEX_STAT0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014038018ull) + ((offset) & 15) * 1024;
@@ -614,6 +641,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_STAT1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_RX_LNEX_STAT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014038020ull) + ((offset) & 15) * 1024;
@@ -625,6 +653,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_STAT1(unsigned long offset)
 static inline uint64_t CVMX_ILK_RX_LNEX_STAT10(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_RX_LNEX_STAT10(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014038068ull) + ((offset) & 15) * 1024;
@@ -637,6 +666,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_STAT2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_RX_LNEX_STAT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014038028ull) + ((offset) & 15) * 1024;
@@ -649,6 +679,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_STAT3(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_RX_LNEX_STAT3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014038030ull) + ((offset) & 15) * 1024;
@@ -661,6 +692,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_STAT4(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_RX_LNEX_STAT4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014038038ull) + ((offset) & 15) * 1024;
@@ -673,6 +705,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_STAT5(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_RX_LNEX_STAT5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014038040ull) + ((offset) & 15) * 1024;
@@ -685,6 +718,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_STAT6(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_RX_LNEX_STAT6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014038048ull) + ((offset) & 15) * 1024;
@@ -697,6 +731,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_STAT7(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_RX_LNEX_STAT7(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014038050ull) + ((offset) & 15) * 1024;
@@ -709,6 +744,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_STAT8(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_RX_LNEX_STAT8(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014038058ull) + ((offset) & 15) * 1024;
@@ -721,6 +757,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_STAT9(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 15))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_ILK_RX_LNEX_STAT9(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014038060ull) + ((offset) & 15) * 1024;
@@ -732,7 +769,7 @@ static inline uint64_t CVMX_ILK_RX_LNEX_STAT9(unsigned long offset)
 #define CVMX_ILK_SER_CFG CVMX_ILK_SER_CFG_FUNC()
 static inline uint64_t CVMX_ILK_SER_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_ILK_SER_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180014000018ull);
 }
@@ -743,6 +780,7 @@ static inline uint64_t CVMX_ILK_SER_CFG_FUNC(void)
 static inline uint64_t CVMX_ILK_TXX_BYTE_CNTX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 255)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 255)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_ILK_TXX_BYTE_CNTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180014013000ull) + (((offset) & 255) + ((block_id) & 1) * 0x800ull) * 8;
@@ -754,6 +792,7 @@ static inline uint64_t CVMX_ILK_TXX_BYTE_CNTX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_ILK_TXX_CAL_ENTRYX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 287)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 287)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_ILK_TXX_CAL_ENTRYX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180014011000ull) + (((offset) & 511) + ((block_id) & 1) * 0x800ull) * 8;
@@ -766,6 +805,7 @@ static inline uint64_t CVMX_ILK_TXX_CFG0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_TXX_CFG0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014010000ull) + ((offset) & 1) * 16384;
@@ -778,6 +818,7 @@ static inline uint64_t CVMX_ILK_TXX_CFG1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_TXX_CFG1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014010008ull) + ((offset) & 1) * 16384;
@@ -789,6 +830,7 @@ static inline uint64_t CVMX_ILK_TXX_CFG1(unsigned long offset)
 static inline uint64_t CVMX_ILK_TXX_CHA_XONX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_ILK_TXX_CHA_XONX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180014010400ull) + (((offset) & 3) + ((block_id) & 1) * 0x800ull) * 8;
@@ -801,6 +843,7 @@ static inline uint64_t CVMX_ILK_TXX_DBG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_TXX_DBG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014010070ull) + ((offset) & 1) * 16384;
@@ -812,6 +855,7 @@ static inline uint64_t CVMX_ILK_TXX_DBG(unsigned long offset)
 static inline uint64_t CVMX_ILK_TXX_ERR_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_TXX_ERR_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800140100B0ull) + ((offset) & 1) * 16384;
@@ -890,6 +934,7 @@ static inline uint64_t CVMX_ILK_TXX_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_TXX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014010078ull) + ((offset) & 1) * 16384;
@@ -978,6 +1023,7 @@ static inline uint64_t CVMX_ILK_TXX_PIPE(unsigned long offset)
 static inline uint64_t CVMX_ILK_TXX_PKT_CNTX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 255)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 255)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_ILK_TXX_PKT_CNTX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180014012000ull) + (((offset) & 255) + ((block_id) & 1) * 0x800ull) * 8;
@@ -990,6 +1036,7 @@ static inline uint64_t CVMX_ILK_TXX_RMATCH(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_ILK_TXX_RMATCH(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180014010040ull) + ((offset) & 1) * 16384;
@@ -1643,7 +1690,8 @@ union cvmx_ilk_lnex_trn_ld {
 	uint64_t u64;
 	struct cvmx_ilk_lnex_trn_ld_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_49_63               : 15;
+	uint64_t lp_manual                    : 1;  /**< Software must write LP_MANUAL=1 when performing manually training. */
+	uint64_t reserved_49_62               : 14;
 	uint64_t ld_cu_val                    : 1;  /**< Local device coefficient update field valid. */
 	uint64_t ld_cu_dat                    : 16; /**< Local device coefficient update field data. */
 	uint64_t reserved_17_31               : 15;
@@ -1655,7 +1703,8 @@ union cvmx_ilk_lnex_trn_ld {
 	uint64_t reserved_17_31               : 15;
 	uint64_t ld_cu_dat                    : 16;
 	uint64_t ld_cu_val                    : 1;
-	uint64_t reserved_49_63               : 15;
+	uint64_t reserved_49_62               : 14;
+	uint64_t lp_manual                    : 1;
 #endif
 	} s;
 	struct cvmx_ilk_lnex_trn_ld_s         cn78xx;
@@ -3913,8 +3962,8 @@ union cvmx_ilk_ser_cfg {
                                                          _ SER_RXPOL<14> = QLM7 lane 2.
                                                          _ SER_RXPOL<15> = QLM7 lane 3. */
 	uint64_t ser_txpol                    : 16; /**< SerDes lane transmit polarity.
-                                                         0 = TX without inversion
-                                                         1 = TX with inversion
+                                                         0 = TX without inversion.
+                                                         1 = TX with inversion.
                                                          _ SER_TXPOL<0>  = QLM4 lane 0.
                                                          _ SER_TXPOL<1>  = QLM4 lane 1.
                                                          _ SER_TXPOL<2>  = QLM4 lane 2.
@@ -4054,15 +4103,15 @@ union cvmx_ilk_txx_cfg0 {
                                                          ILK_TX()_CFG0.CAL_ENA=1. */
 	uint64_t cal_ena                      : 1;  /**< Enable TX calendar. When not asserted, the default calendar is used:
                                                          First control word:
-                                                         _ entry 0 = link
-                                                         _ entry 1 = backpressure ID 0
-                                                         _ entry 2 = backpressure ID 1
+                                                         _ entry 0 = link.
+                                                         _ entry 1 = backpressure ID 0.
+                                                         _ entry 2 = backpressure ID 1.
                                                          _ ...
-                                                         _ entry 15 = backpressure ID 14
+                                                         _ entry 15 = backpressure ID 14.
                                                          Second control word:
-                                                         _ entry 16 = link
-                                                         _ entry 17 = backpressure ID 15
-                                                         _ entry 18 = backpressure ID 16
+                                                         _ entry 16 = link.
+                                                         _ entry 17 = backpressure ID 15.
+                                                         _ entry 18 = backpressure ID 16.
                                                          _ ...
                                                          This continues until the calendar depth is reached.
                                                          To disable backpressure completely, enable the calendar table and program each calendar
diff --git a/arch/mips/include/asm/octeon/cvmx-ilk.h b/arch/mips/include/asm/octeon/cvmx-ilk.h
index 50b560a..035bac7 100644
--- a/arch/mips/include/asm/octeon/cvmx-ilk.h
+++ b/arch/mips/include/asm/octeon/cvmx-ilk.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2014  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -105,20 +105,19 @@ typedef struct {
 
 #define CVMX_ILK_MAX_PIPES 45
 /* Max number of channels allowed */
-#define CVMX_ILK_MAX_CHANS 8
+#define CVMX_ILK_MAX_CHANS 256
 
-extern CVMX_SHARED unsigned char cvmx_ilk_chans[CVMX_MAX_NODES][CVMX_NUM_ILK_INTF];
-extern unsigned char cvmx_ilk_chan_map[CVMX_NUM_ILK_INTF][CVMX_ILK_MAX_CHANS];
+extern CVMX_SHARED int cvmx_ilk_chans[CVMX_MAX_NODES][CVMX_NUM_ILK_INTF];
 
 typedef struct {
 	unsigned int chan;
 	unsigned int pknd;
 } cvmx_ilk_chan_pknd_t;
 
-#define CVMX_ILK_MAX_PKNDS 8	/* must be <45 */
+#define CVMX_ILK_MAX_PKNDS 16	/* must be <45 */
 
 typedef struct {
-	unsigned int *chan_list;	/* for discrete channels. or, must be null */
+	int *chan_list;	/* for discrete channels. or, must be null */
 	unsigned int num_chans;
 
 	unsigned int chan_start;	/* for continuous channels */
diff --git a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
index 91c2dc0..1b27d3d 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_IOBN_BIST_STATUS CVMX_IOBN_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBN_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBN_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000018ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_IOBN_BIST_STATUS_FUNC(void)
 #define CVMX_IOBN_CHIP_CUR_PWR CVMX_IOBN_CHIP_CUR_PWR_FUNC()
 static inline uint64_t CVMX_IOBN_CHIP_CUR_PWR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBN_CHIP_CUR_PWR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000068ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_IOBN_CHIP_CUR_PWR_FUNC(void)
 #define CVMX_IOBN_CHIP_GLB_PWR_THROTTLE CVMX_IOBN_CHIP_GLB_PWR_THROTTLE_FUNC()
 static inline uint64_t CVMX_IOBN_CHIP_GLB_PWR_THROTTLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBN_CHIP_GLB_PWR_THROTTLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000038ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_IOBN_CHIP_GLB_PWR_THROTTLE_FUNC(void)
 #define CVMX_IOBN_CHIP_PWR_OUT CVMX_IOBN_CHIP_PWR_OUT_FUNC()
 static inline uint64_t CVMX_IOBN_CHIP_PWR_OUT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBN_CHIP_PWR_OUT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000048ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_IOBN_CHIP_PWR_OUT_FUNC(void)
 #define CVMX_IOBN_CONTROL CVMX_IOBN_CONTROL_FUNC()
 static inline uint64_t CVMX_IOBN_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBN_CONTROL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000008ull);
 }
@@ -111,7 +111,7 @@ static inline uint64_t CVMX_IOBN_CONTROL_FUNC(void)
 #define CVMX_IOBN_CREDITS CVMX_IOBN_CREDITS_FUNC()
 static inline uint64_t CVMX_IOBN_CREDITS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBN_CREDITS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000028ull);
 }
@@ -122,7 +122,7 @@ static inline uint64_t CVMX_IOBN_CREDITS_FUNC(void)
 #define CVMX_IOBN_ECC CVMX_IOBN_ECC_FUNC()
 static inline uint64_t CVMX_IOBN_ECC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBN_ECC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000010ull);
 }
@@ -133,7 +133,7 @@ static inline uint64_t CVMX_IOBN_ECC_FUNC(void)
 #define CVMX_IOBN_GBL_DLL CVMX_IOBN_GBL_DLL_FUNC()
 static inline uint64_t CVMX_IOBN_GBL_DLL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBN_GBL_DLL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0001000ull);
 }
@@ -144,7 +144,7 @@ static inline uint64_t CVMX_IOBN_GBL_DLL_FUNC(void)
 #define CVMX_IOBN_HIGH_PRIORITY CVMX_IOBN_HIGH_PRIORITY_FUNC()
 static inline uint64_t CVMX_IOBN_HIGH_PRIORITY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBN_HIGH_PRIORITY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000000ull);
 }
@@ -155,7 +155,7 @@ static inline uint64_t CVMX_IOBN_HIGH_PRIORITY_FUNC(void)
 #define CVMX_IOBN_INT_SUM CVMX_IOBN_INT_SUM_FUNC()
 static inline uint64_t CVMX_IOBN_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBN_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000020ull);
 }
@@ -167,6 +167,7 @@ static inline uint64_t CVMX_IOBN_NCBX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_IOBN_NCBX_CTL(%lu) is invalid on this chip\n", offset);
@@ -179,7 +180,7 @@ static inline uint64_t CVMX_IOBN_NCBX_CTL(unsigned long offset)
 #define CVMX_IOBN_PP_BIST_STATUS CVMX_IOBN_PP_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBN_PP_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBN_PP_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0000700ull);
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-iobp-defs.h b/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
index 2023270..19b9729 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_IOBP_BIST_STATUS CVMX_IOBP_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBP_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBP_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010018ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_IOBP_BIST_STATUS_FUNC(void)
 #define CVMX_IOBP_CREDITS CVMX_IOBP_CREDITS_FUNC()
 static inline uint64_t CVMX_IOBP_CREDITS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBP_CREDITS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010028ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_IOBP_CREDITS_FUNC(void)
 #define CVMX_IOBP_ECC CVMX_IOBP_ECC_FUNC()
 static inline uint64_t CVMX_IOBP_ECC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBP_ECC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010010ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_IOBP_ECC_FUNC(void)
 #define CVMX_IOBP_INT_SUM CVMX_IOBP_INT_SUM_FUNC()
 static inline uint64_t CVMX_IOBP_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBP_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010020ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_IOBP_INT_SUM_FUNC(void)
 #define CVMX_IOBP_PP_BIST_STATUS CVMX_IOBP_PP_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_IOBP_PP_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_IOBP_PP_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800F0010700ull);
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
index 80eca5a..664427c 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_L2C_BIG_CTL CVMX_L2C_BIG_CTL_FUNC()
 static inline uint64_t CVMX_L2C_BIG_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_L2C_BIG_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800030ull);
 }
@@ -158,6 +158,7 @@ static inline uint64_t CVMX_L2C_CBCX_BIST_STATUS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_L2C_CBCX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
@@ -171,6 +172,7 @@ static inline uint64_t CVMX_L2C_CBCX_DLL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_L2C_CBCX_DLL(%lu) is invalid on this chip\n", offset);
@@ -184,6 +186,7 @@ static inline uint64_t CVMX_L2C_CBCX_HOLEERR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_L2C_CBCX_HOLEERR(%lu) is invalid on this chip\n", offset);
@@ -198,6 +201,7 @@ static inline uint64_t CVMX_L2C_CBCX_INT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_L2C_CBCX_INT(%lu) is invalid on this chip\n", offset);
@@ -212,6 +216,7 @@ static inline uint64_t CVMX_L2C_CBCX_IOCERR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_L2C_CBCX_IOCERR(%lu) is invalid on this chip\n", offset);
@@ -225,6 +230,7 @@ static inline uint64_t CVMX_L2C_CBCX_IODISOCIERR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_L2C_CBCX_IODISOCIERR(%lu) is invalid on this chip\n", offset);
@@ -237,15 +243,20 @@ static inline uint64_t CVMX_L2C_CBCX_IODISOCIERR(unsigned long offset)
 static inline uint64_t CVMX_L2C_CBCX_MIBERR(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if (((offset >= 2) && (offset <= 3)))
+					return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((offset) & 3) * 0x40000ull - 262144*2;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if (((offset >= 2) && (offset <= 3)))
+					return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((offset) & 3) * 0x40000ull - 262144*2;
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset == 1))
 				return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((offset) & 1) * 0x40000ull - 262144*1;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if (((offset >= 2) && (offset <= 3)))
-				return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((offset) & 3) * 0x40000ull - 262144*2;
-			break;
 	}
 	cvmx_warn("CVMX_L2C_CBCX_MIBERR (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + ((offset) & 1) * 0x40000ull - 262144*1;
@@ -254,11 +265,15 @@ static inline uint64_t CVMX_L2C_CBCX_MIBERR(unsigned long offset)
 static inline uint64_t CVMX_L2C_CBCX_MIBERR(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (offset) * 0x40000ull - 262144*2;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (offset) * 0x40000ull - 262144*2;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (offset) * 0x40000ull - 262144*1;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (offset) * 0x40000ull - 262144*2;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180080E807E0ull) + (offset) * 0x40000ull - 262144*1;
 }
@@ -269,6 +284,7 @@ static inline uint64_t CVMX_L2C_CBCX_RSDERR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_L2C_CBCX_RSDERR(%lu) is invalid on this chip\n", offset);
@@ -292,7 +308,7 @@ static inline uint64_t CVMX_L2C_CFG_FUNC(void)
 #define CVMX_L2C_COP0_ADR CVMX_L2C_COP0_ADR_FUNC()
 static inline uint64_t CVMX_L2C_COP0_ADR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_L2C_COP0_ADR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800038ull);
 }
@@ -303,7 +319,7 @@ static inline uint64_t CVMX_L2C_COP0_ADR_FUNC(void)
 #define CVMX_L2C_COP0_DAT CVMX_L2C_COP0_DAT_FUNC()
 static inline uint64_t CVMX_L2C_COP0_DAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_L2C_COP0_DAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800040ull);
 }
@@ -329,7 +345,7 @@ static inline uint64_t CVMX_L2C_COP0_MAPX(unsigned long offset)
 #define CVMX_L2C_CTL CVMX_L2C_CTL_FUNC()
 static inline uint64_t CVMX_L2C_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_L2C_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800000ull);
 }
@@ -377,7 +393,7 @@ static inline uint64_t CVMX_L2C_DUT_MAPX(unsigned long offset)
 #define CVMX_L2C_ECC_CTL CVMX_L2C_ECC_CTL_FUNC()
 static inline uint64_t CVMX_L2C_ECC_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_L2C_ECC_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800010ull);
 }
@@ -512,6 +528,7 @@ static inline uint64_t CVMX_L2C_INVX_PFC(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_INVX_PFC(%lu) is invalid on this chip\n", offset);
@@ -528,6 +545,12 @@ static inline uint64_t CVMX_L2C_IOCX_PFC(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset == 0))
+					return CVMX_ADD_IO_SEG(0x0001180080800828ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset == 0))
+					return CVMX_ADD_IO_SEG(0x0001180080800828ull);
 			if ((offset == 0))
 				return CVMX_ADD_IO_SEG(0x0001180080800828ull);
 			break;
@@ -551,6 +574,10 @@ static inline uint64_t CVMX_L2C_IOCX_PFC(unsigned long offset __attribute__ ((un
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180080800828ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180080800828ull);
 			return CVMX_ADD_IO_SEG(0x0001180080800828ull);
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -570,6 +597,12 @@ static inline uint64_t CVMX_L2C_IORX_PFC(unsigned long offset)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset == 0))
+					return CVMX_ADD_IO_SEG(0x0001180080800830ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset == 0))
+					return CVMX_ADD_IO_SEG(0x0001180080800830ull);
 			if ((offset == 0))
 				return CVMX_ADD_IO_SEG(0x0001180080800830ull);
 			break;
@@ -593,6 +626,10 @@ static inline uint64_t CVMX_L2C_IORX_PFC(unsigned long offset __attribute__ ((un
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180080800830ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180080800830ull);
 			return CVMX_ADD_IO_SEG(0x0001180080800830ull);
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -676,6 +713,7 @@ static inline uint64_t CVMX_L2C_MCIX_BIST_STATUS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_L2C_MCIX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
@@ -690,6 +728,7 @@ static inline uint64_t CVMX_L2C_MCIX_ERR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_L2C_MCIX_ERR(%lu) is invalid on this chip\n", offset);
@@ -704,6 +743,7 @@ static inline uint64_t CVMX_L2C_MCIX_INT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_L2C_MCIX_INT(%lu) is invalid on this chip\n", offset);
@@ -716,7 +756,7 @@ static inline uint64_t CVMX_L2C_MCIX_INT(unsigned long offset)
 #define CVMX_L2C_OCI_CTL CVMX_L2C_OCI_CTL_FUNC()
 static inline uint64_t CVMX_L2C_OCI_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_L2C_OCI_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800020ull);
 }
@@ -820,6 +860,7 @@ static inline uint64_t CVMX_L2C_QOS_IOBX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -839,6 +880,7 @@ static inline uint64_t CVMX_L2C_QOS_PPX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
@@ -852,7 +894,7 @@ static inline uint64_t CVMX_L2C_QOS_PPX(unsigned long offset)
 #define CVMX_L2C_QOS_WGT CVMX_L2C_QOS_WGT_FUNC()
 static inline uint64_t CVMX_L2C_QOS_WGT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_L2C_QOS_WGT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800008ull);
 }
@@ -873,8 +915,13 @@ static inline uint64_t CVMX_L2C_RSCX_PFC(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180080800810ull) + ((offset) & 3) * 64;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 9))
-				return CVMX_ADD_IO_SEG(0x0001180080800810ull) + ((offset) & 15) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 9))
+					return CVMX_ADD_IO_SEG(0x0001180080800810ull) + ((offset) & 15) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 9))
+					return CVMX_ADD_IO_SEG(0x0001180080800810ull) + ((offset) & 15) * 64;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -901,7 +948,11 @@ static inline uint64_t CVMX_L2C_RSCX_PFC(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800810ull) + (offset) * 64;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180080800810ull) + (offset) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180080800810ull) + (offset) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180080800810ull) + (offset) * 64;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -927,8 +978,13 @@ static inline uint64_t CVMX_L2C_RSDX_PFC(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180080800818ull) + ((offset) & 3) * 64;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 9))
-				return CVMX_ADD_IO_SEG(0x0001180080800818ull) + ((offset) & 15) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 9))
+					return CVMX_ADD_IO_SEG(0x0001180080800818ull) + ((offset) & 15) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 9))
+					return CVMX_ADD_IO_SEG(0x0001180080800818ull) + ((offset) & 15) * 64;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -955,7 +1011,11 @@ static inline uint64_t CVMX_L2C_RSDX_PFC(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800818ull) + (offset) * 64;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180080800818ull) + (offset) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180080800818ull) + (offset) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180080800818ull) + (offset) * 64;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1039,6 +1099,7 @@ static inline uint64_t CVMX_L2C_TADX_DLL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_TADX_DLL(%lu) is invalid on this chip\n", offset);
@@ -1083,6 +1144,7 @@ static inline uint64_t CVMX_L2C_TADX_ERR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_TADX_ERR(%lu) is invalid on this chip\n", offset);
@@ -1116,6 +1178,7 @@ static inline uint64_t CVMX_L2C_TADX_INT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
@@ -1191,6 +1254,7 @@ static inline uint64_t CVMX_L2C_TADX_PFCX(unsigned long offset, unsigned long bl
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 7)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 7)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_L2C_TADX_PFCX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1209,6 +1273,7 @@ static inline uint64_t CVMX_L2C_TADX_PRF(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
@@ -1241,6 +1306,7 @@ static inline uint64_t CVMX_L2C_TADX_TAG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
@@ -1255,6 +1321,7 @@ static inline uint64_t CVMX_L2C_TADX_TIMEOUT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_TADX_TIMEOUT(%lu) is invalid on this chip\n", offset);
@@ -1268,6 +1335,7 @@ static inline uint64_t CVMX_L2C_TADX_TIMETWO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_TADX_TIMETWO(%lu) is invalid on this chip\n", offset);
@@ -1280,7 +1348,7 @@ static inline uint64_t CVMX_L2C_TADX_TIMETWO(unsigned long offset)
 #define CVMX_L2C_TAD_CTL CVMX_L2C_TAD_CTL_FUNC()
 static inline uint64_t CVMX_L2C_TAD_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_L2C_TAD_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800018ull);
 }
@@ -1293,6 +1361,7 @@ static inline uint64_t CVMX_L2C_TBFX_BIST_STATUS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_TBFX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
@@ -1307,6 +1376,7 @@ static inline uint64_t CVMX_L2C_TDTX_BIST_STATUS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_TDTX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
@@ -1321,6 +1391,7 @@ static inline uint64_t CVMX_L2C_TQDX_ERR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_TQDX_ERR(%lu) is invalid on this chip\n", offset);
@@ -1335,6 +1406,7 @@ static inline uint64_t CVMX_L2C_TTGX_BIST_STATUS(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_TTGX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
@@ -1349,6 +1421,7 @@ static inline uint64_t CVMX_L2C_TTGX_ERR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_L2C_TTGX_ERR(%lu) is invalid on this chip\n", offset);
@@ -1467,6 +1540,7 @@ static inline uint64_t CVMX_L2C_WPAR_IOBX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1486,6 +1560,7 @@ static inline uint64_t CVMX_L2C_WPAR_PPX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
@@ -1509,8 +1584,13 @@ static inline uint64_t CVMX_L2C_XMCX_PFC(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180080800800ull) + ((offset) & 3) * 64;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 9))
-				return CVMX_ADD_IO_SEG(0x0001180080800800ull) + ((offset) & 15) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 9))
+					return CVMX_ADD_IO_SEG(0x0001180080800800ull) + ((offset) & 15) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 9))
+					return CVMX_ADD_IO_SEG(0x0001180080800800ull) + ((offset) & 15) * 64;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1537,7 +1617,11 @@ static inline uint64_t CVMX_L2C_XMCX_PFC(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800800ull) + (offset) * 64;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180080800800ull) + (offset) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180080800800ull) + (offset) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180080800800ull) + (offset) * 64;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1553,7 +1637,7 @@ static inline uint64_t CVMX_L2C_XMCX_PFC(unsigned long offset)
 #define CVMX_L2C_XMC_CMD CVMX_L2C_XMC_CMD_FUNC()
 static inline uint64_t CVMX_L2C_XMC_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_L2C_XMC_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180080800028ull);
 }
@@ -1574,8 +1658,13 @@ static inline uint64_t CVMX_L2C_XMDX_PFC(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180080800808ull) + ((offset) & 3) * 64;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 9))
-				return CVMX_ADD_IO_SEG(0x0001180080800808ull) + ((offset) & 15) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 9))
+					return CVMX_ADD_IO_SEG(0x0001180080800808ull) + ((offset) & 15) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 9))
+					return CVMX_ADD_IO_SEG(0x0001180080800808ull) + ((offset) & 15) * 64;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1602,7 +1691,11 @@ static inline uint64_t CVMX_L2C_XMDX_PFC(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180080800808ull) + (offset) * 64;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180080800808ull) + (offset) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180080800808ull) + (offset) * 64;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180080800808ull) + (offset) * 64;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2533,8 +2626,7 @@ union cvmx_l2c_cbcx_holeerr {
 	uint64_t holerd                       : 1;  /**< Logged information is for a HOLERD error. */
 	uint64_t holewr                       : 1;  /**< Logged information is for a HOLEWR error. */
 	uint64_t reserved_59_61               : 3;
-	uint64_t cmd                          : 8;  /**< Encoding of XMC command causing error. INTERNAL: CMD[7] should always be 1, use
-                                                         XMC_CMD_E to decode CMD[6:0]. */
+	uint64_t cmd                          : 8;  /**< Encoding of XMC command causing error. */
 	uint64_t source                       : 7;  /**< XMC 'source' of request causing error. If SOURCE<6>==0, then SOURCE<5:0> is PPID, else
                                                          SOURCE<3:0> is BUSID of the IOB which made the request. */
 	uint64_t node                         : 4;  /**< CCPI is not present. Should always read 0. */
@@ -3352,129 +3444,6 @@ typedef union cvmx_l2c_cfg cvmx_l2c_cfg_t;
  * 3. If a COP0 register cannot be accessed by this mechanism the write be silently
  * ignored and the read data will be 0x2bad2bad2bad2bad. Otherwise, if the COP0
  * register doesn't exist, the read data value will be 0x000000000baddeed.
- *
- * INTERNAL: In HRM, see table in L2C chapter body text.
- * Referring to note 1 above, the following root/rd/sel values are supported:
- *
- * NOTE: Put only the "Customer type" in HRM. do not put the "Real type" in HRM.
- *
- *              Customer                                           Real
- * root rd  sel   type         Description                         type
- * ====+===+===+========+=========================================+====
- *  1    4   2     RO     CP0 Root.UserLocal                        RW
- *  0    4   2     RO     CP0 Guest.UserLocal                       RW
- *  1    7   0     RO     CP0 Root.HWREna                           RW
- *  0    7   0     RO     CP0 Guest.HWREna                          RW
- *  1    8   1     RO     CP0 Root.BadInstr                         RW
- *  0    8   1     RO     CP0 Guest.BadInstr                        RW
- *  1    8   2     RO     CP0 Root.BadInstrP                        RW
- *  0    8   2     RO     CP0 Guest.BadInstrP                       RW
- *  1    9   0     RO     CP0 Root.Count                            RW
- *  1    9   6     RO     CP0 Root.CvmCount                         RW
- *  1    9   7     RO     CP0 Root.CvmCtl                           RW
- *  0    9   7     RO     CP0 Guest.CvmCtl                          RW
- *  1   10   5     RO     CP0 Root.GuestCtl0                        RW
- *  1   11   0     RO     CP0 Root.Compare                          RW
- *  0   11   0     RO     CP0 Guest.Compare                         RW
- *  1   11   4     RO     CP0 Root.GuestCtl0Ext                     RW
- *  1   11   6     RW     CP0 Root.PowThrottle                      RW
- *  1   12   0     RO     CP0 Root.Status                           RW
- *  0   12   0     RO     CP0 Guest.Status                          RW
- *  1   12   1     RO     CP0 Root.IntCtl                           RO
- *  0   12   1     RO     CP0 Guest.IntCtl                          RO
- *  1   12   2     RO     CP0 Root.SRSCtl                           RO
- *  0   12   2     RO     CP0 Guest.SRSCtl                          RO
- *  1   12   6     RO     CP0 Root.GuestCtl0                        RW
- *  1   12   7     RO     CP0 Root.GTOffset                         RW
- *  1   13   0     RO     CP0 Root.Cause                            RW
- *  0   13   0     RO     CP0 Guest.Cause                           RW
- *  1   14   0     RO     CP0 Root.EPC                              RW
- *  0   14   0     RO     CP0 Guest.EPC                             RW
- *  1   15   0     RO     CP0 Root.PrID                             RO
- *  0   15   0     RO     CP0 Guest.PrID                            RO
- *  1   15   1     RO     CP0 Root.EBase                            RW
- *  0   15   1     RO     CP0 Guest.EBase                           RW
- *  1   16   0     RO     PC Issue Debug Info (see details below)   RO
- *  1   16   1     RO     PC Fetch Debug Info (see details below)   RO
- *  1   16   2     RO     PC Fill Debug Info (see details below)    RO
- *  1   16   3     RO     PC Misc Debug Info (see details below)    RO
- *  1   16   5     RO     PC Committed Info (see details below)     RO
- *  1   18   0     RO     CP0 Root.WatchLo0                         RW
- *  1   19   0     RO     CP0 Root.WatchHi0                         RW
- *  1   22   0     RO     CP0 Root.MultiCoreDebug                   RW
- *  1   22   1     --     CP0 Root.ImplDebug                        R0
- *  1   22   2     RO     CP0 Root.CvmCountOffset                   RW
- *  1   23   0     RO     CP0 Root.Debug                            RW
- *  1   23   6     RO     CP0 Root.Debug2                           RO
- *  1   24   0     RO     CP0 Root.DEPC                             RW
- *  1   25   0     RO     CP0 Root.PerfCnt Control0                 RW
- *  1   25   1     RO     CP0 Root.PerfCnt Counter0                 RW
- *  1   25   2     RO     CP0 Root.PerfCnt Control1                 RW
- *  1   25   3     RO     CP0 Root.PerfCnt Counter1                 RW
- *  1   25   4     RO     CP0 Root.PerfCnt Control2                 RW
- *  1   25   5     RO     CP0 Root.PerfCnt Counter2                 RW
- *  1   25   6     RO     CP0 Root.PerfCnt Control3                 RW
- *  1   25   7     RO     CP0 Root.PerfCnt Counter3                 RW
- *  1   27   0     RO     CP0 Root.CacheErr (icache)                RW
- *  1   27   2     RO     CP0 Root.IcacheDebug                      RO
- *  1   28   0     RO     CP0 Root.TagLo (icache)                   RW
- *  1   28   1     RO     CP0 Root.DataLo (icache)                  RW
- *  1   29   1     RO     CP0 Root.DataHi (icache)                  RW
- *  1   30   0     RO     CP0 Root.ErrorEPC                         RW
- *  0   30   0     RO     CP0 Guest.ErrorEPC                        RW
- *  1   31   0     RO     CP0 Root.DESAVE                           RW
- *  1   31   2     RO     CP0 Root.Scratch                          RW
- *  0   31   2     RO     CP0 Guest.Scratch                         RW
- *  1   31   3     RO     CP0 Root.Scratch1                         RW
- *  0   31   3     RO     CP0 Guest.Scratch1                        RW
- *  1   31   4     RO     CP0 Root.Scratch2                         RW
- *  0   31   4     RO     CP0 Guest.Scratch2                        RW
- *  1   31   5     RO     CP0 Root.Scratch3                         RW
- *
- * PC Issue Debug Info
- *  - 63:2  issue_address<63:2>   // often VA<63:2> (PC) of the next instruction to issue (5a in
- * pipeline)
- *                              //    but can also be the PC of an instruction
- *                              //    executing/replaying
- *                              //    or can also be a PC being filled into the instruction cache
- *                              //    or can also be unpredictable
- *                              // <58:50> is a copy of <49>
- *  1     issue_illegal         // set when issue_address is an illegal PC
- *  0     issue_delayslot       // set when issue_address is in a delayslot (prior instruction
- *                              // may be either taken or not taken)
- *
- * PC Fetch Debug Info
- *  - 63:1  fetch_address<63:1>   // VA <63:0> (PC) being fetched from the instruction cache (3a in
- *                              // pipeline)
- *                              // <58:50> is a copy of <49>
- *                              // <1> RAZ
- *  0     fetch_guest           // set when fetch_address is for the guest
- *
- * PC Fill Debug Info
- *  - 63:2  fill_address<63:2>    // VA<63:2> being filled into instruction cache (4a in pipeline)
- *                              // valid when waiting_for_ifill is set (see PC Misc Debug Info
- *                              // below)
- *                              // <58:50> is a copy of <49>
- *  1     fill_illegal          // set when fill_address is an illegal PC
- *  0     fill_guest            // set when fill_address is for the guest
- *
- * PC Misc Debug Info
- *  - 63:5  RAZ
- *  4     kernel_mode           // set if the CPU is in kernel mode (6a in pipeline)
- *  3     guest_mode            // set if the CPU is in guest mode (6a in pipeline)
- *  2     mem_stall             // stall term from L1 memory system (3a in pipeline)
- *  1     waiting_for_pfill     // when waiting_for_ifill is set, indicates whether instruction
- *                              // cache fill is due to a prefetch (4a in pipeline)
- *  0     waiting_for_ifill     // set when there is an outstanding instruction cache fill (4a in
- *                              // pipeline)
- *
- * PC Committed Debug Info
- *  63    commit_guest          // Set if commit_address was for the guest
- *  - 62:55 commit_ASID           // ASID of commit_address
- *  - 54:49 commit_address<63:59> // VA<63:59> (PC) of the last committed instruction (11a in
- *                              // pipeline)
- *  - 48:0  commit_address<48:0>  // VA<48:0> (PC) of last committed instruction (11a in pipeline)
- *                              // <1:0> RAZ
  */
 union cvmx_l2c_cop0_adr {
 	uint64_t u64;
@@ -7507,8 +7476,7 @@ union cvmx_l2c_tadx_err {
 	uint64_t bigrd                        : 1;  /**< Logged information is for a BIGRD error. */
 	uint64_t bigwr                        : 1;  /**< Logged information is for a BIGWR error. */
 	uint64_t reserved_59_61               : 3;
-	uint64_t cmd                          : 8;  /**< Encoding of XMC command causing error.
-                                                         INTERNAL: CMD[7] should always be 1, use XMC_CMD_E to decode CMD[6:0]. */
+	uint64_t cmd                          : 8;  /**< Encoding of XMC command causing error. */
 	uint64_t source                       : 7;  /**< XMC source of request causing error. If SOURCE<6>==0, then SOURCE<5:0> is PPID, else
                                                          SOURCE<3:0> is BUSID of the IOB which made the request. If CMD[7]==0, this field is
                                                          unpredictable. */
@@ -7561,8 +7529,7 @@ union cvmx_l2c_tadx_err {
 	uint64_t rddisoci                     : 1;  /**< Reserved. */
 	uint64_t wrdisoci                     : 1;  /**< Reserved. */
 	uint64_t reserved_59_59               : 1;
-	uint64_t cmd                          : 8;  /**< Encoding of XMC command causing error.
-                                                         INTERNAL: CMD[7] should always be 1, use XMC_CMD_E to decode CMD[6:0]. */
+	uint64_t cmd                          : 8;  /**< Encoding of XMC command causing error. */
 	uint64_t source                       : 7;  /**< XMC source of request causing error. If SOURCE<6>==0, then SOURCE<5:0> is PPID, else
                                                          SOURCE<3:0> is BUSID of the IOB which made the request. If CMD[7]==0, this field is
                                                          unpredictable. */
@@ -8142,9 +8109,7 @@ union cvmx_l2c_tadx_tag {
 	struct cvmx_l2c_tadx_tag_cn61xx       cn68xxp1;
 	struct cvmx_l2c_tadx_tag_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sblkdty                      : 4;  /**< Sub-block dirty bits. INTERNAL: 70xx does not implement true sub-block dirty bits,
-                                                         therefore when L2C_TAD_TAG is written, it is set to all ones if DIRTY is 1, or all zeroes
-                                                         if DIRTY is zero. LTGL2I will always result in similar legal values being loaded. */
+	uint64_t sblkdty                      : 4;  /**< Sub-block dirty bits. */
 	uint64_t reserved_56_59               : 4;
 	uint64_t businfo                      : 8;  /**< The businfo bits. Legal values: when [55]==1, we are in idmode and [54:50] must be 0,
                                                          [49:48] are the PPVID of the PP which could be holding the block; when [55]==0, we are in
@@ -8276,8 +8241,7 @@ union cvmx_l2c_tadx_timeout {
                                                          then both could have timed out, but info captured is from the original LFB. */
 	uint64_t reserved_57_61               : 5;
 	uint64_t lfbnum                       : 5;  /**< The LFB number of the entry that timed out, and have its info captures in this register. */
-	uint64_t cmd                          : 8;  /**< Encoding of XMC command causing error.
-                                                         INTERNAL: CMD[7] should always be 1, use XMC_CMD_E to decode CMD[6:0]. */
+	uint64_t cmd                          : 8;  /**< Encoding of XMC command causing error. */
 	uint64_t node                         : 4;  /**< Home node of the address causing the error. Similar the ADDR below, this can be the
                                                          request address (if INFOLFB is set), else it is the replacement address (if INFOLFB is
                                                          clear & INFOVAB is set). */
@@ -9136,10 +9100,6 @@ typedef union cvmx_l2c_xmcx_pfc cvmx_l2c_xmcx_pfc_t;
  *
  * Any FILL responses generated by the ADD bus command are ignored. Generated STINs, however,
  * will correctly invalidate the required cores.
- * Any L2D read generated by the ADD bus command records the syndrome information in
- * L2C_TAD(0..3)_ECC0/1. If ECC is disabled prior to the CSR write, this provides the ability to
- * read the ECC bits directly. If ECC is not disabled, this should log zeros (assuming no ECC
- * errors were found in the block).
  *
  * A write that arrives while the INUSE bit is set will block until the INUSE bit clears. This
  * gives software two options when needing to issue a stream of write operations to L2C_XMC_CMD:
diff --git a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
index a0be9dd..78e8175 100644
--- a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
@@ -56,6 +56,7 @@
 static inline uint64_t CVMX_LAPX_BIST_RESULT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_BIST_RESULT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C010000ull) + ((offset) & 1) * 0x1000000ull;
@@ -67,6 +68,7 @@ static inline uint64_t CVMX_LAPX_BIST_RESULT(unsigned long offset)
 static inline uint64_t CVMX_LAPX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C010040ull) + ((offset) & 1) * 0x1000000ull;
@@ -78,6 +80,7 @@ static inline uint64_t CVMX_LAPX_CFG(unsigned long offset)
 static inline uint64_t CVMX_LAPX_EDAT_ERR_ST(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_EDAT_ERR_ST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C010220ull) + ((offset) & 1) * 0x1000000ull;
@@ -89,6 +92,7 @@ static inline uint64_t CVMX_LAPX_EDAT_ERR_ST(unsigned long offset)
 static inline uint64_t CVMX_LAPX_EMSK_ERR_ST(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_EMSK_ERR_ST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C010218ull) + ((offset) & 1) * 0x1000000ull;
@@ -100,6 +104,7 @@ static inline uint64_t CVMX_LAPX_EMSK_ERR_ST(unsigned long offset)
 static inline uint64_t CVMX_LAPX_ERR_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_ERR_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C010050ull) + ((offset) & 1) * 0x1000000ull;
@@ -111,6 +116,7 @@ static inline uint64_t CVMX_LAPX_ERR_CFG(unsigned long offset)
 static inline uint64_t CVMX_LAPX_EXPX_DATA(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 15)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 15)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_LAPX_EXPX_DATA(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000118000C020000ull) + (((offset) & 15) + ((block_id) & 1) * 0x200000ull) * 8;
@@ -122,6 +128,7 @@ static inline uint64_t CVMX_LAPX_EXPX_DATA(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_LAPX_EXPX_VALID(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 15)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 15)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_LAPX_EXPX_VALID(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000118000C030000ull) + (((offset) & 15) + ((block_id) & 1) * 0x200000ull) * 8;
@@ -133,6 +140,7 @@ static inline uint64_t CVMX_LAPX_EXPX_VALID(unsigned long offset, unsigned long
 static inline uint64_t CVMX_LAPX_FREE_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_FREE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C010100ull) + ((offset) & 1) * 0x1000000ull;
@@ -144,6 +152,7 @@ static inline uint64_t CVMX_LAPX_FREE_STATE(unsigned long offset)
 static inline uint64_t CVMX_LAPX_GEN_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_GEN_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C010010ull) + ((offset) & 1) * 0x1000000ull;
@@ -155,6 +164,7 @@ static inline uint64_t CVMX_LAPX_GEN_INT(unsigned long offset)
 static inline uint64_t CVMX_LAPX_LABX_STATE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 255)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 255)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_LAPX_LABX_STATE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000118000C060000ull) + (((offset) & 255) + ((block_id) & 1) * 0x200000ull) * 8;
@@ -166,6 +176,7 @@ static inline uint64_t CVMX_LAPX_LABX_STATE(unsigned long offset, unsigned long
 static inline uint64_t CVMX_LAPX_LAB_DATAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1535)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1535)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_LAPX_LAB_DATAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000118000C080000ull) + (((offset) & 2047) + ((block_id) & 1) * 0x200000ull) * 8;
@@ -177,6 +188,7 @@ static inline uint64_t CVMX_LAPX_LAB_DATAX(unsigned long offset, unsigned long b
 static inline uint64_t CVMX_LAPX_LAB_ERR_ST(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_LAB_ERR_ST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C010200ull) + ((offset) & 1) * 0x1000000ull;
@@ -188,6 +200,7 @@ static inline uint64_t CVMX_LAPX_LAB_ERR_ST(unsigned long offset)
 static inline uint64_t CVMX_LAPX_NXT_ERR_ST(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_NXT_ERR_ST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C010210ull) + ((offset) & 1) * 0x1000000ull;
@@ -199,6 +212,7 @@ static inline uint64_t CVMX_LAPX_NXT_ERR_ST(unsigned long offset)
 static inline uint64_t CVMX_LAPX_QUEX_CFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 2)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 2)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_LAPX_QUEX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000118000C040000ull) + (((offset) & 3) + ((block_id) & 1) * 0x200000ull) * 8;
@@ -210,6 +224,7 @@ static inline uint64_t CVMX_LAPX_QUEX_CFG(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_LAPX_QUEX_STATE(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 2)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 2)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_LAPX_QUEX_STATE(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000118000C050000ull) + (((offset) & 3) + ((block_id) & 1) * 0x200000ull) * 8;
@@ -221,6 +236,7 @@ static inline uint64_t CVMX_LAPX_QUEX_STATE(unsigned long offset, unsigned long
 static inline uint64_t CVMX_LAPX_RESP_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_RESP_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C010108ull) + ((offset) & 1) * 0x1000000ull;
@@ -232,6 +248,7 @@ static inline uint64_t CVMX_LAPX_RESP_STATE(unsigned long offset)
 static inline uint64_t CVMX_LAPX_SFT_RST(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_SFT_RST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C000008ull) + ((offset) & 1) * 0x1000000ull;
@@ -243,6 +260,7 @@ static inline uint64_t CVMX_LAPX_SFT_RST(unsigned long offset)
 static inline uint64_t CVMX_LAPX_STA_ERR_ST(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_STA_ERR_ST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C010208ull) + ((offset) & 1) * 0x1000000ull;
@@ -254,6 +272,7 @@ static inline uint64_t CVMX_LAPX_STA_ERR_ST(unsigned long offset)
 static inline uint64_t CVMX_LAPX_TIMEOUT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_TIMEOUT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C010060ull) + ((offset) & 1) * 0x1000000ull;
@@ -265,6 +284,7 @@ static inline uint64_t CVMX_LAPX_TIMEOUT(unsigned long offset)
 static inline uint64_t CVMX_LAPX_XID_POS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LAPX_XID_POS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118000C010070ull) + ((offset) & 1) * 0x1000000ull;
@@ -284,13 +304,13 @@ union cvmx_lapx_bist_result {
 	struct cvmx_lapx_bist_result_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
-	uint64_t nbr                          : 1;  /**< BIST result of the NBR memory. INTERNAL: nbr.nbr_mem_fif. */
-	uint64_t edat                         : 1;  /**< BIST result of the EDAT memory. INTERNAL: rcv.lap_exp_dat_mem. */
-	uint64_t emsk                         : 1;  /**< BIST result of the EMSK memory. INTERNAL: rcv.lap_exp_msk_mem. */
+	uint64_t nbr                          : 1;  /**< BIST result of the NBR memory. */
+	uint64_t edat                         : 1;  /**< BIST result of the EDAT memory. */
+	uint64_t emsk                         : 1;  /**< BIST result of the EMSK memory. */
 	uint64_t reserved_4_5                 : 2;
-	uint64_t lab_dat                      : 2;  /**< BIST result of the LAB_DAT memory. INTERNAL: lab.lab_bnk[0,1]_mem. */
-	uint64_t ctl_nxt                      : 1;  /**< BIST result of the CTL_NXT memory. INTERNAL: ctl.lap_stl_nxt_mem. */
-	uint64_t ctl_sta                      : 1;  /**< BIST result of the CTL_STA memory. INTERNAL: ctl.lap_stl_sta_mem. */
+	uint64_t lab_dat                      : 2;  /**< BIST result of the LAB_DAT memory. */
+	uint64_t ctl_nxt                      : 1;  /**< BIST result of the CTL_NXT memory. */
+	uint64_t ctl_sta                      : 1;  /**< BIST result of the CTL_STA memory. */
 #else
 	uint64_t ctl_sta                      : 1;
 	uint64_t ctl_nxt                      : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-lbk-defs.h b/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
index 15cb7c8..c3b1fa9 100644
--- a/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_LBK_BIST_RESULT CVMX_LBK_BIST_RESULT_FUNC()
 static inline uint64_t CVMX_LBK_BIST_RESULT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_LBK_BIST_RESULT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000020ull);
 }
@@ -68,6 +68,7 @@ static inline uint64_t CVMX_LBK_CHX_PKIND(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_LBK_CHX_PKIND(%lu) is invalid on this chip\n", offset);
@@ -80,7 +81,7 @@ static inline uint64_t CVMX_LBK_CHX_PKIND(unsigned long offset)
 #define CVMX_LBK_CLK_GATE_CTL CVMX_LBK_CLK_GATE_CTL_FUNC()
 static inline uint64_t CVMX_LBK_CLK_GATE_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_LBK_CLK_GATE_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000008ull);
 }
@@ -91,7 +92,7 @@ static inline uint64_t CVMX_LBK_CLK_GATE_CTL_FUNC(void)
 #define CVMX_LBK_DAT_ERR_INFO CVMX_LBK_DAT_ERR_INFO_FUNC()
 static inline uint64_t CVMX_LBK_DAT_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_LBK_DAT_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000050ull);
 }
@@ -102,7 +103,7 @@ static inline uint64_t CVMX_LBK_DAT_ERR_INFO_FUNC(void)
 #define CVMX_LBK_ECC_CFG CVMX_LBK_ECC_CFG_FUNC()
 static inline uint64_t CVMX_LBK_ECC_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_LBK_ECC_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000060ull);
 }
@@ -113,7 +114,7 @@ static inline uint64_t CVMX_LBK_ECC_CFG_FUNC(void)
 #define CVMX_LBK_INT CVMX_LBK_INT_FUNC()
 static inline uint64_t CVMX_LBK_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_LBK_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000040ull);
 }
@@ -124,7 +125,7 @@ static inline uint64_t CVMX_LBK_INT_FUNC(void)
 #define CVMX_LBK_SFT_RST CVMX_LBK_SFT_RST_FUNC()
 static inline uint64_t CVMX_LBK_SFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_LBK_SFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180012000000ull);
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index 327bc4e..be94bd7 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -99,8 +99,13 @@ static inline uint64_t CVMX_LMCX_BIST_CTL(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180088000100ull) + ((offset) & 3) * 0x1000000ull;
+
 			break;
 	}
 	cvmx_warn("CVMX_LMCX_BIST_CTL (offset = %lu) not supported on this chip\n", offset);
@@ -121,7 +126,11 @@ static inline uint64_t CVMX_LMCX_BIST_CTL(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (offset) * 0x1000000ull;
+
 	}
 	return CVMX_ADD_IO_SEG(0x0001180088000100ull) + (offset) * 0x1000000ull;
 }
@@ -149,6 +158,7 @@ static inline uint64_t CVMX_LMCX_CHAR_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -164,6 +174,7 @@ static inline uint64_t CVMX_LMCX_CHAR_DQ_ERR_COUNT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_CHAR_DQ_ERR_COUNT(%lu) is invalid on this chip\n", offset);
@@ -182,6 +193,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -201,6 +213,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -220,6 +233,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -239,6 +253,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK3(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -258,6 +273,7 @@ static inline uint64_t CVMX_LMCX_CHAR_MASK4(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -294,6 +310,7 @@ static inline uint64_t CVMX_LMCX_COMP_CTL2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -313,6 +330,7 @@ static inline uint64_t CVMX_LMCX_CONFIG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -332,6 +350,7 @@ static inline uint64_t CVMX_LMCX_CONTROL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -396,6 +415,7 @@ static inline uint64_t CVMX_LMCX_DCLK_CNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -473,6 +493,7 @@ static inline uint64_t CVMX_LMCX_DDR4_DIMM_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_DDR4_DIMM_CTL(%lu) is invalid on this chip\n", offset);
@@ -491,6 +512,7 @@ static inline uint64_t CVMX_LMCX_DDR_PLL_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -522,6 +544,7 @@ static inline uint64_t CVMX_LMCX_DIMMX_DDR4_PARAMS0(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_LMCX_DIMMX_DDR4_PARAMS0(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -536,6 +559,7 @@ static inline uint64_t CVMX_LMCX_DIMMX_DDR4_PARAMS1(unsigned long offset, unsign
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_LMCX_DIMMX_DDR4_PARAMS1(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -554,6 +578,7 @@ static inline uint64_t CVMX_LMCX_DIMMX_PARAMS(unsigned long offset, unsigned lon
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
@@ -573,6 +598,7 @@ static inline uint64_t CVMX_LMCX_DIMM_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -604,6 +630,7 @@ static inline uint64_t CVMX_LMCX_DLL_CTL2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -623,6 +650,7 @@ static inline uint64_t CVMX_LMCX_DLL_CTL3(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -653,6 +681,12 @@ static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((offset) & 3) * 0x1000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((offset) & 3) * 0x1000000ull;
@@ -682,6 +716,10 @@ static inline uint64_t CVMX_LMCX_DUAL_MEMCFG(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000098ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -695,6 +733,7 @@ static inline uint64_t CVMX_LMCX_ECC_PARITY_TEST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_ECC_PARITY_TEST(%lu) is invalid on this chip\n", offset);
@@ -731,6 +770,12 @@ static inline uint64_t CVMX_LMCX_ECC_SYND(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((offset) & 3) * 0x1000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((offset) & 3) * 0x1000000ull;
@@ -761,6 +806,10 @@ static inline uint64_t CVMX_LMCX_ECC_SYND(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000038ull) + (offset) * 0x1000000ull;
 	}
@@ -773,6 +822,7 @@ static inline uint64_t CVMX_LMCX_EXT_CONFIG(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_EXT_CONFIG(%lu) is invalid on this chip\n", offset);
@@ -822,6 +872,12 @@ static inline uint64_t CVMX_LMCX_FADR(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((offset) & 3) * 0x1000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((offset) & 3) * 0x1000000ull;
@@ -852,6 +908,10 @@ static inline uint64_t CVMX_LMCX_FADR(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180088000020ull) + (offset) * 0x1000000ull;
 	}
@@ -907,6 +967,7 @@ static inline uint64_t CVMX_LMCX_IFB_CNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -960,6 +1021,7 @@ static inline uint64_t CVMX_LMCX_INT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -979,6 +1041,7 @@ static inline uint64_t CVMX_LMCX_INT_EN(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -993,6 +1056,7 @@ static inline uint64_t CVMX_LMCX_LANEX_CRC_SWIZ(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 8)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 8)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 8)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 8)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_LMCX_LANEX_CRC_SWIZ(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1045,6 +1109,7 @@ static inline uint64_t CVMX_LMCX_MODEREG_PARAMS0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1064,6 +1129,7 @@ static inline uint64_t CVMX_LMCX_MODEREG_PARAMS1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1079,6 +1145,7 @@ static inline uint64_t CVMX_LMCX_MODEREG_PARAMS2(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS2(%lu) is invalid on this chip\n", offset);
@@ -1093,6 +1160,7 @@ static inline uint64_t CVMX_LMCX_MODEREG_PARAMS3(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_MODEREG_PARAMS3(%lu) is invalid on this chip\n", offset);
@@ -1107,6 +1175,7 @@ static inline uint64_t CVMX_LMCX_MPR_DATA0(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_MPR_DATA0(%lu) is invalid on this chip\n", offset);
@@ -1121,6 +1190,7 @@ static inline uint64_t CVMX_LMCX_MPR_DATA1(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_MPR_DATA1(%lu) is invalid on this chip\n", offset);
@@ -1135,6 +1205,7 @@ static inline uint64_t CVMX_LMCX_MPR_DATA2(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_MPR_DATA2(%lu) is invalid on this chip\n", offset);
@@ -1149,6 +1220,7 @@ static inline uint64_t CVMX_LMCX_MR_MPR_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_MR_MPR_CTL(%lu) is invalid on this chip\n", offset);
@@ -1190,6 +1262,12 @@ static inline uint64_t CVMX_LMCX_NXM(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((offset) & 1) * 0x1000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((offset) & 3) * 0x1000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((offset) & 3) * 0x1000000ull;
@@ -1218,6 +1296,10 @@ static inline uint64_t CVMX_LMCX_NXM(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880000C8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1232,6 +1314,7 @@ static inline uint64_t CVMX_LMCX_NXM_FADR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_NXM_FADR(%lu) is invalid on this chip\n", offset);
@@ -1250,6 +1333,7 @@ static inline uint64_t CVMX_LMCX_OPS_CNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1303,6 +1387,7 @@ static inline uint64_t CVMX_LMCX_PHY_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1437,6 +1522,7 @@ static inline uint64_t CVMX_LMCX_RESET_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1482,6 +1568,7 @@ static inline uint64_t CVMX_LMCX_RLEVEL_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1501,6 +1588,7 @@ static inline uint64_t CVMX_LMCX_RLEVEL_DBG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1520,6 +1608,7 @@ static inline uint64_t CVMX_LMCX_RLEVEL_RANKX(unsigned long offset, unsigned lon
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset <= 3)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 1))))))
@@ -1570,6 +1659,7 @@ static inline uint64_t CVMX_LMCX_RODT_MASK(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1587,6 +1677,7 @@ static inline uint64_t CVMX_LMCX_SCRAMBLED_FADR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1604,6 +1695,7 @@ static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1621,6 +1713,7 @@ static inline uint64_t CVMX_LMCX_SCRAMBLE_CFG1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1649,6 +1742,7 @@ static inline uint64_t CVMX_LMCX_SEQ_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_SEQ_CTL(%lu) is invalid on this chip\n", offset);
@@ -1667,6 +1761,7 @@ static inline uint64_t CVMX_LMCX_SLOT_CTL0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1686,6 +1781,7 @@ static inline uint64_t CVMX_LMCX_SLOT_CTL1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1705,6 +1801,7 @@ static inline uint64_t CVMX_LMCX_SLOT_CTL2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1737,6 +1834,7 @@ static inline uint64_t CVMX_LMCX_TIMING_PARAMS0(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1756,6 +1854,7 @@ static inline uint64_t CVMX_LMCX_TIMING_PARAMS1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1771,6 +1870,7 @@ static inline uint64_t CVMX_LMCX_TIMING_PARAMS2(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_LMCX_TIMING_PARAMS2(%lu) is invalid on this chip\n", offset);
@@ -1819,6 +1919,7 @@ static inline uint64_t CVMX_LMCX_WLEVEL_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1838,6 +1939,7 @@ static inline uint64_t CVMX_LMCX_WLEVEL_DBG(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1861,8 +1963,13 @@ static inline uint64_t CVMX_LMCX_WLEVEL_RANKX(unsigned long offset, unsigned lon
 				return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + (((offset) & 3) + ((block_id) & 1) * 0x200000ull) * 8;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if (((offset <= 3)) && ((block_id <= 3)))
-				return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + (((offset) & 3) + ((block_id) & 3) * 0x200000ull) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if (((offset <= 3)) && ((block_id <= 3)))
+					return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + (((offset) & 3) + ((block_id) & 3) * 0x200000ull) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if (((offset <= 3)) && ((block_id <= 3)))
+					return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + (((offset) & 3) + ((block_id) & 3) * 0x200000ull) * 8;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1892,7 +1999,11 @@ static inline uint64_t CVMX_LMCX_WLEVEL_RANKX(unsigned long offset, unsigned lon
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800880002C0ull) + ((offset) + (block_id) * 0x200000ull) * 8;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800880002B0ull) + ((offset) + (block_id) * 0x0ull) * 8;
@@ -1946,6 +2057,7 @@ static inline uint64_t CVMX_LMCX_WODT_MASK(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2662,7 +2774,7 @@ union cvmx_lmcx_comp_ctl2 {
 	struct cvmx_lmcx_comp_ctl2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_51_63               : 13;
-	uint64_t rclk_char_mode               : 1;  /**< Reserved. INTERNAL: Select RCLK characterization mode. */
+	uint64_t rclk_char_mode               : 1;  /**< Reserved. */
 	uint64_t reserved_40_49               : 10;
 	uint64_t ptune_offset                 : 4;  /**< Ptune offset value. This is a signed value where the MSB is a sign bit, with zero
                                                          indicating addition and one indicating subtraction. */
@@ -2800,7 +2912,7 @@ union cvmx_lmcx_comp_ctl2 {
 	struct cvmx_lmcx_comp_ctl2_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_51_63               : 13;
-	uint64_t rclk_char_mode               : 1;  /**< Reserved. INTERNAL: Select RCLK characterization mode. */
+	uint64_t rclk_char_mode               : 1;  /**< Reserved. */
 	uint64_t ddr__ptune                   : 5;  /**< DDR PCTL from compensation circuit. The encoded value provides debug information for the
                                                          compensation impedance on P-pullup. */
 	uint64_t ddr__ntune                   : 5;  /**< DDR NCTL from compensation circuit. The encoded value provides debug information for the
@@ -2809,7 +2921,7 @@ union cvmx_lmcx_comp_ctl2 {
                                                          indicating addition and one indicating subtraction. */
 	uint64_t ntune_offset                 : 4;  /**< Ntune offset value. This is a signed value where the MSB is a sign bit, with zero
                                                          indicating addition and one indicating subtraction. */
-	uint64_t m180                         : 1;  /**< Reserved; must be zero. INTERNAL: Cap impedance at 180 ohm, instead of 240 ohm. */
+	uint64_t m180                         : 1;  /**< Reserved; must be zero. */
 	uint64_t byp                          : 1;  /**< Bypass mode. When set, PTUNE,NTUNE are the compensation setting. When clear,
                                                          DDR__PTUNE,DDR__NTUNE are the compensation setting. */
 	uint64_t ptune                        : 5;  /**< PCTL impedance control in bypass mode. */
@@ -2944,42 +3056,17 @@ union cvmx_lmcx_config {
 	uint64_t u64;
 	struct cvmx_lmcx_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t lrdimm_ena                   : 1;  /**< Reserved.
-                                                         INTERNAL: Load Reduced DIMM Enable. When set allows the use of JEDEC DDR4 LRDIMMs. */
+	uint64_t lrdimm_ena                   : 1;  /**< Reserved. */
 	uint64_t bg2_enable                   : 1;  /**< BG1 enable bit. Only has an effect when LMC()_CONFIG[MODEDDR4] = 1.
                                                          Set to 1 when using DDR4 x4 or x8 parts.
                                                          Clear to 0 when using DDR4 x16 parts. */
 	uint64_t mode_x4dev                   : 1;  /**< DDR *4 device mode. */
 	uint64_t mode32b                      : 1;  /**< 32-bit datapath mode. When set, only 32 DQ pins are used. */
 	uint64_t scrz                         : 1;  /**< Hide LMC()_SCRAMBLE_CFG0 and LMC()_SCRAMBLE_CFG1 when set. */
-	uint64_t early_unload_d1_r1           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 3 reads.
-                                                         The recommended EARLY_UNLOAD_D1_R1 value can be calculated after the final
-                                                         LMC()_RLEVEL_RANK3[BYTE*] values are selected (as part of read-leveling initialization).
-                                                         Then, determine the largest read-leveling setting for rank 3 (i.e. calculate
-                                                         maxset=MAX(LMC()_RLEVEL_RANK3[BYTEi]) across all i), then set EARLY_UNLOAD_D1_R1 when the
-                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D1_R1 = (maxset<1:0>
-                                                         !=3)). */
-	uint64_t early_unload_d1_r0           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 2 reads.
-                                                         The recommended EARLY_UNLOAD_D1_RO value can be calculated after the final
-                                                         LMC()_RLEVEL_RANK2[BYTE*] values are selected (as part of read-leveling initialization).
-                                                         Then, determine the largest read-leveling setting for rank 2 (i.e. calculate
-                                                         maxset=MAX(LMC()_RLEVEL_RANK2[BYTEi]) across all i), then set EARLY_UNLOAD_D1_RO when the
-                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D1_RO = (maxset<1:0>
-                                                         !=3)). */
-	uint64_t early_unload_d0_r1           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 1 reads.
-                                                         The recommended EARLY_UNLOAD_D0_R1 value can be calculated after the final
-                                                         LMC()_RLEVEL_RANK1[BYTE*] values are selected (as part of read-leveling initialization).
-                                                         Then, determine the largest read-leveling setting for rank 1 (i.e. calculate
-                                                         maxset=MAX(LMC()_RLEVEL_RANK1[BYTEi]) across all i), then set EARLY_UNLOAD_D0_R1 when the
-                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D0_R1 = (maxset<1:0>
-                                                         !=3)). */
-	uint64_t early_unload_d0_r0           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 0 reads.
-                                                         The recommended EARLY_UNLOAD_D0_R0 value can be calculated after the final
-                                                         LMC()_RLEVEL_RANK0[BYTE*] values are selected (as part of read-leveling initialization).
-                                                         Then, determine the largest read-leveling setting for rank 0 (i.e. calculate
-                                                         maxset=MAX(LMC()_RLEVEL_RANK0[BYTEi]) across all i), then set EARLY_UNLOAD_D0_R0 when the
-                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D0_R0 = (maxset<1:0>
-                                                         !=3)). */
+	uint64_t early_unload_d1_r1           : 1;  /**< Reserved, MBZ. */
+	uint64_t early_unload_d1_r0           : 1;  /**< Reserved, MBZ. */
+	uint64_t early_unload_d0_r1           : 1;  /**< Reserved, MBZ. */
+	uint64_t early_unload_d0_r0           : 1;  /**< Reserved, MBZ. */
 	uint64_t init_status                  : 4;  /**< Indicates status of initialization. INIT_STATUS[n] = 1 implies rank n has been
                                                          initialized.
                                                          Software must set necessary RANKMASK bits before executing the initialization sequence
@@ -3029,8 +3116,7 @@ union cvmx_lmcx_config {
 	uint64_t early_dqx                    : 1;  /**< Set this bit to send DQx signals one CK cycle earlier for the case when the shortest DQx
                                                          lines have a larger delay than the CK line. */
 	uint64_t reserved_18_39               : 22;
-	uint64_t reset                        : 1;  /**< Reset one-shot pulse for LMC()_OPS_CNT, LMC()_IFB_CNT, and LMC()_DCLK_CNT
-                                                         CSRs.
+	uint64_t reset                        : 1;  /**< Reset one-shot pulse for LMC()_OPS_CNT, LMC()_IFB_CNT, and LMC()_DCLK_CNT.
                                                          To cause the reset, software writes this to a 1, then rewrites it to a 0. */
 	uint64_t ecc_adr                      : 1;  /**< Include memory reference address in the ECC calculation.
                                                          0 = disabled, 1 = enabled. */
@@ -3060,9 +3146,7 @@ union cvmx_lmcx_config {
                                                          parts, the column address width = 10, so with 10b of col, 3b of bus, 3b of bank, ROW_LSB =
                                                          16. So, row = mem_adr<29:16>.
                                                          With RANK_ENA = 0, PBANK_LSB = 2.
-                                                         With RANK_ENA = 1, PBANK_LSB = 3.
-                                                         INTERNAL:
-                                                         When interfacing with 8H 3DS, set this 0xA regardless of RANK_ENA value. */
+                                                         With RANK_ENA = 1, PBANK_LSB = 3. */
 	uint64_t row_lsb                      : 3;  /**< "Row address bit select.
                                                          0x0 = Address bit 14 is LSB.
                                                          0x1 = Address bit 15 is LSB.
@@ -4092,16 +4176,10 @@ union cvmx_lmcx_config {
 	uint64_t mode_x4dev                   : 1;  /**< Always reads as 0 for CN70XX devices, there is no x4 device support. */
 	uint64_t mode32b                      : 1;  /**< Always reads as 1 for CN70XX devices, only 32b mode is supported. */
 	uint64_t scrz                         : 1;  /**< Hide LMC(0..0)_SCRAMBLE_CFG0 and LMC(0..0)_SCRAMBLE_CFG1 when set. */
-	uint64_t early_unload_d1_r1           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for
-                                                         Rank 3 reads. The recommended EARLY_UNLOAD_D1_R1 value is 0.  Not used in
-                                                         CN70XX/CN71XX. */
-	uint64_t early_unload_d1_r0           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for
-                                                         Rank 2 reads.  The recommended EARLY_UNLOAD_D1_RO value is 0.  Not used in
-                                                         CN70XX/CN71XX. */
-	uint64_t early_unload_d0_r1           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for
-                                                         Rank 1 reads.  The recommended EARLY_UNLOAD_D0_R1 value is 0. */
-	uint64_t early_unload_d0_r0           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for
-                                                         Rank 0 reads.  The recommended EARLY_UNLOAD_D0_R0 value is 0. */
+	uint64_t early_unload_d1_r1           : 1;  /**< Reserved, MBZ. */
+	uint64_t early_unload_d1_r0           : 1;  /**< Reserved, MBZ. */
+	uint64_t early_unload_d0_r1           : 1;  /**< Reserved, MBZ. */
+	uint64_t early_unload_d0_r0           : 1;  /**< Reserved, MBZ. */
 	uint64_t init_status                  : 4;  /**< Indicates status of initialization. INIT_STATUS[n] = 1 implies rank n has been
                                                          initialized.
                                                          Software must set necessary RANKMASK bits before executing the initialization sequence
@@ -4120,16 +4198,6 @@ union cvmx_lmcx_config {
                                                          DDR#_A<6> is swapped with DDR#_A<5>;
                                                          DDR#_A<4> is swapped with DDR#_A<3>.
                                                          For CN70XX/CN71XX, MIRRMASK<3:2> MBZ.
-                                                         When RANK_ENA = 0, MIRRMASK<1> MBZ."
-                                                         INTERNAL:
-                                                         In DDR4, a mirrored read/write operation has the following differences:
-                                                         DDR#_BG<1> is swapped with DDR#_BG<0>;
-                                                         DDR#_BA<1> is swapped with DDR#_BA<0>;
-                                                         DDR#_A<13> is swapped with DDR#_A<11>;
-                                                         DDR#_A<8> is swapped with DDR#_A<7>;
-                                                         DDR#_A<6> is swapped with DDR#_A<5>;
-                                                         DDR#_A<4> is swapped with DDR#_A<3>.
-                                                         For CN70XX, MIRRMASK<3:2> MBZ.
                                                          When RANK_ENA = 0, MIRRMASK<1> MBZ." */
 	uint64_t rankmask                     : 4;  /**< Mask to select rank to be leveled/initialized. To write-level/read-level/initialize rank
                                                          i, set RANKMASK< i>
@@ -4265,42 +4333,17 @@ union cvmx_lmcx_config {
 	struct cvmx_lmcx_config_cn70xx        cn70xxp1;
 	struct cvmx_lmcx_config_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t lrdimm_ena                   : 1;  /**< Reserved.
-                                                         INTERNAL: Load Reduced DIMM Enable. When set allows the use of JEDEC DDR4 LRDIMMs. */
+	uint64_t lrdimm_ena                   : 1;  /**< Reserved. */
 	uint64_t bg2_enable                   : 1;  /**< BG1 enable bit. Only has an effect when LMC()_CONFIG[MODEDDR4] = 1.
                                                          Set to 1 when using DDR4 x4 or x8 parts.
                                                          Clear to 0 when using DDR4 x16 parts. */
 	uint64_t mode_x4dev                   : 1;  /**< DDR *4 device mode. */
 	uint64_t mode32b                      : 1;  /**< 32-bit datapath mode. When set, only 32 DQ pins are used. */
 	uint64_t scrz                         : 1;  /**< Hide LMC()_SCRAMBLE_CFG0 and LMC()_SCRAMBLE_CFG1 when set. */
-	uint64_t early_unload_d1_r1           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 3 reads.
-                                                         The recommended EARLY_UNLOAD_D1_R1 value can be calculated after the final
-                                                         LMC()_RLEVEL_RANK3[BYTE*] values are selected (as part of read-leveling initialization).
-                                                         Then, determine the largest read-leveling setting for rank 3 (i.e. calculate
-                                                         maxset=MAX(LMC()_RLEVEL_RANK3[BYTEi]) across all i), then set EARLY_UNLOAD_D1_R1 when the
-                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D1_R1 = (maxset<1:0>
-                                                         !=3)). */
-	uint64_t early_unload_d1_r0           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 2 reads.
-                                                         The recommended EARLY_UNLOAD_D1_RO value can be calculated after the final
-                                                         LMC()_RLEVEL_RANK2[BYTE*] values are selected (as part of read-leveling initialization).
-                                                         Then, determine the largest read-leveling setting for rank 2 (i.e. calculate
-                                                         maxset=MAX(LMC()_RLEVEL_RANK2[BYTEi]) across all i), then set EARLY_UNLOAD_D1_RO when the
-                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D1_RO = (maxset<1:0>
-                                                         !=3)). */
-	uint64_t early_unload_d0_r1           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 1 reads.
-                                                         The recommended EARLY_UNLOAD_D0_R1 value can be calculated after the final
-                                                         LMC()_RLEVEL_RANK1[BYTE*] values are selected (as part of read-leveling initialization).
-                                                         Then, determine the largest read-leveling setting for rank 1 (i.e. calculate
-                                                         maxset=MAX(LMC()_RLEVEL_RANK1[BYTEi]) across all i), then set EARLY_UNLOAD_D0_R1 when the
-                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D0_R1 = (maxset<1:0>
-                                                         !=3)). */
-	uint64_t early_unload_d0_r0           : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle early for Rank 0 reads.
-                                                         The recommended EARLY_UNLOAD_D0_R0 value can be calculated after the final
-                                                         LMC()_RLEVEL_RANK0[BYTE*] values are selected (as part of read-leveling initialization).
-                                                         Then, determine the largest read-leveling setting for rank 0 (i.e. calculate
-                                                         maxset=MAX(LMC()_RLEVEL_RANK0[BYTEi]) across all i), then set EARLY_UNLOAD_D0_R0 when the
-                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D0_R0 = (maxset<1:0>
-                                                         !=3)). */
+	uint64_t early_unload_d1_r1           : 1;  /**< Reserved, MBZ. */
+	uint64_t early_unload_d1_r0           : 1;  /**< Reserved, MBZ. */
+	uint64_t early_unload_d0_r1           : 1;  /**< Reserved, MBZ. */
+	uint64_t early_unload_d0_r0           : 1;  /**< Reserved, MBZ. */
 	uint64_t init_status                  : 4;  /**< Indicates status of initialization. INIT_STATUS[n] = 1 implies rank n has been
                                                          initialized.
                                                          Software must set necessary RANKMASK bits before executing the initialization sequence
@@ -4350,7 +4393,7 @@ union cvmx_lmcx_config {
 	uint64_t early_dqx                    : 1;  /**< Set this bit to send DQx signals one CK cycle earlier for the case when the shortest DQx
                                                          lines have a larger delay than the CK line. */
 	uint64_t ref_zqcs_int                 : 22; /**< Refresh interval is represented in number of 512 CK cycle increments. To get more precise
-                                                         control of the refresh interval, the CSR LMC()_EXT_CONFIG[REF_INT_LSBS] can be set to a
+                                                         control of the refresh interval, LMC()_EXT_CONFIG[REF_INT_LSBS] can be set to a
                                                          non-zero value.
                                                          ZQCS interval is represented in a number of refresh intervals. A refresh sequence is
                                                          triggered when bits <24:18> are equal to 0x0, and a ZQCS sequence is triggered when
@@ -4369,8 +4412,7 @@ union cvmx_lmcx_config {
                                                          operations per second.
                                                          LMC()_CONFIG[INIT_STATUS] determines which ranks receive the REF / ZQCS. LMC does not
                                                          send any refreshes / ZQCS's when LMC()_CONFIG[INIT_STATUS]=0. */
-	uint64_t reset                        : 1;  /**< Reset one-shot pulse for LMC()_OPS_CNT, LMC()_IFB_CNT, and LMC()_DCLK_CNT
-                                                         CSRs.
+	uint64_t reset                        : 1;  /**< Reset one-shot pulse for LMC()_OPS_CNT, LMC()_IFB_CNT, and LMC()_DCLK_CNT.
                                                          To cause the reset, software writes this to a 1, then rewrites it to a 0. */
 	uint64_t ecc_adr                      : 1;  /**< Include memory reference address in the ECC calculation.
                                                          0 = disabled, 1 = enabled. */
@@ -4400,9 +4442,7 @@ union cvmx_lmcx_config {
                                                          parts, the column address width = 10, so with 10b of col, 3b of bus, 3b of bank, ROW_LSB =
                                                          16. So, row = mem_adr<29:16>.
                                                          With RANK_ENA = 0, PBANK_LSB = 2.
-                                                         With RANK_ENA = 1, PBANK_LSB = 3.
-                                                         INTERNAL:
-                                                         When interfacing with 8H 3DS, set this 0xA regardless of RANK_ENA value. */
+                                                         With RANK_ENA = 1, PBANK_LSB = 3. */
 	uint64_t row_lsb                      : 3;  /**< "Row address bit select.
                                                          0x0 = Address bit 14 is LSB.
                                                          0x1 = Address bit 15 is LSB.
@@ -4529,8 +4569,7 @@ union cvmx_lmcx_control {
                                                          0x1 = 1 CK cycles.
                                                          0x2 = 2 CK cycles.
                                                          0x3 = Reserved." */
-	uint64_t pocas                        : 1;  /**< Reserved; must be zero. INTERNAL: Enable the posted CAS feature of DDR3. This bit must be
-                                                         set whenever LMC()_MODEREG_PARAMS0[AL]!=0. */
+	uint64_t pocas                        : 1;  /**< Reserved; must be zero. */
 	uint64_t ddr2t                        : 1;  /**< Turn on the DDR 2T mode. 2 CK-cycle window for CMD and address. This mode helps relieve
                                                          setup time pressure on the address and command bus which nominally have a very large
                                                          fanout. Please refer to Micron's tech note tn_47_01 titled DDR2-533 Memory Design Guide
@@ -5720,11 +5759,7 @@ typedef union cvmx_lmcx_ctl1 cvmx_lmcx_ctl1_t;
  * cvmx_lmc#_dbtrain_ctl
  *
  * Reserved.
- * INTERNAL:
- * This register contains control bits that are used during the Data Buffer
- * training sequence in DDR4 LRDIMM mode. When one of the data buffer training
- * sequence is initiated, it uses the contents of this register to control
- * its operation.
+ *
  */
 union cvmx_lmcx_dbtrain_ctl {
 	uint64_t u64;
@@ -5732,25 +5767,11 @@ union cvmx_lmcx_dbtrain_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_63_63               : 1;
 	uint64_t lfsr_pattern_sel             : 1;  /**< If set high, the sequence uses 32-bit LFSR pattern when generating data sequence
-                                                         during the General R/W training (LMC()_DBTRAIN_CTL[RW_TRAIN] == 1).
-                                                         INTERNAL:
-                                                         The LFSR polynomials are programmed by the CSR LMC()_CHAR_CTL[PRBS]. */
+                                                         during the General R/W training (LMC()_DBTRAIN_CTL[RW_TRAIN] == 1). */
 	uint64_t cmd_count_ext                : 2;  /**< Extension bits to the field DBTRAIN_CTL[READ_CMD_COUNT]. This enables
                                                          up to 128 read and write commmands. */
-	uint64_t db_output_impedance          : 3;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Host Interface DQ/DQS Output Driver Impedance control.
-                                                         This is the default value used during Host Interface Write Leveling in LRDIMM
-                                                         environment, i.e., CONFIG[LRDIMM_ENA] = 1, SEQ_CTL[SEQ_SEL] = 0x6.
-                                                         0x0 = RZQ/6 (40 ohm).
-                                                         0x1 = RZQ/7 (34 ohm).
-                                                         0x2 = RZQ/5 (48 ohm).
-                                                         0x3-0x7 = Reserved. */
-	uint64_t db_sel                       : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Used when running Host Interface Write Leveling.
-                                                         0 = selects DIMM0's Data Buffer.
-                                                         1 = selects DIMM1's Data Buffer. */
+	uint64_t db_output_impedance          : 3;  /**< Reserved. */
+	uint64_t db_sel                       : 1;  /**< Reserved. */
 	uint64_t tccd_sel                     : 1;  /**< When set, the sequence uses MODEREG_PARAMS3[TCCD_L] to space out
                                                          back-to-back read commands. Otherwise it will space out back-to-back
                                                          reads with a default value of 4 cycles.
@@ -5766,27 +5787,12 @@ union cvmx_lmcx_dbtrain_ctl {
                                                          the data coming back with this pattern.
                                                          The bit-wise comparison result gets stored in
                                                          LMC()_MPR_DATA0[MPR_DATA]<63:0> and LMC()_MPR_DATA1[MPR_DATA]<7:0>. */
-	uint64_t read_dq_count                : 7;  /**< Reserved.
-                                                         INTERNAL:
-                                                         The amount of cycles until a pulse is issued to sample the DQ into the
-                                                         MPR register. This bits control the timing of when to sample the data
-                                                         buffer training result. */
-	uint64_t read_cmd_count               : 5;  /**< The amount of Read and Write Commands to be sent during the R/W training.
-                                                         INTERNAL:
-                                                         This can be set to zero in which case the sequence does not send any
-                                                         Read commands to accommodate for the DWL training mode. */
-	uint64_t write_ena                    : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Enables the write operation. This is mainly used to accomplish the MWD
-                                                         training sequence of the data buffer.
-                                                         LMC()_DBTRAIN_CTL[ACTIVATE] must be set to 1 for this to take effect. */
-	uint64_t activate                     : 1;  /**< Reserved.
-                                                         INTERNAL: Enables the activate command during the data buffer training sequence. */
+	uint64_t read_dq_count                : 7;  /**< Reserved. */
+	uint64_t read_cmd_count               : 5;  /**< The amount of Read and Write Commands to be sent during the R/W training. */
+	uint64_t write_ena                    : 1;  /**< Reserved. */
+	uint64_t activate                     : 1;  /**< Reserved. */
 	uint64_t prank                        : 2;  /**< Physical Rank bits for Read/Write/Activate operation. */
-	uint64_t lrank                        : 3;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Logical Rank bits for Read/Write/Activate operation during the data buffer
-                                                         training. */
+	uint64_t lrank                        : 3;  /**< Reserved. */
 	uint64_t row_a                        : 18; /**< The row address for the Activate command. */
 	uint64_t bg                           : 2;  /**< The bank group that the R/W commands are directed to. */
 	uint64_t ba                           : 2;  /**< The bank address for the R/W commands are directed to. */
@@ -5814,20 +5820,8 @@ union cvmx_lmcx_dbtrain_ctl {
 	struct cvmx_lmcx_dbtrain_ctl_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
-	uint64_t db_output_impedance          : 3;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Host Interface DQ/DQS Output Driver Impedance control.
-                                                         This is the default value used during Host Interface Write Leveling in LRDIMM
-                                                         environment, i.e., LMC()_CONFIG[LRDIMM_ENA] = 1, LMC()_SEQ_CTL[SEQ_SEL] = 0x6.
-                                                         0x0 = RZQ/6 (40 ohm).
-                                                         0x1 = RZQ/7 (34 ohm).
-                                                         0x2 = RZQ/5 (48 ohm).
-                                                         0x3-0x7 = Reserved. */
-	uint64_t db_sel                       : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Used when running Host Interface Write Leveling.
-                                                         0 = selects DIMM0's Data Buffer.
-                                                         1 = selects DIMM1's Data Buffer. */
+	uint64_t db_output_impedance          : 3;  /**< Reserved. */
+	uint64_t db_sel                       : 1;  /**< Reserved. */
 	uint64_t tccd_sel                     : 1;  /**< When set, the sequence uses MODEREG_PARAMS3[TCCD_L] to space out
                                                          back-to-back read commands. Otherwise it will space out back-to-back
                                                          reads with a default value of 4 cycles.
@@ -5846,22 +5840,11 @@ union cvmx_lmcx_dbtrain_ctl {
 	uint64_t read_dq_count                : 7;  /**< The amount of cycles until a pulse is issued to sample the DQ into the
                                                          MPR register. This bits control the timing of when to sample the data
                                                          buffer training result. */
-	uint64_t read_cmd_count               : 5;  /**< The amount of Read and Write Commands to be sent during the R/W training.
-                                                         INTERNAL:
-                                                         This can be set to zero in which case the sequence does not send any
-                                                         Read commands to accommodate for the DWL training mode. */
-	uint64_t write_ena                    : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Enables the write operation. This is mainly used to accomplish the MWD
-                                                         training sequence of the data buffer.
-                                                         LMC()_DBTRAIN_CTL[ACTIVATE] must be set to 1 for this to take effect. */
-	uint64_t activate                     : 1;  /**< Reserved.
-                                                         INTERNAL: Enables the activate command during the data buffer training sequence. */
+	uint64_t read_cmd_count               : 5;  /**< The amount of Read and Write Commands to be sent during the R/W training. */
+	uint64_t write_ena                    : 1;  /**< Reserved. */
+	uint64_t activate                     : 1;  /**< Reserved. */
 	uint64_t prank                        : 2;  /**< Physical Rank bits for Read/Write/Activate operation. */
-	uint64_t lrank                        : 3;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Logical Rank bits for Read/Write/Activate operation during the data buffer
-                                                         training. */
+	uint64_t lrank                        : 3;  /**< Reserved. */
 	uint64_t row_a                        : 18; /**< The row address for the Activate command. */
 	uint64_t bg                           : 2;  /**< The bank group that the R/W commands are directed to. */
 	uint64_t ba                           : 2;  /**< The bank address that the R/W commands are directed to. */
@@ -5890,20 +5873,8 @@ union cvmx_lmcx_dbtrain_ctl {
 	uint64_t reserved_62_63               : 2;
 	uint64_t cmd_count_ext                : 2;  /**< Extension bits to the field DBTRAIN_CTL[READ_CMD_COUNT]. This enables
                                                          up to 128 read and write commmands. */
-	uint64_t db_output_impedance          : 3;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Host Interface DQ/DQS Output Driver Impedance control.
-                                                         This is the default value used during Host Interface Write Leveling in LRDIMM
-                                                         environment, i.e., CONFIG[LRDIMM_ENA] = 1, SEQ_CTL[SEQ_SEL] = 0x6.
-                                                         0x0 = RZQ/6 (40 ohm).
-                                                         0x1 = RZQ/7 (34 ohm).
-                                                         0x2 = RZQ/5 (48 ohm).
-                                                         0x3-0x7 = Reserved. */
-	uint64_t db_sel                       : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Used when running Host Interface Write Leveling.
-                                                         0 = selects DIMM0's Data Buffer.
-                                                         1 = selects DIMM1's Data Buffer. */
+	uint64_t db_output_impedance          : 3;  /**< Reserved. */
+	uint64_t db_sel                       : 1;  /**< Reserved. */
 	uint64_t tccd_sel                     : 1;  /**< When set, the sequence uses MODEREG_PARAMS3[TCCD_L] to space out
                                                          back-to-back read commands. Otherwise it will space out back-to-back
                                                          reads with a default value of 4 cycles.
@@ -5919,27 +5890,12 @@ union cvmx_lmcx_dbtrain_ctl {
                                                          the data coming back with this pattern.
                                                          The bit-wise comparison result gets stored in
                                                          LMC()_MPR_DATA0[MPR_DATA]<63:0> and LMC()_MPR_DATA1[MPR_DATA]<7:0>. */
-	uint64_t read_dq_count                : 7;  /**< Reserved.
-                                                         INTERNAL:
-                                                         The amount of cycles until a pulse is issued to sample the DQ into the
-                                                         MPR register. This bits control the timing of when to sample the data
-                                                         buffer training result. */
-	uint64_t read_cmd_count               : 5;  /**< The amount of Read and Write Commands to be sent during the R/W training.
-                                                         INTERNAL:
-                                                         This can be set to zero in which case the sequence does not send any
-                                                         Read commands to accommodate for the DWL training mode. */
-	uint64_t write_ena                    : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Enables the write operation. This is mainly used to accomplish the MWD
-                                                         training sequence of the data buffer.
-                                                         LMC()_DBTRAIN_CTL[ACTIVATE] must be set to 1 for this to take effect. */
-	uint64_t activate                     : 1;  /**< Reserved.
-                                                         INTERNAL: Enables the activate command during the data buffer training sequence. */
+	uint64_t read_dq_count                : 7;  /**< Reserved. */
+	uint64_t read_cmd_count               : 5;  /**< The amount of Read and Write Commands to be sent during the R/W training. */
+	uint64_t write_ena                    : 1;  /**< Reserved. */
+	uint64_t activate                     : 1;  /**< Reserved. */
 	uint64_t prank                        : 2;  /**< Physical Rank bits for Read/Write/Activate operation. */
-	uint64_t lrank                        : 3;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Logical Rank bits for Read/Write/Activate operation during the data buffer
-                                                         training. */
+	uint64_t lrank                        : 3;  /**< Reserved. */
 	uint64_t row_a                        : 18; /**< The row address for the Activate command. */
 	uint64_t bg                           : 2;  /**< The bank group that the R/W commands are directed to. */
 	uint64_t ba                           : 2;  /**< The bank address for the R/W commands are directed to. */
@@ -6352,42 +6308,18 @@ typedef union cvmx_lmcx_ddr2_ctl cvmx_lmcx_ddr2_ctl_t;
  * During an RCW initialization sequence, bits 0-21 controls LMC's write
  * operations to the extended DDR4 control words in the JEDEC standard
  * registering clock driver on an RDIMM.
- *
- * INTERNAL:
- * Bits 22-27 is used only when LMC()_CONFIG[LRDIMM_ENA] = 1 AND
- * LMC()_MR_MPR_CTL[MR_WR_PBA_ENABLE] = 1.
- *
- * During PBA mode of an MRW sequence, bits 22-27 controls the Buffer Configuration
- * Control Word F0BC1x settings during the BCW write.
  */
 union cvmx_lmcx_ddr4_dimm_ctl {
 	uint64_t u64;
 	struct cvmx_lmcx_ddr4_dimm_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
-	uint64_t rank_timing_enable           : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Package Rank Timing Alignment Enable bit for the DDR4 LRDIMM Buffer Configuration Control
-                                                         Word F0BC1x DA[7]. Used during PBA BCW Write through the MRW sequence. */
-	uint64_t bodt_trans_mode              : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         BODT input handling in Transparent Mode for the DDR4 LRDIMM Buffer Conifguration Control
-                                                         Word F0BC1x. Used during PBA BCW Write through the MRW sequence. */
-	uint64_t trans_mode_ena               : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Transparent Mode Enable bit for DDR4 LRDIMM Buffer Configuration Control Word
-                                                         F0BC1x DA[5]. Used during PBA BCW Write through the MRW sequence. */
-	uint64_t read_preamble_mode           : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Read Preamble Training Mode Enable bit for DDR4 LRDIMM Buffer Configuration Control Word
-                                                         F0BC1x DA[4]. Used during PBA BCW Write through the MRW sequence. */
-	uint64_t buff_config_da3              : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Reserved setting value in F0BC1x DA3. Used during PBA BCW Write through the MRW sequence. */
-	uint64_t mpr_over_ena                 : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         MPR Override Mode Enable bit for the DDR4 LRDIMM Buffer Configuration Control Word
-                                                         F0BC1x DA[1]. Used during PBA BCW Write through the MRW sequence. */
+	uint64_t rank_timing_enable           : 1;  /**< Reserved. */
+	uint64_t bodt_trans_mode              : 1;  /**< Reserved. */
+	uint64_t trans_mode_ena               : 1;  /**< Reserved. */
+	uint64_t read_preamble_mode           : 1;  /**< Reserved. */
+	uint64_t buff_config_da3              : 1;  /**< Reserved. */
+	uint64_t mpr_over_ena                 : 1;  /**< Reserved. */
 	uint64_t ddr4_dimm1_wmask             : 11; /**< DIMM1 write mask. If (DIMM1_WMASK[n] = 1), write DIMM1.RCn. */
 	uint64_t ddr4_dimm0_wmask             : 11; /**< DIMM0 write mask. If (DIMM0_WMASK[n] = 1), write DIMM0.RCn. */
 #else
@@ -6462,8 +6394,8 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t cps                          : 3;  /**< PLL charge-pump current */
 	uint64_t reserved_8_10                : 3;
 	uint64_t reset_n                      : 1;  /**< PLL reset */
-	uint64_t clkf                         : 7;  /**< Multiply reference by CLKF. 32 <= CLKF <= 64. LMC PLL frequency = 50 * CLKF. min = 1.6
-                                                         GHz, max = 3.2 GHz. */
+	uint64_t clkf                         : 7;  /**< Multiply reference by CLKF. 31 <= CLKF <= 99. LMC PLL frequency = 50 * CLKF. min = 1.6
+                                                         GHz, max = 5 GHz. */
 #else
 	uint64_t clkf                         : 7;
 	uint64_t reset_n                      : 1;
@@ -6555,13 +6487,7 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t pll_lock                     : 1;  /**< PLL LOCK indication. */
 	uint64_t pll_rfslip                   : 1;  /**< PLL RFSLIP indication. */
 	uint64_t clkr                         : 2;  /**< PLL post-divider control. */
-	uint64_t jtg_test_mode                : 1;  /**< Reserved; must be zero. INTERNAL: JTAG test mode. Clock alignment between DCLK & REFCLK as
-                                                         well as FCLK & REFCLK can only be performed after the ddr_pll_divider_reset is deasserted.
-                                                         SW need to wait at least 10 reference clock cycles after deasserting pll_divider_reset
-                                                         before asserting LMC(0..0)_DDR_PLL_CTL[JTG_TEST_MODE]. During alignment (which can take up
-                                                         to 160 microseconds) DCLK and FCLK can exhibit some high-frequency pulses. Therefore, all
-                                                         bring up activities in that clock domain need to be delayed (when the chip operates in
-                                                         jtg_test_mode) by about 160 microseconds to ensure that lock is achieved. */
+	uint64_t jtg_test_mode                : 1;  /**< Reserved; must be zero. */
 	uint64_t ddr_div_reset                : 1;  /**< DDR postscalar divider reset. */
 	uint64_t ddr_ps_en                    : 4;  /**< DDR postscalar divide ratio. Determines the LMC CK speed.
                                                          0x0 = Divide LMC PLL by 1.
@@ -6609,13 +6535,7 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t pll_lock                     : 1;  /**< PLL LOCK indication. */
 	uint64_t pll_rfslip                   : 1;  /**< PLL RFSLIP indication. */
 	uint64_t clkr                         : 2;  /**< PLL post-divider control. */
-	uint64_t jtg_test_mode                : 1;  /**< Reserved; must be zero. INTERNAL: JTAG test mode. Clock alignment between DCLK & REFCLK as
-                                                         well as FCLK & REFCLK can only be performed after the ddr_pll_divider_reset is deasserted.
-                                                         SW need to wait at least 10 reference clock cycles after deasserting pll_divider_reset
-                                                         before asserting LMC()_DDR_PLL_CTL[JTG_TEST_MODE]. During alignment (which can take up
-                                                         to 160 microseconds) DCLK and FCLK can exhibit some high-frequency pulses. Therefore, all
-                                                         bring up activities in that clock domain need to be delayed (when the chip operates in
-                                                         jtg_test_mode) by about 160 microseconds to ensure that lock is achieved. */
+	uint64_t jtg_test_mode                : 1;  /**< Reserved; must be zero. */
 	uint64_t ddr_div_reset                : 1;  /**< DDR postscalar divider reset. */
 	uint64_t ddr_ps_en                    : 4;  /**< DDR postscalar divide ratio. Determines the LMC CK speed.
                                                          0x0 = divide LMC PLL by 1.
@@ -6638,8 +6558,8 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t reserved_9_17                : 9;
 	uint64_t clkf_ext                     : 1;  /**< A 1-bit extension to the CLKF register to support for DDR4-2666. */
 	uint64_t reset_n                      : 1;  /**< PLL reset */
-	uint64_t clkf                         : 7;  /**< Multiply reference by CLKF. 32 <= CLKF <= 64. LMC PLL frequency = 50 * CLKF. min = 1.6
-                                                         GHz, max = 3.2 GHz. */
+	uint64_t clkf                         : 7;  /**< Multiply reference by CLKF. 31 <= CLKF <= 99. LMC PLL frequency = 50 * CLKF. min = 1.6
+                                                         GHz, max = 5 GHz. */
 #else
 	uint64_t clkf                         : 7;
 	uint64_t reset_n                      : 1;
@@ -6894,7 +6814,7 @@ union cvmx_lmcx_dimm_ctl {
                                                          TYP = 0x4E0 (equivalent to 15 us) when changing clock timing (RC2.DBA1, RC6.DA4, RC10.DA3,
                                                          RC10.DA4, RC11.DA3, and RC11.DA4)
                                                          TYP = 0x8, otherwise
-                                                         0x0 = Reserved */
+                                                         0x0 = Reserved. */
 	uint64_t dimm1_wmask                  : 16; /**< DIMM1 write mask. If (DIMM1_WMASK[n] = 1), write DIMM1.RCn. */
 	uint64_t dimm0_wmask                  : 16; /**< DIMM0 write mask. If (DIMM0_WMASK[n] = 1), write DIMM0.RCn. */
 #else
@@ -7050,20 +6970,8 @@ union cvmx_lmcx_dll_ctl2 {
                                                          domain is
                                                          (DRESET -OR- core-clock reset). */
 	uint64_t quad_dll_ena                 : 1;  /**< DLL enable. */
-	uint64_t byp_sel                      : 4;  /**< Reserved; must be zero. INTERNAL: Bypass select.
-                                                         0x0 = no byte.
-                                                         0x1 = byte 0.
-                                                         - ...
-                                                         0x9 = byte 8.
-                                                         0xA = all bytes.
-                                                         0xB-0xF = Reserved. */
-	uint64_t byp_setting                  : 9;  /**< Reserved; must be zero. INTERNAL: Bypass setting.
-                                                         DDR3-1600: 0x22.
-                                                         DDR3-1333: 0x32.
-                                                         DDR3-1066: 0x4B.
-                                                         DDR3-800  : 0x75.
-                                                         DDR3-667  : 0x96.
-                                                         DDR3-600  : 0xAC. */
+	uint64_t byp_sel                      : 4;  /**< Reserved; must be zero. */
+	uint64_t byp_setting                  : 9;  /**< Reserved; must be zero. */
 #else
 	uint64_t byp_setting                  : 9;
 	uint64_t byp_sel                      : 4;
@@ -7101,7 +7009,7 @@ union cvmx_lmcx_dll_ctl3 {
                                                          it is set. */
 	uint64_t bit_select                   : 4;  /**< 0x0-0x7 = Selects bit 0 - bit 8 for write deskew setting assignment.
                                                          0x8 = Selects dbi for write deskew setting assignment.
-                                                         0x9 = No-Op
+                                                         0x9 = No-op.
                                                          0xA = Reuse deskew setting on.
                                                          0xB = Reuse deskew setting off.
                                                          0xC = Vref bypass setting load.
@@ -7251,18 +7159,16 @@ union cvmx_lmcx_dll_ctl3 {
 	struct cvmx_lmcx_dll_ctl3_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_44_63               : 20;
-	uint64_t dclk90_fwd                   : 1;  /**< Reserved; must be zero. INTERNAL: Generate a one cycle pulse to forward setting. This is a
-                                                         oneshot and clears itself each time it is set. */
-	uint64_t ddr_90_dly_byp               : 1;  /**< Reserved; must be zero. INTERNAL: Bypass DDR90_DLY in clock tree. */
+	uint64_t dclk90_fwd                   : 1;  /**< Reserved; must be zero. */
+	uint64_t ddr_90_dly_byp               : 1;  /**< Reserved; must be zero. */
 	uint64_t dclk90_recal_dis             : 1;  /**< Disable periodic recalibration of DDR90 delay line in. */
 	uint64_t dclk90_byp_sel               : 1;  /**< Bypass setting select for DDR90 delay line. */
 	uint64_t dclk90_byp_setting           : 9;  /**< Bypass setting for DDR90 delay line. */
-	uint64_t dll_fast                     : 1;  /**< Reserved; must be zero. INTERNAL: DLL lock, 0=DLL locked. */
-	uint64_t dll90_setting                : 9;  /**< Reserved; must be zero. INTERNAL: Encoded DLL settings. Works in conjunction with
-                                                         DLL90_BYTE_SEL. */
+	uint64_t dll_fast                     : 1;  /**< Reserved; must be zero. */
+	uint64_t dll90_setting                : 9;  /**< Reserved; must be zero. */
 	uint64_t fine_tune_mode               : 1;  /**< DLL fine tune mode. 0 = disabled; 1 = enable. When enabled, calibrate internal PHY DLL
                                                          every LMC(0..0)_CONFIG[REF_ZQCS_INT] CK cycles. */
-	uint64_t dll_mode                     : 1;  /**< Reserved; must be zero. INTERNAL: DLL mode. */
+	uint64_t dll_mode                     : 1;  /**< Reserved; must be zero. */
 	uint64_t dll90_byte_sel               : 4;  /**< Observe DLL settings for selected byte.
                                                          - 0011: byte 4
                                                          - 0100: byte 3
@@ -7270,15 +7176,11 @@ union cvmx_lmcx_dll_ctl3 {
                                                          - 0110: byte 1
                                                          - 0111: byte 0
                                                          0000-0010,1000-1111: Reserved */
-	uint64_t offset_ena                   : 1;  /**< Reserved; must be zero. INTERNAL: Offset enable. 1=enable. */
-	uint64_t load_offset                  : 1;  /**< Reserved; must be zero. INTERNAL: Load offset. 0=disable, 1=generate a one cycle pulse to
-                                                         the PHY. This field is a oneshot and clears itself each time it is set. */
-	uint64_t mode_sel                     : 2;  /**< Reserved; must be zero. INTERNAL: Mode select. 0x0 = reset, 0x1 = write, 0x2 = read, 0x3 =
-                                                         write and read. */
-	uint64_t byte_sel                     : 4;  /**< Reserved; must be zero. INTERNAL: Byte select. 0x0 = no byte, 0x1 = byte 0, ..., 0x9 =
-                                                         byte 8, 0xA = all bytes, 0xB-0xF = Reserved. */
-	uint64_t offset                       : 7;  /**< Reserved; must be zero. INTERNAL: Write/read offset setting. <5:0>: offset (not
-                                                         two's-complement), <5>: 0 = increment, 1 = decrement. */
+	uint64_t offset_ena                   : 1;  /**< Reserved; must be zero. */
+	uint64_t load_offset                  : 1;  /**< Reserved; must be zero. */
+	uint64_t mode_sel                     : 2;  /**< Reserved; must be zero. */
+	uint64_t byte_sel                     : 4;  /**< Reserved; must be zero. */
+	uint64_t offset                       : 7;  /**< Reserved; must be zero. */
 #else
 	uint64_t offset                       : 7;
 	uint64_t byte_sel                     : 4;
@@ -7309,7 +7211,7 @@ union cvmx_lmcx_dll_ctl3 {
                                                          it is set. */
 	uint64_t bit_select                   : 4;  /**< 0x0-0x7 = Selects bit 0 - bit 8 for write deskew setting assignment.
                                                          0x8 = Selects dbi for write deskew setting assignment.
-                                                         0x9 = No-Op
+                                                         0x9 = No-op.
                                                          0xA = Reuse deskew setting on.
                                                          0xB = Reuse deskew setting off.
                                                          0xC = Vref bypass setting load.
@@ -7318,34 +7220,27 @@ union cvmx_lmcx_dll_ctl3 {
                                                          0xF = Bit select reset. Clear write deskew settings to default value 0x40 in each DQ bit.
                                                          Also sets Vref bypass to off and deskew reuse setting to off. */
 	uint64_t dclk90_fwd                   : 1;  /**< When set to one, clock-delay information is forwarded to the neighboring LMC. See LMC CK
-                                                         Locak Initialization step for the LMC bring-up sequence.
-                                                         INTERNAL: Generate a one cycle pulse to forward setting. This is a oneshot and clears
-                                                         itself each time it is set. */
-	uint64_t ddr_90_dly_byp               : 1;  /**< Reserved; must be zero. INTERNAL: Bypass DDR90_DLY in clock tree. */
+                                                         Locak Initialization step for the LMC bring-up sequence. */
+	uint64_t ddr_90_dly_byp               : 1;  /**< Reserved; must be zero. */
 	uint64_t dclk90_recal_dis             : 1;  /**< Disable periodic recalibration of DDR90 delay line in. */
 	uint64_t dclk90_byp_sel               : 1;  /**< Bypass setting select for DDR90 delay line. */
 	uint64_t dclk90_byp_setting           : 9;  /**< Bypass setting for DDR90 delay line. */
-	uint64_t dll_fast                     : 1;  /**< Reserved; must be zero. INTERNAL: DLL lock, 0=DLL locked. */
-	uint64_t dll90_setting                : 9;  /**< Reserved; must be zero. INTERNAL: Encoded DLL settings. Works in conjunction with
-                                                         DLL90_BYTE_SEL. */
+	uint64_t dll_fast                     : 1;  /**< Reserved; must be zero. */
+	uint64_t dll90_setting                : 9;  /**< Reserved; must be zero. */
 	uint64_t fine_tune_mode               : 1;  /**< DLL fine tune mode. 0 = disabled; 1 = enable. When enabled, calibrate internal PHY DLL
                                                          every LMC()_CONFIG[REF_ZQCS_INT] CK cycles. */
-	uint64_t dll_mode                     : 1;  /**< Reserved; must be zero. INTERNAL: DLL mode. */
+	uint64_t dll_mode                     : 1;  /**< Reserved; must be zero. */
 	uint64_t dll90_byte_sel               : 4;  /**< Observe DLL settings for selected byte.
                                                          0x0 = byte 0.
                                                          0x1 = byte 1.
                                                          - ...
                                                          0x8: byte 8.
                                                          0x9-0xF: reserved. */
-	uint64_t offset_ena                   : 1;  /**< Reserved; must be zero. INTERNAL: Offset enable. 1=enable. */
-	uint64_t load_offset                  : 1;  /**< Reserved; must be zero. INTERNAL: Load offset. 0=disable, 1=generate a one cycle pulse to
-                                                         the PHY. This field is a oneshot and clears itself each time it is set. */
-	uint64_t mode_sel                     : 2;  /**< Reserved; must be zero. INTERNAL: Mode select. 0x0 = reset, 0x1 = write, 0x2 = read, 0x3 =
-                                                         write and read. */
-	uint64_t byte_sel                     : 4;  /**< Reserved; must be zero. INTERNAL: Byte select. 0x0 = no byte, 0x1 = byte 0, ..., 0x9 =
-                                                         byte 8, 0xA = all bytes, 0xB-0xF = Reserved. */
-	uint64_t offset                       : 7;  /**< Reserved; must be zero. INTERNAL: Write/read offset setting. <5:0>: offset (not
-                                                         two's-complement), <5>: 0 = increment, 1 = decrement. */
+	uint64_t offset_ena                   : 1;  /**< Reserved; must be zero. */
+	uint64_t load_offset                  : 1;  /**< Reserved; must be zero. */
+	uint64_t mode_sel                     : 2;  /**< Reserved; must be zero. */
+	uint64_t byte_sel                     : 4;  /**< Reserved; must be zero. */
+	uint64_t offset                       : 7;  /**< Reserved; must be zero. */
 #else
 	uint64_t offset                       : 7;
 	uint64_t byte_sel                     : 4;
@@ -7578,14 +7473,7 @@ union cvmx_lmcx_ext_config {
 	struct cvmx_lmcx_ext_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_61_63               : 3;
-	uint64_t bc4_dqs_ena                  : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                           Added in Pass 2.0.
-                                                           CYA bit.
-                                                           When set to 1, LMC produces only 3 cycles of DQS transitions
-                                                           everytime it sends out BC4 Write operation.
-                                                           When set to 0, LMC produces the full bursts of DQS transitions,
-                                                           even for BC4 Write ops. */
+	uint64_t bc4_dqs_ena                  : 1;  /**< Reserved. */
 	uint64_t ref_block                    : 1;  /**< When set, LMC is blocked to initiate any refresh sequence. LMC then will only
                                                          allow refresh sequence to start when LMC()_REF_STATUS[REF_COUNT] has
                                                          reached the maximum value of 0x7. */
@@ -7619,26 +7507,8 @@ union cvmx_lmcx_ext_config {
                                                          to create a uniform memory space that are free from holes in
                                                          between ranks. When different size DIMMs are used, the DIMM with
                                                          the higher capacity is mapped to the lower address space. */
-	uint64_t dimm1_cid                    : 2;  /**< Reserved.
-                                                         INTERNAL:
-                                                         DIMM1 configuration bits that represent the number of Chip
-                                                         ID of the DRAM. This value is use for decoding address
-                                                         as well as routing Chip IDs to the appropriate output
-                                                         pins.
-                                                         0x0 = 0 Chip ID  (Mono-Die stack).
-                                                         0x1 = 1 Chip ID  (2H 3DS).
-                                                         0x2 = 2 Chip IDs (4H 3DS).
-                                                         0x3 = 3 Chip IDs (8H 3DS). */
-	uint64_t dimm0_cid                    : 2;  /**< Reserved.
-                                                         INTERNAL:
-                                                         DIMM0 configuration bits that represent the number of Chip
-                                                         ID of the DRAM. This value is use for decoding address
-                                                         as well as routing Chip IDs to the appropriate output
-                                                         pins.
-                                                         0x0 = 0 Chip ID  (Mono-Die stack).
-                                                         0x1 = 1 Chip ID  (2H 3DS).
-                                                         0x2 = 2 Chip IDs (4H 3DS).
-                                                         0x3 = 3 Chip IDs (8H 3DS). */
+	uint64_t dimm1_cid                    : 2;  /**< Reserved. */
+	uint64_t dimm0_cid                    : 2;  /**< Reserved. */
 	uint64_t rcd_parity_check             : 1;  /**< Enables the one cycle delay of the CA parity output. This MUST be set to 1 when using DDR4
                                                          RDIMM AND parity checking in RCD is enabled (RC0E DA0 = 1). Set this to 0 otherwise.
                                                          To enable the parity checking in RCD, set this bit first BEFORE issuing the RCW write RC0E
@@ -7692,17 +7562,14 @@ union cvmx_lmcx_ext_config {
                                                          write to 1. */
 	uint64_t ref_int_lsbs                 : 9;  /**< Refresh-interval value least-significant bits. The default is 0x0.
                                                          Refresh interval is represented in number of 512 CK cycle increments and is controlled by
-                                                         the CSR LMC()_CONFIG[REF_ZQCS_INT]. More precise refresh interval however (in number of
+                                                         LMC()_CONFIG[REF_ZQCS_INT]. More precise refresh interval however (in number of
                                                          1 CK cycle) can be achieved by setting this field to a non-zero value. */
 	uint64_t drive_ena_bprch              : 1;  /**< Drive DQx for one cycle longer than normal during write operations. */
 	uint64_t drive_ena_fprch              : 1;  /**< Drive DQX starting one cycle earlier than normal during write operations. */
-	uint64_t dlcram_flip_synd             : 2;  /**< Reserved. INTERNAL: DLC RAM flip syndrome control bits. */
-	uint64_t dlcram_cor_dis               : 1;  /**< Reserved. INTERNAL: DLC RAM correction disable control. */
-	uint64_t dlc_nxm_rd                   : 1;  /**< Reserved. INTERNAL:
-                                                         When set, enable NXM events for HFA read operations. INTERNAL: Default is disabled, but
-                                                         could be useful for debug of DLC/DFA accesses. */
-	uint64_t l2c_nxm_rd                   : 1;  /**< When set, enable NXM events for L2C read operations. INTERNAL: Default is disabled as L2C
-                                                         NXM read operations are possible and expected during normal operation. */
+	uint64_t dlcram_flip_synd             : 2;  /**< Reserved. */
+	uint64_t dlcram_cor_dis               : 1;  /**< Reserved. */
+	uint64_t dlc_nxm_rd                   : 1;  /**< Reserved. */
+	uint64_t l2c_nxm_rd                   : 1;  /**< When set, enable NXM events for L2C read operations. */
 	uint64_t l2c_nxm_wr                   : 1;  /**< When set, enable NXM events for L2C write operations. */
 #else
 	uint64_t l2c_nxm_wr                   : 1;
@@ -7764,12 +7631,10 @@ union cvmx_lmcx_ext_config {
                                                          non-zero value to get a more precise refresh interval. */
 	uint64_t drive_ena_bprch              : 1;  /**< Drive DQx for one cycle longer than normal during write operations. */
 	uint64_t drive_ena_fprch              : 1;  /**< Drive DQX starting one cycle earlier than normal during write operations. */
-	uint64_t dlcram_flip_synd             : 2;  /**< Reserved. INTERNAL: DLC RAM flip syndrome control bits. */
-	uint64_t dlcram_cor_dis               : 1;  /**< Reserved. INTERNAL: DLC RAM correction disable control. */
-	uint64_t dlc_nxm_rd                   : 1;  /**< When set, enable NXM events for HFA read operations. INTERNAL: Default is disabled, but
-                                                         could be useful for debug of DLC/DFA accesses. */
-	uint64_t l2c_nxm_rd                   : 1;  /**< When set, enable NXM events for L2C read operations. INTERNAL: Default is disabled as L2C
-                                                         NXM read operations are possible and expected during normal operation. */
+	uint64_t dlcram_flip_synd             : 2;  /**< Reserved. */
+	uint64_t dlcram_cor_dis               : 1;  /**< Reserved. */
+	uint64_t dlc_nxm_rd                   : 1;  /**< When set, enable NXM events for HFA read operations. */
+	uint64_t l2c_nxm_rd                   : 1;  /**< When set, enable NXM events for L2C read operations. */
 	uint64_t l2c_nxm_wr                   : 1;  /**< When set, enable NXM events for L2C write operations. */
 #else
 	uint64_t l2c_nxm_wr                   : 1;
@@ -7824,26 +7689,8 @@ union cvmx_lmcx_ext_config {
                                                          to create a uniform memory space that are free from holes in
                                                          between ranks. When different size DIMMs are used, the DIMM with
                                                          the higher capacity is mapped to the lower address space. */
-	uint64_t dimm1_cid                    : 2;  /**< Reserved.
-                                                         INTERNAL:
-                                                         DIMM1 configuration bits that represent the number of Chip
-                                                         ID of the DRAM. This value is use for decoding address
-                                                         as well as routing Chip IDs to the appropriate output
-                                                         pins.
-                                                         0x0 = 0 Chip ID  (Mono-Die stack).
-                                                         0x1 = 1 Chip ID  (2H 3DS).
-                                                         0x2 = 2 Chip IDs (4H 3DS).
-                                                         0x3 = 3 Chip IDs (8H 3DS). */
-	uint64_t dimm0_cid                    : 2;  /**< Reserved.
-                                                         INTERNAL:
-                                                         DIMM0 configuration bits that represent the number of Chip
-                                                         ID of the DRAM. This value is use for decoding address
-                                                         as well as routing Chip IDs to the appropriate output
-                                                         pins.
-                                                         0x0 = 0 Chip ID  (Mono-Die stack).
-                                                         0x1 = 1 Chip ID  (2H 3DS).
-                                                         0x2 = 2 Chip IDs (4H 3DS).
-                                                         0x3 = 3 Chip IDs (8H 3DS). */
+	uint64_t dimm1_cid                    : 2;  /**< Reserved. */
+	uint64_t dimm0_cid                    : 2;  /**< Reserved. */
 	uint64_t rcd_parity_check             : 1;  /**< Enables the one cycle delay of the CA parity output. This MUST be set to 1 when using DDR4
                                                          RDIMM AND parity checking in RCD is enabled (RC0E DA0 = 1). Set this to 0 otherwise.
                                                          To enable the parity checking in RCD, set this bit first BEFORE issuing the RCW write RC0E
@@ -7897,16 +7744,14 @@ union cvmx_lmcx_ext_config {
                                                          write to 1. */
 	uint64_t ref_int_lsbs                 : 9;  /**< Refresh-interval value least-significant bits. The default is 0x0.
                                                          Refresh interval is represented in number of 512 CK cycle increments and is controlled by
-                                                         the CSR LMC()_CONFIG[REF_ZQCS_INT]. More precise refresh interval however (in number of
+                                                         LMC()_CONFIG[REF_ZQCS_INT]. More precise refresh interval however (in number of
                                                          1 CK cycle) can be achieved by setting this field to a non-zero value. */
 	uint64_t drive_ena_bprch              : 1;  /**< Drive DQx for one cycle longer than normal during write operations. */
 	uint64_t drive_ena_fprch              : 1;  /**< Drive DQX starting one cycle earlier than normal during write operations. */
-	uint64_t dlcram_flip_synd             : 2;  /**< Reserved. INTERNAL: DLC RAM flip syndrome control bits. */
-	uint64_t dlcram_cor_dis               : 1;  /**< Reserved. INTERNAL: DLC RAM correction disable control. */
-	uint64_t dlc_nxm_rd                   : 1;  /**< When set, enable NXM events for HFA read operations. INTERNAL: Default is disabled, but
-                                                         could be useful for debug of DLC/DFA accesses. */
-	uint64_t l2c_nxm_rd                   : 1;  /**< When set, enable NXM events for L2C read operations. INTERNAL: Default is disabled as L2C
-                                                         NXM read operations are possible and expected during normal operation. */
+	uint64_t dlcram_flip_synd             : 2;  /**< Reserved. */
+	uint64_t dlcram_cor_dis               : 1;  /**< Reserved. */
+	uint64_t dlc_nxm_rd                   : 1;  /**< When set, enable NXM events for HFA read operations. */
+	uint64_t l2c_nxm_rd                   : 1;  /**< When set, enable NXM events for L2C read operations. */
 	uint64_t l2c_nxm_wr                   : 1;  /**< When set, enable NXM events for L2C write operations. */
 #else
 	uint64_t l2c_nxm_wr                   : 1;
@@ -7969,14 +7814,10 @@ union cvmx_lmcx_ext_config2 {
 	struct cvmx_lmcx_ext_config2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_21_63               : 43;
-	uint64_t delay_unload_r3              : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle later for Rank 0 reads.
-                                                         Setting this field has priority over LMC()_CONFIG[EARLY_UNLOAD_D1_R1]. */
-	uint64_t delay_unload_r2              : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle later for Rank 0 reads.
-                                                         Setting this field has priority over LMC()_CONFIG[EARLY_UNLOAD_D1_R0]. */
-	uint64_t delay_unload_r1              : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle later for Rank 0 reads.
-                                                         Setting this field has priority over LMC()_CONFIG[EARLY_UNLOAD_D0_R1]. */
-	uint64_t delay_unload_r0              : 1;  /**< Reserved, MBZ.  INTERNAL:  When set, unload the PHY silo one cycle later for Rank 0 reads.
-                                                         Setting this field has priority over LMC()_CONFIG[EARLY_UNLOAD_D0_R0]. */
+	uint64_t delay_unload_r3              : 1;  /**< Reserved, MBZ. */
+	uint64_t delay_unload_r2              : 1;  /**< Reserved, MBZ. */
+	uint64_t delay_unload_r1              : 1;  /**< Reserved, MBZ. */
+	uint64_t delay_unload_r0              : 1;  /**< Reserved, MBZ. */
 	uint64_t early_dqx2                   : 1;  /**< Similar to LMC()_CONFIG[EARLY_DQX]. This field provides an additional setting to send DQx
                                                          signals one more CK cycle earlier on top of LMC()_CONFIG[EARLY_DQX]. */
 	uint64_t xor_bank_sel                 : 4;  /**< When LMC()_CONTROL[XOR_BANK] is set to 1, this field selects which
@@ -8022,8 +7863,8 @@ union cvmx_lmcx_ext_config2 {
 	uint64_t macram_scrub                 : 1;  /**< When set, the Maximum Activate Count memory will be scrubbed to all zero values. This
                                                          should be done before enabling TRR mode by setting LMC()_EXT_CONFIG2[TRR_ON].
                                                          This is a one-shot operation; it automatically returns to 0 after a write to 1. */
-	uint64_t macram_flip_synd             : 2;  /**< Reserved. INTERNAL: MAC RAM flip syndrome control bits. */
-	uint64_t macram_cor_dis               : 1;  /**< Reserved. INTERNAL: MAC RAM correction disable control. */
+	uint64_t macram_flip_synd             : 2;  /**< Reserved. */
+	uint64_t macram_cor_dis               : 1;  /**< Reserved. */
 #else
 	uint64_t macram_cor_dis               : 1;
 	uint64_t macram_flip_synd             : 2;
@@ -8068,8 +7909,8 @@ union cvmx_lmcx_ext_config2 {
 	uint64_t macram_scrub                 : 1;  /**< When set, the Maximum Activate Count memory will be scrubbed to all zero values. This
                                                          should be done before enabling TRR mode by setting LMC()_EXT_CONFIG2[TRR_ON].
                                                          This is a one-shot operation; it automatically returns to 0 after a write to 1. */
-	uint64_t macram_flip_synd             : 2;  /**< Reserved. INTERNAL: MAC RAM flip syndrome control bits. */
-	uint64_t macram_cor_dis               : 1;  /**< Reserved. INTERNAL: MAC RAM correction disable control. */
+	uint64_t macram_flip_synd             : 2;  /**< Reserved. */
+	uint64_t macram_cor_dis               : 1;  /**< Reserved. */
 #else
 	uint64_t macram_cor_dis               : 1;
 	uint64_t macram_flip_synd             : 2;
@@ -8107,13 +7948,7 @@ union cvmx_lmcx_fadr {
 	struct cvmx_lmcx_fadr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_43_63               : 21;
-	uint64_t fcid                         : 3;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Failing CID number. This field is only valid when interfacing with 3DS DRAMs (i.e., when
-                                                         either
-                                                         LMC()_EXT_CONFIG[DIMM0_CID] or LMC()_EXT_CONFIG[DIMM1_CID] is non-zero). Returns a value
-                                                         of zero
-                                                         otherwise. */
+	uint64_t fcid                         : 3;  /**< Reserved. */
 	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
 	uint64_t reserved_0_37                : 38;
 #else
@@ -8205,13 +8040,7 @@ union cvmx_lmcx_fadr {
 	struct cvmx_lmcx_fadr_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_43_63               : 21;
-	uint64_t fcid                         : 3;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Failing CID number. This field is only valid when interfacing with 3DS DRAMs (i.e., when
-                                                         either
-                                                         LMC()_EXT_CONFIG[DIMM0_CID] or LMC()_EXT_CONFIG[DIMM1_CID] is non-zero). Returns a value
-                                                         of zero
-                                                         otherwise. */
+	uint64_t fcid                         : 3;  /**< Reserved. */
 	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
 	uint64_t fdimm                        : 1;  /**< Failing DIMM number. */
 	uint64_t fbunk                        : 1;  /**< Failing rank number. */
@@ -9058,18 +8887,8 @@ union cvmx_lmcx_modereg_params0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_28_63               : 36;
 	uint64_t wrp_ext                      : 1;  /**< A 1 bit extension to the WRP register. */
-	uint64_t cl_ext                       : 1;  /**< Reserved; must be zero.
-                                                         INTERNAL: The extended bit for the proposed CAS Latency spec change. The new
-                                                         CAS Latency in DDR4 DRAM is defined in MR0(A12,A6,A5,A4,A2). This bit sets
-                                                         the A12 bit.
-                                                         See LMC()_MODEREG_PARAMS0[CL]. */
-	uint64_t al_ext                       : 1;  /**< Reserved; must be zero.
-                                                          INTERNAL: The extended bit for the new Additive latency settings for DDR4 3DS.
-                                                          Together with LMC()_MODEREG_PARAMS0[AL], this covers additive latency settings
-                                                          of up to CL-6.
-                                                         - 0: CL - (LMC()_MODEREG_PARAMS0[AL])
-                                                         - 1: CL - (LMC()_MODEREG_PARAMS0[AL] + 4)
-                                                          See LMC()_MODEREG_PARAMS0[AL]. */
+	uint64_t cl_ext                       : 1;  /**< Reserved; must be zero. */
+	uint64_t al_ext                       : 1;  /**< Reserved; must be zero. */
 	uint64_t ppd                          : 1;  /**< DLL control for precharge powerdown.
                                                          0 = Slow exit (DLL off).
                                                          1 = Fast exit (DLL on).
@@ -9173,20 +8992,7 @@ union cvmx_lmcx_modereg_params0 {
                                                          leveling can only be initiated via the write-leveling instruction sequence.) See
                                                          LMC()_SEQ_CTL[SEQ_SEL,INIT_START] and LMC()_CONFIG[RANKMASK,INIT_STATUS] and
                                                          LMC()_RESET_CTL[DDR3PWARM, DDR3PSOFT]. */
-	uint64_t al                           : 2;  /**< Reserved; must be zero.
-                                                         INTERNAL: Additive latency:
-                                                         0x0: 0.
-                                                         0x1: CL-1.
-                                                         0x2: CL - 2.
-                                                         0x3: Reserved.
-                                                         LMC writes this value to MR1[AL] in the selected DDR3 parts during power-up/init, write-
-                                                         leveling, and, if LMC()_CONFIG[SREF_WITH_DLL] is set, self-refresh entry and exit
-                                                         instruction sequences. See LMC()_SEQ_CTL[SEQ_SEL,INIT_START] and
-                                                         LMC()_CONFIG[RANKMASK]
-                                                         and LMC()_RESET_CTL [DDR3PWARM,DDR3PSOFT]. This value must equal the MR1[AL] value in
-                                                         all
-                                                         the DDR3 parts attached to all ranks during normal operation. See also
-                                                         LMC()_CONTROL[POCAS]. */
+	uint64_t al                           : 2;  /**< Reserved; must be zero. */
 	uint64_t dll                          : 1;  /**< DLL Enable. 0: enable; 1: disable. LMC writes this value to MR1[DLL] in the selected DDR3
                                                          parts during power-up/init, write-leveling, and, if LMC()_CONFIG[SREF_WITH_DLL] is
                                                          set, self-refresh entry and exit instruction sequences. See
@@ -9470,15 +9276,7 @@ union cvmx_lmcx_modereg_params1 {
 	uint64_t rtt_wr_10_ext                : 1;  /**< RTT_WR rank 2 extension bit for DDR4. */
 	uint64_t rtt_wr_01_ext                : 1;  /**< RTT_WR rank 1 extension bit for DDR4. */
 	uint64_t rtt_wr_00_ext                : 1;  /**< RTT_WR rank 0 extension bit for DDR4. */
-	uint64_t db_output_impedance          : 3;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Host Interface DQ/DQS Output Driver Impedance control for DIMM0's Data Buffer.
-                                                         This is the default value used during Host Interface Write Leveling in LRDIMM
-                                                         environment, i.e., LMC()_CONFIG[LRDIMM_ENA] = 1, LMC()_SEQ_CTL[SEQ_SEL] = 0x6.
-                                                         0x0 = RZQ/6 (40 ohm).
-                                                         0x1 = RZQ/7 (34 ohm).
-                                                         0x2 = RZQ/5 (48 ohm).
-                                                         0x3-0x7 = Reserved. */
+	uint64_t db_output_impedance          : 3;  /**< Reserved. */
 	uint64_t rtt_nom_11                   : 3;  /**< RTT_NOM rank 3. LMC writes this value to MR1[RTT_NOM] in the rank 3 (i.e. DIMM1_CS1) DDR3
                                                          parts when selected during power-up/init, write-leveling, and, if
                                                          LMC()_CONFIG[SREF_WITH_DLL] is set, self-refresh entry and exit instruction sequences.
@@ -9937,14 +9735,8 @@ union cvmx_lmcx_modereg_params3 {
 	struct cvmx_lmcx_modereg_params3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_39_63               : 25;
-	uint64_t xrank_add_tccd_l             : 3;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Add additional cycles on top of the 4 cycles applied to tCCD_L
-                                                         when crossing logical rank (to the same bank group) of a 3DS DRAM. */
-	uint64_t xrank_add_tccd_s             : 3;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Add additional cycles on top of the 4 cycles applied to tCCD_S
-                                                         when crossing logical rank (to a different bank group) of a 3DS DRAM. */
+	uint64_t xrank_add_tccd_l             : 3;  /**< Reserved. */
+	uint64_t xrank_add_tccd_s             : 3;  /**< Reserved. */
 	uint64_t mpr_fmt                      : 2;  /**< MPR format. */
 	uint64_t wr_cmd_lat                   : 2;  /**< Write command latency when CRC and DM are both enabled. */
 	uint64_t fgrm                         : 3;  /**< Fine granularity refresh mode. */
@@ -10077,7 +9869,7 @@ union cvmx_lmcx_mpr_data0 {
                                                          device 0); bits<15:8> represent *4 device 1; ..., bits<63:56> are for *4 device 7.
                                                          This field is also used to store the results after running the General R/W Training
                                                          sequence (LMC()_SEQ_CTL[SEQ_SEL] = 0xe).
-                                                         The format of the stored results is controlled by the CSR LMC()_DBTRAIN_CTL[RW_TRAIN].
+                                                         The format of the stored results is controlled by LMC()_DBTRAIN_CTL[RW_TRAIN].
                                                          When LMC()_DBTRAIN_CTL[RW_TRAIN] = 1, this field stores the R/W comparison output
                                                          from all DQ63 - DQ0.
                                                          When LMC()_DBTRAIN_CTL[RW_TRAIN] = 0, this field stores the positive edge read data
@@ -10109,7 +9901,7 @@ union cvmx_lmcx_mpr_data1 {
                                                          represent *4 device 9; ...; bits<63:56> are for *4 device 15.
                                                          This field is also used to store the results after running the General R/W Training
                                                          sequence (LMC()_SEQ_CTL[SEQ_SEL] = 0xe).
-                                                         The format of the stored results is controlled by the CSR LMC()_DBTRAIN_CTL[RW_TRAIN].
+                                                         The format of the stored results is controlled by LMC()_DBTRAIN_CTL[RW_TRAIN].
                                                          When LMC()_DBTRAIN_CTL[RW_TRAIN] = 1, this field stores the R/W comparison output
                                                          from the ECC byte (DQ71 - DQ64).
                                                          When LMC()_DBTRAIN_CTL[RW_TRAIN] = 0, MPR_DATA<7:0> stores the positive edge read data
@@ -10143,7 +9935,7 @@ union cvmx_lmcx_mpr_data2 {
                                                          represent *4 device 17.
                                                          This field is also used to store the results after running the General R/W Training
                                                          sequence (LMC()_SEQ_CTL[SEQ_SEL] = 0xe).
-                                                         The format of the stored results is controlled by the CSR LMC()_DBTRAIN_CTL[RW_TRAIN].
+                                                         The format of the stored results is controlled by LMC()_DBTRAIN_CTL[RW_TRAIN].
                                                          When LMC()_DBTRAIN_CTL[RW_TRAIN] = 1, this field is not used.
                                                          When LMC()_DBTRAIN_CTL[RW_TRAIN] = 0, MPR_DATA<15:0> stores the negative edge read data
                                                          on a particular cycle coming from DQ71 - DQ56. */
@@ -10180,20 +9972,15 @@ union cvmx_lmcx_mr_mpr_ctl {
 	uint64_t pba_func_space               : 3;  /**< Set the Function Space Selector during PBA mode of the MRW
                                                          sequence. */
 	uint64_t mr_wr_bg1                    : 1;  /**< BG1 part of the address select for MRS in DDR4 mode. */
-	uint64_t mpr_sample_dq_enable         : 1;  /**< Reserved. INTERNAL: No longer used due to logic change from
-                                                         initial design. */
+	uint64_t mpr_sample_dq_enable         : 1;  /**< Reserved. */
 	uint64_t pda_early_dqx                : 1;  /**< When set, it enables lmc_dqx early for PDA/PBA operation. */
-	uint64_t mr_wr_pba_enable             : 1;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Per Buffer Addressability write enable. When set, MRW operations use PBA, enabled by
-                                                         MR_WR_PDA_MASK per buffer.
-                                                         Only available for DDR4 LRDIMM. */
+	uint64_t mr_wr_pba_enable             : 1;  /**< Reserved. */
 	uint64_t mr_wr_use_default_value      : 1;  /**< When set, write the value to the MR that is computed from the value set in various CSR
                                                          fields that would be used during initialization, rather that using the value in the
                                                          LMC()_MR_MPR_CTL[MR_WR_ADDR]. Useful to rewrite the same value or to change single
                                                          bits without having to compute a whole new value for the MR. */
-	uint64_t mpr_whole_byte_enable        : 1;  /**< Reserved. INTERNAL: Select a whole byte of DRAM data to read when whole-byte mode enabled. */
-	uint64_t mpr_byte_select              : 4;  /**< Reserved. INTERNAL: Select a whole byte of DRAM data to read when whole-byte mode enabled. */
+	uint64_t mpr_whole_byte_enable        : 1;  /**< Reserved. */
+	uint64_t mpr_byte_select              : 4;  /**< Reserved. */
 	uint64_t mpr_bit_select               : 2;  /**< Select which of four bits to read for each nibble of DRAM data. Typically all four bits
                                                          from a *4 device, or all eight bits from a *8 device, or all 16 bits from a *16 device
                                                          carry the same data, but this field allows selection of which device bit will be used to
@@ -10238,8 +10025,8 @@ union cvmx_lmcx_mr_mpr_ctl {
 	struct cvmx_lmcx_mr_mpr_ctl_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_52_63               : 12;
-	uint64_t mpr_whole_byte_enable        : 1;  /**< Reserved. INTERNAL: Select a whole byte of DRAM data to read when whole-byte mode enabled. */
-	uint64_t mpr_byte_select              : 4;  /**< Reserved. INTERNAL: Select a whole byte of DRAM data to read when whole-byte mode enabled. */
+	uint64_t mpr_whole_byte_enable        : 1;  /**< Reserved. */
+	uint64_t mpr_byte_select              : 4;  /**< Reserved. */
 	uint64_t mpr_bit_select               : 2;  /**< Select which of four bits to read for each nibble of DRAM data. Typically all four bits
                                                          from a *4 device, or all eight bits from a *8 device, or all 16 bits from a *16 device
                                                          carry the same data, but this field allows selection of which device bit will be used to
@@ -10356,17 +10143,11 @@ union cvmx_lmcx_nxm {
 	uint64_t mem_msb_d1_r1                : 4;  /**< Maximum row MSB for DIMM1, RANK1/DIMM1 in single ranked.
                                                          If DIMM1 is dual-sided, this should be set to
                                                          NXM[MEM_MSB_D1_R0]. If CONFIG[RANK_ENA] is cleared, this field is ignored. */
-	uint64_t mem_msb_d1_r0                : 4;  /**< Maximum row MSB for DIMM1, RANK0.
-                                                         INTERNAL:
-                                                         if DIMM1 contains 3DS DRAMs, this would point to
-                                                         the logical rank's most significant bit. */
+	uint64_t mem_msb_d1_r0                : 4;  /**< Maximum row MSB for DIMM1, RANK0. */
 	uint64_t mem_msb_d0_r1                : 4;  /**< Maximum row MSB for DIMM0, RANK1/DIMM0 in single ranked.
                                                          If DIMM0 is dual-sided, this should be set to
                                                          NXM[MEM_MSB_D0_R0]. If CONFIG[RANK_ENA] is cleared, this field is ignored. */
-	uint64_t mem_msb_d0_r0                : 4;  /**< Maximum row MSB for DIMM0, RANK0.
-                                                         INTERNAL:
-                                                         If DIMM0 contains 3DS DRAMs, this would point to
-                                                         the logical rank's most significant bit. */
+	uint64_t mem_msb_d0_r0                : 4;  /**< Maximum row MSB for DIMM0, RANK0. */
 	uint64_t cs_mask                      : 8;  /**< Chip select mask. This mask corresponds to the four chip selects for a memory
                                                          configuration. If LMC()_CONFIG[RANK_ENA]=0 then this mask must be set in pairs because
                                                          each reference address will assert a pair of chip selects. If the chip select(s) have a
@@ -10415,8 +10196,8 @@ union cvmx_lmcx_nxm {
 	struct cvmx_lmcx_nxm_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_24_63               : 40;
-	uint64_t mem_msb_d1_r1                : 4;  /**< Reserved.  INTERNAL: Max row MSB for DIMM1, RANK1/DIMM1 in single ranked. */
-	uint64_t mem_msb_d1_r0                : 4;  /**< Reserved.  INTERNAL: Max row MSB for DIMM1, RANK0. */
+	uint64_t mem_msb_d1_r1                : 4;  /**< Reserved. */
+	uint64_t mem_msb_d1_r0                : 4;  /**< Reserved. */
 	uint64_t mem_msb_d0_r1                : 4;  /**< Max row MSB for DIMM0, RANK1/DIMM0 in single ranked. */
 	uint64_t mem_msb_d0_r0                : 4;  /**< Max row MSB for DIMM0, RANK0. */
 	uint64_t reserved_4_7                 : 4;
@@ -10463,9 +10244,9 @@ union cvmx_lmcx_nxm_fadr {
 	uint64_t nxm_faddr_ext                : 1;  /**< Extended bit for the Failing L2C-LMC address (bit 37). */
 	uint64_t nxm_src                      : 1;  /**< Indicates the source of the operation that caused a NXM error:
                                                          0 = L2C.
-                                                         1 = Reserved. INTERNAL: HFA. */
+                                                         1 = Reserved. */
 	uint64_t nxm_type                     : 1;  /**< Indicates the type of operation that caused NXM error:
-                                                         0 = Read, 1 = Write */
+                                                         0 = Read, 1 = Write. */
 	uint64_t nxm_faddr                    : 37; /**< Failing L2C-LMC address. Bits<4:0> are
                                                          always 0s for an L2C access. Bits<5:4> represent the fill order for an L2C read operation,
                                                          and the start point within a cache line for a write operation. */
@@ -10612,29 +10393,11 @@ union cvmx_lmcx_phy_ctl {
 	struct cvmx_lmcx_phy_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_61_63               : 3;
-	uint64_t dsk_dbg_load_dis             : 1;  /**< Reserved. INTERNAL: When set, LMC prevents PHY from loading the deskew shift
-                                                         registers with its internal settings. When Read Deskew sequence is kicked off
-                                                         by setting DSK_DBG_RD_START = 1 and DSK_DBG_WR_MODE = 0, this field determines
-                                                         whether or not to load the shift register with PHY's internal settings before
-                                                         the shifting process. */
-	uint64_t dsk_dbg_overwrt_ena          : 1;  /**< Reserved. INTERNAL:  When set high, PHY selects all of the preloaded data
-                                                         when configuring the read deskew settings. */
-	uint64_t dsk_dbg_wr_mode              : 1;  /**< Reserved. INTERNAL: When set high along with DSK_DBG_RD_START, LMC kicks off Deskew
-                                                         Overwrite sequence to shift out a 10-bits setting for a single DQ.
-                                                         Note that there are a total of 9 bytes and the chain structure are split into two
-                                                         halves such that the top chain covers Byte 7,6,5,4 and bottom chain cover Byte
-                                                         ECC,3,2,1,0.
-                                                         Each byte has 10 DQs (DQ7,DQ6,DQ5,DQ4,DBI,DAC,DQ3,DQ2,DQ1,DQ0) and that each
-                                                         DQ has 10-bits deskew setting. */
-	uint64_t data_rate_loopback           : 1;  /**< Reserved. INTERNAL: DQ data rate loopback, working in conjunction with LOOPBACK assertion.
-                                                         When asserted, incoming PRBS at even DQ can be set at data rate, and the data is loop
-                                                         backed out through odd DQ at the same rate.
-                                                         When de-asserted, LOOPBACK assertion is working along with LOOPBACK_POS to check on even
-                                                         DQ against each DQS edge seperately. This is done at the clock rate. */
-	uint64_t dq_shallow_loopback          : 1;  /**< Reserved. INTERNAL: DQ shallow loopback, working in conjunction with LOOPBACK assertion.
-                                                         When asserted, even DQ inputs can be loop-backed out through its adjacent odd DQ outputs
-                                                         without being flop'd by DQS. Need to make sure LMC()_PHY_CTL[PHY_DSK_BYP] is set and
-                                                         LMC()_PHY_CTL[INT_PHY_LOOPBACK_ENA] is unset. */
+	uint64_t dsk_dbg_load_dis             : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_overwrt_ena          : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_wr_mode              : 1;  /**< Reserved. */
+	uint64_t data_rate_loopback           : 1;  /**< Reserved. */
+	uint64_t dq_shallow_loopback          : 1;  /**< Reserved. */
 	uint64_t dm_disable                   : 1;  /**< Write to 1 to disable the DRAM Data Mask feature by having LMC driving a constant value on
                                                          the
                                                          DDRX_DQS<17:9>_P pins of the chip during write operations. LMC drives a constant 0 in DDR3
@@ -10642,82 +10405,36 @@ union cvmx_lmcx_phy_ctl {
                                                          Note that setting this field high is NOT allowed when LMC has the Write DBI feature turned
                                                          on
                                                          (MODEREG_PARAMS3[WR_DBI]=1). */
-	uint64_t c1_sel                       : 2;  /**< Reserved.
-                                                         INTERNAL:
-                                                         0x0 = C1 is not routed to any output pin.
-                                                         0x1 = C1 is routed to CS3.
-                                                         0x2 = C1 is routed to A17 address pin.
-                                                         0x3 = C1 is not routed to any output pin.
-                                                         Set to 0x0 if not interfacing with 3DS DRAM. */
-	uint64_t c0_sel                       : 2;  /**< Reserved.
-                                                         INTERNAL:
-                                                         0x0 = C0 is not routed to any output pin.
-                                                         0x1 = C0 is routed to CS2.
-                                                         0x2 = C0 is routed to TEN output pin.
-                                                         0x3 = C0 is not routed to any output pin.
-                                                         Set to 0x0 if not interfacing with 3DS DRAM. */
-	uint64_t phy_reset                    : 1;  /**< Reserved. INTERNAL: Write to 1 to reset the PHY, one-shot operation, will automatically
-                                                         clear to value of 0. */
-	uint64_t dsk_dbg_rd_complete          : 1;  /**< Reserved. INTERNAL: Indicates completion of a read operation, will clear to 0 when a read
-                                                         operation is started, then set to 1 when operation is complete. */
-	uint64_t dsk_dbg_rd_data              : 10; /**< Reserved. INTERNAL: Data from a deskew read operation. Only valid when the
-                                                         LMC()_PHY_CTL[DSK_DBG_RD_COMPLETE] bit is set. */
-	uint64_t dsk_dbg_rd_start             : 1;  /**< Reserved. INTERNAL: Write 1 to start deskew data read operation, will automatically clear
-                                                         to 0. Write to 1 will also clear the complete bit. */
-	uint64_t dsk_dbg_clk_scaler           : 2;  /**< Reserved. INTERNAL: Adjust clock toggle rate for reading deskew debug information:
-                                                         0x0 = Deskew read clock toggles every 4 DCLKs.
-                                                         0x1 = Deskew read clock toggles every 8 DCLKs.
-                                                         0x2 = Deskew read clock toggles every 12 DCLKs.
-                                                         0x3 = Deskew read clock toggles every 16 DCLKs. */
-	uint64_t dsk_dbg_offset               : 2;  /**< Reserved. INTERNAL: Offset to change delay of deskew debug data return time to LMC from
-                                                         DDR PHY. */
-	uint64_t dsk_dbg_num_bits_sel         : 1;  /**< Reserved. INTERNAL: Deskew debug, select number of bits per byte lane.
-                                                         0 = 8 bits per byte lane, no DBI, no DAC debug. CN70XX has to be set to this value.
-                                                         1 = 10 bits per byte lane, including DBI and DAC. CNXXXX has to be set to this value. */
-	uint64_t dsk_dbg_byte_sel             : 4;  /**< Reserved. INTERNAL: Deskew debug byte select for read operation. Values 0-3 correspond to
-                                                         byte lanes 0-3, 4 is for ECC, 5-8 are byte lanes 4-7. */
-	uint64_t dsk_dbg_bit_sel              : 4;  /**< Reserved. INTERNAL: Deskew debug bit select for dsk read operation.
-                                                         0x0 = DQ0.
-                                                         0x1 = DQ1.
-                                                         0x2 = DQ2.
-                                                         0x3 = DQ3.
-                                                         0x4 = DAC.
-                                                         0x5 = DBI.
-                                                         0x6 = DQ4.
-                                                         0x7 = DQ5.
-                                                         0x8 = DQ6.
-                                                         0x9 = DQ7. */
+	uint64_t c1_sel                       : 2;  /**< Reserved. */
+	uint64_t c0_sel                       : 2;  /**< Reserved. */
+	uint64_t phy_reset                    : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_rd_complete          : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_rd_data              : 10; /**< Reserved. */
+	uint64_t dsk_dbg_rd_start             : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_clk_scaler           : 2;  /**< Reserved. */
+	uint64_t dsk_dbg_offset               : 2;  /**< Reserved. */
+	uint64_t dsk_dbg_num_bits_sel         : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_byte_sel             : 4;  /**< Reserved. */
+	uint64_t dsk_dbg_bit_sel              : 4;  /**< Reserved. */
 	uint64_t dbi_mode_ena                 : 1;  /**< Enable DBI mode for PHY. */
 	uint64_t ddr_error_n_ena              : 1;  /**< Enable error_alert_n signal for PHY. */
-	uint64_t ref_pin_on                   : 1;  /**< Reserved. INTERNAL: Voltage reference pin enabled. */
-	uint64_t dac_on                       : 1;  /**< Reserved. INTERNAL: PHY DAC on. */
-	uint64_t int_pad_loopback_ena         : 1;  /**< Reserved. INTERNAL: DDR pad loopback enable.  Also must set LMC()_PHY_CTL[PHY_DSK_BYP]
-                                                         when loopback is enabled. */
-	uint64_t int_phy_loopback_ena         : 1;  /**< Reserved. INTERNAL: PHY loopback enable. */
+	uint64_t ref_pin_on                   : 1;  /**< Reserved. */
+	uint64_t dac_on                       : 1;  /**< Reserved. */
+	uint64_t int_pad_loopback_ena         : 1;  /**< Reserved. */
+	uint64_t int_phy_loopback_ena         : 1;  /**< Reserved. */
 	uint64_t phy_dsk_reset                : 1;  /**< PHY deskew reset. When set, the deskew reset signal goes active if the Vrefint/deskew
                                                          training sequence is in the idle state. */
 	uint64_t phy_dsk_byp                  : 1;  /**< PHY deskew bypass. */
 	uint64_t phy_pwr_save_disable         : 1;  /**< DDR PHY power save disable. */
 	uint64_t ten                          : 1;  /**< DDR PHY test enable pin. */
-	uint64_t rx_always_on                 : 1;  /**< Reserved; must be zero. INTERNAL: Set to force read_enable to PHY active all the time.
-                                                         This bit MUST not be set when LMC initialization is in progress. Internal VREF and
-                                                         Deskew training requires normal operation on the dqx/s read_enable signals. */
-	uint64_t lv_mode                      : 1;  /**< Reserved; must be zero. INTERNAL: Low Voltage Mode (1.35V.) */
-	uint64_t ck_tune1                     : 1;  /**< Reserved; must be zero. INTERNAL: Clock tune. */
-	uint64_t ck_dlyout1                   : 4;  /**< Reserved; must be zero. INTERNAL: Clock delay out. */
-	uint64_t ck_tune0                     : 1;  /**< Reserved; must be zero. INTERNAL: Clock tune. */
-	uint64_t ck_dlyout0                   : 4;  /**< Reserved; must be zero. INTERNAL: Clock delay out. */
-	uint64_t loopback                     : 1;  /**< Reserved; must be zero.
-                                                         INTERNAL: external loopback enable. when asserted, Rx is on at DQS0 and data at even DQ
-                                                         bits
-                                                         are loop-backed out through odd DQ bits. For DQS, when LMC_PHY_CTL[PHY_DSK_BYP] and
-                                                         LMC_MEM_CFG0[MODE_X4DEV] are asserted along with LOOPBACK, DQS0 input of a given byte
-                                                         can be loop-backed out through DQS1 of the same byte. For DQ, when
-                                                         LMC()_PHY_CTL[DQ_SHALLOW_LOOPBACK] is asserted, DQ bits are loop-backed out without being
-                                                         flop'd by incoming DQS. When LMC()_PHY_CTL[DQ_SHALLOW_LOOPBACK] is deasserted, DQ bits are
-                                                         loop-backed out after being flop'd by incoming DQS. */
-	uint64_t loopback_pos                 : 1;  /**< Reserved; must be zero. INTERNAL: Loopback pos mode. This works in conjunction with
-                                                         LMC()_PHY_CTL[LOOPBACK] mentioned above. */
+	uint64_t rx_always_on                 : 1;  /**< Reserved; must be zero. */
+	uint64_t lv_mode                      : 1;  /**< Reserved; must be zero. */
+	uint64_t ck_tune1                     : 1;  /**< Reserved; must be zero. */
+	uint64_t ck_dlyout1                   : 4;  /**< Reserved; must be zero. */
+	uint64_t ck_tune0                     : 1;  /**< Reserved; must be zero. */
+	uint64_t ck_dlyout0                   : 4;  /**< Reserved; must be zero. */
+	uint64_t loopback                     : 1;  /**< Reserved; must be zero. */
+	uint64_t loopback_pos                 : 1;  /**< Reserved; must be zero. */
 	uint64_t ts_stagger                   : 1;  /**< TS stagger mode. This mode configures output drivers with two-stage drive strength to
                                                          avoid undershoot issues on the bus when strong drivers are suddenly turned on. When this
                                                          mode is asserted, CNXXXX will configure output drivers to be weak drivers (60ohm output
@@ -10834,48 +10551,35 @@ union cvmx_lmcx_phy_ctl {
 	struct cvmx_lmcx_phy_ctl_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_51_63               : 13;
-	uint64_t phy_reset                    : 1;  /**< Reserved. INTERNAL: Write to 1 to reset the PHY, one-shot operation, will automatically
-                                                         clear to value of 0. */
-	uint64_t dsk_dbg_rd_complete          : 1;  /**< Reserved. INTERNAL: Indicates completion of a read operation, will clear to 0 when a read
-                                                         operation is started, then set to 1 when operation is complete. */
-	uint64_t dsk_dbg_rd_data              : 10; /**< Reserved. INTERNAL: Data from a deskew read operation. Only valid when the
-                                                         LMCX_PHY_CTL[DSK_DBG_RD_COMPLETE] bit is set. */
-	uint64_t dsk_dbg_rd_start             : 1;  /**< Reserved. INTERNAL: Write 1 to start deskew data read operation, will automatically clear
-                                                         to 0. Write to 1 will also clear the complete bit. */
-	uint64_t dsk_dbg_clk_scaler           : 2;  /**< Reserved. INTERNAL: Adjust clock toggle rate for reading deskew debug information:
-                                                         0 = Deskew read clock toggles every 1 DCLK
-                                                         1 = Deskew read clock toggles every 2 DCLKs
-                                                         2 = Deskew read clock toggles every 3 DCLKs
-                                                         3 = Deskew read clock toggles every 4 DCLKs */
-	uint64_t dsk_dbg_offset               : 2;  /**< Reserved. INTERNAL: Offset to change delay of deskew debug data return time to LMC from
-                                                         DDR PHY. */
-	uint64_t dsk_dbg_num_bits_sel         : 1;  /**< Reserved. INTERNAL: Deskew debug, select number of bits per byte lane.
-                                                         0 = 8 bits per byte lane, no DBI
-                                                         1 = 9 bits per byte lane, including DBI */
-	uint64_t dsk_dbg_byte_sel             : 4;  /**< Reserved. INTERNAL: Deskew debug byte select for read operation. Values 0-3 correspond to
-                                                         byte lanes 0-3, 4 is for ECC, 5-8 are byte lanes 4-7. */
-	uint64_t dsk_dbg_bit_sel              : 4;  /**< Reserved. INTERNAL: Deskew debug bit select for dsk read operation. */
+	uint64_t phy_reset                    : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_rd_complete          : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_rd_data              : 10; /**< Reserved. */
+	uint64_t dsk_dbg_rd_start             : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_clk_scaler           : 2;  /**< Reserved. */
+	uint64_t dsk_dbg_offset               : 2;  /**< Reserved. */
+	uint64_t dsk_dbg_num_bits_sel         : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_byte_sel             : 4;  /**< Reserved. */
+	uint64_t dsk_dbg_bit_sel              : 4;  /**< Reserved. */
 	uint64_t dbi_mode_ena                 : 1;  /**< Enable DBI mode for PHY, must be 0.  DBI mode not supported
                                                          in CN70XX. */
 	uint64_t ddr_error_n_ena              : 1;  /**< Reserved. */
-	uint64_t ref_pin_on                   : 1;  /**< Reserved. INTERNAL: Voltage reference pin enabled. */
-	uint64_t dac_on                       : 1;  /**< Reserved. INTERNAL: PHY DAC on. */
-	uint64_t int_pad_loopback_ena         : 1;  /**< Reserved. INTERNAL: DDR pad loopback enable.  Also must set LMCX_PHY_CTL[PHY_DSK_BYP]
-                                                         when loopback is enabled. */
-	uint64_t int_phy_loopback_ena         : 1;  /**< Reserved. INTERNAL: PHY loopback enable. */
+	uint64_t ref_pin_on                   : 1;  /**< Reserved. */
+	uint64_t dac_on                       : 1;  /**< Reserved. */
+	uint64_t int_pad_loopback_ena         : 1;  /**< Reserved. */
+	uint64_t int_phy_loopback_ena         : 1;  /**< Reserved. */
 	uint64_t phy_dsk_reset                : 1;  /**< PHY deskew reset. When set, the deskew reset signal goes active if the Vrefint/deskew
                                                          training sequence is in the idle state. */
 	uint64_t phy_dsk_byp                  : 1;  /**< PHY deskew bypass. */
 	uint64_t phy_pwr_save_disable         : 1;  /**< DDR PHY power save disable. */
 	uint64_t ten                          : 1;  /**< DDR PHY test enable pin. */
-	uint64_t rx_always_on                 : 1;  /**< Reserved; must be zero. INTERNAL: Set to force read_enable to PHY active all the time. */
-	uint64_t lv_mode                      : 1;  /**< Reserved; must be zero. INTERNAL: Low Voltage Mode (1.35V.) */
-	uint64_t ck_tune1                     : 1;  /**< Reserved; must be zero. INTERNAL: Clock tune. */
-	uint64_t ck_dlyout1                   : 4;  /**< Reserved; must be zero. INTERNAL: Clock delay out. */
-	uint64_t ck_tune0                     : 1;  /**< Reserved; must be zero. INTERNAL: Clock tune. */
-	uint64_t ck_dlyout0                   : 4;  /**< Reserved; must be zero. INTERNAL: Clock delay out. */
-	uint64_t loopback                     : 1;  /**< Reserved; must be zero. INTERNAL: Loopback enable. */
-	uint64_t loopback_pos                 : 1;  /**< Reserved; must be zero. INTERNAL: Loopback pos mode. */
+	uint64_t rx_always_on                 : 1;  /**< Reserved; must be zero. */
+	uint64_t lv_mode                      : 1;  /**< Reserved; must be zero. */
+	uint64_t ck_tune1                     : 1;  /**< Reserved; must be zero. */
+	uint64_t ck_dlyout1                   : 4;  /**< Reserved; must be zero. */
+	uint64_t ck_tune0                     : 1;  /**< Reserved; must be zero. */
+	uint64_t ck_dlyout0                   : 4;  /**< Reserved; must be zero. */
+	uint64_t loopback                     : 1;  /**< Reserved; must be zero. */
+	uint64_t loopback_pos                 : 1;  /**< Reserved; must be zero. */
 	uint64_t ts_stagger                   : 1;  /**< TS stagger mode. This mode configures output drivers with two-stage drive strength to
                                                          avoid undershoot issues on the bus when strong drivers are suddenly turned on. When this
                                                          mode is asserted, CN78XX will configure output drivers to be weak drivers (60ohm output
@@ -10917,15 +10621,8 @@ union cvmx_lmcx_phy_ctl {
 	struct cvmx_lmcx_phy_ctl_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_58_63               : 6;
-	uint64_t data_rate_loopback           : 1;  /**< Reserved. INTERNAL: DQ data rate loopback, working in conjunction with LOOPBACK assertion.
-                                                         When asserted, incoming PRBS at even DQ can be set at data rate, and the data is loop
-                                                         backed out through odd DQ at the same rate.
-                                                         When de-asserted, LOOPBACK assertion is working along with LOOPBACK_POS to check on even
-                                                         DQ against each DQS edge seperately. This is done at the clock rate. */
-	uint64_t dq_shallow_loopback          : 1;  /**< Reserved. INTERNAL: DQ shallow loopback, working in conjunction with LOOPBACK assertion.
-                                                         When asserted, even DQ inputs can be loop-backed out through its adjacent odd DQ outputs
-                                                         without being flop'd by DQS. Need to make sure LMC()_PHY_CTL[PHY_DSK_BYP] is set and
-                                                         LMC()_PHY_CTL[INT_PHY_LOOPBACK_ENA] is unset. */
+	uint64_t data_rate_loopback           : 1;  /**< Reserved. */
+	uint64_t dq_shallow_loopback          : 1;  /**< Reserved. */
 	uint64_t dm_disable                   : 1;  /**< Write to 1 to disable the DRAM Data Mask feature by having LMC driving a constant value on
                                                          the
                                                          DDRX_DQS<17:9>_P pins of the chip during write operations. LMC drives a constant 0 in DDR3
@@ -10933,82 +10630,36 @@ union cvmx_lmcx_phy_ctl {
                                                          Note that setting this field high is NOT allowed when LMC has the Write DBI feature turned
                                                          on
                                                          (MODEREG_PARAMS3[WR_DBI]=1). */
-	uint64_t c1_sel                       : 2;  /**< Reserved.
-                                                         INTERNAL:
-                                                         0x0 = C1 is not routed to any output pin.
-                                                         0x1 = C1 is routed to CS3.
-                                                         0x2 = C1 is routed to A17 address pin.
-                                                         0x3 = C1 is not routed to any output pin.
-                                                         Set to 0x0 if not interfacing with 3DS DRAM. */
-	uint64_t c0_sel                       : 2;  /**< Reserved.
-                                                         INTERNAL:
-                                                         0x0 = C0 is not routed to any output pin.
-                                                         0x1 = C0 is routed to CS2.
-                                                         0x2 = C0 is routed to TEN output pin.
-                                                         0x3 = C0 is not routed to any output pin.
-                                                         Set to 0x0 if not interfacing with 3DS DRAM. */
-	uint64_t phy_reset                    : 1;  /**< Reserved. INTERNAL: Write to 1 to reset the PHY, one-shot operation, will automatically
-                                                         clear to value of 0. */
-	uint64_t dsk_dbg_rd_complete          : 1;  /**< Reserved. INTERNAL: Indicates completion of a read operation, will clear to 0 when a read
-                                                         operation is started, then set to 1 when operation is complete. */
-	uint64_t dsk_dbg_rd_data              : 10; /**< Reserved. INTERNAL: Data from a deskew read operation. Only valid when the
-                                                         LMC()_PHY_CTL[DSK_DBG_RD_COMPLETE] bit is set. */
-	uint64_t dsk_dbg_rd_start             : 1;  /**< Reserved. INTERNAL: Write 1 to start deskew data read operation, will automatically clear
-                                                         to 0. Write to 1 will also clear the complete bit. */
-	uint64_t dsk_dbg_clk_scaler           : 2;  /**< Reserved. INTERNAL: Adjust clock toggle rate for reading deskew debug information:
-                                                         0x0 = Deskew read clock toggles every 4 DCLKs.
-                                                         0x1 = Deskew read clock toggles every 8 DCLKs.
-                                                         0x2 = Deskew read clock toggles every 12 DCLKs.
-                                                         0x3 = Deskew read clock toggles every 16 DCLKs. */
-	uint64_t dsk_dbg_offset               : 2;  /**< Reserved. INTERNAL: Offset to change delay of deskew debug data return time to LMC from
-                                                         DDR PHY. */
-	uint64_t dsk_dbg_num_bits_sel         : 1;  /**< Reserved. INTERNAL: Deskew debug, select number of bits per byte lane.
-                                                         0 = 8 bits per byte lane, no DBI, no DAC debug. CN70XX has to be set to this value.
-                                                         1 = 10 bits per byte lane, including DBI and DAC. CNXXXX has to be set to this value. */
-	uint64_t dsk_dbg_byte_sel             : 4;  /**< Reserved. INTERNAL: Deskew debug byte select for read operation. Values 0-3 correspond to
-                                                         byte lanes 0-3, 4 is for ECC, 5-8 are byte lanes 4-7. */
-	uint64_t dsk_dbg_bit_sel              : 4;  /**< Reserved. INTERNAL: Deskew debug bit select for dsk read operation.
-                                                         0x0 = DQ0.
-                                                         0x1 = DQ1.
-                                                         0x2 = DQ2.
-                                                         0x3 = DQ3.
-                                                         0x4 = DAC.
-                                                         0x5 = DBI.
-                                                         0x6 = DQ4.
-                                                         0x7 = DQ5.
-                                                         0x8 = DQ6.
-                                                         0x9 = DQ7. */
+	uint64_t c1_sel                       : 2;  /**< Reserved. */
+	uint64_t c0_sel                       : 2;  /**< Reserved. */
+	uint64_t phy_reset                    : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_rd_complete          : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_rd_data              : 10; /**< Reserved. */
+	uint64_t dsk_dbg_rd_start             : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_clk_scaler           : 2;  /**< Reserved. */
+	uint64_t dsk_dbg_offset               : 2;  /**< Reserved. */
+	uint64_t dsk_dbg_num_bits_sel         : 1;  /**< Reserved. */
+	uint64_t dsk_dbg_byte_sel             : 4;  /**< Reserved. */
+	uint64_t dsk_dbg_bit_sel              : 4;  /**< Reserved. */
 	uint64_t dbi_mode_ena                 : 1;  /**< Enable DBI mode for PHY. */
 	uint64_t ddr_error_n_ena              : 1;  /**< Enable error_alert_n signal for PHY. */
-	uint64_t ref_pin_on                   : 1;  /**< Reserved. INTERNAL: Voltage reference pin enabled. */
-	uint64_t dac_on                       : 1;  /**< Reserved. INTERNAL: PHY DAC on. */
-	uint64_t int_pad_loopback_ena         : 1;  /**< Reserved. INTERNAL: DDR pad loopback enable.  Also must set LMC()_PHY_CTL[PHY_DSK_BYP]
-                                                         when loopback is enabled. */
-	uint64_t int_phy_loopback_ena         : 1;  /**< Reserved. INTERNAL: PHY loopback enable. */
+	uint64_t ref_pin_on                   : 1;  /**< Reserved. */
+	uint64_t dac_on                       : 1;  /**< Reserved. */
+	uint64_t int_pad_loopback_ena         : 1;  /**< Reserved. */
+	uint64_t int_phy_loopback_ena         : 1;  /**< Reserved. */
 	uint64_t phy_dsk_reset                : 1;  /**< PHY deskew reset. When set, the deskew reset signal goes active if the Vrefint/deskew
                                                          training sequence is in the idle state. */
 	uint64_t phy_dsk_byp                  : 1;  /**< PHY deskew bypass. */
 	uint64_t phy_pwr_save_disable         : 1;  /**< DDR PHY power save disable. */
 	uint64_t ten                          : 1;  /**< DDR PHY test enable pin. */
-	uint64_t rx_always_on                 : 1;  /**< Reserved; must be zero. INTERNAL: Set to force read_enable to PHY active all the time.
-                                                         This bit MUST not be set when LMC initialization is in progress. Internal VREF and
-                                                         Deskew training requires normal operation on the dqx/s read_enable signals. */
-	uint64_t lv_mode                      : 1;  /**< Reserved; must be zero. INTERNAL: Low Voltage Mode (1.35V.) */
-	uint64_t ck_tune1                     : 1;  /**< Reserved; must be zero. INTERNAL: Clock tune. */
-	uint64_t ck_dlyout1                   : 4;  /**< Reserved; must be zero. INTERNAL: Clock delay out. */
-	uint64_t ck_tune0                     : 1;  /**< Reserved; must be zero. INTERNAL: Clock tune. */
-	uint64_t ck_dlyout0                   : 4;  /**< Reserved; must be zero. INTERNAL: Clock delay out. */
-	uint64_t loopback                     : 1;  /**< Reserved; must be zero.
-                                                         INTERNAL: external loopback enable. when asserted, Rx is on at DQS0 and data at even DQ
-                                                         bits
-                                                         are loop-backed out through odd DQ bits. For DQS, when LMC_PHY_CTL[PHY_DSK_BYP] and
-                                                         LMC_MEM_CFG0[MODE_X4DEV] are asserted along with LOOPBACK, DQS0 input of a given byte
-                                                         can be loop-backed out through DQS1 of the same byte. For DQ, when
-                                                         LMC()_PHY_CTL[DQ_SHALLOW_LOOPBACK] is asserted, DQ bits are loop-backed out without being
-                                                         flop'd by incoming DQS. When LMC()_PHY_CTL[DQ_SHALLOW_LOOPBACK] is deasserted, DQ bits are
-                                                         loop-backed out after being flop'd by incoming DQS. */
-	uint64_t loopback_pos                 : 1;  /**< Reserved; must be zero. INTERNAL: Loopback pos mode. This works in conjunction with
-                                                         LMC()_PHY_CTL[LOOPBACK] mentioned above. */
+	uint64_t rx_always_on                 : 1;  /**< Reserved; must be zero. */
+	uint64_t lv_mode                      : 1;  /**< Reserved; must be zero. */
+	uint64_t ck_tune1                     : 1;  /**< Reserved; must be zero. */
+	uint64_t ck_dlyout1                   : 4;  /**< Reserved; must be zero. */
+	uint64_t ck_tune0                     : 1;  /**< Reserved; must be zero. */
+	uint64_t ck_dlyout0                   : 4;  /**< Reserved; must be zero. */
+	uint64_t loopback                     : 1;  /**< Reserved; must be zero. */
+	uint64_t loopback_pos                 : 1;  /**< Reserved; must be zero. */
 	uint64_t ts_stagger                   : 1;  /**< TS stagger mode. This mode configures output drivers with two-stage drive strength to
                                                          avoid undershoot issues on the bus when strong drivers are suddenly turned on. When this
                                                          mode is asserted, CNXXXX will configure output drivers to be weak drivers (60ohm output
@@ -11340,8 +10991,8 @@ union cvmx_lmcx_ppr_ctl {
 	struct cvmx_lmcx_ppr_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_27_63               : 37;
-	uint64_t lrank_sel                    : 3;  /**< Selects which logical rank to perform the Post Package Repair sequence.
-                                                         Package Ranks are selected by the CSR LMC()_MR_MPR_CTL[MR_WR_RANK]. */
+	uint64_t lrank_sel                    : 3;  /**< Selects which logical rank to perform the post package repair sequence.
+                                                         Package ranks are selected by LMC()_MR_MPR_CTL[MR_WR_RANK]. */
 	uint64_t skip_issue_security          : 1;  /**< Personality bit for the PPR sequence. When set, this field forces the sequence to skip
                                                          issuing four consecutive MR0 commands that suppliy the Security Key. */
 	uint64_t sppr                         : 1;  /**< Personality bit for the PPR sequence. When set, this field forces the sequence to run
@@ -11754,18 +11405,10 @@ union cvmx_lmcx_rlevel_ctl {
                                                          reads commands are spaced out by a default 4 cycles. */
 	uint64_t pattern                      : 8;  /**< Sets the data pattern used to match in read-leveling operations. */
 	uint64_t reserved_22_23               : 2;
-	uint64_t delay_unload_3               : 1;  /**< Reserved, must be set.  INTERNAL: When set, unload the PHY silo one cycle later during
-                                                         read-leveling if LMC()_RLEVEL_RANK()[BYTE*<1:0>] = 3. DELAY_UNLOAD_3 should
-                                                         normally be set, particularly at higher speeds. */
-	uint64_t delay_unload_2               : 1;  /**< Reserved, must be set.  INTERNAL: When set, unload the PHY silo one cycle later during
-                                                         read-leveling if LMC()_RLEVEL_RANK()[BYTE*<1:0>] = 2. DELAY_UNLOAD_2 should
-                                                         normally be set. */
-	uint64_t delay_unload_1               : 1;  /**< Reserved, must be set.  INTERNAL: When set, unload the PHY silo one cycle later during
-                                                         read-leveling if LMC()_RLEVEL_RANK()[BYTE*<1:0>] = 1. DELAY_UNLOAD_1 should
-                                                         normally be set. */
-	uint64_t delay_unload_0               : 1;  /**< Reserved, must be set.  INTERNAL: When set, unload the PHY silo one cycle later during
-                                                         read-leveling if LMC()_RLEVEL_RANK()[BYTE*<1:0>] = 0. DELAY_UNLOAD_0 should
-                                                         normally be set. */
+	uint64_t delay_unload_3               : 1;  /**< Reserved, must be set. */
+	uint64_t delay_unload_2               : 1;  /**< Reserved, must be set. */
+	uint64_t delay_unload_1               : 1;  /**< Reserved, must be set. */
+	uint64_t delay_unload_0               : 1;  /**< Reserved, must be set. */
 	uint64_t bitmask                      : 8;  /**< Mask to select bit lanes on which read-leveling feedback is returned when OR_DIS is set to 1. */
 	uint64_t or_dis                       : 1;  /**< Disable ORing of bits in a byte lane when computing the read-leveling bitmask. OR_DIS
                                                          should normally not be set. */
@@ -12310,13 +11953,7 @@ union cvmx_lmcx_scrambled_fadr {
 	struct cvmx_lmcx_scrambled_fadr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_43_63               : 21;
-	uint64_t fcid                         : 3;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Failing CID number. This field is only valid when interfacing with 3DS DRAMs (i.e., when
-                                                         either
-                                                         LMC()_EXT_CONFIG[DIMM0_CID] or LMC()_EXT_CONFIG[DIMM1_CID] is non-zero). Returns a value
-                                                         of zero
-                                                         otherwise. */
+	uint64_t fcid                         : 3;  /**< Reserved. */
 	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
 	uint64_t reserved_14_37               : 24;
 	uint64_t fcol                         : 14; /**< Failing column address <13:0>. Technically, represents the address of the 128b data that
@@ -12377,13 +12014,7 @@ union cvmx_lmcx_scrambled_fadr {
 	struct cvmx_lmcx_scrambled_fadr_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_43_63               : 21;
-	uint64_t fcid                         : 3;  /**< Reserved.
-                                                         INTERNAL:
-                                                         Failing CID number. This field is only valid when interfacing with 3DS DRAMs (i.e., when
-                                                         either
-                                                         LMC()_EXT_CONFIG[DIMM0_CID] or LMC()_EXT_CONFIG[DIMM1_CID] is non-zero). Returns a value
-                                                         of zero
-                                                         otherwise. */
+	uint64_t fcid                         : 3;  /**< Reserved. */
 	uint64_t fill_order                   : 2;  /**< Fill order for failing transaction. */
 	uint64_t fdimm                        : 1;  /**< Failing DIMM number. */
 	uint64_t fbunk                        : 1;  /**< Failing rank number. */
@@ -12582,7 +12213,7 @@ typedef union cvmx_lmcx_slot_ctl0 cvmx_lmcx_slot_ctl0_t;
  * This register is an assortment of control fields needed by the memory controller. If software
  * has not previously written to this register (since the last DRESET), hardware updates the
  * fields in this register to the minimum allowed value when any of LMC()_RLEVEL_RANK(),
- * LMC()_WLEVEL_RANK(), LMC()_CONTROL and LMC()_MODEREG_PARAMS0 CSRs change.
+ * LMC()_WLEVEL_RANK(), LMC()_CONTROL and LMC()_MODEREG_PARAMS0 change.
  * Ideally, only read this register after LMC has been initialized and
  * LMC()_RLEVEL_RANK(), LMC()_WLEVEL_RANK() have valid data.
  *
@@ -12641,7 +12272,7 @@ typedef union cvmx_lmcx_slot_ctl1 cvmx_lmcx_slot_ctl1_t;
  * This register is an assortment of control fields needed by the memory controller. If software
  * has not previously written to this register (since the last DRESET), hardware updates the
  * fields in this register to the minimum allowed value when any of LMC()_RLEVEL_RANK(),
- * LMC()_WLEVEL_RANK(), LMC()_CONTROL and LMC()_MODEREG_PARAMS0 CSRs change.
+ * LMC()_WLEVEL_RANK(), LMC()_CONTROL and LMC()_MODEREG_PARAMS0 change.
  * Ideally, only read this register after LMC has been initialized and
  * LMC()_RLEVEL_RANK(), LMC()_WLEVEL_RANK() have valid data.
  *
@@ -12699,7 +12330,7 @@ typedef union cvmx_lmcx_slot_ctl2 cvmx_lmcx_slot_ctl2_t;
  * This register is an assortment of control fields needed by the memory controller. If software
  * has not previously written to this register (since the last DRESET), hardware updates the
  * fields in this register to the minimum allowed value when any of LMC()_RLEVEL_RANK(),
- * LMC()_WLEVEL_RANK(), LMC()_CONTROL and LMC()_MODEREG_PARAMS0 CSRs change.
+ * LMC()_WLEVEL_RANK(), LMC()_CONTROL and LMC()_MODEREG_PARAMS0 change.
  * Ideally, only read this register after LMC has been initialized and
  * LMC()_RLEVEL_RANK(), LMC()_WLEVEL_RANK() have valid data.
  *
@@ -13483,12 +13114,7 @@ union cvmx_lmcx_timing_params1 {
                                                          _ RNDUP[TFAW(ns) / (4 * TCYC(ns))]
                                                          where TFAW is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
                                                          frequency (not data rate).
-                                                         TYP = 30-40 ns
-                                                         INTERNAL:
-                                                         When interfacing with DIMMs that contain 3DS DRAMs, set this field as follows:
-                                                         _ RNDUP[TFAW_SLR(ns) / (4 * TCYC(ns))]
-                                                         where TFAW_SLR is the Four activate window to the same logical rank from the
-                                                         JEDEC DDR4 3D Stacked spec. */
+                                                         TYP = 30-40 ns */
 	uint64_t twldqsen                     : 4;  /**< Indicates TWLDQSEN constraints. Set this field as follows:
                                                          _ RNDUP[TWLDQSEN(ns) / (4 * TCYC(ns))]
                                                          where TWLDQSEN is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
@@ -13618,8 +13244,7 @@ union cvmx_lmcx_timing_params2 {
                                                          _ RNDUP[TWTR_L(ns) / TCYC(ns)] - 1
                                                          where TWTR_L is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not the
                                                          data rate).
-                                                         Typical = MAX(4 nCK, 7.5 ns)
-                                                         INTERNAL: Seems the '- 1' is because we add 1 back into slot timing equation */
+                                                         Typical = MAX(4 nCK, 7.5 ns) */
 	uint64_t trrd_l                       : 3;  /**< Specifies TRRD_L constraints. Set this field as follows:
                                                          _ RNDUP[TRRD_L(ns) / TCYC(ns)] - 1,
                                                          where TRRD_L is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not the
@@ -13657,8 +13282,7 @@ union cvmx_lmcx_timing_params2 {
                                                          RNDUP[TWTR_L(ns) / TCYC(ns)] - 1
                                                          where TWTR_L is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not the
                                                          data rate).
-                                                         Typical = MAX(4 nCK, 7.5 ns)
-                                                         INTERNAL: Seems the '- 1' is because we add 1 back into slot timing equation */
+                                                         Typical = MAX(4 nCK, 7.5 ns) */
 	uint64_t trrd_l                       : 3;  /**< Specifies TRRD_L constraints. Set this field as follows:
                                                          RNDUP[TRRD_L(ns) / TCYC(ns)] - 1,
                                                          where TRRD_L is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not the
@@ -13763,18 +13387,7 @@ union cvmx_lmcx_wlevel_ctl {
                                                          0x4 = LMC writes 0x5 (RZQ/8) to MR1[Rtt_Nom].
                                                          0x5 = LMC writes 0x6 (Rsvd) to MR1[Rtt_Nom].
                                                          0x6 = LMC writes 0x7 (Rsvd) to MR1[Rtt_Nom].
-                                                         0x7 = LMC writes 0x0 (Disabled) to MR1[Rtt_Nom].
-                                                         INTERNAL:
-                                                         In DDR4 LRDIMM application, this is used to program the Data Buffer Control Word BC00
-                                                         during the Host Interface Write Leveling Mode:
-                                                         0x0 = LMC writes 0x1 (RZQ/4).
-                                                         0x1 = LMC writes 0x2 (RZQ/2).
-                                                         0x2 = LMC writes 0x3 (RZQ/6).
-                                                         0x3 = LMC writes 0x4 (RZQ/1).
-                                                         0x4 = LMC writes 0x5 (RZQ/5).
-                                                         0x5 = LMC writes 0x6 (RZQ/3).
-                                                         0x6 = LMC writes 0x7 (RZQ/7).
-                                                         0x7 = LMC writes 0x0 (Disabled). */
+                                                         0x7 = LMC writes 0x0 (Disabled) to MR1[Rtt_Nom]. */
 	uint64_t bitmask                      : 8;  /**< Mask to select bit lanes on which write-leveling feedback is returned when OR_DIS is set to 1. */
 	uint64_t or_dis                       : 1;  /**< Disable ORing of bits in a byte lane when computing the write-leveling bitmask. */
 	uint64_t sset                         : 1;  /**< Run write-leveling on the current setting only. */
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index 7aa363f..ba91aef 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -57,7 +57,7 @@
 #define CVMX_MIO_BOOT_COMP CVMX_MIO_BOOT_COMP_FUNC()
 static inline uint64_t CVMX_MIO_BOOT_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_BOOT_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000000B8ull);
 }
@@ -80,6 +80,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_ADRX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_BOOT_DMA_ADRX(%lu) is invalid on this chip\n", offset);
@@ -99,6 +100,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_CFGX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -119,6 +121,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_INTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -169,6 +172,7 @@ static inline uint64_t CVMX_MIO_BOOT_DMA_TIMX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -209,6 +213,7 @@ static inline uint64_t CVMX_MIO_BOOT_LOC_CFGX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -223,7 +228,7 @@ static inline uint64_t CVMX_MIO_BOOT_LOC_CFGX(unsigned long offset)
 #define CVMX_MIO_BOOT_PIN_DEFS CVMX_MIO_BOOT_PIN_DEFS_FUNC()
 static inline uint64_t CVMX_MIO_BOOT_PIN_DEFS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_BOOT_PIN_DEFS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000000C0ull);
 }
@@ -247,6 +252,7 @@ static inline uint64_t CVMX_MIO_BOOT_REG_CFGX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 7)))))
@@ -273,6 +279,7 @@ static inline uint64_t CVMX_MIO_BOOT_REG_TIMX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 7))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 7)))))
@@ -287,7 +294,7 @@ static inline uint64_t CVMX_MIO_BOOT_REG_TIMX(unsigned long offset)
 #define CVMX_MIO_EMM_ACCESS_WDOG CVMX_MIO_EMM_ACCESS_WDOG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_ACCESS_WDOG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_ACCESS_WDOG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020F0ull);
 }
@@ -298,7 +305,7 @@ static inline uint64_t CVMX_MIO_EMM_ACCESS_WDOG_FUNC(void)
 #define CVMX_MIO_EMM_BUF_DAT CVMX_MIO_EMM_BUF_DAT_FUNC()
 static inline uint64_t CVMX_MIO_EMM_BUF_DAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_BUF_DAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020E8ull);
 }
@@ -309,7 +316,7 @@ static inline uint64_t CVMX_MIO_EMM_BUF_DAT_FUNC(void)
 #define CVMX_MIO_EMM_BUF_IDX CVMX_MIO_EMM_BUF_IDX_FUNC()
 static inline uint64_t CVMX_MIO_EMM_BUF_IDX_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_BUF_IDX not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020E0ull);
 }
@@ -320,7 +327,7 @@ static inline uint64_t CVMX_MIO_EMM_BUF_IDX_FUNC(void)
 #define CVMX_MIO_EMM_CFG CVMX_MIO_EMM_CFG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002000ull);
 }
@@ -331,7 +338,7 @@ static inline uint64_t CVMX_MIO_EMM_CFG_FUNC(void)
 #define CVMX_MIO_EMM_CMD CVMX_MIO_EMM_CMD_FUNC()
 static inline uint64_t CVMX_MIO_EMM_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002058ull);
 }
@@ -342,7 +349,7 @@ static inline uint64_t CVMX_MIO_EMM_CMD_FUNC(void)
 #define CVMX_MIO_EMM_DMA CVMX_MIO_EMM_DMA_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002050ull);
 }
@@ -353,7 +360,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FUNC(void)
 #define CVMX_MIO_EMM_DMA_ADR CVMX_MIO_EMM_DMA_ADR_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_ADR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_ADR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000188ull);
 }
@@ -364,7 +371,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_ADR_FUNC(void)
 #define CVMX_MIO_EMM_DMA_CFG CVMX_MIO_EMM_DMA_CFG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000180ull);
 }
@@ -375,7 +382,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_CFG_FUNC(void)
 #define CVMX_MIO_EMM_DMA_FIFO_ADR CVMX_MIO_EMM_DMA_FIFO_ADR_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_ADR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_FIFO_ADR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000170ull);
 }
@@ -386,7 +393,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_ADR_FUNC(void)
 #define CVMX_MIO_EMM_DMA_FIFO_CFG CVMX_MIO_EMM_DMA_FIFO_CFG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_FIFO_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000160ull);
 }
@@ -397,7 +404,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CFG_FUNC(void)
 #define CVMX_MIO_EMM_DMA_FIFO_CMD CVMX_MIO_EMM_DMA_FIFO_CMD_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_FIFO_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000178ull);
 }
@@ -408,7 +415,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_FIFO_CMD_FUNC(void)
 #define CVMX_MIO_EMM_DMA_INT CVMX_MIO_EMM_DMA_INT_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000190ull);
 }
@@ -419,7 +426,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_INT_FUNC(void)
 #define CVMX_MIO_EMM_DMA_INT_W1S CVMX_MIO_EMM_DMA_INT_W1S_FUNC()
 static inline uint64_t CVMX_MIO_EMM_DMA_INT_W1S_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_DMA_INT_W1S not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000000198ull);
 }
@@ -430,7 +437,7 @@ static inline uint64_t CVMX_MIO_EMM_DMA_INT_W1S_FUNC(void)
 #define CVMX_MIO_EMM_INT CVMX_MIO_EMM_INT_FUNC()
 static inline uint64_t CVMX_MIO_EMM_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002078ull);
 }
@@ -466,6 +473,7 @@ static inline uint64_t CVMX_MIO_EMM_MODEX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
@@ -479,7 +487,7 @@ static inline uint64_t CVMX_MIO_EMM_MODEX(unsigned long offset)
 #define CVMX_MIO_EMM_RCA CVMX_MIO_EMM_RCA_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RCA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_RCA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800000020A0ull);
 }
@@ -490,7 +498,7 @@ static inline uint64_t CVMX_MIO_EMM_RCA_FUNC(void)
 #define CVMX_MIO_EMM_RSP_HI CVMX_MIO_EMM_RSP_HI_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RSP_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_RSP_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002070ull);
 }
@@ -501,7 +509,7 @@ static inline uint64_t CVMX_MIO_EMM_RSP_HI_FUNC(void)
 #define CVMX_MIO_EMM_RSP_LO CVMX_MIO_EMM_RSP_LO_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RSP_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_RSP_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002068ull);
 }
@@ -512,7 +520,7 @@ static inline uint64_t CVMX_MIO_EMM_RSP_LO_FUNC(void)
 #define CVMX_MIO_EMM_RSP_STS CVMX_MIO_EMM_RSP_STS_FUNC()
 static inline uint64_t CVMX_MIO_EMM_RSP_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_RSP_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002060ull);
 }
@@ -523,7 +531,7 @@ static inline uint64_t CVMX_MIO_EMM_RSP_STS_FUNC(void)
 #define CVMX_MIO_EMM_SAMPLE CVMX_MIO_EMM_SAMPLE_FUNC()
 static inline uint64_t CVMX_MIO_EMM_SAMPLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_SAMPLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002090ull);
 }
@@ -534,7 +542,7 @@ static inline uint64_t CVMX_MIO_EMM_SAMPLE_FUNC(void)
 #define CVMX_MIO_EMM_STS_MASK CVMX_MIO_EMM_STS_MASK_FUNC()
 static inline uint64_t CVMX_MIO_EMM_STS_MASK_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_STS_MASK not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002098ull);
 }
@@ -545,7 +553,7 @@ static inline uint64_t CVMX_MIO_EMM_STS_MASK_FUNC(void)
 #define CVMX_MIO_EMM_SWITCH CVMX_MIO_EMM_SWITCH_FUNC()
 static inline uint64_t CVMX_MIO_EMM_SWITCH_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_SWITCH not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002048ull);
 }
@@ -556,7 +564,7 @@ static inline uint64_t CVMX_MIO_EMM_SWITCH_FUNC(void)
 #define CVMX_MIO_EMM_WDOG CVMX_MIO_EMM_WDOG_FUNC()
 static inline uint64_t CVMX_MIO_EMM_WDOG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_EMM_WDOG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000002088ull);
 }
@@ -577,6 +585,7 @@ static inline uint64_t CVMX_MIO_FUS_BNK_DATX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -594,7 +603,7 @@ static inline uint64_t CVMX_MIO_FUS_BNK_DATX(unsigned long offset)
 #define CVMX_MIO_FUS_DAT4 CVMX_MIO_FUS_DAT4_FUNC()
 static inline uint64_t CVMX_MIO_FUS_DAT4_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_FUS_DAT4 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001420ull);
 }
@@ -616,7 +625,7 @@ static inline uint64_t CVMX_MIO_FUS_EMA_FUNC(void)
 #define CVMX_MIO_FUS_INT CVMX_MIO_FUS_INT_FUNC()
 static inline uint64_t CVMX_MIO_FUS_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_FUS_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001548ull);
 }
@@ -632,6 +641,10 @@ static inline uint64_t CVMX_MIO_FUS_PDF_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x0001180000001428ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 			return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -658,6 +671,10 @@ static inline uint64_t CVMX_MIO_FUS_PDF_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180000001428ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 			return CVMX_ADD_IO_SEG(0x0001180000001428ull);
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN50XX & OCTEON_FAMILY_MASK:
@@ -677,7 +694,7 @@ static inline uint64_t CVMX_MIO_FUS_PDF_FUNC(void)
 #define CVMX_MIO_FUS_PLL CVMX_MIO_FUS_PLL_FUNC()
 static inline uint64_t CVMX_MIO_FUS_PLL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_FUS_PLL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001580ull);
 }
@@ -689,7 +706,7 @@ static inline uint64_t CVMX_MIO_FUS_PLL_FUNC(void)
 #define CVMX_MIO_FUS_PROG_TIMES CVMX_MIO_FUS_PROG_TIMES_FUNC()
 static inline uint64_t CVMX_MIO_FUS_PROG_TIMES_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_FUS_PROG_TIMES not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001518ull);
 }
@@ -701,7 +718,7 @@ static inline uint64_t CVMX_MIO_FUS_PROG_TIMES_FUNC(void)
 #define CVMX_MIO_FUS_READ_TIMES CVMX_MIO_FUS_READ_TIMES_FUNC()
 static inline uint64_t CVMX_MIO_FUS_READ_TIMES_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_FUS_READ_TIMES not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001570ull);
 }
@@ -747,6 +764,7 @@ static inline uint64_t CVMX_MIO_FUS_RPR_DATX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIO_FUS_RPR_DATX(%lu) is invalid on this chip\n", offset);
@@ -759,7 +777,7 @@ static inline uint64_t CVMX_MIO_FUS_RPR_DATX(unsigned long offset)
 #define CVMX_MIO_FUS_SOFT_REPAIR CVMX_MIO_FUS_SOFT_REPAIR_FUNC()
 static inline uint64_t CVMX_MIO_FUS_SOFT_REPAIR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_FUS_SOFT_REPAIR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180000001540ull);
 }
@@ -777,6 +795,10 @@ static inline uint64_t CVMX_MIO_FUS_TGG_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x0001180000001430ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x0001180000001430ull);
 			return CVMX_ADD_IO_SEG(0x0001180000001430ull);
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -797,6 +819,10 @@ static inline uint64_t CVMX_MIO_FUS_TGG_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180000001430ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180000001430ull);
 			return CVMX_ADD_IO_SEG(0x0001180000001430ull);
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -888,7 +914,7 @@ static inline uint64_t CVMX_MIO_PLL_SETTING_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_HI_INCR CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_HI_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F40ull);
 }
@@ -899,7 +925,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_LO_INCR CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_LO_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F48ull);
 }
@@ -910,7 +936,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_THRESH_HI CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_THRESH_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F38ull);
 }
@@ -921,7 +947,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC(void)
 #define CVMX_MIO_PTP_CKOUT_THRESH_LO CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_CKOUT_THRESH_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F30ull);
 }
@@ -932,7 +958,7 @@ static inline uint64_t CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_CFG CVMX_MIO_PTP_CLOCK_CFG_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F00ull);
 }
@@ -943,7 +969,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_CFG_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_COMP CVMX_MIO_PTP_CLOCK_COMP_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_COMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_COMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F18ull);
 }
@@ -954,7 +980,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_COMP_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_HI CVMX_MIO_PTP_CLOCK_HI_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F10ull);
 }
@@ -965,7 +991,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_HI_FUNC(void)
 #define CVMX_MIO_PTP_CLOCK_LO CVMX_MIO_PTP_CLOCK_LO_FUNC()
 static inline uint64_t CVMX_MIO_PTP_CLOCK_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_CLOCK_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F08ull);
 }
@@ -976,7 +1002,7 @@ static inline uint64_t CVMX_MIO_PTP_CLOCK_LO_FUNC(void)
 #define CVMX_MIO_PTP_DPLL_ERR_INT CVMX_MIO_PTP_DPLL_ERR_INT_FUNC()
 static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_DPLL_ERR_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F90ull);
 }
@@ -987,7 +1013,7 @@ static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_INT_FUNC(void)
 #define CVMX_MIO_PTP_DPLL_ERR_THRESH CVMX_MIO_PTP_DPLL_ERR_THRESH_FUNC()
 static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_THRESH_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_DPLL_ERR_THRESH not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F88ull);
 }
@@ -998,7 +1024,7 @@ static inline uint64_t CVMX_MIO_PTP_DPLL_ERR_THRESH_FUNC(void)
 #define CVMX_MIO_PTP_DPLL_INCR CVMX_MIO_PTP_DPLL_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_DPLL_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_DPLL_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F80ull);
 }
@@ -1009,7 +1035,7 @@ static inline uint64_t CVMX_MIO_PTP_DPLL_INCR_FUNC(void)
 #define CVMX_MIO_PTP_EVT_CNT CVMX_MIO_PTP_EVT_CNT_FUNC()
 static inline uint64_t CVMX_MIO_PTP_EVT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_EVT_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F28ull);
 }
@@ -1020,7 +1046,7 @@ static inline uint64_t CVMX_MIO_PTP_EVT_CNT_FUNC(void)
 #define CVMX_MIO_PTP_EVT_INT CVMX_MIO_PTP_EVT_INT_FUNC()
 static inline uint64_t CVMX_MIO_PTP_EVT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_EVT_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F70ull);
 }
@@ -1042,7 +1068,7 @@ static inline uint64_t CVMX_MIO_PTP_PHY_1PPS_IN_FUNC(void)
 #define CVMX_MIO_PTP_PPS_HI_INCR CVMX_MIO_PTP_PPS_HI_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_HI_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_HI_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F60ull);
 }
@@ -1053,7 +1079,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_HI_INCR_FUNC(void)
 #define CVMX_MIO_PTP_PPS_LO_INCR CVMX_MIO_PTP_PPS_LO_INCR_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_LO_INCR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_LO_INCR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F68ull);
 }
@@ -1064,7 +1090,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_LO_INCR_FUNC(void)
 #define CVMX_MIO_PTP_PPS_THRESH_HI CVMX_MIO_PTP_PPS_THRESH_HI_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_HI_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_THRESH_HI not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F58ull);
 }
@@ -1075,7 +1101,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_HI_FUNC(void)
 #define CVMX_MIO_PTP_PPS_THRESH_LO CVMX_MIO_PTP_PPS_THRESH_LO_FUNC()
 static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_LO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_PPS_THRESH_LO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F50ull);
 }
@@ -1086,7 +1112,7 @@ static inline uint64_t CVMX_MIO_PTP_PPS_THRESH_LO_FUNC(void)
 #define CVMX_MIO_PTP_TIMESTAMP CVMX_MIO_PTP_TIMESTAMP_FUNC()
 static inline uint64_t CVMX_MIO_PTP_TIMESTAMP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_MIO_PTP_TIMESTAMP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000000F20ull);
 }
@@ -1208,6 +1234,12 @@ static inline uint64_t CVMX_MIO_TWSX_INT(unsigned long offset)
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x0001180000001010ull) + ((offset) & 1) * 512;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x0001180000001010ull) + ((offset) & 1) * 512;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -1241,6 +1273,10 @@ static inline uint64_t CVMX_MIO_TWSX_INT(unsigned long offset)
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180000001010ull) + (offset) * 512;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180000001010ull) + (offset) * 512;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -1272,6 +1308,9 @@ static inline uint64_t CVMX_MIO_TWSX_INT_W1S(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x0001180000001020ull) + ((offset) & 1) * 512;
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001180000001020ull) + ((offset) & 1) * 512;
 			break;
@@ -1287,6 +1326,8 @@ static inline uint64_t CVMX_MIO_TWSX_INT_W1S(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001180000001020ull) + (offset) * 256;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180000001020ull) + (offset) * 512;
 			return CVMX_ADD_IO_SEG(0x0001180000001020ull) + (offset) * 512;
 	}
 	return CVMX_ADD_IO_SEG(0x0001180000001020ull) + (offset) * 256;
@@ -1298,6 +1339,12 @@ static inline uint64_t CVMX_MIO_TWSX_SW_TWSI(unsigned long offset)
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x0001180000001000ull) + ((offset) & 1) * 512;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x0001180000001000ull) + ((offset) & 1) * 512;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -1331,6 +1378,10 @@ static inline uint64_t CVMX_MIO_TWSX_SW_TWSI(unsigned long offset)
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180000001000ull) + (offset) * 512;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180000001000ull) + (offset) * 512;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -1358,6 +1409,12 @@ static inline uint64_t CVMX_MIO_TWSX_SW_TWSI_EXT(unsigned long offset)
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x0001180000001018ull) + ((offset) & 1) * 512;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x0001180000001018ull) + ((offset) & 1) * 512;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -1391,6 +1448,10 @@ static inline uint64_t CVMX_MIO_TWSX_SW_TWSI_EXT(unsigned long offset)
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180000001018ull) + (offset) * 512;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180000001018ull) + (offset) * 512;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -1418,6 +1479,12 @@ static inline uint64_t CVMX_MIO_TWSX_TWSI_SW(unsigned long offset)
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x0001180000001008ull) + ((offset) & 1) * 512;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x0001180000001008ull) + ((offset) & 1) * 512;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -1451,6 +1518,10 @@ static inline uint64_t CVMX_MIO_TWSX_TWSI_SW(unsigned long offset)
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180000001008ull) + (offset) * 512;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180000001008ull) + (offset) * 512;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
@@ -1764,6 +1835,7 @@ static inline uint64_t CVMX_MIO_UARTX_DLH(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1790,6 +1862,7 @@ static inline uint64_t CVMX_MIO_UARTX_DLL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1816,6 +1889,7 @@ static inline uint64_t CVMX_MIO_UARTX_FAR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1842,6 +1916,7 @@ static inline uint64_t CVMX_MIO_UARTX_FCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1868,6 +1943,7 @@ static inline uint64_t CVMX_MIO_UARTX_HTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1894,6 +1970,7 @@ static inline uint64_t CVMX_MIO_UARTX_IER(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1920,6 +1997,7 @@ static inline uint64_t CVMX_MIO_UARTX_IIR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1946,6 +2024,7 @@ static inline uint64_t CVMX_MIO_UARTX_LCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1972,6 +2051,7 @@ static inline uint64_t CVMX_MIO_UARTX_LSR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1998,6 +2078,7 @@ static inline uint64_t CVMX_MIO_UARTX_MCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2024,6 +2105,7 @@ static inline uint64_t CVMX_MIO_UARTX_MSR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2050,6 +2132,7 @@ static inline uint64_t CVMX_MIO_UARTX_RBR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2076,6 +2159,7 @@ static inline uint64_t CVMX_MIO_UARTX_RFL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2102,6 +2186,7 @@ static inline uint64_t CVMX_MIO_UARTX_RFW(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2128,6 +2213,7 @@ static inline uint64_t CVMX_MIO_UARTX_SBCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2154,6 +2240,7 @@ static inline uint64_t CVMX_MIO_UARTX_SCR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2180,6 +2267,7 @@ static inline uint64_t CVMX_MIO_UARTX_SFE(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2206,6 +2294,7 @@ static inline uint64_t CVMX_MIO_UARTX_SRR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2232,6 +2321,7 @@ static inline uint64_t CVMX_MIO_UARTX_SRT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2258,6 +2348,7 @@ static inline uint64_t CVMX_MIO_UARTX_SRTS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2284,6 +2375,7 @@ static inline uint64_t CVMX_MIO_UARTX_STT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2310,6 +2402,7 @@ static inline uint64_t CVMX_MIO_UARTX_TFL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2336,6 +2429,7 @@ static inline uint64_t CVMX_MIO_UARTX_TFR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2362,6 +2456,7 @@ static inline uint64_t CVMX_MIO_UARTX_THR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2388,6 +2483,7 @@ static inline uint64_t CVMX_MIO_UARTX_USR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -2542,16 +2638,7 @@ union cvmx_mio_boot_bist_stat {
 	struct cvmx_mio_boot_bist_stat_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t stat                         : 8;  /**< BIST status.
-                                                         INTERNAL:
-                                                           <0> = mio.mio_boot.boot_fifo.mem.
-                                                           <1> = mio.mio_boot.mio_boot_emm.mem.
-                                                           <2> = mio.mio_boot.mio_boot_mem2.mem.
-                                                           <3> = mio.mio_boot.boot_loc.mem.
-                                                           <4> = mio.mio_boot.dma_fifo.mem.
-                                                           <5> = mio.mio_nbt.mio_nbt_fifo.mem.
-                                                           <6> = mio.mio_emm.bufs.mem.mem.
-                                                           <7> = mio_boot_rom/mio_boot_rom1 (bootroms). */
+	uint64_t stat                         : 8;  /**< BIST status. */
 #else
 	uint64_t stat                         : 8;
 	uint64_t reserved_8_63                : 56;
@@ -3859,8 +3946,8 @@ union cvmx_mio_emm_buf_idx {
 	struct cvmx_mio_emm_buf_idx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_17_63               : 47;
-	uint64_t inc                          : 1;  /**< Automatically advance BUF_NUM/OFFSET after each access to MIO_EMM_BUF_DAT. Wraps after the
-                                                         last offset of the last data buffer. */
+	uint64_t inc                          : 1;  /**< Automatically advance [BUF_NUM]/[OFFSET] after each access to
+                                                         MIO_EMM_BUF_DAT. Wraps after the last offset of the last data buffer. */
 	uint64_t reserved_7_15                : 9;
 	uint64_t buf_num                      : 1;  /**< Specify the data buffer for the next access to MIO_EMM_BUF_DAT. */
 	uint64_t offset                       : 6;  /**< Specify the 8B data buffer offset for the next access to MIO_EMM_BUF_DAT. */
@@ -3903,13 +3990,13 @@ union cvmx_mio_emm_cfg {
                                                          * BOOT_WE_L driven to 0. */
 	uint64_t reserved_4_15                : 12;
 	uint64_t bus_ena                      : 4;  /**< eMMC bus enable mask.
-                                                         Setting bit0 of BUS_ENA causes EMMC_CMD[0] to become dedicated eMMC bus 0 command (i.e.
+                                                         Setting bit0 of [BUS_ENA] causes EMMC_CMD[0] to become dedicated eMMC bus 0 command (i.e.
                                                          disabling any NOR use).
-                                                         Setting bit1 of BUS_ENA causes EMMC_CMD[1] to become dedicated eMMC bus 1 command (i.e.
+                                                         Setting bit1 of [BUS_ENA] causes EMMC_CMD[1] to become dedicated eMMC bus 1 command (i.e.
                                                          disabling any NOR use).
-                                                         Setting bit2 of BUS_ENA causes EMMC_CMD[2] to become dedicated eMMC bus 2 command (i.e.
+                                                         Setting bit2 of [BUS_ENA] causes EMMC_CMD[2] to become dedicated eMMC bus 2 command (i.e.
                                                          disabling any NOR use).
-                                                         Bit3 of BUS_ENA is reserved.
+                                                         Bit3 of [BUS_ENA] is reserved.
                                                          Clearing all bits of this field will reset the other MIO_EMM_* registers.  It might be
                                                          necessary
                                                          to set and and clear the bits several times to insure the MIO_EMM_* registers have been
@@ -3954,8 +4041,7 @@ union cvmx_mio_emm_cmd {
 	uint64_t dbuf                         : 1;  /**< Specify the data buffer to be used for a block transfer. */
 	uint64_t offset                       : 6;  /**< Debug only. Specify the number of 8-byte transfers used in the command. Value is
                                                          64-OFFSET. The block transfer still starts at the first byte in the 512B data buffer.
-                                                         Software must ensure CMD16 has updated the card block length.
-                                                         INTERNAL:  This field is forced to zero in cases where CMD_VAL is not set. */
+                                                         Software must ensure CMD16 has updated the card block length. */
 	uint64_t reserved_43_48               : 6;
 	uint64_t ctype_xor                    : 2;  /**< Command type override; typically zero. Value is XOR'd with the default command type. See
                                                          Command and Response Types for command types per command index. Types are:
@@ -4067,7 +4153,7 @@ union cvmx_mio_emm_dma {
 	uint64_t thres                        : 6;  /**< Number of 8-byte blocks of data that must exist in the DBUF before starting the 512-byte
                                                          block transfer. Zero indicates to wait for the entire block. */
 	uint64_t rel_wr                       : 1;  /**< Set the reliable write parameter when performing CMD23 (SET_BLOCK_COUNT) for a multiple block. */
-	uint64_t rw                           : 1;  /**< Read/write bit (0 = read, 1 = write) */
+	uint64_t rw                           : 1;  /**< Read/write bit (0 = read, 1 = write). */
 	uint64_t multi                        : 1;  /**< Perform operation using a multiple block command instead of a series of single block commands. */
 	uint64_t block_cnt                    : 16; /**< Number of blocks to read/write. Hardware decrements the block count after each successful
                                                          block transfer. */
@@ -4583,7 +4669,8 @@ union cvmx_mio_emm_rca {
 	struct cvmx_mio_emm_rca_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t card_rca                     : 16; /**< Whenever software performs CMD7, hardware updates CARD_RCA with the relative card address
+	uint64_t card_rca                     : 16; /**< Whenever software performs CMD7, hardware updates [CARD_RCA] with the relative card
+                                                         address
                                                          from the MIO_EMM_CMD[ARG], unless the operation encounters an error. */
 #else
 	uint64_t card_rca                     : 16;
@@ -4705,29 +4792,32 @@ union cvmx_mio_emm_rsp_sts {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_62_63               : 2;
 	uint64_t bus_id                       : 2;  /**< eMMC bus ID to which the response status corresponds. */
-	uint64_t cmd_val                      : 1;  /**< Read-only copy of MIO_EMM_CMD[CMD_VAL]. CMD_VAL = 1 indicates that a direct operation is
+	uint64_t cmd_val                      : 1;  /**< Read-only copy of MIO_EMM_CMD[CMD_VAL]. [CMD_VAL] = 1 indicates that a direct operation is
                                                          in progress. */
-	uint64_t switch_val                   : 1;  /**< Read-only copy of MIO_EMM_SWITCH[SWITCH_EXE]. SWITCH_VAL = 1 indicates that a switch
+	uint64_t switch_val                   : 1;  /**< Read-only copy of MIO_EMM_SWITCH[SWITCH_EXE]. [SWITCH_VAL] = 1 indicates that a switch
                                                          operation is in progress. */
-	uint64_t dma_val                      : 1;  /**< Read-only copy of MIO_EMM_DMA[DMA_VAL]. DMA_VAL = 1 indicates that a DMA operation is in progress. */
+	uint64_t dma_val                      : 1;  /**< Read-only copy of MIO_EMM_DMA[DMA_VAL]. [DMA_VAL] = 1 indicates that a DMA operation is in
+                                                         progress. */
 	uint64_t dma_pend                     : 1;  /**< The DMA engine has a pending transfer resulting from an error. Software can resume the
                                                          transfer by writing MIO_EMM_DMA[DMA_VAL] = 1.
                                                          Software can terminate the transfer by writing MIO_EMM_DMA[DMA_VAL] = 1 and
-                                                         MIO_EMM_DMA[DAT_NULL] = 1. Hardware will then clear DMA_PEND and perform the DMA
+                                                         MIO_EMM_DMA[DAT_NULL] = 1. Hardware will then clear [DMA_PEND] and perform the DMA
                                                          operation. */
 	uint64_t acc_timeout                  : 1;  /**< The store operation to the device took longer than MIO_EMM_ACCESS_WDOG[CLK_CNT]
                                                          coprocessor-clocks to complete.
-                                                         Valid when DMA_PEND=1. */
+                                                         Valid when [DMA_PEND] is set. */
 	uint64_t reserved_29_54               : 26;
-	uint64_t dbuf_err                     : 1;  /**< For CMD_TYPE = 1, indicates that a DMA read data arrived from the card without a free
-                                                         DBUF. For CMD_TYPE = 2, indicates a DBUF underflow occurred during a DMA write. See
+	uint64_t dbuf_err                     : 1;  /**< For [CMD_TYPE] = 1, indicates that a DMA read data arrived from the card without a free
+                                                         DBUF. For [CMD_TYPE] = 2, indicates a DBUF underflow occurred during a DMA write. See
                                                          MIO_EMM_DMA[THRES]. */
 	uint64_t reserved_24_27               : 4;
 	uint64_t dbuf                         : 1;  /**< DBUF corresponding to the most recently attempted block transfer. */
 	uint64_t blk_timeout                  : 1;  /**< Timeout waiting for read data or 3-bit CRC token. */
-	uint64_t blk_crc_err                  : 1;  /**< For CMD_TYPE = 1, indicates a card read data CRC mismatch. MIO_EMM_RSP_STS[DBUF] indicates
+	uint64_t blk_crc_err                  : 1;  /**< For [CMD_TYPE] = 1, indicates a card read data CRC mismatch. MIO_EMM_RSP_STS[DBUF]
+                                                         indicates
                                                          the failing data buffer.
-                                                         For CMD_TYPE = 2, indicates card returned 3-bit CRC status token indicating that the card
+                                                         For [CMD_TYPE] = 2, indicates card returned 3-bit CRC status token indicating that the
+                                                         card
                                                          encountered a write data CRC check mismatch. MIO_EMM_RSP_STS[DBUF] indicates the failing
                                                          data buffer. */
 	uint64_t rsp_busybit                  : 1;  /**< Debug only. eMMC protocol utilizes DAT0 as a busy signal during block writes and R1b
@@ -4899,8 +4989,8 @@ union cvmx_mio_emm_sts_mask {
 	struct cvmx_mio_emm_sts_mask_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t sts_msk                      : 32; /**< Any bit set in STS_MSK causes the corresponding bit in the card status to be considered
-                                                         when computing response bad status. */
+	uint64_t sts_msk                      : 32; /**< Any bit set in [STS_MSK] causes the corresponding bit in the card status to be
+                                                         considered when computing response bad status. */
 #else
 	uint64_t sts_msk                      : 32;
 	uint64_t reserved_32_63               : 32;
@@ -4929,31 +5019,31 @@ union cvmx_mio_emm_switch {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_62_63               : 2;
 	uint64_t bus_id                       : 2;  /**< Specifies the eMMC bus id. */
-	uint64_t switch_exe                   : 1;  /**< When SWITCH_EXE is 0, the operating modes are updated directly without performing any
+	uint64_t switch_exe                   : 1;  /**< When clear, the operating modes are updated directly without performing any
                                                          SWITCH operations. This allows software to perform the SWITCH operations manually, then
                                                          update the hardware.
                                                          Software writes this bit to a 1 to indicate that hardware should perform the necessary
                                                          SWITCH operations.
-                                                         * First, the POWER_CLASS switch is performed. If it fails, SWITCH_ERR0 is set and the
-                                                         remaining SWITCH operations are not performed. If it succeeds, the POWER_CLASS field is
+                                                         * First, the POWER_CLASS switch is performed. If it fails, [SWITCH_ERR0] is set and the
+                                                         remaining SWITCH operations are not performed. If it succeeds, [POWER_CLASS] is
                                                          updated and the HS_TIMING switch is performed.
-                                                         * If the HS_TIMING switch fails, SWITCH_ERR1 is set and the remaining SWITCH operations
-                                                         are not performed. If it succeeds, the HS_TIMING field is updated and the BUS_WIDTH switch
+                                                         * If the HS_TIMING switch fails, [SWITCH_ERR1] is set and the remaining SWITCH operations
+                                                         are not performed. If it succeeds, [HS_TIMING] is updated and the BUS_WIDTH switch
                                                          operation is performed.
-                                                         * If the BUS_WIDTH switch operation fails, SWITCH_ERR2 is set. If it succeeds, the
+                                                         * If the BUS_WIDTH switch operation fails, [SWITCH_ERR2] is set. If it succeeds, the
                                                          BUS_WITDH is updated.
                                                          Changes to CLK_HI and CLK_LO are discarded if any SWITCH_ERR occurs. */
 	uint64_t switch_err0                  : 1;  /**< Error encountered while performing POWER_CLASS switch. See MIO_EMM_RSP_STS. */
 	uint64_t switch_err1                  : 1;  /**< Error encountered while performing HS_TIMING switch. See MIO_EMM_RSP_STS. */
 	uint64_t switch_err2                  : 1;  /**< Error encountered while performing BUS_WIDTH switch. See MIO_EMM_RSP_STS. */
 	uint64_t reserved_49_55               : 7;
-	uint64_t hs_timing                    : 1;  /**< Requested update to HS_TIMING */
+	uint64_t hs_timing                    : 1;  /**< Requested update to HS_TIMING. */
 	uint64_t reserved_43_47               : 5;
-	uint64_t bus_width                    : 3;  /**< Requested update to BUS_WIDTH */
+	uint64_t bus_width                    : 3;  /**< Requested update to BUS_WIDTH. */
 	uint64_t reserved_36_39               : 4;
-	uint64_t power_class                  : 4;  /**< Requested update to POWER_CLASS */
-	uint64_t clk_hi                       : 16; /**< Requested update to CLK_HI */
-	uint64_t clk_lo                       : 16; /**< Requested update to CLK_LO */
+	uint64_t power_class                  : 4;  /**< Requested update to POWER_CLASS. */
+	uint64_t clk_hi                       : 16; /**< Requested update to CLK_HI. */
+	uint64_t clk_lo                       : 16; /**< Requested update to CLK_LO. */
 #else
 	uint64_t clk_lo                       : 16;
 	uint64_t clk_hi                       : 16;
@@ -5178,17 +5268,15 @@ union cvmx_mio_fus_dat2 {
 	uint64_t gbl_pwr_throttle             : 8;  /**< Controls global power throttling. MSB is a spare, and lower 7 bits indicate
                                                          N/128 power reduction. Small values have less throttling and higher
                                                          performance. 0x0 disables throttling. */
-	uint64_t fus118                       : 1;  /**< Fuse information - Ignore Authentik disable.
-                                                         INTERNAL: fuse[99]. */
+	uint64_t fus118                       : 1;  /**< Fuse information - Ignore Authentik disable. */
 	uint64_t rom_info                     : 10; /**< Fuse information - ROM info. */
 	uint64_t power_limit                  : 2;  /**< Fuse information - Power limit. */
 	uint64_t dorm_crypto                  : 1;  /**< Fuse information - Dormant encryption enable. See NOCRYPTO. */
-	uint64_t fus318                       : 1;  /**< Reserved.
-                                                         INTERNAL: Tied to 0. */
+	uint64_t fus318                       : 1;  /**< Reserved. */
 	uint64_t raid_en                      : 1;  /**< Fuse information - RAID enabled. */
 	uint64_t reserved_30_31               : 2;
 	uint64_t nokasu                       : 1;  /**< Fuse information - Disable Kasumi */
-	uint64_t nodfa_cp2                    : 1;  /**< Reserved. INTERNAL: Fuse information - HFA disable (CP2). */
+	uint64_t nodfa_cp2                    : 1;  /**< Reserved. */
 	uint64_t nomul                        : 1;  /**< Fuse information - VMUL disable. */
 	uint64_t nocrypto                     : 1;  /**< Fuse information - DORM_CRYPTO and NOCRYPTO together select one of four mutually-exclusive
                                                          modes:
@@ -5619,13 +5707,11 @@ union cvmx_mio_fus_dat2 {
 	uint64_t gbl_pwr_throttle             : 8;  /**< Controls global power throttling. MSB is a spare, and lower 7 bits indicate
                                                          N/128 power reduction. Small values have less throttling and higher
                                                          performance. 0x0 disables throttling. */
-	uint64_t fus118                       : 1;  /**< Fuse information - Ignore Authentik disable.
-                                                         INTERNAL: fuse[99]. */
+	uint64_t fus118                       : 1;  /**< Fuse information - Ignore Authentik disable. */
 	uint64_t rom_info                     : 10; /**< Fuse information - ROM info. */
 	uint64_t power_limit                  : 2;  /**< Fuse information - Power limit. */
 	uint64_t dorm_crypto                  : 1;  /**< Fuse information - Dormant encryption enable. See NOCRYPTO. */
-	uint64_t fus318                       : 1;  /**< Reserved.
-                                                         INTERNAL: Tied to 0. */
+	uint64_t fus318                       : 1;  /**< Reserved. */
 	uint64_t raid_en                      : 1;  /**< Fuse information - RAID enabled. */
 	uint64_t reserved_31_29               : 3;
 	uint64_t nodfa_cp2                    : 1;  /**< Fuse information - HFA disable (CP2). */
@@ -5669,17 +5755,14 @@ union cvmx_mio_fus_dat2 {
                                                          0x3 = ASIM.
                                                          0x4-0x7 = Reserved. */
 	uint64_t reserved_48_55               : 8;
-	uint64_t fus118                       : 1;  /**< Fuse information - Ignore Authentik disable.
-                                                         INTERNAL: fuse[99]. */
+	uint64_t fus118                       : 1;  /**< Fuse information - Ignore Authentik disable. */
 	uint64_t rom_info                     : 10; /**< Fuse information - ROM info. */
 	uint64_t power_limit                  : 2;  /**< Fuse information - Power limit. */
 	uint64_t dorm_crypto                  : 1;  /**< Fuse information - Dormant encryption enable. See NOCRYPTO. */
-	uint64_t fus318                       : 1;  /**< Reserved.
-                                                         INTERNAL: Tied to 0. */
+	uint64_t fus318                       : 1;  /**< Reserved. */
 	uint64_t raid_en                      : 1;  /**< Fuse information - RAID enabled. */
 	uint64_t reserved_31_29               : 3;
-	uint64_t nodfa_cp2                    : 1;  /**< Fuse information - HFA disable (CP2).
-                                                         INTERNAL: Tied to 1. */
+	uint64_t nodfa_cp2                    : 1;  /**< Fuse information - HFA disable (CP2). */
 	uint64_t nomul                        : 1;  /**< Fuse information - VMUL disable. */
 	uint64_t nocrypto                     : 1;  /**< Fuse information - DORM_CRYPTO and NOCRYPTO together select one of four mutually-exclusive
                                                          modes:
@@ -5723,17 +5806,14 @@ union cvmx_mio_fus_dat2 {
                                                          N/128 power reduction. Small values have less throttling and higher
                                                          performance. 0x0 disables throttling.
                                                          Added in pass 2. */
-	uint64_t fus118                       : 1;  /**< Fuse information - Ignore Authentik disable.
-                                                         INTERNAL: fuse[99]. */
+	uint64_t fus118                       : 1;  /**< Fuse information - Ignore Authentik disable. */
 	uint64_t rom_info                     : 10; /**< Fuse information - ROM info. */
 	uint64_t power_limit                  : 2;  /**< Fuse information - Power limit. */
 	uint64_t dorm_crypto                  : 1;  /**< Fuse information - Dormant encryption enable. See NOCRYPTO. */
-	uint64_t fus318                       : 1;  /**< Reserved.
-                                                         INTERNAL: Tied to 0. */
+	uint64_t fus318                       : 1;  /**< Reserved. */
 	uint64_t raid_en                      : 1;  /**< Fuse information - RAID enabled. */
 	uint64_t reserved_31_29               : 3;
-	uint64_t nodfa_cp2                    : 1;  /**< Fuse information - HFA disable (CP2).
-                                                         INTERNAL: Tied to 1. */
+	uint64_t nodfa_cp2                    : 1;  /**< Fuse information - HFA disable (CP2). */
 	uint64_t nomul                        : 1;  /**< Fuse information - VMUL disable. */
 	uint64_t nocrypto                     : 1;  /**< Fuse information - DORM_CRYPTO and NOCRYPTO together select one of four mutually-exclusive
                                                          modes:
@@ -5775,11 +5855,10 @@ union cvmx_mio_fus_dat3 {
 	uint64_t u64;
 	struct cvmx_mio_fus_dat3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x11. Soft or hard blow of these fuses
-                                                         will XOR with this value. */
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. */
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
-	uint64_t dfa_info_dte                 : 3;  /**< Reserved. INTERNAL: Fuse information - HFA information (HTE). */
-	uint64_t dfa_info_clm                 : 4;  /**< Reserved. INTERNAL: Fuse information - HFA information (cluster mask). */
+	uint64_t dfa_info_dte                 : 3;  /**< Reserved. */
+	uint64_t dfa_info_clm                 : 4;  /**< Reserved. */
 	uint64_t pll_alt_matrix               : 1;  /**< Select alternate PLL matrix. */
 	uint64_t reserved_38_39               : 2;
 	uint64_t efus_lck_rsv                 : 1;  /**< Fuse information - efuse lockdown. */
@@ -5794,8 +5873,8 @@ union cvmx_mio_fus_dat3 {
 	uint64_t reserved_28_31               : 4;
 	uint64_t efus_lck                     : 1;  /**< Fuse information - efuse lockdown. */
 	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore. */
-	uint64_t nozip                        : 1;  /**< Reserved. INTERNAL: Fuse information - ZIP disable. */
-	uint64_t nodfa_dte                    : 1;  /**< Reserved. INTERNAL: Fuse information - HFA disable (HTE). */
+	uint64_t nozip                        : 1;  /**< Reserved. */
+	uint64_t nodfa_dte                    : 1;  /**< Reserved. */
 	uint64_t reserved_0_23                : 24;
 #else
 	uint64_t reserved_0_23                : 24;
@@ -5983,8 +6062,7 @@ union cvmx_mio_fus_dat3 {
 	struct cvmx_mio_fus_dat3_cn61xx       cn68xxp1;
 	struct cvmx_mio_fus_dat3_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x02. Soft or hard blow of these fuses
-                                                         will XOR with this value. */
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. */
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
 	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - HFA information (HTE). */
 	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - HFA information (cluster mask). */
@@ -6011,8 +6089,7 @@ union cvmx_mio_fus_dat3 {
 	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore. */
 	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable. */
 	uint64_t nodfa_dte                    : 1;  /**< Fuse information - HFA disable (HTE). */
-	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. INTERNAL: dflt value is 0x11. Soft or hard blow
-                                                         of these fuses will XOR with this value. */
+	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. */
 	uint64_t reserved_0_17                : 18;
 #else
 	uint64_t reserved_0_17                : 18;
@@ -6038,8 +6115,7 @@ union cvmx_mio_fus_dat3 {
 	} cn70xx;
 	struct cvmx_mio_fus_dat3_cn70xxp1 {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x02. Soft or hard blow of these fuses
-                                                         will XOR with this value. */
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. */
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
 	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - HFA information (HTE). */
 	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - HFA information (cluster mask). */
@@ -6060,8 +6136,7 @@ union cvmx_mio_fus_dat3 {
 	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore. */
 	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable. */
 	uint64_t nodfa_dte                    : 1;  /**< Fuse information - HFA disable (HTE). */
-	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. INTERNAL: dflt value is 0x11. Soft or hard blow
-                                                         of these fuses will XOR with this value. */
+	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. */
 	uint64_t reserved_0_17                : 18;
 #else
 	uint64_t reserved_0_17                : 18;
@@ -6086,8 +6161,7 @@ union cvmx_mio_fus_dat3 {
 	} cn70xxp1;
 	struct cvmx_mio_fus_dat3_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x11. Soft or hard blow of these fuses
-                                                         will XOR with this value. */
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. */
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
 	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - HFA information (HTE). */
 	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - HFA information (cluster mask). */
@@ -6113,8 +6187,7 @@ union cvmx_mio_fus_dat3 {
 	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore. */
 	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable. */
 	uint64_t nodfa_dte                    : 1;  /**< Fuse information - HFA disable (HTE). */
-	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. INTERNAL: Default value is 0x02. Soft or hard blow of these fuses
-                                                         will XOR with this value. */
+	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. */
 	uint64_t nohna_dte                    : 1;  /**< Fuse information - HNA disable (DTE). */
 	uint64_t hna_info_dte                 : 3;  /**< Fuse information - HNA information (DTE). */
 	uint64_t hna_info_clm                 : 4;  /**< Fuse information - HNA information (cluster mask). */
@@ -6154,8 +6227,7 @@ union cvmx_mio_fus_dat3 {
 	} cn73xx;
 	struct cvmx_mio_fus_dat3_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x11. Soft or hard blow of these fuses
-                                                         will XOR with this value. */
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. */
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
 	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - HFA information (HTE). */
 	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - HFA information (cluster mask). */
@@ -6176,8 +6248,7 @@ union cvmx_mio_fus_dat3 {
 	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore. */
 	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable. */
 	uint64_t nodfa_dte                    : 1;  /**< Fuse information - HFA disable (HTE). */
-	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. INTERNAL: Default value is 0x02. Soft or hard blow of these fuses
-                                                         will XOR with this value. */
+	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. */
 	uint64_t nohna_dte                    : 1;  /**< Fuse information - HNA disable (DTE). */
 	uint64_t hna_info_dte                 : 3;  /**< Fuse information - HNA information (DTE). */
 	uint64_t hna_info_clm                 : 4;  /**< Fuse information - HNA information (cluster mask). */
@@ -6210,11 +6281,10 @@ union cvmx_mio_fus_dat3 {
 	struct cvmx_mio_fus_dat3_cn61xx       cnf71xx;
 	struct cvmx_mio_fus_dat3_cnf75xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x11. Soft or hard blow of these fuses
-                                                         will XOR with this value. */
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. */
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
-	uint64_t dfa_info_dte                 : 3;  /**< Reserved. INTERNAL: Fuse information - HFA information (HTE). */
-	uint64_t dfa_info_clm                 : 4;  /**< Reserved. INTERNAL: Fuse information - HFA information (cluster mask). */
+	uint64_t dfa_info_dte                 : 3;  /**< Reserved. */
+	uint64_t dfa_info_clm                 : 4;  /**< Reserved. */
 	uint64_t pll_alt_matrix               : 1;  /**< Select alternate PLL matrix. */
 	uint64_t pll_bwadj_denom              : 2;  /**< Select CLKF denominator for BWADJ value.
                                                          0x0 = Selects CLKF/4.
@@ -6231,14 +6301,13 @@ union cvmx_mio_fus_dat3 {
                                                          0x4-0x7 = Reserved. */
 	uint64_t use_int_refclk               : 1;  /**< If set, use the PLL output as the low-jitter reference clock to the rclk DLLs. Default is
                                                          to use the internal input reference clock. */
-	uint64_t zip_info                     : 2;  /**< Reserved. INTERNAL: Fuse information - ZIP information. */
+	uint64_t zip_info                     : 2;  /**< Reserved. */
 	uint64_t bar2_sz_conf                 : 1;  /**< Fuse information - When 0, BAR2 size conforms to PCIe specification. */
 	uint64_t efus_lck                     : 1;  /**< Fuse information - efuse lockdown. */
 	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore. */
-	uint64_t nozip                        : 1;  /**< Reserved. INTERNAL: Fuse information - ZIP disable. */
-	uint64_t nodfa_dte                    : 1;  /**< Reserved. INTERNAL: Fuse information - HFA disable (HTE). */
-	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. INTERNAL: Default value is 0x02. Soft or hard blow of these fuses
-                                                         will XOR with this value. */
+	uint64_t nozip                        : 1;  /**< Reserved. */
+	uint64_t nodfa_dte                    : 1;  /**< Reserved. */
+	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. */
 	uint64_t reserved_9_17                : 9;
 	uint64_t core_pll_mul                 : 5;  /**< Core-clock PLL multiplier hardware limit. Indicates maximum
                                                          value for PLL_MUL[5:1] straps.  Any strap setting above this
@@ -6366,8 +6435,8 @@ union cvmx_mio_fus_int {
 	struct cvmx_mio_fus_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t rpr_dbe                      : 1;  /**< INTERNAL: Indicates an uncorrectable double-bit-error occurred to RPR_MEM. */
-	uint64_t rpr_sbe                      : 1;  /**< INTERNAL: Indicates a corrected single-bit-error occurred to RPR_MEM. */
+	uint64_t rpr_dbe                      : 1;  /**< N/A */
+	uint64_t rpr_sbe                      : 1;  /**< N/A */
 #else
 	uint64_t rpr_sbe                      : 1;
 	uint64_t rpr_dbe                      : 1;
@@ -6615,14 +6684,7 @@ union cvmx_mio_fus_prog {
 	struct cvmx_mio_fus_prog_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t prog                         : 1;  /**< INTERNAL: When written to one by software, blow the fuse bank. Hardware will clear when
-                                                         the program operation is complete.
-                                                         To write a bank of fuses, software must set MIO_FUS_WADR[ADDR] to the bank to be
-                                                         programmed and then set each bit within MIO_FUS_BNK_DAT() to indicate which fuses to blow.
-                                                         Once ADDR, and DAT are setup, SW can write to MIO_FUS_PROG[PROG] to start the bank write
-                                                         and poll on PROG. Once PROG is clear, the bank write is complete. A soft blow is still
-                                                         subject to lockdown fuses. After a soft/warm reset, the chip will behave as though the
-                                                         fuses were actually blown. A cold reset restores the actual fuse values. */
+	uint64_t prog                         : 1;  /**< N/A */
 #else
 	uint64_t prog                         : 1;
 	uint64_t reserved_1_63                : 63;
@@ -6662,16 +6724,8 @@ union cvmx_mio_fus_prog {
 	struct cvmx_mio_fus_prog_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t sft                          : 1;  /**< INTERNAL: When set with PROG, causes only the local storage to change and will not blow
-                                                         any fuses. Hardware will clear when the program operation is complete. */
-	uint64_t prog                         : 1;  /**< INTERNAL: When written to one by software, blow the fuse bank. Hardware will clear when
-                                                         the program operation is complete.
-                                                         To write a bank of fuses, software must set MIO_FUS_WADR[ADDR] to the bank to be
-                                                         programmed and then set each bit within MIO_FUS_BNK_DATX to indicate which fuses to blow.
-                                                         Once ADDR, and DAT are setup, SW can write to MIO_FUS_PROG[PROG] to start the bank write
-                                                         and poll on PROG. Once PROG is clear, the bank write is complete. A soft blow is still
-                                                         subject to lockdown fuses. After a soft/warm reset, the chip will behave as though the
-                                                         fuses were actually blown. A cold reset restores the actual fuse values. */
+	uint64_t sft                          : 1;  /**< N/A */
+	uint64_t prog                         : 1;  /**< N/A */
 #else
 	uint64_t prog                         : 1;
 	uint64_t sft                          : 1;
@@ -6708,9 +6762,9 @@ union cvmx_mio_fus_prog_times {
 	struct cvmx_mio_fus_prog_times_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_35_63               : 29;
-	uint64_t vgate_pin                    : 1;  /**< INTERNAL: Efuse vgate pin (L6G). */
-	uint64_t fsrc_pin                     : 1;  /**< INTERNAL: Efuse fsource pin (L6G). */
-	uint64_t prog_pin                     : 1;  /**< INTERNAL: Efuse program pin (IFB). */
+	uint64_t vgate_pin                    : 1;  /**< N/A */
+	uint64_t fsrc_pin                     : 1;  /**< N/A */
+	uint64_t prog_pin                     : 1;  /**< N/A */
 	uint64_t reserved_6_31                : 26;
 	uint64_t setup                        : 6;  /**< efuse timing param
 
@@ -6800,9 +6854,9 @@ union cvmx_mio_fus_prog_times {
 	struct cvmx_mio_fus_prog_times_cn70xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_35_63               : 29;
-	uint64_t vgate_pin                    : 1;  /**< INTERNAL: Efuse vgate pin (L6G). */
-	uint64_t fsrc_pin                     : 1;  /**< INTERNAL: Efuse fsource pin (L6G). */
-	uint64_t prog_pin                     : 1;  /**< INTERNAL: Efuse program pin (IFB). */
+	uint64_t vgate_pin                    : 1;  /**< N/A */
+	uint64_t fsrc_pin                     : 1;  /**< N/A */
+	uint64_t prog_pin                     : 1;  /**< N/A */
 	uint64_t reserved_0_31                : 32;
 #else
 	uint64_t reserved_0_31                : 32;
@@ -7130,8 +7184,7 @@ union cvmx_mio_fus_rpr_datx {
 	uint64_t u64;
 	struct cvmx_mio_fus_rpr_datx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dat                          : 64; /**< INTERNAL: Repair memory store (RPR_MEM). Data for read and write. A write to
-                                                         MIO_FUS_RPR_DAT(1) writes all 128 bits from both registers to RPR_MEM. */
+	uint64_t dat                          : 64; /**< N/A */
 #else
 	uint64_t dat                          : 64;
 #endif
@@ -7153,16 +7206,11 @@ union cvmx_mio_fus_soft_repair {
 	struct cvmx_mio_fus_soft_repair_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_20_63               : 44;
-	uint64_t rpr_flip_synd                : 2;  /**< INTERNAL: Flip syndrome bits on RPR_MEM writes. For diagnostic use only. */
-	uint64_t autoblow                     : 1;  /**< INTERNAL: Set to initiate burning of defect fuses to fuse macro. Clears when fuses are
-                                                         blown. */
-	uint64_t too_many                     : 1;  /**< INTERNAL: Set if the sum of fuse repairs and memory defects exceeds 195. */
-	uint64_t numdefects                   : 8;  /**< INTERNAL: After reset/BIST indicates the number of memory defects reported. Defects are
-                                                         stored in REPAIR_MEM from bit address NUMREPAIRS*21 to (NUMREPAIRS*21 + NUMDEFECTS*21 -
-                                                         1). */
-	uint64_t numrepairs                   : 8;  /**< INTERNAL: Indicates the number of soft repairs to load from repair mem to the memories on
-                                                         a soft/warm reset. Indicates the number of repairs loaded from efuses to repair mem on a
-                                                         cold reset. */
+	uint64_t rpr_flip_synd                : 2;  /**< N/A */
+	uint64_t autoblow                     : 1;  /**< N/A */
+	uint64_t too_many                     : 1;  /**< N/A */
+	uint64_t numdefects                   : 8;  /**< N/A */
+	uint64_t numrepairs                   : 8;  /**< N/A */
 #else
 	uint64_t numrepairs                   : 8;
 	uint64_t numdefects                   : 8;
@@ -7264,15 +7312,6 @@ typedef union cvmx_mio_fus_spr_repair_sum cvmx_mio_fus_spr_repair_sum_t;
  *
  * This register exists to support Authentik. Authentik code should read this register, then
  * clear VAL to prevent other software from observing the value of the TGG fuses.
- *
- * INTERNAL: It is never possible to read the TGG fuses via MIO_FUS_RCMD. Whenever the fuse
- * corresponding to VAL (TGG<63>) is blown, it is not possible to blow any of TGG<62:0>. The fuse
- * corresponding to VAL must be the one and only lock down bit for TGG<62:0> - no other fuse
- * lockdown bit can prevent blowing TGG<62:0>. It must always be possible to blow the fuse
- * corresponding to VAL when it is not already blown. If an Authentik part may be converted to a
- * non-Authentik part (via some JTAG mechanism or any other mechanism), it must not be possible
- * to read the TGG fuse values from the Authentik part by performing this conversion -> the reset
- * value of VAL should be zero in this converted case.
  */
 union cvmx_mio_fus_tgg {
 	uint64_t u64;
@@ -7742,7 +7781,7 @@ union cvmx_mio_ptp_clock_cfg {
 	uint64_t pps_inv                      : 1;  /**< Invert PTP PPS.
                                                          0 = Don't invert.
                                                          1 = Invert. */
-	uint64_t pps_en                       : 1;  /**< Enable PTP PPS. (For output pin selection see GPIO_BIT_CFG.) */
+	uint64_t pps_en                       : 1;  /**< Enable PTP PPS. (For output pin selection see GPIO_BIT_CFG().) */
 	uint64_t ckout_out                    : 4;  /**< Destination for PTP Clock Out output to GPIO
                                                          0-19 : GPIO[[CKOUT_OUT4,CKOUT_OUT[3:0]]]
                                                          - 20:30: Reserved
@@ -7751,16 +7790,16 @@ union cvmx_mio_ptp_clock_cfg {
 	uint64_t ckout_inv                    : 1;  /**< Invert PTP CKOUT.
                                                          0 = Don't invert.
                                                          1 = Invert. */
-	uint64_t ckout_en                     : 1;  /**< Enable PTP CKOUT. (For output pin selection see GPIO_BIT_CFG.) */
+	uint64_t ckout_en                     : 1;  /**< Enable PTP CKOUT. (For output pin selection see GPIO_BIT_CFG().) */
 	uint64_t evcnt_in                     : 6;  /**< Source for event counter input:
                                                          Enumerated by MIO_PTP_EXT_SEL_E. */
-	uint64_t evcnt_edge                   : 1;  /**< Event counter input edge: 0 = falling edge, 1 = rising edge */
+	uint64_t evcnt_edge                   : 1;  /**< Event counter input edge: 0 = falling edge, 1 = rising edge. */
 	uint64_t evcnt_en                     : 1;  /**< Enable event counter. */
 	uint64_t tstmp_in                     : 6;  /**< Source for timestamp input:
                                                          Enumerated by MIO_PTP_EXT_SEL_E. */
-	uint64_t tstmp_edge                   : 1;  /**< External timestamp input edge: 0 = falling edge, 1 = rising edge */
+	uint64_t tstmp_edge                   : 1;  /**< External timestamp input edge: 0 = falling edge, 1 = rising edge. */
 	uint64_t tstmp_en                     : 1;  /**< Enable external timestamp. */
-	uint64_t ext_clk_in                   : 6;  /**< Source for external clock when EXT_CLK_EN is set:
+	uint64_t ext_clk_in                   : 6;  /**< Source for external clock when [EXT_CLK_EN] is set:
                                                          Enumerated by MIO_PTP_EXT_SEL_E. */
 	uint64_t ext_clk_en                   : 1;  /**< Use external clock for PTP clock. */
 	uint64_t ptp_en                       : 1;  /**< Enable PTP module. */
@@ -8174,8 +8213,10 @@ union cvmx_mio_ptp_dpll_err_thresh {
 	uint64_t u64;
 	struct cvmx_mio_ptp_dpll_err_thresh_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t max                          : 32; /**< Highest acceptable value of MIO_PTP_DPLL_ERR_INT[N_SCLK] without asserting DPLL_INT interrupt. */
-	uint64_t min                          : 32; /**< Lowest acceptable value of MIO_PTP_DPLL_ERR_INT[N_SCLK] without asserting DPLL_INT interrupt. */
+	uint64_t max                          : 32; /**< Highest acceptable value of MIO_PTP_DPLL_ERR_INT[N_SCLK] without asserting
+                                                         MIO_PTP_INT[DPLL_INT] interrupt. */
+	uint64_t min                          : 32; /**< Lowest acceptable value of MIO_PTP_DPLL_ERR_INT[N_SCLK] without asserting
+                                                         MIO_PTP_INT[DPLL_INT] interrupt. */
 #else
 	uint64_t min                          : 32;
 	uint64_t max                          : 32;
@@ -10118,7 +10159,7 @@ union cvmx_mio_twsx_sw_twsi {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t v                            : 1;  /**< Valid bit. Set on a write operation (should always be written with a 1). Cleared when a
                                                          TWSI master-mode operation completes, a TWSI configuration register access completes, or
-                                                         when the TWSI device reads the register if SLONLY = 1. */
+                                                         when the TWSI device reads the register if [SLONLY] = 1. */
 	uint64_t slonly                       : 1;  /**< Slave-only mode.
                                                          When this bit is set, no operations are initiated with a write operation. Only the D field
                                                          is updated in this case.
@@ -10126,7 +10167,7 @@ union cvmx_mio_twsx_sw_twsi {
                                                          TWSI configuration register access. */
 	uint64_t eia                          : 1;  /**< Extended internal address. Sends an additional internal address byte (the MSB of IA is
                                                          from MIO_TWS()_SW_TWSI_EXT[IA]). */
-	uint64_t op                           : 4;  /**< Opcode field. When the register is written with SLONLY = 0, this field initiates one of
+	uint64_t op                           : 4;  /**< Opcode field. When the register is written with [SLONLY] = 0, this field initiates one of
                                                          the following read or write operations:
                                                          0x0 = 7-bit byte master-mode operation.
                                                          0x1 = 7-bit byte combined-read master-mode operation, 7-bit byte write-with-IA master-mode
@@ -10135,17 +10176,17 @@ union cvmx_mio_twsx_sw_twsi {
                                                          0x3 = 10-bit byte combined-read master-mode operation, 10-bit byte write-with-IA master-
                                                          mode operation.
                                                          0x4 = TWSI master-clock register, TWSI_CLK in TWSI Master Clock Register.
-                                                         0x6 = See EOP_IA field.
+                                                         0x6 = See [EOP_IA] field.
                                                          0x8 = 7-bit 4-byte master-mode operation.
                                                          0x9 = 7-bit 4-byte combined-read master-mode operation, 7-bit 4-byte write-with-IA master-
                                                          mode operation.
                                                          0xA = 10-bit 4-byte master-mode operation.
                                                          0xB = 10-bit 4-byte combined-read master-mode operation, 10-bit 4-byte write-with-IA
                                                          master-mode operation. */
-	uint64_t r                            : 1;  /**< Read bit or result. If this bit is set on a CSR write when SLONLY = 0, the operation is a
-                                                         read operation (if clear, it is a write operation).
-                                                         On a CSR read, this bit returns the result indication for the most recent master-mode
-                                                         operation, 1 = success, 0 = failure. */
+	uint64_t r                            : 1;  /**< Read bit or result. If this bit is set on a CSR write when [SLONLY] = 0, the
+                                                         operation is a read operation (if clear, it is a write operation).
+                                                         On a CSR read, this bit returns the result indication for the most recent
+                                                         master-mode operation, 1 = success, 0 = failure. */
 	uint64_t sovr                         : 1;  /**< Size override. If this bit is set, use the SIZE field to determine the master-mode
                                                          operation size rather than what OP specifies. For operations greater than four bytes, the
                                                          additional data is contained in MIO_TWS()_SW_TWSI_EXT[DATA]. */
@@ -10157,8 +10198,8 @@ union cvmx_mio_twsx_sw_twsi {
                                                          Note that when mastering a 7-bit OP, ADDR<6:0> should not take any of the values 0x78,
                                                          0x79, 0x7A nor 0x7B. (These 7-bit addresses are reserved to extend to 10-bit addressing). */
 	uint64_t ia                           : 5;  /**< Internal Address. Used when launching a combined master-mode operation. The lower 3
-                                                         address bits are contained in EOP_IA. */
-	uint64_t eop_ia                       : 3;  /**< Extra opcode, used when OP<3:0> = 0x6 and SLONLY = 0.
+                                                         address bits are contained in [EOP_IA]. */
+	uint64_t eop_ia                       : 3;  /**< Extra opcode, used when OP<3:0> = 0x6 and [SLONLY] = 0.
                                                          0x0 = TWSI slave address register (TWSI_SLAVE_ADD).
                                                          0x1 = TWSI data register (TWSI_DATA).
                                                          0x2 = TWSI control register (TWSI_CTL).
@@ -10170,9 +10211,9 @@ union cvmx_mio_twsx_sw_twsi {
                                                          operation. */
 	uint64_t d                            : 32; /**< Data field.
                                                          Used on a write operation when:
-                                                         * Initiating a master-mode write operation (SLONLY = 0).
-                                                         * Writing a TWSI configuration register (SLONLY = 0).
-                                                         * A slave-mode write operation (SLONLY = 1).
+                                                         * Initiating a master-mode write operation ([SLONLY] = 0).
+                                                         * Writing a TWSI configuration register ([SLONLY] = 0).
+                                                         * A slave-mode write operation ([SLONLY] = 1).
                                                          The read value is updated by:
                                                          * A write operation to this register.
                                                          * Master-mode completion (contains error code).
@@ -10708,7 +10749,7 @@ union cvmx_mio_uartx_iir {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
 	uint64_t fen                          : 2;  /**< FIFO-enabled.
-                                                         0x0 = FIFOs disabled, 0x1 = reserved, 0x2 = reserved, 0x3 = FIFOs enabled */
+                                                         0x0 = FIFOs disabled, 0x1 = reserved, 0x2 = reserved, 0x3 = FIFOs enabled. */
 	uint64_t reserved_4_5                 : 2;
 	cvmx_uart_iid_t iid                   : 4;  /**< Interrupt ID. Identifies the highest priority pending interrupt. Assertion of any
                                                          interrupt throws MIO_UART_INTSN_E::MIO_UART(0..1)_IID. The interrupt-source decoding,
diff --git a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
index 8fad590..e962e98 100644
--- a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
@@ -63,6 +63,7 @@ static inline uint64_t CVMX_MIXX_BIST(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_BIST(%lu) is invalid on this chip\n", offset);
@@ -82,6 +83,7 @@ static inline uint64_t CVMX_MIXX_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_CTL(%lu) is invalid on this chip\n", offset);
@@ -117,6 +119,7 @@ static inline uint64_t CVMX_MIXX_IRCNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRCNT(%lu) is invalid on this chip\n", offset);
@@ -136,6 +139,7 @@ static inline uint64_t CVMX_MIXX_IRHWM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRHWM(%lu) is invalid on this chip\n", offset);
@@ -155,6 +159,7 @@ static inline uint64_t CVMX_MIXX_IRING1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRING1(%lu) is invalid on this chip\n", offset);
@@ -174,6 +179,7 @@ static inline uint64_t CVMX_MIXX_IRING2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_IRING2(%lu) is invalid on this chip\n", offset);
@@ -193,6 +199,7 @@ static inline uint64_t CVMX_MIXX_ISR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ISR(%lu) is invalid on this chip\n", offset);
@@ -225,6 +232,7 @@ static inline uint64_t CVMX_MIXX_ORCNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORCNT(%lu) is invalid on this chip\n", offset);
@@ -244,6 +252,7 @@ static inline uint64_t CVMX_MIXX_ORHWM(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORHWM(%lu) is invalid on this chip\n", offset);
@@ -263,6 +272,7 @@ static inline uint64_t CVMX_MIXX_ORING1(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORING1(%lu) is invalid on this chip\n", offset);
@@ -282,6 +292,7 @@ static inline uint64_t CVMX_MIXX_ORING2(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_ORING2(%lu) is invalid on this chip\n", offset);
@@ -301,6 +312,7 @@ static inline uint64_t CVMX_MIXX_REMCNT(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_REMCNT(%lu) is invalid on this chip\n", offset);
@@ -318,6 +330,7 @@ static inline uint64_t CVMX_MIXX_TSCTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_TSCTL(%lu) is invalid on this chip\n", offset);
@@ -335,6 +348,7 @@ static inline uint64_t CVMX_MIXX_TSTAMP(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_MIXX_TSTAMP(%lu) is invalid on this chip\n", offset);
diff --git a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
index 891deef..c2a479f 100644
--- a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_MPI_CFG CVMX_MPI_CFG_FUNC()
 static inline uint64_t CVMX_MPI_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001000ull);
 }
@@ -74,6 +74,7 @@ static inline uint64_t CVMX_MPI_DATX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 8))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 8))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_MPI_DATX(%lu) is invalid on this chip\n", offset);
@@ -86,7 +87,7 @@ static inline uint64_t CVMX_MPI_DATX(unsigned long offset)
 #define CVMX_MPI_STS CVMX_MPI_STS_FUNC()
 static inline uint64_t CVMX_MPI_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001008ull);
 }
@@ -108,7 +109,7 @@ static inline uint64_t CVMX_MPI_STS_W1S_FUNC(void)
 #define CVMX_MPI_TX CVMX_MPI_TX_FUNC()
 static inline uint64_t CVMX_MPI_TX_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN30XX) || OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN50XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_MPI_TX not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001010ull);
 }
@@ -119,7 +120,7 @@ static inline uint64_t CVMX_MPI_TX_FUNC(void)
 #define CVMX_MPI_WIDE_DAT CVMX_MPI_WIDE_DAT_FUNC()
 static inline uint64_t CVMX_MPI_WIDE_DAT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_MPI_WIDE_DAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001070000001040ull);
 }
@@ -571,8 +572,8 @@ union cvmx_mpi_cfg {
                                                          0 = UART0_DTR_L/SPI_DO, UART0_DCD_L/SPI_DI, UART1_CTS_L/SPI_CS2_L, UART1_RTS_L/SPI_CS3_L
                                                          pins are UART pins.
                                                          1 = UART0_DTR_L/SPI_DO and UART0_DCD_L/SPI_DI pins are MPI/SPI pins.
-                                                         UART1_CTS_L/SPI_CS2_L is an MPI/SPI pin if CSENA2 = 1
-                                                         UART1_RTS_L/SPI_CS3_L is an MPI/SPI pin if CSENA3 = 1 */
+                                                         UART1_CTS_L/SPI_CS2_L is an MPI/SPI pin if CSENA2 = 1.
+                                                         UART1_RTS_L/SPI_CS3_L is an MPI/SPI pin if CSENA3 = 1. */
 #else
 	uint64_t enable                       : 1;
 	uint64_t idlelo                       : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
index 5905036..b490ea7 100644
--- a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
@@ -58,6 +58,7 @@ static inline uint64_t CVMX_OCLAX_BIST_RESULT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_BIST_RESULT(%lu) is invalid on this chip\n", offset);
@@ -72,6 +73,7 @@ static inline uint64_t CVMX_OCLAX_CDHX_CTL(unsigned long offset, unsigned long b
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCLAX_CDHX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -86,6 +88,7 @@ static inline uint64_t CVMX_OCLAX_CONST(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_CONST(%lu) is invalid on this chip\n", offset);
@@ -100,6 +103,7 @@ static inline uint64_t CVMX_OCLAX_DATX(unsigned long offset, unsigned long block
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 8191)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 8191)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 8191)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 8191)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 8191)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCLAX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -114,6 +118,7 @@ static inline uint64_t CVMX_OCLAX_DAT_POP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_DAT_POP(%lu) is invalid on this chip\n", offset);
@@ -142,6 +147,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_DEPTH(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_DEPTH(%lu) is invalid on this chip\n", offset);
@@ -156,6 +162,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_LIMIT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_LIMIT(%lu) is invalid on this chip\n", offset);
@@ -170,6 +177,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_TAIL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_TAIL(%lu) is invalid on this chip\n", offset);
@@ -184,6 +192,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_TRIG(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_TRIG(%lu) is invalid on this chip\n", offset);
@@ -198,6 +207,7 @@ static inline uint64_t CVMX_OCLAX_FIFO_WRAP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_FIFO_WRAP(%lu) is invalid on this chip\n", offset);
@@ -212,6 +222,7 @@ static inline uint64_t CVMX_OCLAX_FSMX_ANDX_IX(unsigned long a, unsigned long b,
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((a <= 4)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)) && ((d <= 1))))))
 		cvmx_warn("CVMX_OCLAX_FSMX_ANDX_IX(%lu,%lu,%lu,%lu) is invalid on this chip\n", a, b, c, d);
@@ -226,6 +237,7 @@ static inline uint64_t CVMX_OCLAX_FSMX_ORX(unsigned long a, unsigned long b, uns
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((a <= 4)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15))))))
 		cvmx_warn("CVMX_OCLAX_FSMX_ORX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
@@ -240,6 +252,7 @@ static inline uint64_t CVMX_OCLAX_FSMX_STATEX(unsigned long a, unsigned long b,
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((a <= 4)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 1)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((a <= 2)) && ((b <= 1)) && ((c <= 15))))))
 		cvmx_warn("CVMX_OCLAX_FSMX_STATEX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
@@ -254,6 +267,7 @@ static inline uint64_t CVMX_OCLAX_GEN_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_GEN_CTL(%lu) is invalid on this chip\n", offset);
@@ -268,6 +282,7 @@ static inline uint64_t CVMX_OCLAX_MATX_COUNT(unsigned long offset, unsigned long
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCLAX_MATX_COUNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -282,6 +297,7 @@ static inline uint64_t CVMX_OCLAX_MATX_CTL(unsigned long offset, unsigned long b
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCLAX_MATX_CTL(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -296,6 +312,7 @@ static inline uint64_t CVMX_OCLAX_MATX_MASKX(unsigned long a, unsigned long b, u
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 3)) && ((c <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((a <= 4)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((a <= 2)) && ((b <= 3)) && ((c <= 1))))))
 		cvmx_warn("CVMX_OCLAX_MATX_MASKX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
@@ -310,6 +327,7 @@ static inline uint64_t CVMX_OCLAX_MATX_THRESH(unsigned long offset, unsigned lon
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 3)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCLAX_MATX_THRESH(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -324,6 +342,7 @@ static inline uint64_t CVMX_OCLAX_MATX_VALUEX(unsigned long a, unsigned long b,
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((a == 0)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 2)) && ((b <= 3)) && ((c <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((a <= 4)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 4)) && ((b <= 3)) && ((c <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((a <= 2)) && ((b <= 3)) && ((c <= 1))))))
 		cvmx_warn("CVMX_OCLAX_MATX_VALUEX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
@@ -338,6 +357,7 @@ static inline uint64_t CVMX_OCLAX_RAWX(unsigned long offset, unsigned long block
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCLAX_RAWX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -352,6 +372,7 @@ static inline uint64_t CVMX_OCLAX_SFT_RST(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_SFT_RST(%lu) is invalid on this chip\n", offset);
@@ -366,6 +387,7 @@ static inline uint64_t CVMX_OCLAX_STACK_BASE(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_STACK_BASE(%lu) is invalid on this chip\n", offset);
@@ -380,6 +402,7 @@ static inline uint64_t CVMX_OCLAX_STACK_CUR(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_STACK_CUR(%lu) is invalid on this chip\n", offset);
@@ -394,6 +417,7 @@ static inline uint64_t CVMX_OCLAX_STACK_STORE_CNT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_STACK_STORE_CNT(%lu) is invalid on this chip\n", offset);
@@ -408,6 +432,7 @@ static inline uint64_t CVMX_OCLAX_STACK_TOP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_STACK_TOP(%lu) is invalid on this chip\n", offset);
@@ -422,6 +447,7 @@ static inline uint64_t CVMX_OCLAX_STACK_WRAP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_STACK_WRAP(%lu) is invalid on this chip\n", offset);
@@ -436,6 +462,7 @@ static inline uint64_t CVMX_OCLAX_STAGEX(unsigned long offset, unsigned long blo
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 71)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 71)) && ((block_id <= 2)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 71)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 71)) && ((block_id <= 4)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 71)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCLAX_STAGEX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -450,6 +477,7 @@ static inline uint64_t CVMX_OCLAX_STATE_INT(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_STATE_INT(%lu) is invalid on this chip\n", offset);
@@ -464,6 +492,7 @@ static inline uint64_t CVMX_OCLAX_STATE_SET(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_STATE_SET(%lu) is invalid on this chip\n", offset);
@@ -478,6 +507,7 @@ static inline uint64_t CVMX_OCLAX_TIME(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCLAX_TIME(%lu) is invalid on this chip\n", offset);
@@ -647,7 +677,7 @@ union cvmx_oclax_eco {
 	struct cvmx_oclax_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 32; /**< N/A */
 #else
 	uint64_t eco_rw                       : 32;
 	uint64_t reserved_32_63               : 32;
@@ -1131,8 +1161,7 @@ union cvmx_oclax_stack_base {
 	struct cvmx_oclax_stack_base_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
-	uint64_t ptr                          : 35; /**< Memory address for base of overflow stack.
-                                                         INTERNAL: This address must be on the local node in a CCPI system. */
+	uint64_t ptr                          : 35; /**< Memory address for base of overflow stack. */
 	uint64_t reserved_0_6                 : 7;
 #else
 	uint64_t reserved_0_6                 : 7;
@@ -1158,8 +1187,7 @@ union cvmx_oclax_stack_cur {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
 	uint64_t ptr                          : 35; /**< Next address to write for overflow stack.
-                                                         During initialization this must be between OCLA()_STACK_BASE and OCLA()_STACK_TOP.
-                                                         INTERNAL: This address must be on the local node in a CCPI system. */
+                                                         During initialization this must be between OCLA()_STACK_BASE and OCLA()_STACK_TOP. */
 	uint64_t reserved_0_6                 : 7;
 #else
 	uint64_t reserved_0_6                 : 7;
@@ -1207,8 +1235,7 @@ union cvmx_oclax_stack_top {
 	struct cvmx_oclax_stack_top_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
-	uint64_t ptr                          : 35; /**< Memory address for top of overflow stack plus one.
-                                                         INTERNAL: This address must be on the local node in a CCPI system. */
+	uint64_t ptr                          : 35; /**< Memory address for top of overflow stack plus one. */
 	uint64_t reserved_0_6                 : 7;
 #else
 	uint64_t reserved_0_6                 : 7;
diff --git a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
index 0b6d169..54f09d1 100644
--- a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_OCX_COM_BIST_STATUS CVMX_OCX_COM_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_OCX_COM_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OCX_COM_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800110000F0ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_OCX_COM_BIST_STATUS_FUNC(void)
 #define CVMX_OCX_COM_DUAL_SORT CVMX_OCX_COM_DUAL_SORT_FUNC()
 static inline uint64_t CVMX_OCX_COM_DUAL_SORT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OCX_COM_DUAL_SORT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180011000008ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_OCX_COM_DUAL_SORT_FUNC(void)
 #define CVMX_OCX_COM_INT CVMX_OCX_COM_INT_FUNC()
 static inline uint64_t CVMX_OCX_COM_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OCX_COM_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180011000100ull);
 }
@@ -89,6 +89,7 @@ static inline uint64_t CVMX_OCX_COM_INT_FUNC(void)
 static inline uint64_t CVMX_OCX_COM_LINKX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_COM_LINKX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011000020ull) + ((offset) & 3) * 8;
@@ -100,6 +101,7 @@ static inline uint64_t CVMX_OCX_COM_LINKX_CTL(unsigned long offset)
 static inline uint64_t CVMX_OCX_COM_LINKX_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_COM_LINKX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011000120ull) + ((offset) & 3) * 8;
@@ -111,7 +113,7 @@ static inline uint64_t CVMX_OCX_COM_LINKX_INT(unsigned long offset)
 #define CVMX_OCX_COM_LINK_TIMER CVMX_OCX_COM_LINK_TIMER_FUNC()
 static inline uint64_t CVMX_OCX_COM_LINK_TIMER_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OCX_COM_LINK_TIMER not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180011000010ull);
 }
@@ -122,7 +124,7 @@ static inline uint64_t CVMX_OCX_COM_LINK_TIMER_FUNC(void)
 #define CVMX_OCX_COM_NODE CVMX_OCX_COM_NODE_FUNC()
 static inline uint64_t CVMX_OCX_COM_NODE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OCX_COM_NODE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180011000000ull);
 }
@@ -133,6 +135,7 @@ static inline uint64_t CVMX_OCX_COM_NODE_FUNC(void)
 static inline uint64_t CVMX_OCX_DLLX_STATUS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_OCX_DLLX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011000080ull) + ((offset) & 1) * 8;
@@ -144,6 +147,7 @@ static inline uint64_t CVMX_OCX_DLLX_STATUS(unsigned long offset)
 static inline uint64_t CVMX_OCX_FRCX_STAT0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_OCX_FRCX_STAT0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118001100FA00ull) + ((offset) & 7) * 8;
@@ -155,6 +159,7 @@ static inline uint64_t CVMX_OCX_FRCX_STAT0(unsigned long offset)
 static inline uint64_t CVMX_OCX_FRCX_STAT1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_OCX_FRCX_STAT1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118001100FA80ull) + ((offset) & 7) * 8;
@@ -166,6 +171,7 @@ static inline uint64_t CVMX_OCX_FRCX_STAT1(unsigned long offset)
 static inline uint64_t CVMX_OCX_FRCX_STAT2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_OCX_FRCX_STAT2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118001100FB00ull) + ((offset) & 7) * 8;
@@ -177,6 +183,7 @@ static inline uint64_t CVMX_OCX_FRCX_STAT2(unsigned long offset)
 static inline uint64_t CVMX_OCX_FRCX_STAT3(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_OCX_FRCX_STAT3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118001100FB80ull) + ((offset) & 7) * 8;
@@ -188,6 +195,7 @@ static inline uint64_t CVMX_OCX_FRCX_STAT3(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_BAD_CNT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_BAD_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008028ull) + ((offset) & 31) * 256;
@@ -199,6 +207,7 @@ static inline uint64_t CVMX_OCX_LNEX_BAD_CNT(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008000ull) + ((offset) & 31) * 256;
@@ -210,6 +219,7 @@ static inline uint64_t CVMX_OCX_LNEX_CFG(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_INT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008018ull) + ((offset) & 31) * 256;
@@ -221,6 +231,7 @@ static inline uint64_t CVMX_OCX_LNEX_INT(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_INT_EN(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_INT_EN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008020ull) + ((offset) & 31) * 256;
@@ -232,6 +243,7 @@ static inline uint64_t CVMX_OCX_LNEX_INT_EN(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT00(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT00(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008040ull) + ((offset) & 31) * 256;
@@ -243,6 +255,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT00(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT01(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT01(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008048ull) + ((offset) & 31) * 256;
@@ -254,6 +267,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT01(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT02(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT02(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008050ull) + ((offset) & 31) * 256;
@@ -265,6 +279,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT02(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT03(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT03(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008058ull) + ((offset) & 31) * 256;
@@ -276,6 +291,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT03(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT04(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT04(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008060ull) + ((offset) & 31) * 256;
@@ -287,6 +303,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT04(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT05(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT05(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008068ull) + ((offset) & 31) * 256;
@@ -298,6 +315,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT05(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT06(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT06(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008070ull) + ((offset) & 31) * 256;
@@ -309,6 +327,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT06(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT07(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT07(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008078ull) + ((offset) & 31) * 256;
@@ -320,6 +339,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT07(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT08(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT08(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008080ull) + ((offset) & 31) * 256;
@@ -331,6 +351,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT08(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT09(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT09(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008088ull) + ((offset) & 31) * 256;
@@ -342,6 +363,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT09(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT10(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT10(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008090ull) + ((offset) & 31) * 256;
@@ -353,6 +375,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT10(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT11(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT11(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008098ull) + ((offset) & 31) * 256;
@@ -364,6 +387,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT11(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT12(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT12(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800110080A0ull) + ((offset) & 31) * 256;
@@ -375,6 +399,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT12(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT13(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT13(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800110080A8ull) + ((offset) & 31) * 256;
@@ -386,6 +411,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT13(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STAT14(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STAT14(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800110080B0ull) + ((offset) & 31) * 256;
@@ -397,6 +423,7 @@ static inline uint64_t CVMX_OCX_LNEX_STAT14(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STATUS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008008ull) + ((offset) & 31) * 256;
@@ -408,6 +435,7 @@ static inline uint64_t CVMX_OCX_LNEX_STATUS(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_STS_MSG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_STS_MSG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011008010ull) + ((offset) & 31) * 256;
@@ -419,6 +447,7 @@ static inline uint64_t CVMX_OCX_LNEX_STS_MSG(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_TRN_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_TRN_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800110080D0ull) + ((offset) & 31) * 256;
@@ -430,6 +459,7 @@ static inline uint64_t CVMX_OCX_LNEX_TRN_CTL(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_TRN_LD(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_TRN_LD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800110080C0ull) + ((offset) & 31) * 256;
@@ -441,6 +471,7 @@ static inline uint64_t CVMX_OCX_LNEX_TRN_LD(unsigned long offset)
 static inline uint64_t CVMX_OCX_LNEX_TRN_LP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 23))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 23)))))
 		cvmx_warn("CVMX_OCX_LNEX_TRN_LP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800110080C8ull) + ((offset) & 31) * 256;
@@ -452,7 +483,7 @@ static inline uint64_t CVMX_OCX_LNEX_TRN_LP(unsigned long offset)
 #define CVMX_OCX_LNE_DBG CVMX_OCX_LNE_DBG_FUNC()
 static inline uint64_t CVMX_OCX_LNE_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OCX_LNE_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x000118001100FF00ull);
 }
@@ -463,6 +494,7 @@ static inline uint64_t CVMX_OCX_LNE_DBG_FUNC(void)
 static inline uint64_t CVMX_OCX_LNKX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_LNKX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118001100F900ull) + ((offset) & 3) * 8;
@@ -474,7 +506,7 @@ static inline uint64_t CVMX_OCX_LNKX_CFG(unsigned long offset)
 #define CVMX_OCX_PP_CMD CVMX_OCX_PP_CMD_FUNC()
 static inline uint64_t CVMX_OCX_PP_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OCX_PP_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800110000C8ull);
 }
@@ -485,7 +517,7 @@ static inline uint64_t CVMX_OCX_PP_CMD_FUNC(void)
 #define CVMX_OCX_PP_RD_DATA CVMX_OCX_PP_RD_DATA_FUNC()
 static inline uint64_t CVMX_OCX_PP_RD_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OCX_PP_RD_DATA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800110000D0ull);
 }
@@ -496,7 +528,7 @@ static inline uint64_t CVMX_OCX_PP_RD_DATA_FUNC(void)
 #define CVMX_OCX_PP_WR_DATA CVMX_OCX_PP_WR_DATA_FUNC()
 static inline uint64_t CVMX_OCX_PP_WR_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OCX_PP_WR_DATA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800110000C0ull);
 }
@@ -507,6 +539,7 @@ static inline uint64_t CVMX_OCX_PP_WR_DATA_FUNC(void)
 static inline uint64_t CVMX_OCX_QLMX_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 5)))))
 		cvmx_warn("CVMX_OCX_QLMX_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000118001100F800ull) + ((offset) & 7) * 8;
@@ -518,6 +551,7 @@ static inline uint64_t CVMX_OCX_QLMX_CFG(unsigned long offset)
 static inline uint64_t CVMX_OCX_RLKX_ALIGN(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_RLKX_ALIGN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011018060ull) + ((offset) & 3) * 8192;
@@ -529,6 +563,7 @@ static inline uint64_t CVMX_OCX_RLKX_ALIGN(unsigned long offset)
 static inline uint64_t CVMX_OCX_RLKX_BLK_ERR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_RLKX_BLK_ERR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011018050ull) + ((offset) & 3) * 8192;
@@ -540,6 +575,7 @@ static inline uint64_t CVMX_OCX_RLKX_BLK_ERR(unsigned long offset)
 static inline uint64_t CVMX_OCX_RLKX_ECC_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_RLKX_ECC_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011018018ull) + ((offset) & 3) * 8192;
@@ -551,6 +587,7 @@ static inline uint64_t CVMX_OCX_RLKX_ECC_CTL(unsigned long offset)
 static inline uint64_t CVMX_OCX_RLKX_ENABLES(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_RLKX_ENABLES(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011018000ull) + ((offset) & 3) * 8192;
@@ -562,6 +599,7 @@ static inline uint64_t CVMX_OCX_RLKX_ENABLES(unsigned long offset)
 static inline uint64_t CVMX_OCX_RLKX_FIFOX_CNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 13)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 13)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_RLKX_FIFOX_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011018100ull) + (((offset) & 15) + ((block_id) & 3) * 0x400ull) * 8;
@@ -573,6 +611,7 @@ static inline uint64_t CVMX_OCX_RLKX_FIFOX_CNT(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_OCX_RLKX_LNK_DATA(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_RLKX_LNK_DATA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011018028ull) + ((offset) & 3) * 8192;
@@ -584,6 +623,7 @@ static inline uint64_t CVMX_OCX_RLKX_LNK_DATA(unsigned long offset)
 static inline uint64_t CVMX_OCX_RLKX_MCD_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_RLKX_MCD_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011018020ull) + ((offset) & 3) * 8192;
@@ -606,6 +646,7 @@ static inline uint64_t CVMX_OCX_STRAP_FUNC(void)
 static inline uint64_t CVMX_OCX_TLKX_BIST_STATUS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_TLKX_BIST_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011010008ull) + ((offset) & 3) * 8192;
@@ -628,6 +669,7 @@ static inline uint64_t CVMX_OCX_TLKX_BYP_CTL(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_ECC_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_TLKX_ECC_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011010018ull) + ((offset) & 3) * 8192;
@@ -639,6 +681,7 @@ static inline uint64_t CVMX_OCX_TLKX_ECC_CTL(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_FIFOX_CNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 13)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 13)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_TLKX_FIFOX_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011010100ull) + (((offset) & 15) + ((block_id) & 3) * 0x400ull) * 8;
@@ -650,6 +693,7 @@ static inline uint64_t CVMX_OCX_TLKX_FIFOX_CNT(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_OCX_TLKX_LNK_DATA(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_TLKX_LNK_DATA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011010028ull) + ((offset) & 3) * 8192;
@@ -661,6 +705,7 @@ static inline uint64_t CVMX_OCX_TLKX_LNK_DATA(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_LNK_VCX_CNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 13)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 13)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_TLKX_LNK_VCX_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011010200ull) + (((offset) & 15) + ((block_id) & 3) * 0x400ull) * 8;
@@ -672,6 +717,7 @@ static inline uint64_t CVMX_OCX_TLKX_LNK_VCX_CNT(unsigned long offset, unsigned
 static inline uint64_t CVMX_OCX_TLKX_MCD_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_TLKX_MCD_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011010020ull) + ((offset) & 3) * 8192;
@@ -683,6 +729,7 @@ static inline uint64_t CVMX_OCX_TLKX_MCD_CTL(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_RTN_VCX_CNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 13)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 13)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_TLKX_RTN_VCX_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011010300ull) + (((offset) & 15) + ((block_id) & 3) * 0x400ull) * 8;
@@ -694,6 +741,7 @@ static inline uint64_t CVMX_OCX_TLKX_RTN_VCX_CNT(unsigned long offset, unsigned
 static inline uint64_t CVMX_OCX_TLKX_STATUS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_TLKX_STATUS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011010000ull) + ((offset) & 3) * 8192;
@@ -705,6 +753,7 @@ static inline uint64_t CVMX_OCX_TLKX_STATUS(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_STAT_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_TLKX_STAT_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011010040ull) + ((offset) & 3) * 8192;
@@ -716,6 +765,7 @@ static inline uint64_t CVMX_OCX_TLKX_STAT_CTL(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_STAT_DATA_CNT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_TLKX_STAT_DATA_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011010408ull) + ((offset) & 3) * 8192;
@@ -727,6 +777,7 @@ static inline uint64_t CVMX_OCX_TLKX_STAT_DATA_CNT(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_STAT_ERR_CNT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_TLKX_STAT_ERR_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011010420ull) + ((offset) & 3) * 8192;
@@ -738,6 +789,7 @@ static inline uint64_t CVMX_OCX_TLKX_STAT_ERR_CNT(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_STAT_IDLE_CNT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_TLKX_STAT_IDLE_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011010400ull) + ((offset) & 3) * 8192;
@@ -749,6 +801,7 @@ static inline uint64_t CVMX_OCX_TLKX_STAT_IDLE_CNT(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_STAT_MATCHX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_TLKX_STAT_MATCHX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011010080ull) + (((offset) & 3) + ((block_id) & 3) * 0x400ull) * 8;
@@ -760,6 +813,7 @@ static inline uint64_t CVMX_OCX_TLKX_STAT_MATCHX(unsigned long offset, unsigned
 static inline uint64_t CVMX_OCX_TLKX_STAT_MATX_CNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_TLKX_STAT_MATX_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011010440ull) + (((offset) & 3) + ((block_id) & 3) * 0x400ull) * 8;
@@ -771,6 +825,7 @@ static inline uint64_t CVMX_OCX_TLKX_STAT_MATX_CNT(unsigned long offset, unsigne
 static inline uint64_t CVMX_OCX_TLKX_STAT_RETRY_CNT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_TLKX_STAT_RETRY_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011010418ull) + ((offset) & 3) * 8192;
@@ -782,6 +837,7 @@ static inline uint64_t CVMX_OCX_TLKX_STAT_RETRY_CNT(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_STAT_SYNC_CNT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_OCX_TLKX_STAT_SYNC_CNT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180011010410ull) + ((offset) & 3) * 8192;
@@ -793,6 +849,7 @@ static inline uint64_t CVMX_OCX_TLKX_STAT_SYNC_CNT(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_STAT_VCX_CMD(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 5)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 5)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_TLKX_STAT_VCX_CMD(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011010480ull) + (((offset) & 7) + ((block_id) & 3) * 0x400ull) * 8;
@@ -804,6 +861,7 @@ static inline uint64_t CVMX_OCX_TLKX_STAT_VCX_CMD(unsigned long offset, unsigned
 static inline uint64_t CVMX_OCX_TLKX_STAT_VCX_CON(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 13)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 13)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_TLKX_STAT_VCX_CON(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011010580ull) + (((offset) & 15) + ((block_id) & 3) * 0x400ull) * 8;
@@ -815,6 +873,7 @@ static inline uint64_t CVMX_OCX_TLKX_STAT_VCX_CON(unsigned long offset, unsigned
 static inline uint64_t CVMX_OCX_TLKX_STAT_VCX_PKT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 13)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 13)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_TLKX_STAT_VCX_PKT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011010500ull) + (((offset) & 15) + ((block_id) & 3) * 0x400ull) * 8;
@@ -826,7 +885,7 @@ static inline uint64_t CVMX_OCX_TLKX_STAT_VCX_PKT(unsigned long offset, unsigned
 #define CVMX_OCX_WIN_CMD CVMX_OCX_WIN_CMD_FUNC()
 static inline uint64_t CVMX_OCX_WIN_CMD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OCX_WIN_CMD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180011000048ull);
 }
@@ -837,7 +896,7 @@ static inline uint64_t CVMX_OCX_WIN_CMD_FUNC(void)
 #define CVMX_OCX_WIN_RD_DATA CVMX_OCX_WIN_RD_DATA_FUNC()
 static inline uint64_t CVMX_OCX_WIN_RD_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OCX_WIN_RD_DATA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180011000050ull);
 }
@@ -848,7 +907,7 @@ static inline uint64_t CVMX_OCX_WIN_RD_DATA_FUNC(void)
 #define CVMX_OCX_WIN_TIMER CVMX_OCX_WIN_TIMER_FUNC()
 static inline uint64_t CVMX_OCX_WIN_TIMER_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OCX_WIN_TIMER not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180011000058ull);
 }
@@ -859,7 +918,7 @@ static inline uint64_t CVMX_OCX_WIN_TIMER_FUNC(void)
 #define CVMX_OCX_WIN_WR_DATA CVMX_OCX_WIN_WR_DATA_FUNC()
 static inline uint64_t CVMX_OCX_WIN_WR_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OCX_WIN_WR_DATA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180011000040ull);
 }
@@ -879,26 +938,7 @@ union cvmx_ocx_com_bist_status {
 	struct cvmx_ocx_com_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t status                       : 36; /**< BIST status.
-                                                         INTERNAL:
-                                                         <35:34> = Link 2 VC4/VC2.
-                                                         <33:32> = Link 2 VC10/VC8/VC6. (Reserved in pass 2)
-                                                         <31:30> = Link 1 VC4/VC2.
-                                                         <29:28> = Link 1 VC10/VC8/VC6. (Reserved in pass 2)
-                                                         <27:26> = Link 0 VC4/VC2.
-                                                         <25:24> = Link 0 VC10/VC8/VC6. (Reserved in pass 2)
-                                                         <23:22> = Link 2 VC12.
-                                                         <21:20> = Link 2 VC1/VC0.
-                                                         <19:18> = Link 2 VC5/VC3.
-                                                         <17:16> = Link 2 VC11/VC9/VC7. (Reserved in pass 2)
-                                                         <15:14> = Link 1 VC12.
-                                                         <13:12> = Link 1 VC1/VC0.
-                                                         <11:10> = Link 1 VC5/VC3.
-                                                         <9:8>   = Link 1 VC11/VC9/VC7. (Reserved in pass 2)
-                                                         <7:6>   = Link 0 VC12.
-                                                         <5:4>   = Link 0 VC1/VC0.
-                                                         <3:2>   = Link 0 VC5/VC3.
-                                                         <1:0>   = Link 0 VC11/VC9/VC7. (Reserved in pass 2) */
+	uint64_t status                       : 36; /**< BIST status. */
 #else
 	uint64_t status                       : 36;
 	uint64_t reserved_36_63               : 28;
@@ -1002,12 +1042,8 @@ union cvmx_ocx_com_linkx_ctl {
 	struct cvmx_ocx_com_linkx_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
-	uint64_t cclk_dis                     : 1;  /**< Reserved.  INTERNAL:  Disable conditional clocking.  Set to force link clocks on
-                                                         unconditionally.
-                                                         Added in pass 2. */
-	uint64_t loopback                     : 1;  /**< Reserved. INTERNAL: Diagnostic data loopback.Set to force outgoing link to inbound port.
-                                                         All data and link credits are returned and appear to come from link partner. Typically
-                                                         SerDes should be disabled during this operation. */
+	uint64_t cclk_dis                     : 1;  /**< Reserved. */
+	uint64_t loopback                     : 1;  /**< Reserved. */
 	uint64_t reinit                       : 1;  /**< Reinitialize link. Setting this bit forces link back into init state and sets the DROP
                                                          bit.
                                                          Setting the bit also causes the link to transmit a REINIT request to the link partner.
@@ -1777,8 +1813,9 @@ union cvmx_ocx_lnex_trn_ctl {
 	uint64_t reserved_4_63                : 60;
 	uint64_t lock                         : 1;  /**< Training frame boundary locked. */
 	uint64_t done                         : 1;  /**< Training done. For diagnostic use only may be written to 1 to force training done. */
-	uint64_t ena                          : 1;  /**< Training enabled.
-                                                         Should match corresponding OCX_QLM()_CFG[TRN_ENA]. */
+	uint64_t ena                          : 1;  /**< OCX_LNEX_TRN_CTL[TRN_ENA]=1 indicates that the lane is currently training.  It is a status
+                                                         bit used for debug.  It will read as zero when training has completed or when the QLM
+                                                         isn't ready for training. */
 	uint64_t eie_detect                   : 1;  /**< Electrical idle exit (EIE) detected. */
 #else
 	uint64_t eie_detect                   : 1;
@@ -2509,11 +2546,6 @@ typedef union cvmx_ocx_tlkx_lnk_vcx_cnt cvmx_ocx_tlkx_lnk_vcx_cnt_t;
  *
  * This register controls which MCD bits are transported via the link. For proper operation
  * only one link must be enabled in both directions between each pair of link partners.
- *
- * INTERNAL: If N chips are connected over OCX, N-1 links should have MCD enabled.
- * A single "central" chip should connect all MCD buses and have a single MCD enabled link
- * to each of the other chips.  No MCD enabled links should connect between chips that don't
- * include the "central" chip.
  */
 union cvmx_ocx_tlkx_mcd_ctl {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-osm-defs.h b/arch/mips/include/asm/octeon/cvmx-osm-defs.h
index 729e645..b527730 100644
--- a/arch/mips/include/asm/octeon/cvmx-osm-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-osm-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_OSM_ASE_RATE_LIMIT_CTRL CVMX_OSM_ASE_RATE_LIMIT_CTRL_FUNC()
 static inline uint64_t CVMX_OSM_ASE_RATE_LIMIT_CTRL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_OSM_ASE_RATE_LIMIT_CTRL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC002100ull);
 }
@@ -67,14 +67,19 @@ static inline uint64_t CVMX_OSM_ASE_RATE_LIMIT_CTRL_FUNC(void)
 static inline uint64_t CVMX_OSM_BANKX_CTRL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + ((offset) & 63) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + ((offset) & 63) * 8;
+
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x0001DC0000001000ull) + ((offset) & 31) * 8;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + ((offset) & 63) * 8;
-			break;
 	}
 	cvmx_warn("CVMX_OSM_BANKX_CTRL (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + ((offset) & 63) * 8;
@@ -83,10 +88,14 @@ static inline uint64_t CVMX_OSM_BANKX_CTRL(unsigned long offset)
 static inline uint64_t CVMX_OSM_BANKX_CTRL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + (offset) * 8;
+
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DC0000001000ull) + (offset) * 8;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800DC001000ull) + (offset) * 8;
 }
@@ -107,12 +116,16 @@ static inline uint64_t CVMX_OSM_CLK_CFG_FUNC(void)
 static inline uint64_t CVMX_OSM_ECC_CTRL_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
+
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DC0000000020ull);
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
-			break;
 	}
 	cvmx_warn("CVMX_OSM_ECC_CTRL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
@@ -122,10 +135,14 @@ static inline uint64_t CVMX_OSM_ECC_CTRL_FUNC(void)
 static inline uint64_t CVMX_OSM_ECC_CTRL_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
+
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DC0000000020ull);
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800DC000020ull);
 }
@@ -135,12 +152,16 @@ static inline uint64_t CVMX_OSM_ECC_CTRL_FUNC(void)
 static inline uint64_t CVMX_OSM_ECO_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011800DC003000ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011800DC003000ull);
+
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DC0000003000ull);
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800DC003000ull);
-			break;
 	}
 	cvmx_warn("CVMX_OSM_ECO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC003000ull);
@@ -150,10 +171,14 @@ static inline uint64_t CVMX_OSM_ECO_FUNC(void)
 static inline uint64_t CVMX_OSM_ECO_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800DC003000ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800DC003000ull);
+
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DC0000003000ull);
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800DC003000ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800DC003000ull);
 }
@@ -163,12 +188,16 @@ static inline uint64_t CVMX_OSM_ECO_FUNC(void)
 static inline uint64_t CVMX_OSM_INT_INFO_ADDR_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
+
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DC0000000018ull);
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
-			break;
 	}
 	cvmx_warn("CVMX_OSM_INT_INFO_ADDR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
@@ -178,10 +207,14 @@ static inline uint64_t CVMX_OSM_INT_INFO_ADDR_FUNC(void)
 static inline uint64_t CVMX_OSM_INT_INFO_ADDR_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
+
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DC0000000018ull);
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800DC000018ull);
 }
@@ -191,12 +224,16 @@ static inline uint64_t CVMX_OSM_INT_INFO_ADDR_FUNC(void)
 static inline uint64_t CVMX_OSM_INT_INFO_ECC_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
+
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DC0000000010ull);
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
-			break;
 	}
 	cvmx_warn("CVMX_OSM_INT_INFO_ECC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
@@ -206,10 +243,14 @@ static inline uint64_t CVMX_OSM_INT_INFO_ECC_FUNC(void)
 static inline uint64_t CVMX_OSM_INT_INFO_ECC_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
+
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DC0000000010ull);
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800DC000010ull);
 }
@@ -219,12 +260,16 @@ static inline uint64_t CVMX_OSM_INT_INFO_ECC_FUNC(void)
 static inline uint64_t CVMX_OSM_INT_STAT_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
+
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DC0000000008ull);
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
-			break;
 	}
 	cvmx_warn("CVMX_OSM_INT_STAT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
@@ -234,10 +279,14 @@ static inline uint64_t CVMX_OSM_INT_STAT_FUNC(void)
 static inline uint64_t CVMX_OSM_INT_STAT_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
+
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DC0000000008ull);
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011800DC000008ull);
 }
@@ -246,14 +295,19 @@ static inline uint64_t CVMX_OSM_INT_STAT_FUNC(void)
 static inline uint64_t CVMX_OSM_MEMX_BIST_STATUS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 7))
+					return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + ((offset) & 7) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 7))
+					return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + ((offset) & 7) * 8;
+
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x0001DC0000002000ull) + ((offset) & 1) * 8;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 7))
-				return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + ((offset) & 7) * 8;
-			break;
 	}
 	cvmx_warn("CVMX_OSM_MEMX_BIST_STATUS (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + ((offset) & 7) * 8;
@@ -262,10 +316,14 @@ static inline uint64_t CVMX_OSM_MEMX_BIST_STATUS(unsigned long offset)
 static inline uint64_t CVMX_OSM_MEMX_BIST_STATUS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + (offset) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + (offset) * 8;
+
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001DC0000002000ull) + (offset) * 8;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800DC002000ull) + (offset) * 8;
 }
@@ -290,21 +348,9 @@ union cvmx_osm_ase_rate_limit_ctrl {
 	struct cvmx_osm_ase_rate_limit_ctrl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t rwc_rate_limit               : 1;  /**< Reserved. INTERNAL: Must be enabled when ASE is running at SCLK/2. If ASE is running at
-                                                         SCLK/1, this should be disabled for best performance. Mechanism: Each request is assigned
-                                                         to either phase 0 or phase 1. When feature is enabled, OSM does not send back-to-back
-                                                         responses for requests on the RWC ports with the same phase. Instead, a idle cycle is
-                                                         inserted between the responses. This enable applies to RWC ports. */
-	uint64_t bwc_rate_limit               : 1;  /**< Reserved. INTERNAL: Must be enabled when ASE is running at SCLK/2. If ASE is running at
-                                                         SCLK/1, this should be disabled for best performance. Mechanism: Each request is assigned
-                                                         to either phase 0 or phase 1. When feature is enabled, OSM does not send back-to-back
-                                                         responses for requests on the RWC ports with the same phase. Instead, a idle cycle is
-                                                         inserted between the responses. This enable applies to BWC ports. */
-	uint64_t twc_rate_limit               : 1;  /**< Reserved. INTERNAL: Must be enabled when ASE is running at SCLK/2. If ASE is running at
-                                                         SCLK/1, this should be disabled for best performance. Mechanism: Each request is assigned
-                                                         to either phase 0 or phase 1. When feature is enabled, OSM does not send back-to-back
-                                                         responses for requests on the RWC ports with the same phase. Instead, a idle cycle is
-                                                         inserted between the responses. This enable applies to TWC ports. */
+	uint64_t rwc_rate_limit               : 1;  /**< Reserved. */
+	uint64_t bwc_rate_limit               : 1;  /**< Reserved. */
+	uint64_t twc_rate_limit               : 1;  /**< Reserved. */
 #else
 	uint64_t twc_rate_limit               : 1;
 	uint64_t bwc_rate_limit               : 1;
@@ -411,8 +457,8 @@ union cvmx_osm_eco {
 	struct cvmx_osm_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t eco_ro                       : 8;  /**< INTERNAL: Reserved for ECO usage. */
-	uint64_t eco_rw                       : 8;  /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_ro                       : 8;  /**< N/A */
+	uint64_t eco_rw                       : 8;  /**< N/A */
 #else
 	uint64_t eco_rw                       : 8;
 	uint64_t eco_ro                       : 8;
@@ -585,9 +631,7 @@ union cvmx_osm_memx_bist_status {
 	struct cvmx_osm_memx_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t bist_status                  : 32; /**< BIST status with one bit corresponding to each BIST memory instance.
-                                                         INTERNAL: Each BIST Memory Instance (1 BIST engine + multiple physical memories) contains
-                                                         2 physical memories. */
+	uint64_t bist_status                  : 32; /**< BIST status with one bit corresponding to each BIST memory instance. */
 #else
 	uint64_t bist_status                  : 32;
 	uint64_t reserved_32_63               : 32;
@@ -596,9 +640,7 @@ union cvmx_osm_memx_bist_status {
 	struct cvmx_osm_memx_bist_status_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t bist_status                  : 1;  /**< BIST status with one bit corresponding to each BIST memory instance.
-                                                         INTERNAL: Each BIST Memory Instance (1 BIST engine + multiple physical memories) contains
-                                                         2 physical memories. */
+	uint64_t bist_status                  : 1;  /**< BIST status with one bit corresponding to each BIST memory instance. */
 #else
 	uint64_t bist_status                  : 1;
 	uint64_t reserved_1_63                : 63;
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
index 5109c1a..6b42e15 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
@@ -57,8 +57,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG000(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG000(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000000ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -70,8 +71,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG001(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG001(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000004ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -83,8 +85,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG002(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG002(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000008ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -96,8 +99,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG003(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG003(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000000Cull + ((offset) & 7) * 0x100000000ull;
 }
@@ -109,8 +113,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG004(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG004(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000010ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -122,8 +127,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG005(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG005(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000014ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -135,8 +141,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG006(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG006(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000018ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -148,8 +155,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG007(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG007(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000001Cull + ((offset) & 7) * 0x100000000ull;
 }
@@ -161,8 +169,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG008(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG008(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000020ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -174,8 +183,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG009(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG009(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000024ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -187,8 +197,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG010(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG010(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000028ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -200,8 +211,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG011(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG011(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000002Cull + ((offset) & 7) * 0x100000000ull;
 }
@@ -213,8 +225,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG012(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG012(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000030ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -226,8 +239,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG013(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG013(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000034ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -239,8 +253,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG015(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG015(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000003Cull + ((offset) & 7) * 0x100000000ull;
 }
@@ -252,8 +267,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG028(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG028(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000070ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -265,8 +281,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG029(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG029(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000074ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -278,8 +295,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG030(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG030(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000078ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -291,8 +309,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG031(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG031(%lu) is invalid on this chip\n", offset);
 	return 0x000005000000007Cull + ((offset) & 7) * 0x100000000ull;
 }
@@ -304,8 +323,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG032(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG032(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000080ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -317,8 +337,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG037(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG037(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000094ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -330,8 +351,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG038(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG038(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000098ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -342,20 +364,24 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG038(unsigned long offset)
 static inline uint64_t CVMX_PCIEEPVFX_CFG039(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG039(%lu) is invalid on this chip\n", offset);
-	return 0x000005000000009Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000005000000009Cull + ((offset) & 7) * 0x100000000ull;
 }
 #else
-#define CVMX_PCIEEPVFX_CFG039(offset) (0x000005000000009Cull + ((offset) & 3) * 0x100000000ull)
+#define CVMX_PCIEEPVFX_CFG039(offset) (0x000005000000009Cull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPVFX_CFG040(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG040(%lu) is invalid on this chip\n", offset);
 	return 0x00000500000000A0ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -367,8 +393,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG044(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG044(%lu) is invalid on this chip\n", offset);
 	return 0x00000500000000B0ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -380,8 +407,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG045(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG045(%lu) is invalid on this chip\n", offset);
 	return 0x00000500000000B4ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -393,8 +421,9 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG046(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG046(%lu) is invalid on this chip\n", offset);
 	return 0x00000500000000B8ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -402,34 +431,13 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG046(unsigned long offset)
 #define CVMX_PCIEEPVFX_CFG046(offset) (0x00000500000000B8ull + ((offset) & 7) * 0x100000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG048(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG048(%lu) is invalid on this chip\n", offset);
-	return 0x00000500000000C0ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG048(offset) (0x00000500000000C0ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG049(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG049(%lu) is invalid on this chip\n", offset);
-	return 0x00000500000000C4ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG049(offset) (0x00000500000000C4ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIEEPVFX_CFG064(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG064(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000100ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -441,321 +449,15 @@ static inline uint64_t CVMX_PCIEEPVFX_CFG065(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2) || (offset == 4))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2) || (offset == 4)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPVFX_CFG065(%lu) is invalid on this chip\n", offset);
 	return 0x0000050000000104ull + ((offset) & 7) * 0x100000000ull;
 }
 #else
 #define CVMX_PCIEEPVFX_CFG065(offset) (0x0000050000000104ull + ((offset) & 7) * 0x100000000ull)
 #endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG082(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG082(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000148ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG082(offset) (0x0000050000000148ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG083(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG083(%lu) is invalid on this chip\n", offset);
-	return 0x000005000000014Cull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG083(offset) (0x000005000000014Cull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG448(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG448(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000700ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG448(offset) (0x0000050000000700ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG449(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG449(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000704ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG449(offset) (0x0000050000000704ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG450(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG450(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000708ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG450(offset) (0x0000050000000708ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG451(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG451(%lu) is invalid on this chip\n", offset);
-	return 0x000005000000070Cull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG451(offset) (0x000005000000070Cull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG452(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG452(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000710ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG452(offset) (0x0000050000000710ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG453(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG453(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000714ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG453(offset) (0x0000050000000714ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG454(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG454(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000718ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG454(offset) (0x0000050000000718ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG455(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG455(%lu) is invalid on this chip\n", offset);
-	return 0x000005000000071Cull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG455(offset) (0x000005000000071Cull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG456(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG456(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000720ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG456(offset) (0x0000050000000720ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG458(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG458(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000728ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG458(offset) (0x0000050000000728ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG459(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG459(%lu) is invalid on this chip\n", offset);
-	return 0x000005000000072Cull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG459(offset) (0x000005000000072Cull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG460(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG460(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000730ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG460(offset) (0x0000050000000730ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG461(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG461(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000734ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG461(offset) (0x0000050000000734ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG462(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG462(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000738ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG462(offset) (0x0000050000000738ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG463(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG463(%lu) is invalid on this chip\n", offset);
-	return 0x000005000000073Cull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG463(offset) (0x000005000000073Cull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG464(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG464(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000740ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG464(offset) (0x0000050000000740ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG465(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG465(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000744ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG465(offset) (0x0000050000000744ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG466(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG466(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000748ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG466(offset) (0x0000050000000748ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG467(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG467(%lu) is invalid on this chip\n", offset);
-	return 0x000005000000074Cull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG467(offset) (0x000005000000074Cull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG468(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG468(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000750ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG468(offset) (0x0000050000000750ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG490(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG490(%lu) is invalid on this chip\n", offset);
-	return 0x00000500000007A8ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG490(offset) (0x00000500000007A8ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG491(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG491(%lu) is invalid on this chip\n", offset);
-	return 0x00000500000007ACull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG491(offset) (0x00000500000007ACull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG492(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG492(%lu) is invalid on this chip\n", offset);
-	return 0x00000500000007B0ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG492(offset) (0x00000500000007B0ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG515(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG515(%lu) is invalid on this chip\n", offset);
-	return 0x000005000000080Cull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG515(offset) (0x000005000000080Cull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG516(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG516(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000810ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG516(offset) (0x0000050000000810ull + ((offset) & 3) * 0x100000000ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_PCIEEPVFX_CFG517(unsigned long offset)
-{
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PCIEEPVFX_CFG517(%lu) is invalid on this chip\n", offset);
-	return 0x0000050000000814ull + ((offset) & 3) * 0x100000000ull;
-}
-#else
-#define CVMX_PCIEEPVFX_CFG517(offset) (0x0000050000000814ull + ((offset) & 3) * 0x100000000ull)
-#endif
 
 /**
  * cvmx_pcieepvf#_cfg000
@@ -1333,35 +1035,6 @@ union cvmx_pcieepvfx_cfg031 {
 	struct cvmx_pcieepvfx_cfg031_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t pnum                         : 8;  /**< Read-only copy of the associated PF's PCIEP()_CFG031[PNUM]. */
-	uint32_t reserved_23_23               : 1;
-	uint32_t aspm                         : 1;  /**< ASPM optionality compliance. */
-	uint32_t lbnc                         : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG031[LBNC]. */
-	uint32_t dllarc                       : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG031[DLLARC]. */
-	uint32_t sderc                        : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG031[SDERC]. */
-	uint32_t cpm                          : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG031[CPM]. */
-	uint32_t l1el                         : 3;  /**< Read-only copy of the associated PF's PCIEP()_CFG031[L1EL]. */
-	uint32_t l0el                         : 3;  /**< Read-only copy of the associated PF's PCIEP()_CFG031[L0EL]. */
-	uint32_t aslpms                       : 2;  /**< Read-only copy of the associated PF's PCIEP()_CFG031[ASLPMS]. */
-	uint32_t mlw                          : 6;  /**< Read-only copy of the associated PF's PCIEP()_CFG031[MLW]. */
-	uint32_t mls                          : 4;  /**< Read-only copy of the associated PF's PCIEP()_CFG031[MLS]. */
-#else
-	uint32_t mls                          : 4;
-	uint32_t mlw                          : 6;
-	uint32_t aslpms                       : 2;
-	uint32_t l0el                         : 3;
-	uint32_t l1el                         : 3;
-	uint32_t cpm                          : 1;
-	uint32_t sderc                        : 1;
-	uint32_t dllarc                       : 1;
-	uint32_t lbnc                         : 1;
-	uint32_t aspm                         : 1;
-	uint32_t reserved_23_23               : 1;
-	uint32_t pnum                         : 8;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg031_cn73xx {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t pnum                         : 8;  /**< Read-only copy of the associated PF's PCIEP()_CFG031[PNUM]. */
 	uint32_t reserved_22_23               : 2;
 	uint32_t lbnc                         : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG031[LBNC]. */
 	uint32_t dllarc                       : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG031[DLLARC]. */
@@ -1385,10 +1058,11 @@ union cvmx_pcieepvfx_cfg031 {
 	uint32_t reserved_22_23               : 2;
 	uint32_t pnum                         : 8;
 #endif
-	} cn73xx;
+	} s;
+	struct cvmx_pcieepvfx_cfg031_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg031_s        cn78xx;
 	struct cvmx_pcieepvfx_cfg031_s        cn78xxp2;
-	struct cvmx_pcieepvfx_cfg031_cn73xx   cnf75xx;
+	struct cvmx_pcieepvfx_cfg031_s        cnf75xx;
 };
 typedef union cvmx_pcieepvfx_cfg031 cvmx_pcieepvfx_cfg031_t;
 
@@ -1402,57 +1076,6 @@ union cvmx_pcieepvfx_cfg032 {
 	uint32_t u32;
 	struct cvmx_pcieepvfx_cfg032_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t lab                          : 1;  /**< Link autonomous bandwidth status. */
-	uint32_t lbm                          : 1;  /**< Link bandwidth management status. */
-	uint32_t dlla                         : 1;  /**< Data link layer active. Not applicable for an upstream port or endpoint device, hardwired to 0. */
-	uint32_t scc                          : 1;  /**< Slot clock configuration. Indicates that the component uses the same physical reference
-                                                         clock that the platform provides on the connector. */
-	uint32_t lt                           : 1;  /**< Link training. Not applicable for an upstream port or endpoint device, hardwired to 0. */
-	uint32_t reserved_26_26               : 1;
-	uint32_t nlw                          : 6;  /**< Negotiated link width. Set automatically by hardware after Link initialization. */
-	uint32_t ls                           : 4;  /**< Link speed.
-                                                         0x1 = The negotiated link speed: 2.5 Gbps.
-                                                         0x2 = The negotiated link speed: 5.0 Gbps.
-                                                         0x4 = The negotiated link speed: 8.0 Gbps. */
-	uint32_t reserved_12_15               : 4;
-	uint32_t lab_int_enb                  : 1;  /**< Link autonomous bandwidth interrupt enable. This bit is not applicable and is reserved for
-                                                         endpoints. */
-	uint32_t lbm_int_enb                  : 1;  /**< Link bandwidth management interrupt enable. This bit is not applicable and is reserved for
-                                                         endpoints. */
-	uint32_t hawd                         : 1;  /**< Hardware autonomous width disable (not supported). */
-	uint32_t ecpm                         : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG032[ECPM]. */
-	uint32_t es                           : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG032[ES]. */
-	uint32_t ccc                          : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG032[CCC]. */
-	uint32_t rl                           : 1;  /**< Retrain link. Not applicable for an upstream port or endpoint device. Hardwired to 0. */
-	uint32_t ld                           : 1;  /**< Link disable. Not applicable for an upstream port or endpoint device. Hardwired to 0. */
-	uint32_t rcb                          : 1;  /**< VF's read-only zeros. */
-	uint32_t reserved_2_2                 : 1;
-	uint32_t aslpc                        : 2;  /**< Read-only copy of the associated PF's PCIEP()_CFG032[ASLPC]. */
-#else
-	uint32_t aslpc                        : 2;
-	uint32_t reserved_2_2                 : 1;
-	uint32_t rcb                          : 1;
-	uint32_t ld                           : 1;
-	uint32_t rl                           : 1;
-	uint32_t ccc                          : 1;
-	uint32_t es                           : 1;
-	uint32_t ecpm                         : 1;
-	uint32_t hawd                         : 1;
-	uint32_t lbm_int_enb                  : 1;
-	uint32_t lab_int_enb                  : 1;
-	uint32_t reserved_12_15               : 4;
-	uint32_t ls                           : 4;
-	uint32_t nlw                          : 6;
-	uint32_t reserved_26_26               : 1;
-	uint32_t lt                           : 1;
-	uint32_t scc                          : 1;
-	uint32_t dlla                         : 1;
-	uint32_t lbm                          : 1;
-	uint32_t lab                          : 1;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg032_cn73xx {
-#ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_12_31               : 20;
 	uint32_t lab_int_enb                  : 1;  /**< Link autonomous bandwidth interrupt enable. This bit is not applicable and is reserved for
                                                          endpoints. */
@@ -1481,10 +1104,11 @@ union cvmx_pcieepvfx_cfg032 {
 	uint32_t lab_int_enb                  : 1;
 	uint32_t reserved_12_31               : 20;
 #endif
-	} cn73xx;
+	} s;
+	struct cvmx_pcieepvfx_cfg032_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg032_s        cn78xx;
 	struct cvmx_pcieepvfx_cfg032_s        cn78xxp2;
-	struct cvmx_pcieepvfx_cfg032_cn73xx   cnf75xx;
+	struct cvmx_pcieepvfx_cfg032_s        cnf75xx;
 };
 typedef union cvmx_pcieepvfx_cfg032 cvmx_pcieepvfx_cfg032_t;
 
@@ -1559,12 +1183,12 @@ union cvmx_pcieepvfx_cfg038 {
 	struct cvmx_pcieepvfx_cfg038_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_16_31               : 16;
-	uint32_t eetpb                        : 1;  /**< Unsupported end-end TLP prefix blocking. */
+	uint32_t eetpb                        : 1;  /**< End-end TLP prefix blocking (not supported). */
 	uint32_t obffe                        : 2;  /**< Optimized buffer flush fill (OBFF) enable (not supported). */
 	uint32_t reserved_10_12               : 3;
 	uint32_t id0_cp                       : 1;  /**< ID based ordering completion enable (not supported). */
 	uint32_t id0_rq                       : 1;  /**< ID based ordering request enable (not supported). */
-	uint32_t atom_op_eb                   : 1;  /**< AtomicOp egress blocking (not supported). */
+	uint32_t reserved_7_7                 : 1;
 	uint32_t atom_op                      : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG038[ATOM_OP]. */
 	uint32_t ari                          : 1;  /**< Alternate routing ID forwarding supported (not supported). */
 	uint32_t ctd                          : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG038[CTD]. */
@@ -1574,7 +1198,7 @@ union cvmx_pcieepvfx_cfg038 {
 	uint32_t ctd                          : 1;
 	uint32_t ari                          : 1;
 	uint32_t atom_op                      : 1;
-	uint32_t atom_op_eb                   : 1;
+	uint32_t reserved_7_7                 : 1;
 	uint32_t id0_rq                       : 1;
 	uint32_t id0_cp                       : 1;
 	uint32_t reserved_10_12               : 3;
@@ -1583,30 +1207,10 @@ union cvmx_pcieepvfx_cfg038 {
 	uint32_t reserved_16_31               : 16;
 #endif
 	} s;
-	struct cvmx_pcieepvfx_cfg038_cn73xx {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_10_31               : 22;
-	uint32_t id0_cp                       : 1;  /**< ID based ordering completion enable (not supported). */
-	uint32_t id0_rq                       : 1;  /**< ID based ordering request enable (not supported). */
-	uint32_t reserved_7_7                 : 1;
-	uint32_t atom_op                      : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG038[ATOM_OP]. */
-	uint32_t reserved_5_5                 : 1;
-	uint32_t ctd                          : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG038[CTD]. */
-	uint32_t ctv                          : 4;  /**< Read-only copy of the associated PF's PCIEP()_CFG038[CTV]. */
-#else
-	uint32_t ctv                          : 4;
-	uint32_t ctd                          : 1;
-	uint32_t reserved_5_5                 : 1;
-	uint32_t atom_op                      : 1;
-	uint32_t reserved_7_7                 : 1;
-	uint32_t id0_rq                       : 1;
-	uint32_t id0_cp                       : 1;
-	uint32_t reserved_10_31               : 22;
-#endif
-	} cn73xx;
+	struct cvmx_pcieepvfx_cfg038_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg038_s        cn78xx;
 	struct cvmx_pcieepvfx_cfg038_s        cn78xxp2;
-	struct cvmx_pcieepvfx_cfg038_cn73xx   cnf75xx;
+	struct cvmx_pcieepvfx_cfg038_s        cnf75xx;
 };
 typedef union cvmx_pcieepvfx_cfg038 cvmx_pcieepvfx_cfg038_t;
 
@@ -1622,18 +1226,7 @@ union cvmx_pcieepvfx_cfg039 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_9_31                : 23;
 	uint32_t cls                          : 1;  /**< Crosslink supported. */
-	uint32_t slsv                         : 7;  /**< Supported link speeds vector. Indicates the supported link speeds of the associated port.
-                                                         For each bit, a value of 1b indicates that the corresponding link speed is supported;
-                                                         otherwise, the link speed is not supported. Bit definitions are:
-                                                         _ Bit <1> =  2.5 GT/s.
-                                                         _ Bit <2> = 5.0 GT/s.
-                                                         _ Bit <3> = 8.0 GT/s.
-                                                         _ Bits <7:4> are reserved.
-                                                         The reset value of this field is controlled by the value read from PEM()_CFG[MD].
-                                                         _ MD is 0x0, reset to 0x1: 2.5 GHz supported.
-                                                         _ MD is 0x1, reset to 0x3: 5.0 GHz and 2.5 GHz supported.
-                                                         _ MD is 0x2, reset to 0x7: 8.0 Ghz, 5.0 GHz and 2.5 GHz supported.
-                                                         _ MD is 0x3, reset to 0x7: 8.0 Ghz, 5.0 GHz and 2.5 GHz supported (RC Mode). */
+	uint32_t slsv                         : 7;  /**< Read-only copy of the associated PF's PCIEP()_CFG039[SLSV]. */
 	uint32_t reserved_0_0                 : 1;
 #else
 	uint32_t reserved_0_0                 : 1;
@@ -1642,8 +1235,10 @@ union cvmx_pcieepvfx_cfg039 {
 	uint32_t reserved_9_31                : 23;
 #endif
 	} s;
+	struct cvmx_pcieepvfx_cfg039_s        cn73xx;
 	struct cvmx_pcieepvfx_cfg039_s        cn78xx;
 	struct cvmx_pcieepvfx_cfg039_s        cn78xxp2;
+	struct cvmx_pcieepvfx_cfg039_s        cnf75xx;
 };
 typedef union cvmx_pcieepvfx_cfg039 cvmx_pcieepvfx_cfg039_t;
 
@@ -1774,99 +1369,9 @@ union cvmx_pcieepvfx_cfg046 {
 typedef union cvmx_pcieepvfx_cfg046 cvmx_pcieepvfx_cfg046_t;
 
 /**
- * cvmx_pcieepvf#_cfg048
+ * cvmx_pcieepvf#_cfg064
  *
- * This register contains the forty-ninth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg048 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg048_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t pmes                         : 5;  /**< PME_Support.
-                                                         _ Bit 11: If set, PME Messages can be generated from D0.
-                                                         _ Bit 12: If set, PME Messages can be generated from D1.
-                                                         _ Bit 13: If set, PME Messages can be generated from D2.
-                                                         _ Bit 14: If set, PME Messages can be generated from D3hot.
-                                                         _ Bit 15: If set, PME Messages can be generated from D3cold. */
-	uint32_t d2s                          : 1;  /**< D2 support. */
-	uint32_t d1s                          : 1;  /**< D1 support. */
-	uint32_t auxc                         : 3;  /**< AUX current. */
-	uint32_t dsi                          : 1;  /**< Device specific initialization (DSI). */
-	uint32_t reserved_20_20               : 1;
-	uint32_t pme_clock                    : 1;  /**< PME clock, hardwired to 0. */
-	uint32_t pmsv                         : 3;  /**< Power management specification version. */
-	uint32_t ncp                          : 8;  /**< Next capability pointer. */
-	uint32_t pmcid                        : 8;  /**< Power management capability ID. */
-#else
-	uint32_t pmcid                        : 8;
-	uint32_t ncp                          : 8;
-	uint32_t pmsv                         : 3;
-	uint32_t pme_clock                    : 1;
-	uint32_t reserved_20_20               : 1;
-	uint32_t dsi                          : 1;
-	uint32_t auxc                         : 3;
-	uint32_t d1s                          : 1;
-	uint32_t d2s                          : 1;
-	uint32_t pmes                         : 5;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg048_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg048_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg048 cvmx_pcieepvfx_cfg048_t;
-
-/**
- * cvmx_pcieepvf#_cfg049
- *
- * This register contains the fiftieth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg049 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg049_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t pmdia                        : 8;  /**< Data register for additional information (not supported) */
-	uint32_t bpccee                       : 1;  /**< Bus power/clock control enable, hardwired to 0. */
-	uint32_t bd3h                         : 1;  /**< B2/B3 support, hardwired to 0. */
-	uint32_t reserved_16_21               : 6;
-	uint32_t pmess                        : 1;  /**< PME status. Indicates whether or not a previously enabled PME event occurred. */
-	uint32_t pmedsia                      : 2;  /**< Data scale (not supported). */
-	uint32_t pmds                         : 4;  /**< Data select (not supported). */
-	uint32_t pmeens                       : 1;  /**< PME enable. A value of 1 indicates that the device is enabled to generate PME. */
-	uint32_t reserved_4_7                 : 4;
-	uint32_t nsr                          : 1;  /**< No soft reset. */
-	uint32_t reserved_2_2                 : 1;
-	uint32_t ps                           : 2;  /**< Power state. Controls the device power state:
-                                                         0x0 = D0.
-                                                         0x1 = D1.
-                                                         0x2 = D2.
-                                                         0x3 = D3.
-                                                         The written value is ignored if the specific state is not supported. */
-#else
-	uint32_t ps                           : 2;
-	uint32_t reserved_2_2                 : 1;
-	uint32_t nsr                          : 1;
-	uint32_t reserved_4_7                 : 4;
-	uint32_t pmeens                       : 1;
-	uint32_t pmds                         : 4;
-	uint32_t pmedsia                      : 2;
-	uint32_t pmess                        : 1;
-	uint32_t reserved_16_21               : 6;
-	uint32_t bd3h                         : 1;
-	uint32_t bpccee                       : 1;
-	uint32_t pmdia                        : 8;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg049_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg049_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg049 cvmx_pcieepvfx_cfg049_t;
-
-/**
- * cvmx_pcieepvf#_cfg064
- *
- * This register contains the sixty-fifth 32-bits of PCIe type 0 configuration space.
+ * This register contains the sixty-fifth 32-bits of PCIe type 0 configuration space.
  *
  */
 union cvmx_pcieepvfx_cfg064 {
@@ -1875,37 +1380,17 @@ union cvmx_pcieepvfx_cfg064 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t nco                          : 12; /**< Next capability offset. */
 	uint32_t cv                           : 4;  /**< Capability version. */
-	uint32_t reserved_0_15                : 16;
-#else
-	uint32_t reserved_0_15                : 16;
-	uint32_t cv                           : 4;
-	uint32_t nco                          : 12;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg064_cn73xx {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t nco                          : 12; /**< Next capability offset. */
-	uint32_t cv                           : 4;  /**< Capability version. */
 	uint32_t ariid                        : 16; /**< PCIE Express extended capability */
 #else
 	uint32_t ariid                        : 16;
 	uint32_t cv                           : 4;
 	uint32_t nco                          : 12;
 #endif
-	} cn73xx;
-	struct cvmx_pcieepvfx_cfg064_cn78xx {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t nco                          : 12; /**< Next capability offset. Points to the ARI capabilities by default. */
-	uint32_t cv                           : 4;  /**< Capability version */
-	uint32_t pcieec                       : 16; /**< PCI Express extended capability */
-#else
-	uint32_t pcieec                       : 16;
-	uint32_t cv                           : 4;
-	uint32_t nco                          : 12;
-#endif
-	} cn78xx;
-	struct cvmx_pcieepvfx_cfg064_cn78xx   cn78xxp2;
-	struct cvmx_pcieepvfx_cfg064_cn73xx   cnf75xx;
+	} s;
+	struct cvmx_pcieepvfx_cfg064_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg064_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg064_s        cn78xxp2;
+	struct cvmx_pcieepvfx_cfg064_s        cnf75xx;
 };
 typedef union cvmx_pcieepvfx_cfg064 cvmx_pcieepvfx_cfg064_t;
 
@@ -1939,963 +1424,10 @@ union cvmx_pcieepvfx_cfg065 {
 #endif
 	} s;
 	struct cvmx_pcieepvfx_cfg065_s        cn73xx;
+	struct cvmx_pcieepvfx_cfg065_s        cn78xx;
+	struct cvmx_pcieepvfx_cfg065_s        cn78xxp2;
 	struct cvmx_pcieepvfx_cfg065_s        cnf75xx;
 };
 typedef union cvmx_pcieepvfx_cfg065 cvmx_pcieepvfx_cfg065_t;
 
-/**
- * cvmx_pcieepvf#_cfg082
- *
- * This register contains the eighty-third 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg082 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg082_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t nco                          : 12; /**< Next capability offset. */
-	uint32_t cv                           : 4;  /**< Capability version. */
-	uint32_t ariid                        : 16; /**< PCIE Express extended capability */
-#else
-	uint32_t ariid                        : 16;
-	uint32_t cv                           : 4;
-	uint32_t nco                          : 12;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg082_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg082_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg082 cvmx_pcieepvfx_cfg082_t;
-
-/**
- * cvmx_pcieepvf#_cfg083
- *
- * This register contains the eighty-fourth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg083 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg083_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_24_31               : 8;
-	uint32_t fg                           : 4;  /**< Function group. */
-	uint32_t reserved_18_19               : 2;
-	uint32_t acsfge                       : 1;  /**< ACS function groups enable (A). */
-	uint32_t mfvcfge                      : 1;  /**< MFVC function groups enable (M). */
-	uint32_t nfn                          : 8;  /**< Next function number. */
-	uint32_t reserved_2_7                 : 6;
-	uint32_t acsfgc                       : 1;  /**< ACS function groups capability. */
-	uint32_t mfvcfgc                      : 1;  /**< MFVC function groups capability. */
-#else
-	uint32_t mfvcfgc                      : 1;
-	uint32_t acsfgc                       : 1;
-	uint32_t reserved_2_7                 : 6;
-	uint32_t nfn                          : 8;
-	uint32_t mfvcfge                      : 1;
-	uint32_t acsfge                       : 1;
-	uint32_t reserved_18_19               : 2;
-	uint32_t fg                           : 4;
-	uint32_t reserved_24_31               : 8;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg083_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg083_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg083 cvmx_pcieepvfx_cfg083_t;
-
-/**
- * cvmx_pcieepvf#_cfg448
- *
- * This register contains the four hundred forty-ninth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg448 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg448_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t rtl                          : 16; /**< Replay time limit. The replay timer expires when it reaches this limit. The PCI Express
-                                                         bus initiates a replay upon reception of a nak or when the replay timer expires. This
-                                                         value is set correctly by the hardware out of reset or when the negotiated link width or
-                                                         payload size changes. If the user changes this value through a CSR write or by an EEPROM
-                                                         load, they should refer to the PCIe specification for the correct value. */
-	uint32_t rtltl                        : 16; /**< Round trip latency time limit. The ack/nak latency timer expires when it reaches this
-                                                         limit. This value is set correctly by the hardware out of reset or when the negotiated
-                                                         link width or payload size changes. If the user changes this value through a CSR write or
-                                                         by an EEPROM load, they should refer to the PCIe specification for the correct value. */
-#else
-	uint32_t rtltl                        : 16;
-	uint32_t rtl                          : 16;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg448_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg448_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg448 cvmx_pcieepvfx_cfg448_t;
-
-/**
- * cvmx_pcieepvf#_cfg449
- *
- * This register contains the four hundred fiftieth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg449 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg449_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t omr                          : 32; /**< Other message register. This register can be used for either of the following purposes:
-                                                         * To send a specific PCI Express message, the application writes the payload of the
-                                                         message into this register, then sets bit 0 of the port link control register to send the
-                                                         message.
-                                                         * To store a corruption pattern for corrupting the LCRC on all TLPs, the application
-                                                         places a 32-bit corruption pattern into this register and enables this function by setting
-                                                         bit 25 of the port link control register. When enabled, the transmit LCRC result is XORed
-                                                         with this pattern before inserting it into the packet. */
-#else
-	uint32_t omr                          : 32;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg449_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg449_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg449 cvmx_pcieepvfx_cfg449_t;
-
-/**
- * cvmx_pcieepvf#_cfg450
- *
- * This register contains the four hundred fifty-first 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg450 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg450_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t lpec                         : 8;  /**< Low power entrance count. The power management state waits this many clock cycles for the
-                                                         associated completion of a CfgWr to PCIEEP()_CFG017 register, power state (PS) field
-                                                         register
-                                                         to go low-power. This register is intended for applications that do not let the PCI
-                                                         Express bus handle a completion for configuration request to the power management control
-                                                         and status (PCIEP()_CFG017) register. */
-	uint32_t reserved_22_23               : 2;
-	uint32_t link_state                   : 6;  /**< Link state. The link state that the PCI Express bus is forced to when bit 15 (force link)
-                                                         is set. State encoding:
-                                                         0x0 = DETECT_QUIET.
-                                                         0x1 = DETECT_ACT.
-                                                         0x2 = POLL_ACTIVE.
-                                                         0x3 = POLL_COMPLIANCE.
-                                                         0x4 = POLL_CONFIG.
-                                                         0x5 = PRE_DETECT_QUIET.
-                                                         0x6 = DETECT_WAIT.
-                                                         0x7 = CFG_LINKWD_START.
-                                                         0x8 = CFG_LINKWD_ACEPT.
-                                                         0x9 = CFG_LANENUM_WAIT.
-                                                         0xA = CFG_LANENUM_ACEPT.
-                                                         0xB = CFG_COMPLETE.
-                                                         0xC = CFG_IDLE.
-                                                         0xD = RCVRY_LOCK.
-                                                         0xE = RCVRY_SPEED.
-                                                         0xF = RCVRY_RCVRCFG.
-                                                         0x10 = RCVRY_IDLE.
-                                                         0x11 = L0.
-                                                         0x12 = L0S.
-                                                         0x13 = L123_SEND_EIDLE.
-                                                         0x14 = L1_IDLE.
-                                                         0x15 = L2_IDLE.
-                                                         0x16 = L2_WAKE.
-                                                         0x17 = DISABLED_ENTRY.
-                                                         0x18 = DISABLED_IDLE.
-                                                         0x19 = DISABLED.
-                                                         0x1A = LPBK_ENTRY.
-                                                         0x1B = LPBK_ACTIVE.
-                                                         0x1C = LPBK_EXIT.
-                                                         0x1D = LPBK_EXIT_TIMEOUT.
-                                                         0x1E = HOT_RESET_ENTRY.
-                                                         0x1F = HOT_RESET. */
-	uint32_t force_link                   : 1;  /**< Force link. Forces the link to the state specified by the LINK_STATE field. The force link
-                                                         pulse triggers link renegotiation.
-                                                         As the force link is a pulse, writing a 1 to it does trigger the forced link state event,
-                                                         even though reading it always returns a 0. */
-	uint32_t reserved_8_14                : 7;
-	uint32_t link_num                     : 8;  /**< Link number. Not used for endpoint. */
-#else
-	uint32_t link_num                     : 8;
-	uint32_t reserved_8_14                : 7;
-	uint32_t force_link                   : 1;
-	uint32_t link_state                   : 6;
-	uint32_t reserved_22_23               : 2;
-	uint32_t lpec                         : 8;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg450_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg450_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg450 cvmx_pcieepvfx_cfg450_t;
-
-/**
- * cvmx_pcieepvf#_cfg451
- *
- * This register contains the four hundred fifty-second 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg451 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg451_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_31_31               : 1;
-	uint32_t easpml1                      : 1;  /**< Enter ASPM L1 without receive in L0s. Allow core to enter ASPM L1 even when link partner
-                                                         did not go to L0s (receive is not in L0s). When not set, core goes to ASPM L1 only after
-                                                         idle period, during which both receive and transmit are in L0s. */
-	uint32_t l1el                         : 3;  /**< L1 entrance latency. Values correspond to:
-                                                         0x0 = 1 ms.
-                                                         0x1 = 2 ms.
-                                                         0x2 = 4 ms.
-                                                         0x3 = 8 ms.
-                                                         0x4 = 16 ms.
-                                                         0x5 = 32 ms.
-                                                         0x6 or 0x7 = 64 ms. */
-	uint32_t l0el                         : 3;  /**< L0s entrance latency. Values correspond to:
-                                                         0x0 = 1 ms.
-                                                         0x1 = 2 ms.
-                                                         0x2 = 3 ms.
-                                                         0x3 = 4 ms.
-                                                         0x4 = 5 ms.
-                                                         0x5 = 6 ms.
-                                                         0x6 or 0x7 = 7 ms. */
-	uint32_t n_fts_cc                     : 8;  /**< N_FTS when common clock is used.
-                                                         The number of fast training sequence (FTS) ordered sets to be transmitted when
-                                                         transitioning from L0s to L0. The maximum number of FTS ordered sets that a component can
-                                                         request is 255.
-                                                         A value of zero is not supported; a value of zero can cause the LTSSM to go into the
-                                                         recovery state when exiting from L0s. */
-	uint32_t n_fts                        : 8;  /**< N_FTS. The number of fast training sequence (FTS) ordered sets to be transmitted when
-                                                         transitioning from L0s to L0. The maximum number of FTS ordered sets that a component can
-                                                         request is 255.
-                                                         A value of zero is not supported; a value of zero can cause the LTSSM to go into the
-                                                         recovery state when exiting from L0s. */
-	uint32_t ack_freq                     : 8;  /**< Ack frequency. The number of pending Acks specified here (up to 255) before sending an Ack. */
-#else
-	uint32_t ack_freq                     : 8;
-	uint32_t n_fts                        : 8;
-	uint32_t n_fts_cc                     : 8;
-	uint32_t l0el                         : 3;
-	uint32_t l1el                         : 3;
-	uint32_t easpml1                      : 1;
-	uint32_t reserved_31_31               : 1;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg451_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg451_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg451 cvmx_pcieepvfx_cfg451_t;
-
-/**
- * cvmx_pcieepvf#_cfg452
- *
- * This register contains the four hundred fifty-third 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg452 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg452_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_22_31               : 10;
-	uint32_t lme                          : 6;  /**< Link mode enable set as follows:
-                                                         0x1 = x1.
-                                                         0x3 = x2.
-                                                         0x7 = x4.
-                                                         0xF = x8.
-                                                         0x1F = x16 (not supported).
-                                                         0x3F = x32 (not supported).
-                                                         This field indicates the maximum number of lanes supported by the PCIe port. The value can
-                                                         be set less than 0xF to limit the number of lanes that the PCIe will attempt to use. If
-                                                         the value of 0xF set by the hardware is not desired, this field can be programmed to a
-                                                         smaller value (i.e. EEPROM). See also PCIEEP()_CFG031[MLW].
-                                                         The value of this field does not indicate the number of lanes in use by the PCIe. This
-                                                         field sets the maximum number of lanes in the PCIe core that could be used. As per the
-                                                         PCIe specification, the PCIe core can negotiate a smaller link width, so all of x8, x4,
-                                                         x2, and x1 are supported when
-                                                         LME = 0xF, for example. */
-	uint32_t reserved_12_15               : 4;
-	uint32_t link_rate                    : 4;  /**< Reserved. */
-	uint32_t flm                          : 1;  /**< Fast link mode. Sets all internal timers to fast mode for simulation purposes. If during
-                                                         an EEPROM load, the first word loaded is 0xFFFFFFFF, the EEPROM load is terminated and
-                                                         this bit is set. */
-	uint32_t reserved_6_6                 : 1;
-	uint32_t dllle                        : 1;  /**< DLL link enable. Enables link initialization. If DLL link enable = 0, the PCI Express bus
-                                                         does not transmit InitFC DLLPs and does not establish a link. */
-	uint32_t reserved_4_4                 : 1;
-	uint32_t ra                           : 1;  /**< Reset assert. Triggers a recovery and forces the LTSSM to the hot reset state (downstream
-                                                         port only). */
-	uint32_t le                           : 1;  /**< Loopback enable. Initiate loopback mode as a master. On a 0->1 transition, the PCIe core
-                                                         sends TS ordered sets with the loopback bit set to cause the link partner to enter into
-                                                         loopback mode as a slave. Normal transmission is not possible when LE=1. To exit loopback
-                                                         mode, take the link through a reset sequence. */
-	uint32_t sd                           : 1;  /**< Scramble disable. Setting this bit turns off data scrambling. */
-	uint32_t omr                          : 1;  /**< Other message request. When software writes a 1 to this bit, the PCI Express bus transmits
-                                                         the message contained in the other message register. */
-#else
-	uint32_t omr                          : 1;
-	uint32_t sd                           : 1;
-	uint32_t le                           : 1;
-	uint32_t ra                           : 1;
-	uint32_t reserved_4_4                 : 1;
-	uint32_t dllle                        : 1;
-	uint32_t reserved_6_6                 : 1;
-	uint32_t flm                          : 1;
-	uint32_t link_rate                    : 4;
-	uint32_t reserved_12_15               : 4;
-	uint32_t lme                          : 6;
-	uint32_t reserved_22_31               : 10;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg452_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg452_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg452 cvmx_pcieepvfx_cfg452_t;
-
-/**
- * cvmx_pcieepvf#_cfg453
- *
- * This register contains the four hundred fifty-fourth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg453 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg453_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t dlld                         : 1;  /**< Disable lane-to-lane deskew. Disables the internal lane-to-lane deskew logic. */
-	uint32_t reserved_26_30               : 5;
-	uint32_t ack_nak                      : 1;  /**< Ack/Nak disable. Prevents the PCI Express bus from sending Ack and Nak DLLPs. */
-	uint32_t fcd                          : 1;  /**< Flow control disable. Prevents the PCI Express bus from sending FC DLLPs. */
-	uint32_t ilst                         : 24; /**< Insert lane skew for transmit. Causes skew between lanes for test purposes. There are
-                                                         three bits per lane. The value is in units of one symbol time. For example, the value 010b
-                                                         for a lane forces a skew of two symbol times for that lane. The maximum skew value for any
-                                                         lane is 5 symbol times. */
-#else
-	uint32_t ilst                         : 24;
-	uint32_t fcd                          : 1;
-	uint32_t ack_nak                      : 1;
-	uint32_t reserved_26_30               : 5;
-	uint32_t dlld                         : 1;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg453_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg453_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg453 cvmx_pcieepvfx_cfg453_t;
-
-/**
- * cvmx_pcieepvf#_cfg454
- *
- * This register contains the four hundred fifty-fifth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg454 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg454_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_29_31               : 3;
-	uint32_t tmfcwt                       : 5;  /**< Used to be 'timer modifier for flow control watchdog timer.' This field is no longer used.
-                                                         and has moved to the queue status register -- PCIEEP()_CFG463. This field remains to
-                                                         prevent software from breaking. */
-	uint32_t tmanlt                       : 5;  /**< Timer modifier for Ack/Nak latency timer. Increases the timer value for the Ack/Nak
-                                                         latency timer, in increments of 64 clock cycles. */
-	uint32_t tmrt                         : 5;  /**< Timer modifier for replay timer. Increases the timer value for the replay timer, in
-                                                         increments of 64 clock cycles. */
-	uint32_t reserved_8_13                : 6;
-	uint32_t mfuncn                       : 8;  /**< Max number of functions supported. */
-#else
-	uint32_t mfuncn                       : 8;
-	uint32_t reserved_8_13                : 6;
-	uint32_t tmrt                         : 5;
-	uint32_t tmanlt                       : 5;
-	uint32_t tmfcwt                       : 5;
-	uint32_t reserved_29_31               : 3;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg454_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg454_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg454 cvmx_pcieepvfx_cfg454_t;
-
-/**
- * cvmx_pcieepvf#_cfg455
- *
- * This register contains the four hundred fifty-sixth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg455 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg455_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t m_cfg0_filt                  : 1;  /**< Mask filtering of received configuration requests (RC mode only). */
-	uint32_t m_io_filt                    : 1;  /**< Mask filtering of received I/O requests (RC mode only). */
-	uint32_t msg_ctrl                     : 1;  /**< Message control. The application must not change this field. */
-	uint32_t m_cpl_ecrc_filt              : 1;  /**< Mask ECRC error filtering for completions. */
-	uint32_t m_ecrc_filt                  : 1;  /**< Mask ECRC error filtering. */
-	uint32_t m_cpl_len_err                : 1;  /**< Mask length mismatch error for received completions. */
-	uint32_t m_cpl_attr_err               : 1;  /**< Mask attributes mismatch error for received completions. */
-	uint32_t m_cpl_tc_err                 : 1;  /**< Mask traffic class mismatch error for received completions. */
-	uint32_t m_cpl_fun_err                : 1;  /**< Mask function mismatch error for received completions. */
-	uint32_t m_cpl_rid_err                : 1;  /**< Mask requester ID mismatch error for received completions. */
-	uint32_t m_cpl_tag_err                : 1;  /**< Mask tag error rules for received completions. */
-	uint32_t m_lk_filt                    : 1;  /**< Mask locked request filtering. */
-	uint32_t m_cfg1_filt                  : 1;  /**< Mask type 1 configuration request filtering. */
-	uint32_t m_bar_match                  : 1;  /**< Mask BAR match filtering. */
-	uint32_t m_pois_filt                  : 1;  /**< Mask poisoned TLP filtering. */
-	uint32_t m_fun                        : 1;  /**< Mask function. */
-	uint32_t dfcwt                        : 1;  /**< Disable FC watchdog timer. */
-	uint32_t reserved_11_14               : 4;
-	uint32_t skpiv                        : 11; /**< SKP interval value. */
-#else
-	uint32_t skpiv                        : 11;
-	uint32_t reserved_11_14               : 4;
-	uint32_t dfcwt                        : 1;
-	uint32_t m_fun                        : 1;
-	uint32_t m_pois_filt                  : 1;
-	uint32_t m_bar_match                  : 1;
-	uint32_t m_cfg1_filt                  : 1;
-	uint32_t m_lk_filt                    : 1;
-	uint32_t m_cpl_tag_err                : 1;
-	uint32_t m_cpl_rid_err                : 1;
-	uint32_t m_cpl_fun_err                : 1;
-	uint32_t m_cpl_tc_err                 : 1;
-	uint32_t m_cpl_attr_err               : 1;
-	uint32_t m_cpl_len_err                : 1;
-	uint32_t m_ecrc_filt                  : 1;
-	uint32_t m_cpl_ecrc_filt              : 1;
-	uint32_t msg_ctrl                     : 1;
-	uint32_t m_io_filt                    : 1;
-	uint32_t m_cfg0_filt                  : 1;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg455_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg455_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg455 cvmx_pcieepvfx_cfg455_t;
-
-/**
- * cvmx_pcieepvf#_cfg456
- *
- * This register contains the four hundred fifty-seventh 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg456 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg456_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_4_31                : 28;
-	uint32_t m_handle_flush               : 1;  /**< Mask core filter to handle flush request. */
-	uint32_t m_dabort_4ucpl               : 1;  /**< Mask DLLP abort for unexpected CPL. */
-	uint32_t m_vend1_drp                  : 1;  /**< Mask vendor MSG type 1 dropped silently. */
-	uint32_t m_vend0_drp                  : 1;  /**< Mask vendor MSG type 0 dropped with UR error reporting. */
-#else
-	uint32_t m_vend0_drp                  : 1;
-	uint32_t m_vend1_drp                  : 1;
-	uint32_t m_dabort_4ucpl               : 1;
-	uint32_t m_handle_flush               : 1;
-	uint32_t reserved_4_31                : 28;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg456_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg456_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg456 cvmx_pcieepvfx_cfg456_t;
-
-/**
- * cvmx_pcieepvf#_cfg458
- *
- * This register contains the four hundred fifty-ninth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg458 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg458_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t dbg_info_l32                 : 32; /**< Debug info lower 32 bits. */
-#else
-	uint32_t dbg_info_l32                 : 32;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg458_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg458_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg458 cvmx_pcieepvfx_cfg458_t;
-
-/**
- * cvmx_pcieepvf#_cfg459
- *
- * This register contains the four hundred sixtieth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg459 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg459_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t dbg_info_u32                 : 32; /**< Debug info upper 32 bits. */
-#else
-	uint32_t dbg_info_u32                 : 32;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg459_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg459_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg459 cvmx_pcieepvfx_cfg459_t;
-
-/**
- * cvmx_pcieepvf#_cfg460
- *
- * This register contains the four hundred sixty-first 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg460 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg460_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_20_31               : 12;
-	uint32_t tphfcc                       : 8;  /**< Transmit posted header FC Credits. The posted header credits advertised by the receiver at
-                                                         the other end of the link, updated with each UpdateFC DLLP. */
-	uint32_t tpdfcc                       : 12; /**< Transmit posted data FC credits. The posted data credits advertised by the receiver at the
-                                                         other end of the link, updated with each UpdateFC DLLP. */
-#else
-	uint32_t tpdfcc                       : 12;
-	uint32_t tphfcc                       : 8;
-	uint32_t reserved_20_31               : 12;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg460_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg460_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg460 cvmx_pcieepvfx_cfg460_t;
-
-/**
- * cvmx_pcieepvf#_cfg461
- *
- * This register contains the four hundred sixty-second 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg461 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg461_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_20_31               : 12;
-	uint32_t tchfcc                       : 8;  /**< Transmit nonposted header FC credits. The nonposted header credits advertised by the
-                                                         receiver at the other end of the link, updated with each UpdateFC DLLP. */
-	uint32_t tcdfcc                       : 12; /**< Transmit nonposted data FC credits. The nonposted data credits advertised by the receiver
-                                                         at the other end of the link, updated with each UpdateFC DLLP. */
-#else
-	uint32_t tcdfcc                       : 12;
-	uint32_t tchfcc                       : 8;
-	uint32_t reserved_20_31               : 12;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg461_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg461_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg461 cvmx_pcieepvfx_cfg461_t;
-
-/**
- * cvmx_pcieepvf#_cfg462
- *
- * This register contains the four hundred sixty-third 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg462 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg462_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_20_31               : 12;
-	uint32_t tchfcc                       : 8;  /**< Transmit completion header FC credits. The completion header credits advertised by the
-                                                         receiver at the other end of the link, updated with each UpdateFC DLLP. */
-	uint32_t tcdfcc                       : 12; /**< Transmit completion data FC credits. The completion data credits advertised by the
-                                                         receiver at the other end of the link, updated with each UpdateFC DLLP. */
-#else
-	uint32_t tcdfcc                       : 12;
-	uint32_t tchfcc                       : 8;
-	uint32_t reserved_20_31               : 12;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg462_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg462_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg462 cvmx_pcieepvfx_cfg462_t;
-
-/**
- * cvmx_pcieepvf#_cfg463
- *
- * This register contains the four hundred sixty-fourth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg463 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg463_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t fcltoe                       : 1;  /**< FC latency timer override enable. When this bit is set, the value from
-                                                         PCIEEPVF()_CFG463[FCLTOV] will override the FC latency timer value that the core
-                                                         calculates according to the PCIe specification. */
-	uint32_t reserved_29_30               : 2;
-	uint32_t fcltov                       : 13; /**< FC latency timer override value. When you set PCIEEPVF()_CFG463[FCLTOE], the value in
-                                                         this
-                                                         field will override the FC latency timer value that the core calculates according to the
-                                                         PCIe specification. */
-	uint32_t reserved_3_15                : 13;
-	uint32_t rqne                         : 1;  /**< Received queue not empty. Indicates there is data in one or more of the receive buffers. */
-	uint32_t trbne                        : 1;  /**< Transmit retry buffer not empty. Indicates that there is data in the transmit retry buffer. */
-	uint32_t rtlpfccnr                    : 1;  /**< Received TLP FC credits not returned. Indicates that the PCI Express bus has sent a TLP
-                                                         but has not yet received an UpdateFC DLLP indicating that the credits for that TLP have
-                                                         been restored by the receiver at the other end of the link. */
-#else
-	uint32_t rtlpfccnr                    : 1;
-	uint32_t trbne                        : 1;
-	uint32_t rqne                         : 1;
-	uint32_t reserved_3_15                : 13;
-	uint32_t fcltov                       : 13;
-	uint32_t reserved_29_30               : 2;
-	uint32_t fcltoe                       : 1;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg463_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg463_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg463 cvmx_pcieepvfx_cfg463_t;
-
-/**
- * cvmx_pcieepvf#_cfg464
- *
- * This register contains the four hundred sixty-fifth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg464 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg464_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t wrr_vc3                      : 8;  /**< WRR Weight for VC3. */
-	uint32_t wrr_vc2                      : 8;  /**< WRR Weight for VC2. */
-	uint32_t wrr_vc1                      : 8;  /**< WRR Weight for VC1. */
-	uint32_t wrr_vc0                      : 8;  /**< WRR Weight for VC0. */
-#else
-	uint32_t wrr_vc0                      : 8;
-	uint32_t wrr_vc1                      : 8;
-	uint32_t wrr_vc2                      : 8;
-	uint32_t wrr_vc3                      : 8;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg464_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg464_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg464 cvmx_pcieepvfx_cfg464_t;
-
-/**
- * cvmx_pcieepvf#_cfg465
- *
- * This register contains the four hundred sixty-sixth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg465 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg465_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t wrr_vc7                      : 8;  /**< WRR Weight for VC7. */
-	uint32_t wrr_vc6                      : 8;  /**< WRR Weight for VC6. */
-	uint32_t wrr_vc5                      : 8;  /**< WRR Weight for VC5. */
-	uint32_t wrr_vc4                      : 8;  /**< WRR Weight for VC4. */
-#else
-	uint32_t wrr_vc4                      : 8;
-	uint32_t wrr_vc5                      : 8;
-	uint32_t wrr_vc6                      : 8;
-	uint32_t wrr_vc7                      : 8;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg465_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg465_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg465 cvmx_pcieepvfx_cfg465_t;
-
-/**
- * cvmx_pcieepvf#_cfg466
- *
- * This register contains the four hundred sixty-seventh 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg466 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg466_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t rx_queue_order               : 1;  /**< VC ordering for receive queues. Determines the VC ordering rule for the receive queues,
-                                                         used only in the segmented-buffer configuration, writable through PEM()_CFG_WR:
-                                                         0 = Round robin.
-                                                         1 = Strict ordering, higher numbered VCs have higher priority. */
-	uint32_t type_ordering                : 1;  /**< TLP type ordering for VC0. Determines the TLP type ordering rule for VC0 receive queues,
-                                                         used only in the segmented-buffer configuration:
-                                                         0 = Strict ordering for received TLPs: Posted, then Completion, then Nonposted.
-                                                         1 = Ordering of received TLPs follows the rules in PCI Express Base Specification */
-	uint32_t reserved_24_29               : 6;
-	uint32_t queue_mode                   : 3;  /**< VC0 posted TLP queue mode. The operating mode of the posted receive queue for VC0, used
-                                                         only in the segmented-buffer configuration, writable through PEM()_CFG_WR.
-                                                         However, the application must not change this field.
-                                                         Only one bit can be set at a time:
-                                                         _ Bit 23 = Bypass.
-                                                         _ Bit 22 = Cut-through.
-                                                         _ Bit 21 = Store-and-forward. */
-	uint32_t reserved_20_20               : 1;
-	uint32_t header_credits               : 8;  /**< VC0 posted header credits. The number of initial posted header credits for VC0, used for
-                                                         all receive queue buffer configurations. */
-	uint32_t data_credits                 : 12; /**< VC0 posted data credits. The number of initial posted data credits for VC0, used for all
-                                                         receive queue buffer configurations. */
-#else
-	uint32_t data_credits                 : 12;
-	uint32_t header_credits               : 8;
-	uint32_t reserved_20_20               : 1;
-	uint32_t queue_mode                   : 3;
-	uint32_t reserved_24_29               : 6;
-	uint32_t type_ordering                : 1;
-	uint32_t rx_queue_order               : 1;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg466_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg466_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg466 cvmx_pcieepvfx_cfg466_t;
-
-/**
- * cvmx_pcieepvf#_cfg467
- *
- * This register contains the four hundred sixty-eighth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg467 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg467_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_24_31               : 8;
-	uint32_t queue_mode                   : 3;  /**< VC0 nonposted TLP queue mode. The operating mode of the nonposted receive queue for VC0,
-                                                         used only in the segmented-buffer configuration. This field is writable through
-                                                         PEM()_CFG_WR. However, the application must not change this field.
-                                                         Only one bit can be set at a time:
-                                                         _ Bit 23 = Bypass.
-                                                         _ Bit 22 = Cut-through.
-                                                         _ Bit 21 = Store-and-forward. */
-	uint32_t reserved_20_20               : 1;
-	uint32_t header_credits               : 8;  /**< VC0 nonposted header credits. The number of initial nonposted header credits for VC0, used
-                                                         for all receive queue buffer configurations. This field is writable through
-                                                         PEM()_CFG_WR. However, the application must not change this field. */
-	uint32_t data_credits                 : 12; /**< VC0 non-posted data credits. The number of initial nonposted data credits for VC0, used
-                                                         for all receive queue buffer configurations. This field is writable through
-                                                         PEM()_CFG_WR. However, the application must not change this field. */
-#else
-	uint32_t data_credits                 : 12;
-	uint32_t header_credits               : 8;
-	uint32_t reserved_20_20               : 1;
-	uint32_t queue_mode                   : 3;
-	uint32_t reserved_24_31               : 8;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg467_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg467_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg467 cvmx_pcieepvfx_cfg467_t;
-
-/**
- * cvmx_pcieepvf#_cfg468
- *
- * This register contains the four hundred sixty-ninth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg468 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg468_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_24_31               : 8;
-	uint32_t queue_mode                   : 3;  /**< VC0 completion TLP queue mode. The operating mode of the completion receive queue for VC0,
-                                                         used only in the segmented-buffer configuration.
-                                                         Only one bit can be set at a time:
-                                                         Bit 23 = Bypass
-                                                         Bit 22 = Cut-through
-                                                         Bit 21 = Store-and-forward
-                                                         This field is writable through PEM()_CFG_WR. However, the application must not change
-                                                         this field. */
-	uint32_t reserved_20_20               : 1;
-	uint32_t header_credits               : 8;  /**< VC0 completion header credits. The number of initial completion header credits for VC0,
-                                                         used for all receive queue buffer configurations. This field is writable through
-                                                         PEM()_CFG_WR. However, the application must not change this field. */
-	uint32_t data_credits                 : 12; /**< VC0 completion data credits. The number of initial completion data credits for VC0, used
-                                                         for all receive queue buffer configurations. This field is writable through
-                                                         PEM()_CFG_WR. However, the application must not change this field. */
-#else
-	uint32_t data_credits                 : 12;
-	uint32_t header_credits               : 8;
-	uint32_t reserved_20_20               : 1;
-	uint32_t queue_mode                   : 3;
-	uint32_t reserved_24_31               : 8;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg468_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg468_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg468 cvmx_pcieepvfx_cfg468_t;
-
-/**
- * cvmx_pcieepvf#_cfg490
- *
- * This register contains the four hundred ninety-first 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg490 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg490_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_26_31               : 6;
-	uint32_t header_depth                 : 10; /**< VC0 posted header queue depth. Sets the number of entries in the posted header queue for
-                                                         VC0 when using the segmented-buffer configuration. */
-	uint32_t reserved_14_15               : 2;
-	uint32_t data_depth                   : 14; /**< VC0 posted data queue depth. Sets the number of entries in the posted data queue for VC0
-                                                         when using the segmented-buffer configuration. */
-#else
-	uint32_t data_depth                   : 14;
-	uint32_t reserved_14_15               : 2;
-	uint32_t header_depth                 : 10;
-	uint32_t reserved_26_31               : 6;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg490_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg490_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg490 cvmx_pcieepvfx_cfg490_t;
-
-/**
- * cvmx_pcieepvf#_cfg491
- *
- * This register contains the four hundred ninety-second 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg491 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg491_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_26_31               : 6;
-	uint32_t header_depth                 : 10; /**< VC0 nonposted header queue depth. Sets the number of entries in the nonposted header queue
-                                                         for VC0 when using the segmented-buffer configuration. */
-	uint32_t reserved_14_15               : 2;
-	uint32_t data_depth                   : 14; /**< VC0 nonposted data queue depth. Sets the number of entries in the nonposted data queue for
-                                                         VC0 when using the segmented-buffer configuration. */
-#else
-	uint32_t data_depth                   : 14;
-	uint32_t reserved_14_15               : 2;
-	uint32_t header_depth                 : 10;
-	uint32_t reserved_26_31               : 6;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg491_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg491_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg491 cvmx_pcieepvfx_cfg491_t;
-
-/**
- * cvmx_pcieepvf#_cfg492
- *
- * This register contains the four hundred ninety-third 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg492 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg492_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_26_31               : 6;
-	uint32_t header_depth                 : 10; /**< VC0 completion header queue depth. Sets the number of entries in the completion header
-                                                         queue for VC0 when using the segmented-buffer configuration. */
-	uint32_t reserved_14_15               : 2;
-	uint32_t data_depth                   : 14; /**< VC0 completion data queue depth. Sets the number of entries in the completion data queue
-                                                         for VC0 when using the segmented-buffer configuration. */
-#else
-	uint32_t data_depth                   : 14;
-	uint32_t reserved_14_15               : 2;
-	uint32_t header_depth                 : 10;
-	uint32_t reserved_26_31               : 6;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg492_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg492_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg492 cvmx_pcieepvfx_cfg492_t;
-
-/**
- * cvmx_pcieepvf#_cfg515
- *
- * This register contains the five hundred sixteenth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg515 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg515_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t reserved_21_31               : 11;
-	uint32_t s_d_e                        : 1;  /**< SEL_DE_EMPHASIS. Used to set the deemphasis level for upstream ports. */
-	uint32_t ctcrb                        : 1;  /**< Config Tx compliance receive bit. When set to 1, signals LTSSM to transmit TS ordered sets
-                                                         with the compliance receive bit assert (equal to 1). */
-	uint32_t cpyts                        : 1;  /**< Config PHY Tx swing. Indicates the voltage level that the PHY should drive. When set to 1,
-                                                         indicates full swing. When set to 0, indicates low swing. */
-	uint32_t dsc                          : 1;  /**< Directed speed change. A write of 1 initiates a speed change; always reads as zero. */
-	uint32_t le                           : 9;  /**< Lane enable. Indicates the number of lanes to check for exit from electrical idle in
-                                                         Polling.Active and Polling.Compliance. 0x1 = x1, 0x2 = x2, etc. Used to limit the maximum
-                                                         link width to ignore broken lanes that detect a receiver, but will not exit electrical
-                                                         idle and would otherwise prevent a valid link from being configured. */
-	uint32_t n_fts                        : 8;  /**< N_FTS. Sets the number of fast training sequences (N_FTS) that the core advertises as its
-                                                         N_FTS during GEN2 Link training. This value is used to inform the link partner about the
-                                                         PHY's ability to recover synchronization after a low power state.
-                                                         Do not set N_FTS to zero; doing so can cause the LTSSM to go into the recovery state when
-                                                         exiting from L0s. */
-#else
-	uint32_t n_fts                        : 8;
-	uint32_t le                           : 9;
-	uint32_t dsc                          : 1;
-	uint32_t cpyts                        : 1;
-	uint32_t ctcrb                        : 1;
-	uint32_t s_d_e                        : 1;
-	uint32_t reserved_21_31               : 11;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg515_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg515_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg515 cvmx_pcieepvfx_cfg515_t;
-
-/**
- * cvmx_pcieepvf#_cfg516
- *
- * This register contains the five hundred seventeenth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg516 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg516_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t phy_stat                     : 32; /**< PHY status. */
-#else
-	uint32_t phy_stat                     : 32;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg516_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg516_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg516 cvmx_pcieepvfx_cfg516_t;
-
-/**
- * cvmx_pcieepvf#_cfg517
- *
- * This register contains the five hundred eighteenth 32-bits of PCIe type 0 configuration space.
- *
- */
-union cvmx_pcieepvfx_cfg517 {
-	uint32_t u32;
-	struct cvmx_pcieepvfx_cfg517_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t phy_ctrl                     : 32; /**< PHY control. */
-#else
-	uint32_t phy_ctrl                     : 32;
-#endif
-	} s;
-	struct cvmx_pcieepvfx_cfg517_s        cn78xx;
-	struct cvmx_pcieepvfx_cfg517_s        cn78xxp2;
-};
-typedef union cvmx_pcieepvfx_cfg517 cvmx_pcieepvfx_cfg517_t;
-
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index b6bbda5..07656ce 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -69,8 +69,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long offset)
 				return 0x0000030000000000ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000000ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000000ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000000ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -100,7 +105,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000000ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000000ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000000ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000000ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -131,8 +140,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long offset)
 				return 0x0000030000000004ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000004ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000004ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000004ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -162,7 +176,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000004ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000004ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000004ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000004ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -193,8 +211,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long offset)
 				return 0x0000030000000008ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000008ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000008ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000008ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -224,7 +247,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000008ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000008ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000008ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000008ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -255,8 +282,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long offset)
 				return 0x000003000000000Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000000Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000000Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000000Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -286,7 +318,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000000Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000000Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000000Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000000Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -317,8 +353,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long offset)
 				return 0x0000030000000010ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000010ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000010ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000010ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -348,7 +389,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000010ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000010ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000010ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -379,8 +424,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long offset)
 				return 0x0000030080000010ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030080000010ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030080000010ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030080000010ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -410,7 +460,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000010ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030080000010ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030080000010ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -441,8 +495,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long offset)
 				return 0x0000030000000014ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000014ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000014ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000014ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -472,7 +531,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000014ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000014ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000014ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -503,8 +566,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long offset)
 				return 0x0000030080000014ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030080000014ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030080000014ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030080000014ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -534,7 +602,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000014ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030080000014ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030080000014ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -565,8 +637,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long offset)
 				return 0x0000030000000018ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000018ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000018ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000018ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -596,7 +673,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000018ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000018ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000018ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -627,8 +708,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long offset)
 				return 0x0000030080000018ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030080000018ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030080000018ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030080000018ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -658,7 +744,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000018ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030080000018ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030080000018ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -689,8 +779,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long offset)
 				return 0x000003000000001Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000001Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000001Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000001Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -720,7 +815,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000001Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000001Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000001Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -751,8 +850,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long offset)
 				return 0x000003008000001Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003008000001Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003008000001Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003008000001Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -782,7 +886,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003008000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003008000001Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003008000001Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003008000001Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -813,8 +921,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long offset)
 				return 0x0000030000000020ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000020ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000020ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000020ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -844,7 +957,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000020ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000020ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000020ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -875,8 +992,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long offset)
 				return 0x0000030080000020ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030080000020ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030080000020ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030080000020ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -906,7 +1028,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000020ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030080000020ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030080000020ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -937,8 +1063,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long offset)
 				return 0x0000030000000024ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000024ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000024ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000024ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -968,7 +1099,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000024ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000024ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000024ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -999,8 +1134,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long offset)
 				return 0x0000030080000024ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030080000024ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030080000024ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030080000024ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1030,7 +1170,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000024ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030080000024ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030080000024ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1061,8 +1205,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long offset)
 				return 0x0000030000000028ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000028ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000028ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000028ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1092,7 +1241,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000028ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000028ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000028ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000028ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1123,8 +1276,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long offset)
 				return 0x000003000000002Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000002Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000002Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000002Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1154,7 +1312,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000002Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000002Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000002Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000002Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1185,8 +1347,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long offset)
 				return 0x0000030000000030ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000030ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000030ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000030ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1216,7 +1383,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000030ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000030ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000030ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1247,8 +1418,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long offset)
 				return 0x0000030080000030ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030080000030ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030080000030ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030080000030ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1278,7 +1454,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030080000030ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030080000030ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030080000030ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1309,8 +1489,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long offset)
 				return 0x0000030000000034ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000034ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000034ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000034ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1340,7 +1525,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000034ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000034ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000034ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000034ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1371,8 +1560,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long offset)
 				return 0x000003000000003Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000003Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000003Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000003Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1402,7 +1596,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000003Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000003Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000003Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000003Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1433,8 +1631,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long offset)
 				return 0x0000030000000040ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000040ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000040ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000040ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1464,7 +1667,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000040ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000040ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000040ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000040ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1495,8 +1702,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long offset)
 				return 0x0000030000000044ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000044ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000044ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000044ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1526,7 +1738,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000044ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000044ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000044ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000044ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1557,8 +1773,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long offset)
 				return 0x0000030000000050ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000050ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000050ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000050ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1588,7 +1809,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000050ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000050ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000050ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000050ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1619,8 +1844,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long offset)
 				return 0x0000030000000054ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000054ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000054ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000054ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1650,7 +1880,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000054ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000054ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000054ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000054ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1681,8 +1915,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long offset)
 				return 0x0000030000000058ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000058ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000058ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000058ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1712,7 +1951,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000058ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000058ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000058ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000058ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1743,8 +1986,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long offset)
 				return 0x000003000000005Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000005Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000005Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000005Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1774,7 +2022,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000005Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000005Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000005Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000005Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1794,6 +2046,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG024(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG024(%lu) is invalid on this chip\n", offset);
@@ -1808,6 +2061,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG025(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG025(%lu) is invalid on this chip\n", offset);
@@ -1833,8 +2087,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long offset)
 				return 0x0000030000000070ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000070ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000070ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000070ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1864,7 +2123,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000070ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000070ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000070ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000070ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1895,8 +2158,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long offset)
 				return 0x0000030000000074ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000074ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000074ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000074ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1926,7 +2194,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000074ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000074ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000074ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000074ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -1957,8 +2229,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long offset)
 				return 0x0000030000000078ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000078ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000078ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000078ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -1988,7 +2265,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000078ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000078ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000078ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000078ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2019,8 +2300,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long offset)
 				return 0x000003000000007Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000007Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000007Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000007Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2050,7 +2336,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000007Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000007Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000007Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000007Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2081,8 +2371,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long offset)
 				return 0x0000030000000080ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000080ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000080ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000080ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2112,7 +2407,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000080ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000080ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000080ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000080ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2169,8 +2468,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long offset)
 				return 0x0000030000000094ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000094ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000094ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000094ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2200,7 +2504,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000094ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000094ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000094ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000094ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2231,8 +2539,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long offset)
 				return 0x0000030000000098ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000098ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000098ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000098ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2262,7 +2575,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000098ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000098ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000098ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000098ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2293,8 +2610,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long offset)
 				return 0x000003000000009Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000009Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000009Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000009Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2324,7 +2646,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000009Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000009Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000009Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000009Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2355,8 +2681,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long offset)
 				return 0x00000300000000A0ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x00000300000000A0ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x00000300000000A0ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x00000300000000A0ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2386,7 +2717,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x00000300000000A0ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x00000300000000A0ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000300000000A0ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000300000000A0ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2431,6 +2766,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG044(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG044(%lu) is invalid on this chip\n", offset);
@@ -2444,6 +2780,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG045(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG045(%lu) is invalid on this chip\n", offset);
@@ -2457,6 +2794,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG046(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG046(%lu) is invalid on this chip\n", offset);
@@ -2482,8 +2820,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long offset)
 				return 0x0000030000000100ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000100ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000100ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000100ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2513,7 +2856,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000100ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000100ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000100ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000100ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2544,8 +2891,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long offset)
 				return 0x0000030000000104ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000104ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000104ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000104ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2575,7 +2927,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000104ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000104ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000104ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000104ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2606,8 +2962,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long offset)
 				return 0x0000030000000108ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000108ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000108ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000108ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2637,7 +2998,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000108ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000108ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000108ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000108ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2668,8 +3033,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long offset)
 				return 0x000003000000010Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000010Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000010Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000010Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2699,7 +3069,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000010Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000010Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000010Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000010Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2730,8 +3104,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long offset)
 				return 0x0000030000000110ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000110ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000110ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000110ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2761,7 +3140,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000110ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000110ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000110ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000110ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2792,8 +3175,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long offset)
 				return 0x0000030000000114ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000114ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000114ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000114ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2823,7 +3211,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000114ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000114ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000114ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000114ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2854,8 +3246,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long offset)
 				return 0x0000030000000118ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000118ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000118ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000118ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2885,7 +3282,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000118ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000118ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000118ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000118ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2916,8 +3317,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long offset)
 				return 0x000003000000011Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000011Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000011Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000011Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -2947,7 +3353,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000011Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000011Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000011Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000011Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -2978,8 +3388,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long offset)
 				return 0x0000030000000120ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000120ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000120ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000120ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3009,7 +3424,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000120ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000120ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000120ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000120ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -3040,8 +3459,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long offset)
 				return 0x0000030000000124ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000124ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000124ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000124ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3071,7 +3495,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000124ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000124ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000124ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000124ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -3102,8 +3530,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long offset)
 				return 0x0000030000000128ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000128ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000128ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000128ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3133,7 +3566,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000128ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000128ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000128ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000128ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -3152,6 +3589,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG078(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG078(%lu) is invalid on this chip\n", offset);
@@ -3166,6 +3604,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG082(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG082(%lu) is invalid on this chip\n", offset);
@@ -3180,6 +3619,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG083(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG083(%lu) is invalid on this chip\n", offset);
@@ -3204,6 +3644,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG086(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG086(%lu) is invalid on this chip\n", offset);
@@ -3217,6 +3658,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG087(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG087(%lu) is invalid on this chip\n", offset);
@@ -3230,6 +3672,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG088(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG088(%lu) is invalid on this chip\n", offset);
@@ -3243,6 +3686,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG089(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG089(%lu) is invalid on this chip\n", offset);
@@ -3256,6 +3700,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG090(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG090(%lu) is invalid on this chip\n", offset);
@@ -3269,6 +3714,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG091(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG091(%lu) is invalid on this chip\n", offset);
@@ -3282,6 +3728,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG092(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG092(%lu) is invalid on this chip\n", offset);
@@ -3295,6 +3742,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG094(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG094(%lu) is invalid on this chip\n", offset);
@@ -3308,6 +3756,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG095(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG095(%lu) is invalid on this chip\n", offset);
@@ -3321,6 +3770,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG096(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG096(%lu) is invalid on this chip\n", offset);
@@ -3334,6 +3784,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG097(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG097(%lu) is invalid on this chip\n", offset);
@@ -3347,6 +3798,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG098(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG098(%lu) is invalid on this chip\n", offset);
@@ -3360,6 +3812,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG099(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG099(%lu) is invalid on this chip\n", offset);
@@ -3373,6 +3826,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG100(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG100(%lu) is invalid on this chip\n", offset);
@@ -3386,6 +3840,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG101(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG101(%lu) is invalid on this chip\n", offset);
@@ -3399,6 +3854,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG102(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG102(%lu) is invalid on this chip\n", offset);
@@ -3412,6 +3868,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG103(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG103(%lu) is invalid on this chip\n", offset);
@@ -3425,6 +3882,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG104(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG104(%lu) is invalid on this chip\n", offset);
@@ -3438,6 +3896,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG105(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG105(%lu) is invalid on this chip\n", offset);
@@ -3451,6 +3910,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG106(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG106(%lu) is invalid on this chip\n", offset);
@@ -3464,6 +3924,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG107(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG107(%lu) is invalid on this chip\n", offset);
@@ -3477,6 +3938,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG108(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG108(%lu) is invalid on this chip\n", offset);
@@ -3490,6 +3952,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG109(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG109(%lu) is invalid on this chip\n", offset);
@@ -3503,6 +3966,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG110(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG110(%lu) is invalid on this chip\n", offset);
@@ -3516,6 +3980,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG111(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG111(%lu) is invalid on this chip\n", offset);
@@ -3529,6 +3994,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG112(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG112(%lu) is invalid on this chip\n", offset);
@@ -3554,8 +4020,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long offset)
 				return 0x0000030000000700ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000700ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000700ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000700ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3585,7 +4056,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000700ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000700ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000700ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000700ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -3616,8 +4091,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long offset)
 				return 0x0000030000000704ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000704ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000704ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000704ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3647,7 +4127,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000704ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000704ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000704ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000704ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -3678,8 +4162,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long offset)
 				return 0x0000030000000708ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000708ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000708ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000708ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3709,7 +4198,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000708ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000708ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000708ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000708ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -3740,8 +4233,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long offset)
 				return 0x000003000000070Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000070Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000070Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000070Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3771,7 +4269,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000070Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000070Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000070Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000070Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -3802,8 +4304,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long offset)
 				return 0x0000030000000710ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000710ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000710ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000710ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3833,7 +4340,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000710ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000710ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000710ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000710ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -3864,8 +4375,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long offset)
 				return 0x0000030000000714ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000714ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000714ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000714ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3895,7 +4411,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000714ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000714ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000714ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000714ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -3926,8 +4446,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long offset)
 				return 0x0000030000000718ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000718ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000718ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000718ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -3957,7 +4482,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000718ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000718ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000718ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000718ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -3988,8 +4517,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long offset)
 				return 0x000003000000071Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000071Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000071Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000071Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4019,7 +4553,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000071Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000071Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000071Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000071Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -4050,8 +4588,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long offset)
 				return 0x0000030000000720ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000720ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000720ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000720ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4081,7 +4624,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000720ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000720ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000720ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000720ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -4112,8 +4659,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long offset)
 				return 0x0000030000000728ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000728ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000728ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000728ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4143,7 +4695,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000728ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000728ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000728ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000728ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -4174,8 +4730,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long offset)
 				return 0x000003000000072Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000072Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000072Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000072Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4205,7 +4766,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000072Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000072Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000072Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000072Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -4236,8 +4801,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long offset)
 				return 0x0000030000000730ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000730ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000730ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000730ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4267,7 +4837,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000730ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000730ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000730ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000730ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -4298,8 +4872,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long offset)
 				return 0x0000030000000734ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000734ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000734ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000734ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4329,7 +4908,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000734ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000734ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000734ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000734ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -4360,8 +4943,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long offset)
 				return 0x0000030000000738ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000738ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000738ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000738ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4391,7 +4979,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000738ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000738ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000738ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000738ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -4422,8 +5014,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long offset)
 				return 0x000003000000073Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000073Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000073Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000073Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4453,7 +5050,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000073Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000073Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000073Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000073Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -4484,8 +5085,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long offset)
 				return 0x0000030000000740ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000740ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000740ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000740ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4515,7 +5121,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000740ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000740ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000740ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000740ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -4546,8 +5156,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long offset)
 				return 0x0000030000000744ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000744ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000744ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000744ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4577,7 +5192,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000744ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000744ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000744ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000744ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -4608,8 +5227,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long offset)
 				return 0x0000030000000748ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000748ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000748ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000748ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4639,7 +5263,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000748ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000748ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000748ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000748ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -4670,8 +5298,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long offset)
 				return 0x000003000000074Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000074Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000074Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000074Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4701,7 +5334,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000074Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000074Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000074Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000074Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -4732,8 +5369,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long offset)
 				return 0x0000030000000750ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000750ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000750ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000750ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4763,7 +5405,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000750ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000750ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000750ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000750ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -4926,8 +5572,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long offset)
 				return 0x000003000000080Cull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000003000000080Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000003000000080Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000003000000080Cull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4952,7 +5603,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000080Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x000003000000080Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000003000000080Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000003000000080Cull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -4980,8 +5635,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long offset)
 				return 0x0000030000000810ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000810ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000810ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000810ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -5011,7 +5671,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000810ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000810ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000810ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000810ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -5042,8 +5706,13 @@ static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long offset)
 				return 0x0000030000000814ull + ((offset) & 7) * 0x100000000ull;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000030000000814ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000030000000814ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000030000000814ull + ((offset) & 3) * 0x100000000ull;
+
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -5073,7 +5742,11 @@ static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000814ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000030000000814ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000030000000814ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000030000000814ull + (offset) * 0x100000000ull;
+
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
@@ -5092,6 +5765,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG548(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG548(%lu) is invalid on this chip\n", offset);
@@ -5105,6 +5779,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG554(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG554(%lu) is invalid on this chip\n", offset);
@@ -5118,6 +5793,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG558(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG558(%lu) is invalid on this chip\n", offset);
@@ -5466,7 +6142,7 @@ union cvmx_pcieepx_cfg004 {
 	uint32_t lbab                         : 17;
 #endif
 	} cn78xx;
-	struct cvmx_pcieepx_cfg004_cn78xx     cn78xxp2;
+	struct cvmx_pcieepx_cfg004_cn73xx     cn78xxp2;
 	struct cvmx_pcieepx_cfg004_cn52xx     cnf71xx;
 	struct cvmx_pcieepx_cfg004_cn73xx     cnf75xx;
 };
@@ -6970,18 +7646,25 @@ union cvmx_pcieepx_cfg031 {
                                                          must not change this field. */
 	uint32_t mlw                          : 6;  /**< Maximum link width.
                                                          The reset value of this field is determined by the value read from the PEM
-                                                         csr PEM()_CFG[LANES8] and PEM()_QLM[PEMDLMSEL]. If PEMDLMSEL is set, the reset
-                                                         value is 0x2.  If PEMDLMSEL is set and LANES8 is set the reset value is 0x4, otherwise
-                                                         0x8.
-                                                         This field is writable through PEM()_CFG_WR. */
+                                                         csr PEM()_CFG[LANES4]. If LANES4 is set the reset value is 0x4, otherwise 0x2.
+                                                         This field is writable through PEM()_CFG_WR.
+                                                         Zeroing both [MLW] and [MLS] out of reset, using the EEPROM, will prevent the
+                                                         link state machine from advancing past CONFIG.  This can be useful to allow
+                                                         software to locally boot and perform preconfiguration and bug fixes.  Setting
+                                                         [MLW] and [MLS] to non-zero values will then allow the lttsm to advance and the
+                                                         link to come up. */
 	uint32_t mls                          : 4;  /**< Maximum link speed. The reset value of this field is controlled by the value read from
                                                          PEM()_CFG[MD].
                                                          _ MD is 0x0, reset to 0x1: 2.5 GHz supported.
                                                          _ MD is 0x1, reset to 0x2: 5.0 GHz and 2.5 GHz supported.
                                                          _ MD is 0x2, reset to 0x3: 8.0 Ghz, 5.0 GHz and 2.5 GHz supported.
                                                          _ MD is 0x3, reset to 0x3: 8.0 Ghz, 5.0 GHz and 2.5 GHz supported (RC Mode).
-                                                         This field is writable through PEM()_CFG_WR. However, the application must not change
-                                                         this field. */
+                                                         This field is writable through PEM()_CFG_WR.
+                                                         Zeroing both [MLW] and [MLS] out of reset, using the EEPROM, will prevent the
+                                                         link state machine from advancing past CONFIG.  This can be useful to allow
+                                                         software to locally boot and perform preconfiguration and bug fixes.  Setting
+                                                         [MLW] and [MLS] to non-zero values will then allow the lttsm to advance and the
+                                                         link to come up. */
 #else
 	uint32_t mls                          : 4;
 	uint32_t mlw                          : 6;
@@ -9851,7 +10534,7 @@ union cvmx_pcieepx_cfg099 {
 	struct cvmx_pcieepx_cfg099_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t vfs                          : 16; /**< VF stride.
-                                                         There are two VF Stride registers;  one for each ARI Capable
+                                                         There are two VF Stride registers per PF; one for each ARI Capable
                                                          and non-ARI Capable Hierarchies.  The PCIEP()_CFG096[ACH] determines which one is
                                                          being used for SR-IOV, and which one is accessed by a read request.
                                                          This field is writable through PEM()_CFG_WR, PEM()_CFG_WR[ADDR[31]] determines
@@ -10011,7 +10694,7 @@ union cvmx_pcieepx_cfg103 {
 	uint32_t lbab                         : 17;
 #endif
 	} cn78xx;
-	struct cvmx_pcieepx_cfg103_cn78xx     cn78xxp2;
+	struct cvmx_pcieepx_cfg103_cn73xx     cn78xxp2;
 	struct cvmx_pcieepx_cfg103_cn73xx     cnf75xx;
 };
 typedef union cvmx_pcieepx_cfg103 cvmx_pcieepx_cfg103_t;
@@ -11566,7 +12249,7 @@ union cvmx_pcieepx_cfg466 {
                                                          used only in the segmented-buffer configuration, writable through
                                                          PEM()_CFG_WR:
                                                          0 = Strict ordering for received TLPs: Posted, then completion, then NonPosted.
-                                                         1 = Ordering of received TLPs follows the rules in PCI Express Base Specification
+                                                         1 = Ordering of received TLPs follows the rules in PCI Express Base Specification.
                                                          The application must not change this field. */
 	uint32_t reserved_24_29               : 6;
 	uint32_t queue_mode                   : 3;  /**< VC0 posted TLP queue mode. The operating mode of the posted receive queue for VC0, used
diff --git a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
index 6dcc4ed..78bcad9 100644
--- a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
@@ -66,6 +66,12 @@ static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000000ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000000ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000000ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -93,6 +99,10 @@ static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long offset)
 			return 0x0000020000000000ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000000ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000000ull + (offset) * 0x100000000ull;
 			return 0x0000020000000000ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -120,6 +130,12 @@ static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000004ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000004ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000004ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -147,6 +163,10 @@ static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long offset)
 			return 0x0000020000000004ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000004ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000004ull + (offset) * 0x100000000ull;
 			return 0x0000020000000004ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -174,6 +194,12 @@ static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000008ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000008ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000008ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -201,6 +227,10 @@ static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long offset)
 			return 0x0000020000000008ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000008ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000008ull + (offset) * 0x100000000ull;
 			return 0x0000020000000008ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -228,6 +258,12 @@ static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000000Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000000Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000000Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -255,6 +291,10 @@ static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long offset)
 			return 0x000002000000000Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000000Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000000Cull + (offset) * 0x100000000ull;
 			return 0x000002000000000Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -282,6 +322,12 @@ static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000010ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000010ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -309,6 +355,10 @@ static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long offset)
 			return 0x0000020000000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000010ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000010ull + (offset) * 0x100000000ull;
 			return 0x0000020000000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -336,6 +386,12 @@ static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000014ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000014ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -363,6 +419,10 @@ static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long offset)
 			return 0x0000020000000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000014ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000014ull + (offset) * 0x100000000ull;
 			return 0x0000020000000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -390,6 +450,12 @@ static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000018ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000018ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -417,6 +483,10 @@ static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long offset)
 			return 0x0000020000000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000018ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000018ull + (offset) * 0x100000000ull;
 			return 0x0000020000000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -444,6 +514,12 @@ static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000001Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000001Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -471,6 +547,10 @@ static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long offset)
 			return 0x000002000000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000001Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000001Cull + (offset) * 0x100000000ull;
 			return 0x000002000000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -498,6 +578,12 @@ static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000020ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000020ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -525,6 +611,10 @@ static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long offset)
 			return 0x0000020000000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000020ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000020ull + (offset) * 0x100000000ull;
 			return 0x0000020000000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -552,6 +642,12 @@ static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000024ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000024ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -579,6 +675,10 @@ static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long offset)
 			return 0x0000020000000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000024ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000024ull + (offset) * 0x100000000ull;
 			return 0x0000020000000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -606,6 +706,12 @@ static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000028ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000028ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000028ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -633,6 +739,10 @@ static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long offset)
 			return 0x0000020000000028ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000028ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000028ull + (offset) * 0x100000000ull;
 			return 0x0000020000000028ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -660,6 +770,12 @@ static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000002Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000002Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000002Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -687,6 +803,10 @@ static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long offset)
 			return 0x000002000000002Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000002Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000002Cull + (offset) * 0x100000000ull;
 			return 0x000002000000002Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -714,6 +834,12 @@ static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000030ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000030ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -741,6 +867,10 @@ static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long offset)
 			return 0x0000020000000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000030ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000030ull + (offset) * 0x100000000ull;
 			return 0x0000020000000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -768,6 +898,12 @@ static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000034ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000034ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000034ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -795,6 +931,10 @@ static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long offset)
 			return 0x0000020000000034ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000034ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000034ull + (offset) * 0x100000000ull;
 			return 0x0000020000000034ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -822,6 +962,12 @@ static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000038ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000038ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000038ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -849,6 +995,10 @@ static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long offset)
 			return 0x0000020000000038ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000038ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000038ull + (offset) * 0x100000000ull;
 			return 0x0000020000000038ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -876,6 +1026,12 @@ static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000003Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000003Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000003Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -903,6 +1059,10 @@ static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long offset)
 			return 0x000002000000003Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000003Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000003Cull + (offset) * 0x100000000ull;
 			return 0x000002000000003Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -930,6 +1090,12 @@ static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000040ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000040ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000040ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -957,6 +1123,10 @@ static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long offset)
 			return 0x0000020000000040ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000040ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000040ull + (offset) * 0x100000000ull;
 			return 0x0000020000000040ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -984,6 +1154,12 @@ static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000044ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000044ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000044ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1011,6 +1187,10 @@ static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long offset)
 			return 0x0000020000000044ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000044ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000044ull + (offset) * 0x100000000ull;
 			return 0x0000020000000044ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1038,6 +1218,12 @@ static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000050ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000050ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000050ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1065,6 +1251,10 @@ static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long offset)
 			return 0x0000020000000050ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000050ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000050ull + (offset) * 0x100000000ull;
 			return 0x0000020000000050ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1092,6 +1282,12 @@ static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000054ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000054ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000054ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1119,6 +1315,10 @@ static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long offset)
 			return 0x0000020000000054ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000054ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000054ull + (offset) * 0x100000000ull;
 			return 0x0000020000000054ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1146,6 +1346,12 @@ static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000058ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000058ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000058ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1173,6 +1379,10 @@ static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long offset)
 			return 0x0000020000000058ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000058ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000058ull + (offset) * 0x100000000ull;
 			return 0x0000020000000058ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1200,6 +1410,12 @@ static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000005Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000005Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000005Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1227,6 +1443,10 @@ static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long offset)
 			return 0x000002000000005Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000005Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000005Cull + (offset) * 0x100000000ull;
 			return 0x000002000000005Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1254,6 +1474,12 @@ static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000070ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000070ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000070ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1281,6 +1507,10 @@ static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long offset)
 			return 0x0000020000000070ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000070ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000070ull + (offset) * 0x100000000ull;
 			return 0x0000020000000070ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1308,6 +1538,12 @@ static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000074ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000074ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000074ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1335,6 +1571,10 @@ static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long offset)
 			return 0x0000020000000074ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000074ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000074ull + (offset) * 0x100000000ull;
 			return 0x0000020000000074ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1362,6 +1602,12 @@ static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000078ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000078ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000078ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1389,6 +1635,10 @@ static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long offset)
 			return 0x0000020000000078ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000078ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000078ull + (offset) * 0x100000000ull;
 			return 0x0000020000000078ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1416,6 +1666,12 @@ static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000007Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000007Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000007Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1443,6 +1699,10 @@ static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long offset)
 			return 0x000002000000007Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000007Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000007Cull + (offset) * 0x100000000ull;
 			return 0x000002000000007Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1470,6 +1730,12 @@ static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000080ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000080ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000080ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1497,6 +1763,10 @@ static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long offset)
 			return 0x0000020000000080ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000080ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000080ull + (offset) * 0x100000000ull;
 			return 0x0000020000000080ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1524,6 +1794,12 @@ static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000084ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000084ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000084ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1551,6 +1827,10 @@ static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long offset)
 			return 0x0000020000000084ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000084ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000084ull + (offset) * 0x100000000ull;
 			return 0x0000020000000084ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1578,6 +1858,12 @@ static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000088ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000088ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000088ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1605,6 +1891,10 @@ static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long offset)
 			return 0x0000020000000088ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000088ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000088ull + (offset) * 0x100000000ull;
 			return 0x0000020000000088ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1632,6 +1922,12 @@ static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000008Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000008Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000008Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1659,6 +1955,10 @@ static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long offset)
 			return 0x000002000000008Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000008Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000008Cull + (offset) * 0x100000000ull;
 			return 0x000002000000008Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1686,6 +1986,12 @@ static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000090ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000090ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000090ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1713,6 +2019,10 @@ static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long offset)
 			return 0x0000020000000090ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000090ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000090ull + (offset) * 0x100000000ull;
 			return 0x0000020000000090ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1740,6 +2050,12 @@ static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000094ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000094ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000094ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1767,6 +2083,10 @@ static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long offset)
 			return 0x0000020000000094ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000094ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000094ull + (offset) * 0x100000000ull;
 			return 0x0000020000000094ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1794,6 +2114,12 @@ static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000098ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000098ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000098ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1821,6 +2147,10 @@ static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long offset)
 			return 0x0000020000000098ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000098ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000098ull + (offset) * 0x100000000ull;
 			return 0x0000020000000098ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1848,6 +2178,12 @@ static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000009Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000009Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000009Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1875,6 +2211,10 @@ static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long offset)
 			return 0x000002000000009Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000009Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000009Cull + (offset) * 0x100000000ull;
 			return 0x000002000000009Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1902,6 +2242,12 @@ static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x00000200000000A0ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x00000200000000A0ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x00000200000000A0ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1929,6 +2275,10 @@ static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long offset)
 			return 0x00000200000000A0ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000200000000A0ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000200000000A0ull + (offset) * 0x100000000ull;
 			return 0x00000200000000A0ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -1956,6 +2306,12 @@ static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x00000200000000A4ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x00000200000000A4ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x00000200000000A4ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -1983,6 +2339,10 @@ static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long offset)
 			return 0x00000200000000A4ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000200000000A4ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000200000000A4ull + (offset) * 0x100000000ull;
 			return 0x00000200000000A4ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2010,6 +2370,12 @@ static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x00000200000000A8ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x00000200000000A8ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x00000200000000A8ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2037,6 +2403,10 @@ static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long offset)
 			return 0x00000200000000A8ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000200000000A8ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000200000000A8ull + (offset) * 0x100000000ull;
 			return 0x00000200000000A8ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2055,6 +2425,7 @@ static inline uint64_t CVMX_PCIERCX_CFG044(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG044(%lu) is invalid on this chip\n", offset);
@@ -2068,6 +2439,7 @@ static inline uint64_t CVMX_PCIERCX_CFG045(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG045(%lu) is invalid on this chip\n", offset);
@@ -2081,6 +2453,7 @@ static inline uint64_t CVMX_PCIERCX_CFG046(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG046(%lu) is invalid on this chip\n", offset);
@@ -2103,6 +2476,12 @@ static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000100ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000100ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000100ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2130,6 +2509,10 @@ static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long offset)
 			return 0x0000020000000100ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000100ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000100ull + (offset) * 0x100000000ull;
 			return 0x0000020000000100ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2157,6 +2540,12 @@ static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000104ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000104ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000104ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2184,6 +2573,10 @@ static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long offset)
 			return 0x0000020000000104ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000104ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000104ull + (offset) * 0x100000000ull;
 			return 0x0000020000000104ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2211,6 +2604,12 @@ static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000108ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000108ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000108ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2238,6 +2637,10 @@ static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long offset)
 			return 0x0000020000000108ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000108ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000108ull + (offset) * 0x100000000ull;
 			return 0x0000020000000108ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2265,6 +2668,12 @@ static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000010Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000010Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000010Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2292,6 +2701,10 @@ static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long offset)
 			return 0x000002000000010Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000010Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000010Cull + (offset) * 0x100000000ull;
 			return 0x000002000000010Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2319,6 +2732,12 @@ static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000110ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000110ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000110ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2346,6 +2765,10 @@ static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long offset)
 			return 0x0000020000000110ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000110ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000110ull + (offset) * 0x100000000ull;
 			return 0x0000020000000110ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2373,6 +2796,12 @@ static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000114ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000114ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000114ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2400,6 +2829,10 @@ static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long offset)
 			return 0x0000020000000114ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000114ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000114ull + (offset) * 0x100000000ull;
 			return 0x0000020000000114ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2427,6 +2860,12 @@ static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000118ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000118ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000118ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2454,6 +2893,10 @@ static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long offset)
 			return 0x0000020000000118ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000118ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000118ull + (offset) * 0x100000000ull;
 			return 0x0000020000000118ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2481,6 +2924,12 @@ static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000011Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000011Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000011Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2508,6 +2957,10 @@ static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long offset)
 			return 0x000002000000011Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000011Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000011Cull + (offset) * 0x100000000ull;
 			return 0x000002000000011Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2535,6 +2988,12 @@ static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000120ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000120ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000120ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2562,6 +3021,10 @@ static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long offset)
 			return 0x0000020000000120ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000120ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000120ull + (offset) * 0x100000000ull;
 			return 0x0000020000000120ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2589,6 +3052,12 @@ static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000124ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000124ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000124ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2616,6 +3085,10 @@ static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long offset)
 			return 0x0000020000000124ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000124ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000124ull + (offset) * 0x100000000ull;
 			return 0x0000020000000124ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2643,6 +3116,12 @@ static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000128ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000128ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000128ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2670,6 +3149,10 @@ static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long offset)
 			return 0x0000020000000128ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000128ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000128ull + (offset) * 0x100000000ull;
 			return 0x0000020000000128ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2697,6 +3180,12 @@ static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000012Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000012Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000012Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2724,6 +3213,10 @@ static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long offset)
 			return 0x000002000000012Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000012Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000012Cull + (offset) * 0x100000000ull;
 			return 0x000002000000012Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2751,6 +3244,12 @@ static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000130ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000130ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000130ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2778,6 +3277,10 @@ static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long offset)
 			return 0x0000020000000130ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000130ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000130ull + (offset) * 0x100000000ull;
 			return 0x0000020000000130ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2805,6 +3308,12 @@ static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000134ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000134ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000134ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2832,6 +3341,10 @@ static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long offset)
 			return 0x0000020000000134ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000134ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000134ull + (offset) * 0x100000000ull;
 			return 0x0000020000000134ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -2850,6 +3363,7 @@ static inline uint64_t CVMX_PCIERCX_CFG086(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG086(%lu) is invalid on this chip\n", offset);
@@ -2863,6 +3377,7 @@ static inline uint64_t CVMX_PCIERCX_CFG087(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG087(%lu) is invalid on this chip\n", offset);
@@ -2876,6 +3391,7 @@ static inline uint64_t CVMX_PCIERCX_CFG088(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG088(%lu) is invalid on this chip\n", offset);
@@ -2889,6 +3405,7 @@ static inline uint64_t CVMX_PCIERCX_CFG089(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG089(%lu) is invalid on this chip\n", offset);
@@ -2902,6 +3419,7 @@ static inline uint64_t CVMX_PCIERCX_CFG090(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG090(%lu) is invalid on this chip\n", offset);
@@ -2915,6 +3433,7 @@ static inline uint64_t CVMX_PCIERCX_CFG091(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG091(%lu) is invalid on this chip\n", offset);
@@ -2928,6 +3447,7 @@ static inline uint64_t CVMX_PCIERCX_CFG092(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG092(%lu) is invalid on this chip\n", offset);
@@ -2950,6 +3470,12 @@ static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000700ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000700ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000700ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -2977,6 +3503,10 @@ static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long offset)
 			return 0x0000020000000700ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000700ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000700ull + (offset) * 0x100000000ull;
 			return 0x0000020000000700ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3004,6 +3534,12 @@ static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000704ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000704ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000704ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3031,6 +3567,10 @@ static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long offset)
 			return 0x0000020000000704ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000704ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000704ull + (offset) * 0x100000000ull;
 			return 0x0000020000000704ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3058,6 +3598,12 @@ static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000708ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000708ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000708ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3085,6 +3631,10 @@ static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long offset)
 			return 0x0000020000000708ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000708ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000708ull + (offset) * 0x100000000ull;
 			return 0x0000020000000708ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3112,6 +3662,12 @@ static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000070Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000070Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000070Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3139,6 +3695,10 @@ static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long offset)
 			return 0x000002000000070Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000070Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000070Cull + (offset) * 0x100000000ull;
 			return 0x000002000000070Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3166,6 +3726,12 @@ static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000710ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000710ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000710ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3193,6 +3759,10 @@ static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long offset)
 			return 0x0000020000000710ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000710ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000710ull + (offset) * 0x100000000ull;
 			return 0x0000020000000710ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3220,6 +3790,12 @@ static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000714ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000714ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000714ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3247,6 +3823,10 @@ static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long offset)
 			return 0x0000020000000714ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000714ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000714ull + (offset) * 0x100000000ull;
 			return 0x0000020000000714ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3274,6 +3854,12 @@ static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000718ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000718ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000718ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3301,6 +3887,10 @@ static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long offset)
 			return 0x0000020000000718ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000718ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000718ull + (offset) * 0x100000000ull;
 			return 0x0000020000000718ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3328,6 +3918,12 @@ static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000071Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000071Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000071Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3355,6 +3951,10 @@ static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long offset)
 			return 0x000002000000071Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000071Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000071Cull + (offset) * 0x100000000ull;
 			return 0x000002000000071Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3382,6 +3982,12 @@ static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000720ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000720ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000720ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3409,6 +4015,10 @@ static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long offset)
 			return 0x0000020000000720ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000720ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000720ull + (offset) * 0x100000000ull;
 			return 0x0000020000000720ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3436,6 +4046,12 @@ static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000728ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000728ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000728ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3463,6 +4079,10 @@ static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long offset)
 			return 0x0000020000000728ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000728ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000728ull + (offset) * 0x100000000ull;
 			return 0x0000020000000728ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3490,6 +4110,12 @@ static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000072Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000072Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000072Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3517,6 +4143,10 @@ static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long offset)
 			return 0x000002000000072Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000072Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000072Cull + (offset) * 0x100000000ull;
 			return 0x000002000000072Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3544,6 +4174,12 @@ static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000730ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000730ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000730ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3571,6 +4207,10 @@ static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long offset)
 			return 0x0000020000000730ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000730ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000730ull + (offset) * 0x100000000ull;
 			return 0x0000020000000730ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3598,6 +4238,12 @@ static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000734ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000734ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000734ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3625,6 +4271,10 @@ static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long offset)
 			return 0x0000020000000734ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000734ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000734ull + (offset) * 0x100000000ull;
 			return 0x0000020000000734ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3652,6 +4302,12 @@ static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000738ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000738ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000738ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3679,6 +4335,10 @@ static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long offset)
 			return 0x0000020000000738ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000738ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000738ull + (offset) * 0x100000000ull;
 			return 0x0000020000000738ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3706,6 +4366,12 @@ static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000073Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000073Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000073Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3733,6 +4399,10 @@ static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long offset)
 			return 0x000002000000073Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000073Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000073Cull + (offset) * 0x100000000ull;
 			return 0x000002000000073Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3760,6 +4430,12 @@ static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000740ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000740ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000740ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3787,6 +4463,10 @@ static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long offset)
 			return 0x0000020000000740ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000740ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000740ull + (offset) * 0x100000000ull;
 			return 0x0000020000000740ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3814,6 +4494,12 @@ static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000744ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000744ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000744ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3841,6 +4527,10 @@ static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long offset)
 			return 0x0000020000000744ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000744ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000744ull + (offset) * 0x100000000ull;
 			return 0x0000020000000744ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3868,6 +4558,12 @@ static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000748ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000748ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000748ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3895,6 +4591,10 @@ static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long offset)
 			return 0x0000020000000748ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000748ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000748ull + (offset) * 0x100000000ull;
 			return 0x0000020000000748ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3922,6 +4622,12 @@ static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000074Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000074Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000074Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -3949,6 +4655,10 @@ static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long offset)
 			return 0x000002000000074Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000074Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000074Cull + (offset) * 0x100000000ull;
 			return 0x000002000000074Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -3976,6 +4686,12 @@ static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000750ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000750ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000750ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -4003,6 +4719,10 @@ static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long offset)
 			return 0x0000020000000750ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000750ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000750ull + (offset) * 0x100000000ull;
 			return 0x0000020000000750ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -4150,6 +4870,12 @@ static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x000002000000080Cull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x000002000000080Cull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x000002000000080Cull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -4175,6 +4901,10 @@ static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long offset)
 			return 0x000002000000080Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x000002000000080Cull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x000002000000080Cull + (offset) * 0x100000000ull;
 			return 0x000002000000080Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -4200,6 +4930,12 @@ static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000810ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000810ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000810ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -4227,6 +4963,10 @@ static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long offset)
 			return 0x0000020000000810ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000810ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000810ull + (offset) * 0x100000000ull;
 			return 0x0000020000000810ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -4254,6 +4994,12 @@ static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000020000000814ull + ((offset) & 3) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000020000000814ull + ((offset) & 3) * 0x100000000ull;
 			if ((offset <= 3))
 				return 0x0000020000000814ull + ((offset) & 3) * 0x100000000ull;
 			break;
@@ -4281,6 +5027,10 @@ static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long offset)
 			return 0x0000020000000814ull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000020000000814ull + (offset) * 0x100000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000020000000814ull + (offset) * 0x100000000ull;
 			return 0x0000020000000814ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -4299,6 +5049,7 @@ static inline uint64_t CVMX_PCIERCX_CFG548(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG548(%lu) is invalid on this chip\n", offset);
@@ -4312,6 +5063,7 @@ static inline uint64_t CVMX_PCIERCX_CFG554(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG554(%lu) is invalid on this chip\n", offset);
@@ -4325,6 +5077,7 @@ static inline uint64_t CVMX_PCIERCX_CFG558(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG558(%lu) is invalid on this chip\n", offset);
@@ -4694,8 +5447,8 @@ union cvmx_pciercx_cfg007 {
 	uint32_t lio_base                     : 4;  /**< I/O space base. */
 	uint32_t reserved_1_3                 : 3;
 	uint32_t io32a                        : 1;  /**< 32-bit I/O space.
-                                                         0 = 16-bit I/O addressing
-                                                         1 = 32-bit I/O addressing
+                                                         0 = 16-bit I/O addressing.
+                                                         1 = 32-bit I/O addressing.
                                                          This bit is writable through PEM()_CFG_WR. When the application writes to this bit
                                                          through PEM()_CFG_WR, the same value is written to bit 8 of this register. */
 #else
@@ -5762,7 +6515,7 @@ union cvmx_pciercx_cfg031 {
                                                          must not change this field. */
 	uint32_t mlw                          : 6;  /**< Maximum link width.
                                                          The reset value of this field is determined by the value read from the PEM
-                                                         csr PEM()_CFG[LANES8]. If LANES8 is set the reset value is 0x4, otherwise 0x8.
+                                                         csr PEM()_CFG[LANES4]. If LANES4 is set the reset value is 0x4, otherwise 0x2.
                                                          This field is writable through PEM()_CFG_WR. */
 	uint32_t mls                          : 4;  /**< Maximum link speed. The reset value of this field is controlled by the value read from
                                                          PEM()_CFG[MD].
@@ -9041,7 +9794,7 @@ union cvmx_pciercx_cfg453 {
 	uint32_t fcd                          : 1;  /**< Flow control disable. Prevents the PCI Express bus from sending FC DLLPs. */
 	uint32_t ilst                         : 24; /**< Insert lane skew for transmit (not supported for *16). Causes skew between lanes for test
                                                          purposes. There are three bits per lane. The value is in units of one symbol time. For
-                                                         example, the value 010b for a lane forces a skew of two symbol times for that Lane. The
+                                                         example, the value 0x2 for a lane forces a skew of two symbol times for that lane. The
                                                          maximum skew value for any lane is 5 symbol times. */
 #else
 	uint32_t ilst                         : 24;
@@ -9703,7 +10456,7 @@ union cvmx_pciercx_cfg466 {
                                                          used only in the segmented-buffer configuration, writable through
                                                          PEM()_CFG_WR:
                                                          0 = Strict ordering for received TLPs: Posted, then completion, then NonPosted.
-                                                         1 = Ordering of received TLPs follows the rules in PCI Express Base Specification
+                                                         1 = Ordering of received TLPs follows the rules in PCI Express Base Specification.
                                                          The application must not change this field. */
 	uint32_t reserved_24_29               : 6;
 	uint32_t queue_mode                   : 3;  /**< VC0 posted TLP queue mode. The operating mode of the posted receive queue for VC0, used
diff --git a/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h
index 107463c..90d9e40 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h
@@ -1408,7 +1408,7 @@ typedef union cvmx_pcsx_log_anlx_reg cvmx_pcsx_log_anlx_reg_t;
  * cvmx_pcs#_mac_crdt_cnt#_reg
  *
  * PCS MAC Credit Count
- * INTERNAL: Do not add this register to the HRM
+ *
  */
 union cvmx_pcsx_mac_crdt_cntx_reg {
 	uint64_t u64;
@@ -1785,7 +1785,7 @@ typedef union cvmx_pcsx_rxx_sync_reg cvmx_pcsx_rxx_sync_reg_t;
  * cvmx_pcs#_serdes_crdt_cnt#_reg
  *
  * PCS SERDES Credit Count
- * INTERNAL: Do not add this register to the HRM
+ *
  */
 union cvmx_pcsx_serdes_crdt_cntx_reg {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
index 9eb3975..1cf50ce 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
@@ -1175,18 +1175,14 @@ typedef union cvmx_pcsxx_rx_sync_states_reg cvmx_pcsxx_rx_sync_states_reg_t;
  * cvmx_pcsx#_serdes_crdt_cnt_reg
  *
  * PCSX SERDES Credit Count
- * INTERNAL: Do not add this register to the HRM
+ *
  */
 union cvmx_pcsxx_serdes_crdt_cnt_reg {
 	uint64_t u64;
 	struct cvmx_pcsxx_serdes_crdt_cnt_reg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
-	uint64_t cnt                          : 5;  /**< INTERNAL: SERDES Credit Count.
-                                                         Valid rand is 1-31.
-                                                         Recommended value is 16 for all full-duplex operations.  Some clock ratios may require a
-                                                         larger setting of 20.
-                                                         Value of zero will disable the port. */
+	uint64_t cnt                          : 5;  /**< N/A */
 #else
 	uint64_t cnt                          : 5;
 	uint64_t reserved_5_63                : 59;
diff --git a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
index 4a2e26f..6e6ad7d 100644
--- a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
@@ -66,6 +66,12 @@ static inline uint64_t CVMX_PEMX_BAR1_INDEXX(unsigned long offset, unsigned long
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if (((offset <= 15)) && ((block_id <= 3)))
+					return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if (((offset <= 15)) && ((block_id <= 3)))
+					return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
 			if (((offset <= 15)) && (((block_id >= 1) && (block_id <= 3))))
 				return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + (((offset) & 15) + ((block_id) & 3) * 0x200000ull) * 8;
 			break;
@@ -91,6 +97,10 @@ static inline uint64_t CVMX_PEMX_BAR1_INDEXX(unsigned long offset, unsigned long
 			return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + ((offset) + (block_id) * 0x200000ull) * 8;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 			return CVMX_ADD_IO_SEG(0x00011800C0000100ull) + ((offset) + (block_id) * 0x200000ull) * 8;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -116,6 +126,12 @@ static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + ((offset) & 3) * 0x1000000ull;
 			if (((offset >= 1) && (offset <= 3)))
 				return CVMX_ADD_IO_SEG(0x00011800C10000B0ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
@@ -140,6 +156,10 @@ static inline uint64_t CVMX_PEMX_BAR2_MASK(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800C00000B0ull) + (offset) * 0x1000000ull;
 			return CVMX_ADD_IO_SEG(0x00011800C10000B0ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -164,6 +184,12 @@ static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + ((offset) & 3) * 0x1000000ull;
 			if (((offset >= 1) && (offset <= 3)))
 				return CVMX_ADD_IO_SEG(0x00011800C10000A8ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
@@ -189,6 +215,10 @@ static inline uint64_t CVMX_PEMX_BAR_CTL(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (offset) * 0x1000000ull;
 			return CVMX_ADD_IO_SEG(0x00011800C10000A8ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -222,6 +252,12 @@ static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + ((offset) & 3) * 0x1000000ull;
 			if (((offset >= 1) && (offset <= 3)))
 				return CVMX_ADD_IO_SEG(0x00011800C1000440ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
@@ -245,6 +281,10 @@ static inline uint64_t CVMX_PEMX_BIST_STATUS(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + (offset) * 0x1000000ull;
 			return CVMX_ADD_IO_SEG(0x00011800C1000440ull) + (offset) * 0x1000000ull - 16777216*1;
 	}
 	return CVMX_ADD_IO_SEG(0x00011800C0000440ull) + (offset) * 0x1000000ull;
@@ -292,6 +332,7 @@ static inline uint64_t CVMX_PEMX_CFG(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CFG(%lu) is invalid on this chip\n", offset);
@@ -310,6 +351,7 @@ static inline uint64_t CVMX_PEMX_CFG_RD(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -329,6 +371,7 @@ static inline uint64_t CVMX_PEMX_CFG_WR(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -344,6 +387,7 @@ static inline uint64_t CVMX_PEMX_CLK_EN(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CLK_EN(%lu) is invalid on this chip\n", offset);
@@ -362,6 +406,7 @@ static inline uint64_t CVMX_PEMX_CPL_LUT_VALID(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -381,6 +426,7 @@ static inline uint64_t CVMX_PEMX_CTL_STATUS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -395,6 +441,7 @@ static inline uint64_t CVMX_PEMX_CTL_STATUS2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_CTL_STATUS2(%lu) is invalid on this chip\n", offset);
@@ -417,6 +464,12 @@ static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + ((offset) & 3) * 0x1000000ull;
 			if (((offset >= 1) && (offset <= 3)))
 				return CVMX_ADD_IO_SEG(0x00011800C10000D0ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
@@ -442,6 +495,10 @@ static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800C00000D0ull) + (offset) * 0x1000000ull;
 			return CVMX_ADD_IO_SEG(0x00011800C10000D0ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -479,6 +536,7 @@ static inline uint64_t CVMX_PEMX_DIAG_STATUS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -498,6 +556,12 @@ static inline uint64_t CVMX_PEMX_ECC_ENA(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + ((offset) & 3) * 0x1000000ull;
 			if (((offset >= 1) && (offset <= 3)))
 				return CVMX_ADD_IO_SEG(0x00011800C1000448ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
@@ -517,6 +581,10 @@ static inline uint64_t CVMX_PEMX_ECC_ENA(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800C0000448ull) + (offset) * 0x1000000ull;
 			return CVMX_ADD_IO_SEG(0x00011800C1000448ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000C0ull) + (offset) * 0x1000000ull;
@@ -534,6 +602,12 @@ static inline uint64_t CVMX_PEMX_ECC_SYND_CTRL(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + ((offset) & 3) * 0x1000000ull;
 			if (((offset >= 1) && (offset <= 3)))
 				return CVMX_ADD_IO_SEG(0x00011800C1000450ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
@@ -553,6 +627,10 @@ static inline uint64_t CVMX_PEMX_ECC_SYND_CTRL(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800C0000450ull) + (offset) * 0x1000000ull;
 			return CVMX_ADD_IO_SEG(0x00011800C1000450ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011800C00000C8ull) + (offset) * 0x1000000ull;
@@ -565,6 +643,7 @@ static inline uint64_t CVMX_PEMX_ECO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_ECO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000010ull) + ((offset) & 3) * 0x1000000ull;
@@ -577,6 +656,7 @@ static inline uint64_t CVMX_PEMX_FLR_GLBLCNT_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_FLR_GLBLCNT_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000210ull) + ((offset) & 3) * 0x1000000ull;
@@ -589,6 +669,7 @@ static inline uint64_t CVMX_PEMX_FLR_PF0_VF_STOPREQ(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_FLR_PF0_VF_STOPREQ(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000220ull) + ((offset) & 3) * 0x1000000ull;
@@ -601,6 +682,7 @@ static inline uint64_t CVMX_PEMX_FLR_PF_STOPREQ(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_FLR_PF_STOPREQ(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000218ull) + ((offset) & 3) * 0x1000000ull;
@@ -612,18 +694,20 @@ static inline uint64_t CVMX_PEMX_FLR_PF_STOPREQ(unsigned long offset)
 static inline uint64_t CVMX_PEMX_FLR_STOPREQ_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_FLR_STOPREQ_CTL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011800C0000238ull) + ((offset) & 1) * 0x1000000ull;
+	return CVMX_ADD_IO_SEG(0x00011800C0000238ull) + ((offset) & 3) * 0x1000000ull;
 }
 #else
-#define CVMX_PEMX_FLR_STOPREQ_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800C0000238ull) + ((offset) & 1) * 0x1000000ull)
+#define CVMX_PEMX_FLR_STOPREQ_CTL(offset) (CVMX_ADD_IO_SEG(0x00011800C0000238ull) + ((offset) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEMX_FLR_ZOMBIE_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_FLR_ZOMBIE_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800C0000230ull) + ((offset) & 3) * 0x1000000ull;
@@ -645,6 +729,12 @@ static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + ((offset) & 3) * 0x1000000ull;
 			if (((offset >= 1) && (offset <= 3)))
 				return CVMX_ADD_IO_SEG(0x00011800C10000B8ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
@@ -669,6 +759,10 @@ static inline uint64_t CVMX_PEMX_INB_READ_CREDITS(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800C00000B8ull) + (offset) * 0x1000000ull;
 			return CVMX_ADD_IO_SEG(0x00011800C10000B8ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -765,6 +859,12 @@ static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long offset)
 			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((offset) & 3) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + ((offset) & 3) * 0x1000000ull;
 			if (((offset >= 1) && (offset <= 3)))
 				return CVMX_ADD_IO_SEG(0x00011800C1000428ull) + ((offset) & 3) * 0x1000000ull - 16777216*1;
 			break;
@@ -790,6 +890,10 @@ static inline uint64_t CVMX_PEMX_INT_SUM(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (offset) * 0x1000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (offset) * 0x1000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011800C0000428ull) + (offset) * 0x1000000ull;
 			return CVMX_ADD_IO_SEG(0x00011800C1000428ull) + (offset) * 0x1000000ull - 16777216*1;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -807,6 +911,7 @@ static inline uint64_t CVMX_PEMX_ON(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_ON(%lu) is invalid on this chip\n", offset);
@@ -825,6 +930,7 @@ static inline uint64_t CVMX_PEMX_P2N_BAR0_START(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -844,6 +950,7 @@ static inline uint64_t CVMX_PEMX_P2N_BAR1_START(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -863,6 +970,7 @@ static inline uint64_t CVMX_PEMX_P2N_BAR2_START(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -880,6 +988,7 @@ static inline uint64_t CVMX_PEMX_P2P_BARX_END(unsigned long offset, unsigned lon
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && (((block_id >= 1) && (block_id <= 3))))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_PEMX_P2P_BARX_END(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -896,6 +1005,7 @@ static inline uint64_t CVMX_PEMX_P2P_BARX_START(unsigned long offset, unsigned l
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset <= 3)) && ((block_id <= 1)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && (((block_id >= 1) && (block_id <= 3))))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_PEMX_P2P_BARX_START(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -909,6 +1019,7 @@ static inline uint64_t CVMX_PEMX_QLM(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_QLM(%lu) is invalid on this chip\n", offset);
@@ -923,6 +1034,7 @@ static inline uint64_t CVMX_PEMX_SPI_CTL(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_SPI_CTL(%lu) is invalid on this chip\n", offset);
@@ -937,6 +1049,7 @@ static inline uint64_t CVMX_PEMX_SPI_DATA(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_SPI_DATA(%lu) is invalid on this chip\n", offset);
@@ -951,6 +1064,7 @@ static inline uint64_t CVMX_PEMX_STRAP(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEMX_STRAP(%lu) is invalid on this chip\n", offset);
@@ -969,6 +1083,7 @@ static inline uint64_t CVMX_PEMX_TLP_CREDITS(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
@@ -1044,13 +1159,13 @@ union cvmx_pemx_bar2_mask {
 	uint64_t u64;
 	struct cvmx_pemx_bar2_mask_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_42_63               : 22;
-	uint64_t mask                         : 39; /**< The value to be ANDed with the address sent to the CNXXXX memory. */
+	uint64_t reserved_45_63               : 19;
+	uint64_t mask                         : 42; /**< The value to be ANDed with the address sent to the CNXXXX memory. */
 	uint64_t reserved_0_2                 : 3;
 #else
 	uint64_t reserved_0_2                 : 3;
-	uint64_t mask                         : 39;
-	uint64_t reserved_42_63               : 22;
+	uint64_t mask                         : 42;
+	uint64_t reserved_45_63               : 19;
 #endif
 	} s;
 	struct cvmx_pemx_bar2_mask_cn61xx {
@@ -1070,11 +1185,21 @@ union cvmx_pemx_bar2_mask {
 	struct cvmx_pemx_bar2_mask_cn61xx     cn68xxp1;
 	struct cvmx_pemx_bar2_mask_cn61xx     cn70xx;
 	struct cvmx_pemx_bar2_mask_cn61xx     cn70xxp1;
-	struct cvmx_pemx_bar2_mask_s          cn73xx;
-	struct cvmx_pemx_bar2_mask_s          cn78xx;
+	struct cvmx_pemx_bar2_mask_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_42_63               : 22;
+	uint64_t mask                         : 39; /**< The value to be ANDed with the address sent to the CNXXXX memory. */
+	uint64_t reserved_0_2                 : 3;
+#else
+	uint64_t reserved_0_2                 : 3;
+	uint64_t mask                         : 39;
+	uint64_t reserved_42_63               : 22;
+#endif
+	} cn73xx;
+	struct cvmx_pemx_bar2_mask_cn73xx     cn78xx;
 	struct cvmx_pemx_bar2_mask_s          cn78xxp2;
 	struct cvmx_pemx_bar2_mask_cn61xx     cnf71xx;
-	struct cvmx_pemx_bar2_mask_s          cnf75xx;
+	struct cvmx_pemx_bar2_mask_cn73xx     cnf75xx;
 };
 typedef union cvmx_pemx_bar2_mask cvmx_pemx_bar2_mask_t;
 
@@ -1471,20 +1596,16 @@ union cvmx_pemx_cfg_rd {
 	uint64_t data                         : 32; /**< Data. */
 	uint64_t addr                         : 32; /**< Address to read. A write to this register starts a read operation.
                                                          Following are the subfields of the ADDR field.
-                                                         <31:24> Reserved. Must be zero.
-                                                         <23>    When clear, the read accesses the physical function. When set,
+                                                         <31:24> = Reserved. Must be zero.
+                                                         <23>    = When clear, the read accesses the physical function. When set,
                                                                  the read accesses the virtual function selected by <22:12>.
                                                                  Must be zero when SR-IOV is not used in the physical function.
                                                                  Must be zero in RC mode.
-                                                         <22:18> Reserved. Must be zero.
-                                                         <17:12> The selected virtual function. Must be zero when <23> is
+                                                         <22:18> = Reserved. Must be zero.
+                                                         <17:12> = The selected virtual function. Must be zero when <23> is
                                                                  clear. Must be zero in RC mode.
-                                                         <11:0>  Selects the PCIe config space register being read in the
-                                                                 function.
-                                                         INTERNAL:
-                                                           <31>    asserts dbi_cs2 at PCIe core.
-                                                           <23>    is dbi_vfunc_active to the core.
-                                                           <22:12> is dbi_vfunc_num to the core. */
+                                                         <11:0>  = Selects the PCIe config space register being read in the
+                                                                 function. */
 #else
 	uint64_t addr                         : 32;
 	uint64_t data                         : 32;
@@ -1519,24 +1640,20 @@ union cvmx_pemx_cfg_wr {
 	uint64_t data                         : 32; /**< Data to write. A write to this register starts a write operation. */
 	uint64_t addr                         : 32; /**< Address to write. A write to this register starts a write operation.
                                                          Following are the subfields of the ADDR field.
-                                                         <31>    When clear, the write is the same as a config space write received
+                                                         <31>    = When clear, the write is the same as a config space write received
                                                                  from external. When set, the write can modify more fields than
                                                                  an external write could (i.e. configuration mask register).
                                                                  Corresponds to the CS2 field in Byte2 of the EEPROM.
-                                                         <30:24> Reserved. Must be zero.
-                                                         <23>    When clear, the write accesses the physical function. When set,
+                                                         <30:24> = Reserved. Must be zero.
+                                                         <23>    = When clear, the write accesses the physical function. When set,
                                                                  the write accesses the virtual function selected by <22:12>.
                                                                  Must be zero when SR-IOV is not used in the physical function.
                                                                  Must be zero in RC mode.
-                                                         <22:18> Reserved. Must be zero.
-                                                         <17:12> The selected virtual function. Must be zero when <23> is
+                                                         <22:18> = Reserved. Must be zero.
+                                                         <17:12> = The selected virtual function. Must be zero when <23> is
                                                                  clear. Must be zero in RC mode.
-                                                         <11:0>  Selects the PCIe config space register being written in the
-                                                                 function.
-                                                         INTERNAL:
-                                                           <31>    asserts dbi_cs2 at PCIe core.
-                                                           <23>    is dbi_vfunc_active to the core.
-                                                           <22:12> is dbi_vfunc_num to the core. */
+                                                         <11:0>  = Selects the PCIe config space register being written in the
+                                                                 function. */
 #else
 	uint64_t addr                         : 32;
 	uint64_t data                         : 32;
@@ -1904,101 +2021,70 @@ union cvmx_pemx_dbg_info {
 	uint64_t ecrc_e                       : 1;  /**< Received an ECRC error.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_ECRC_E. */
 	uint64_t rawwpp                       : 1;  /**< Received a write with poisoned payload.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAWWPP.
-                                                         INTERNAL: radm_rcvd_wreq_poisoned. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAWWPP. */
 	uint64_t racpp                        : 1;  /**< Received a completion with poisoned payload.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACPP.
-                                                         INTERNAL: radm_rcvd_cpl_poisoned. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACPP. */
 	uint64_t ramtlp                       : 1;  /**< Received a malformed TLP.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAMTLP.
-                                                         INTERNAL: radm_mlf_tlp_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAMTLP. */
 	uint64_t rarwdns                      : 1;  /**< Received a request which device does not support.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RARWDNS.
-                                                         INTERNAL: radm_rcvd_ur_req. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RARWDNS. */
 	uint64_t caar                         : 1;  /**< Completer aborted a request.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_CAAR.
-                                                         INTERNAL: radm_rcvd_cpl_ca */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_CAAR. */
 	uint64_t racca                        : 1;  /**< Received a completion with CA status.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACCA.
-                                                         INTERNAL: radm_rcvd_cpl_ca. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACCA. */
 	uint64_t racur                        : 1;  /**< Received a completion with UR status.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACUR.
-                                                         INTERNAL: radm_rcvd_cpl_ur. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACUR. */
 	uint64_t rauc                         : 1;  /**< Received an unexpected completion.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAUC.
-                                                         INTERNAL: radm_unexp_cpl_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAUC. */
 	uint64_t rqo                          : 1;  /**< Receive queue overflow. Normally happens only when flow control advertisements are
                                                          ignored.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RQO.
-                                                         INTERNAL: radm_qoverflow. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RQO. */
 	uint64_t fcuv                         : 1;  /**< Flow control update violation.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_FCUV.
-                                                         INTERNAL: (opt. checks) int_xadm_fc_prot_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_FCUV. */
 	uint64_t rpe                          : 1;  /**< PHY reported an 8B/10B decode error (RxStatus = 0x4) or disparity error (RxStatus =
                                                          0x7).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPE.
-                                                         INTERNAL: rmlh_rcvd_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPE. */
 	uint64_t fcpvwt                       : 1;  /**< Flow control protocol violation (watchdog timer).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_FCPVWT.
-                                                         INTERNAL: rtlh_fc_prot_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_FCPVWT. */
 	uint64_t dpeoosd                      : 1;  /**< DLLP protocol error (out of sequence DLLP).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_DPEOOSD.
-                                                         INTERNAL: rdlh_prot_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_DPEOOSD. */
 	uint64_t rtwdle                       : 1;  /**< Received TLP with datalink layer error.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTWDLE.
-                                                         INTERNAL: rdlh_bad_tlp_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTWDLE. */
 	uint64_t rdwdle                       : 1;  /**< Received DLLP with datalink layer error.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RDWDLE.
-                                                         INTERNAL: rdlh_bad_dllp_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RDWDLE. */
 	uint64_t mre                          : 1;  /**< Maximum number of retries exceeded.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_MRE.
-                                                         INTERNAL: xdlh_replay_num_rlover_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_MRE. */
 	uint64_t rte                          : 1;  /**< Replay timer expired. This bit is set when the REPLAY_TIMER expires in the PCIe core. The
                                                          probability of this bit being set increases with the traffic load.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTE.
-                                                         INTERNAL: xdlh_replay_timeout_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTE. */
 	uint64_t acto                         : 1;  /**< A completion timeout occurred.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_ACTO.
-                                                         INTERNAL: pedc_radm_cpl_timeout. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_ACTO. */
 	uint64_t rvdm                         : 1;  /**< Received vendor-defined message.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RVDM.
-                                                         INTERNAL: pedc_radm_vendor_msg. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RVDM. */
 	uint64_t rumep                        : 1;  /**< Received unlock message (EP mode only).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RUMEP.
-                                                         INTERNAL: pedc_radm_msg_unlock. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RUMEP. */
 	uint64_t rptamrc                      : 1;  /**< Received PME turnoff acknowledge message (RC mode only).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPTAMRC.
-                                                         INTERNAL: pedc_radm_pm_to_ack. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPTAMRC. */
 	uint64_t rpmerc                       : 1;  /**< Received PME message (RC mode only).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPMERC.
-                                                         INTERNAL: pedc_radm_pm_pme. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPMERC. */
 	uint64_t rfemrc                       : 1;  /**< Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
                                                          is set.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RFEMRC.
-                                                         INTERNAL: pedc_radm_fatal_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RFEMRC. */
 	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message (RC mode only).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RNFEMRC.
-                                                         INTERNAL: pedc_radm_nonfatal_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RNFEMRC. */
 	uint64_t rcemrc                       : 1;  /**< Received correctable error message (RC mode only).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RCEMRC.
-                                                         INTERNAL: pedc_radm_correctable_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RCEMRC. */
 	uint64_t rpoison                      : 1;  /**< Received poisoned TLP.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPOISON.
-                                                         INTERNAL: pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPOISON. */
 	uint64_t recrce                       : 1;  /**< Received ECRC error.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RECRCE.
-                                                         INTERNAL: pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RECRCE. */
 	uint64_t rtlplle                      : 1;  /**< Received TLP has link layer error.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTLPLLE.
-                                                         INTERNAL: pedc_radm_trgt1_dllp_abort & pedc__radm_trgt1_eot. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTLPLLE. */
 	uint64_t rtlpmal                      : 1;  /**< Received TLP is malformed or a message. If the core receives a MSG (or Vendor Message) or
                                                          if a received AtomicOp viloates address/length rules, this bit is set as well.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTLPMAL.
-                                                         INTERNAL: pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTLPMAL. */
 	uint64_t spoison                      : 1;  /**< Poisoned TLP sent.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_SPOISON.
-                                                         INTERNAL: peai__client0_tlp_ep & peai__client0_tlp_hv or peai__client1_tlp_ep
-                                                                   & peai__client1_tlp_hv (atomic_op). */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_SPOISON. */
 #else
 	uint64_t spoison                      : 1;
 	uint64_t rtlpmal                      : 1;
@@ -2386,101 +2472,70 @@ union cvmx_pemx_dbg_info {
 	uint64_t ecrc_e                       : 1;  /**< Received an ECRC error.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_ECRC_E. */
 	uint64_t rawwpp                       : 1;  /**< Received a write with poisoned payload.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAWWPP.
-                                                         INTERNAL: radm_rcvd_wreq_poisoned. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAWWPP. */
 	uint64_t racpp                        : 1;  /**< Received a completion with poisoned payload.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACPP.
-                                                         INTERNAL: radm_rcvd_cpl_poisoned. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACPP. */
 	uint64_t ramtlp                       : 1;  /**< Received a malformed TLP.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAMTLP.
-                                                         INTERNAL: radm_mlf_tlp_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAMTLP. */
 	uint64_t rarwdns                      : 1;  /**< Received a request which device does not support.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RARWDNS.
-                                                         INTERNAL: radm_rcvd_ur_req. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RARWDNS. */
 	uint64_t caar                         : 1;  /**< Completer aborted a request.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_CAAR.
-                                                         INTERNAL: radm_rcvd_cpl_ca */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_CAAR. */
 	uint64_t racca                        : 1;  /**< Received a completion with CA status.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACCA.
-                                                         INTERNAL: radm_rcvd_cpl_ca. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACCA. */
 	uint64_t racur                        : 1;  /**< Received a completion with UR status.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACUR.
-                                                         INTERNAL: radm_rcvd_cpl_ur. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACUR. */
 	uint64_t rauc                         : 1;  /**< Received an unexpected completion.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAUC.
-                                                         INTERNAL: radm_unexp_cpl_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAUC. */
 	uint64_t rqo                          : 1;  /**< Receive queue overflow. Normally happens only when flow control advertisements are
                                                          ignored.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RQO.
-                                                         INTERNAL: radm_qoverflow. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RQO. */
 	uint64_t fcuv                         : 1;  /**< Flow control update violation.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_FCUV.
-                                                         INTERNAL: (opt. checks) int_xadm_fc_prot_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_FCUV. */
 	uint64_t rpe                          : 1;  /**< PHY reported an 8B/10B decode error (RxStatus = 0x4) or disparity error (RxStatus =
                                                          0x7).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPE.
-                                                         INTERNAL: rmlh_rcvd_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPE. */
 	uint64_t fcpvwt                       : 1;  /**< Flow control protocol violation (watchdog timer).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_FCPVWT.
-                                                         INTERNAL: rtlh_fc_prot_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_FCPVWT. */
 	uint64_t dpeoosd                      : 1;  /**< DLLP protocol error (out of sequence DLLP).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_DPEOOSD.
-                                                         INTERNAL: rdlh_prot_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_DPEOOSD. */
 	uint64_t rtwdle                       : 1;  /**< Received TLP with datalink layer error.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTWDLE.
-                                                         INTERNAL: rdlh_bad_tlp_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTWDLE. */
 	uint64_t rdwdle                       : 1;  /**< Received DLLP with datalink layer error.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RDWDLE.
-                                                         INTERNAL: rdlh_bad_dllp_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RDWDLE. */
 	uint64_t mre                          : 1;  /**< Maximum number of retries exceeded.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_MRE.
-                                                         INTERNAL: xdlh_replay_num_rlover_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_MRE. */
 	uint64_t rte                          : 1;  /**< Replay timer expired. This bit is set when the REPLAY_TIMER expires in the PCIe core. The
                                                          probability of this bit being set increases with the traffic load.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTE.
-                                                         INTERNAL: xdlh_replay_timeout_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTE. */
 	uint64_t acto                         : 1;  /**< A completion timeout occurred.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_ACTO.
-                                                         INTERNAL: pedc_radm_cpl_timeout. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_ACTO. */
 	uint64_t rvdm                         : 1;  /**< Received vendor-defined message.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RVDM.
-                                                         INTERNAL: pedc_radm_vendor_msg. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RVDM. */
 	uint64_t rumep                        : 1;  /**< Received unlock message (EP mode only).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RUMEP.
-                                                         INTERNAL: pedc_radm_msg_unlock. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RUMEP. */
 	uint64_t rptamrc                      : 1;  /**< Received PME turnoff acknowledge message (RC mode only).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPTAMRC.
-                                                         INTERNAL: pedc_radm_pm_to_ack. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPTAMRC. */
 	uint64_t rpmerc                       : 1;  /**< Received PME message (RC mode only).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPMERC.
-                                                         INTERNAL: pedc_radm_pm_pme. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPMERC. */
 	uint64_t rfemrc                       : 1;  /**< Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
                                                          is set.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RFEMRC.
-                                                         INTERNAL: pedc_radm_fatal_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RFEMRC. */
 	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message (RC mode only).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RNFEMRC.
-                                                         INTERNAL: pedc_radm_nonfatal_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RNFEMRC. */
 	uint64_t rcemrc                       : 1;  /**< Received correctable error message (RC mode only).
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RCEMRC.
-                                                         INTERNAL: pedc_radm_correctable_err. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RCEMRC. */
 	uint64_t rpoison                      : 1;  /**< Received poisoned TLP.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPOISON.
-                                                         INTERNAL: pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPOISON. */
 	uint64_t recrce                       : 1;  /**< Received ECRC error.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RECRCE.
-                                                         INTERNAL: pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RECRCE. */
 	uint64_t rtlplle                      : 1;  /**< Received TLP has link layer error.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTLPLLE.
-                                                         INTERNAL: pedc_radm_trgt1_dllp_abort & pedc__radm_trgt1_eot. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTLPLLE. */
 	uint64_t rtlpmal                      : 1;  /**< Received TLP is malformed or a message. If the core receives a MSG (or Vendor Message) or
                                                          if a received AtomicOp viloates address/length rules, this bit is set as well.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTLPMAL.
-                                                         INTERNAL: pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTLPMAL. */
 	uint64_t spoison                      : 1;  /**< Poisoned TLP sent.
-                                                         Throws PEM_INTSN_E::PEM()_ERROR_SPOISON.
-                                                         INTERNAL: peai__client0_tlp_ep & peai__client0_tlp_hv or peai__client1_tlp_ep
-                                                                   & peai__client1_tlp_hv (atomic_op). */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_SPOISON. */
 #else
 	uint64_t spoison                      : 1;
 	uint64_t rtlpmal                      : 1;
@@ -2550,75 +2605,126 @@ union cvmx_pemx_dbg_info {
 	struct cvmx_pemx_dbg_info_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_58_63               : 6;
-	uint64_t qhdr_b1_dbe                  : 1;  /**< Detected a core header queue bank1 double bit error. */
-	uint64_t qhdr_b1_sbe                  : 1;  /**< Detected a core header queue bank1 single bit error. */
-	uint64_t qhdr_b0_dbe                  : 1;  /**< Detected a core header queue bank0 double bit error. */
-	uint64_t qhdr_b0_sbe                  : 1;  /**< Detected a core header queue bank0 single bit error. */
-	uint64_t rtry_dbe                     : 1;  /**< Detected a core retry RAM double bit error. */
-	uint64_t rtry_sbe                     : 1;  /**< Detected a core retry RAM single bit error. */
-	uint64_t c_c_dbe                      : 1;  /**< Detected a TLP CPL FIFO control double bit error. */
-	uint64_t c_c_sbe                      : 1;  /**< Detected a TLP CPL FIFO control single bit error. */
-	uint64_t c_d1_dbe                     : 1;  /**< Detected a TLP CPL FIFO data1 double bit error. */
-	uint64_t c_d1_sbe                     : 1;  /**< Detected a TLP CPL FIFO data1 single bit error. */
-	uint64_t c_d0_dbe                     : 1;  /**< Detected a TLP CPL FIFO data0 double bit error. */
-	uint64_t c_d0_sbe                     : 1;  /**< Detected a TLP CPL FIFO data0 single bit error. */
-	uint64_t n_c_dbe                      : 1;  /**< Detected a TLP NP FIFO control double bit error. */
-	uint64_t n_c_sbe                      : 1;  /**< Detected a TLP NP FIFO control single bit error. */
-	uint64_t n_d1_dbe                     : 1;  /**< Detected a TLP NP FIFO data1 double bit error. */
-	uint64_t n_d1_sbe                     : 1;  /**< Detected a TLP NP FIFO data1 single bit error. */
-	uint64_t n_d0_dbe                     : 1;  /**< Detected a TLP NP FIFO data0 double bit error. */
-	uint64_t n_d0_sbe                     : 1;  /**< Detected a TLP NP FIFO data0 single bit error. */
-	uint64_t p_c_dbe                      : 1;  /**< Detected a TLP posted FIFO control double bit error. */
-	uint64_t p_c_sbe                      : 1;  /**< Detected a TLP posted FIFO control single bit error. */
-	uint64_t p_d1_dbe                     : 1;  /**< Detected a TLP posted FIFO data1 double bit error. */
-	uint64_t p_d1_sbe                     : 1;  /**< Detected a TLP posted FIFO data1 single bit error. */
-	uint64_t p_d0_dbe                     : 1;  /**< Detected a TLP posted FIFO data0 double bit error. */
-	uint64_t p_d0_sbe                     : 1;  /**< Detected a TLP posted FIFO data0 single bit error. */
-	uint64_t datq_pe                      : 1;  /**< Detected a data queue RAM parity error. */
+	uint64_t qhdr_b1_dbe                  : 1;  /**< Detected a core header queue bank1 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_QHDR_B1_DBE. */
+	uint64_t qhdr_b1_sbe                  : 1;  /**< Detected a core header queue bank1 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_QHDR_B1_SBE. */
+	uint64_t qhdr_b0_dbe                  : 1;  /**< Detected a core header queue bank0 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_QHDR_B0_DBE. */
+	uint64_t qhdr_b0_sbe                  : 1;  /**< Detected a core header queue bank0 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_QHDR_B0_SBE. */
+	uint64_t rtry_dbe                     : 1;  /**< Detected a core retry RAM double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTRY_DBE. */
+	uint64_t rtry_sbe                     : 1;  /**< Detected a core retry RAM single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTRY_SBE. */
+	uint64_t c_c_dbe                      : 1;  /**< Detected a SLI TLP CPL FIFO control double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_C_C_DBE. */
+	uint64_t c_c_sbe                      : 1;  /**< Detected a SLI TLP CPL FIFO control single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_C_C_SBE. */
+	uint64_t c_d1_dbe                     : 1;  /**< Detected a SLI TLP CPL FIFO data1 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_C_D1_DBE. */
+	uint64_t c_d1_sbe                     : 1;  /**< Detected a SLI TLP CPL FIFO data1 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_C_D1_SBE. */
+	uint64_t c_d0_dbe                     : 1;  /**< Detected a SLI TLP CPL FIFO data0 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_C_D0_DBE. */
+	uint64_t c_d0_sbe                     : 1;  /**< Detected a SLI TLP CPL FIFO data0 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_C_D0_SBE. */
+	uint64_t n_c_dbe                      : 1;  /**< Detected a SLI TLP NP FIFO control double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_N_C_DBE. */
+	uint64_t n_c_sbe                      : 1;  /**< Detected a SLI TLP NP FIFO control single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_N_C_SBE. */
+	uint64_t n_d1_dbe                     : 1;  /**< Detected a SLI TLP NP FIFO data1 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_N_D1_DBE. */
+	uint64_t n_d1_sbe                     : 1;  /**< Detected a SLI TLP NP FIFO data1 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_N_D1_SBE. */
+	uint64_t n_d0_dbe                     : 1;  /**< Detected a SLI TLP NP FIFO data0 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_N_D0_DBE. */
+	uint64_t n_d0_sbe                     : 1;  /**< Detected a SLI TLP NP FIFO data0 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_N_D0_SBE. */
+	uint64_t p_c_dbe                      : 1;  /**< Detected a SLI TLP posted FIFO control double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_P_C_DBE. */
+	uint64_t p_c_sbe                      : 1;  /**< Detected a SLI TLP posted FIFO control single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_P_C_SBE. */
+	uint64_t p_d1_dbe                     : 1;  /**< Detected a SLI TLP posted FIFO data1 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_P_D1_DBE. */
+	uint64_t p_d1_sbe                     : 1;  /**< Detected a SLI TLP posted FIFO data1 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_P_D1_SBE. */
+	uint64_t p_d0_dbe                     : 1;  /**< Detected a SLI TLP posted FIFO data0 double bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_P_D0_DBE. */
+	uint64_t p_d0_sbe                     : 1;  /**< Detected a SLI TLP posted FIFO data0 single bit error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_P_D0_SBE. */
+	uint64_t datq_pe                      : 1;  /**< Detected a data queue RAM parity error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_DATQ_PE. */
 	uint64_t reserved_32_32               : 1;
-	uint64_t lofp                         : 1;  /**< Lack of forward progress at TLP FIFOs timeout occurred. */
-	uint64_t ecrc_e                       : 1;  /**< Received an ECRC error. */
-	uint64_t rawwpp                       : 1;  /**< Received a write with poisoned payload. INTERNAL: radm_rcvd_wreq_poisoned. */
-	uint64_t racpp                        : 1;  /**< Received a completion with poisoned payload. INTERNAL: radm_rcvd_cpl_poisoned. */
-	uint64_t ramtlp                       : 1;  /**< Received a malformed TLP. INTERNAL: radm_mlf_tlp_err. */
-	uint64_t rarwdns                      : 1;  /**< Received a request which device does not support. INTERNAL: radm_rcvd_ur_req. */
-	uint64_t caar                         : 1;  /**< Completer aborted a request. This bit is never set because CNXXXX does not generate
-                                                         completer aborts. */
-	uint64_t racca                        : 1;  /**< Received a completion with CA status. INTERNAL: radm_rcvd_cpl_ca. */
-	uint64_t racur                        : 1;  /**< Received a completion with UR status. INTERNAL: radm_rcvd_cpl_ur. */
-	uint64_t rauc                         : 1;  /**< Received an unexpected completion. INTERNAL: radm_unexp_cpl_err. */
+	uint64_t lofp                         : 1;  /**< Lack of forward progress at TLP FIFOs timeout occurred.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_LOFP. */
+	uint64_t ecrc_e                       : 1;  /**< Received an ECRC error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_ECRC_E. */
+	uint64_t rawwpp                       : 1;  /**< Received a write with poisoned payload.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAWWPP. */
+	uint64_t racpp                        : 1;  /**< Received a completion with poisoned payload.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACPP. */
+	uint64_t ramtlp                       : 1;  /**< Received a malformed TLP.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAMTLP. */
+	uint64_t rarwdns                      : 1;  /**< Received a request which device does not support.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RARWDNS. */
+	uint64_t caar                         : 1;  /**< Completer aborted a request.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_CAAR. */
+	uint64_t racca                        : 1;  /**< Received a completion with CA status.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACCA. */
+	uint64_t racur                        : 1;  /**< Received a completion with UR status.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RACUR. */
+	uint64_t rauc                         : 1;  /**< Received an unexpected completion.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RAUC. */
 	uint64_t rqo                          : 1;  /**< Receive queue overflow. Normally happens only when flow control advertisements are
-                                                         ignored. INTERNAL: radm_qoverflow. */
-	uint64_t fcuv                         : 1;  /**< Flow control update violation. INTERNAL: (opt. checks) int_xadm_fc_prot_err. */
+                                                         ignored.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RQO. */
+	uint64_t fcuv                         : 1;  /**< Flow control update violation.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_FCUV. */
 	uint64_t rpe                          : 1;  /**< PHY reported an 8B/10B decode error (RxStatus = 0x4) or disparity error (RxStatus =
-                                                         0x7). INTERNAL: rmlh_rcvd_err. */
-	uint64_t fcpvwt                       : 1;  /**< Flow control protocol violation (watchdog timer). INTERNAL: rtlh_fc_prot_err. */
-	uint64_t dpeoosd                      : 1;  /**< DLLP protocol error (out of sequence DLLP). INTERNAL: rdlh_prot_err. */
-	uint64_t rtwdle                       : 1;  /**< Received TLP with datalink layer error. INTERNAL: rdlh_bad_tlp_err. */
-	uint64_t rdwdle                       : 1;  /**< Received DLLP with datalink layer error. INTERNAL: rdlh_bad_dllp_err. */
-	uint64_t mre                          : 1;  /**< Maximum number of retries exceeded. INTERNAL: xdlh_replay_num_rlover_err. */
+                                                         0x7).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPE. */
+	uint64_t fcpvwt                       : 1;  /**< Flow control protocol violation (watchdog timer).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_FCPVWT. */
+	uint64_t dpeoosd                      : 1;  /**< DLLP protocol error (out of sequence DLLP).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_DPEOOSD. */
+	uint64_t rtwdle                       : 1;  /**< Received TLP with datalink layer error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTWDLE. */
+	uint64_t rdwdle                       : 1;  /**< Received DLLP with datalink layer error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RDWDLE. */
+	uint64_t mre                          : 1;  /**< Maximum number of retries exceeded.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_MRE. */
 	uint64_t rte                          : 1;  /**< Replay timer expired. This bit is set when the REPLAY_TIMER expires in the PCIe core. The
                                                          probability of this bit being set increases with the traffic load.
-                                                         INTERNAL: xdlh_replay_timeout_err. */
-	uint64_t acto                         : 1;  /**< A completion timeout occurred. INTERNAL: pedc_radm_cpl_timeout. */
-	uint64_t rvdm                         : 1;  /**< Received vendor-defined message. INTERNAL: pedc_radm_vendor_msg. */
-	uint64_t rumep                        : 1;  /**< Received unlock message (EP mode only). INTERNAL: pedc_radm_msg_unlock. */
-	uint64_t rptamrc                      : 1;  /**< Received PME turnoff acknowledge message (RC mode only). INTERNAL: pedc_radm_pm_to_ack. */
-	uint64_t rpmerc                       : 1;  /**< Received PME message (RC mode only). INTERNAL: pedc_radm_pm_pme. */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTE. */
+	uint64_t acto                         : 1;  /**< A completion timeout occurred.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_ACTO. */
+	uint64_t rvdm                         : 1;  /**< Received vendor-defined message.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RVDM. */
+	uint64_t rumep                        : 1;  /**< Received unlock message (EP mode only).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RUMEP. */
+	uint64_t rptamrc                      : 1;  /**< Received PME turnoff acknowledge message (RC mode only).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPTAMRC. */
+	uint64_t rpmerc                       : 1;  /**< Received PME message (RC mode only).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPMERC. */
 	uint64_t rfemrc                       : 1;  /**< Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
-                                                         is set. INTERNAL: pedc_radm_fatal_err. */
-	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message (RC mode only). INTERNAL: pedc_radm_nonfatal_err. */
-	uint64_t rcemrc                       : 1;  /**< Received correctable error message (RC mode only). INTERNAL: pedc_radm_correctable_err. */
-	uint64_t rpoison                      : 1;  /**< Received poisoned TLP. INTERNAL: pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
-	uint64_t recrce                       : 1;  /**< Received ECRC error. INTERNAL: pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
-	uint64_t rtlplle                      : 1;  /**< Received TLP has link layer error. INTERNAL: pedc_radm_trgt1_dllp_abort &
-                                                         pedc__radm_trgt1_eot. */
+                                                         is set.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RFEMRC. */
+	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message (RC mode only).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RNFEMRC. */
+	uint64_t rcemrc                       : 1;  /**< Received correctable error message (RC mode only).
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RCEMRC. */
+	uint64_t rpoison                      : 1;  /**< Received poisoned TLP.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RPOISON. */
+	uint64_t recrce                       : 1;  /**< Received ECRC error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RECRCE. */
+	uint64_t rtlplle                      : 1;  /**< Received TLP has link layer error.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTLPLLE. */
 	uint64_t rtlpmal                      : 1;  /**< Received TLP is malformed or a message. If the core receives a MSG (or Vendor Message) or
                                                          if a received AtomicOp viloates address/length rules, this bit is set as well.
-                                                         INTERNAL: pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
-	uint64_t spoison                      : 1;  /**< Poisoned TLP sent. Throws PEM_INTSN_E::PEM(0..3)_ERROR_SPOISON.
-                                                         INTERNAL: peai__client0_tlp_ep &
-                                                         peai__client0_tlp_hv or peai__client1_tlp_ep & peai__client1_tlp_hv (atomic_op). */
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_RTLPMAL. */
+	uint64_t spoison                      : 1;  /**< Poisoned TLP sent.
+                                                         Throws PEM_INTSN_E::PEM()_ERROR_SPOISON. */
 #else
 	uint64_t spoison                      : 1;
 	uint64_t rtlpmal                      : 1;
@@ -2681,7 +2787,7 @@ union cvmx_pemx_dbg_info {
 	uint64_t reserved_58_63               : 6;
 #endif
 	} cn78xx;
-	struct cvmx_pemx_dbg_info_cn78xx      cn78xxp2;
+	struct cvmx_pemx_dbg_info_cn73xx      cn78xxp2;
 	struct cvmx_pemx_dbg_info_cn61xx      cnf71xx;
 	struct cvmx_pemx_dbg_info_cn73xx      cnf75xx;
 };
@@ -3084,7 +3190,7 @@ union cvmx_pemx_ecc_ena {
 	uint64_t reserved_35_63               : 29;
 #endif
 	} cn78xx;
-	struct cvmx_pemx_ecc_ena_cn78xx       cn78xxp2;
+	struct cvmx_pemx_ecc_ena_cn73xx       cn78xxp2;
 	struct cvmx_pemx_ecc_ena_cn73xx       cnf75xx;
 };
 typedef union cvmx_pemx_ecc_ena cvmx_pemx_ecc_ena_t;
@@ -3214,7 +3320,7 @@ union cvmx_pemx_ecc_synd_ctrl {
 	uint64_t reserved_38_63               : 26;
 #endif
 	} cn78xx;
-	struct cvmx_pemx_ecc_synd_ctrl_cn78xx cn78xxp2;
+	struct cvmx_pemx_ecc_synd_ctrl_cn73xx cn78xxp2;
 	struct cvmx_pemx_ecc_synd_ctrl_cn73xx cnf75xx;
 };
 typedef union cvmx_pemx_ecc_synd_ctrl cvmx_pemx_ecc_synd_ctrl_t;
@@ -3227,13 +3333,14 @@ union cvmx_pemx_eco {
 	struct cvmx_pemx_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t eco_rw                       : 8;  /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 8;  /**< N/A */
 #else
 	uint64_t eco_rw                       : 8;
 	uint64_t reserved_8_63                : 56;
 #endif
 	} s;
 	struct cvmx_pemx_eco_s                cn73xx;
+	struct cvmx_pemx_eco_s                cn78xxp2;
 	struct cvmx_pemx_eco_s                cnf75xx;
 };
 typedef union cvmx_pemx_eco cvmx_pemx_eco_t;
@@ -3267,6 +3374,7 @@ union cvmx_pemx_flr_glblcnt_ctl {
 #endif
 	} s;
 	struct cvmx_pemx_flr_glblcnt_ctl_s    cn73xx;
+	struct cvmx_pemx_flr_glblcnt_ctl_s    cn78xxp2;
 	struct cvmx_pemx_flr_glblcnt_ctl_s    cnf75xx;
 };
 typedef union cvmx_pemx_flr_glblcnt_ctl cvmx_pemx_flr_glblcnt_ctl_t;
@@ -3301,6 +3409,7 @@ union cvmx_pemx_flr_pf0_vf_stopreq {
 #endif
 	} s;
 	struct cvmx_pemx_flr_pf0_vf_stopreq_s cn73xx;
+	struct cvmx_pemx_flr_pf0_vf_stopreq_s cn78xxp2;
 	struct cvmx_pemx_flr_pf0_vf_stopreq_s cnf75xx;
 };
 typedef union cvmx_pemx_flr_pf0_vf_stopreq cvmx_pemx_flr_pf0_vf_stopreq_t;
@@ -3341,6 +3450,7 @@ union cvmx_pemx_flr_pf_stopreq {
 #endif
 	} s;
 	struct cvmx_pemx_flr_pf_stopreq_s     cn73xx;
+	struct cvmx_pemx_flr_pf_stopreq_s     cn78xxp2;
 	struct cvmx_pemx_flr_pf_stopreq_s     cnf75xx;
 };
 typedef union cvmx_pemx_flr_pf_stopreq cvmx_pemx_flr_pf_stopreq_t;
@@ -3370,6 +3480,7 @@ union cvmx_pemx_flr_stopreq_ctl {
 	uint64_t reserved_1_63                : 63;
 #endif
 	} s;
+	struct cvmx_pemx_flr_stopreq_ctl_s    cn78xxp2;
 	struct cvmx_pemx_flr_stopreq_ctl_s    cnf75xx;
 };
 typedef union cvmx_pemx_flr_stopreq_ctl cvmx_pemx_flr_stopreq_ctl_t;
@@ -3400,6 +3511,7 @@ union cvmx_pemx_flr_zombie_ctl {
 #endif
 	} s;
 	struct cvmx_pemx_flr_zombie_ctl_s     cn73xx;
+	struct cvmx_pemx_flr_zombie_ctl_s     cn78xxp2;
 	struct cvmx_pemx_flr_zombie_ctl_s     cnf75xx;
 };
 typedef union cvmx_pemx_flr_zombie_ctl cvmx_pemx_flr_zombie_ctl_t;
@@ -3630,15 +3742,12 @@ union cvmx_pemx_int_sum {
 	uint64_t pmem                         : 1;  /**< Recived PME MSG.
                                                          (radm_pm_pme) */
 	uint64_t pmei                         : 1;  /**< PME interrupt. This is a level-sensitive interrupt.
-                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_PMEI.
-                                                         INTERNAL: cfg_pme_int */
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_PMEI. */
 	uint64_t se                           : 1;  /**< System error, RC mode only.
-                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_SE.
-                                                         INTERNAL: cfg_sys_err_rc */
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_SE. */
 	uint64_t aeri                         : 1;  /**< Advanced error reporting interrupt, RC mode only.
                                                          This is a level-sensitive interrupt.
-                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_AERI.
-                                                         INTERNAL: cfg_aer_rc_err_int */
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_AERI. */
 #else
 	uint64_t aeri                         : 1;
 	uint64_t se                           : 1;
@@ -3747,15 +3856,12 @@ union cvmx_pemx_int_sum {
                                                          Throws corresponding PEM_INTSN_E::PEM()_ERROR_UP_B1. */
 	uint64_t reserved_3_3                 : 1;
 	uint64_t pmei                         : 1;  /**< PME interrupt. This is a level-sensitive interrupt.
-                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_PMEI.
-                                                         INTERNAL: cfg_pme_int */
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_PMEI. */
 	uint64_t se                           : 1;  /**< System error, RC mode only.
-                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_SE.
-                                                         INTERNAL: cfg_sys_err_rc */
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_SE. */
 	uint64_t aeri                         : 1;  /**< Advanced error reporting interrupt, RC mode only.
                                                          This is a level-sensitive interrupt.
-                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_AERI.
-                                                         INTERNAL: cfg_aer_rc_err_int */
+                                                         Throws corresponding PEM_INTSN_E::PEM()_ERROR_AERI. */
 #else
 	uint64_t aeri                         : 1;
 	uint64_t se                           : 1;
@@ -3865,7 +3971,7 @@ union cvmx_pemx_p2n_bar0_start {
 	uint64_t addr                         : 49;
 #endif
 	} cn78xx;
-	struct cvmx_pemx_p2n_bar0_start_cn78xx cn78xxp2;
+	struct cvmx_pemx_p2n_bar0_start_cn73xx cn78xxp2;
 	struct cvmx_pemx_p2n_bar0_start_cn61xx cnf71xx;
 	struct cvmx_pemx_p2n_bar0_start_cn73xx cnf75xx;
 };
@@ -4184,9 +4290,7 @@ union cvmx_pemx_strap {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
 	uint64_t miopem2dlm5sel               : 1;  /**< The value of the BOOT_AD[13] pin via MIO, which is captured on chip cold reset. It is not
-                                                         affected by any other reset.  Only used for PEM2.  When set, PEM2 is configured to
-                                                         DLM5 and PEM()_QLM[PEMDLMSEL] will be set, the Mac will be confifgured for 2 lanes.
-                                                         When clear, PEM2 is configured to QLM2. */
+                                                         affected by any other reset.  This bit is not used in CN75XX. */
 	uint64_t pilaneswap                   : 1;  /**< The value of the pi_select_laneswap pin, which is captured on chip cold reset. It is not
                                                          affected by any other reset.  When set, lane swapping is performed to/from the
                                                          SerDes. When clear, no lane swapping is performed. */
@@ -4265,9 +4369,7 @@ union cvmx_pemx_strap {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
 	uint64_t miopem2dlm5sel               : 1;  /**< The value of the BOOT_AD[13] pin via MIO, which is captured on chip cold reset. It is not
-                                                         affected by any other reset.  Only used for PEM2.  When set, PEM2 is configured to
-                                                         DLM5 and PEM()_QLM[PEMDLMSEL] will be set, the Mac will be confifgured for 2 lanes.
-                                                         When clear, PEM2 is configured to QLM2. */
+                                                         affected by any other reset.  This bit is not used in CN75XX. */
 	uint64_t pilaneswap                   : 1;  /**< The value of the pi_select_laneswap pin, which is captured on chip cold reset. It is not
                                                          affected by any other reset.  When set, lane swapping is performed to/from the
                                                          SerDes. When clear, no lane swapping is performed. */
diff --git a/arch/mips/include/asm/octeon/cvmx-pexp-defs.h b/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
index 3e09d5a..ba0c250 100644
--- a/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
@@ -1318,6 +1318,7 @@ static inline uint64_t CVMX_PEXP_SLITB_MSIXX_TABLE_ADDR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
 		cvmx_warn("CVMX_PEXP_SLITB_MSIXX_TABLE_ADDR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000004000ull) + ((offset) & 127) * 16;
@@ -1330,6 +1331,7 @@ static inline uint64_t CVMX_PEXP_SLITB_MSIXX_TABLE_DATA(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
 		cvmx_warn("CVMX_PEXP_SLITB_MSIXX_TABLE_DATA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000004008ull) + ((offset) & 127) * 16;
@@ -1342,6 +1344,7 @@ static inline uint64_t CVMX_PEXP_SLITB_MSIX_MACX_PFX_TABLE_ADDR(unsigned long of
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEXP_SLITB_MSIX_MACX_PFX_TABLE_ADDR(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000002000ull) + ((offset) & 1) * 4096 + ((block_id) & 3) * 0x10ull;
@@ -1354,6 +1357,7 @@ static inline uint64_t CVMX_PEXP_SLITB_MSIX_MACX_PFX_TABLE_DATA(unsigned long of
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEXP_SLITB_MSIX_MACX_PFX_TABLE_DATA(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000002008ull) + ((offset) & 1) * 4096 + ((block_id) & 3) * 0x10ull;
@@ -1366,6 +1370,7 @@ static inline uint64_t CVMX_PEXP_SLITB_PFX_PKT_CNT_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_PEXP_SLITB_PFX_PKT_CNT_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000008000ull) + ((offset) & 7) * 16;
@@ -1378,6 +1383,7 @@ static inline uint64_t CVMX_PEXP_SLITB_PFX_PKT_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_PEXP_SLITB_PFX_PKT_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000008300ull) + ((offset) & 7) * 16;
@@ -1390,6 +1396,7 @@ static inline uint64_t CVMX_PEXP_SLITB_PFX_PKT_IN_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_PEXP_SLITB_PFX_PKT_IN_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000008200ull) + ((offset) & 7) * 16;
@@ -1402,6 +1409,7 @@ static inline uint64_t CVMX_PEXP_SLITB_PFX_PKT_RING_RST(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_PEXP_SLITB_PFX_PKT_RING_RST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000008400ull) + ((offset) & 7) * 16;
@@ -1414,6 +1422,7 @@ static inline uint64_t CVMX_PEXP_SLITB_PFX_PKT_TIME_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_PEXP_SLITB_PFX_PKT_TIME_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000008100ull) + ((offset) & 7) * 16;
@@ -1426,6 +1435,7 @@ static inline uint64_t CVMX_PEXP_SLITB_PKTX_PF_VF_MBOX_SIGX(unsigned long offset
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 127)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 127)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 127))))))
 		cvmx_warn("CVMX_PEXP_SLITB_PKTX_PF_VF_MBOX_SIGX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000011000ull) + (((offset) & 1) + ((block_id) & 127) * 0x4000ull) * 8;
@@ -1442,13 +1452,17 @@ static inline uint64_t CVMX_PEXP_SLI_BIST_STATUS_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010580ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000010580ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000028580ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028580ull);
 			break;
 	}
@@ -1464,12 +1478,16 @@ static inline uint64_t CVMX_PEXP_SLI_BIST_STATUS_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010580ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000010580ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000028580ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028580ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000028580ull);
@@ -1494,15 +1512,20 @@ static inline uint64_t CVMX_PEXP_SLI_CTL_PORTX(unsigned long offset)
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 3) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return CVMX_ADD_IO_SEG(0x00011F00000106E0ull) + ((offset) & 3) * 16;
-			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011F00000106E0ull) + ((offset) & 3) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + ((offset) & 3) * 16;
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + ((offset) & 3) * 16;
 			break;
+
+			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_CTL_PORTX (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + ((offset) & 3) * 16;
@@ -1520,11 +1543,15 @@ static inline uint64_t CVMX_PEXP_SLI_CTL_PORTX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 16;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000106E0ull) + (offset) * 16;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F00000106E0ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + (offset) * 16;
 			return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + (offset) * 16;
+
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + (offset) * 16;
 }
@@ -1538,13 +1565,17 @@ static inline uint64_t CVMX_PEXP_SLI_CTL_STATUS_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010570ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000010570ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000028570ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028570ull);
 			break;
 	}
@@ -1560,12 +1591,16 @@ static inline uint64_t CVMX_PEXP_SLI_CTL_STATUS_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010570ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000010570ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000028570ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028570ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000028570ull);
@@ -1580,13 +1615,17 @@ static inline uint64_t CVMX_PEXP_SLI_DATA_OUT_CNT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000105F0ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F00000105F0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F00000285F0ull);
 			return CVMX_ADD_IO_SEG(0x00011F00000285F0ull);
 			break;
 	}
@@ -1602,12 +1641,16 @@ static inline uint64_t CVMX_PEXP_SLI_DATA_OUT_CNT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000105F0ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F00000105F0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F00000285F0ull);
 			return CVMX_ADD_IO_SEG(0x00011F00000285F0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000285F0ull);
@@ -1643,7 +1686,6 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_CNT(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
@@ -1651,6 +1693,13 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_CNT(unsigned long offset)
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011F0000010400ull) + ((offset) & 1) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011F0000028400ull) + ((offset) & 1) * 16;
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011F0000028400ull) + ((offset) & 1) * 16;
 			break;
@@ -1666,12 +1715,16 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_CNT(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010400ull) + (offset) * 16;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000010400ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000028400ull) + (offset) * 16;
 			return CVMX_ADD_IO_SEG(0x00011F0000028400ull) + (offset) * 16;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000028400ull) + (offset) * 16;
@@ -1685,7 +1738,6 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_INT_LEVEL(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
@@ -1693,6 +1745,13 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_INT_LEVEL(unsigned long offset)
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011F00000103E0ull) + ((offset) & 1) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011F00000283E0ull) + ((offset) & 1) * 16;
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011F00000283E0ull) + ((offset) & 1) * 16;
 			break;
@@ -1708,12 +1767,16 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_INT_LEVEL(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000103E0ull) + (offset) * 16;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F00000103E0ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F00000283E0ull) + (offset) * 16;
 			return CVMX_ADD_IO_SEG(0x00011F00000283E0ull) + (offset) * 16;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000283E0ull) + (offset) * 16;
@@ -1727,7 +1790,6 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_TIM(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
@@ -1735,6 +1797,13 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_TIM(unsigned long offset)
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011F0000010420ull) + ((offset) & 1) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return CVMX_ADD_IO_SEG(0x00011F0000028420ull) + ((offset) & 1) * 16;
 			if ((offset <= 1))
 				return CVMX_ADD_IO_SEG(0x00011F0000028420ull) + ((offset) & 1) * 16;
 			break;
@@ -1750,12 +1819,16 @@ static inline uint64_t CVMX_PEXP_SLI_DMAX_TIM(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010420ull) + (offset) * 16;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000010420ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000028420ull) + (offset) * 16;
 			return CVMX_ADD_IO_SEG(0x00011F0000028420ull) + (offset) * 16;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000028420ull) + (offset) * 16;
@@ -1781,7 +1854,7 @@ static inline uint64_t CVMX_PEXP_SLI_INT_ENB_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PEXP_SLI_INT_ENB_PORTX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000010340ull) + ((offset) & 3) * 16;
@@ -1793,7 +1866,7 @@ static inline uint64_t CVMX_PEXP_SLI_INT_ENB_PORTX(unsigned long offset)
 #define CVMX_PEXP_SLI_INT_SUM CVMX_PEXP_SLI_INT_SUM_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000010330ull);
 }
@@ -1849,6 +1922,7 @@ static inline uint64_t CVMX_PEXP_SLI_MACX_PFX_DMA_VF_INT(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEXP_SLI_MACX_PFX_DMA_VF_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000027280ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -1861,6 +1935,7 @@ static inline uint64_t CVMX_PEXP_SLI_MACX_PFX_DMA_VF_INT_ENB(unsigned long offse
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEXP_SLI_MACX_PFX_DMA_VF_INT_ENB(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000027500ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -1873,6 +1948,7 @@ static inline uint64_t CVMX_PEXP_SLI_MACX_PFX_FLR_VF_INT(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEXP_SLI_MACX_PFX_FLR_VF_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000027400ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -1885,6 +1961,7 @@ static inline uint64_t CVMX_PEXP_SLI_MACX_PFX_INT_ENB(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEXP_SLI_MACX_PFX_INT_ENB(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000027080ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -1897,6 +1974,7 @@ static inline uint64_t CVMX_PEXP_SLI_MACX_PFX_INT_SUM(unsigned long offset, unsi
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEXP_SLI_MACX_PFX_INT_SUM(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000027000ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -1909,6 +1987,7 @@ static inline uint64_t CVMX_PEXP_SLI_MACX_PFX_MBOX_INT(unsigned long offset, uns
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEXP_SLI_MACX_PFX_MBOX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000027380ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -1921,6 +2000,7 @@ static inline uint64_t CVMX_PEXP_SLI_MACX_PFX_PKT_VF_INT(unsigned long offset, u
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEXP_SLI_MACX_PFX_PKT_VF_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000027300ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -1933,6 +2013,7 @@ static inline uint64_t CVMX_PEXP_SLI_MACX_PFX_PKT_VF_INT_ENB(unsigned long offse
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEXP_SLI_MACX_PFX_PKT_VF_INT_ENB(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000027580ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -1945,6 +2026,7 @@ static inline uint64_t CVMX_PEXP_SLI_MACX_PFX_PP_VF_INT(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEXP_SLI_MACX_PFX_PP_VF_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000027200ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -1957,6 +2039,7 @@ static inline uint64_t CVMX_PEXP_SLI_MACX_PFX_PP_VF_INT_ENB(unsigned long offset
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEXP_SLI_MACX_PFX_PP_VF_INT_ENB(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000027480ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -1973,13 +2056,17 @@ static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013D70ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000013D70ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000023D70ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023D70ull);
 			break;
 	}
@@ -1995,12 +2082,16 @@ static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013D70ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000013D70ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000023D70ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023D70ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000023D70ull);
@@ -2014,12 +2105,16 @@ static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013E10ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000013E10ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000023E10ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023E10ull);
 			break;
 	}
@@ -2034,11 +2129,15 @@ static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013E10ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000013E10ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000023E10ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023E10ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000023E10ull);
@@ -2053,13 +2152,17 @@ static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_CTL_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000102F0ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F00000102F0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F00000282F0ull);
 			return CVMX_ADD_IO_SEG(0x00011F00000282F0ull);
 			break;
 	}
@@ -2075,12 +2178,16 @@ static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_CTL_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000102F0ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F00000102F0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F00000282F0ull);
 			return CVMX_ADD_IO_SEG(0x00011F00000282F0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000282F0ull);
@@ -2094,7 +2201,6 @@ static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if (((offset >= 12) && (offset <= 27)))
@@ -2102,6 +2208,13 @@ static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if (((offset >= 12) && (offset <= 27)))
+					return CVMX_ADD_IO_SEG(0x00011F00000100E0ull) + ((offset) & 31) * 16 - 16*12;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if (((offset >= 12) && (offset <= 27)))
+					return CVMX_ADD_IO_SEG(0x00011F00000280E0ull) + ((offset) & 31) * 16 - 16*12;
 			if (((offset >= 12) && (offset <= 27)))
 				return CVMX_ADD_IO_SEG(0x00011F00000280E0ull) + ((offset) & 31) * 16 - 16*12;
 			break;
@@ -2117,12 +2230,16 @@ static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000100E0ull) + (offset) * 16 - 16*12;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F00000100E0ull) + (offset) * 16 - 16*12;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F00000280E0ull) + (offset) * 16 - 16*12;
 			return CVMX_ADD_IO_SEG(0x00011F00000280E0ull) + (offset) * 16 - 16*12;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000280E0ull) + (offset) * 16 - 16*12;
@@ -2133,12 +2250,16 @@ static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 static inline uint64_t CVMX_PEXP_SLI_MEM_CTL_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
+			return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
 			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_MEM_CTL not supported on this chip\n");
@@ -2149,11 +2270,15 @@ static inline uint64_t CVMX_PEXP_SLI_MEM_CTL_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_MEM_CTL_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
+			return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
 }
@@ -2163,12 +2288,16 @@ static inline uint64_t CVMX_PEXP_SLI_MEM_CTL_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_MEM_INT_SUM_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
+			return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
 			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_MEM_INT_SUM not supported on this chip\n");
@@ -2179,11 +2308,15 @@ static inline uint64_t CVMX_PEXP_SLI_MEM_INT_SUM_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_MEM_INT_SUM_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
+			return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
 }
@@ -2192,14 +2325,19 @@ static inline uint64_t CVMX_PEXP_SLI_MEM_INT_SUM_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 64))
-				return CVMX_ADD_IO_SEG(0x00011F0000000000ull) + ((offset) & 127) * 16;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 64))
+					return CVMX_ADD_IO_SEG(0x00011F0000016000ull) + ((offset) & 127) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 64))
+					return CVMX_ADD_IO_SEG(0x00011F0000000000ull) + ((offset) & 127) * 16;
 			if ((offset <= 64))
-				return CVMX_ADD_IO_SEG(0x00011F0000016000ull) + ((offset) & 127) * 16;
+				return CVMX_ADD_IO_SEG(0x00011F0000000000ull) + ((offset) & 127) * 16;
 			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_MSIXX_TABLE_ADDR (offset = %lu) not supported on this chip\n", offset);
@@ -2209,11 +2347,15 @@ static inline uint64_t CVMX_PEXP_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
 static inline uint64_t CVMX_PEXP_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000000000ull) + (offset) * 16;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000016000ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000016000ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000000000ull) + (offset) * 16;
+			return CVMX_ADD_IO_SEG(0x00011F0000000000ull) + (offset) * 16;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000000000ull) + (offset) * 16;
 }
@@ -2222,14 +2364,19 @@ static inline uint64_t CVMX_PEXP_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
 static inline uint64_t CVMX_PEXP_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 64))
-				return CVMX_ADD_IO_SEG(0x00011F0000000008ull) + ((offset) & 127) * 16;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 64))
+					return CVMX_ADD_IO_SEG(0x00011F0000016008ull) + ((offset) & 127) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 64))
+					return CVMX_ADD_IO_SEG(0x00011F0000000008ull) + ((offset) & 127) * 16;
 			if ((offset <= 64))
-				return CVMX_ADD_IO_SEG(0x00011F0000016008ull) + ((offset) & 127) * 16;
+				return CVMX_ADD_IO_SEG(0x00011F0000000008ull) + ((offset) & 127) * 16;
 			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_MSIXX_TABLE_DATA (offset = %lu) not supported on this chip\n", offset);
@@ -2239,11 +2386,15 @@ static inline uint64_t CVMX_PEXP_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 static inline uint64_t CVMX_PEXP_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000000008ull) + (offset) * 16;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000016008ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000016008ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000000008ull) + (offset) * 16;
+			return CVMX_ADD_IO_SEG(0x00011F0000000008ull) + (offset) * 16;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000000008ull) + (offset) * 16;
 }
@@ -2252,7 +2403,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 static inline uint64_t CVMX_PEXP_SLI_MSIX_MACX_PF_TABLE_ADDR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PEXP_SLI_MSIX_MACX_PF_TABLE_ADDR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000017C00ull) + ((offset) & 3) * 16;
 }
@@ -2263,7 +2414,7 @@ static inline uint64_t CVMX_PEXP_SLI_MSIX_MACX_PF_TABLE_ADDR(unsigned long offse
 static inline uint64_t CVMX_PEXP_SLI_MSIX_MACX_PF_TABLE_DATA(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PEXP_SLI_MSIX_MACX_PF_TABLE_DATA(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000017C08ull) + ((offset) & 3) * 16;
 }
@@ -2275,12 +2426,16 @@ static inline uint64_t CVMX_PEXP_SLI_MSIX_MACX_PF_TABLE_DATA(unsigned long offse
 static inline uint64_t CVMX_PEXP_SLI_MSIX_PBA0_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
+			return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
 			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_MSIX_PBA0 not supported on this chip\n");
@@ -2291,11 +2446,15 @@ static inline uint64_t CVMX_PEXP_SLI_MSIX_PBA0_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_MSIX_PBA0_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
+			return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
 }
@@ -2305,12 +2464,16 @@ static inline uint64_t CVMX_PEXP_SLI_MSIX_PBA0_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_MSIX_PBA1_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000001008ull);
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000001008ull);
+			return CVMX_ADD_IO_SEG(0x00011F0000001008ull);
 			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_MSIX_PBA1 not supported on this chip\n");
@@ -2321,11 +2484,15 @@ static inline uint64_t CVMX_PEXP_SLI_MSIX_PBA1_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_MSIX_PBA1_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000001008ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000001008ull);
+			return CVMX_ADD_IO_SEG(0x00011F0000001008ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000001008ull);
 }
@@ -2383,13 +2550,17 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV0_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013C10ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000013C10ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000023C10ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023C10ull);
 			break;
 	}
@@ -2405,12 +2576,16 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV0_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013C10ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000013C10ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000023C10ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023C10ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000023C10ull);
@@ -2425,13 +2600,17 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013C20ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000013C20ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000023C20ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023C20ull);
 			break;
 	}
@@ -2447,12 +2626,16 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013C20ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000013C20ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000023C20ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023C20ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000023C20ull);
@@ -2467,13 +2650,17 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013C30ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000013C30ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000023C30ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023C30ull);
 			break;
 	}
@@ -2489,12 +2676,16 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013C30ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000013C30ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000023C30ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023C30ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000023C30ull);
@@ -2509,13 +2700,17 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV3_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013C40ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000013C40ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000023C40ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023C40ull);
 			break;
 	}
@@ -2531,12 +2726,16 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RCV3_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013C40ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000013C40ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000023C40ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023C40ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000023C40ull);
@@ -2551,13 +2750,17 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RD_MAP_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013CA0ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000013CA0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000023CA0ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023CA0ull);
 			break;
 	}
@@ -2573,12 +2776,16 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_RD_MAP_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013CA0ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000013CA0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000023CA0ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023CA0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000023CA0ull);
@@ -2681,13 +2888,17 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_WR_MAP_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013C90ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000013C90ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000023C90ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023C90ull);
 			break;
 	}
@@ -2703,12 +2914,16 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_WR_MAP_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013C90ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000013C90ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000023C90ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023C90ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000023C90ull);
@@ -2723,13 +2938,17 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013CB0ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000013CB0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000023CB0ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023CB0ull);
 			break;
 	}
@@ -2745,12 +2964,16 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013CB0ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000013CB0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000023CB0ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000023CB0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000023CB0ull);
@@ -2765,13 +2988,17 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010650ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000010650ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000028650ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028650ull);
 			break;
 	}
@@ -2787,12 +3014,16 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010650ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000010650ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000028650ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028650ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000028650ull);
@@ -2807,13 +3038,17 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010660ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000010660ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000028660ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028660ull);
 			break;
 	}
@@ -2829,12 +3064,16 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010660ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000010660ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000028660ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028660ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000028660ull);
@@ -2849,13 +3088,17 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B3_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010670ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000010670ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000028670ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028670ull);
 			break;
 	}
@@ -2871,12 +3114,16 @@ static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B3_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010670ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000010670ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000028670ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028670ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000028670ull);
@@ -2895,12 +3142,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_CNTS(unsigned long offset)
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return CVMX_ADD_IO_SEG(0x00011F00000100B0ull) + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F00000100B0ull) + ((offset) & 127) * 0x20000ull;
 			break;
@@ -2919,10 +3171,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_CNTS(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F00000100B0ull) + (offset) * 0x20000ull;
 			return CVMX_ADD_IO_SEG(0x00011F00000100B0ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000100B0ull) + (offset) * 0x20000ull;
@@ -2933,6 +3189,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_ERROR_INFO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_ERROR_INFO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F00000100C0ull) + ((offset) & 127) * 0x20000ull;
@@ -2944,15 +3201,20 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_ERROR_INFO(unsigned long offset)
 static inline uint64_t CVMX_PEXP_SLI_PKTX_INPUT_CONTROL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011F0000014000ull) + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return CVMX_ADD_IO_SEG(0x00011F0000010000ull) + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F0000010000ull) + ((offset) & 127) * 0x20000ull;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x00011F0000014000ull) + ((offset) & 63) * 16;
-			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_PKTX_INPUT_CONTROL (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000010000ull) + ((offset) & 127) * 0x20000ull;
@@ -2961,11 +3223,15 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INPUT_CONTROL(unsigned long offset)
 static inline uint64_t CVMX_PEXP_SLI_PKTX_INPUT_CONTROL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000010000ull) + (offset) * 0x20000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000014000ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000014000ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000010000ull) + (offset) * 0x20000ull;
+			return CVMX_ADD_IO_SEG(0x00011F0000010000ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000010000ull) + (offset) * 0x20000ull;
 }
@@ -2983,12 +3249,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BADDR(unsigned long offset)
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return CVMX_ADD_IO_SEG(0x00011F0000010010ull) + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F0000010010ull) + ((offset) & 127) * 0x20000ull;
 			break;
@@ -3007,10 +3278,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BADDR(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000010010ull) + (offset) * 0x20000ull;
 			return CVMX_ADD_IO_SEG(0x00011F0000010010ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000010010ull) + (offset) * 0x20000ull;
@@ -3029,12 +3304,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return CVMX_ADD_IO_SEG(0x00011F0000010020ull) + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F0000010020ull) + ((offset) & 127) * 0x20000ull;
 			break;
@@ -3053,10 +3333,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000010020ull) + (offset) * 0x20000ull;
 			return CVMX_ADD_IO_SEG(0x00011F0000010020ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000010020ull) + (offset) * 0x20000ull;
@@ -3075,12 +3359,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return CVMX_ADD_IO_SEG(0x00011F0000010030ull) + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F0000010030ull) + ((offset) & 127) * 0x20000ull;
 			break;
@@ -3099,10 +3388,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000010030ull) + (offset) * 0x20000ull;
 			return CVMX_ADD_IO_SEG(0x00011F0000010030ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000010030ull) + (offset) * 0x20000ull;
@@ -3128,15 +3421,20 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_HEADER(unsigned long offset)
 static inline uint64_t CVMX_PEXP_SLI_PKTX_INT_LEVELS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011F0000014400ull) + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return CVMX_ADD_IO_SEG(0x00011F00000100A0ull) + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F00000100A0ull) + ((offset) & 127) * 0x20000ull;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x00011F0000014400ull) + ((offset) & 63) * 16;
-			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_PKTX_INT_LEVELS (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F00000100A0ull) + ((offset) & 127) * 0x20000ull;
@@ -3145,11 +3443,15 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_INT_LEVELS(unsigned long offset)
 static inline uint64_t CVMX_PEXP_SLI_PKTX_INT_LEVELS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000100A0ull) + (offset) * 0x20000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000014400ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000014400ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F00000100A0ull) + (offset) * 0x20000ull;
+			return CVMX_ADD_IO_SEG(0x00011F00000100A0ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000100A0ull) + (offset) * 0x20000ull;
 }
@@ -3174,6 +3476,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_MBOX_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_MBOX_INT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000010210ull) + ((offset) & 127) * 0x20000ull;
@@ -3185,15 +3488,20 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_MBOX_INT(unsigned long offset)
 static inline uint64_t CVMX_PEXP_SLI_PKTX_OUTPUT_CONTROL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011F0000014800ull) + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 127) * 0x20000ull;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x00011F0000014800ull) + ((offset) & 63) * 16;
-			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_PKTX_OUTPUT_CONTROL (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 127) * 0x20000ull;
@@ -3202,11 +3510,15 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_OUTPUT_CONTROL(unsigned long offset)
 static inline uint64_t CVMX_PEXP_SLI_PKTX_OUTPUT_CONTROL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 0x20000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000014800ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000014800ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 0x20000ull;
+			return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 0x20000ull;
 }
@@ -3224,12 +3536,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_OUT_SIZE(unsigned long offset)
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return CVMX_ADD_IO_SEG(0x00011F0000010060ull) + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F0000010060ull) + ((offset) & 127) * 0x20000ull;
 			break;
@@ -3248,10 +3565,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_OUT_SIZE(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000010060ull) + (offset) * 0x20000ull;
 			return CVMX_ADD_IO_SEG(0x00011F0000010060ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000010060ull) + (offset) * 0x20000ull;
@@ -3262,6 +3583,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_PF_VF_MBOX_SIGX(unsigned long offset,
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 63)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 63)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 63))))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_PF_VF_MBOX_SIGX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000010200ull) + (((offset) & 1) + ((block_id) & 63) * 0x4000ull) * 8;
@@ -3282,12 +3604,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BADDR(unsigned long offset)
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return CVMX_ADD_IO_SEG(0x00011F0000010070ull) + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F0000010070ull) + ((offset) & 127) * 0x20000ull;
 			break;
@@ -3306,10 +3633,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BADDR(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000010070ull) + (offset) * 0x20000ull;
 			return CVMX_ADD_IO_SEG(0x00011F0000010070ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000010070ull) + (offset) * 0x20000ull;
@@ -3328,12 +3659,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return CVMX_ADD_IO_SEG(0x00011F0000010080ull) + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F0000010080ull) + ((offset) & 127) * 0x20000ull;
 			break;
@@ -3352,10 +3688,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000010080ull) + (offset) * 0x20000ull;
 			return CVMX_ADD_IO_SEG(0x00011F0000010080ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000010080ull) + (offset) * 0x20000ull;
@@ -3374,12 +3714,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return CVMX_ADD_IO_SEG(0x00011F0000010090ull) + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F0000010090ull) + ((offset) & 127) * 0x20000ull;
 			break;
@@ -3398,10 +3743,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000010090ull) + (offset) * 0x20000ull;
 			return CVMX_ADD_IO_SEG(0x00011F0000010090ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000010090ull) + (offset) * 0x20000ull;
@@ -3412,6 +3761,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_VF_INT_SUM(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_VF_INT_SUM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F00000100D0ull) + ((offset) & 127) * 0x20000ull;
@@ -3423,7 +3773,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_VF_INT_SUM(unsigned long offset)
 static inline uint64_t CVMX_PEXP_SLI_PKTX_VF_SIG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKTX_VF_SIG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000014C00ull) + ((offset) & 63) * 16;
 }
@@ -3434,7 +3784,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_VF_SIG(unsigned long offset)
 #define CVMX_PEXP_SLI_PKT_BIST_STATUS CVMX_PEXP_SLI_PKT_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000029220ull);
 }
@@ -3450,13 +3800,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_CNT_INT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011130ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000011130ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000029130ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000029130ull);
 			break;
 	}
@@ -3472,12 +3826,16 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_CNT_INT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011130ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000011130ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000029130ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000029130ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000029130ull);
@@ -3553,7 +3911,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_DPADDR_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_GBL_CONTROL CVMX_PEXP_SLI_PKT_GBL_CONTROL_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_GBL_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_GBL_CONTROL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000029210ull);
 }
@@ -3575,7 +3933,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_INPUT_CONTROL_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_INSTR_ENB CVMX_PEXP_SLI_PKT_INSTR_ENB_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_INSTR_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_INSTR_ENB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011000ull);
 }
@@ -3609,12 +3967,16 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_INSTR_SIZE_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_PKT_INT_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
+			return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
 			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_PKT_INT not supported on this chip\n");
@@ -3625,11 +3987,15 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_INT_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_PKT_INT_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
+			return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
 }
@@ -3669,12 +4035,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return CVMX_ADD_IO_SEG(0x00011F0000010040ull) + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return CVMX_ADD_IO_SEG(0x00011F0000010040ull) + ((offset) & 127) * 0x20000ull;
 			break;
@@ -3693,10 +4064,14 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000010040ull) + (offset) * 0x20000ull;
 			return CVMX_ADD_IO_SEG(0x00011F0000010040ull) + (offset) * 0x20000ull;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000010040ull) + (offset) * 0x20000ull;
@@ -3711,13 +4086,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011200ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000011200ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000029200ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000029200ull);
 			break;
 	}
@@ -3733,12 +4112,16 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011200ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000011200ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000029200ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000029200ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000029200ull);
@@ -3749,12 +4132,16 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INT_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
+			return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
 			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_PKT_IN_INT not supported on this chip\n");
@@ -3765,11 +4152,15 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INT_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INT_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
+			return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
 }
@@ -3778,7 +4169,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INT_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_IN_JABBER CVMX_PEXP_SLI_PKT_IN_JABBER_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_IN_JABBER_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_IN_JABBER not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000029170ull);
 }
@@ -3811,7 +4202,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IPTR_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_MAC0_SIG0 CVMX_PEXP_SLI_PKT_MAC0_SIG0_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_MAC0_SIG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_MAC0_SIG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011300ull);
 }
@@ -3822,7 +4213,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_MAC0_SIG0_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_MAC0_SIG1 CVMX_PEXP_SLI_PKT_MAC0_SIG1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_MAC0_SIG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_MAC0_SIG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011310ull);
 }
@@ -3833,7 +4224,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_MAC0_SIG1_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_MAC1_SIG0 CVMX_PEXP_SLI_PKT_MAC1_SIG0_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_MAC1_SIG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_MAC1_SIG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011320ull);
 }
@@ -3844,7 +4235,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_MAC1_SIG0_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_MAC1_SIG1 CVMX_PEXP_SLI_PKT_MAC1_SIG1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_MAC1_SIG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_MAC1_SIG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011330ull);
 }
@@ -3856,6 +4247,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_MACX_PFX_RINFO(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_MACX_PFX_RINFO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011F0000029030ull) + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -3867,7 +4259,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_MACX_PFX_RINFO(unsigned long offset, un
 static inline uint64_t CVMX_PEXP_SLI_PKT_MACX_RINFO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3)))))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_MACX_RINFO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011F0000011030ull) + ((offset) & 3) * 16;
 }
@@ -3879,12 +4271,16 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_MACX_RINFO(unsigned long offset)
 static inline uint64_t CVMX_PEXP_SLI_PKT_MEM_CTL_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
+			return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
 			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_PKT_MEM_CTL not supported on this chip\n");
@@ -3895,11 +4291,15 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_MEM_CTL_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_PKT_MEM_CTL_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
+			return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
 }
@@ -3913,13 +4313,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUTPUT_WMARK_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011180ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000011180ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000029180ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000029180ull);
 			break;
 	}
@@ -3935,12 +4339,16 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUTPUT_WMARK_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011180ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000011180ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000029180ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000029180ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000029180ull);
@@ -3961,7 +4369,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BMODE_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUT_BP_EN CVMX_PEXP_SLI_PKT_OUT_BP_EN_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_BP_EN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011240ull);
 }
@@ -3972,7 +4380,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1C CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1C_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1C_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1C not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000029290ull);
 }
@@ -3983,7 +4391,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1C_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1S CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1S_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1S_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1S not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000029270ull);
 }
@@ -3994,7 +4402,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1S_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1C CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1C_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1C_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1C not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000029280ull);
 }
@@ -4005,7 +4413,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1C_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1S CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1S_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1S_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1S not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000029260ull);
 }
@@ -4016,7 +4424,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1S_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUT_ENB CVMX_PEXP_SLI_PKT_OUT_ENB_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_ENB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000011010ull);
 }
@@ -4038,7 +4446,7 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_PCIE_PORT_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_PKIND_VALID CVMX_PEXP_SLI_PKT_PKIND_VALID_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_PKIND_VALID_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PEXP_SLI_PKT_PKIND_VALID not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000029190ull);
 }
@@ -4061,12 +4469,16 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_PORT_IN_RST_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_PKT_RING_RST_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
+			return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
 			break;
 	}
 	cvmx_warn("CVMX_PEXP_SLI_PKT_RING_RST not supported on this chip\n");
@@ -4077,11 +4489,15 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_RING_RST_FUNC(void)
 static inline uint64_t CVMX_PEXP_SLI_PKT_RING_RST_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
+			return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
 }
@@ -4128,13 +4544,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_TIME_INT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011140ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000011140ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000029140ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000029140ull);
 			break;
 	}
@@ -4150,12 +4570,16 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_TIME_INT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000011140ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000011140ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000029140ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000029140ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000029140ull);
@@ -4199,12 +4623,18 @@ static inline uint64_t CVMX_PEXP_SLI_S2M_PORTX_CTL(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + ((offset) & 3) * 16;
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + ((offset) & 3) * 16;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + ((offset) & 3) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x00011F0000023D80ull) + ((offset) & 3) * 16;
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x00011F0000023D80ull) + ((offset) & 3) * 16;
 			break;
@@ -4224,10 +4654,14 @@ static inline uint64_t CVMX_PEXP_SLI_S2M_PORTX_CTL(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + (offset) * 16;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + (offset) * 16;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000023D80ull) + (offset) * 16;
 			return CVMX_ADD_IO_SEG(0x00011F0000023D80ull) + (offset) * 16;
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000023D80ull) + (offset) * 16;
@@ -4242,13 +4676,17 @@ static inline uint64_t CVMX_PEXP_SLI_SCRATCH_1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000103C0ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F00000103C0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F00000283C0ull);
 			return CVMX_ADD_IO_SEG(0x00011F00000283C0ull);
 			break;
 	}
@@ -4264,12 +4702,16 @@ static inline uint64_t CVMX_PEXP_SLI_SCRATCH_1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000103C0ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F00000103C0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F00000283C0ull);
 			return CVMX_ADD_IO_SEG(0x00011F00000283C0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000283C0ull);
@@ -4284,13 +4726,17 @@ static inline uint64_t CVMX_PEXP_SLI_SCRATCH_2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000103D0ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F00000103D0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F00000283D0ull);
 			return CVMX_ADD_IO_SEG(0x00011F00000283D0ull);
 			break;
 	}
@@ -4306,12 +4752,16 @@ static inline uint64_t CVMX_PEXP_SLI_SCRATCH_2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000103D0ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F00000103D0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F00000283D0ull);
 			return CVMX_ADD_IO_SEG(0x00011F00000283D0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000283D0ull);
@@ -4326,13 +4776,17 @@ static inline uint64_t CVMX_PEXP_SLI_STATE1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010620ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000010620ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000028620ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028620ull);
 			break;
 	}
@@ -4348,12 +4802,16 @@ static inline uint64_t CVMX_PEXP_SLI_STATE1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010620ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000010620ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000028620ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028620ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000028620ull);
@@ -4368,13 +4826,17 @@ static inline uint64_t CVMX_PEXP_SLI_STATE2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010630ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000010630ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000028630ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028630ull);
 			break;
 	}
@@ -4390,12 +4852,16 @@ static inline uint64_t CVMX_PEXP_SLI_STATE2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010630ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000010630ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000028630ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028630ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000028630ull);
@@ -4410,13 +4876,17 @@ static inline uint64_t CVMX_PEXP_SLI_STATE3_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010640ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000010640ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000028640ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028640ull);
 			break;
 	}
@@ -4432,12 +4902,16 @@ static inline uint64_t CVMX_PEXP_SLI_STATE3_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F0000010640ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000010640ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000028640ull);
 			return CVMX_ADD_IO_SEG(0x00011F0000028640ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000028640ull);
@@ -4463,13 +4937,17 @@ static inline uint64_t CVMX_PEXP_SLI_WINDOW_CTL_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000102E0ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F00000102E0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F00000282E0ull);
 			return CVMX_ADD_IO_SEG(0x00011F00000282E0ull);
 			break;
 	}
@@ -4485,12 +4963,16 @@ static inline uint64_t CVMX_PEXP_SLI_WINDOW_CTL_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00011F00000102E0ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F00000102E0ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F00000282E0ull);
 			return CVMX_ADD_IO_SEG(0x00011F00000282E0ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F00000282E0ull);
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-cluster.h b/arch/mips/include/asm/octeon/cvmx-pki-cluster.h
index a845383..a8a0557 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-cluster.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-cluster.h
@@ -1,3 +1,48 @@
+/***********************license start***************
+ * Copyright (c) 2013-2015  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * <hr>$Revision: 120981 $<hr>
+ */
+
 /* This file is autogenerated from ipemainc.elf */
 const int cvmx_pki_cluster_code_length = 741;
 const uint64_t cvmx_pki_cluster_code_default[] = {
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index 9c1053b..e421316 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_PKI_ACTIVE0 CVMX_PKI_ACTIVE0_FUNC()
 static inline uint64_t CVMX_PKI_ACTIVE0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_ACTIVE0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000220ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_PKI_ACTIVE0_FUNC(void)
 #define CVMX_PKI_ACTIVE1 CVMX_PKI_ACTIVE1_FUNC()
 static inline uint64_t CVMX_PKI_ACTIVE1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_ACTIVE1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000230ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_PKI_ACTIVE1_FUNC(void)
 #define CVMX_PKI_ACTIVE2 CVMX_PKI_ACTIVE2_FUNC()
 static inline uint64_t CVMX_PKI_ACTIVE2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_ACTIVE2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000240ull);
 }
@@ -90,6 +90,7 @@ static inline uint64_t CVMX_PKI_AURAX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKI_AURAX_CFG(%lu) is invalid on this chip\n", offset);
@@ -102,7 +103,7 @@ static inline uint64_t CVMX_PKI_AURAX_CFG(unsigned long offset)
 #define CVMX_PKI_BIST_STATUS0 CVMX_PKI_BIST_STATUS0_FUNC()
 static inline uint64_t CVMX_PKI_BIST_STATUS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_BIST_STATUS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000080ull);
 }
@@ -113,7 +114,7 @@ static inline uint64_t CVMX_PKI_BIST_STATUS0_FUNC(void)
 #define CVMX_PKI_BIST_STATUS1 CVMX_PKI_BIST_STATUS1_FUNC()
 static inline uint64_t CVMX_PKI_BIST_STATUS1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_BIST_STATUS1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000088ull);
 }
@@ -124,7 +125,7 @@ static inline uint64_t CVMX_PKI_BIST_STATUS1_FUNC(void)
 #define CVMX_PKI_BIST_STATUS2 CVMX_PKI_BIST_STATUS2_FUNC()
 static inline uint64_t CVMX_PKI_BIST_STATUS2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_BIST_STATUS2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000090ull);
 }
@@ -136,6 +137,7 @@ static inline uint64_t CVMX_PKI_BPIDX_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 511))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKI_BPIDX_STATE(%lu) is invalid on this chip\n", offset);
@@ -148,7 +150,7 @@ static inline uint64_t CVMX_PKI_BPIDX_STATE(unsigned long offset)
 #define CVMX_PKI_BUF_CTL CVMX_PKI_BUF_CTL_FUNC()
 static inline uint64_t CVMX_PKI_BUF_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_BUF_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000100ull);
 }
@@ -160,6 +162,7 @@ static inline uint64_t CVMX_PKI_CHANX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4095))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 4095)))))
 		cvmx_warn("CVMX_PKI_CHANX_CFG(%lu) is invalid on this chip\n", offset);
@@ -172,7 +175,7 @@ static inline uint64_t CVMX_PKI_CHANX_CFG(unsigned long offset)
 #define CVMX_PKI_CLKEN CVMX_PKI_CLKEN_FUNC()
 static inline uint64_t CVMX_PKI_CLKEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_CLKEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000410ull);
 }
@@ -184,6 +187,7 @@ static inline uint64_t CVMX_PKI_CLX_ECC_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKI_CLX_ECC_CTL(%lu) is invalid on this chip\n", offset);
@@ -197,6 +201,7 @@ static inline uint64_t CVMX_PKI_CLX_ECC_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKI_CLX_ECC_INT(%lu) is invalid on this chip\n", offset);
@@ -210,6 +215,7 @@ static inline uint64_t CVMX_PKI_CLX_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKI_CLX_INT(%lu) is invalid on this chip\n", offset);
@@ -223,6 +229,7 @@ static inline uint64_t CVMX_PKI_CLX_PCAMX_ACTIONX(unsigned long a, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((a <= 3)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191))))))
 		cvmx_warn("CVMX_PKI_CLX_PCAMX_ACTIONX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
@@ -236,6 +243,7 @@ static inline uint64_t CVMX_PKI_CLX_PCAMX_MATCHX(unsigned long a, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((a <= 3)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191))))))
 		cvmx_warn("CVMX_PKI_CLX_PCAMX_MATCHX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
@@ -249,6 +257,7 @@ static inline uint64_t CVMX_PKI_CLX_PCAMX_TERMX(unsigned long a, unsigned long b
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((a <= 3)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 1)) && ((c <= 191)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((a <= 1)) && ((b <= 1)) && ((c <= 191))))))
 		cvmx_warn("CVMX_PKI_CLX_PCAMX_TERMX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
@@ -262,6 +271,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_CFG(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 63)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -275,6 +285,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_KMEMX(unsigned long a, unsigned long
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 1)) && ((b <= 63)) && ((c <= 15)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((a <= 3)) && ((b <= 63)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 3)) && ((b <= 63)) && ((c <= 15)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((a <= 1)) && ((b <= 63)) && ((c <= 15))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_KMEMX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
@@ -288,6 +299,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_L2_CUSTOM(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 63)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_L2_CUSTOM(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -301,6 +313,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_LG_CUSTOM(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 63)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_LG_CUSTOM(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -314,6 +327,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_SKIP(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 63)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_SKIP(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -327,6 +341,7 @@ static inline uint64_t CVMX_PKI_CLX_PKINDX_STYLE(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 63)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_PKI_CLX_PKINDX_STYLE(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -340,6 +355,7 @@ static inline uint64_t CVMX_PKI_CLX_SMEMX(unsigned long offset, unsigned long bl
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 2047)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 2047)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 2047)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 2047)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_PKI_CLX_SMEMX(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -353,6 +369,7 @@ static inline uint64_t CVMX_PKI_CLX_START(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKI_CLX_START(%lu) is invalid on this chip\n", offset);
@@ -366,6 +383,7 @@ static inline uint64_t CVMX_PKI_CLX_STYLEX_ALG(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 63)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_PKI_CLX_STYLEX_ALG(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -379,6 +397,7 @@ static inline uint64_t CVMX_PKI_CLX_STYLEX_CFG(unsigned long offset, unsigned lo
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 63)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_PKI_CLX_STYLEX_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -392,6 +411,7 @@ static inline uint64_t CVMX_PKI_CLX_STYLEX_CFG2(unsigned long offset, unsigned l
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 63)) && ((block_id <= 1)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 63)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 63)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_PKI_CLX_STYLEX_CFG2(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -469,7 +489,7 @@ static inline uint64_t CVMX_PKI_DSTATX_STAT4(unsigned long offset)
 #define CVMX_PKI_ECC_CTL0 CVMX_PKI_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKI_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000060ull);
 }
@@ -480,7 +500,7 @@ static inline uint64_t CVMX_PKI_ECC_CTL0_FUNC(void)
 #define CVMX_PKI_ECC_CTL1 CVMX_PKI_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_PKI_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000068ull);
 }
@@ -491,7 +511,7 @@ static inline uint64_t CVMX_PKI_ECC_CTL1_FUNC(void)
 #define CVMX_PKI_ECC_CTL2 CVMX_PKI_ECC_CTL2_FUNC()
 static inline uint64_t CVMX_PKI_ECC_CTL2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_ECC_CTL2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000070ull);
 }
@@ -502,7 +522,7 @@ static inline uint64_t CVMX_PKI_ECC_CTL2_FUNC(void)
 #define CVMX_PKI_ECC_INT0 CVMX_PKI_ECC_INT0_FUNC()
 static inline uint64_t CVMX_PKI_ECC_INT0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_ECC_INT0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000040ull);
 }
@@ -513,7 +533,7 @@ static inline uint64_t CVMX_PKI_ECC_INT0_FUNC(void)
 #define CVMX_PKI_ECC_INT1 CVMX_PKI_ECC_INT1_FUNC()
 static inline uint64_t CVMX_PKI_ECC_INT1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_ECC_INT1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000048ull);
 }
@@ -524,7 +544,7 @@ static inline uint64_t CVMX_PKI_ECC_INT1_FUNC(void)
 #define CVMX_PKI_ECC_INT2 CVMX_PKI_ECC_INT2_FUNC()
 static inline uint64_t CVMX_PKI_ECC_INT2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_ECC_INT2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000050ull);
 }
@@ -536,6 +556,7 @@ static inline uint64_t CVMX_PKI_FRM_LEN_CHKX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKI_FRM_LEN_CHKX(%lu) is invalid on this chip\n", offset);
@@ -548,7 +569,7 @@ static inline uint64_t CVMX_PKI_FRM_LEN_CHKX(unsigned long offset)
 #define CVMX_PKI_GBL_PEN CVMX_PKI_GBL_PEN_FUNC()
 static inline uint64_t CVMX_PKI_GBL_PEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_GBL_PEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000200ull);
 }
@@ -559,7 +580,7 @@ static inline uint64_t CVMX_PKI_GBL_PEN_FUNC(void)
 #define CVMX_PKI_GEN_INT CVMX_PKI_GEN_INT_FUNC()
 static inline uint64_t CVMX_PKI_GEN_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_GEN_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000020ull);
 }
@@ -571,19 +592,21 @@ static inline uint64_t CVMX_PKI_ICGX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset == 0))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_PKI_ICGX_CFG(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x000118004400A000ull) + ((offset) & 3) * 8;
+	return CVMX_ADD_IO_SEG(0x000118004400A000ull);
 }
 #else
-#define CVMX_PKI_ICGX_CFG(offset) (CVMX_ADD_IO_SEG(0x000118004400A000ull) + ((offset) & 3) * 8)
+#define CVMX_PKI_ICGX_CFG(offset) (CVMX_ADD_IO_SEG(0x000118004400A000ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKI_IMEMX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2047))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2047))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2047))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2047)))))
 		cvmx_warn("CVMX_PKI_IMEMX(%lu) is invalid on this chip\n", offset);
@@ -597,6 +620,7 @@ static inline uint64_t CVMX_PKI_LTYPEX_MAP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKI_LTYPEX_MAP(%lu) is invalid on this chip\n", offset);
@@ -620,7 +644,7 @@ static inline uint64_t CVMX_PKI_PBE_ECO_FUNC(void)
 #define CVMX_PKI_PCAM_LOOKUP CVMX_PKI_PCAM_LOOKUP_FUNC()
 static inline uint64_t CVMX_PKI_PCAM_LOOKUP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_PCAM_LOOKUP not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000500ull);
 }
@@ -631,7 +655,7 @@ static inline uint64_t CVMX_PKI_PCAM_LOOKUP_FUNC(void)
 #define CVMX_PKI_PCAM_RESULT CVMX_PKI_PCAM_RESULT_FUNC()
 static inline uint64_t CVMX_PKI_PCAM_RESULT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_PCAM_RESULT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000510ull);
 }
@@ -642,7 +666,7 @@ static inline uint64_t CVMX_PKI_PCAM_RESULT_FUNC(void)
 #define CVMX_PKI_PFE_DIAG CVMX_PKI_PFE_DIAG_FUNC()
 static inline uint64_t CVMX_PKI_PFE_DIAG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_PFE_DIAG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000560ull);
 }
@@ -664,7 +688,7 @@ static inline uint64_t CVMX_PKI_PFE_ECO_FUNC(void)
 #define CVMX_PKI_PIX_CLKEN CVMX_PKI_PIX_CLKEN_FUNC()
 static inline uint64_t CVMX_PKI_PIX_CLKEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_PIX_CLKEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000600ull);
 }
@@ -675,7 +699,7 @@ static inline uint64_t CVMX_PKI_PIX_CLKEN_FUNC(void)
 #define CVMX_PKI_PIX_DIAG CVMX_PKI_PIX_DIAG_FUNC()
 static inline uint64_t CVMX_PKI_PIX_DIAG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_PIX_DIAG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000580ull);
 }
@@ -698,6 +722,7 @@ static inline uint64_t CVMX_PKI_PKINDX_ICGSEL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKINDX_ICGSEL(%lu) is invalid on this chip\n", offset);
@@ -711,6 +736,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKNDX_INB_STAT0(%lu) is invalid on this chip\n", offset);
@@ -724,6 +750,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKNDX_INB_STAT1(%lu) is invalid on this chip\n", offset);
@@ -737,6 +764,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_PKNDX_INB_STAT2(%lu) is invalid on this chip\n", offset);
@@ -749,7 +777,7 @@ static inline uint64_t CVMX_PKI_PKNDX_INB_STAT2(unsigned long offset)
 #define CVMX_PKI_PKT_ERR CVMX_PKI_PKT_ERR_FUNC()
 static inline uint64_t CVMX_PKI_PKT_ERR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_PKT_ERR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000030ull);
 }
@@ -785,6 +813,7 @@ static inline uint64_t CVMX_PKI_QPG_TBLX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2047))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2047))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2047))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2047)))))
 		cvmx_warn("CVMX_PKI_QPG_TBLX(%lu) is invalid on this chip\n", offset);
@@ -798,6 +827,7 @@ static inline uint64_t CVMX_PKI_REASM_SOPX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKI_REASM_SOPX(%lu) is invalid on this chip\n", offset);
@@ -810,7 +840,7 @@ static inline uint64_t CVMX_PKI_REASM_SOPX(unsigned long offset)
 #define CVMX_PKI_REQ_WGT CVMX_PKI_REQ_WGT_FUNC()
 static inline uint64_t CVMX_PKI_REQ_WGT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_REQ_WGT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000120ull);
 }
@@ -821,7 +851,7 @@ static inline uint64_t CVMX_PKI_REQ_WGT_FUNC(void)
 #define CVMX_PKI_SFT_RST CVMX_PKI_SFT_RST_FUNC()
 static inline uint64_t CVMX_PKI_SFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_SFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000010ull);
 }
@@ -833,6 +863,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST0(%lu) is invalid on this chip\n", offset);
@@ -846,6 +877,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST1(%lu) is invalid on this chip\n", offset);
@@ -859,6 +891,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST2(%lu) is invalid on this chip\n", offset);
@@ -872,6 +905,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST3(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST3(%lu) is invalid on this chip\n", offset);
@@ -885,6 +919,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST4(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST4(%lu) is invalid on this chip\n", offset);
@@ -898,6 +933,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST5(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST5(%lu) is invalid on this chip\n", offset);
@@ -911,6 +947,7 @@ static inline uint64_t CVMX_PKI_STATX_HIST6(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_HIST6(%lu) is invalid on this chip\n", offset);
@@ -924,6 +961,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT0(%lu) is invalid on this chip\n", offset);
@@ -937,6 +975,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT1(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT1(%lu) is invalid on this chip\n", offset);
@@ -950,6 +989,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT10(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT10(%lu) is invalid on this chip\n", offset);
@@ -963,6 +1003,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT11(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT11(%lu) is invalid on this chip\n", offset);
@@ -976,6 +1017,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT12(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT12(%lu) is invalid on this chip\n", offset);
@@ -989,6 +1031,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT13(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT13(%lu) is invalid on this chip\n", offset);
@@ -1002,6 +1045,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT14(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT14(%lu) is invalid on this chip\n", offset);
@@ -1015,6 +1059,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT15(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT15(%lu) is invalid on this chip\n", offset);
@@ -1028,6 +1073,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT16(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT16(%lu) is invalid on this chip\n", offset);
@@ -1041,6 +1087,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT17(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT17(%lu) is invalid on this chip\n", offset);
@@ -1054,6 +1101,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT18(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT18(%lu) is invalid on this chip\n", offset);
@@ -1067,6 +1115,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT2(%lu) is invalid on this chip\n", offset);
@@ -1080,6 +1129,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT3(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT3(%lu) is invalid on this chip\n", offset);
@@ -1093,6 +1143,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT4(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT4(%lu) is invalid on this chip\n", offset);
@@ -1106,6 +1157,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT5(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT5(%lu) is invalid on this chip\n", offset);
@@ -1119,6 +1171,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT6(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT6(%lu) is invalid on this chip\n", offset);
@@ -1132,6 +1185,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT7(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT7(%lu) is invalid on this chip\n", offset);
@@ -1145,6 +1199,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT8(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT8(%lu) is invalid on this chip\n", offset);
@@ -1158,6 +1213,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT9(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STATX_STAT9(%lu) is invalid on this chip\n", offset);
@@ -1170,7 +1226,7 @@ static inline uint64_t CVMX_PKI_STATX_STAT9(unsigned long offset)
 #define CVMX_PKI_STAT_CTL CVMX_PKI_STAT_CTL_FUNC()
 static inline uint64_t CVMX_PKI_STAT_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_STAT_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000110ull);
 }
@@ -1182,6 +1238,7 @@ static inline uint64_t CVMX_PKI_STYLEX_BUF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_BUF(%lu) is invalid on this chip\n", offset);
@@ -1195,6 +1252,7 @@ static inline uint64_t CVMX_PKI_STYLEX_TAG_MASK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_TAG_MASK(%lu) is invalid on this chip\n", offset);
@@ -1208,6 +1266,7 @@ static inline uint64_t CVMX_PKI_STYLEX_TAG_SEL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_TAG_SEL(%lu) is invalid on this chip\n", offset);
@@ -1221,6 +1280,7 @@ static inline uint64_t CVMX_PKI_STYLEX_WQ2(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_WQ2(%lu) is invalid on this chip\n", offset);
@@ -1234,6 +1294,7 @@ static inline uint64_t CVMX_PKI_STYLEX_WQ4(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_PKI_STYLEX_WQ4(%lu) is invalid on this chip\n", offset);
@@ -1247,6 +1308,7 @@ static inline uint64_t CVMX_PKI_TAG_INCX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKI_TAG_INCX_CTL(%lu) is invalid on this chip\n", offset);
@@ -1260,6 +1322,7 @@ static inline uint64_t CVMX_PKI_TAG_INCX_MASK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKI_TAG_INCX_MASK(%lu) is invalid on this chip\n", offset);
@@ -1272,7 +1335,7 @@ static inline uint64_t CVMX_PKI_TAG_INCX_MASK(unsigned long offset)
 #define CVMX_PKI_TAG_SECRET CVMX_PKI_TAG_SECRET_FUNC()
 static inline uint64_t CVMX_PKI_TAG_SECRET_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_TAG_SECRET not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000430ull);
 }
@@ -1283,7 +1346,7 @@ static inline uint64_t CVMX_PKI_TAG_SECRET_FUNC(void)
 #define CVMX_PKI_X2P_REQ_OFL CVMX_PKI_X2P_REQ_OFL_FUNC()
 static inline uint64_t CVMX_PKI_X2P_REQ_OFL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKI_X2P_REQ_OFL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180044000038ull);
 }
@@ -1372,11 +1435,11 @@ union cvmx_pki_aurax_cfg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
 	uint64_t pkt_add                      : 2;  /**< Specifies what to add to FPA_AURA()_CNT when PKI enqueues a packet:
-                                                         0 = zero.
-                                                         1 = one.
-                                                         2 = The number of FPA buffers allocated; i.e. if PKI_STYLE()_BUF[DIS_WQ_DAT] is set,
-                                                         WQE[BUFS]+1, else WQE[BUFS].
-                                                         3 = WQE[LEN] (i.e. the packet length). */
+                                                         0x0 = zero.
+                                                         0x1 = one.
+                                                         0x2 = The number of FPA buffers allocated; i.e. if PKI_STYLE()_BUF[DIS_WQ_DAT]
+                                                         is set, PKI_WQE_S[BUFS]+1, else PKI_WQE_S[BUFS].
+                                                         0x3 = PKI_WQE_S[LEN] (i.e. the packet length). */
 	uint64_t reserved_19_29               : 11;
 	uint64_t ena_red                      : 1;  /**< Enable RED drop between PASS and DROP levels. See also
                                                          FPA_AURA()_POOL_LEVELS[RED_ENA] and FPA_AURA()_CNT_LEVELS[RED_ENA]. */
@@ -1407,7 +1470,7 @@ typedef union cvmx_pki_aurax_cfg cvmx_pki_aurax_cfg_t;
 /**
  * cvmx_pki_bist_status0
  *
- * BIST status register.
+ * This register indicates BIST status.
  *
  */
 union cvmx_pki_bist_status0 {
@@ -1415,21 +1478,7 @@ union cvmx_pki_bist_status0 {
 	struct cvmx_pki_bist_status0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_31_63               : 33;
-	uint64_t bist                         : 31; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. INTERNAL: This
-                                                         register collects status for PKI_PFE.
-                                                         <30> = INB_ERRS.
-                                                         <29> = INB OCTS.
-                                                         <28> = INB PKTS.
-                                                         <27> = LD FIF.
-                                                         <26> = PBE STATE.
-                                                         <25> = WADR STATE.
-                                                         <24> = NXT PTAG.
-                                                         <23> = CUR PTAG.
-                                                         <22> = X2P FIF.
-                                                         <21> = DROP FIF.
-                                                         <20> = NXT BLK.
-                                                         <19..16> = KMEM.
-                                                         <15..0> = ASM BUFF. */
+	uint64_t bist                         : 31; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. */
 #else
 	uint64_t bist                         : 31;
 	uint64_t reserved_31_63               : 33;
@@ -1445,7 +1494,7 @@ typedef union cvmx_pki_bist_status0 cvmx_pki_bist_status0_t;
 /**
  * cvmx_pki_bist_status1
  *
- * BIST status register.
+ * This register indicates BIST status.
  *
  */
 union cvmx_pki_bist_status1 {
@@ -1453,31 +1502,7 @@ union cvmx_pki_bist_status1 {
 	struct cvmx_pki_bist_status1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_26_63               : 38;
-	uint64_t bist                         : 26; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. INTERNAL: This
-                                                         register collects status for PKI_PBE.
-                                                         <25> = DSTATS_MEM0.
-                                                         <24> = DSTATS_MEM1.
-                                                         <23> = DSTATS_MEM2.
-                                                         <22> = DSTATS_MEM3.
-                                                         <21> = DSTATS_MEM4.
-                                                         <20> = STATS_MEM0.
-                                                         <19> = STATS_MEM1.
-                                                         <18> = STATS_MEM2.
-                                                         <17> = STATS_MEM3.
-                                                         <16> = SWS.
-                                                         <15> = WQEOUT.
-                                                         <14> = DOA.
-                                                         <13> = BPID.
-                                                         <12 =10> = Reserved.
-                                                         <9> = PLC.
-                                                         <8> = PKTWQ.
-                                                         <7 =6> = Reserved.
-                                                         <5> = TAG.
-                                                         <4> = AURA.
-                                                         <3> = CHAN.
-                                                         <2> = PBTAG.
-                                                         <1> = STYLEWQ.
-                                                         <0> = QPG. */
+	uint64_t bist                         : 26; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. */
 #else
 	uint64_t bist                         : 26;
 	uint64_t reserved_26_63               : 38;
@@ -1487,26 +1512,7 @@ union cvmx_pki_bist_status1 {
 	struct cvmx_pki_bist_status1_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_21_63               : 43;
-	uint64_t bist                         : 21; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. INTERNAL: This
-                                                         register collects status for PKI_PBE.
-                                                         <20> = STATS_MEM0.
-                                                         <19> = STATS_MEM1.
-                                                         <18> = STATS_MEM2.
-                                                         <17> = STATS_MEM3.
-                                                         <16> = SWS.
-                                                         <15> = WQEOUT.
-                                                         <14> = DOA.
-                                                         <13> = BPID.
-                                                         <12 =10> = Reserved.
-                                                         <9> = PLC.
-                                                         <8> = PKTWQ.
-                                                         <7 =6> = Reserved.
-                                                         <5> = TAG.
-                                                         <4> = AURA.
-                                                         <3> = CHAN.
-                                                         <2> = PBTAG.
-                                                         <1> = STYLEWQ.
-                                                         <0> = QPG. */
+	uint64_t bist                         : 21; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. */
 #else
 	uint64_t bist                         : 21;
 	uint64_t reserved_21_63               : 43;
@@ -1520,7 +1526,7 @@ typedef union cvmx_pki_bist_status1 cvmx_pki_bist_status1_t;
 /**
  * cvmx_pki_bist_status2
  *
- * BIST status register.
+ * This register indicates BIST status.
  *
  */
 union cvmx_pki_bist_status2 {
@@ -1528,22 +1534,7 @@ union cvmx_pki_bist_status2 {
 	struct cvmx_pki_bist_status2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
-	uint64_t bist                         : 25; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. INTERNAL: This
-                                                         register collects status for PKI_PIX (verif/vkits/pki/pki_mem_info_table.sv).
-                                                         24     = IMEM.
-                                                         23..20 = Reserved.
-                                                         19     = IPEC1 / IPEs 10 .. 19 (RegFile + DMEM).
-                                                         18     = IPEC1 / IPEs  0 ..  9 (RegFile + DMEM).
-                                                         17     = IPEC0 / IPEs 10 .. 19 (RegFile + DMEM).
-                                                         16     = IPEC0 / IPEs  0 ..  9 (RegFile + DMEM).
-                                                         15..13 = Reserved.
-                                                         14..12 = IPEC SMEM.
-                                                         11..10 = Reserved.
-                                                         9..8   = IPEC PCAM ECC.
-                                                         7..6   = Reserved.
-                                                         5..4   = IPEC PCAM RES.
-                                                         3..2   = Reserved.
-                                                         1..0   = IPEC PCAM CAM. */
+	uint64_t bist                         : 25; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. */
 #else
 	uint64_t bist                         : 25;
 	uint64_t reserved_25_63               : 39;
@@ -1589,8 +1580,8 @@ union cvmx_pki_buf_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_11_63               : 53;
 	uint64_t fpa_wait                     : 1;  /**< Policy when FPA runs out of buffers:
-                                                         0 = Drop the remainder of the packet requesting the buffer, and set WQE[OPCODE] to
-                                                         RE_MEMOUT.
+                                                         0 = Drop the remainder of the packet requesting the buffer, and set
+                                                         PKI_WQE_S[ERRLEV,OPCODE] to PKI_ERRLEV_E::RE,PKI_OPCODE_E::RE_MEMOUT.
                                                          1 = Wait until buffers become available, only dropping packets if buffering ahead of PKI
                                                          fills. This may lead to head-of-line blocking of packets on other Auras. */
 	uint64_t fpa_cac_dis                  : 1;  /**< Reserved. */
@@ -1602,12 +1593,10 @@ union cvmx_pki_buf_ctl {
                                                          interface.
                                                          The application should not de-assert this bit after asserting it. The receivers of this
                                                          bit may have been put into backpressure mode and can only be released by PKI informing
-                                                         them that the backpressure has been released.
-                                                         INTERNAL: Must be one for PKI HW to assert any output backpressure wires. */
+                                                         them that the backpressure has been released. */
 	uint64_t reserved_1_1                 : 1;
 	uint64_t pki_en                       : 1;  /**< PKI enable. When set to 1, enables the operation of the PKI. When clear to 0, the PKI
-                                                         asserts backpressure on all ports. INTERNAL: Suppresses grants to X2P, not BPID
-                                                         backpressure. */
+                                                         asserts backpressure on all ports. */
 #else
 	uint64_t pki_en                       : 1;
 	uint64_t reserved_1_1                 : 1;
@@ -1640,10 +1629,10 @@ union cvmx_pki_chanx_cfg {
 	uint64_t reserved_17_63               : 47;
 	uint64_t imp                          : 1;  /**< Implemented. This register is sparse (only indexes with values in PKI_CHAN_E are
                                                          implemented).
-                                                         0 = this index is read only.
-                                                         1 = this index is read-write.
-                                                         INTERNAL: Write to a non-implemented channel is ignored but returns write commit. Reading
-                                                         non-implemented channel returns all zero data. */
+                                                         0 = This index is read only.
+                                                         1 = This index is read-write.
+                                                         Write to a non-implemented channel is ignored. Reading a non-implemented channel
+                                                         returns all zero data. */
 	uint64_t reserved_10_15               : 6;
 	uint64_t bpid                         : 10; /**< Bpid to receive backpressure from. Value must be 0 to 511. */
 #else
@@ -1662,13 +1651,16 @@ typedef union cvmx_pki_chanx_cfg cvmx_pki_chanx_cfg_t;
 
 /**
  * cvmx_pki_cl#_ecc_ctl
+ *
+ * This register configures ECC. All of PKI_CL()_ECC_CTL must be configured identically.
+ *
  */
 union cvmx_pki_clx_ecc_ctl {
 	uint64_t u64;
 	struct cvmx_pki_clx_ecc_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pcam_en                      : 1;  /**< PCAM ECC checking enable. PCAM_EN must be clear when reading or writing the
-                                                         PKI_PCAM_RESULT registers. INTERNAL: This enables the PCAM scrubber. */
+	uint64_t pcam_en                      : 1;  /**< PCAM ECC scrubber and checking enable. PCAM_EN must be clear when reading or
+                                                         writing the PKI_PCAM_RESULT registers. */
 	uint64_t reserved_24_62               : 39;
 	uint64_t pcam1_flip                   : 2;  /**< PCAM1 flip syndrome bits on write. */
 	uint64_t pcam0_flip                   : 2;  /**< PCAM  flip syndrome bits on write. */
@@ -1750,11 +1742,10 @@ union cvmx_pki_clx_int {
 	struct cvmx_pki_clx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t iptint                       : 1;  /**< PCAM sequencer debug interrupt. Throws PKI_INTSN_E::PKI_CL()_INT_IPTINT. INTERNAL:
-                                                         Caused by TRAP or INTR sequence state. */
-	uint64_t sched_conf                   : 1;  /**< PCAM/SMEM internal port conflict. Internal error, should not occur. Throws
-                                                         PKI_INTSN_E::PKI_CL()_INT_SCHED_CONF. INTERNAL: Sequencer mis-scheduled PCAM or SMEM
-                                                         ops with overlapping accesses. */
+	uint64_t iptint                       : 1;  /**< PCAM sequencer debug interrupt. Throws PKI_INTSN_E::PKI_CL()_INT_IPTINT. */
+	uint64_t sched_conf                   : 1;  /**< PCAM/SMEM internal port conflict, sequencer mis-scheduled PCAM or SMEM
+                                                         ops with overlapping accesses. Internal error, should not occur. Throws
+                                                         PKI_INTSN_E::PKI_CL()_INT_SCHED_CONF. */
 	uint64_t pcam_conf                    : 2;  /**< PCAM() match hit multiple rows, indicating either a soft error in the PCAM or a
                                                          programming error in PKI_CL()_PCAM()_MATCH() or related registers. Throws
                                                          PKI_INTSN_E::PKI_CL()_INT_PCAM_CONF(). Once a conflict is detected, the PCAM state
@@ -1777,16 +1768,23 @@ typedef union cvmx_pki_clx_int cvmx_pki_clx_int_t;
 /**
  * cvmx_pki_cl#_pcam#_action#
  *
+ * This register configures the result side of the PCAM. PKI HW is opaque as to the use
+ * of the 32 bits of CAM result.
+ *
+ * For each legal j and k, PKI_CL(i)_PCAM(j)_ACTION(k) must be configured identically for i=0..1.
+ *
+ * With the current sequencer code:
+ *
  * Action performed based on PCAM lookup using the PKI_CL()_PCAM()_TERM() and
  * PKI_CL()_PCAM()_MATCH() registers.
  *
  * If lookup data matches no PCAM entries, then no action takes place. No matches indicates
  * normal parsing will continue.
  *
- * If data matches multiple PCAM entries, PKI_WQE_S[OPCODE] of the processed packet may be set to
- * PKI_OPCODE_E::RE_PKIPCAM and the PKI_CL()_INT[PCAM_CONF] error interrupt is signaled.  Once a
- * conflict is detected, the PCAM state is unpredictable and is required to be fully reconfigured
- * before further valid processing can take place.
+ * If data matches multiple PCAM entries, PKI_WQE_S[ERRLEV,OPCODE] of the processed packet may
+ * be set to PKI_ERRLEV_E::RE,PKI_OPCODE_E::RE_PKIPCAM and the PKI_CL()_INT[PCAM_CONF] error
+ * interrupt is signaled.  Once a conflict is detected, the PCAM state is unpredictable and is
+ * required to be fully reconfigured before further valid processing can take place.
  */
 union cvmx_pki_clx_pcamx_actionx {
 	uint64_t u64;
@@ -1795,36 +1793,40 @@ union cvmx_pki_clx_pcamx_actionx {
 	uint64_t reserved_31_63               : 33;
 	uint64_t pmc                          : 7;  /**< Parse mode change. Where to resume parsing after applying the scan offset (if any) as bit
                                                          mask of which sequence steps to no longer process:
-                                                         _ <0> = LA (L2)
-                                                         _ <1> = LB (Custom)
-                                                         _ <2> = LC (L3)
-                                                         _ <3> = LD (Virt)
-                                                         _ <4> = LE (IL3)
-                                                         _ <5> = LF (L4)
-                                                         _ <6> = LG (Custom/Application)
-                                                         The legal values are:
-                                                         0x0 = no change in parsing.
-                                                         0x1 = Skip further LA parsing; start LB parsing. For TERM==L2_CUSTOM only).
-                                                         0x3 = Skip further LA/LB parsing; start LC parsing. For TERMs through Ethertypes only).
-                                                         0x7 = Skip further LA-LC parsing; start LD parsing. For TERMs through L3FLAGS only).
-                                                         0x7F = Skip all parsing; no further packet inspection. For TERMs through L3FLAGS only).
-                                                         For example an Ethertype match action that wishes to resume with additional Ethertype
-                                                         matches would use a zero PMC to indicate no parse mode change. An Ethertype match action
-                                                         that wishes to not parse any additional Ethertypes and resume at LC would use 0x3.
-                                                         Must be zero for invalid entries, or for TERMs that do not allow a parse mode change as
-                                                         specified in the PKI_PCAM_TERM_E table. */
+                                                         _ <0> = LA (L2).
+                                                         _ <1> = LB (Custom).
+                                                         _ <2> = LC (L3).
+                                                         _ <3> = LD (Virt).
+                                                         _ <4> = LE (IL3).
+                                                         _ <5> = LF (L4).
+                                                         _ <6> = LG (Custom/Application-specific relative to C, D, E, or F).
+                                                         Typically PMC is 0x0 to indicate no parse mode change.  Must be zero for invalid
+                                                         entries, or for TERMs that do not allow a parse mode change as specified in the
+                                                         PMC column of the PKI_PCAM_TERM_E table.
+                                                         Typical values for PMC<5:0> are:
+                                                           0x0 = no change in parsing.
+                                                           0x1 = Skip further LA parsing; start LB parsing.
+                                                           0x3 = Skip further LA/LB parsing; start LC parsing.
+                                                           0x7 = Skip further LA-LC parsing; start LD parsing.
+                                                           0x38 = Skip LD, LE, LF parsing.
+                                                           0x3F = Skip all parsing; no further packet inspection.
+                                                         The typical use of PMC<5:0> being non-zero is for Ethertypes or custom headers
+                                                         to indicate non-IP follows that Ethertype/custom header. This corresponds to use
+                                                         only with PKI_PCAM_TERM_E::ETHTYPE0..3, and PKI_PCAM_TERM_E::L2_CUSTOM.
+                                                         Independently PMC<6> may be set to disable LG (LG_CUSTOM) parsing. */
 	uint64_t style_add                    : 8;  /**< Resulting interim style adder. If this CAM entry matches, the value to add to the current
                                                          style (may wrap around through 256). Must be zero for invalid entries. */
 	uint64_t pf                           : 3;  /**< Parse flag to set. Specifies the parse flag to set when entry matches, see PCAM actions
                                                          may also specify setting one of four user flags in the generated work queue entry,
-                                                         WQE[PF1] through WQE[PF4]. These flags are not used by hardware; they are intended to
+                                                         PKI_WQE_S[PF1] through PKI_WQE_S[PF4]. These flags are not used by hardware; they are
+                                                         intended to
                                                          indicate to software that exceptional handling may be required, such as the presence of an
                                                          encrypted packet:
                                                          _ 0x0 = no change.
-                                                         _ 0x1 = Set WQE[PF1].
-                                                         _ 0x2 = Set WQE[PF2].
-                                                         _ 0x3 = Set WQE[PF3].
-                                                         _ 0x4 = Set WQE[PF4].
+                                                         _ 0x1 = Set PKI_WQE_S[PF1].
+                                                         _ 0x2 = Set PKI_WQE_S[PF2].
+                                                         _ 0x3 = Set PKI_WQE_S[PF3].
+                                                         _ 0x4 = Set PKI_WQE_S[PF4].
                                                          _ else = reserved.
                                                          Must be zero for invalid entries. */
 	uint64_t setty                        : 5;  /**< Set pointer type. If non-zero, indicates the layer type to be set as described under
@@ -1851,6 +1853,11 @@ typedef union cvmx_pki_clx_pcamx_actionx cvmx_pki_clx_pcamx_actionx_t;
 
 /**
  * cvmx_pki_cl#_pcam#_match#
+ *
+ * This register configures the match side of the PCAM. PKI HW is opaque as to the use
+ * of the 32 bits of CAM data.
+ *
+ * For each legal j and k, PKI_CL(i)_PCAM(j)_MATCH(k) must be configured identically for i=0..1.
  */
 union cvmx_pki_clx_pcamx_matchx {
 	uint64_t u64;
@@ -1879,6 +1886,12 @@ typedef union cvmx_pki_clx_pcamx_matchx cvmx_pki_clx_pcamx_matchx_t;
 
 /**
  * cvmx_pki_cl#_pcam#_term#
+ *
+ * This register configures the match side of the PCAM. PKI HW is opaque as to the use
+ * of the 16 bits of CAM data; the split between TERM and STYLE is defined by the
+ * sequencer.
+ *
+ * For each legal j and k, PKI_CL(i)_PCAM(j)_TERM(k) must be configured identically for i=0..1.
  */
 union cvmx_pki_clx_pcamx_termx {
 	uint64_t u64;
@@ -1897,7 +1910,7 @@ union cvmx_pki_clx_pcamx_termx {
                                                          _ TERM1<n>=1, TERM0<n>=1: Reserved. */
 	uint64_t style0                       : 8;  /**< Previous interim style. The style that must have been calculated by the port
                                                          PKI_CL()_PKIND()_STYLE[STYLE] or as modified by previous CAM hits's
-                                                         PKI_CL()_PCAM()_ACTION()[STYLE]. This is used to form AND style matches.
+                                                         PKI_CL()_PCAM()_ACTION()[STYLE_ADD]. This is used to form AND style matches.
                                                          The field value is ternary, where each bit matches as follows:
                                                          _ STYLE1<n>=0, STYLE0<n>=0: Always match; data<n> don't care.
                                                          _ STYLE1<n>=0, STYLE0<n>=1: Match when data<n> == 0.
@@ -1922,26 +1935,37 @@ typedef union cvmx_pki_clx_pcamx_termx cvmx_pki_clx_pcamx_termx_t;
 
 /**
  * cvmx_pki_cl#_pkind#_cfg
+ *
+ * This register is inside PKI_CL()_PKIND()_KMEM(). These CSRs are used only by
+ * the PKI parse engine/sequencer.
+ *
+ * For each legal j, PKI_CL(i)_PKIND(j)_CFG must be configured identically for i=0..1.
  */
 union cvmx_pki_clx_pkindx_cfg {
 	uint64_t u64;
 	struct cvmx_pki_clx_pkindx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_8_63                : 56;
+	uint64_t reserved_11_63               : 53;
+	uint64_t lg_custom_layer              : 3;  /**< Layer G custom match enable.
+                                                         0x0 = Disable custom LG header extraction
+                                                         0x1 = Enable custom LG header extraction after layer C.
+                                                         0x2 = Enable custom LG header extraction after layer D.
+                                                         0x3 = Enable custom LG header extraction after layer E.
+                                                         0x4 = Enable custom LG header extraction after layer F.
+                                                         0x5-0x7 = Reserved.
+                                                         If non-zero PKI_GBL_PEN[CLG_PEN] must be set. */
 	uint64_t fcs_pres                     : 1;  /**< FCS present.
                                                          0 = FCS not present. FCS may not be checked nor stripped.
                                                          1 = FCS present; the last four bytes of the packet are part of the FCS and may not be
                                                          considered part of a IP, TCP or other header for length error checks.
-                                                         PKI_CL()_STYLE()_CFG[FCS_CHK or FCS_STRIP] may optionally be set. */
+                                                         When either PKI_CL()_STYLE()_CFG[FCS_CHK or FCS_STRIP] are set, the
+                                                         corresponding [FCS_PRES] must be set. */
 	uint64_t mpls_en                      : 1;  /**< Enable MPLS parsing.
                                                          0 = Any MPLS labels are ignored, but may be handled by custom Ethertype PCAM matchers.
                                                          1 = MPLS label stacks are parsed and skipped over. PKI_GBL_PEN[MPLS_PEN] must be set. */
-	uint64_t inst_hdr                     : 1;  /**< INST header. When set, the eight-byte INST_HDR is present on all packets (except incoming
-                                                         packets on the DPI ports). */
-	uint64_t lg_custom                    : 1;  /**< Layer G Custom Match Enable.
-                                                         0 = Disable custom LG header extraction
-                                                         1 = Enable custom LG header extraction.
-                                                         PKI_GBL_PEN[CLG_PEN] must be set. */
+	uint64_t inst_hdr                     : 1;  /**< INST header. When set, a PKI_INST_HDR_S is present PKI_CL()_PKIND()_SKIP[INST_SKIP]
+                                                         bytes into the packet received by PKI. */
+	uint64_t lg_custom                    : 1;  /**< Reserved. */
 	uint64_t fulc_en                      : 1;  /**< Enable Fulcrum tag parsing.
                                                          0 = Any Fulcrum header is ignored.
                                                          1 = Fulcrum header is parsed. PKI_GBL_PEN[FULC_PEN] must be set.
@@ -1966,7 +1990,8 @@ union cvmx_pki_clx_pkindx_cfg {
 	uint64_t inst_hdr                     : 1;
 	uint64_t mpls_en                      : 1;
 	uint64_t fcs_pres                     : 1;
-	uint64_t reserved_8_63                : 56;
+	uint64_t lg_custom_layer              : 3;
+	uint64_t reserved_11_63               : 53;
 #endif
 	} s;
 	struct cvmx_pki_clx_pkindx_cfg_s      cn73xx;
@@ -1979,28 +2004,26 @@ typedef union cvmx_pki_clx_pkindx_cfg cvmx_pki_clx_pkindx_cfg_t;
 /**
  * cvmx_pki_cl#_pkind#_kmem#
  *
- * A convenient alias block for the following registers:
- * * PKI_CL()_PKIND()_CFG
- * * PKI_CL()_PKIND()_STYLE
- * * PKI_CL()_PKIND()_SKIP
- * * PKI_CL()_PKIND()_L2_CUSTOM
- * * PKI_CL()_PKIND()_LG_CUSTOM
- *
- * The PKI_CL(0..1)_PKIND* registers listed above are the preferred access method.
+ * This register initializes the KMEM, which initializes the sequencer state for each
+ * pkind. These CSRs are used only by the PKI parse engine/sequencer.
  *
- * Software should reload the PKI_CL()_PKIND()_KMEM() registers upon the
- * detection of KMEM_SBE or KMEM_DBE.
+ * Inside the KMEM are the following sequencer registers. These registers are the
+ * preferred access method for software:
+ * * PKI_CL()_PKIND()_CFG.
+ * * PKI_CL()_PKIND()_STYLE.
+ * * PKI_CL()_PKIND()_SKIP.
+ * * PKI_CL()_PKIND()_L2_CUSTOM.
+ * * PKI_CL()_PKIND()_LG_CUSTOM.
  *
- * INTERNAL: The register initialization value for each PKIND and register number (plus 32 or 48
- * based on
- * PKI_ICG()_CFG[MLO]). The other PKI_PKND* registers alias inside regions of
- * PKI_CL()_PKIND()_KMEM(). To avoid confusing tools, these aliases have address
- * bit 20 set; the PKI address decoder ignores bit 20 when accessing
+ * To avoid overlapping addresses, these aliases have address bit 20 set in contrast to
+ * this register; the PKI address decoder ignores bit 20 when accessing
  * PKI_CL()_PKIND()_KMEM().
  *
- * In terms of ECC processing, PFE will unload the entire PKND KMEM register set
- * potentially introducing an ECC error from an unaliased register.  Therefore the
- * entire KMEM must be exposed to software to be scrubbed in such an event.
+ * Software must reload the PKI_CL()_PKIND()_KMEM() registers upon the detection of
+ * PKI_ECC_INT0[KMEM_SBE] or PKI_ECC_INT0[KMEM_DBE].
+ *
+ * For each legal j and k value, PKI_CL(i)_PKIND(j)_KMEM(k) must be configured
+ * identically for i=0..1.
  */
 union cvmx_pki_clx_pkindx_kmemx {
 	uint64_t u64;
@@ -2022,6 +2045,11 @@ typedef union cvmx_pki_clx_pkindx_kmemx cvmx_pki_clx_pkindx_kmemx_t;
 
 /**
  * cvmx_pki_cl#_pkind#_l2_custom
+ *
+ * This register is inside PKI_CL()_PKIND()_KMEM(). These CSRs are used only by
+ * the PKI parse engine/sequencer.
+ *
+ * For each legal j, PKI_CL(i)_PKIND(j)_L2_CUSTOM must be configured identically for i=0..1.
  */
 union cvmx_pki_clx_pkindx_l2_custom {
 	uint64_t u64;
@@ -2030,8 +2058,7 @@ union cvmx_pki_clx_pkindx_l2_custom {
 	uint64_t reserved_16_63               : 48;
 	uint64_t valid                        : 1;  /**< Valid.
                                                          0 = Disable custom L2 header extraction.
-                                                         1 = Enable custom L2 header extraction.
-                                                         PKI_GBL_PEN[CLG_PEN] must be set. */
+                                                         1 = Enable custom L2 header extraction. */
 	uint64_t reserved_8_14                : 7;
 	uint64_t offset                       : 8;  /**< Scan offset. Pointer to first byte of 32-bit custom extraction header, as absolute number
                                                          of bytes from beginning of packet. If PTP_MODE, the 8-byte timestamp is prepended to the
@@ -2052,14 +2079,21 @@ typedef union cvmx_pki_clx_pkindx_l2_custom cvmx_pki_clx_pkindx_l2_custom_t;
 
 /**
  * cvmx_pki_cl#_pkind#_lg_custom
+ *
+ * This register is inside PKI_CL()_PKIND()_KMEM(). These CSRs are used only by
+ * the PKI parse engine/sequencer.
+ *
+ * For each legal j, PKI_CL(i)_PKIND(j)_LG_CUSTOM must be configured identically for i=0..1.
  */
 union cvmx_pki_clx_pkindx_lg_custom {
 	uint64_t u64;
 	struct cvmx_pki_clx_pkindx_lg_custom_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t offset                       : 8;  /**< Scan offset. Pointer to first byte of 32-bit custom extraction header, as relative number
-                                                         of bytes from WQE[LFPTR]. */
+	uint64_t offset                       : 8;  /**< Scan offset. Pointer to first byte of 32-bit custom extraction header, as
+                                                         relative number of bytes from PKI_WQE_S[LCPTR], PKI_WQE_S[LDPTR],
+                                                         PKI_WQE_S[LEPTR], PKI_WQE_S[LFPTR], as selected by
+                                                         PKI_CL()_PKIND()_CFG[LG_CUSTOM_LAYER]. */
 #else
 	uint64_t offset                       : 8;
 	uint64_t reserved_8_63                : 56;
@@ -2074,6 +2108,11 @@ typedef union cvmx_pki_clx_pkindx_lg_custom cvmx_pki_clx_pkindx_lg_custom_t;
 
 /**
  * cvmx_pki_cl#_pkind#_skip
+ *
+ * This register is inside PKI_CL()_PKIND()_KMEM(). These CSRs are used only by
+ * the PKI parse engine/sequencer.
+ *
+ * For each legal j, PKI_CL(i)_PKIND(j)_SKIP must be configured identically for i=0..1.
  */
 union cvmx_pki_clx_pkindx_skip {
 	uint64_t u64;
@@ -2103,6 +2142,11 @@ typedef union cvmx_pki_clx_pkindx_skip cvmx_pki_clx_pkindx_skip_t;
 
 /**
  * cvmx_pki_cl#_pkind#_style
+ *
+ * This register is inside PKI_CL()_PKIND()_KMEM(). These CSRs are used only by
+ * the PKI parse engine/sequencer.
+ *
+ * For each legal j, PKI_CL(i)_PKIND(j)_STYLE must be configured identically for i=0..1.
  */
 union cvmx_pki_clx_pkindx_style {
 	uint64_t u64;
@@ -2110,20 +2154,20 @@ union cvmx_pki_clx_pkindx_style {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
 	uint64_t pm                           : 7;  /**< Initial parse mode. Bit mask of which sequence steps to perform, refer to Parse Mode:
-                                                         _ <0> = LA (L2)
-                                                         _ <1> = LB (Custom)
-                                                         _ <2> = LC (L3)
-                                                         _ <3> = LD (L4 Virt)
-                                                         _ <4> = LE (IL3)
-                                                         _ <5> = LF (L4)
-                                                         _ <6> = LG (Custom/Application)
+                                                         _ <0> = LA (L2).
+                                                         _ <1> = LB (Custom).
+                                                         _ <2> = LC (L3).
+                                                         _ <3> = LD (L4 Virt).
+                                                         _ <4> = LE (IL3).
+                                                         _ <5> = LF (L4).
+                                                         _ <6> = LG (Custom/Application).
                                                          The legal values are:
-                                                         _ 0x0 = Parse LA..LG
-                                                         _ 0x1 = Parse LB..LG
-                                                         _ 0x3 = Parse LC..LG
-                                                         _ 0x3F = Parse LG
-                                                         _ 0x7F = Parse nothing
-                                                         _ else = Reserved */
+                                                         _ 0x0 = Parse LA..LG.
+                                                         _ 0x1 = Parse LB..LG.
+                                                         _ 0x3 = Parse LC..LG.
+                                                         _ 0x3F = Parse LG.
+                                                         _ 0x7F = Parse nothing.
+                                                         _ else = Reserved. */
 	uint64_t style                        : 8;  /**< Initial style. Initial style number for packets on this port, will remain as final style
                                                          if no PCAM entries match the packet. Note only 64 final styles exist, the upper two bits
                                                          will only be used for PCAM matching. */
@@ -2143,23 +2187,23 @@ typedef union cvmx_pki_clx_pkindx_style cvmx_pki_clx_pkindx_style_t;
 /**
  * cvmx_pki_cl#_smem#
  *
- * A convenient alias block for the following registers:
+ * This register initializes the SMEM, which configures the sequencer. These CSRs
+ * are used by the PKI parse engine/sequencer and other PKI HW.
+ *
+ * Inside the SMEM are the following sequencer registers. These registers are the
+ * preferred access method for software:
  * * PKI_CL()_STYLE()_CFG
  * * PKI_CL()_STYLE()_CFG2
  * * PKI_CL()_STYLE()_ALG
  *
- * The PKI_CL(0..1)_STYLE* registers listed above are the preferred access method.
+ * To avoid overlapping addresses, these aliases have address bit 20 set in contrast to
+ * this register; the PKI address decoder ignores bit 20 when accessing
+ * PKI_CL()_SMEM().
  *
- * Software should reload the PKI_CL()_SMEM() registers upon the
- * detection of SMEM_SBE or SMEM_DBE.
+ * Software must reload the PKI_CL()_SMEM() registers upon the detection of
+ * PKI_CL()_ECC_INT[SMEM_SBE] or PKI_CL()_ECC_INT[SMEM_DBE].
  *
- * INTERNAL: PKI_STYLE* registers alias inside regions of PKI_CL()_SMEM(). To avoid confusing
- * tools, these aliases have address bit 20 set; the PKI address decoder ignores bit 20 when
- * accessing PKI_CL()_SMEM().
- *
- * In terms of ECC processing, ucode will only touch SMEM registers based on the
- * program so we can limit which SMEM addresses are actually used.  ECC faults to
- * unused entries will not create a problem but we will expose for symmetry.
+ * For each legal j, PKI_CL(i)_SMEM(j) must be configured identically for i=0..1.
  */
 union cvmx_pki_clx_smemx {
 	uint64_t u64;
@@ -2181,6 +2225,9 @@ typedef union cvmx_pki_clx_smemx cvmx_pki_clx_smemx_t;
 
 /**
  * cvmx_pki_cl#_start
+ *
+ * This register configures a cluster. All of PKI_CL()_START must be programmed identically.
+ *
  */
 union cvmx_pki_clx_start {
 	uint64_t u64;
@@ -2202,6 +2249,11 @@ typedef union cvmx_pki_clx_start cvmx_pki_clx_start_t;
 
 /**
  * cvmx_pki_cl#_style#_alg
+ *
+ * This register is inside PKI_CL()_SMEM(). These CSRs are used only by
+ * the PKI parse engine/sequencer.
+ *
+ * For each legal j, PKI_CL(i)_STYLE(j)_ALG must be configured identically for i=0..1.
  */
 union cvmx_pki_clx_stylex_alg {
 	uint64_t u64;
@@ -2209,7 +2261,7 @@ union cvmx_pki_clx_stylex_alg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
 	uint64_t tt                           : 2;  /**< SSO tag type to schedule to, enumerated by SSO_TT_E. */
-	uint64_t apad_nip                     : 3;  /**< Value for WQE[APAD] when packet is not IP. */
+	uint64_t apad_nip                     : 3;  /**< Value for PKI_WQE_S[APAD] when packet is not IP. */
 	uint64_t qpg_qos                      : 3;  /**< Algorithm to select QoS field in QPG calculation. Enumerated by PKI_QPGQOS_E. */
 	uint64_t qpg_port_sh                  : 3;  /**< Number of bits to shift port number in QPG calculation. */
 	uint64_t qpg_port_msb                 : 4;  /**< MSB to take from port number in QPG calculation.
@@ -2233,7 +2285,7 @@ union cvmx_pki_clx_stylex_alg {
 	uint64_t tag_vlan                     : 1;  /**< Reserved. */
 	uint64_t tag_mpls0                    : 1;  /**< Reserved. */
 	uint64_t tag_prt                      : 1;  /**< Include interface port in tag hash. */
-	uint64_t wqe_vs                       : 1;  /**< Which VLAN to put into WQE[VLPTR] when VLAN stacking.
+	uint64_t wqe_vs                       : 1;  /**< Which VLAN to put into PKI_WQE_S[VLPTR] when VLAN stacking.
                                                          0 = Use the first (in network order) VLAN or DSA VID.
                                                          1 = Use the second (in network order) VLAN. */
 #else
@@ -2266,6 +2318,11 @@ typedef union cvmx_pki_clx_stylex_alg cvmx_pki_clx_stylex_alg_t;
 
 /**
  * cvmx_pki_cl#_style#_cfg
+ *
+ * This register is inside PKI_CL()_SMEM(). These CSRs are used by
+ * the PKI parse engine/sequencer and other PKI HW.
+ *
+ * For each legal j, PKI_CL(i)_STYLE(j)_CFG must be configured identically for i=0..1.
  */
 union cvmx_pki_clx_stylex_cfg {
 	uint64_t u64;
@@ -2276,28 +2333,31 @@ union cvmx_pki_clx_stylex_cfg {
                                                          patterns. IPv6 outlaws this and the spec says to always check UDP checksum.
                                                          0 = Spec compliant, do not allow optional code.
                                                          1 = Treat IPv6 as IPv4; the all-0s pattern will cause a UDP checksum pass. */
-	uint64_t lenerr_en                    : 1;  /**< L2 length error check enable. Check if frame was received with L2 length error. This check
-                                                         is typically not enabled for incoming packets on the DPI ports. INTERNAL: Sequencer clears
-                                                         this bit for PKI_BE when SNAP length checks are not appropriate. */
-	uint64_t lenerr_eqpad                 : 1;  /**< L2 length checks exact pad size.
-                                                         0 = Length check uses greater then or equal comparison. Packets must have at least minimum
-                                                         padding, but may have more. This mode must be used when there may be extra Etherypes
-                                                         including VLAN tags.
-                                                         1 = Length check uses equal comparison. Packets must have the exact padding necessary to
-                                                         insure a minimum frame size and no more. */
+	uint64_t lenerr_en                    : 1;  /**< L2 length error check enable. When set, the hardware checks that the number of packet
+                                                         bytes following the L2 length field (excluding FCS) is at least as large as the L2
+                                                         length field value whenever the ethertype / L2 length field is <= 1535.
+                                                         The PKI L2 length check assumes that FCS is present in the packet received by PKI,
+                                                         so [LENERR_EN] should be clear when FCS is not present in the packets received
+                                                         (i.e. [LENERR_EN] should be clear whenever corresponding PKI_CL()_PKIND()_CFG[FCS_PRES]
+                                                         is clear). */
+	uint64_t lenerr_eqpad                 : 1;  /**< Reserved. Must be zero. */
 	uint64_t minmax_sel                   : 1;  /**< Selects which PKI_FRM_LEN_CHK() register is used for this pkind for MINERR and MAXERR
                                                          checks.
-                                                         0 = use PKI_FRM_LEN_CHK0.
-                                                         1 = use PKI_FRM_LEN_CHK1. */
-	uint64_t maxerr_en                    : 1;  /**< Max frame error check enable. */
-	uint64_t minerr_en                    : 1;  /**< Min frame error check enable. This check is typically not enabled for incoming packets on
-                                                         the DPI ports. */
-	uint64_t qpg_dis_grptag               : 1;  /**< Disable computing group using WQE[TAG]. */
-	uint64_t fcs_strip                    : 1;  /**< Strip L2 FCS bytes from packet, decrease WQE[LEN] by 4 bytes.
-                                                         PKI_CL()_PKIND()_CFG[FCS_PRES] must be set. */
-	uint64_t fcs_chk                      : 1;  /**< FCS checking enabled. PKI_CL()_PKIND()_CFG[FCS_PRES] must be set. */
+                                                         0 = use PKI_FRM_LEN_CHK(0).
+                                                         1 = use PKI_FRM_LEN_CHK(1). */
+	uint64_t maxerr_en                    : 1;  /**< Max frame error check enable. See PKI_FRM_LEN_CHK()[MAXLEN], [MINMAX_SEL],
+                                                         PKI_OPCODE_E::L2_OVERSIZE,L2_OVERRUN, PKI_ERRLEV_E::LA, and PKI_WQE_S[ERRLEV,OPCODE]. */
+	uint64_t minerr_en                    : 1;  /**< Min frame error check enable. See PKI_FRM_LEN_CHK()[MINLEN], [MINMAX_SEL],
+                                                         PKI_OPCODE_E::L2_UNDERSIZE,L2_FRAGMENT, PKI_ERRLEV_E::LA, and PKI_WQE_S[ERRLEV,OPCODE]. */
+	uint64_t qpg_dis_grptag               : 1;  /**< Disable computing group using PKI_WQE_S[TAG]. See PKI_WQE_S[GRP]. */
+	uint64_t fcs_strip                    : 1;  /**< Strip L2 FCS bytes from packet, decrease PKI_WQE_S[LEN] by 4 bytes. Corresponding
+                                                         PKI_CL()_PKIND()_CFG[FCS_PRES] must be set when [FCS_STRIP] is set.
+                                                         See the PKI_OPCODE_E::L2_PUNY exception case. */
+	uint64_t fcs_chk                      : 1;  /**< FCS checking enabled. Corresponding PKI_CL()_PKIND()_CFG[FCS_PRES] must be set
+                                                         when [FCS_CHK] is set. See PKI_OPCODE_E::L2_PFCS,L2_FRAGMENT,L2_OVERRUN,
+                                                         PKI_ERRLEV_E::LA, and PKI_WQE_S[ERRLEV,OPCODE]. */
 	uint64_t rawdrp                       : 1;  /**< Allow RAW packet drop.
-                                                         0 = Never drop packets with WQE[RAW] set.
+                                                         0 = Never drop packets with PKI_WQE_S[RAW] set.
                                                          1 = Allow the PKI to drop RAW packets based on PKI_AURA()_CFG[ENA_RED/ENA_DROP]. */
 	uint64_t drop                         : 1;  /**< Force packet dropping.
                                                          0 = Drop packet based on PKI_AURA()_CFG[ENA_RED/ENA_DROP].
@@ -2305,12 +2365,13 @@ union cvmx_pki_clx_stylex_cfg {
 	uint64_t nodrop                       : 1;  /**< Disable QoS packet drop.
                                                          0 = Allowed to drop packet based on PKI_AURA()_CFG[ENA_RED/ENA_DROP].
                                                          1 = Never drop the packet. Overrides [RAWDRP]. */
-	uint64_t qpg_dis_padd                 : 1;  /**< Disable computing port adder by QPG algorithm. */
-	uint64_t qpg_dis_grp                  : 1;  /**< Disable computing group by QPG algorithm. */
-	uint64_t qpg_dis_aura                 : 1;  /**< Disable computing aura by QPG algorithm. */
+	uint64_t qpg_dis_padd                 : 1;  /**< Disable computing port adder by QPG algorithm. See PKI_WQE_S[CHAN]. */
+	uint64_t qpg_dis_grp                  : 1;  /**< Disable computing group by QPG algorithm.
+                                                         [QPG_DIS_GRP] should normally always be clear. */
+	uint64_t qpg_dis_aura                 : 1;  /**< Disable computing aura by QPG algorithm.
+                                                         [QPG_DIS_AURA] should normally always be clear. */
 	uint64_t reserved_11_15               : 5;
-	uint64_t qpg_base                     : 11; /**< Base index into PKI_QPG_TBL(). INTERNAL: Sequencer starts with QPG_BASE, performs
-                                                         the QPG calculation and packs the resulting QPG index back into this field for PKI_BE_S. */
+	uint64_t qpg_base                     : 11; /**< Base index into PKI_QPG_TBL(). */
 #else
 	uint64_t qpg_base                     : 11;
 	uint64_t reserved_11_15               : 5;
@@ -2341,6 +2402,11 @@ typedef union cvmx_pki_clx_stylex_cfg cvmx_pki_clx_stylex_cfg_t;
 
 /**
  * cvmx_pki_cl#_style#_cfg2
+ *
+ * This register is inside PKI_CL()_SMEM(). These CSRs are used by
+ * the PKI parse engine/sequencer and other PKI HW.
+ *
+ * For each legal j, PKI_CL(i)_STYLE(j)_CFG2 must be configured identically for i=0..1.
  */
 union cvmx_pki_clx_stylex_cfg2 {
 	uint64_t u64;
@@ -2348,37 +2414,90 @@ union cvmx_pki_clx_stylex_cfg2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
 	uint64_t tag_inc                      : 4;  /**< Include masked tags using PKI_TAG_INC()_MASK. Each bit indicates to include the
-                                                         corresponding PKI_TAG_INC_MASK range, see PKI_INST_HDR_S. */
+                                                         corresponding PKI_TAG_INC()_MASK range. See also PKI_TAG_INC()_CTL
+                                                         and PKI_WQE_S[TAG]. */
 	uint64_t reserved_25_27               : 3;
-	uint64_t tag_masken                   : 1;  /**< Apply PKI_STYLE()_TAG_MASK to computed tag. INTERNAL: Sequencer must clear for PKI BE
-                                                         when the tag comes from the PKI_INST_HDR_S. */
-	uint64_t tag_src_lg                   : 1;  /**< Include Layer G source address in tuple tag generation. */
-	uint64_t tag_src_lf                   : 1;  /**< Include Layer F source address in tuple tag generation. */
-	uint64_t tag_src_le                   : 1;  /**< Include Layer E source address in tuple tag generation. */
-	uint64_t tag_src_ld                   : 1;  /**< Include Layer D source address in tuple tag generation. */
-	uint64_t tag_src_lc                   : 1;  /**< Include Layer C source address in tuple tag generation. */
-	uint64_t tag_src_lb                   : 1;  /**< Include Layer B source address in tuple tag generation. INTERNAL: Sequencer must clear
-                                                         TAG_SRC_L* for PKI BE when TCP SYNs are not tagged, or when the tag comes from the
-                                                         PKI_INST_HDR_S. */
-	uint64_t tag_dst_lg                   : 1;  /**< Include Layer G destination address in tuple tag generation. */
-	uint64_t tag_dst_lf                   : 1;  /**< Include Layer F destination address in tuple tag generation. */
-	uint64_t tag_dst_le                   : 1;  /**< Include Layer E destination address in tuple tag generation. */
-	uint64_t tag_dst_ld                   : 1;  /**< Include Layer D destination address in tuple tag generation. */
-	uint64_t tag_dst_lc                   : 1;  /**< Include Layer C destination address in tuple tag generation. */
-	uint64_t tag_dst_lb                   : 1;  /**< Include Layer B destination address in tuple tag generation. INTERNAL: Sequencer must
-                                                         clear TAG_SRC_L* for PKI BE when the tag comes from the PKI_INST_HDR_S. */
-	uint64_t len_lg                       : 1;  /**< Check length of Layer G. */
-	uint64_t len_lf                       : 1;  /**< Check length of Layer F. */
-	uint64_t len_le                       : 1;  /**< Check length of Layer E. */
-	uint64_t len_ld                       : 1;  /**< Check length of Layer D. */
-	uint64_t len_lc                       : 1;  /**< Check length of Layer C. */
-	uint64_t len_lb                       : 1;  /**< Check length of Layer B. */
-	uint64_t csum_lg                      : 1;  /**< Compute checksum on Layer G. */
-	uint64_t csum_lf                      : 1;  /**< Compute checksum on Layer F. */
-	uint64_t csum_le                      : 1;  /**< Compute checksum on Layer E. */
-	uint64_t csum_ld                      : 1;  /**< Compute checksum on Layer D. */
-	uint64_t csum_lc                      : 1;  /**< Compute checksum on Layer C. */
-	uint64_t csum_lb                      : 1;  /**< Compute checksum on Layer B. */
+	uint64_t tag_masken                   : 1;  /**< When set, apply PKI_STYLE()_TAG_MASK to computed tag. See PKI_WQE_S[TAG]. */
+	uint64_t tag_src_lg                   : 1;  /**< Reserved. Must be zero. */
+	uint64_t tag_src_lf                   : 1;  /**< When set, PKI hardware includes the (inner or outer) IPv4/IPv6 TCP/UDP/SCTP
+                                                         source port in tuple tag generation when PKI_LTYPE(PKI_WQE_S[LFTY])_MAP[BELTYPE]
+                                                         equals any of PKI_BELTYPE_E::TCP,UDP,SCTP. PKI_WQE_S[LFPTR] points to the
+                                                         TCP/UDP/SCTP header in this case. In an IP-in-IP case, [TAG_SRC_LF] refers
+                                                         to the inner IPv4/IPv6 TCP/UDP/SCTP, else the outer/only IPv4/IPv6 TCP/UDP/SCTP.
+                                                         See PKI_WQE_S[TAG]. */
+	uint64_t tag_src_le                   : 1;  /**< When set, PKI hardware includes the inner IPv4/IPv6 source address (in an
+                                                         IP-in-IP case) in tuple tag generation when PKI_LTYPE(PKI_WQE_S[LETY])_MAP[BELTYPE]
+                                                         equals either of PKI_BELTYPE_E::IP4,IP6. PKI_WQE_S[LEPTR] points to the inner
+                                                         IPv4/IPv6 header in this case. See PKI_WQE_S[TAG]. */
+	uint64_t tag_src_ld                   : 1;  /**< When set, PKI hardware includes the outer IPv4/IPv6 UDP source port (in an
+                                                         IP-in-IP case) in tuple tag generation when PKI_LTYPE(PKI_WQE_S[LDTY])_MAP[BELTYPE]
+                                                         equals PKI_BELTYPE_E::UDP. PKI_WQE_S[LDPTR] points to the UDP header in this case.
+                                                         See PKI_WQE_S[TAG]. */
+	uint64_t tag_src_lc                   : 1;  /**< When set, PKI hardware includes the outermost IPv4/IPv6 source address
+                                                         in tuple tag generation when PKI_LTYPE(PKI_WQE_S[LCTY])_MAP[BELTYPE]
+                                                         equals either of PKI_BELTYPE_E::IP4,IP6. PKI_WQE_S[LCPTR] points to the
+                                                         IPv4/IPv6 header in this case. See PKI_WQE_S[TAG]. */
+	uint64_t tag_src_lb                   : 1;  /**< Reserved. Must be zero. */
+	uint64_t tag_dst_lg                   : 1;  /**< Reserved. Must be zero. */
+	uint64_t tag_dst_lf                   : 1;  /**< When set, PKI hardware includes the (inner or outer) IPv4/IPv6 TCP/UDP/SCTP
+                                                         destination port in tuple tag generation when PKI_LTYPE(PKI_WQE_S[LFTY])_MAP[BELTYPE]
+                                                         equals any of PKI_BELTYPE_E::TCP,UDP,SCTP. PKI_WQE_S[LFPTR] points to the
+                                                         TCP/UDP/SCTP header in this case. In an IP-in-IP case, [TAG_DST_LF] refers
+                                                         to the inner IPv4/IPv6 TCP/UDP/SCTP, else the outer/only IPv4/IPv6 TCP/UDP/SCTP.
+                                                         See PKI_WQE_S[TAG]. */
+	uint64_t tag_dst_le                   : 1;  /**< When set, PKI hardware includes the inner IPv4/IPv6 destination address (in an
+                                                         IP-in-IP case) in tuple tag generation when PKI_LTYPE(PKI_WQE_S[LETY])_MAP[BELTYPE]
+                                                         equals either of PKI_BELTYPE_E::IP4,IP6. PKI_WQE_S[LEPTR] points to the inner
+                                                         IPv4/IPv6 header in this case. See PKI_WQE_S[TAG]. */
+	uint64_t tag_dst_ld                   : 1;  /**< When set, PKI hardware includes the outer IPv4/IPv6 UDP destination port (in an
+                                                         IP-in-IP case) in tuple tag generation when PKI_LTYPE(PKI_WQE_S[LDTY])_MAP[BELTYPE]
+                                                         equals PKI_BELTYPE_E::UDP. PKI_WQE_S[LDPTR] points to the UDP header in this case.
+                                                         See PKI_WQE_S[TAG]. */
+	uint64_t tag_dst_lc                   : 1;  /**< When set, PKI hardware includes the outermost IPv4/IPv6 destination address
+                                                         in tuple tag generation when PKI_LTYPE(PKI_WQE_S[LCTY])_MAP[BELTYPE]
+                                                         equals either of PKI_BELTYPE_E::IP4,IP6. PKI_WQE_S[LCPTR] points to the
+                                                         IPv4/IPv6 header in this case. See PKI_WQE_S[TAG]. */
+	uint64_t tag_dst_lb                   : 1;  /**< Reserved. Must be zero. */
+	uint64_t len_lg                       : 1;  /**< Reserved. Must be zero. */
+	uint64_t len_lf                       : 1;  /**< When set, PKI hardware performs an (inner or outer) IPv4/IPv6 TCP/UDP/SCTP
+                                                         PKI_OPCODE_E::L4_LEN check when PKI_LTYPE(PKI_WQE_S[LFTY])_MAP[BELTYPE]
+                                                         equals any of PKI_BELTYPE_E::TCP,UDP,SCTP. PKI_WQE_S[LFPTR] points to the
+                                                         TCP/UDP/SCTP header in this case. In an IP-in-IP case, [LEN_LF] refers
+                                                         to the inner IPv4/IPv6 TCP/UDP/SCTP, else the outer/only IPv4/IPv6 TCP/UDP/SCTP.
+                                                         See PKI_WQE_S[ERRLEV,OPCODE] and PKI_ERRLEV_E::LF. */
+	uint64_t len_le                       : 1;  /**< When set, PKI hardware performs an inner IPv4/IPv6 PKI_OPCODE_E::IP_MALD check (in an
+                                                         IP-in-IP case) when PKI_LTYPE(PKI_WQE_S[LETY])_MAP[BELTYPE] equals either of
+                                                         PKI_BELTYPE_E::IP4,IP6. PKI_WQE_S[LEPTR] points to the inner IPv4/IPv6 header in this
+                                                         case. See PKI_WQE_S[ERRLEV,OPCODE] and PKI_ERRLEV_E::LE. */
+	uint64_t len_ld                       : 1;  /**< When set, PKI hardware performs an outer IPv4/IPv6 UDP PKI_OPCODE_E::L4_LEN
+                                                         check (in an IP-in-IP case) when PKI_LTYPE(PKI_WQE_S[LDTY])_MAP[BELTYPE]
+                                                         equals PKI_BELTYPE_E::UDP. PKI_WQE_S[LDPTR] points to the UDP header in this case.
+                                                         See PKI_WQE_S[ERRLEV,OPCODE] and PKI_ERRLEV_E::LD. */
+	uint64_t len_lc                       : 1;  /**< When set, PKI hardware performs an outermost IPv4/IPv6 PKI_OPCODE_E::IP_MALD
+                                                         check when PKI_LTYPE(PKI_WQE_S[LCTY])_MAP[BELTYPE] equals either of
+                                                         PKI_BELTYPE_E::IP4,IP6. PKI_WQE_S[LCPTR] points to the IPv4/IPv6 header in this
+                                                         case. See PKI_WQE_S[ERRLEV,OPCODE] and PKI_ERRLEV_E::LC. */
+	uint64_t len_lb                       : 1;  /**< Reserved. Must be zero. */
+	uint64_t csum_lg                      : 1;  /**< Reserved. Must be zero. */
+	uint64_t csum_lf                      : 1;  /**< When set, PKI hardware performs an (inner or outer) IPv4/IPv6 TCP/UDP/SCTP
+                                                         PKI_OPCODE_E::L4_CHK check when PKI_LTYPE(PKI_WQE_S[LFTY])_MAP[BELTYPE]
+                                                         equals any of PKI_BELTYPE_E::TCP,UDP,SCTP. PKI_WQE_S[LFPTR] points to the
+                                                         TCP/UDP/SCTP header in this case. In an IP-in-IP case, [CSUM_LF] refers
+                                                         to the inner IPv4/IPv6 TCP/UDP/SCTP, else the outer/only IPv4/IPv6 TCP/UDP/SCTP.
+                                                         See PKI_WQE_S[ERRLEV,OPCODE] and PKI_ERRLEV_E::LF. */
+	uint64_t csum_le                      : 1;  /**< When set, PKI hardware performs an inner IPv4/IPv6 PKI_OPCODE_E::IP_CHK check (in an
+                                                         IP-in-IP case) when PKI_LTYPE(PKI_WQE_S[LETY])_MAP[BELTYPE] equals either of
+                                                         PKI_BELTYPE_E::IP4,IP6. PKI_WQE_S[LEPTR] points to the inner IPv4/IPv6 header in this
+                                                         case. See PKI_WQE_S[ERRLEV,OPCODE] and PKI_ERRLEV_E::LE. */
+	uint64_t csum_ld                      : 1;  /**< When set, PKI hardware performs an outer IPv4/IPv6 UDP PKI_OPCODE_E::L4_CHK
+                                                         check (in an IP-in-IP case) when PKI_LTYPE(PKI_WQE_S[LDTY])_MAP[BELTYPE]
+                                                         equals PKI_BELTYPE_E::UDP. PKI_WQE_S[LDPTR] points to the UDP header in this case.
+                                                         See PKI_WQE_S[ERRLEV,OPCODE] and PKI_ERRLEV_E::LD. */
+	uint64_t csum_lc                      : 1;  /**< When set, PKI hardware performs an outermost IPv4/IPv6 PKI_OPCODE_E::IP_CHK
+                                                         check when PKI_LTYPE(PKI_WQE_S[LCTY])_MAP[BELTYPE] equals either of
+                                                         PKI_BELTYPE_E::IP4,IP6. PKI_WQE_S[LCPTR] points to the IPv4/IPv6 header in this
+                                                         case. See PKI_WQE_S[ERRLEV,OPCODE] and PKI_ERRLEV_E::LC. */
+	uint64_t csum_lb                      : 1;  /**< Reserved. Must be zero. */
 #else
 	uint64_t csum_lb                      : 1;
 	uint64_t csum_lc                      : 1;
@@ -2500,7 +2619,7 @@ union cvmx_pki_dstatx_stat2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
 	uint64_t err_pkts                     : 32; /**< Number of packets with errors, including length < minimum, length > maximum, FCS
-                                                         errors, or WQE[ERRLEV]==RE or L2.
+                                                         errors, or PKI_WQE_S[ERRLEV] = RE or L2.
                                                          This corresponds to a sum across the wide statistics PKI_STAT()_STAT7, PKI_STAT()_STAT7,
                                                          PKI_STAT()_STAT8, PKI_STAT()_STAT9, PKI_STAT()_STAT10, PKI_STAT()_STAT11, and
                                                          PKI_STAT()_STAT12. */
@@ -2945,8 +3064,16 @@ union cvmx_pki_frm_len_chkx {
 	struct cvmx_pki_frm_len_chkx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t maxlen                       : 16; /**< Byte count for max-sized frame check. */
-	uint64_t minlen                       : 16; /**< Byte count for min-sized frame check. */
+	uint64_t maxlen                       : 16; /**< Byte count for max-sized frame check. See PKI_CL()_STYLE()_CFG[MAXERR_EN,MINMAX_SEL],
+                                                         PKI_OPCODE_E::L2_OVERSIZE,L2_OVERRUN, PKI_ERRLEV_E::LA, and PKI_WQE_S[ERRLEV,OPCODE].
+                                                         When BGX()_SMU()_RX_FRM_CTL[PTP_MODE] is set, BGX adds an extra 8B timestamp onto
+                                                         the front of every packet sent to PKI. Thus, [MAXLEN] should be increased by 8
+                                                         when BGX()_SMU()_RX_FRM_CTL[PTP_MODE] is set. */
+	uint64_t minlen                       : 16; /**< Byte count for min-sized frame check. See PKI_CL()_STYLE()_CFG[MINERR_EN,MINMAX_SEL],
+                                                         PKI_OPCODE_E::L2_UNDERSIZE,L2_FRAGMENT, PKI_ERRLEV_E::LA, and PKI_WQE_S[ERRLEV,OPCODE].
+                                                         When BGX()_SMU()_RX_FRM_CTL[PTP_MODE] is set, BGX adds an extra 8B timestamp onto
+                                                         the front of every packet sent to PKI. Thus, [MINLEN] should be increased by 8
+                                                         when BGX()_SMU()_RX_FRM_CTL[PTP_MODE] is set. */
 #else
 	uint64_t minlen                       : 16;
 	uint64_t maxlen                       : 16;
@@ -2962,6 +3089,14 @@ typedef union cvmx_pki_frm_len_chkx cvmx_pki_frm_len_chkx_t;
 
 /**
  * cvmx_pki_gbl_pen
+ *
+ * This register contains global configuration information that applies to all
+ * pkinds. The values are opaque to PKI HW.
+ *
+ * This is intended for communication between the higher-level software SDK, and the
+ * SDK code that loads PKI_IMEM() with the sequencer code.  This allows the loader to
+ * appropriately select the sequencer code with only those features required, so that
+ * performance will be optimized.
  */
 union cvmx_pki_gbl_pen {
 	uint64_t u64;
@@ -2973,8 +3108,8 @@ union cvmx_pki_gbl_pen {
                                                          and latency reductions.
                                                          1 = VXLAN/NVGRE/GENEVE parsing may be used. */
 	uint64_t clg_pen                      : 1;  /**< Custom LG parsing enable.
-                                                         0 = Custom LG is never used in any style; i.e. PKI_CL()_PKIND()_CFG[LG_CUSTOM] is
-                                                         zero for all indices. This enables internal power and latency reductions.
+                                                         0 = Custom LG is never used in any style; i.e. PKI_CL()_PKIND()_CFG[LG_CUSTOM_LAYER]
+                                                         is zero for all indices. This enables internal power and latency reductions.
                                                          1 = Custom LG parsing may be used. */
 	uint64_t cl2_pen                      : 1;  /**< Custom L2 parsing enable.
                                                          0 = Custom L2 is never used in any style; i.e. PKI_CL()_PKIND()_L2_CUSTOM[VALID]
@@ -3122,34 +3257,22 @@ typedef union cvmx_pki_gen_int cvmx_pki_gen_int_t;
 /**
  * cvmx_pki_icg#_cfg
  *
- * Configures a cluster group.
- * INTERNAL: Only document a ICG(0..0)
+ * This register configures the cluster group.
+ *
  */
 union cvmx_pki_icgx_cfg {
 	uint64_t u64;
 	struct cvmx_pki_icgx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_53_63               : 11;
-	uint64_t maxipe_use                   : 5;  /**< Maximum number of IPEs to use in each cluster for this ICG. For diagnostic use only.
-                                                         INTERNAL: Allows reducing the number of IPEs available for debug, characterization,
-                                                         repair, etc. Must be 1-20. Normally, PKI will have all 20 IPEs available in a cluster for
-                                                         packet processing, other values will decrease performance. */
+	uint64_t maxipe_use                   : 5;  /**< Reserved. Must be 0x14. */
 	uint64_t reserved_36_47               : 12;
-	uint64_t clusters                     : 4;  /**< Bit-mask of clusters in this cluster group. A given cluster can only be enabled
-                                                         in a single cluster group. Behavior is undefined for an ICG which receives
-                                                         traffic with a [CLUSTERS] of 0x0. ICG(0)'s entry resets to 0x3, all other
-                                                         entries to 0x0. Valid values of CLUSTERS is: 0..3 */
+	uint64_t clusters                     : 4;  /**< Reserved. Must be 0x3. */
 	uint64_t reserved_27_31               : 5;
-	uint64_t release_rqd                  : 1;  /**< Release required. For diagnostic use only. INTERNAL:
-                                                         0 = Release of r64 to r95 will occur immediately, no release microop is needed.
-                                                         1 = Release will wait until release microop executes. */
-	uint64_t mlo                          : 1;  /**< Memory low bypass enable. For diagnostic use only. INTERNAL:
-                                                         0 = KMEM specifies contents of r48 to r63. The sequencer code expects this setting.
-                                                         1 = KMEM specifies contents of r32 to r47. This may be desirable when PKIENA=0 to allow
-                                                         direct control over the back end. */
-	uint64_t pena                         : 1;  /**< Parse enable. Must be set after PKI has been initialized.
-                                                         INTERNAL: Software should set after the IMEM and associated state is initialized.
-                                                         0 = IPT transitions from start directly to done without executing a sequence, and the KMEM
+	uint64_t release_rqd                  : 1;  /**< Reserved. Must be zero. */
+	uint64_t mlo                          : 1;  /**< Reserved. Must be zero. */
+	uint64_t pena                         : 1;  /**< Parse enable. Must be set after PKI has been initialized and PKI_IMEM() loaded.
+                                                         0 = IPE transitions from start directly to done without executing a sequence, and the KMEM
                                                          bits effectively are copied through to the WQ.
                                                          1 = Normal sequencer operation. */
 	uint64_t timer                        : 12; /**< Current hold-off timer. Enables even spreading of cluster utilization over time; while
@@ -3157,15 +3280,11 @@ union cvmx_pki_icgx_cfg {
                                                          group starts parsing, TIMER is set to DELAY, and decrements every coprocessor-clock. TIMER
                                                          is zeroed if all clusters in this group are idle. */
 	uint64_t delay                        : 12; /**< Delay between cluster starts, as described under TIMER. If 0x0, a cluster can
-                                                         start at any time relative to other clusters. DELAY should be typically selected
-                                                         to minimize the average observed parser latency by loading with the parsing
-                                                         delay divided by the number of clusters in this cluster group which will
-                                                         typically be 800 divided by the population count of CLUSTERS
-                                                         (800/pop_cnt(CLUSTERS)). The smallest useful non-zero value is 0xA0,
+                                                         start at any time relative to other clusters. DELAY should typically be
+                                                         the approximate parsing delay (800) divided by the number of bits set in
+                                                         [CLUSTERS]. The smallest useful non-zero value is 0xA0,
                                                          corresponding to the minimum number of cycles needed to fill one cluster with
-                                                         packets.
-                                                         INTERNAL: The number 800 above was chosen as a typical production ucode
-                                                         length with some additional instruction growth. */
+                                                         packets. So set [DELAY] = maximum(0xA0,800/pop_cnt([CLUSTERS])). */
 #else
 	uint64_t delay                        : 12;
 	uint64_t timer                        : 12;
@@ -3193,8 +3312,8 @@ union cvmx_pki_imemx {
 	uint64_t u64;
 	struct cvmx_pki_imemx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t data                         : 64; /**< Instruction word at given address. Software should reload PKI_IMEM() upon the
-                                                         detection of IMEM_SBE or IMEM_DBE errors. */
+	uint64_t data                         : 64; /**< Sequencer instruction word. Software must reload PKI_IMEM() upon the detection
+                                                         of PKI_ECC_INT2[IMEM_SBE] or PKI_ECC_INT2[IMEM_DBE] errors. */
 #else
 	uint64_t data                         : 64;
 #endif
@@ -3208,15 +3327,19 @@ typedef union cvmx_pki_imemx cvmx_pki_imemx_t;
 
 /**
  * cvmx_pki_ltype#_map
+ *
+ * This register is the layer type map, indexed by PKI_LTYPE_E.
+ *
  */
 union cvmx_pki_ltypex_map {
 	uint64_t u64;
 	struct cvmx_pki_ltypex_map_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t beltype                      : 3;  /**< For each given PKI_LTYPE_E, the protocol type backend hardware should assume this layer
-                                                         type corresponds to. Enumerated by PKI_BELTYPE_E. The recommended settings for each
-                                                         PKI_LTYPE_E are shown in the PKI_LTYPE_E table. */
+	uint64_t beltype                      : 3;  /**< For each given PKI_LTYPE_E, the protocol type backend hardware should assume
+                                                         this layer type corresponds to. Enumerated by PKI_BELTYPE_E. The recommended
+                                                         settings for each register index (PKI_LTYPE_E) are shown in the PKI_LTYPE_E
+                                                         table. */
 #else
 	uint64_t beltype                      : 3;
 	uint64_t reserved_3_63                : 61;
@@ -3237,7 +3360,7 @@ union cvmx_pki_pbe_eco {
 	struct cvmx_pki_pbe_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 32; /**< Reserved for ECO usage. */
 #else
 	uint64_t eco_rw                       : 32;
 	uint64_t reserved_32_63               : 32;
@@ -3252,8 +3375,8 @@ typedef union cvmx_pki_pbe_eco cvmx_pki_pbe_eco_t;
 /**
  * cvmx_pki_pcam_lookup
  *
- * For diagnostic use only, perform a PCAM lookup against the provided cluster and PCAM instance
- * and loads results into PKI_PCAM_RESULT.
+ * For diagnostic use only, this register performs a PCAM lookup against the provided
+ * cluster and PCAM instance and loads results into PKI_PCAM_RESULT.
  */
 union cvmx_pki_pcam_lookup {
 	uint64_t u64;
@@ -3285,6 +3408,12 @@ typedef union cvmx_pki_pcam_lookup cvmx_pki_pcam_lookup_t;
 
 /**
  * cvmx_pki_pcam_result
+ *
+ * For diagnostic use only, this register returns PCAM results for the most recent write to
+ * PKI_PCAM_LOOKUP. The read will stall until the lookup is completed.
+ * PKI_CL()_ECC_CTL[PCAM_EN] must be clear before accessing this register.  Read stall
+ * is implemented by delaying the PKI_PCAM_LOOKUP write acknowledge until the PCAM is
+ * free and the lookup can be issued.
  */
 union cvmx_pki_pcam_result {
 	uint64_t u64;
@@ -3354,7 +3483,7 @@ union cvmx_pki_pfe_eco {
 	struct cvmx_pki_pfe_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 32; /**< Reserved for ECO usage. */
 #else
 	uint64_t eco_rw                       : 32;
 	uint64_t reserved_32_63               : 32;
@@ -3420,7 +3549,7 @@ union cvmx_pki_pix_eco {
 	struct cvmx_pki_pix_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 32; /**< Reserved for ECO usage. */
 #else
 	uint64_t eco_rw                       : 32;
 	uint64_t reserved_32_63               : 32;
@@ -3440,8 +3569,7 @@ union cvmx_pki_pkindx_icgsel {
 	struct cvmx_pki_pkindx_icgsel_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t icg                          : 2;  /**< Cluster group that will service traffic on this pkind. See also PKI_ICG()_CFG, the
-                                                         register to which this field indexes. */
+	uint64_t icg                          : 2;  /**< Reserved. Must be zero. */
 #else
 	uint64_t icg                          : 2;
 	uint64_t reserved_2_63                : 62;
@@ -3457,7 +3585,7 @@ typedef union cvmx_pki_pkindx_icgsel cvmx_pki_pkindx_icgsel_t;
 /**
  * cvmx_pki_pknd#_inb_stat0
  *
- * Inbound packets received by PKI per pkind.
+ * This register counts inbound statistics, indexed by pkind.
  *
  */
 union cvmx_pki_pkndx_inb_stat0 {
@@ -3481,7 +3609,7 @@ typedef union cvmx_pki_pkndx_inb_stat0 cvmx_pki_pkndx_inb_stat0_t;
 /**
  * cvmx_pki_pknd#_inb_stat1
  *
- * Inbound octets received by PKI per pkind.
+ * This register counts inbound statistics, indexed by pkind.
  *
  */
 union cvmx_pki_pkndx_inb_stat1 {
@@ -3505,7 +3633,7 @@ typedef union cvmx_pki_pkndx_inb_stat1 cvmx_pki_pkndx_inb_stat1_t;
 /**
  * cvmx_pki_pknd#_inb_stat2
  *
- * Inbound error packets received by PKI per pkind.
+ * This register counts inbound statistics, indexed by pkind.
  *
  */
 union cvmx_pki_pkndx_inb_stat2 {
@@ -3551,15 +3679,8 @@ typedef union cvmx_pki_pkt_err cvmx_pki_pkt_err_t;
 /**
  * cvmx_pki_ptag_avail
  *
- * For diagnostic use. INTERNAL: This register configures tag management. It is
- * suggested that this register only be written when PKI_BUF_CTL[PKI_EN] is clear and
- * must not be reconfigured without soft resetting PKI. While PKI is tolerant of
- * changes to this register and programing restrictions are not necessary for the
- * general case, the suggestion is to simplify verification. Therefore do not put other
- * fields into this register unless the same constraint applies. When the number of
- * tags available increases, PKI will simply have more resources. When the number of
- * tags available decreases, PKI will use less resources and may begin to assert BP if
- * the current tags in use exceeds the programmed value.
+ * For diagnostic use only.
+ *
  */
 union cvmx_pki_ptag_avail {
 	uint64_t u64;
@@ -3586,28 +3707,25 @@ typedef union cvmx_pki_ptag_avail cvmx_pki_ptag_avail_t;
 /**
  * cvmx_pki_qpg_tbl#
  *
- * The QPG table is used to indirectly calculate the Portadd/Aura/Group from the Diffsrv, HiGig
- * or VLAN information as described in QPG.
- * See also PKI_QPG_TBLB().
- * INTERNAL: This register is outside SMEM due to opcode detection.
+ * These registers are used by PKI BE to indirectly calculate the Portadd/Aura/Group
+ * from the Diffsrv, HiGig or VLAN information as described in QPG. See also
+ * PKI_QPG_TBLB().
  */
 union cvmx_pki_qpg_tblx {
 	uint64_t u64;
 	struct cvmx_pki_qpg_tblx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_60_63               : 4;
-	uint64_t padd                         : 12; /**< Port to channel adder for calculating WQE[CHAN]. */
-	uint64_t grptag_ok                    : 3;  /**< Number of WQE[TAG] bits to add into WQE[GRP] if no error is detected. */
+	uint64_t padd                         : 12; /**< Port to channel adder for calculating PKI_WQE_S[CHAN]. */
+	uint64_t grptag_ok                    : 3;  /**< Number of PKI_WQE_S[TAG] bits to add into PKI_WQE_S[GRP] if no error is detected. */
 	uint64_t reserved_42_44               : 3;
-	uint64_t grp_ok                       : 10; /**< SSO group to schedule packet to and to load WQE[GRP] with if no error is detected. */
-	uint64_t grptag_bad                   : 3;  /**< Number of WQE[TAG] bits to add into WQE[GRP] if an error is detected. */
+	uint64_t grp_ok                       : 10; /**< SSO group to schedule packet to and to load PKI_WQE_S[GRP] with if no error is detected. */
+	uint64_t grptag_bad                   : 3;  /**< Number of PKI_WQE_S[TAG] bits to add into PKI_WQE_S[GRP] if an error is detected. */
 	uint64_t reserved_26_28               : 3;
-	uint64_t grp_bad                      : 10; /**< SSO group to schedule packet to and to load WQE[GRP] with if an error is detected. */
+	uint64_t grp_bad                      : 10; /**< SSO group to schedule packet to and to load PKI_WQE_S[GRP] with if an error is detected. */
 	uint64_t reserved_12_15               : 4;
-	uint64_t aura_node                    : 2;  /**< Aura node number. The node number is part of the upper aura bits, however PKI can only
-                                                         allocate from auras on the local node, therefore these bits are hardcoded to the node
-                                                         number. */
-	uint64_t laura                        : 10; /**< Aura on local node for QOS calculations and loading into WQE[AURA]. */
+	uint64_t aura_node                    : 2;  /**< Reserved. */
+	uint64_t laura                        : 10; /**< Aura on local node for QOS calculations and loading into PKI_WQE_S[AURA]. */
 #else
 	uint64_t laura                        : 10;
 	uint64_t aura_node                    : 2;
@@ -3657,9 +3775,6 @@ typedef union cvmx_pki_qpg_tblbx cvmx_pki_qpg_tblbx_t;
 
 /**
  * cvmx_pki_reasm_sop#
- *
- * Set when a SOP is detected on a Reasm-Id, where the Reasm-ID value sets the bit vector of this
- * register.
  */
 union cvmx_pki_reasm_sopx {
 	uint64_t u64;
@@ -3667,9 +3782,9 @@ union cvmx_pki_reasm_sopx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t sop                          : 64; /**< When set, a SOP was detected on a reasm-Id. When clear, a SOP has not yet been
                                                          received, or an EOP was received on the Reasm-Id. The total number of available
-                                                         reassembly IDs is described with the PKI_REASM_E[NUM_REASM] enumeration. Not all
-                                                         bits are implemented. Only PKI_REASM_SOP(0)[SOP<63:0>],
-                                                         PKI_REASM_SOP(1)[SOP<31:0>] are present in this implementation. */
+                                                         reassembly IDs is described with the PKI_REASM_E::NUM_REASM enumeration. Not all
+                                                         bits are implemented. Only PKI_REASM_SOP(0)[SOP]<63:0>,
+                                                         PKI_REASM_SOP(1)[SOP]<31:0> are present in this implementation. */
 #else
 	uint64_t sop                          : 64;
 #endif
@@ -3684,8 +3799,8 @@ typedef union cvmx_pki_reasm_sopx cvmx_pki_reasm_sopx_t;
 /**
  * cvmx_pki_req_wgt
  *
- * Controls the round-robin weights between each PKI requestor. Intended for diagnostic tuning only.
- *
+ * This register controls the round-robin weights between each PKI requestor. For diagnostic
+ * tuning only.
  */
 union cvmx_pki_req_wgt {
 	uint64_t u64;
@@ -3729,15 +3844,10 @@ union cvmx_pki_sft_rst {
 	struct cvmx_pki_sft_rst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t busy                         : 1;  /**< When set, PKI is busy completing reset. No access except the reading of this bit should
-                                                         occur to the PKI until this is clear. INTERNAL: The BUSY bit for this implementation is a
-                                                         placeholder and is not required to be implemented in HW. The soft reset pulse is short
-                                                         enough that we can guarantee that reset will complete below a subsequent RSL reference can
-                                                         be made. It is still useful for this bit to exist in case that property every changes and
-                                                         the reset requires a longer duration. For this implementation, SW will check the bit which
-                                                         will always report not BUSY allowing SW to proceed with its flow. */
+                                                         occur to the PKI until this is clear. */
 	uint64_t reserved_33_62               : 30;
 	uint64_t active                       : 1;  /**< When set, PKI is actively processing packet traffic. It is recommenced that software wait
-                                                         until ACTIVE is clear before setting RST. INTERNAL: ACTIVE is an OR of PKI_ACTIVE0..2. */
+                                                         until ACTIVE is clear before setting RST. */
 	uint64_t reserved_1_31                : 31;
 	uint64_t rst                          : 1;  /**< Reset. When set to 1 by software, PKI will produce an internal reset pulse. */
 #else
@@ -3995,7 +4105,8 @@ union cvmx_pki_statx_stat12 {
 	struct cvmx_pki_statx_stat12_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t l2err                        : 48; /**< Number of non-dropped packets with receive errors (WQE[ERRLEV]==RE or L2) not covered by
+	uint64_t l2err                        : 48; /**< Number of non-dropped packets with receive errors (PKI_WQE_S[ERRLEV]==RE or L2) not
+                                                         covered by
                                                          more specific length or FCS statistic error registers. */
 #else
 	uint64_t l2err                        : 48;
@@ -4017,9 +4128,8 @@ union cvmx_pki_statx_stat13 {
 	struct cvmx_pki_statx_stat13_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t spec                         : 48; /**< Number of non-dropped packets with special handling. For profiling and diagnostic use
-                                                         only.
-                                                         INTERNAL: Counts packets completing IPE processing with WQE[SH] set. */
+	uint64_t spec                         : 48; /**< Number of non-dropped packets with special handling (WEQ[SH] set). For profiling
+                                                         and diagnostic use only. */
 #else
 	uint64_t spec                         : 48;
 	uint64_t reserved_48_63               : 16;
@@ -4041,7 +4151,7 @@ union cvmx_pki_statx_stat14 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t drp_bcast                    : 48; /**< Number of packets with L2 broadcast DMAC that were dropped by RED, buffer exhaustion, or
-                                                         PKI_CL()_STYLE()_CFG[DROP]. See WQE[L2B] for the definition of L2 broadcast. */
+                                                         PKI_CL()_STYLE()_CFG[DROP]. See PKI_WQE_S[L2B] for the definition of L2 broadcast. */
 #else
 	uint64_t drp_bcast                    : 48;
 	uint64_t reserved_48_63               : 16;
@@ -4063,7 +4173,7 @@ union cvmx_pki_statx_stat15 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t drp_mcast                    : 48; /**< Number of packets with L2 multicast DMAC that were dropped by RED, buffer exhaustion, or
-                                                         PKI_CL()_STYLE()_CFG[DROP]. See WQE[L2M] for the definition of L2 multicast. */
+                                                         PKI_CL()_STYLE()_CFG[DROP]. See PKI_WQE_S[L2M] for the definition of L2 multicast. */
 #else
 	uint64_t drp_mcast                    : 48;
 	uint64_t reserved_48_63               : 16;
@@ -4085,7 +4195,7 @@ union cvmx_pki_statx_stat16 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t drp_bcast                    : 48; /**< Number of packets with IPv4 L3 broadcast destination address that were dropped due to RED
-                                                         or buffer exhaustion. See WQE[L3B] for the definition of L2 multicast. */
+                                                         or buffer exhaustion. See PKI_WQE_S[L3B] for the definition of L2 multicast. */
 #else
 	uint64_t drp_bcast                    : 48;
 	uint64_t reserved_48_63               : 16;
@@ -4107,7 +4217,7 @@ union cvmx_pki_statx_stat17 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t drp_mcast                    : 48; /**< Number of packets with IPv4 or IPv6 L3 multicast destination address that were dropped due
-                                                         to RED or buffer exhaustion. See WQE[L3M] for the definition of L3 multicast. */
+                                                         to RED or buffer exhaustion. See PKI_WQE_S[L3M] for the definition of L3 multicast. */
 #else
 	uint64_t drp_mcast                    : 48;
 	uint64_t reserved_48_63               : 16;
@@ -4128,8 +4238,8 @@ union cvmx_pki_statx_stat18 {
 	struct cvmx_pki_statx_stat18_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t drp_spec                     : 48; /**< Number of packets dropped with special handling. For profiling and diagnostic use only.
-                                                         INTERNAL: Counts packets with dropped after completing IPE processing with WQE[SH] set. */
+	uint64_t drp_spec                     : 48; /**< Number of packets dropped with special handling (PKI_WQE_S[SH] set). For
+                                                         profiling and diagnostic use only. */
 #else
 	uint64_t drp_spec                     : 48;
 	uint64_t reserved_48_63               : 16;
@@ -4150,7 +4260,7 @@ union cvmx_pki_statx_stat2 {
 	struct cvmx_pki_statx_stat2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t raw                          : 48; /**< Number of non-dropped packets with WQE[RAW] set. */
+	uint64_t raw                          : 48; /**< Number of non-dropped packets with PKI_WQE_S[RAW] set. */
 #else
 	uint64_t raw                          : 48;
 	uint64_t reserved_48_63               : 16;
@@ -4214,7 +4324,7 @@ union cvmx_pki_statx_stat5 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t bcast                        : 48; /**< Number of non-dropped L2 broadcast packets. Does not include multicast packets. See
-                                                         WQE[L2B] for the definition of L2 broadcast. */
+                                                         PKI_WQE_S[L2B] for the definition of L2 broadcast. */
 #else
 	uint64_t bcast                        : 48;
 	uint64_t reserved_48_63               : 16;
@@ -4236,7 +4346,7 @@ union cvmx_pki_statx_stat6 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t mcast                        : 48; /**< Number of non-dropped L2 multicast packets. Does not include broadcast packets. See
-                                                         WQE[L2M] for the definition of L2 multicast. */
+                                                         PKI_WQE_S[L2M] for the definition of L2 multicast. */
 #else
 	uint64_t mcast                        : 48;
 	uint64_t reserved_48_63               : 16;
@@ -4315,7 +4425,7 @@ typedef union cvmx_pki_statx_stat9 cvmx_pki_statx_stat9_t;
 /**
  * cvmx_pki_stat_ctl
  *
- * Controls how the PKI statistics counters are handled.
+ * This register controls how the PKI statistics counters are handled.
  *
  */
 union cvmx_pki_stat_ctl {
@@ -4346,6 +4456,9 @@ typedef union cvmx_pki_stat_ctl cvmx_pki_stat_ctl_t;
 
 /**
  * cvmx_pki_style#_buf
+ *
+ * This register configures the PKI BE skip amounts and other information.
+ * It is indexed by final style, PKI_WQE_S[STYLE]<5:0>.
  */
 union cvmx_pki_stylex_buf {
 	uint64_t u64;
@@ -4355,13 +4468,15 @@ union cvmx_pki_stylex_buf {
 	uint64_t pkt_lend                     : 1;  /**< Packet little-endian. Changes write operations of packet data to L2C to be in little-
                                                          endian. Does not change the WQE header format, which is properly endian neutral. */
 	uint64_t wqe_hsz                      : 2;  /**< Work queue header size:
-                                                         0x0 = WORD0..4, standard WQE_S. Note FIRST_SKIP may be set to not include WORD4 in memory.
+                                                         0x0 = WORD0..4, standard PKI_WQE_S. Note FIRST_SKIP may be set to not include WORD4 in
+                                                         memory.
                                                          0x1 = WORD0..5.
-                                                         0x2 = Reserved
-                                                         0x3 = Reserved
-                                                         INTERNAL: Selects which PIX words are transferred to the PKI BE. If a word is not
-                                                         transferred and the word will reach memory (FIRST_SKIP is greater than that word number),
-                                                         then the final WQE memory word will be zero, not the PIX register contents. */
+                                                         0x2 = Reserved.
+                                                         0x3 = Reserved.
+                                                         Selects which sequencer words are transferred to the PKI BE. If a word is not
+                                                         transferred and the word will reach memory (FIRST_SKIP is greater than that word
+                                                         number), then the final WQE memory word will be zero, not the sequencer register
+                                                         contents. */
 	uint64_t wqe_skip                     : 2;  /**< WQE start offset. The number of 128-byte cache lines to skip between the buffer pointer
                                                          and WORD0 of the work-queue entry.
                                                          If [DIS_WQ_DAT]=1, legal values must satisfy:
@@ -4430,6 +4545,9 @@ typedef union cvmx_pki_stylex_buf cvmx_pki_stylex_buf_t;
 
 /**
  * cvmx_pki_style#_tag_mask
+ *
+ * This register configures the PKI BE tag algorithm.
+ * It is indexed by final style, PKI_WQE_S[STYLE]<5:0>.
  */
 union cvmx_pki_stylex_tag_mask {
 	uint64_t u64;
@@ -4453,6 +4571,9 @@ typedef union cvmx_pki_stylex_tag_mask cvmx_pki_stylex_tag_mask_t;
 
 /**
  * cvmx_pki_style#_tag_sel
+ *
+ * This register configures the PKI BE tag algorithm.
+ * It is indexed by final style, PKI_WQE_S[STYLE]<5:0>.
  */
 union cvmx_pki_stylex_tag_sel {
 	uint64_t u64;
@@ -4466,7 +4587,7 @@ union cvmx_pki_stylex_tag_sel {
 	uint64_t tag_idx1                     : 3;  /**< Index for TAG_INC<1>. */
 	uint64_t reserved_3_7                 : 5;
 	uint64_t tag_idx0                     : 3;  /**< Index for TAG_INC<0>. This value is multipled by 4 to index into PKI_TAG_INC()_MASK.
-                                                         See WQE[TAG]. */
+                                                         See PKI_WQE_S[TAG]. */
 #else
 	uint64_t tag_idx0                     : 3;
 	uint64_t reserved_3_7                 : 5;
@@ -4487,14 +4608,18 @@ typedef union cvmx_pki_stylex_tag_sel cvmx_pki_stylex_tag_sel_t;
 
 /**
  * cvmx_pki_style#_wq2
+ *
+ * This register configures the PKI BE WQE generation.
+ * It is indexed by final style, PKI_WQE_S[STYLE]<5:0>.
  */
 union cvmx_pki_stylex_wq2 {
 	uint64_t u64;
 	struct cvmx_pki_stylex_wq2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t data                         : 64; /**< Data for WQ2<63:0>. This is ORed over any parser calculated WQ2<63:0> fields, and is used
-                                                         to emulate as if the parser set a WQ field such as WQE[PF1]. PKI_INST_HDR_S packets may
-                                                         also want to use this mode to set WQE[LCTY] to IP when PKI parsing IP is disabled. */
+	uint64_t data                         : 64; /**< Data for WQ2<63:0>. This is ORed over any parser calculated WQ2<63:0> fields,
+                                                         and is used to emulate as if the parser set a WQ field such as
+                                                         PKI_WQE_S[PF1]. PKI_INST_HDR_S packets may also want to use this mode to set
+                                                         PKI_WQE_S[LCTY] to IP when PKI parsing IP is disabled. */
 #else
 	uint64_t data                         : 64;
 #endif
@@ -4508,14 +4633,18 @@ typedef union cvmx_pki_stylex_wq2 cvmx_pki_stylex_wq2_t;
 
 /**
  * cvmx_pki_style#_wq4
+ *
+ * This register configures the PKI BE WQE generation.
+ * It is indexed by final style, PKI_WQE_S[STYLE]<5:0>.
  */
 union cvmx_pki_stylex_wq4 {
 	uint64_t u64;
 	struct cvmx_pki_stylex_wq4_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t data                         : 64; /**< Data for WQ4<63:0>. This is ORed over any parser calculated WQ4<63:0> fields, and is used
-                                                         to emulate as if the parser set a WQ pointer field. PKI_INST_HDR_S packets may also want
-                                                         to use this mode to set WQE[LCPTR] to the start of IP when PKI parsing IP is disabled. */
+	uint64_t data                         : 64; /**< Data for WQ4<63:0>. This is ORed over any parser calculated WQ4<63:0> fields,
+                                                         and is used to emulate as if the parser set a WQ pointer field. PKI_INST_HDR_S
+                                                         packets may also want to use this mode to set PKI_WQE_S[LCPTR] to the start of
+                                                         IP when PKI parsing IP is disabled. */
 #else
 	uint64_t data                         : 64;
 #endif
@@ -4538,23 +4667,22 @@ union cvmx_pki_tag_incx_ctl {
 	uint64_t ptr_sel                      : 4;  /**< Which pointer to use for the bitmask in PKI_TAG_INC()_MASK.
                                                          0 = Absolute from start of packet.
                                                          1-7 = Reserved.
-                                                         8 = Relative to start of WQE[LAPTR]. LAPTR must be valid (see WQE[LAPTR]) or mask is
-                                                         ignored.
-                                                         9 = Relative to start of WQE[LBPTR]. LBPTR must be valid (see WQE[LBPTR]) or mask is
-                                                         ignored.
-                                                         10 = Relative to start of WQE[LCPTR]. LCPTR must be valid (see WQE[LCPTR]) or mask is
-                                                         ignored.
-                                                         11 = Relative to start of WQE[LDPTR]. LDPTR must be valid (see WQE[LDPTR]) or mask is
-                                                         ignored.
-                                                         12 = Relative to start of WQE[LEPTR]. LEPTR must be valid (see WQE[LEPTR]) or mask is
-                                                         ignored.
-                                                         13 = Relative to start of WQE[LFPTR]. LFPTR must be valid (see WQE[LFPTR]) or mask is
-                                                         ignored.
-                                                         14 = Relative to start of WQE[LGPTR]. LGPTR must be valid (see WQE[LGPTR]) or mask is
-                                                         ignored.
-                                                         15 = Relative to start of WQE[VLPTR]. VLPTR must be valid (see WQE[VLPTR]) or mask is
-                                                         ignored.
-                                                         INTERNAL: Note excluding 0, the encoding matches the byte number to read from WQE WORD4. */
+                                                         8 = Relative to start of PKI_WQE_S[LAPTR]. LAPTR must be valid (see
+                                                         PKI_WQE_S[LAPTR]) or mask is ignored.
+                                                         9 = Relative to start of PKI_WQE_S[LBPTR]. LBPTR must be valid (see
+                                                         PKI_WQE_S[LBPTR]) or mask is ignored.
+                                                         10 = Relative to start of PKI_WQE_S[LCPTR]. LCPTR must be valid (see
+                                                         PKI_WQE_S[LCPTR]) or mask is ignored.
+                                                         11 = Relative to start of PKI_WQE_S[LDPTR]. LDPTR must be valid (see
+                                                         PKI_WQE_S[LDPTR]) or mask is ignored.
+                                                         12 = Relative to start of PKI_WQE_S[LEPTR]. LEPTR must be valid (see
+                                                         PKI_WQE_S[LEPTR]) or mask is ignored.
+                                                         13 = Relative to start of PKI_WQE_S[LFPTR]. LFPTR must be valid (see
+                                                         PKI_WQE_S[LFPTR]) or mask is ignored.
+                                                         14 = Relative to start of PKI_WQE_S[LGPTR]. LGPTR must be valid (see
+                                                         PKI_WQE_S[LGPTR]) or mask is ignored.
+                                                         15 = Relative to start of PKI_WQE_S[VLPTR]. VLPTR must be valid (see
+                                                         PKI_WQE_S[VLPTR]) or mask is ignored. */
 	uint64_t offset                       : 8;  /**< Offset for PKI_TAG_INC()_MASK. Number of bytes to add to the selected pointer before
                                                          applying the mask. */
 #else
@@ -4577,8 +4705,9 @@ union cvmx_pki_tag_incx_mask {
 	uint64_t u64;
 	struct cvmx_pki_tag_incx_mask_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t en                           : 64; /**< Include byte in mask-tag algorithm. Each EN bit corresponds to 64 consecutive bytes in the
-                                                         data stream, as controlled by PKI_TAG_INC()_CTL as described in WQE[TAG]. */
+	uint64_t en                           : 64; /**< Include byte in mask-tag algorithm. Each EN bit corresponds to 64 consecutive
+                                                         bytes in the data stream, as controlled by PKI_TAG_INC()_CTL as described in
+                                                         PKI_WQE_S[TAG]. */
 #else
 	uint64_t en                           : 64;
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-pki.h b/arch/mips/include/asm/octeon/cvmx-pki.h
index fd9bed96..effa997 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki.h
@@ -66,36 +66,34 @@ extern "C" {
 #endif
 
 /* PKI AURA and BPID count are equal to FPA AURA count */
-#define CVMX_PKI_NUM_AURA	(cvmx_fpa3_num_auras())
-#define CVMX_PKI_NUM_BPID	(cvmx_fpa3_num_auras())
-#define CVMX_PKI_NUM_SSO_GROUP	(cvmx_sso_num_xgrp())
-/* #define CVMX_PKI_NUM_CLUSTER_GROUP      (4) */
-#define CVMX_PKI_NUM_CLUSTER_GROUP_MAX	(4)
-#define CVMX_PKI_NUM_CLUSTER_GROUP	(cvmx_pki_num_cl_grp())
-/* #define CVMX_PKI_NUM_CLUSTER		(4) */
-#define CVMX_PKI_NUM_CLUSTER	 (cvmx_pki_num_clusters())
+#define CVMX_PKI_NUM_AURA              (cvmx_fpa3_num_auras())
+#define CVMX_PKI_NUM_BPID              (cvmx_fpa3_num_auras())
+#define CVMX_PKI_NUM_SSO_GROUP         (cvmx_sso_num_xgrp())
+#define CVMX_PKI_NUM_CLUSTER_GROUP_MAX 1
+#define CVMX_PKI_NUM_CLUSTER_GROUP     (cvmx_pki_num_cl_grp())
+#define CVMX_PKI_NUM_CLUSTER           (cvmx_pki_num_clusters())
 
 /* FIXME: Reduce some of these values, convert to routines XXX */
-#define CVMX_PKI_NUM_CHANNEL		(4096)
-#define CVMX_PKI_NUM_PKIND		(64)
-#define CVMX_PKI_NUM_INTERNAL_STYLE     (256)
-#define CVMX_PKI_NUM_FINAL_STYLE 	(64)
-#define CVMX_PKI_NUM_QPG_ENTRY		(2048)
-#define CVMX_PKI_NUM_MTAG_IDX	(32 / 4) /*32 registers grouped by 4*/
-#define CVMX_PKI_NUM_LTYPE		(32)
-#define CVMX_PKI_NUM_PCAM_BANK		(2)
-#define CVMX_PKI_NUM_PCAM_ENTRY		(192)
-#define CVMX_PKI_NUM_FRAME_CHECK	(2)
-#define CVMX_PKI_NUM_BELTYPE		(32)
-#define CVMX_PKI_MAX_FRAME_SIZE		(65535)
-#define CVMX_PKI_FIND_AVAL_ENTRY        (-1)
-#define CVMX_PKI_CLUSTER_ALL		(0xf)
+#define CVMX_PKI_NUM_CHANNEL        4096
+#define CVMX_PKI_NUM_PKIND          64
+#define CVMX_PKI_NUM_INTERNAL_STYLE 256
+#define CVMX_PKI_NUM_FINAL_STYLE    64
+#define CVMX_PKI_NUM_QPG_ENTRY      2048
+#define CVMX_PKI_NUM_MTAG_IDX       (32 / 4) /* 32 registers grouped by 4*/
+#define CVMX_PKI_NUM_LTYPE          32
+#define CVMX_PKI_NUM_PCAM_BANK      2
+#define CVMX_PKI_NUM_PCAM_ENTRY     192
+#define CVMX_PKI_NUM_FRAME_CHECK    2
+#define CVMX_PKI_NUM_BELTYPE        32
+#define CVMX_PKI_MAX_FRAME_SIZE     65535
+#define CVMX_PKI_FIND_AVAL_ENTRY    (-1)
+#define CVMX_PKI_CLUSTER_ALL        0xf
 
 #ifdef CVMX_SUPPORT_SEPARATE_CLUSTER_CONFIG
-#define CVMX_PKI_TOTAL_PCAM_ENTRY	((CVMX_PKI_NUM_CLUSTER) * (CVMX_PKI_NUM_PCAM_BANK) *\
-						(CVMX_PKI_NUM_PCAM_ENTRY))
+#define CVMX_PKI_TOTAL_PCAM_ENTRY \
+	((CVMX_PKI_NUM_CLUSTER) * (CVMX_PKI_NUM_PCAM_BANK) * (CVMX_PKI_NUM_PCAM_ENTRY))
 #else
-#define CVMX_PKI_TOTAL_PCAM_ENTRY	(CVMX_PKI_NUM_PCAM_BANK * CVMX_PKI_NUM_PCAM_ENTRY)
+#define CVMX_PKI_TOTAL_PCAM_ENTRY (CVMX_PKI_NUM_PCAM_BANK * CVMX_PKI_NUM_PCAM_ENTRY)
 #endif
 
 static inline unsigned cvmx_pki_num_clusters(void)
@@ -106,26 +104,28 @@ static inline unsigned cvmx_pki_num_clusters(void)
 }
 static inline unsigned cvmx_pki_num_cl_grp(void)
 {
-	if (OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX))
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX) ||
+		OCTEON_IS_MODEL(OCTEON_CNF75XX) ||
+		OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return 1;
-	return 4;
+	return 0;
 }
 
 enum cvmx_pki_pkind_parse_mode {
-	CVMX_PKI_PARSE_LA_TO_LG = 0,	/* parse LA(L2) to LG */
-	CVMX_PKI_PARSE_LB_TO_LG = 1,	/* parse LB(custom) to LG */
-	CVMX_PKI_PARSE_LC_TO_LG = 3,	/* parse LC(L3) to LG */
-	CVMX_PKI_PARSE_LG = 0x3f,	/* parse LG */
-	CVMX_PKI_PARSE_NOTHING = 0x7f	/* parse nothing */
+	CVMX_PKI_PARSE_LA_TO_LG = 0, /* Parse LA(L2) to LG */
+	CVMX_PKI_PARSE_LB_TO_LG = 1, /* Parse LB(custom) to LG */
+	CVMX_PKI_PARSE_LC_TO_LG = 3, /* Parse LC(L3) to LG */
+	CVMX_PKI_PARSE_LG       = 0x3f, /* Parse LG */
+	CVMX_PKI_PARSE_NOTHING  = 0x7f /* Parse nothing */
 };
 
 enum cvmx_pki_parse_mode_chg {
-	CVMX_PKI_PARSE_NO_CHG = 0x0,
+	CVMX_PKI_PARSE_NO_CHG     = 0x0,
 	CVMX_PKI_PARSE_SKIP_TO_LB = 0x1,
 	CVMX_PKI_PARSE_SKIP_TO_LC = 0x3,
 	CVMX_PKI_PARSE_SKIP_TO_LD = 0x7,
 	CVMX_PKI_PARSE_SKIP_TO_LG = 0x3f,
-	CVMX_PKI_PARSE_SKIP_ALL = 0x7f,
+	CVMX_PKI_PARSE_SKIP_ALL   = 0x7f,
 };
 
 enum cvmx_pki_l2_len_mode {
@@ -134,25 +134,28 @@ enum cvmx_pki_l2_len_mode {
 };
 
 enum cvmx_pki_cache_mode {
-	CVMX_PKI_OPC_MODE_STT = 0LL,	/* All blocks write through DRAM,*/
-	CVMX_PKI_OPC_MODE_STF = 1LL,	/* All blocks into L2 */
-	CVMX_PKI_OPC_MODE_STF1_STT = 2LL,	/* 1st block L2, rest DRAM */
-	CVMX_PKI_OPC_MODE_STF2_STT = 3LL	/* 1st, 2nd blocks L2, rest DRAM */
+	CVMX_PKI_OPC_MODE_STT      = 0LL, /* All blocks write through DRAM,*/
+	CVMX_PKI_OPC_MODE_STF      = 1LL, /* All blocks into L2 */
+	CVMX_PKI_OPC_MODE_STF1_STT = 2LL, /* 1st block L2, rest DRAM */
+	CVMX_PKI_OPC_MODE_STF2_STT = 3LL /* 1st, 2nd blocks L2, rest DRAM */
 };
 
 /**
  * Tag type definitions
  */
 enum cvmx_sso_tag_type {
-	CVMX_SSO_TAG_TYPE_ORDERED = 0L,	/**< Tag ordering is maintained */
-	CVMX_SSO_TAG_TYPE_ATOMIC = 1L,	/**< Tag ordering is maintained, and at most one PP has the tag */
-	CVMX_SSO_TAG_TYPE_UNTAGGED = 2L,	/**< The work queue entry from the order
-	- NEVER tag switch from NULL to NULL */
-	CVMX_SSO_TAG_TYPE_EMPTY = 3L/**< A tag switch to NULL, and there is no space reserved in POW
-			- NEVER tag switch to NULL_NULL
-			- NEVER tag switch from NULL_NULL
-			- NULL_NULL is entered at the beginning of time and on a deschedule.
-			- NULL_NULL can be exited by a new work request. A NULL_SWITCH load can also switch the state to NULL */
+	CVMX_SSO_TAG_TYPE_ORDERED  = 0L, /**< Tag ordering is maintained */
+	CVMX_SSO_TAG_TYPE_ATOMIC   = 1L,
+		/**< Tag ordering is maintained, and at most one PP has the tag */
+	CVMX_SSO_TAG_TYPE_UNTAGGED = 2L, /**< The work queue entry from the order
+		- NEVER tag switch from NULL to NULL */
+	CVMX_SSO_TAG_TYPE_EMPTY    = 3L
+		/**< A tag switch to NULL, and there is no space reserved in POW
+		- NEVER tag switch to NULL_NULL
+		- NEVER tag switch from NULL_NULL
+		- NULL_NULL is entered at the beginning of time and on a deschedule.
+		- NULL_NULL can be exited by a new work request.
+		A NULL_SWITCH load can also switch the state to NULL */
 };
 
 enum cvmx_pki_qpg_qos {
@@ -186,78 +189,85 @@ enum cvmx_pki_fpa_wait {
 	CVMX_PKI_WAIT_PKT
 };
 
-#define PKI_BELTYPE_E__NONE_M                              (0x0)
-#define PKI_BELTYPE_E__MISC_M                              (0x1)
-#define PKI_BELTYPE_E__IP4_M                               (0x2)
-#define PKI_BELTYPE_E__IP6_M                               (0x3)
-#define PKI_BELTYPE_E__TCP_M                               (0x4)
-#define PKI_BELTYPE_E__UDP_M                               (0x5)
-#define PKI_BELTYPE_E__SCTP_M                              (0x6)
-#define PKI_BELTYPE_E__SNAP_M                              (0x7)
-
-enum cvmx_pki_beltype { /* PKI_BELTYPE_E_t */
-	CVMX_PKI_BELTYPE_NONE	= PKI_BELTYPE_E__NONE_M,
-	CVMX_PKI_BELTYPE_MISC	= PKI_BELTYPE_E__MISC_M,
-	CVMX_PKI_BELTYPE_IP4	= PKI_BELTYPE_E__IP4_M,
-	CVMX_PKI_BELTYPE_IP6    = PKI_BELTYPE_E__IP6_M,
-	CVMX_PKI_BELTYPE_TCP    = PKI_BELTYPE_E__TCP_M,
-	CVMX_PKI_BELTYPE_UDP    = PKI_BELTYPE_E__UDP_M,
-	CVMX_PKI_BELTYPE_SCTP   = PKI_BELTYPE_E__SCTP_M,
-	CVMX_PKI_BELTYPE_SNAP   = PKI_BELTYPE_E__SNAP_M,
-	CVMX_PKI_BELTYPE_MAX   = CVMX_PKI_BELTYPE_SNAP
+#define PKI_BELTYPE_E__NONE_M 0x0
+#define PKI_BELTYPE_E__MISC_M 0x1
+#define PKI_BELTYPE_E__IP4_M  0x2
+#define PKI_BELTYPE_E__IP6_M  0x3
+#define PKI_BELTYPE_E__TCP_M  0x4
+#define PKI_BELTYPE_E__UDP_M  0x5
+#define PKI_BELTYPE_E__SCTP_M 0x6
+#define PKI_BELTYPE_E__SNAP_M 0x7
+
+/* PKI_BELTYPE_E_t */
+enum cvmx_pki_beltype {
+	CVMX_PKI_BELTYPE_NONE = PKI_BELTYPE_E__NONE_M,
+	CVMX_PKI_BELTYPE_MISC = PKI_BELTYPE_E__MISC_M,
+	CVMX_PKI_BELTYPE_IP4  = PKI_BELTYPE_E__IP4_M,
+	CVMX_PKI_BELTYPE_IP6  = PKI_BELTYPE_E__IP6_M,
+	CVMX_PKI_BELTYPE_TCP  = PKI_BELTYPE_E__TCP_M,
+	CVMX_PKI_BELTYPE_UDP  = PKI_BELTYPE_E__UDP_M,
+	CVMX_PKI_BELTYPE_SCTP = PKI_BELTYPE_E__SCTP_M,
+	CVMX_PKI_BELTYPE_SNAP = PKI_BELTYPE_E__SNAP_M,
+	CVMX_PKI_BELTYPE_MAX  = CVMX_PKI_BELTYPE_SNAP
 };
 
 struct cvmx_pki_frame_len {
-	uint16_t	maxlen;
-	uint16_t	minlen;
+	uint16_t maxlen;
+	uint16_t minlen;
 };
 
 struct cvmx_pki_tag_fields {
-	uint64_t layer_g_src:1;
-	uint64_t layer_f_src:1;
-	uint64_t layer_e_src:1;
-	uint64_t layer_d_src:1;
-	uint64_t layer_c_src:1;
-	uint64_t layer_b_src:1;
-	uint64_t layer_g_dst:1;
-	uint64_t layer_f_dst:1;
-	uint64_t layer_e_dst:1;
-	uint64_t layer_d_dst:1;
-	uint64_t layer_c_dst:1;
-	uint64_t layer_b_dst:1;
-	uint64_t input_port:1;
-	uint64_t mpls_label:1;
-	uint64_t first_vlan:1;
-	uint64_t second_vlan:1;
-	uint64_t ip_prot_nexthdr:1;
-	uint64_t tag_sync:1;
-	uint64_t tag_spi:1;
-	uint64_t tag_gtp:1;
-	uint64_t tag_vni:1;
+	uint64_t layer_g_src :1;
+	uint64_t layer_f_src :1;
+	uint64_t layer_e_src :1;
+	uint64_t layer_d_src :1;
+	uint64_t layer_c_src :1;
+	uint64_t layer_b_src :1;
+	uint64_t layer_g_dst :1;
+	uint64_t layer_f_dst :1;
+	uint64_t layer_e_dst :1;
+	uint64_t layer_d_dst :1;
+	uint64_t layer_c_dst :1;
+	uint64_t layer_b_dst :1;
+	uint64_t input_port :1;
+	uint64_t mpls_label :1;
+	uint64_t first_vlan :1;
+	uint64_t second_vlan :1;
+	uint64_t ip_prot_nexthdr :1;
+	uint64_t tag_sync :1;
+	uint64_t tag_spi :1;
+	uint64_t tag_gtp :1;
+	uint64_t tag_vni :1;
 };
 
 struct cvmx_pki_pkind_parse {
-	uint64_t mpls_en:1;	/**< Enable MPLS parsing.
-				0 = Any MPLS labels are ignored, but may be handled by custom Ethertype PCAM matchers.
-				1 = MPLS label stacks are parsed and skipped over. PKI_GBL_PEN[MPLS_PEN] must be set. */
-	uint64_t inst_hdr:1;	/**< INST header. When set, the eight-byte INST_HDR is present on all packets (except incoming
-				packets on the DPI ports). */
-	uint64_t lg_custom:1;	/**< Layer G Custom Match Enable.
-				0 = Disable custom LG header extraction
-				1 = Enable custom LG header extraction.*/
-	uint64_t fulc_en:1;	/**< Enable Fulcrum tag parsing.
-				0 = Any Fulcrum header is ignored.
-				1 = Fulcrum header is parsed.*/
-	uint64_t dsa_en:1;	/**< Enable DSA parsing. This field should not be set for DPI ports.
-				0 = Any DSA header is ignored.
-				1 = DSA is parsed. */
-	uint64_t hg2_en:1;	/**< Enable HiGig 2 parsing. This field should not be set for DPI ports.
-				0 = Any HiGig2 header is ignored.
-				1 = HiGig2 is parsed. PKI_GBL_PEN[HG_PEN] must be set. */
-	uint64_t hg_en:1;	/**< Enable HiGig parsing. This field should not be set for DPI ports.
-				0 = Any HiGig header is ignored.
-				1 = HiGig is parsed. PKI_GBL_PEN[HG_PEN] must be set.
-				At most one of FULC_EN, DSA_EN or HG_EN may be set. */
+	uint64_t mpls_en :1;	/**< Enable MPLS parsing.
+		0 = Any MPLS labels are ignored, but may be handled by custom
+		Ethertype PCAM matchers.
+		1 = MPLS label stacks are parsed and skipped over.
+		PKI_GBL_PEN[MPLS_PEN] must be set.*/
+	uint64_t inst_hdr :1; /**< INST header.
+		When set, the eight-byte INST_HDR is present on all packets
+		(except incoming packets on the DPI ports). */
+	uint64_t lg_custom :1; /**< Layer G Custom Match Enable.
+		0 = Disable custom LG header extraction
+		1 = Enable custom LG header extraction.*/
+	uint64_t fulc_en :1;	/**< Enable Fulcrum tag parsing.
+		0 = Any Fulcrum header is ignored.
+		1 = Fulcrum header is parsed.*/
+	uint64_t dsa_en :1; /**< Enable DSA parsing.
+		This field should not be set for DPI ports.
+		0 = Any DSA header is ignored.
+		1 = DSA is parsed. */
+	uint64_t hg2_en :1; /**< Enable HiGig 2 parsing.
+		This field should not be set for DPI ports.
+		0 = Any HiGig2 header is ignored.
+		1 = HiGig2 is parsed. PKI_GBL_PEN[HG_PEN] must be set. */
+	uint64_t hg_en :1; /**< Enable HiGig parsing.
+		This field should not be set for DPI ports.
+		0 = Any HiGig header is ignored.
+		1 = HiGig is parsed. PKI_GBL_PEN[HG_PEN] must be set.
+		At most one of FULC_EN, DSA_EN or HG_EN may be set. */
 };
 
 struct cvmx_pki_pool_config {
@@ -287,7 +297,7 @@ struct cvmx_pki_aura_config {
 
 struct cvmx_pki_cluster_grp_config {
 	int grp_num;
-	uint64_t cluster_mask; /* bit mask of cluster assigned to this cluster group */
+	uint64_t cluster_mask; /* Bit mask of cluster assigned to this cluster group */
 };
 
 struct cvmx_pki_sso_grp_config {
@@ -307,93 +317,103 @@ struct cvmx_pki_sso_grp_config {
  */
 struct cvmx_pki_style_parm {
 
-	bool ip6_udp_opt;	/**< IPv6/UDP checksum is optional. IPv4 allows an optional UDP checksum by sending the all-0s
-					patterns. IPv6 outlaws this and the spec says to always check UDP checksum.
-					0 = Spec compliant, do not allow optional code.
-					1 = Treat IPv6 as IPv4; */
-	bool lenerr_en;         /**< L2 length error check enable. Check if frame was received with L2 length error. */
-	bool maxerr_en;         /**< Max frame error check enable. */
-	bool minerr_en;	        /**< Min frame error check enable. */
-
-	uint8_t lenerr_eqpad;	/**< L2 length checks exact pad size.
-					0 = Length check uses greater then or equal comparison.
-					1 = Length check uses equal comparison.*/
-	uint8_t minmax_sel;	/**< Selects which PKI_FRM_LEN_CHK(0..1) register is used for this pkind for MINERR and MAXERR */
-	bool qpg_dis_grptag;	/**< Disable computing group using WQE[TAG]. 1 -- Disable 0 -- Enable */
-	bool fcs_strip;         /**< Strip L2 FCS bytes from packet, decrease WQE[LEN] by 4 bytes.*/
-	bool fcs_chk;           /**< FCS checking enabled.*/
-	bool rawdrp;		/**< Allow RAW packet drop
-					0 = Never drop packets with WQE[RAW] set.
-					1 = Allow the PKI to drop RAW packets based on PKI_AURA(0..1023)_CFG[ENA_RED/ENA_DROP]. */
-	bool force_drop;	/**< Force packet dropping.
-					0 = Drop packet based on PKI_AURA(0..1023)_CFG[ENA_RED/ENA_DROP].
-					1 = Always drop the packet. Overrides NODROP, RAWDRP. */
-	bool nodrop;            /**< Disable QoS packet drop.
-					0 = Allowed to drop packet based on PKI_AURA(0..1023)_CFG[ENA_RED/ENA_DROP].
-					1 = Never drop the packet. Overrides RAWDRP. */
-	bool qpg_dis_padd;	/**< Disable computing port adder by QPG algorithm. */
-	bool qpg_dis_grp;       /**< Disable computing group by QPG algorithm. */
-	bool qpg_dis_aura;      /**< Disable computing aura by QPG algorithm. */
-	uint16_t qpg_base;	/**< Base index into PKI_QPG_TBL(0..2047)*/
-	enum cvmx_pki_qpg_qos	qpg_qos;	/**< Algorithm to select QoS field in QPG calculation */
-	uint8_t			qpg_port_sh;	/**< MSB to take from port number in QPG calculation
-							0 = Exclude port number from QPG.
-							4 = Include port<3:0>.
-							8 = Include port<7:0>.*/
-	uint8_t			qpg_port_msb;	/**< Number of bits to shift port number in QPG */
-	uint8_t apad_nip;			/**< Value for WQE[APAD] when packet is not IP. */
-	uint8_t wqe_vs;				/**< Which VLAN to put into WQE[VLPTR] when VLAN stacking.
-							0 = Use the first (in network order) VLAN or DSA VID.
-							1 = Use the second (in network order) VLAN. */
-
-	enum cvmx_sso_tag_type	tag_type;	/**< SSO tag type to schedule to */
-	bool pkt_lend;				/**< Packet little-endian.write operations of packet data to L2C to be in LE */
-	uint8_t wqe_hsz;			/**< Work queue header size:
-							0x0 = WORD0..4, standard WQE_S. Note FIRST_SKIP may be set to not include WORD4 in memory.
-							0x1 = WORD0..5
-							0x2 = WORD0..6
-							0x3 = WORD0..7
-							else = Reserved */
-	uint8_t wqe_skip;			/**< in bytes, WQE start offset. The number of 128-byte cache lines to skip between the buffer
-							Pointer and WORD0 of the work-queue entry.*/
-	uint8_t first_skip;			/**< in bytes, The number of eight-byte words from the top of the first MBUF
-							that the PKI stores the next pointer.*/
-	uint8_t later_skip;			/**< in bytes, The number of eight-byte words from the top of any MBUF
-							that is not the first MBUF that PKI writes next-pointer to.*/
-	enum cvmx_pki_cache_mode cache_mode;;	/**< Select the style of write to the L2C.
-							0 = all packet data and next-buffer pointers are written through to memory.
-							1 = all packet data and next-buffer pointers are written into the cache.
-							2 = the first aligned cache block holding the WQE and/or front packet data are written to
-							    the L2 cache. All remaining cache blocks are not written to the L2 cache.
-							3 = the first two aligned cache blocks holding the WQE and front packet data are written
-							    to the L2 cache. All remaining cache blocks are not written to the L2 cache. */
-	uint8_t dis_wq_dat;			/**< Separate first data buffer from the work queue entry.
-							0 = The packet link pointer will be at word [FIRST_SKIP] immediately followed by packet
-							    data, in the same buffer as the work queue entry.
-							1 = The packet link pointer will be at word [FIRST_SKIP] in a new buffer separate from the
-							    work queue entry.*/
-	uint64_t mbuff_size;			/**< The number of eight-byte words to store into a buffer. This must be even, in the range of
-						     32 to 4096. This must be less than or equal to the maximum size of every free page in
-						     every FPA pool this style may use. */
-	bool len_lg;				/**< Check length of Layer G. */
-	bool len_lf;				/**< Check length of Layer F. */
-	bool len_le;				/**< Check length of Layer E. */
-	bool len_ld;				/**< Check length of Layer D. */
-	bool len_lc;				/**< Check length of Layer C. */
-	bool len_lb;				/**< Check length of Layer B. */
-	bool csum_lg;				/**< Compute checksum on Layer G. */
-	bool csum_lf;				/**< Compute checksum on Layer F. */
-	bool csum_le;				/**< Compute checksum on Layer E. */
-	bool csum_ld;				/**< Compute checksum on Layer D. */
-	bool csum_lc;				/**< Compute checksum on Layer C. */
-	bool csum_lb;				/**< Compute checksum on Layer B. */
+	bool ip6_udp_opt; /**< IPv6/UDP checksum is optional.
+		IPv4 allows an optional UDP checksum by sending the all-0s patterns.
+		IPv6 outlaws this and the spec says to always check UDP checksum.
+		0 = Spec compliant, do not allow optional code.
+		1 = Treat IPv6 as IPv4; */
+	bool lenerr_en; /**< L2 length error check enable.
+		Check if frame was received with L2 length error. */
+	bool maxerr_en; /**< Max frame error check enable. */
+	bool minerr_en; /**< Min frame error check enable. */
+	uint8_t lenerr_eqpad; /**< L2 length checks exact pad size.
+		0 = Length check uses greater then or equal comparison.
+		1 = Length check uses equal comparison.*/
+	uint8_t minmax_sel;	/**< Selects which PKI_FRM_LEN_CHK(0..1) register is used
+		for this pkind for MINERR and MAXERR */
+	bool qpg_dis_grptag; /**< Disable computing group using WQE[TAG].
+		1 -- Disable 0 -- Enable */
+	bool fcs_strip; /**< Strip L2 FCS bytes from packet, decrease WQE[LEN] by 4 bytes.*/
+	bool fcs_chk; /**< FCS checking enabled.*/
+	bool rawdrp; /**< Allow RAW packet drop
+		0 = Never drop packets with WQE[RAW] set.
+		1 = Allow the PKI to drop RAW packets based on
+		PKI_AURA(0..1023)_CFG[ENA_RED/ENA_DROP]. */
+	bool force_drop; /**< Force packet dropping.
+		0 = Drop packet based on PKI_AURA(0..1023)_CFG[ENA_RED/ENA_DROP].
+		1 = Always drop the packet. Overrides NODROP, RAWDRP. */
+	bool nodrop; /**< Disable QoS packet drop.
+		0 = Allowed to drop packet based on PKI_AURA(0..1023)_CFG[ENA_RED/ENA_DROP].
+		1 = Never drop the packet. Overrides RAWDRP. */
+	bool qpg_dis_padd; /**< Disable computing port adder by QPG algorithm. */
+	bool qpg_dis_grp; /**< Disable computing group by QPG algorithm. */
+	bool qpg_dis_aura; /**< Disable computing aura by QPG algorithm. */
+	uint16_t qpg_base; /**< Base index into PKI_QPG_TBL(0..2047)*/
+	enum cvmx_pki_qpg_qos qpg_qos; /**< Algorithm to select QoS field in QPG calculation */
+	uint8_t qpg_port_sh; /**< MSB to take from port number in QPG calculation
+		0 = Exclude port number from QPG.
+		4 = Include port<3:0>.
+		8 = Include port<7:0>.*/
+	uint8_t qpg_port_msb; /**< Number of bits to shift port number in QPG */
+	uint8_t apad_nip; /**< Value for WQE[APAD] when packet is not IP. */
+	uint8_t wqe_vs; /**< Which VLAN to put into WQE[VLPTR] when VLAN stacking.
+		0 = Use the first (in network order) VLAN or DSA VID.
+		1 = Use the second (in network order) VLAN. */
+	enum cvmx_sso_tag_type tag_type; /**< SSO tag type to schedule to */
+	bool pkt_lend; /**< Packet little-endian.write operations of packet data
+		to L2C to be in LE */
+	uint8_t wqe_hsz; /**< Work queue header size:
+		0x0 = WORD0..4, standard WQE_S.
+		Note FIRST_SKIP may be set to not include WORD4 in memory.
+		0x1 = WORD0..5
+		0x2 = WORD0..6
+		0x3 = WORD0..7
+		else = Reserved */
+	uint8_t wqe_skip; /**< in bytes, WQE start offset.
+		The number of 128-byte cache lines to skip between the buffer
+		Pointer and WORD0 of the work-queue entry.*/
+	uint8_t first_skip; /**< The number of eight-byte words from the top
+		of the first MBUF, that the PKI stores the next pointer.*/
+	uint8_t later_skip; /**< The number of eight-byte words from the top
+		of any MBUF, that is not the first MBUF that PKI writes
+		next-pointer to.*/
+	enum cvmx_pki_cache_mode cache_mode; /**< Select the style of write to the L2C.
+		0 = all packet data and next-buffer pointers are written through to memory.
+		1 = all packet data and next-buffer pointers are written into the cache.
+		2 = the first aligned cache block holding the WQE and/or front packet data
+		are written to the L2 cache. All remaining cache blocks are not written to
+		the L2 cache.
+		3 = the first two aligned cache blocks holding the WQE and front packet data
+		are written to the L2 cache. All remaining cache blocks are not written to
+		the L2 cache. */
+	uint8_t dis_wq_dat; /**< Separate first data buffer from the work queue entry.
+		0 = The packet link pointer will be at word [FIRST_SKIP] immediately followed
+		by packet data, in the same buffer as the work queue entry.
+		1 = The packet link pointer will be at word [FIRST_SKIP] in a new buffer
+		separate from the work queue entry.*/
+	uint64_t mbuff_size; /**< The number of eight-byte words to store into a buffer.
+		This must be even, in the range of 32 to 4096 and this must be
+		less than or equal to the maximum size of every free page in every FPA pool
+		this style may use. */
+	bool len_lg; /**< Check length of Layer G. */
+	bool len_lf; /**< Check length of Layer F. */
+	bool len_le; /**< Check length of Layer E. */
+	bool len_ld; /**< Check length of Layer D. */
+	bool len_lc; /**< Check length of Layer C. */
+	bool len_lb; /**< Check length of Layer B. */
+	bool csum_lg; /**< Compute checksum on Layer G. */
+	bool csum_lf; /**< Compute checksum on Layer F. */
+	bool csum_le; /**< Compute checksum on Layer E. */
+	bool csum_ld; /**< Compute checksum on Layer D. */
+	bool csum_lc; /**< Compute checksum on Layer C. */
+	bool csum_lb; /**< Compute checksum on Layer B. */
 };
 
-/* This is per style structure for configuring port's tag configuration, it is kind of of profile
-   which can be assigned to any port. If multiple ports are assigned same style be aware
-   that modiying that style will modify the respective parameters for all the ports which
-   are using this style */
-
+/* This is per style structure for configuring port's tag configuration,
+ * it is kind of of profile which can be assigned to any port.
+ * If multiple ports are assigned same style be aware that modiying that style
+ * will modify the respective parameters for all the ports which are
+ * using this style */
 enum cvmx_pki_mtag_ptrsel {
 	CVMX_PKI_MTAG_PTRSEL_SOP = 0,
 	CVMX_PKI_MTAG_PTRSEL_LA = 8,
@@ -410,7 +430,8 @@ struct cvmx_pki_mask_tag {
 	bool enable;
 	int base; /* CVMX_PKI_MTAG_PTRSEL_XXX */
 	int offset; /* Offset from base. */
-	uint64_t val; /* Bitmask: 1 = enable, 0 = disabled for each byte in the 64-byte array.*/
+	uint64_t val; /* Bitmask:
+		1 = enable, 0 = disabled for each byte in the 64-byte array.*/
 };
 
 struct cvmx_pki_style_tag_cfg {
@@ -419,244 +440,261 @@ struct cvmx_pki_style_tag_cfg {
 };
 
 struct cvmx_pki_style_config {
-	struct cvmx_pki_style_parm parm_cfg;		/**< General parameter configuration. */
-	struct cvmx_pki_style_tag_cfg  tag_cfg;		/**< Tag parameter configuration. */
+	struct cvmx_pki_style_parm parm_cfg; /**< General parameter configuration. */
+	struct cvmx_pki_style_tag_cfg  tag_cfg; /**< Tag parameter configuration. */
 };
 
 struct cvmx_pki_pkind_config {
-	uint8_t cluster_grp;		/**< cluster group that will service traffic on this pkind */
-	bool fcs_pres;			/**< FCS present.
-					0 = FCS not present. FCS may not be checked nor stripped.
-					1 = FCS present; the last four bytes of the packet are part of the FCS and may not be
-					considered part of a IP, TCP or other header for length error checks.*/
+	uint8_t cluster_grp; /**< Cluster group that will service traffic on this pkind */
+	bool fcs_pres; /**< FCS present.
+		0 = FCS not present. FCS may not be checked nor stripped.
+		1 = FCS present; the last four bytes of the packet are part of the FCS
+		and may not be considered part of a IP, TCP or other header for length
+		error checks.*/
 	struct cvmx_pki_pkind_parse parse_en;
-	enum cvmx_pki_pkind_parse_mode	initial_parse_mode;
+	enum cvmx_pki_pkind_parse_mode initial_parse_mode;
 	uint8_t fcs_skip;
-	uint8_t inst_skip;              /**< Skip amount from front of packet to first byte covered by FCS start. The
-	                                skip must be even. If PTP_MODE, the 8-byte timestamp is prepended to
-	                                the packet, and FCS_SKIP must be at least 8.*/
-	int initial_style;             /**< Skip amount from front of packet to begin parsing at. If
-	                                PKI_CL(0..3)_PKIND(0..63)_CFG[INST_HDR] is set, points at the first
-	                                byte of the instruction header. If INST_HDR is clear, points at the first
-	                                byte to begin parsing at. The skip must be even. If PTP_MODE, the 8-
-	                                byte timestamp is prepended to the packet, and INST_SKIP must be at
-	                                least 8. */
-	bool custom_l2_hdr;		/**< Valid.custom L2 hesder extraction
-					0 = Disable custom L2 header extraction.
-					1 = Enable custom L2 header extraction.
-					PKI_GBL_PEN[CLG_PEN] must be set. */
-	uint8_t l2_scan_offset;		/**< Scan offset for custom L2 header.
-					Pointer to first byte of 32-bit custom extraction header, as absolute number
-					of bytes from beginning of packet. If PTP_MODE, the 8-byte timestamp is prepended to the
-					packet, and must be included in counting offset bytes. */
-	uint64_t lg_scan_offset;	/**< Scan offset for custom lg header.
-					Pointer to first byte of 32-bit custom extraction header, as relative number
-					of bytes from WQE[LFPTR]. */
+	uint8_t inst_skip; /**< Skip amount from front of packet to first byte covered
+		by FCS start. The skip must be even. If PTP_MODE, the 8-byte timestamp is
+		prepended to the packet, and FCS_SKIP must be at least 8.*/
+	int initial_style; /**< Skip amount from front of packet to begin parsing at.
+		If PKI_CL(0..3)_PKIND(0..63)_CFG[INST_HDR] is set, points at the first
+		byte of the instruction header. If INST_HDR is clear, points at the first
+		byte to begin parsing at. The skip must be even. If PTP_MODE, the 8-byte
+		timestamp is prepended to the packet, and INST_SKIP must be at least 8. */
+	bool custom_l2_hdr; /**< Valid.custom L2 hesder extraction
+		0 = Disable custom L2 header extraction.
+		1 = Enable custom L2 header extraction.
+		PKI_GBL_PEN[CLG_PEN] must be set. */
+	uint8_t l2_scan_offset; /**< Scan offset for custom L2 header.
+		Pointer to first byte of 32-bit custom extraction header, as absolute
+		number of bytes from beginning of packet. If PTP_MODE, the 8-byte timestamp
+		is prepended to the packet, and must be included in counting offset bytes. */
+	uint64_t lg_scan_offset; /**< Scan offset for custom lg header.
+		Pointer to first byte of 32-bit custom extraction header, as relative number
+		of bytes from WQE[LFPTR]. */
 };
 
 struct cvmx_pki_port_config {
-	struct cvmx_pki_pkind_config pkind_cfg;		/**< Parameters can be configure per pkind */
-	struct cvmx_pki_style_config style_cfg;		/**< Parameters are configured per style, style is a profile
-							which can be applied to multiple ports which have same configuration
-							and packet processing */
+	struct cvmx_pki_pkind_config pkind_cfg; /**< Parameters can be configure per pkind */
+	struct cvmx_pki_style_config style_cfg; /**< Parameters are configured per style,
+		style is a profile, which can be applied to multiple ports which have same
+		configuration and packet processing */
 };
 
 struct cvmx_pki_global_parse {
-	uint64_t virt_pen:1;	/**< Virtualization parsing enable.*/
-	uint64_t clg_pen:1;	/**< Custom LG parsing enable. */
-	uint64_t cl2_pen:1;	/**< Custom L2 parsing enable.*/
-	uint64_t l4_pen:1;	/**< L4 parsing enable.*/
-	uint64_t il3_pen:1;	/**< L3 inner parsing enable. Must be zero if L3_PEN is zero. */
-	uint64_t l3_pen:1;	/**< L3 parsing enable.*/
-	uint64_t mpls_pen:1;	/**< MPLS parsing enable.*/
-	uint64_t fulc_pen:1;	/**< Fulcrum parsing enable.*/
-	uint64_t dsa_pen:1;	/**< DSA parsing enable. Must be zero if HG_PEN is set.*/
-	uint64_t hg_pen:1;	/**< HiGig parsing enable. Must be zero if DSA_PEN is set.*/
+	uint64_t virt_pen :1; /**< Virtualization parsing enable.*/
+	uint64_t clg_pen :1;	/**< Custom LG parsing enable. */
+	uint64_t cl2_pen :1;	/**< Custom L2 parsing enable.*/
+	uint64_t l4_pen :1; /**< L4 parsing enable.*/
+	uint64_t il3_pen :1; /**< L3 inner parsing enable. Must be zero if L3_PEN is zero. */
+	uint64_t l3_pen :1; /**< L3 parsing enable.*/
+	uint64_t mpls_pen :1; /**< MPLS parsing enable.*/
+	uint64_t fulc_pen :1; /**< Fulcrum parsing enable.*/
+	uint64_t dsa_pen :1; /**< DSA parsing enable. Must be zero if HG_PEN is set.*/
+	uint64_t hg_pen :1; /**< HiGig parsing enable. Must be zero if DSA_PEN is set.*/
 };
 
 struct cvmx_pki_tag_sec {
-	uint16_t dst6;				/**< Secret for the destination tuple IPv6 tag CRC calculation. Typically identical to SRC6 to						insure tagging is symmetric between source/destination flows. Typically different from DST
-						for maximum security. */
-	uint16_t src6;				/**< Secret for the source tuple IPv6 tag CRC calculation. Typically different from SRC for
-						maximum security. */
-	uint16_t dst;				/**< Secret for the destination tuple tag CRC calculation. Typically identical to DST6 to
-						insure tagging is symmetric between source/destination flows. */
-	uint16_t src;				/**< Secret for the source tuple tag CRC calculation. */
+	uint16_t dst6; /**< Secret for the destination tuple IPv6 tag CRC calculation.
+		Typically identical to SRC6 to insure tagging is symmetric between
+		source/destination flows. Typically different from DST for maximum security. */
+	uint16_t src6; /**< Secret for the source tuple IPv6 tag CRC calculation.
+		Typically different from SRC for maximum security. */
+	uint16_t dst; /**< Secret for the destination tuple tag CRC calculation.
+		Typically identical to DST6 to insure tagging is symmetric between
+		source/destination flows. */
+	uint16_t src; /**< Secret for the source tuple tag CRC calculation. */
 };
 
 struct cvmx_pki_global_config {
-	uint64_t cluster_mask[CVMX_PKI_NUM_CLUSTER_GROUP_MAX];/**< Mask of clusters associated with that cluster group,
-								there are 4 cluster groups and 4 clusters which can be assigned
-								to cluster groups */
-	enum cvmx_pki_stats_mode stat_mode;			/**< The PKI_STAT*_X registers can be indexed either by pkind or final style.
-								(Does not apply to the PKI_STAT_INB* registers.)
-								0 = X represents the packet's pkind
-								1 = X represents the low 6-bits of packet's final style */
-	enum cvmx_pki_fpa_wait fpa_wait;			/**< Policy when FPA runs out of buffers:
-								0 = Drop the remainder of the packet requesting the buffer, and
-								set WQE[OPCODE] to RE_MEMOUT.
-								1 = Wait until buffers become available, only dropping packets if
-								buffering ahead of PKI fills. This may lead to head-of-line
-								blocking of packets on other Auras */
-	struct cvmx_pki_global_parse gbl_pen;			/**< Controls Global parsing options for chip */
-	struct cvmx_pki_tag_sec tag_secret;			/**< Secret value for src/dst tag tuple to reduce cache collision attacks */
-	struct cvmx_pki_frame_len frm_len[CVMX_PKI_NUM_FRAME_CHECK]; /**< values for max and min frame length to check against,2 combination */
-	enum cvmx_pki_beltype ltype_map[CVMX_PKI_NUM_BELTYPE];	/**< Map of which protocol maps to what layer */
+	uint64_t cluster_mask[CVMX_PKI_NUM_CLUSTER_GROUP_MAX]; /**< Mask of clusters
+		associated with that cluster group, there are 4 cluster groups and 4 clusters
+		which can be assigned to cluster groups */
+	enum cvmx_pki_stats_mode stat_mode;	/**< The PKI_STAT*_X registers can be indexed
+		either by pkind or final style.
+		(Does not apply to the PKI_STAT_INB* registers.)
+		0 = X represents the packet's pkind
+		1 = X represents the low 6-bits of packet's final style */
+	enum cvmx_pki_fpa_wait fpa_wait; /**< Policy when FPA runs out of buffers:
+		0 = Drop the remainder of the packet requesting the buffer, and
+		set WQE[OPCODE] to RE_MEMOUT.
+		1 = Wait until buffers become available, only dropping packets if
+		buffering ahead of PKI fills. This may lead to head-of-line
+		blocking of packets on other Auras */
+	struct cvmx_pki_global_parse gbl_pen; /**< Controls Global parsing options for chip */
+	struct cvmx_pki_tag_sec tag_secret; /**< Secret value for src/dst tag tuple to
+		reduce cache collision attacks */
+	struct cvmx_pki_frame_len frm_len[CVMX_PKI_NUM_FRAME_CHECK]; /**< Values for max
+		and min frame length to check against,2 combination */
+	enum cvmx_pki_beltype ltype_map[CVMX_PKI_NUM_BELTYPE]; /**< Map of which protocol
+		maps to what layer */
 	/* struct cvmx_pki_tag_ctl  tag_ctl[32]; */
 	/* cvmx_pki_tag_incx_mask_t tag_mask[32]; */
 	int pki_enable;
 };
 
-#define CVMX_PKI_PCAM_TERM_E_NONE_M                            (0x0)
-#define CVMX_PKI_PCAM_TERM_E_L2_CUSTOM_M                       (0x2)
-#define CVMX_PKI_PCAM_TERM_E_HIGIG_M                           (0x5)
-#define CVMX_PKI_PCAM_TERM_E_DMACH_M                           (0xA)
-#define CVMX_PKI_PCAM_TERM_E_DMACL_M                           (0xB)
-#define CVMX_PKI_PCAM_TERM_E_GLORT_M                           (0x12)
-#define CVMX_PKI_PCAM_TERM_E_DSA_M                             (0x13)
-#define CVMX_PKI_PCAM_TERM_E_ETHTYPE0_M                        (0x18)
-#define CVMX_PKI_PCAM_TERM_E_ETHTYPE1_M                        (0x19)
-#define CVMX_PKI_PCAM_TERM_E_ETHTYPE2_M                        (0x1A)
-#define CVMX_PKI_PCAM_TERM_E_ETHTYPE3_M                        (0x1B)
-#define CVMX_PKI_PCAM_TERM_E_MPLS0_M                           (0x1E)
-#define CVMX_PKI_PCAM_TERM_E_L3_FLAGS_M                        (0x23)
-#define CVMX_PKI_PCAM_TERM_E_LD_VNI_M                          (0x28)
-#define CVMX_PKI_PCAM_TERM_E_IL3_FLAGS_M                       (0x2B)
-#define CVMX_PKI_PCAM_TERM_E_L4_PORT_M                         (0x30)
-#define CVMX_PKI_PCAM_TERM_E_LG_CUSTOM_M                       (0x39)
+#define CVMX_PKI_PCAM_TERM_E_NONE_M      0x0
+#define CVMX_PKI_PCAM_TERM_E_L2_CUSTOM_M 0x2
+#define CVMX_PKI_PCAM_TERM_E_HIGIG_M     0x5
+#define CVMX_PKI_PCAM_TERM_E_DMACH_M     0xA
+#define CVMX_PKI_PCAM_TERM_E_DMACL_M     0xB
+#define CVMX_PKI_PCAM_TERM_E_GLORT_M     0x12
+#define CVMX_PKI_PCAM_TERM_E_DSA_M       0x13
+#define CVMX_PKI_PCAM_TERM_E_ETHTYPE0_M  0x18
+#define CVMX_PKI_PCAM_TERM_E_ETHTYPE1_M  0x19
+#define CVMX_PKI_PCAM_TERM_E_ETHTYPE2_M  0x1A
+#define CVMX_PKI_PCAM_TERM_E_ETHTYPE3_M  0x1B
+#define CVMX_PKI_PCAM_TERM_E_MPLS0_M     0x1E
+#define CVMX_PKI_PCAM_TERM_E_L3_FLAGS_M  0x23
+#define CVMX_PKI_PCAM_TERM_E_LD_VNI_M    0x28
+#define CVMX_PKI_PCAM_TERM_E_IL3_FLAGS_M 0x2B
+#define CVMX_PKI_PCAM_TERM_E_L4_PORT_M   0x30
+#define CVMX_PKI_PCAM_TERM_E_LG_CUSTOM_M 0x39
 
 enum cvmx_pki_term {
-	CVMX_PKI_PCAM_TERM_NONE                    = CVMX_PKI_PCAM_TERM_E_NONE_M,
-	CVMX_PKI_PCAM_TERM_L2_CUSTOM               = CVMX_PKI_PCAM_TERM_E_L2_CUSTOM_M,
-	CVMX_PKI_PCAM_TERM_HIGIG                   = CVMX_PKI_PCAM_TERM_E_HIGIG_M,
-	CVMX_PKI_PCAM_TERM_DMACH                   = CVMX_PKI_PCAM_TERM_E_DMACH_M,
-	CVMX_PKI_PCAM_TERM_DMACL                   = CVMX_PKI_PCAM_TERM_E_DMACL_M,
-	CVMX_PKI_PCAM_TERM_GLORT                   = CVMX_PKI_PCAM_TERM_E_GLORT_M,
-	CVMX_PKI_PCAM_TERM_DSA                     = CVMX_PKI_PCAM_TERM_E_DSA_M,
-	CVMX_PKI_PCAM_TERM_ETHTYPE0                = CVMX_PKI_PCAM_TERM_E_ETHTYPE0_M,
-	CVMX_PKI_PCAM_TERM_ETHTYPE1                = CVMX_PKI_PCAM_TERM_E_ETHTYPE1_M,
-	CVMX_PKI_PCAM_TERM_ETHTYPE2                = CVMX_PKI_PCAM_TERM_E_ETHTYPE2_M,
-	CVMX_PKI_PCAM_TERM_ETHTYPE3                = CVMX_PKI_PCAM_TERM_E_ETHTYPE3_M,
-	CVMX_PKI_PCAM_TERM_MPLS0                   = CVMX_PKI_PCAM_TERM_E_MPLS0_M,
-	CVMX_PKI_PCAM_TERM_L3_FLAGS                = CVMX_PKI_PCAM_TERM_E_L3_FLAGS_M,
-	CVMX_PKI_PCAM_TERM_LD_VNI                  = CVMX_PKI_PCAM_TERM_E_LD_VNI_M,
-	CVMX_PKI_PCAM_TERM_IL3_FLAGS               = CVMX_PKI_PCAM_TERM_E_IL3_FLAGS_M,
-	CVMX_PKI_PCAM_TERM_L4_PORT                 = CVMX_PKI_PCAM_TERM_E_L4_PORT_M,
-	CVMX_PKI_PCAM_TERM_LG_CUSTOM               = CVMX_PKI_PCAM_TERM_E_LG_CUSTOM_M
+	CVMX_PKI_PCAM_TERM_NONE      = CVMX_PKI_PCAM_TERM_E_NONE_M,
+	CVMX_PKI_PCAM_TERM_L2_CUSTOM = CVMX_PKI_PCAM_TERM_E_L2_CUSTOM_M,
+	CVMX_PKI_PCAM_TERM_HIGIG     = CVMX_PKI_PCAM_TERM_E_HIGIG_M,
+	CVMX_PKI_PCAM_TERM_DMACH     = CVMX_PKI_PCAM_TERM_E_DMACH_M,
+	CVMX_PKI_PCAM_TERM_DMACL     = CVMX_PKI_PCAM_TERM_E_DMACL_M,
+	CVMX_PKI_PCAM_TERM_GLORT     = CVMX_PKI_PCAM_TERM_E_GLORT_M,
+	CVMX_PKI_PCAM_TERM_DSA       = CVMX_PKI_PCAM_TERM_E_DSA_M,
+	CVMX_PKI_PCAM_TERM_ETHTYPE0  = CVMX_PKI_PCAM_TERM_E_ETHTYPE0_M,
+	CVMX_PKI_PCAM_TERM_ETHTYPE1  = CVMX_PKI_PCAM_TERM_E_ETHTYPE1_M,
+	CVMX_PKI_PCAM_TERM_ETHTYPE2  = CVMX_PKI_PCAM_TERM_E_ETHTYPE2_M,
+	CVMX_PKI_PCAM_TERM_ETHTYPE3  = CVMX_PKI_PCAM_TERM_E_ETHTYPE3_M,
+	CVMX_PKI_PCAM_TERM_MPLS0     = CVMX_PKI_PCAM_TERM_E_MPLS0_M,
+	CVMX_PKI_PCAM_TERM_L3_FLAGS  = CVMX_PKI_PCAM_TERM_E_L3_FLAGS_M,
+	CVMX_PKI_PCAM_TERM_LD_VNI    = CVMX_PKI_PCAM_TERM_E_LD_VNI_M,
+	CVMX_PKI_PCAM_TERM_IL3_FLAGS = CVMX_PKI_PCAM_TERM_E_IL3_FLAGS_M,
+	CVMX_PKI_PCAM_TERM_L4_PORT   = CVMX_PKI_PCAM_TERM_E_L4_PORT_M,
+	CVMX_PKI_PCAM_TERM_LG_CUSTOM = CVMX_PKI_PCAM_TERM_E_LG_CUSTOM_M
 };
 
-#define CVMX_PKI_DMACH_SHIFT	(32)
-#define CVMX_PKI_DMACH_MASK	cvmx_build_mask(16)
-#define CVMX_PKI_DMACL_MASK	CVMX_PKI_DATA_MASK_32
-#define CVMX_PKI_DATA_MASK_32	cvmx_build_mask(32)
-#define CVMX_PKI_DATA_MASK_16	cvmx_build_mask(16)
-#define CVMX_PKI_DMAC_MATCH_EXACT   cvmx_build_mask(48)
+#define CVMX_PKI_DMACH_SHIFT	  32
+#define CVMX_PKI_DMACH_MASK	      cvmx_build_mask(16)
+#define CVMX_PKI_DMACL_MASK	      CVMX_PKI_DATA_MASK_32
+#define CVMX_PKI_DATA_MASK_32	  cvmx_build_mask(32)
+#define CVMX_PKI_DATA_MASK_16	  cvmx_build_mask(16)
+#define CVMX_PKI_DMAC_MATCH_EXACT cvmx_build_mask(48)
 
 struct cvmx_pki_pcam_input {
-	uint64_t		style;
-	uint64_t		style_mask; /* bits: 1-match, 0-dont care */
-	enum cvmx_pki_term	field;
-	uint32_t		field_mask; /* bits: 1-match, 0-dont care */
-	uint64_t		data;
-	uint64_t		data_mask; /* bits: 1-match, 0-dont care */
+	uint64_t style;
+	uint64_t style_mask; /* bits: 1-match, 0-dont care */
+	enum cvmx_pki_term field;
+	uint32_t field_mask; /* bits: 1-match, 0-dont care */
+	uint64_t data;
+	uint64_t data_mask; /* bits: 1-match, 0-dont care */
 };
 
 struct cvmx_pki_pcam_action {
-	enum cvmx_pki_parse_mode_chg	parse_mode_chg;
-	enum cvmx_pki_layer_type	layer_type_set;
-	int				style_add;
-	int				parse_flag_set;
-	int				pointer_advance;
+	enum cvmx_pki_parse_mode_chg parse_mode_chg;
+	enum cvmx_pki_layer_type layer_type_set;
+	int style_add;
+	int parse_flag_set;
+	int pointer_advance;
 };
 
 struct cvmx_pki_pcam_config {
-	int				in_use;
-	int				entry_num;
-	uint64_t			cluster_mask;
-	struct cvmx_pki_pcam_input	pcam_input;
-	struct cvmx_pki_pcam_action	pcam_action;
+	int in_use;
+	int entry_num;
+	uint64_t cluster_mask;
+	struct cvmx_pki_pcam_input pcam_input;
+	struct cvmx_pki_pcam_action pcam_action;
 };
 
-
 /**
  * Status statistics for a port
  */
 struct cvmx_pki_port_stats {
-	uint64_t dropped_octets;	/**< Inbound octets marked to be dropped by the IPD */
-	uint64_t dropped_packets;	/**< Inbound packets marked to be dropped by the IPD */
-	uint64_t pci_raw_packets;	/**< RAW PCI Packets received by PKI per port */
-	uint64_t octets;		/**< Number of octets processed by PKI */
-	uint64_t packets;		/**< Number of packets processed by PKI */
+	uint64_t dropped_octets; /**< Inbound octets marked to be dropped by the IPD */
+	uint64_t dropped_packets; /**< Inbound packets marked to be dropped by the IPD */
+	uint64_t pci_raw_packets; /**< RAW PCI Packets received by PKI per port */
+	uint64_t octets; /**< Number of octets processed by PKI */
+	uint64_t packets; /**< Number of packets processed by PKI */
 	uint64_t multicast_packets;	/**< Number of indentified L2 multicast packets.
-					Does not include broadcast packets.
-					Only includes packets whose parse mode is
-					SKIP_TO_L2 */
+		Does not include broadcast packets.
+		Only includes packets whose parse mode is SKIP_TO_L2 */
 	uint64_t broadcast_packets;	/**< Number of indentified L2 broadcast packets.
-					Does not include multicast packets.
-					Only includes packets whose parse mode is
-					SKIP_TO_L2 */
-	uint64_t len_64_packets;	/**< Number of 64B packets */
-	uint64_t len_65_127_packets;	/**< Number of 65-127B packets */
-	uint64_t len_128_255_packets;	/**< Number of 128-255B packets */
-	uint64_t len_256_511_packets;	/**< Number of 256-511B packets */
-	uint64_t len_512_1023_packets;	/**< Number of 512-1023B packets */
-	uint64_t len_1024_1518_packets;	/**< Number of 1024-1518B packets */
-	uint64_t len_1519_max_packets;	/**< Number of 1519-max packets */
+		Does not include multicast packets.
+		Only includes packets whose parse mode is SKIP_TO_L2 */
+	uint64_t len_64_packets; /**< Number of 64B packets */
+	uint64_t len_65_127_packets; /**< Number of 65-127B packets */
+	uint64_t len_128_255_packets; /**< Number of 128-255B packets */
+	uint64_t len_256_511_packets; /**< Number of 256-511B packets */
+	uint64_t len_512_1023_packets; /**< Number of 512-1023B packets */
+	uint64_t len_1024_1518_packets; /**< Number of 1024-1518B packets */
+	uint64_t len_1519_max_packets; /**< Number of 1519-max packets */
 	uint64_t fcs_align_err_packets;	/**< Number of packets with FCS or Align opcode errors */
-	uint64_t runt_packets;		/**< Number of packets with length < min */
-	uint64_t runt_crc_packets;	/**< Number of packets with length < min and FCS error */
-	uint64_t oversize_packets;	/**< Number of packets with length > max */
-	uint64_t oversize_crc_packets;	/**< Number of packets with length > max and FCS error */
-	uint64_t inb_packets;		/**< Number of packets without GMX/SPX/PCI errors received by PKI */
-	uint64_t inb_octets;		/**< Total number of octets from all packets received by PKI, including CRC */
-	uint64_t inb_errors;		/**< Number of packets with GMX/SPX/PCI errors received by PKI */
-	uint64_t mcast_l2_red_packets;	/**< Number of packets with L2 Multicast DMAC
-					that were dropped due to RED.
-					The HW will consider a packet to be an L2
-					multicast packet when the least-significant bit
-					of the first byte of the DMAC is set and the
-					packet is not an L2 broadcast packet.
-					Only applies when the parse mode for the packets
-					is SKIP-TO-L2 */
-	uint64_t bcast_l2_red_packets;	/**< Number of packets with L2 Broadcast DMAC	that were dropped due to RED.
-					The HW will consider a packet to be an L2
-					broadcast packet when the 48-bit DMAC is all 1's.
-					Only applies when the parse mode for the packets
-					is SKIP-TO-L2 */
-	uint64_t mcast_l3_red_packets;	/**< Number of packets with L3 Multicast Dest Address
-					that were dropped due to RED.
-					The HW considers an IPv4 packet to be multicast
-					when the most-significant nibble of the 32-bit
-					destination address is 0xE (i.e it is a class D
-					address). The HW considers an IPv6 packet to be
-					multicast when the most-significant byte of the
-					128-bit destination address is all 1's.
-					Only applies when the parse mode for the packets
-					is SKIP-TO-L2 and the packet is IP or the parse
-					mode for the packet is SKIP-TO-IP */
-	uint64_t bcast_l3_red_packets;	/**< Number of packets with L3 Broadcast Dest Address
-					that were dropped due to RED.
-					The HW considers an IPv4 packet to be broadcast
-					when all bits are set in the MSB of the
-					destination address. IPv6 does not have the
-					concept of a broadcast packets.
-					Only applies when the parse mode for the packet
-					is SKIP-TO-L2 and the packet is IP or the parse
-					mode for the packet is SKIP-TO-IP */
+	uint64_t runt_packets; /**< Number of packets with length < min */
+	uint64_t runt_crc_packets; /**< Number of packets with length < min and FCS error */
+	uint64_t oversize_packets; /**< Number of packets with length > max */
+	uint64_t oversize_crc_packets; /**< Number of packets with length > max and FCS error */
+	uint64_t inb_packets; /**< Number of packets without GMX/SPX/PCI errors received by PKI */
+	uint64_t inb_octets; /**< Total number of octets from all packets received by PKI,
+		including CRC */
+	uint64_t inb_errors; /**< Number of packets with GMX/SPX/PCI errors received by PKI */
+	uint64_t mcast_l2_red_packets; /**< Number of packets with L2 Multicast DMAC
+		that were dropped due to RED.
+		The HW will consider a packet to be an L2 multicast packet, when
+		the least-significant bit of the first byte of the DMAC is set and the packet
+		is not an L2 broadcast packet.
+		Only applies when the parse mode for the packets is SKIP-TO-L2 */
+	uint64_t bcast_l2_red_packets; /**< Number of packets with L2 Broadcast DMAC
+		that were dropped due to RED.
+		The HW will consider a packet to be an L2 broadcast packet when the 48-bit
+		DMAC is all 1's.
+		Only applies when the parse mode for the packets is SKIP-TO-L2 */
+	uint64_t mcast_l3_red_packets; /**< Number of packets with L3 Multicast Dest Address
+		that were dropped due to RED.
+		The HW considers an IPv4 packet to be multicast when the most-significant
+		nibble of the 32-bit destination address is 0xE (i.e it is a class D address).
+		The HW considers an IPv6 packet to be multicast when the most-significant byte
+		of the 128-bit destination address is all 1's.
+		Only applies when the parse mode for the packets is SKIP-TO-L2 and the packet
+		is IP or the parse mode for the packet is SKIP-TO-IP */
+	uint64_t bcast_l3_red_packets; /**< Number of packets with L3 Broadcast Dest Address
+		that were dropped due to RED.
+		The HW considers an IPv4 packet to be broadcast when all bits are set in
+		the MSB of the destination address. IPv6 does not have the concept of
+		broadcast packets.
+		Only applies when the parse mode for the packet is SKIP-TO-L2 and the packet
+		is IP or the parse mode for the packet is SKIP-TO-IP */
 };
 
 /**
+ * PKI Packet Instruction Header Structure (PKI_INST_HDR_S)
+ */
+typedef union {
+	uint64_t u64;
+	struct {
+		uint64_t w     : 1; /* INST_HDR size: 0 = 2 bytes, 1 = 4 or 8 bytes */
+		uint64_t raw   : 1; /* RAW packet indicator in WQE[RAW]: 1 = enable */
+		uint64_t utag  : 1; /* Use INST_HDR[TAG] to compute WQE[TAG]: 1 = enable */
+		uint64_t uqpg  : 1; /* Use INST_HDR[QPG] to compute QPG: 1 = enable */
+		uint64_t rsvd1 : 1;
+		uint64_t pm    : 3; /* Packet parsing mode. Legal values = 0x0..0x7 */
+		uint64_t sl    : 8; /* Number of bytes in INST_HDR. */
+		/* The following fields are not present, if INST_HDR[W] = 0: */
+		uint64_t utt   : 1; /* Use INST_HDR[TT] to compute WQE[TT]: 1 = enable */
+		uint64_t tt    : 2; /* INST_HDR[TT] => WQE[TT], if INST_HDR[UTT] = 1 */
+		uint64_t rsvd2 : 2;
+		uint64_t qpg   :11; /* INST_HDR[QPG] => QPG, if INST_HDR[UQPG] = 1 */
+		uint64_t tag   :32; /* INST_HDR[TAG] => WQE[TAG], if INST_HDR[UTAG] = 1 */
+	} s;
+} cvmx_pki_inst_hdr_t;
+
+/**
  * This function assignes the clusters to a group, later pkind can be
  * configured to use that group depending on number of clusters pkind
  * would use. A given cluster can only be enabled in a single cluster group.
  * Number of clusters assign to that group determines how many engine can work
  * in parallel to process the packet. Eack cluster can process x MPPS.
  *
- * @param node		node
- * @param cluster_group Group to attach clusters to
- * @param cluster_mask  It is the mask of clusters which needs to be assigned to group.
- * to that group
- *
+ * @param node	Node
+ * @param cluster_group Group to attach clusters to.
+ * @param cluster_mask The mask of clusters which needs to be assigned to the group.
  */
 static inline int cvmx_pki_attach_cluster_to_group(int node, uint64_t cluster_group,
 		 uint64_t cluster_mask)
@@ -673,7 +711,8 @@ static inline int cvmx_pki_attach_cluster_to_group(int node, uint64_t cluster_gr
 	return 0;
 }
 
-static inline void cvmx_pki_write_global_parse(int node, struct cvmx_pki_global_parse gbl_pen)
+static inline void cvmx_pki_write_global_parse(int node,
+	struct cvmx_pki_global_parse gbl_pen)
 {
 	cvmx_pki_gbl_pen_t gbl_pen_reg;
 	gbl_pen_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_GBL_PEN);
@@ -690,7 +729,8 @@ static inline void cvmx_pki_write_global_parse(int node, struct cvmx_pki_global_
 	cvmx_write_csr_node(node, CVMX_PKI_GBL_PEN, gbl_pen_reg.u64);
 }
 
-static inline void cvmx_pki_write_tag_secret(int node, struct cvmx_pki_tag_sec tag_secret)
+static inline void cvmx_pki_write_tag_secret(int node,
+	struct cvmx_pki_tag_sec tag_secret)
 {
 	cvmx_pki_tag_secret_t tag_secret_reg;
 	tag_secret_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_SECRET);
@@ -716,11 +756,10 @@ static inline void cvmx_pki_write_ltype_map(int node,
 }
 
 /**
- * This function enables the cluster group to start parsing
- *
- * @param node          node number
- * @param cl_grp        cluster group to enable parsing
+ * This function enables the cluster group to start parsing.
  *
+ * @param node    Node number.
+ * @param cl_grp  Cluster group to enable parsing.
  */
 static inline int cvmx_pki_parse_enable(int node, unsigned cl_grp)
 {
@@ -737,9 +776,9 @@ static inline int cvmx_pki_parse_enable(int node, unsigned cl_grp)
 }
 
 /**
- * This function enables the PKI to send bpid level backpressure
- * to CN78XX inputs.
- * @param node       node number
+ * This function enables the PKI to send bpid level backpressure to CN78XX inputs.
+ *
+ * @param node Node number.
  */
 static inline void cvmx_pki_enable_backpressure(int node)
 {
@@ -753,51 +792,49 @@ static inline void cvmx_pki_enable_backpressure(int node)
 /**
  * Clear the statistics counters for a port.
  *
- * @param node	   node number
+ * @param node Node number.
  * @param port Port number (ipd_port) to get statistics for.
- *		   Make sure PKI_STATS_CTL:mode is set to 0 for
- *		   collecting per port/pkind stats.
+ *    Make sure PKI_STATS_CTL:mode is set to 0 for collecting per port/pkind stats.
  */
 void cvmx_pki_clear_port_stats(int node, uint64_t port);
 
 /**
  * Get the status counters for index from PKI.
  *
- * @param node	   node number
- * @param index    pkind number (if PKI_STATS_CTL:mode=0) or
- *		   style(flow) number (if PKI_STATS_CTL:mode=1)
- * @param status   Where to put the results.
+ * @param node	  Node number.
+ * @param index   PKIND number, if PKI_STATS_CTL:mode = 0 or
+ *     style(flow) number, if PKI_STATS_CTL:mode = 1
+ * @param status  Where to put the results.
  */
 void cvmx_pki_get_stats(int node, int index, struct cvmx_pki_port_stats *status);
 
 /**
  * Get the statistics counters for a port.
  *
- * @param node	   node number
- * @param port Port number (ipd_port) to get statistics for.
- *		   Make sure PKI_STATS_CTL:mode is set to 0 for
- *		   collecting per port/pkind stats.
- * @param status   Where to put the results.
+ * @param node	 Node number
+ * @param port   Port number (ipd_port) to get statistics for.
+ *    Make sure PKI_STATS_CTL:mode is set to 0 for collecting per port/pkind stats.
+ * @param status Where to put the results.
  */
-static inline void cvmx_pki_get_port_stats(int node, uint64_t port, struct cvmx_pki_port_stats *status)
+static inline void cvmx_pki_get_port_stats(int node, uint64_t port,
+	struct cvmx_pki_port_stats *status)
 {
 	int interface = cvmx_helper_get_interface_num(port);
 	int index = cvmx_helper_get_interface_index_num(port);
 	int pknd = cvmx_helper_get_pknd(interface, index);
-
 	cvmx_pki_get_stats(node, pknd, status);
 }
 
 /**
  * Get the statistics counters for a flow represented by style in PKI.
  *
- * @param node	   node number
- * @param style_num   style number to get statistics for.
- *		   Make sure PKI_STATS_CTL:mode is set to 1 for
- *		   collecting per style/flow stats.
- * @param status   Where to put the results.
+ * @param node Node number.
+ * @param style_num Style number to get statistics for.
+ *    Make sure PKI_STATS_CTL:mode is set to 1 for collecting per style/flow stats.
+ * @param status Where to put the results.
  */
-static inline void cvmx_pki_get_flow_stats(int node, uint64_t style_num, struct cvmx_pki_port_stats *status)
+static inline void cvmx_pki_get_flow_stats(int node, uint64_t style_num,
+	struct cvmx_pki_port_stats *status)
 {
 	cvmx_pki_get_stats(node, style_num, status);
 }
@@ -817,147 +854,166 @@ int cvmx_pki_config_dump(unsigned node);
 int cvmx_pki_stats_dump(unsigned node);
 
 /**
- * This function enables pki
+ * Clear PKI statistics.
+ *
+ * @param node	   node number
+ */
+void cvmx_pki_stats_clear(unsigned node);
+
+/**
+ * This function enables PKI.
+ *
  * @param node	 node to enable pki in.
  */
 void cvmx_pki_enable(int node);
 
 /**
- * This function disables pki
+ * This function disables PKI.
+ *
  * @param node	node to disable pki in.
  */
 void cvmx_pki_disable(int node);
 
 /**
- * This function soft resets pki
+ * This function soft resets PKI.
+ *
  * @param node	node to enable pki in.
  */
 void cvmx_pki_reset(int node);
 
 /**
- * This function sets the clusters in PKI
+ * This function sets the clusters in PKI.
+ *
  * @param node	node to set clusters in.
  */
 int cvmx_pki_setup_clusters(int node);
 
 /**
  * This function reads global configuration of PKI block.
- * @param node		      node number.
- * @param gbl_cfg	      pointer to struct to read global configuration
+ *
+ * @param node    Node number.
+ * @param gbl_cfg Pointer to struct to read global configuration
  */
 void cvmx_pki_read_global_config(int node, struct cvmx_pki_global_config *gbl_cfg);
 
 /**
  * This function writes global configuration of PKI into hw.
- * @param node		      node number.
- * @param gbl_cfg	      pointer to struct to global configuration
+ *
+ * @param node    Node number.
+ * @param gbl_cfg Pointer to struct to global configuration
  */
 void cvmx_pki_write_global_config(int node, struct cvmx_pki_global_config *gbl_cfg);
 
-
 /**
  * This function reads per pkind parameters in hardware which defines how
-  the incoming packet is processed.
- * @param node		      node number.
- * @param pkind               PKI supports a large number of incoming interfaces
- *                            and packets arriving on different interfaces or channels
- *                            may want to be processed differently. PKI uses the pkind to
- *                            determine how the incoming packet is processed.
- * @param pkind_cfg	      pointer to struct conatining pkind configuration read from hw
+ * the incoming packet is processed.
+ * 
+ * @param node   Node number.
+ * @param pkind  PKI supports a large number of incoming interfaces and packets
+ *     arriving on different interfaces or channels may want to be processed
+ *     differently. PKI uses the pkind to determine how the incoming packet
+ *     is processed.
+ * @param pkind_cfg	Pointer to struct conatining pkind configuration read
+ *     from hardware.
  */
-int cvmx_pki_read_pkind_config(int node, int pkind, struct cvmx_pki_pkind_config *pkind_cfg);
+int cvmx_pki_read_pkind_config(int node, int pkind,
+	struct cvmx_pki_pkind_config *pkind_cfg);
 
 /**
  * This function writes per pkind parameters in hardware which defines how
-  the incoming packet is processed.
- * @param node		      node number.
- * @param pkind               PKI supports a large number of incoming interfaces
- *                            and packets arriving on different interfaces or channels
- *                            may want to be processed differently. PKI uses the pkind to
- *                            determine how the incoming packet is processed.
- * @param pkind_cfg	      pointer to struct conatining pkind configuration need to be written
- *                            in hw
+ * the incoming packet is processed.
+ *
+ * @param node   Node number.
+ * @param pkind  PKI supports a large number of incoming interfaces and packets
+ *     arriving on different interfaces or channels may want to be processed
+ *     differently. PKI uses the pkind to determine how the incoming packet
+ *     is processed.
+ * @param pkind_cfg	Pointer to struct conatining pkind configuration need
+ *     to be written in hardware.
+ */
+int cvmx_pki_write_pkind_config(int node, int pkind,
+	struct cvmx_pki_pkind_config *pkind_cfg);
+
+/**
+ * This function reads parameters associated with tag configuration in hardware.
+ *
+ * @param node	 Node number.
+ * @param style  Style to configure tag for.
+ * @param cluster_mask  Mask of clusters to configure the style for.
+ * @param tag_cfg  Pointer to tag configuration struct.
  */
-int cvmx_pki_write_pkind_config(int node, int pkind, struct cvmx_pki_pkind_config *pkind_cfg);
-
- /** This function reads parameters associated with tag configuration in hardware.
- * @param node	              node number.
- * @param style		      style to configure tag for
- * @param cluster_mask	      Mask of clusters to configure the style for.
- * @param tag_cfg	      pointer to tag configuration struct.
-  */
 void cvmx_pki_read_tag_config(int node, int style, uint64_t cluster_mask,
-		struct cvmx_pki_style_tag_cfg *tag_cfg);
-
- /** This function writes/configures parameters associated with tag configuration in hardware.
- * @param node	              node number.
- * @param style		      style to configure tag for
- * @param cluster_mask	      Mask of clusters to configure the style for.
- * @param tag_cfg	      pointer to taf configuration struct.
-  */
+	struct cvmx_pki_style_tag_cfg *tag_cfg);
+
+/**
+ * This function writes/configures parameters associated with tag
+ * configuration in hardware.
+ *
+ * @param node  Node number.
+ * @param style  Style to configure tag for.
+ * @param cluster_mask  Mask of clusters to configure the style for.
+ * @param tag_cfg  Pointer to taf configuration struct.
+ */
 void cvmx_pki_write_tag_config(int node, int style, uint64_t cluster_mask,
-		struct cvmx_pki_style_tag_cfg *tag_cfg);
+	struct cvmx_pki_style_tag_cfg *tag_cfg);
 
 /**
  * This function reads parameters associated with style in hardware.
- * @param node	              node number.
- * @param style		      style to read from.
- * @param cluster_mask	      Mask of clusters style belongs to.
- * @param style_cfg	      pointer to style config struct.
+ *
+ * @param node	Node number.
+ * @param style  Style to read from.
+ * @param cluster_mask  Mask of clusters style belongs to.
+ * @param style_cfg  Pointer to style config struct.
  */
 void cvmx_pki_read_style_config(int node, int style, uint64_t cluster_mask,
-		struct cvmx_pki_style_config *style_cfg);
+	struct cvmx_pki_style_config *style_cfg);
 
 /**
  * This function writes/configures parameters associated with style in hardware.
- * @param node	              node number.
- * @param style		      style to configure.
- * @param cluster_mask	      Mask of clusters to configure the style for.
- * @param style_cfg	      pointer to style config struct.
+ *
+ * @param node  Node number.
+ * @param style  Style to configure.
+ * @param cluster_mask  Mask of clusters to configure the style for.
+ * @param style_cfg  Pointer to style config struct.
  */
-void cvmx_pki_write_style_config(int node, uint64_t style,
-		uint64_t cluster_mask,
-		struct cvmx_pki_style_config *style_cfg);
+void cvmx_pki_write_style_config(int node, uint64_t style, uint64_t cluster_mask,
+	struct cvmx_pki_style_config *style_cfg);
 /**
  * This function reads qpg entry at specified offset from qpg table
  *
- * @param node		node number
- * @param offset	offset in qpg table to read from.
- * @param qpg_cfg       pointer to structure containing qpg values
+ * @param node  Node number.
+ * @param offset  Offset in qpg table to read from.
+ * @param qpg_cfg  Pointer to structure containing qpg values
  */
 int cvmx_pki_read_qpg_entry(int node, int offset, struct cvmx_pki_qpg_config *qpg_cfg);
 
-
 /**
  * This function writes qpg entry at specified offset in qpg table
  *
- * @param node		node number
- * @param offset	offset in qpg table to write to.
- * @param qpg_cfg       pointer to stricture containing qpg values
+ * @param node  Node number.
+ * @param offset  Offset in qpg table to write to.
+ * @param qpg_cfg  Pointer to stricture containing qpg values.
  */
 void cvmx_pki_write_qpg_entry(int node, int offset, struct cvmx_pki_qpg_config *qpg_cfg);
 
 /**
  * This function writes pcam entry at given offset in pcam table in hardware
  *
- * @param node	              node number.
- * @param index		      offset in pcam table.
- * @param cluster_mask	      Mask of clusters in which to write pcam entry.
- * @param input 	      input keys to pcam match passed as struct.
- * @param action	      pcam match action passed as struct
- *
+ * @param node  Node number.
+ * @param index	 Offset in pcam table.
+ * @param cluster_mask  Mask of clusters in which to write pcam entry.
+ * @param input  Input keys to pcam match passed as struct.
+ * @param action  PCAM match action passed as struct
  */
 int cvmx_pki_pcam_write_entry(int node, int index, uint64_t cluster_mask,
-		struct cvmx_pki_pcam_input input,
-		struct cvmx_pki_pcam_action action);
+	struct cvmx_pki_pcam_input input, struct cvmx_pki_pcam_action action);
 /**
- * Configures the channel which will receive backpressure
- * from the specified bpid.
+ * Configures the channel which will receive backpressure from the specified bpid.
  * Each channel listens for backpressure on a specific bpid.
  * Each bpid can backpressure multiple channels.
- * @param node    node number
- * @param bpid    bpid from which, channel will receive backpressure.
- * @param channel channel numner to receive backpressue.
+ * @param node  Node number.
+ * @param bpid  BPID from which channel will receive backpressure.
+ * @param channel  Channel numner to receive backpressue.
  */
 int cvmx_pki_write_channel_bpid(int node, int channel, int bpid);
 
@@ -966,32 +1022,33 @@ int cvmx_pki_write_channel_bpid(int node, int channel, int bpid);
  * assert backpressure.
  * Each bpid receives backpressure from auras.
  * Multiple auras can backpressure single bpid.
- * @param node   node number
- * @param aura   number which will assert backpressure on that bpid.
- * @param bpid   to assert backpressure on.
+ * @param node  Node number.
+ * @param aura  Number which will assert backpressure on that bpid.
+ * @param bpid  To assert backpressure on.
  */
 int cvmx_pki_write_aura_bpid(int node, int aura, int bpid);
 
 /**
- * Enables/Disabled QoS (RED Drop, Tail Drop & backpressure) for the
- * PKI aura.
- * @param node      node number
- * @param aura      to enable/disable QoS on.
- * @param ena_red   Enable/Disable RED drop between pass and drop level
- *                  1-enable 0-disable
+ * Enables/Disabled QoS (RED Drop, Tail Drop & backpressure) for the* PKI aura.
+ *
+ * @param node  Node number
+ * @param aura  To enable/disable QoS on.
+ * @param ena_red  Enable/Disable RED drop between pass and drop level
+ *    1-enable 0-disable
  * @param ena_drop  Enable/disable tail drop when max drop level exceeds
- *                  1-enable 0-disable
- * @param ena_bp    Enable/Disable asserting backpressure on bpid when
- *                  max DROP level exceeds.
- *                  1-enable 0-disable
+ *    1-enable 0-disable
+ * @param ena_bp  Enable/Disable asserting backpressure on bpid when
+ *    max DROP level exceeds.
+ *    1-enable 0-disable
  */
 int cvmx_pki_enable_aura_qos(int node, int aura, bool ena_red,
 		bool ena_drop, bool ena_bp);
 
 /**
  * This function gives the initial style used by that pkind.
- * @param node          node number.
- * @param pkind         pkind number.
+ *
+ * @param node  Node number.
+ * @param pkind  PKIND number.
  */
 int cvmx_pki_get_pkind_style(int node, int pkind);
 
@@ -999,17 +1056,18 @@ int cvmx_pki_get_pkind_style(int node, int pkind);
  * This function sets the wqe buffer mode. First packet data buffer can reside
  * either in same buffer as wqe OR it can go in separate buffer. If used the later mode,
  * make sure software allocate enough buffers to now have wqe separate from packet data.
- * @param node	              node number.
- * @param style		      style to configure.
- * @param pkt_outside_wqe	0 = The packet link pointer will be at word [FIRST_SKIP]
- *				    immediately followed by packet data, in the same buffer
- *				    as the work queue entry.
- *				1 = The packet link pointer will be at word [FIRST_SKIP] in a new
- *				    buffer separate from the work queue entry. Words following the
- *				    WQE in the same cache line will be zeroed, other lines in the
- *				    buffer will not be modified and will retain stale data (from the
- *				    buffer’s previous use). This setting may decrease the peak PKI
- *				    performance by up to half on small packets.
+ *
+ * @param node  Node number.
+ * @param style  Style to configure.
+ * @param pkt_outside_wqe 
+ *    0 = The packet link pointer will be at word [FIRST_SKIP] immediately
+ *    followed by packet data, in the same buffer as the work queue entry.
+ *    1 = The packet link pointer will be at word [FIRST_SKIP] in a new
+ *    buffer separate from the work queue entry. Words following the
+ *    WQE in the same cache line will be zeroed, other lines in the
+ *    buffer will not be modified and will retain stale data (from the
+ *    buffer’s previous use). This setting may decrease the peak PKI
+ *    performance by up to half on small packets.
  */
 void cvmx_pki_set_wqe_mode(int node, uint64_t style, bool pkt_outside_wqe);
 
@@ -1018,77 +1076,80 @@ void cvmx_pki_set_wqe_mode(int node, uint64_t style, bool pkt_outside_wqe);
  * It Changes write operations of packet data to L2C to
  * be in little-endian. Does not change the WQE header format, which is
  * properly endian neutral.
- * @param node	              node number.
- * @param style 	      style to configure.
+ *
+ * @param node  Node number.
+ * @param style  Style to configure.
  */
 void cvmx_pki_set_little_endian(int node, uint64_t style);
 
 /**
- * Enables/Disables l2 length error check and max & min frame length checks
- * @param node		node number
- * @param pknd		pkind to disable error for.
- * @param l2len_err	L2 length error check enable.
+ * Enables/Disables L2 length error check and max & min frame length checks.
+ *
+ * @param node  Node number.
+ * @param pknd  PKIND to disable error for.
+ * @param l2len_err	 L2 length error check enable.
  * @param maxframe_err	Max frame error check enable.
  * @param minframe_err	Min frame error check enable.
- *			1 -- Enabel err checks
- *			0 -- Disable error checks
+ *    1 -- Enabel err checks
+ *    0 -- Disable error checks
  */
 void cvmx_pki_endis_l2_errs(int node, int pknd, bool l2len_err,
 			bool maxframe_err, bool minframe_err);
 
 /**
  * Enables/Disables fcs check and fcs stripping on the pkind.
- * @param node		node number
- * @param pknd		pkind to apply settings on.
- * @param fcs_chk	enable/disable fcs check.
- *			1 -- enable fcs error check.
- *			0 -- disable fcs error check.
- * @param fcs_strip	Strip L2 FCS bytes from packet, decrease WQE[LEN] by 4 bytes
- *			1 -- strip L2 FCS.
- *			0 -- Do not strip L2 FCS.
+ *
+ * @param node  Node number.
+ * @param pknd  PKIND to apply settings on.
+ * @param fcs_chk  Enable/disable fcs check.
+ *    1 -- enable fcs error check.
+ *    0 -- disable fcs error check.
+ * @param fcs_strip	 Strip L2 FCS bytes from packet, decrease WQE[LEN] by 4 bytes
+ *    1 -- strip L2 FCS.
+ *    0 -- Do not strip L2 FCS.
  */
 void cvmx_pki_endis_fcs_check(int node, int pknd, bool fcs_chk, bool fcs_strip);
 
 /**
- * This function shows the qpg table entries,
- * read directly from hardware.
- * @param node    node number
- * @param num_entry number of entries to print
+ * This function shows the qpg table entries, read directly from hardware.
+ *
+ * @param node  Node number.
+ * @param num_entry  Number of entries to print.
  */
 void cvmx_pki_show_qpg_entries(int node, uint16_t num_entry);
 
 /**
- * This function shows the pcam table in raw format,
- * read directly from hardware.
- * @param node    node number
+ * This function shows the pcam table in raw format read directly from hardware.
+ *
+ * @param node  Node number.
  */
 void cvmx_pki_show_pcam_entries(int node);
 
 /**
  * This function shows the valid entries in readable format,
  * read directly from hardware.
- * @param node    node number
+ *
+ * @param node  Node number.
  */
 void cvmx_pki_show_valid_pcam_entries(int node);
 
 /**
  * This function shows the pkind attributes in readable format,
  * read directly from hardware.
- * @param node    node number
- * @param pkind   pkind number to print
+ * @param node  Node number.
+ * @param pkind  PKIND number to print.
  */
 void cvmx_pki_show_pkind_attributes(int node, int pkind);
 
 /**
  * @INTERNAL
- * This function is called by cvmx_helper_shutdown() to extract
- * all FPA buffers out of the PKI. After this function
- * completes, all FPA buffers that were prefetched by PKI
- * wil be in the apropriate FPA pool. This functions does not reset
- * PKI.
- * WARNING: It is very important that PKI be
- * reset soon after a call to this function.
- * @param node	              node number.
+ * This function is called by cvmx_helper_shutdown() to extract all FPA buffers
+ * out of the PKI. After this function completes, all FPA buffers that were
+ * prefetched by PKI will be in the apropriate FPA pool.
+ * This functions does not reset the PKI.
+ * WARNING: It is very important that PKI be reset soon after a call to this function.
+ *
+ * @param node  Node number.
  */
 void __cvmx_pki_free_ptr(int node);
 
@@ -1098,3 +1159,4 @@ void __cvmx_pki_free_ptr(int node);
 /* *INDENT-ON* */
 #endif
 #endif
+
diff --git a/arch/mips/include/asm/octeon/cvmx-pko-defs.h b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
index 101848a..e13117a 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
@@ -56,7 +56,7 @@
 #define CVMX_PKO_CHANNEL_LEVEL CVMX_PKO_CHANNEL_LEVEL_FUNC()
 static inline uint64_t CVMX_PKO_CHANNEL_LEVEL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_CHANNEL_LEVEL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000800F0ull);
 }
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_PKO_CHANNEL_LEVEL_FUNC(void)
 #define CVMX_PKO_DPFI_ENA CVMX_PKO_DPFI_ENA_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_ENA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_DPFI_ENA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00018ull);
 }
@@ -78,7 +78,7 @@ static inline uint64_t CVMX_PKO_DPFI_ENA_FUNC(void)
 #define CVMX_PKO_DPFI_FLUSH CVMX_PKO_DPFI_FLUSH_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_FLUSH_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_DPFI_FLUSH not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00008ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_PKO_DPFI_FLUSH_FUNC(void)
 #define CVMX_PKO_DPFI_FPA_AURA CVMX_PKO_DPFI_FPA_AURA_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_FPA_AURA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_DPFI_FPA_AURA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00010ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_PKO_DPFI_FPA_AURA_FUNC(void)
 #define CVMX_PKO_DPFI_STATUS CVMX_PKO_DPFI_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_DPFI_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_DPFI_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000C00000ull);
 }
@@ -112,6 +112,7 @@ static inline uint64_t CVMX_PKO_DQX_BYTES(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_BYTES(%lu) is invalid on this chip\n", offset);
@@ -125,6 +126,7 @@ static inline uint64_t CVMX_PKO_DQX_CIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_CIR(%lu) is invalid on this chip\n", offset);
@@ -138,6 +140,7 @@ static inline uint64_t CVMX_PKO_DQX_DROPPED_BYTES(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_DROPPED_BYTES(%lu) is invalid on this chip\n", offset);
@@ -151,6 +154,7 @@ static inline uint64_t CVMX_PKO_DQX_DROPPED_PACKETS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_DROPPED_PACKETS(%lu) is invalid on this chip\n", offset);
@@ -164,6 +168,7 @@ static inline uint64_t CVMX_PKO_DQX_FIFO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_FIFO(%lu) is invalid on this chip\n", offset);
@@ -177,6 +182,7 @@ static inline uint64_t CVMX_PKO_DQX_PACKETS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_PACKETS(%lu) is invalid on this chip\n", offset);
@@ -190,6 +196,7 @@ static inline uint64_t CVMX_PKO_DQX_PICK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_PICK(%lu) is invalid on this chip\n", offset);
@@ -203,6 +210,7 @@ static inline uint64_t CVMX_PKO_DQX_PIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_PIR(%lu) is invalid on this chip\n", offset);
@@ -216,6 +224,7 @@ static inline uint64_t CVMX_PKO_DQX_POINTERS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_POINTERS(%lu) is invalid on this chip\n", offset);
@@ -229,6 +238,7 @@ static inline uint64_t CVMX_PKO_DQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
@@ -242,6 +252,7 @@ static inline uint64_t CVMX_PKO_DQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
@@ -255,6 +266,7 @@ static inline uint64_t CVMX_PKO_DQX_SHAPE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_SHAPE(%lu) is invalid on this chip\n", offset);
@@ -268,6 +280,7 @@ static inline uint64_t CVMX_PKO_DQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
@@ -281,6 +294,7 @@ static inline uint64_t CVMX_PKO_DQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
@@ -294,6 +308,7 @@ static inline uint64_t CVMX_PKO_DQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
@@ -307,6 +322,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_BUF_CNT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CNT(%lu) is invalid on this chip\n", offset);
@@ -320,6 +336,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CTL(%lu) is invalid on this chip\n", offset);
@@ -333,6 +350,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_BUF_CTL_W1C(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_BUF_CTL_W1C(%lu) is invalid on this chip\n", offset);
@@ -346,6 +364,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CNT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_CNT(%lu) is invalid on this chip\n", offset);
@@ -359,6 +378,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_CTL(%lu) is invalid on this chip\n", offset);
@@ -372,6 +392,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CTL_W1C(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_DQX_WM_CTL_W1C(%lu) is invalid on this chip\n", offset);
@@ -384,7 +405,7 @@ static inline uint64_t CVMX_PKO_DQX_WM_CTL_W1C(unsigned long offset)
 #define CVMX_PKO_DQ_CSR_BUS_DEBUG CVMX_PKO_DQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_DQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_DQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400003001F8ull);
 }
@@ -395,7 +416,7 @@ static inline uint64_t CVMX_PKO_DQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_DQ_DEBUG CVMX_PKO_DQ_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_DQ_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_DQ_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300128ull);
 }
@@ -406,7 +427,7 @@ static inline uint64_t CVMX_PKO_DQ_DEBUG_FUNC(void)
 #define CVMX_PKO_DRAIN_IRQ CVMX_PKO_DRAIN_IRQ_FUNC()
 static inline uint64_t CVMX_PKO_DRAIN_IRQ_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_DRAIN_IRQ not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000140ull);
 }
@@ -417,7 +438,7 @@ static inline uint64_t CVMX_PKO_DRAIN_IRQ_FUNC(void)
 #define CVMX_PKO_ENABLE CVMX_PKO_ENABLE_FUNC()
 static inline uint64_t CVMX_PKO_ENABLE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_ENABLE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000D00008ull);
 }
@@ -429,6 +450,7 @@ static inline uint64_t CVMX_PKO_FORMATX_CTL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 31))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 31)))))
 		cvmx_warn("CVMX_PKO_FORMATX_CTL(%lu) is invalid on this chip\n", offset);
@@ -441,7 +463,7 @@ static inline uint64_t CVMX_PKO_FORMATX_CTL(unsigned long offset)
 #define CVMX_PKO_L1_SQA_DEBUG CVMX_PKO_L1_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L1_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_L1_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080128ull);
 }
@@ -452,7 +474,7 @@ static inline uint64_t CVMX_PKO_L1_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L1_SQB_DEBUG CVMX_PKO_L1_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L1_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_L1_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080130ull);
 }
@@ -464,6 +486,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_CIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_CIR(%lu) is invalid on this chip\n", offset);
@@ -477,6 +500,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_DROPPED_BYTES(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_DROPPED_BYTES(%lu) is invalid on this chip\n", offset);
@@ -490,6 +514,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_DROPPED_PACKETS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_DROPPED_PACKETS(%lu) is invalid on this chip\n", offset);
@@ -503,6 +528,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_GREEN(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_GREEN(%lu) is invalid on this chip\n", offset);
@@ -516,6 +542,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_GREEN_BYTES(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_GREEN_BYTES(%lu) is invalid on this chip\n", offset);
@@ -529,6 +556,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_GREEN_PACKETS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_GREEN_PACKETS(%lu) is invalid on this chip\n", offset);
@@ -542,6 +570,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_LINK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_LINK(%lu) is invalid on this chip\n", offset);
@@ -555,6 +584,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_PICK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_PICK(%lu) is invalid on this chip\n", offset);
@@ -568,6 +598,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_RED(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_RED(%lu) is invalid on this chip\n", offset);
@@ -581,6 +612,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_RED_BYTES(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_RED_BYTES(%lu) is invalid on this chip\n", offset);
@@ -594,6 +626,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_RED_PACKETS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_RED_PACKETS(%lu) is invalid on this chip\n", offset);
@@ -607,6 +640,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
@@ -620,6 +654,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
@@ -633,6 +668,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
@@ -646,6 +682,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
@@ -659,6 +696,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
@@ -672,6 +710,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
@@ -685,6 +724,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_BYTES(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_YELLOW_BYTES(%lu) is invalid on this chip\n", offset);
@@ -698,6 +738,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_PACKETS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 31))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_L1_SQX_YELLOW_PACKETS(%lu) is invalid on this chip\n", offset);
@@ -710,7 +751,7 @@ static inline uint64_t CVMX_PKO_L1_SQX_YELLOW_PACKETS(unsigned long offset)
 #define CVMX_PKO_L1_SQ_CSR_BUS_DEBUG CVMX_PKO_L1_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L1_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_L1_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000801F8ull);
 }
@@ -721,7 +762,7 @@ static inline uint64_t CVMX_PKO_L1_SQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_L2_SQA_DEBUG CVMX_PKO_L2_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L2_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_L2_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100128ull);
 }
@@ -732,7 +773,7 @@ static inline uint64_t CVMX_PKO_L2_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L2_SQB_DEBUG CVMX_PKO_L2_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L2_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_L2_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100130ull);
 }
@@ -744,6 +785,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_CIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_CIR(%lu) is invalid on this chip\n", offset);
@@ -757,6 +799,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_GREEN(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_GREEN(%lu) is invalid on this chip\n", offset);
@@ -770,6 +813,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_PICK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_PICK(%lu) is invalid on this chip\n", offset);
@@ -783,6 +827,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_PIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_PIR(%lu) is invalid on this chip\n", offset);
@@ -796,6 +841,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_POINTERS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_POINTERS(%lu) is invalid on this chip\n", offset);
@@ -809,6 +855,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_RED(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_RED(%lu) is invalid on this chip\n", offset);
@@ -822,6 +869,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
@@ -835,6 +883,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
@@ -848,6 +897,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
@@ -861,6 +911,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
@@ -874,6 +925,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
@@ -887,6 +939,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
@@ -900,6 +953,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L2_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
@@ -912,7 +966,7 @@ static inline uint64_t CVMX_PKO_L2_SQX_YELLOW(unsigned long offset)
 #define CVMX_PKO_L2_SQ_CSR_BUS_DEBUG CVMX_PKO_L2_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L2_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_L2_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400001001F8ull);
 }
@@ -924,6 +978,7 @@ static inline uint64_t CVMX_PKO_L3_L2_SQX_CHANNEL(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_L2_SQX_CHANNEL(%lu) is invalid on this chip\n", offset);
@@ -936,7 +991,7 @@ static inline uint64_t CVMX_PKO_L3_L2_SQX_CHANNEL(unsigned long offset)
 #define CVMX_PKO_L3_SQA_DEBUG CVMX_PKO_L3_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L3_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_L3_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180128ull);
 }
@@ -947,7 +1002,7 @@ static inline uint64_t CVMX_PKO_L3_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L3_SQB_DEBUG CVMX_PKO_L3_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L3_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_L3_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180130ull);
 }
@@ -959,6 +1014,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_CIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_CIR(%lu) is invalid on this chip\n", offset);
@@ -972,6 +1028,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_GREEN(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_GREEN(%lu) is invalid on this chip\n", offset);
@@ -985,6 +1042,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_PICK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_PICK(%lu) is invalid on this chip\n", offset);
@@ -998,6 +1056,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_PIR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_PIR(%lu) is invalid on this chip\n", offset);
@@ -1011,6 +1070,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_POINTERS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_POINTERS(%lu) is invalid on this chip\n", offset);
@@ -1024,6 +1084,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_RED(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_RED(%lu) is invalid on this chip\n", offset);
@@ -1037,6 +1098,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
@@ -1050,6 +1112,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
@@ -1063,6 +1126,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
@@ -1076,6 +1140,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
@@ -1089,6 +1154,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
@@ -1102,6 +1168,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
@@ -1115,6 +1182,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_L3_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
@@ -1127,7 +1195,7 @@ static inline uint64_t CVMX_PKO_L3_SQX_YELLOW(unsigned long offset)
 #define CVMX_PKO_L3_SQ_CSR_BUS_DEBUG CVMX_PKO_L3_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L3_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_L3_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400001801F8ull);
 }
@@ -1138,7 +1206,7 @@ static inline uint64_t CVMX_PKO_L3_SQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_L4_SQA_DEBUG CVMX_PKO_L4_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L4_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_L4_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000200128ull);
 }
@@ -1149,7 +1217,7 @@ static inline uint64_t CVMX_PKO_L4_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L4_SQB_DEBUG CVMX_PKO_L4_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L4_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_L4_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000200130ull);
 }
@@ -1160,6 +1228,7 @@ static inline uint64_t CVMX_PKO_L4_SQB_DEBUG_FUNC(void)
 static inline uint64_t CVMX_PKO_L4_SQX_CIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180018ull) + ((offset) & 1023) * 512;
@@ -1171,6 +1240,7 @@ static inline uint64_t CVMX_PKO_L4_SQX_CIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L4_SQX_GREEN(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_GREEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000200058ull) + ((offset) & 1023) * 512;
@@ -1182,6 +1252,7 @@ static inline uint64_t CVMX_PKO_L4_SQX_GREEN(unsigned long offset)
 static inline uint64_t CVMX_PKO_L4_SQX_PICK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000200070ull) + ((offset) & 1023) * 512;
@@ -1193,6 +1264,7 @@ static inline uint64_t CVMX_PKO_L4_SQX_PICK(unsigned long offset)
 static inline uint64_t CVMX_PKO_L4_SQX_PIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_PIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180020ull) + ((offset) & 1023) * 512;
@@ -1204,6 +1276,7 @@ static inline uint64_t CVMX_PKO_L4_SQX_PIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L4_SQX_POINTERS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_POINTERS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180078ull) + ((offset) & 1023) * 512;
@@ -1215,6 +1288,7 @@ static inline uint64_t CVMX_PKO_L4_SQX_POINTERS(unsigned long offset)
 static inline uint64_t CVMX_PKO_L4_SQX_RED(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_RED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000200068ull) + ((offset) & 1023) * 512;
@@ -1226,6 +1300,7 @@ static inline uint64_t CVMX_PKO_L4_SQX_RED(unsigned long offset)
 static inline uint64_t CVMX_PKO_L4_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180008ull) + ((offset) & 1023) * 512;
@@ -1237,6 +1312,7 @@ static inline uint64_t CVMX_PKO_L4_SQX_SCHEDULE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L4_SQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 511))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180028ull) + ((offset) & 511) * 512;
@@ -1248,6 +1324,7 @@ static inline uint64_t CVMX_PKO_L4_SQX_SCHED_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L4_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180010ull) + ((offset) & 1023) * 512;
@@ -1259,6 +1336,7 @@ static inline uint64_t CVMX_PKO_L4_SQX_SHAPE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L4_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000180030ull) + ((offset) & 1023) * 512;
@@ -1270,6 +1348,7 @@ static inline uint64_t CVMX_PKO_L4_SQX_SHAPE_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L4_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400001800E0ull) + ((offset) & 1023) * 512;
@@ -1281,6 +1360,7 @@ static inline uint64_t CVMX_PKO_L4_SQX_SW_XOFF(unsigned long offset)
 static inline uint64_t CVMX_PKO_L4_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000200000ull) + ((offset) & 1023) * 512;
@@ -1292,6 +1372,7 @@ static inline uint64_t CVMX_PKO_L4_SQX_TOPOLOGY(unsigned long offset)
 static inline uint64_t CVMX_PKO_L4_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000200060ull) + ((offset) & 1023) * 512;
@@ -1303,7 +1384,7 @@ static inline uint64_t CVMX_PKO_L4_SQX_YELLOW(unsigned long offset)
 #define CVMX_PKO_L4_SQ_CSR_BUS_DEBUG CVMX_PKO_L4_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L4_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_L4_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400002001F8ull);
 }
@@ -1314,7 +1395,7 @@ static inline uint64_t CVMX_PKO_L4_SQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_L5_SQA_DEBUG CVMX_PKO_L5_SQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L5_SQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_L5_SQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000280128ull);
 }
@@ -1325,7 +1406,7 @@ static inline uint64_t CVMX_PKO_L5_SQA_DEBUG_FUNC(void)
 #define CVMX_PKO_L5_SQB_DEBUG CVMX_PKO_L5_SQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L5_SQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_L5_SQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000280130ull);
 }
@@ -1336,6 +1417,7 @@ static inline uint64_t CVMX_PKO_L5_SQB_DEBUG_FUNC(void)
 static inline uint64_t CVMX_PKO_L5_SQX_CIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L5_SQX_CIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000200018ull) + ((offset) & 1023) * 512;
@@ -1347,6 +1429,7 @@ static inline uint64_t CVMX_PKO_L5_SQX_CIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L5_SQX_GREEN(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L5_SQX_GREEN(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280058ull) + ((offset) & 1023) * 512;
@@ -1358,6 +1441,7 @@ static inline uint64_t CVMX_PKO_L5_SQX_GREEN(unsigned long offset)
 static inline uint64_t CVMX_PKO_L5_SQX_PICK(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L5_SQX_PICK(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280070ull) + ((offset) & 1023) * 512;
@@ -1369,6 +1453,7 @@ static inline uint64_t CVMX_PKO_L5_SQX_PICK(unsigned long offset)
 static inline uint64_t CVMX_PKO_L5_SQX_PIR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L5_SQX_PIR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000200020ull) + ((offset) & 1023) * 512;
@@ -1380,6 +1465,7 @@ static inline uint64_t CVMX_PKO_L5_SQX_PIR(unsigned long offset)
 static inline uint64_t CVMX_PKO_L5_SQX_POINTERS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L5_SQX_POINTERS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000200078ull) + ((offset) & 1023) * 512;
@@ -1391,6 +1477,7 @@ static inline uint64_t CVMX_PKO_L5_SQX_POINTERS(unsigned long offset)
 static inline uint64_t CVMX_PKO_L5_SQX_RED(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L5_SQX_RED(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280068ull) + ((offset) & 1023) * 512;
@@ -1402,6 +1489,7 @@ static inline uint64_t CVMX_PKO_L5_SQX_RED(unsigned long offset)
 static inline uint64_t CVMX_PKO_L5_SQX_SCHEDULE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L5_SQX_SCHEDULE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000200008ull) + ((offset) & 1023) * 512;
@@ -1413,6 +1501,7 @@ static inline uint64_t CVMX_PKO_L5_SQX_SCHEDULE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L5_SQX_SCHED_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L5_SQX_SCHED_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000200028ull) + ((offset) & 1023) * 512;
@@ -1424,6 +1513,7 @@ static inline uint64_t CVMX_PKO_L5_SQX_SCHED_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L5_SQX_SHAPE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L5_SQX_SHAPE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000200010ull) + ((offset) & 1023) * 512;
@@ -1435,6 +1525,7 @@ static inline uint64_t CVMX_PKO_L5_SQX_SHAPE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L5_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L5_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000200030ull) + ((offset) & 1023) * 512;
@@ -1446,6 +1537,7 @@ static inline uint64_t CVMX_PKO_L5_SQX_SHAPE_STATE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L5_SQX_SW_XOFF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L5_SQX_SW_XOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00015400002000E0ull) + ((offset) & 1023) * 512;
@@ -1457,6 +1549,7 @@ static inline uint64_t CVMX_PKO_L5_SQX_SW_XOFF(unsigned long offset)
 static inline uint64_t CVMX_PKO_L5_SQX_TOPOLOGY(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L5_SQX_TOPOLOGY(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280000ull) + ((offset) & 1023) * 512;
@@ -1468,6 +1561,7 @@ static inline uint64_t CVMX_PKO_L5_SQX_TOPOLOGY(unsigned long offset)
 static inline uint64_t CVMX_PKO_L5_SQX_YELLOW(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L5_SQX_YELLOW(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000280060ull) + ((offset) & 1023) * 512;
@@ -1479,7 +1573,7 @@ static inline uint64_t CVMX_PKO_L5_SQX_YELLOW(unsigned long offset)
 #define CVMX_PKO_L5_SQ_CSR_BUS_DEBUG CVMX_PKO_L5_SQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_L5_SQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_L5_SQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400002801F8ull);
 }
@@ -1491,6 +1585,7 @@ static inline uint64_t CVMX_PKO_LUTX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 383))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 191)))))
 		cvmx_warn("CVMX_PKO_LUTX(%lu) is invalid on this chip\n", offset);
@@ -1503,7 +1598,7 @@ static inline uint64_t CVMX_PKO_LUTX(unsigned long offset)
 #define CVMX_PKO_LUT_BIST_STATUS CVMX_PKO_LUT_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_LUT_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_LUT_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000B02018ull);
 }
@@ -1514,7 +1609,7 @@ static inline uint64_t CVMX_PKO_LUT_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_LUT_ECC_CTL0 CVMX_PKO_LUT_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFD0ull);
 }
@@ -1525,7 +1620,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_DBE_STS0 CVMX_PKO_LUT_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFF0ull);
 }
@@ -1536,7 +1631,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_DBE_STS_CMB0 CVMX_PKO_LUT_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFD8ull);
 }
@@ -1547,7 +1642,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_SBE_STS0 CVMX_PKO_LUT_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFF8ull);
 }
@@ -1558,7 +1653,7 @@ static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_LUT_ECC_SBE_STS_CMB0 CVMX_PKO_LUT_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_LUT_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_LUT_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000BFFFE8ull);
 }
@@ -1570,6 +1665,7 @@ static inline uint64_t CVMX_PKO_MACX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 27))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 9)))))
 		cvmx_warn("CVMX_PKO_MACX_CFG(%lu) is invalid on this chip\n", offset);
@@ -1582,6 +1678,7 @@ static inline uint64_t CVMX_PKO_MACX_CFG(unsigned long offset)
 static inline uint64_t CVMX_PKO_MCI0_CRED_CNTX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 27))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_MCI0_CRED_CNTX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000A40000ull) + ((offset) & 31) * 8;
@@ -1593,6 +1690,7 @@ static inline uint64_t CVMX_PKO_MCI0_CRED_CNTX(unsigned long offset)
 static inline uint64_t CVMX_PKO_MCI0_MAX_CREDX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 27))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27)))))
 		cvmx_warn("CVMX_PKO_MCI0_MAX_CREDX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001540000A00000ull) + ((offset) & 31) * 8;
@@ -1605,6 +1703,7 @@ static inline uint64_t CVMX_PKO_MCI1_CRED_CNTX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 27))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 9)))))
 		cvmx_warn("CVMX_PKO_MCI1_CRED_CNTX(%lu) is invalid on this chip\n", offset);
@@ -1618,6 +1717,7 @@ static inline uint64_t CVMX_PKO_MCI1_MAX_CREDX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 13))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 27))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 9)))))
 		cvmx_warn("CVMX_PKO_MCI1_MAX_CREDX(%lu) is invalid on this chip\n", offset);
@@ -1789,7 +1889,7 @@ static inline uint64_t CVMX_PKO_MEM_THROTTLE_PIPE_FUNC(void)
 #define CVMX_PKO_NCB_BIST_STATUS CVMX_PKO_NCB_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_NCB_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_NCB_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFF00ull);
 }
@@ -1800,7 +1900,7 @@ static inline uint64_t CVMX_PKO_NCB_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_NCB_ECC_CTL0 CVMX_PKO_NCB_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFD0ull);
 }
@@ -1811,7 +1911,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_DBE_STS0 CVMX_PKO_NCB_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFF0ull);
 }
@@ -1822,7 +1922,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_DBE_STS_CMB0 CVMX_PKO_NCB_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFD8ull);
 }
@@ -1833,7 +1933,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_SBE_STS0 CVMX_PKO_NCB_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFF8ull);
 }
@@ -1844,7 +1944,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_NCB_ECC_SBE_STS_CMB0 CVMX_PKO_NCB_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_NCB_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000EFFFE8ull);
 }
@@ -1855,7 +1955,7 @@ static inline uint64_t CVMX_PKO_NCB_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_NCB_INT CVMX_PKO_NCB_INT_FUNC()
 static inline uint64_t CVMX_PKO_NCB_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_NCB_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000E00010ull);
 }
@@ -1866,7 +1966,7 @@ static inline uint64_t CVMX_PKO_NCB_INT_FUNC(void)
 #define CVMX_PKO_NCB_TX_ERR_INFO CVMX_PKO_NCB_TX_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_NCB_TX_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_NCB_TX_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000E00008ull);
 }
@@ -1877,7 +1977,7 @@ static inline uint64_t CVMX_PKO_NCB_TX_ERR_INFO_FUNC(void)
 #define CVMX_PKO_NCB_TX_ERR_WORD CVMX_PKO_NCB_TX_ERR_WORD_FUNC()
 static inline uint64_t CVMX_PKO_NCB_TX_ERR_WORD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_NCB_TX_ERR_WORD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000E00000ull);
 }
@@ -1888,7 +1988,7 @@ static inline uint64_t CVMX_PKO_NCB_TX_ERR_WORD_FUNC(void)
 #define CVMX_PKO_PDM_BIST_STATUS CVMX_PKO_PDM_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PDM_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFF00ull);
 }
@@ -1899,7 +1999,7 @@ static inline uint64_t CVMX_PKO_PDM_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PDM_CFG CVMX_PKO_PDM_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800000ull);
 }
@@ -1910,7 +2010,7 @@ static inline uint64_t CVMX_PKO_PDM_CFG_FUNC(void)
 #define CVMX_PKO_PDM_CFG_DBG CVMX_PKO_PDM_CFG_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_CFG_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_CFG_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800FF8ull);
 }
@@ -1921,7 +2021,7 @@ static inline uint64_t CVMX_PKO_PDM_CFG_DBG_FUNC(void)
 #define CVMX_PKO_PDM_CP_DBG CVMX_PKO_PDM_CP_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_CP_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_CP_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800190ull);
 }
@@ -1933,6 +2033,7 @@ static inline uint64_t CVMX_PKO_PDM_DQX_MINPAD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 255))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 255)))))
 		cvmx_warn("CVMX_PKO_PDM_DQX_MINPAD(%lu) is invalid on this chip\n", offset);
@@ -1945,7 +2046,7 @@ static inline uint64_t CVMX_PKO_PDM_DQX_MINPAD(unsigned long offset)
 #define CVMX_PKO_PDM_DRPBUF_DBG CVMX_PKO_PDM_DRPBUF_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_DRPBUF_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_DRPBUF_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008000B0ull);
 }
@@ -1956,7 +2057,7 @@ static inline uint64_t CVMX_PKO_PDM_DRPBUF_DBG_FUNC(void)
 #define CVMX_PKO_PDM_DWPBUF_DBG CVMX_PKO_PDM_DWPBUF_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_DWPBUF_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_DWPBUF_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008000A8ull);
 }
@@ -1967,7 +2068,7 @@ static inline uint64_t CVMX_PKO_PDM_DWPBUF_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ECC_CTL0 CVMX_PKO_PDM_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFD0ull);
 }
@@ -1978,7 +2079,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_CTL1 CVMX_PKO_PDM_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFD8ull);
 }
@@ -1989,7 +2090,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_CTL1_FUNC(void)
 #define CVMX_PKO_PDM_ECC_DBE_STS0 CVMX_PKO_PDM_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFF0ull);
 }
@@ -2000,7 +2101,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_DBE_STS_CMB0 CVMX_PKO_PDM_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFE0ull);
 }
@@ -2011,7 +2112,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_SBE_STS0 CVMX_PKO_PDM_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFF8ull);
 }
@@ -2022,7 +2123,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PDM_ECC_SBE_STS_CMB0 CVMX_PKO_PDM_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008FFFE8ull);
 }
@@ -2033,7 +2134,7 @@ static inline uint64_t CVMX_PKO_PDM_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PDM_FILLB_DBG0 CVMX_PKO_PDM_FILLB_DBG0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FILLB_DBG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_FILLB_DBG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002A0ull);
 }
@@ -2044,7 +2145,7 @@ static inline uint64_t CVMX_PKO_PDM_FILLB_DBG0_FUNC(void)
 #define CVMX_PKO_PDM_FILLB_DBG1 CVMX_PKO_PDM_FILLB_DBG1_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FILLB_DBG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_FILLB_DBG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002A8ull);
 }
@@ -2055,7 +2156,7 @@ static inline uint64_t CVMX_PKO_PDM_FILLB_DBG1_FUNC(void)
 #define CVMX_PKO_PDM_FILLB_DBG2 CVMX_PKO_PDM_FILLB_DBG2_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FILLB_DBG2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_FILLB_DBG2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002B0ull);
 }
@@ -2066,7 +2167,7 @@ static inline uint64_t CVMX_PKO_PDM_FILLB_DBG2_FUNC(void)
 #define CVMX_PKO_PDM_FLSHB_DBG0 CVMX_PKO_PDM_FLSHB_DBG0_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_FLSHB_DBG0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002B8ull);
 }
@@ -2077,7 +2178,7 @@ static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG0_FUNC(void)
 #define CVMX_PKO_PDM_FLSHB_DBG1 CVMX_PKO_PDM_FLSHB_DBG1_FUNC()
 static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_FLSHB_DBG1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008002C0ull);
 }
@@ -2088,7 +2189,7 @@ static inline uint64_t CVMX_PKO_PDM_FLSHB_DBG1_FUNC(void)
 #define CVMX_PKO_PDM_INTF_DBG_RD CVMX_PKO_PDM_INTF_DBG_RD_FUNC()
 static inline uint64_t CVMX_PKO_PDM_INTF_DBG_RD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_INTF_DBG_RD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900F20ull);
 }
@@ -2099,7 +2200,7 @@ static inline uint64_t CVMX_PKO_PDM_INTF_DBG_RD_FUNC(void)
 #define CVMX_PKO_PDM_ISRD_DBG CVMX_PKO_PDM_ISRD_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRD_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800090ull);
 }
@@ -2110,7 +2211,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ISRD_DBG_DQ CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRD_DBG_DQ not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800290ull);
 }
@@ -2121,7 +2222,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRD_DBG_DQ_FUNC(void)
 #define CVMX_PKO_PDM_ISRM_DBG CVMX_PKO_PDM_ISRM_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRM_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800098ull);
 }
@@ -2132,7 +2233,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_FUNC(void)
 #define CVMX_PKO_PDM_ISRM_DBG_DQ CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC()
 static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_ISRM_DBG_DQ not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800298ull);
 }
@@ -2143,7 +2244,7 @@ static inline uint64_t CVMX_PKO_PDM_ISRM_DBG_DQ_FUNC(void)
 #define CVMX_PKO_PDM_MEM_ADDR CVMX_PKO_PDM_MEM_ADDR_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_ADDR_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_ADDR not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800018ull);
 }
@@ -2154,7 +2255,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_ADDR_FUNC(void)
 #define CVMX_PKO_PDM_MEM_DATA CVMX_PKO_PDM_MEM_DATA_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_DATA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_DATA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800010ull);
 }
@@ -2165,7 +2266,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_DATA_FUNC(void)
 #define CVMX_PKO_PDM_MEM_RW_CTL CVMX_PKO_PDM_MEM_RW_CTL_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_RW_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_RW_CTL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800020ull);
 }
@@ -2176,7 +2277,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_RW_CTL_FUNC(void)
 #define CVMX_PKO_PDM_MEM_RW_STS CVMX_PKO_PDM_MEM_RW_STS_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MEM_RW_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_MEM_RW_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800028ull);
 }
@@ -2187,7 +2288,7 @@ static inline uint64_t CVMX_PKO_PDM_MEM_RW_STS_FUNC(void)
 #define CVMX_PKO_PDM_MWPBUF_DBG CVMX_PKO_PDM_MWPBUF_DBG_FUNC()
 static inline uint64_t CVMX_PKO_PDM_MWPBUF_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_MWPBUF_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400008000A0ull);
 }
@@ -2198,7 +2299,7 @@ static inline uint64_t CVMX_PKO_PDM_MWPBUF_DBG_FUNC(void)
 #define CVMX_PKO_PDM_STS CVMX_PKO_PDM_STS_FUNC()
 static inline uint64_t CVMX_PKO_PDM_STS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PDM_STS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000800008ull);
 }
@@ -2209,7 +2310,7 @@ static inline uint64_t CVMX_PKO_PDM_STS_FUNC(void)
 #define CVMX_PKO_PEB_BIST_STATUS CVMX_PKO_PEB_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PEB_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900D00ull);
 }
@@ -2220,7 +2321,7 @@ static inline uint64_t CVMX_PKO_PEB_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PEB_ECC_CTL0 CVMX_PKO_PEB_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFD0ull);
 }
@@ -2231,7 +2332,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_CTL1 CVMX_PKO_PEB_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFA8ull);
 }
@@ -2242,7 +2343,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_CTL1_FUNC(void)
 #define CVMX_PKO_PEB_ECC_DBE_STS0 CVMX_PKO_PEB_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFF0ull);
 }
@@ -2253,7 +2354,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_DBE_STS_CMB0 CVMX_PKO_PEB_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFD8ull);
 }
@@ -2264,7 +2365,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_SBE_STS0 CVMX_PKO_PEB_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFF8ull);
 }
@@ -2275,7 +2376,7 @@ static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PEB_ECC_SBE_STS_CMB0 CVMX_PKO_PEB_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400009FFFE8ull);
 }
@@ -2297,7 +2398,7 @@ static inline uint64_t CVMX_PKO_PEB_ECO_FUNC(void)
 #define CVMX_PKO_PEB_ERR_INT CVMX_PKO_PEB_ERR_INT_FUNC()
 static inline uint64_t CVMX_PKO_PEB_ERR_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_ERR_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C00ull);
 }
@@ -2308,7 +2409,7 @@ static inline uint64_t CVMX_PKO_PEB_ERR_INT_FUNC(void)
 #define CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C08ull);
 }
@@ -2319,7 +2420,7 @@ static inline uint64_t CVMX_PKO_PEB_EXT_HDR_DEF_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_FCS_SOP_ERR_INFO CVMX_PKO_PEB_FCS_SOP_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_FCS_SOP_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_FCS_SOP_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C18ull);
 }
@@ -2330,7 +2431,7 @@ static inline uint64_t CVMX_PKO_PEB_FCS_SOP_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_JUMP_DEF_ERR_INFO CVMX_PKO_PEB_JUMP_DEF_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_JUMP_DEF_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_JUMP_DEF_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C10ull);
 }
@@ -2341,7 +2442,7 @@ static inline uint64_t CVMX_PKO_PEB_JUMP_DEF_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C50ull);
 }
@@ -2352,7 +2453,7 @@ static inline uint64_t CVMX_PKO_PEB_MACX_CFG_WR_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_MAX_LINK_ERR_INFO CVMX_PKO_PEB_MAX_LINK_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_MAX_LINK_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_MAX_LINK_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C48ull);
 }
@@ -2363,7 +2464,7 @@ static inline uint64_t CVMX_PKO_PEB_MAX_LINK_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_NCB_CFG CVMX_PKO_PEB_NCB_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PEB_NCB_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_NCB_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900308ull);
 }
@@ -2374,7 +2475,7 @@ static inline uint64_t CVMX_PKO_PEB_NCB_CFG_FUNC(void)
 #define CVMX_PKO_PEB_PAD_ERR_INFO CVMX_PKO_PEB_PAD_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_PAD_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_PAD_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C28ull);
 }
@@ -2385,7 +2486,7 @@ static inline uint64_t CVMX_PKO_PEB_PAD_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_PSE_FIFO_ERR_INFO CVMX_PKO_PEB_PSE_FIFO_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_PSE_FIFO_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_PSE_FIFO_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C20ull);
 }
@@ -2396,7 +2497,7 @@ static inline uint64_t CVMX_PKO_PEB_PSE_FIFO_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C38ull);
 }
@@ -2407,7 +2508,7 @@ static inline uint64_t CVMX_PKO_PEB_SUBD_ADDR_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C40ull);
 }
@@ -2418,7 +2519,7 @@ static inline uint64_t CVMX_PKO_PEB_SUBD_SIZE_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_TRUNC_ERR_INFO CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC()
 static inline uint64_t CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_TRUNC_ERR_INFO not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900C30ull);
 }
@@ -2429,7 +2530,7 @@ static inline uint64_t CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_TSO_CFG CVMX_PKO_PEB_TSO_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PEB_TSO_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PEB_TSO_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900310ull);
 }
@@ -2440,7 +2541,7 @@ static inline uint64_t CVMX_PKO_PEB_TSO_CFG_FUNC(void)
 #define CVMX_PKO_PQA_DEBUG CVMX_PKO_PQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_PQA_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PQA_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000128ull);
 }
@@ -2451,7 +2552,7 @@ static inline uint64_t CVMX_PKO_PQA_DEBUG_FUNC(void)
 #define CVMX_PKO_PQB_DEBUG CVMX_PKO_PQB_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_PQB_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PQB_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000130ull);
 }
@@ -2462,7 +2563,7 @@ static inline uint64_t CVMX_PKO_PQB_DEBUG_FUNC(void)
 #define CVMX_PKO_PQ_CSR_BUS_DEBUG CVMX_PKO_PQ_CSR_BUS_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_PQ_CSR_BUS_DEBUG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PQ_CSR_BUS_DEBUG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000001F8ull);
 }
@@ -2473,7 +2574,7 @@ static inline uint64_t CVMX_PKO_PQ_CSR_BUS_DEBUG_FUNC(void)
 #define CVMX_PKO_PQ_DEBUG_GREEN CVMX_PKO_PQ_DEBUG_GREEN_FUNC()
 static inline uint64_t CVMX_PKO_PQ_DEBUG_GREEN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PQ_DEBUG_GREEN not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000058ull);
 }
@@ -2484,7 +2585,7 @@ static inline uint64_t CVMX_PKO_PQ_DEBUG_GREEN_FUNC(void)
 #define CVMX_PKO_PQ_DEBUG_LINKS CVMX_PKO_PQ_DEBUG_LINKS_FUNC()
 static inline uint64_t CVMX_PKO_PQ_DEBUG_LINKS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PQ_DEBUG_LINKS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000068ull);
 }
@@ -2495,7 +2596,7 @@ static inline uint64_t CVMX_PKO_PQ_DEBUG_LINKS_FUNC(void)
 #define CVMX_PKO_PQ_DEBUG_YELLOW CVMX_PKO_PQ_DEBUG_YELLOW_FUNC()
 static inline uint64_t CVMX_PKO_PQ_DEBUG_YELLOW_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PQ_DEBUG_YELLOW not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000060ull);
 }
@@ -2506,7 +2607,7 @@ static inline uint64_t CVMX_PKO_PQ_DEBUG_YELLOW_FUNC(void)
 #define CVMX_PKO_PSE_DQ_BIST_STATUS CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300138ull);
 }
@@ -2517,7 +2618,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_CTL0 CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300100ull);
 }
@@ -2528,7 +2629,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_DBE_STS0 CVMX_PKO_PSE_DQ_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300118ull);
 }
@@ -2539,7 +2640,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300120ull);
 }
@@ -2550,7 +2651,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_SBE_STS0 CVMX_PKO_PSE_DQ_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300108ull);
 }
@@ -2561,7 +2662,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000300110ull);
 }
@@ -2572,7 +2673,7 @@ static inline uint64_t CVMX_PKO_PSE_DQ_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_BIST_STATUS CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000138ull);
 }
@@ -2583,7 +2684,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_CTL0 CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000100ull);
 }
@@ -2594,7 +2695,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_DBE_STS0 CVMX_PKO_PSE_PQ_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000118ull);
 }
@@ -2605,7 +2706,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000120ull);
 }
@@ -2616,7 +2717,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_SBE_STS0 CVMX_PKO_PSE_PQ_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000108ull);
 }
@@ -2627,7 +2728,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000000110ull);
 }
@@ -2638,7 +2739,7 @@ static inline uint64_t CVMX_PKO_PSE_PQ_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_BIST_STATUS CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080138ull);
 }
@@ -2649,7 +2750,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_CTL0 CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080100ull);
 }
@@ -2660,7 +2761,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_DBE_STS0 CVMX_PKO_PSE_SQ1_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080118ull);
 }
@@ -2671,7 +2772,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080120ull);
 }
@@ -2682,7 +2783,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_SBE_STS0 CVMX_PKO_PSE_SQ1_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080108ull);
 }
@@ -2693,7 +2794,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000080110ull);
 }
@@ -2704,7 +2805,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ1_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_BIST_STATUS CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100138ull);
 }
@@ -2715,7 +2816,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_CTL0 CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100100ull);
 }
@@ -2726,7 +2827,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_DBE_STS0 CVMX_PKO_PSE_SQ2_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100118ull);
 }
@@ -2737,7 +2838,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100120ull);
 }
@@ -2748,7 +2849,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_SBE_STS0 CVMX_PKO_PSE_SQ2_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100108ull);
 }
@@ -2759,7 +2860,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000100110ull);
 }
@@ -2770,7 +2871,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ2_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_BIST_STATUS CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180138ull);
 }
@@ -2781,7 +2882,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_CTL0 CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180100ull);
 }
@@ -2792,7 +2893,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_DBE_STS0 CVMX_PKO_PSE_SQ3_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180118ull);
 }
@@ -2803,7 +2904,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180120ull);
 }
@@ -2814,7 +2915,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_SBE_STS0 CVMX_PKO_PSE_SQ3_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180108ull);
 }
@@ -2825,7 +2926,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000180110ull);
 }
@@ -2836,7 +2937,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ3_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ4_BIST_STATUS CVMX_PKO_PSE_SQ4_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ4_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_PSE_SQ4_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000200138ull);
 }
@@ -2847,7 +2948,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ4_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ4_ECC_CTL0 CVMX_PKO_PSE_SQ4_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ4_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_PSE_SQ4_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000200100ull);
 }
@@ -2858,7 +2959,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ4_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ4_ECC_DBE_STS0 CVMX_PKO_PSE_SQ4_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ4_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_PSE_SQ4_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000200118ull);
 }
@@ -2869,7 +2970,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ4_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ4_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ4_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ4_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_PSE_SQ4_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000200120ull);
 }
@@ -2880,7 +2981,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ4_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ4_ECC_SBE_STS0 CVMX_PKO_PSE_SQ4_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ4_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_PSE_SQ4_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000200108ull);
 }
@@ -2891,7 +2992,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ4_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ4_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ4_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ4_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_PSE_SQ4_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000200110ull);
 }
@@ -2902,7 +3003,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ4_ECC_SBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ5_BIST_STATUS CVMX_PKO_PSE_SQ5_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ5_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_PSE_SQ5_BIST_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000280138ull);
 }
@@ -2913,7 +3014,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ5_BIST_STATUS_FUNC(void)
 #define CVMX_PKO_PSE_SQ5_ECC_CTL0 CVMX_PKO_PSE_SQ5_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ5_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_PSE_SQ5_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000280100ull);
 }
@@ -2924,7 +3025,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ5_ECC_CTL0_FUNC(void)
 #define CVMX_PKO_PSE_SQ5_ECC_DBE_STS0 CVMX_PKO_PSE_SQ5_ECC_DBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ5_ECC_DBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_PSE_SQ5_ECC_DBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000280118ull);
 }
@@ -2935,7 +3036,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ5_ECC_DBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ5_ECC_DBE_STS_CMB0 CVMX_PKO_PSE_SQ5_ECC_DBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ5_ECC_DBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_PSE_SQ5_ECC_DBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000280120ull);
 }
@@ -2946,7 +3047,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ5_ECC_DBE_STS_CMB0_FUNC(void)
 #define CVMX_PKO_PSE_SQ5_ECC_SBE_STS0 CVMX_PKO_PSE_SQ5_ECC_SBE_STS0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ5_ECC_SBE_STS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_PSE_SQ5_ECC_SBE_STS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000280108ull);
 }
@@ -2957,7 +3058,7 @@ static inline uint64_t CVMX_PKO_PSE_SQ5_ECC_SBE_STS0_FUNC(void)
 #define CVMX_PKO_PSE_SQ5_ECC_SBE_STS_CMB0 CVMX_PKO_PSE_SQ5_ECC_SBE_STS_CMB0_FUNC()
 static inline uint64_t CVMX_PKO_PSE_SQ5_ECC_SBE_STS_CMB0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_PKO_PSE_SQ5_ECC_SBE_STS_CMB0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000280110ull);
 }
@@ -2969,6 +3070,7 @@ static inline uint64_t CVMX_PKO_PTFX_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 27))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_PTFX_STATUS(%lu) is invalid on this chip\n", offset);
@@ -2981,7 +3083,7 @@ static inline uint64_t CVMX_PKO_PTFX_STATUS(unsigned long offset)
 #define CVMX_PKO_PTF_IOBP_CFG CVMX_PKO_PTF_IOBP_CFG_FUNC()
 static inline uint64_t CVMX_PKO_PTF_IOBP_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_PTF_IOBP_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000900300ull);
 }
@@ -2993,6 +3095,7 @@ static inline uint64_t CVMX_PKO_PTGFX_CFG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 7))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_PKO_PTGFX_CFG(%lu) is invalid on this chip\n", offset);
@@ -3235,7 +3338,7 @@ static inline uint64_t CVMX_PKO_REG_TIMESTAMP_FUNC(void)
 #define CVMX_PKO_SHAPER_CFG CVMX_PKO_SHAPER_CFG_FUNC()
 static inline uint64_t CVMX_PKO_SHAPER_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_SHAPER_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00015400000800F8ull);
 }
@@ -3247,6 +3350,7 @@ static inline uint64_t CVMX_PKO_STATE_UID_IN_USEX_RD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PKO_STATE_UID_IN_USEX_RD(%lu) is invalid on this chip\n", offset);
@@ -3259,7 +3363,7 @@ static inline uint64_t CVMX_PKO_STATE_UID_IN_USEX_RD(unsigned long offset)
 #define CVMX_PKO_STATUS CVMX_PKO_STATUS_FUNC()
 static inline uint64_t CVMX_PKO_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_PKO_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001540000D00000ull);
 }
@@ -3271,6 +3375,7 @@ static inline uint64_t CVMX_PKO_TXFX_PKT_CNT_RD(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 27))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 27))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_PKO_TXFX_PKT_CNT_RD(%lu) is invalid on this chip\n", offset);
@@ -3290,7 +3395,9 @@ union cvmx_pko_channel_level {
 	uint64_t reserved_1_63                : 63;
 	uint64_t cc_level                     : 1;  /**< Channel credit level. Channels can be configured at levels 2 or 3 of the PSE hierarchy.
                                                          0 = Selects the level-2 as the channel level.
-                                                         1 = Selects the level-3 as the channel level. */
+                                                         1 = Selects the level-3 as the channel level.
+                                                         [CC_LEVEL] determines whether PKO_L3_L2_SQ()_CHANNEL is associated with the L2 SQ's or
+                                                         the L3 SQ's. */
 #else
 	uint64_t cc_level                     : 1;
 	uint64_t reserved_1_63                : 63;
@@ -3359,8 +3466,7 @@ union cvmx_pko_dpfi_fpa_aura {
 	struct cvmx_pko_dpfi_fpa_aura_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
-	uint64_t node                         : 2;  /**< Reserved. INTERNAL:
-                                                         Node number of current chip, to ensure that the aura is on the local node. */
+	uint64_t node                         : 2;  /**< Reserved. */
 	uint64_t laura                        : 10; /**< FPA local-node aura to use for PKO command buffering allocations and frees. The
                                                          FPA aura selected by LAURA must correspond to a pool where the buffers (after
                                                          any FPA_POOL()_CFG[BUF_OFFSET]) are at least 4 KB. */
@@ -3427,7 +3533,7 @@ union cvmx_pko_dpfi_status {
 	uint64_t ptr_rtn_pend                 : 1;  /**< DPFI has pointer returns to FPA pending. */
 	uint64_t fpa_empty                    : 1;  /**< FPA empty status:
                                                          0 = FPA is providing pointers when requested.
-                                                         1 = FPA responded to pointer request with 'no pointers available.' */
+                                                         1 = FPA responded to pointer request with 'no pointers available'. */
 	uint64_t dpfi_empty                   : 1;  /**< DPFI pointer cache is empty. */
 	uint64_t cache_flushed                : 1;  /**< Cache flushed:
                                                          0 = Cache flush not enabled or in-progress.
@@ -3473,7 +3579,7 @@ union cvmx_pko_dpfi_status {
 	uint64_t ptr_rtn_pend                 : 1;  /**< DPFI has pointer returns to FPA pending. */
 	uint64_t fpa_empty                    : 1;  /**< FPA empty status:
                                                          0 = FPA is providing pointers when requested.
-                                                         1 = FPA responded to pointer request with 'no pointers available.' */
+                                                         1 = FPA responded to pointer request with 'no pointers available'. */
 	uint64_t dpfi_empty                   : 1;  /**< DPFI pointer cache is empty. */
 	uint64_t cache_flushed                : 1;  /**< Cache flushed:
                                                          0 = Cache flush not enabled or in-progress.
@@ -4102,7 +4208,13 @@ union cvmx_pko_dqx_wm_buf_cnt {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
 	uint64_t count                        : 36; /**< Watermark buffer count. The number of buffers allocated (from
-                                                         FPA aura PKO_DPFI_FPA_AURA[NODE,LAURA]) for this DQ. */
+                                                         FPA aura PKO_DPFI_FPA_AURA[NODE,LAURA]) for this DQ.
+                                                         Note that there is a worstcase watermark accuracy error from hardware of 167 pointers.
+                                                         This means that the CSR read could have 167 pointers unaccounted for in the read data from
+                                                         send-packets queued up in PDM. Note the maximum error is smaller if TSO is not used; with
+                                                         no TSO the max number of pointers the hardware is off by should be 8. Because software
+                                                         doesn't know which DQs have unaccounted for pointers, it must assume every queue is off by
+                                                         the max number of pointers (167 if TSO, 8 if no TSO). */
 #else
 	uint64_t count                        : 36;
 	uint64_t reserved_36_63               : 28;
@@ -5944,13 +6056,16 @@ typedef union cvmx_pko_l2_sqb_debug cvmx_pko_l2_sqb_debug_t;
 
 /**
  * cvmx_pko_l3_l2_sq#_channel
+ *
+ * PKO_CHANNEL_LEVEL[CC_LEVEL] determines whether this CSR array is associated to
+ * the L2 SQ's or the L3 SQ's.
  */
 union cvmx_pko_l3_l2_sqx_channel {
 	uint64_t u64;
 	struct cvmx_pko_l3_l2_sqx_channel_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_44_63               : 20;
-	uint64_t cc_channel                   : 12; /**< Channel ID. */
+	uint64_t cc_channel                   : 12; /**< Channel ID. See PKI_CHAN_E. */
 	uint64_t cc_word_cnt                  : 20; /**< Channel credit word count. This value, plus 1 MTU, represents the maximum outstanding word
                                                          count for this channel. (Words are 16 bytes.) Note that this 20-bit field represents a
                                                          signed value that decrements towards zero as credits are used. Packets are not allowed to
@@ -7759,8 +7874,12 @@ union cvmx_pko_lutx {
 	uint64_t reserved_16_63               : 48;
 	uint64_t valid                        : 1;  /**< Declares if the index in the LUT is valid. */
 	uint64_t reserved_14_14               : 1;
-	uint64_t pq_idx                       : 5;  /**< PQ index for channel return processing in the PSE. */
-	uint64_t queue_number                 : 9;  /**< Mapping from this channel to the programmed queue number. */
+	uint64_t pq_idx                       : 5;  /**< When [VALID] is set, [PQ_IDX] must select the L1 SQ that services the L2/L3 SQ that
+                                                         is selected by [QUEUE_NUMBER]. */
+	uint64_t queue_number                 : 9;  /**< When [VALID] is set, [QUEUE_NUMBER] selects the PKO_L3_L2_SQ()_CHANNEL CSR array entry
+                                                         for the PKO_LUT entry. This also selects an associated L2/L3 SQ.
+                                                         PKO_CHANNEL_LEVEL[CC_LEVEL]
+                                                         determines whether [QUEUE_NUMBER] selects an L2 SQ or a L3 SQ. */
 #else
 	uint64_t queue_number                 : 9;
 	uint64_t pq_idx                       : 5;
@@ -7774,9 +7893,13 @@ union cvmx_pko_lutx {
 	uint64_t reserved_16_63               : 48;
 	uint64_t valid                        : 1;  /**< Declares if the index in the LUT is valid. */
 	uint64_t reserved_13_14               : 2;
-	uint64_t pq_idx                       : 4;  /**< PQ index for channel return processing in the PSE. */
+	uint64_t pq_idx                       : 4;  /**< When [VALID] is set, [PQ_IDX] must select the L1 SQ that services the L2/L3 SQ that
+                                                         is selected by [QUEUE_NUMBER]. */
 	uint64_t reserved_8_8                 : 1;
-	uint64_t queue_number                 : 8;  /**< Mapping from this channel to the programmed queue number. */
+	uint64_t queue_number                 : 8;  /**< When [VALID] is set, [QUEUE_NUMBER] selects the PKO_L3_L2_SQ()_CHANNEL CSR array entry
+                                                         for the PKO_LUT entry. This also selects an associated L2/L3 SQ.
+                                                         PKO_CHANNEL_LEVEL[CC_LEVEL]
+                                                         determines whether [QUEUE_NUMBER] selects an L2 SQ or a L3 SQ. */
 #else
 	uint64_t queue_number                 : 8;
 	uint64_t reserved_8_8                 : 1;
@@ -7843,8 +7966,7 @@ union cvmx_pko_lut_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_lut_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t c2q_lut_ram_dbe              : 1;  /**< Double-bit error for C2Q_LUT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.pko_c2q_lut.pko_c2q_lut_ram_i */
+	uint64_t c2q_lut_ram_dbe              : 1;  /**< Double-bit error for C2Q_LUT_RAM. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -7868,8 +7990,7 @@ union cvmx_pko_lut_ecc_dbe_sts_cmb0 {
 	uint64_t lut_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_LUT_ECC_DBE_STS0. To clear this bit,
                                                          software
                                                          must clear bits in PKO_LUT_ECC_DBE_STS0. When this bit is set, the corresponding interrupt
-                                                         is set. Throws PKO_INTSN_E::PKO_LUT_DBE_CMB0. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.pko_c2q_lut.pko_c2q_lut_ram_i */
+                                                         is set. Throws PKO_INTSN_E::PKO_LUT_DBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -7890,8 +8011,7 @@ union cvmx_pko_lut_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_lut_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t c2q_lut_ram_sbe              : 1;  /**< Single-bit error for C2Q_LUT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.pko_c2q_lut.pko_c2q_lut_ram_i */
+	uint64_t c2q_lut_ram_sbe              : 1;  /**< Single-bit error for C2Q_LUT_RAM. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -7915,8 +8035,7 @@ union cvmx_pko_lut_ecc_sbe_sts_cmb0 {
 	uint64_t lut_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_LUT_ECC_SBE_STS0. To clear this bit,
                                                          software
                                                          must clear bits in PKO_LUT_ECC_SBE_STS0. When this bit is set, the corresponding interrupt
-                                                         is set. Throws PKO_INTSN_E::PKO_LUT_SBE_CMB0. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.pko_c2q_lut.pko_c2q_lut_ram_i */
+                                                         is set. Throws PKO_INTSN_E::PKO_LUT_SBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -10207,18 +10326,12 @@ union cvmx_pko_ncb_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_ncb_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ncbi_l2_out_ram_dbe          : 1;  /**< Double-bit error for NCBI_L2_OUT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo */
-	uint64_t ncbi_pp_out_ram_dbe          : 1;  /**< Double-bit error for NCBI_PP_OUT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo */
-	uint64_t ncbo_pdm_cmd_dat_ram_dbe     : 1;  /**< Double-bit error for NCBO_PDM_CMD_DAT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo */
-	uint64_t ncbi_l2_pdm_pref_ram_dbe     : 1;  /**< Double-bit error for NCBI_L2_PDM_PREF_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo */
-	uint64_t ncbo_pp_fif_ram_dbe          : 1;  /**< Double-bit error for NCBO_PP_FIF_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
-	uint64_t ncbo_skid_fif_ram_dbe        : 1;  /**< Double-bit error for NCBO_SKID_FIF_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.skid_fifo */
+	uint64_t ncbi_l2_out_ram_dbe          : 1;  /**< Double-bit error for NCBI_L2_OUT_RAM. */
+	uint64_t ncbi_pp_out_ram_dbe          : 1;  /**< Double-bit error for NCBI_PP_OUT_RAM. */
+	uint64_t ncbo_pdm_cmd_dat_ram_dbe     : 1;  /**< Double-bit error for NCBO_PDM_CMD_DAT_RAM. */
+	uint64_t ncbi_l2_pdm_pref_ram_dbe     : 1;  /**< Double-bit error for NCBI_L2_PDM_PREF_RAM. */
+	uint64_t ncbo_pp_fif_ram_dbe          : 1;  /**< Double-bit error for NCBO_PP_FIF_RAM. */
+	uint64_t ncbo_skid_fif_ram_dbe        : 1;  /**< Double-bit error for NCBO_SKID_FIF_RAM. */
 	uint64_t reserved_0_57                : 58;
 #else
 	uint64_t reserved_0_57                : 58;
@@ -10247,13 +10360,7 @@ union cvmx_pko_ncb_ecc_dbe_sts_cmb0 {
 	uint64_t ncb_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_NCB_ECC_DBE_STS0. To clear this bit,
                                                          software
                                                          must clear bits in PKO_NCB_ECC_DBE_STS0. When this bit is set, the corresponding interrupt
-                                                         is set. Throws PKO_INTSN_E::PKO_NCB_DBE_CMB0. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo
-                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo
-                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.skid_fifo */
+                                                         is set. Throws PKO_INTSN_E::PKO_NCB_DBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -10274,18 +10381,12 @@ union cvmx_pko_ncb_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_ncb_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ncbi_l2_out_ram_sbe          : 1;  /**< Single-bit error for NCBI_L2_OUT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo */
-	uint64_t ncbi_pp_out_ram_sbe          : 1;  /**< Single-bit error for NCBI_PP_OUT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo */
-	uint64_t ncbo_pdm_cmd_dat_ram_sbe     : 1;  /**< Single-bit error for NCBO_PDM_CMD_DAT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo */
-	uint64_t ncbi_l2_pdm_pref_ram_sbe     : 1;  /**< Single-bit error for NCBI_L2_PDM_PREF_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo */
-	uint64_t ncbo_pp_fif_ram_sbe          : 1;  /**< Single-bit error for NCBO_PP_FIF_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
-	uint64_t ncbo_skid_fif_ram_sbe        : 1;  /**< Single-bit error for NCBO_PP_FIF_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo */
+	uint64_t ncbi_l2_out_ram_sbe          : 1;  /**< Single-bit error for NCBI_L2_OUT_RAM. */
+	uint64_t ncbi_pp_out_ram_sbe          : 1;  /**< Single-bit error for NCBI_PP_OUT_RAM. */
+	uint64_t ncbo_pdm_cmd_dat_ram_sbe     : 1;  /**< Single-bit error for NCBO_PDM_CMD_DAT_RAM. */
+	uint64_t ncbi_l2_pdm_pref_ram_sbe     : 1;  /**< Single-bit error for NCBI_L2_PDM_PREF_RAM. */
+	uint64_t ncbo_pp_fif_ram_sbe          : 1;  /**< Single-bit error for NCBO_PP_FIF_RAM. */
+	uint64_t ncbo_skid_fif_ram_sbe        : 1;  /**< Single-bit error for NCBO_PP_FIF_RAM. */
 	uint64_t reserved_0_57                : 58;
 #else
 	uint64_t reserved_0_57                : 58;
@@ -10314,13 +10415,7 @@ union cvmx_pko_ncb_ecc_sbe_sts_cmb0 {
 	uint64_t ncb_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_NCB_ECC_SBE_STS0. To clear this bit,
                                                          software
                                                          must clear bits in PKO_NCB_ECC_SBE_STS0. When this bit is set, the corresponding interrupt
-                                                         is set. Throws PKO_INTSN_E::PKO_NCB_SBE_CMB0. INTERNAL: Instances:
-                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.l2_out_fifo
-                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_txr.pp_out_fifo
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.ncb__pdm_cmnd_data_fifo
-                                                         pko_pnr2.nonpse.ncb.pko_ncbi_outb.ncbi_l2_pipe.pdm_prefbuf_fifo
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.pp_fifo
-                                                         pko_pnr2.nonpse.ncb.pko_ncbo_inb.splitter.skid_fifo */
+                                                         is set. Throws PKO_INTSN_E::PKO_NCB_SBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -10556,7 +10651,7 @@ union cvmx_pko_pdm_cfg_dbg {
 	uint64_t reserved_32_63               : 32;
 	uint64_t cp_stall_thrshld             : 32; /**< Program this register to the 32-bit number of cycles to test for the PDM(CP) stalled on
                                                          inputs going into the ISRs. PKO_PDM_STS[CP_STALL_THRSHLD_HIT] indicates the threshold has
-                                                         been hit. INTERNAL: Do not list field in HRM. For lab debug only. */
+                                                         been hit. */
 #else
 	uint64_t cp_stall_thrshld             : 32;
 	uint64_t reserved_32_63               : 32;
@@ -11001,53 +11096,30 @@ union cvmx_pko_pdm_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pdm_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t flshb_cache_lo_ram_dbe       : 1;  /**< Double-bit error for FLSHB_CACHE_LO_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_lo */
-	uint64_t flshb_cache_hi_ram_dbe       : 1;  /**< Double-bit error for FLSHB_CACHE_HI_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_hi */
-	uint64_t isrm_ca_iinst_ram_dbe        : 1;  /**< Double-bit error for ISRM_CA_IINST_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.iinst_in_fif */
-	uint64_t isrm_ca_cm_ram_dbe           : 1;  /**< Double-bit error for ISRM_CA_CM_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.cred_accum_ctrlr_and_mem.cred_accum_spr */
-	uint64_t isrm_st_ram2_dbe             : 1;  /**< Double-bit error for ISRM_ST_RAM2. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem2 */
-	uint64_t isrm_st_ram1_dbe             : 1;  /**< Double-bit error for ISRM_ST_RAM1. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem1 */
-	uint64_t isrm_st_ram0_dbe             : 1;  /**< Double-bit error for ISRM_ST_RAM0. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem0 */
-	uint64_t isrd_st_ram3_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM3. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem3 */
-	uint64_t isrd_st_ram2_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM2. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem2 */
-	uint64_t isrd_st_ram1_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM1. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem1 */
-	uint64_t isrd_st_ram0_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM0. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem0 */
-	uint64_t drp_hi_ram_dbe               : 1;  /**< Double-bit error for DRP_HI_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_1 */
-	uint64_t drp_lo_ram_dbe               : 1;  /**< Double-bit error for DRP_LO_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_2 */
-	uint64_t dwp_hi_ram_dbe               : 1;  /**< Double-bit error for DWP_HI_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_high */
-	uint64_t dwp_lo_ram_dbe               : 1;  /**< Double-bit error for DWP_LO_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_low */
-	uint64_t mwp_hi_ram_dbe               : 1;  /**< Double-bit error for MWP_RAM_PBUF_MEM2. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem2 */
-	uint64_t mwp_lo_ram_dbe               : 1;  /**< Double-bit error for MWP_RAM_PBUF_MEM0. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem0 */
-	uint64_t fillb_m_rsp_ram_hi_dbe       : 1;  /**< Double-bit error for FILLB_M_DAT_RAM_HI. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_ram_hi */
-	uint64_t fillb_m_rsp_ram_lo_dbe       : 1;  /**< Double-bit error for FILLB_D_DAT_RAM_LO. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_ram_lo */
-	uint64_t fillb_d_rsp_ram_hi_dbe       : 1;  /**< Double-bit error for FILLB_D_DAT_RAM_HI. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_hi */
-	uint64_t fillb_d_rsp_ram_lo_dbe       : 1;  /**< Double-bit error for FILLB_D_DAT_RAM_LO. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_lo */
-	uint64_t minpad_ram_dbe               : 1;  /**< Double-bit error for MINPAD_RAM. INTERNAL: Instances: pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
-	uint64_t mwp_hi_spt_ram_dbe           : 1;  /**< Double-bit error for MWP_RAM_PBUF_MEM3. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem3 */
-	uint64_t mwp_lo_spt_ram_dbe           : 1;  /**< Double-bit error for MWP_RAM_PBUF_MEM1. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem1 */
+	uint64_t flshb_cache_lo_ram_dbe       : 1;  /**< Double-bit error for FLSHB_CACHE_LO_RAM. */
+	uint64_t flshb_cache_hi_ram_dbe       : 1;  /**< Double-bit error for FLSHB_CACHE_HI_RAM. */
+	uint64_t isrm_ca_iinst_ram_dbe        : 1;  /**< Double-bit error for ISRM_CA_IINST_RAM. */
+	uint64_t isrm_ca_cm_ram_dbe           : 1;  /**< Double-bit error for ISRM_CA_CM_RAM. */
+	uint64_t isrm_st_ram2_dbe             : 1;  /**< Double-bit error for ISRM_ST_RAM2. */
+	uint64_t isrm_st_ram1_dbe             : 1;  /**< Double-bit error for ISRM_ST_RAM1. */
+	uint64_t isrm_st_ram0_dbe             : 1;  /**< Double-bit error for ISRM_ST_RAM0. */
+	uint64_t isrd_st_ram3_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM3. */
+	uint64_t isrd_st_ram2_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM2. */
+	uint64_t isrd_st_ram1_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM1. */
+	uint64_t isrd_st_ram0_dbe             : 1;  /**< Double-bit error for ISRD_ST_RAM0. */
+	uint64_t drp_hi_ram_dbe               : 1;  /**< Double-bit error for DRP_HI_RAM. */
+	uint64_t drp_lo_ram_dbe               : 1;  /**< Double-bit error for DRP_LO_RAM. */
+	uint64_t dwp_hi_ram_dbe               : 1;  /**< Double-bit error for DWP_HI_RAM. */
+	uint64_t dwp_lo_ram_dbe               : 1;  /**< Double-bit error for DWP_LO_RAM. */
+	uint64_t mwp_hi_ram_dbe               : 1;  /**< Double-bit error for MWP_RAM_PBUF_MEM2. */
+	uint64_t mwp_lo_ram_dbe               : 1;  /**< Double-bit error for MWP_RAM_PBUF_MEM0. */
+	uint64_t fillb_m_rsp_ram_hi_dbe       : 1;  /**< Double-bit error for FILLB_M_DAT_RAM_HI. */
+	uint64_t fillb_m_rsp_ram_lo_dbe       : 1;  /**< Double-bit error for FILLB_D_DAT_RAM_LO. */
+	uint64_t fillb_d_rsp_ram_hi_dbe       : 1;  /**< Double-bit error for FILLB_D_DAT_RAM_HI. */
+	uint64_t fillb_d_rsp_ram_lo_dbe       : 1;  /**< Double-bit error for FILLB_D_DAT_RAM_LO. */
+	uint64_t minpad_ram_dbe               : 1;  /**< Double-bit error for MINPAD_RAM. */
+	uint64_t mwp_hi_spt_ram_dbe           : 1;  /**< Double-bit error for MWP_RAM_PBUF_MEM3. */
+	uint64_t mwp_lo_spt_ram_dbe           : 1;  /**< Double-bit error for MWP_RAM_PBUF_MEM1. */
 	uint64_t buf_wm_ram_dbe               : 1;  /**< Double-bit error for BUF_WM_RAM. */
 	uint64_t reserved_0_38                : 39;
 #else
@@ -11096,28 +11168,7 @@ union cvmx_pko_pdm_ecc_dbe_sts_cmb0 {
 	uint64_t pdm_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_PDM_ECC_DBE_STS0. To clear this bit,
                                                          software
                                                          must clear bits in PKO_PDM_ECC_DBE_STS0. When this bit is set, the corresponding interrupt
-                                                         is set. Throws PKO_INTSN_E::PKO_PDM_DBE_CMB0. INTERNAL: Instances:
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_hi
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_lo
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.iinst_in_fif
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.cred_accum_ctrlr_and_mem.cred_
-                                                         accum_spr fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem0
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem1
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem2
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem0
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem1
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem2
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem3
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_1
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_2
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_low
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_high
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_low
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_high
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_hi
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_lo
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_dat_fifo
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
+                                                         is set. Throws PKO_INTSN_E::PKO_PDM_DBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -11138,53 +11189,30 @@ union cvmx_pko_pdm_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pdm_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t flshb_cache_lo_ram_sbe       : 1;  /**< Single-bit error for FLSHB_CACHE_LO_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_lo */
-	uint64_t flshb_cache_hi_ram_sbe       : 1;  /**< Single-bit error for FLSHB_CACHE_HI_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_hi */
-	uint64_t isrm_ca_iinst_ram_sbe        : 1;  /**< Single-bit error for ISRM_CA_IINST_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.iinst_in_fif */
-	uint64_t isrm_ca_cm_ram_sbe           : 1;  /**< Single-bit error for ISRM_CA_CM_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.cred_accum_ctrlr_and_mem.cred_accum_spr */
-	uint64_t isrm_st_ram2_sbe             : 1;  /**< Single-bit error for ISRM_ST_RAM2. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem2 */
-	uint64_t isrm_st_ram1_sbe             : 1;  /**< Single-bit error for ISRM_ST_RAM1. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem1 */
-	uint64_t isrm_st_ram0_sbe             : 1;  /**< Single-bit error for ISRM_ST_RAM0. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem0 */
-	uint64_t isrd_st_ram3_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM3. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem3 */
-	uint64_t isrd_st_ram2_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM2. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem2 */
-	uint64_t isrd_st_ram1_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM1. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem1 */
-	uint64_t isrd_st_ram0_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM0. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem0 */
-	uint64_t drp_hi_ram_sbe               : 1;  /**< Single-bit error for DRP_HI_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_1 */
-	uint64_t drp_lo_ram_sbe               : 1;  /**< Single-bit error for DRP_LO_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_2 */
-	uint64_t dwp_hi_ram_sbe               : 1;  /**< Single-bit error for DWP_HI_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_high */
-	uint64_t dwp_lo_ram_sbe               : 1;  /**< Single-bit error for DWP_LO_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_low */
-	uint64_t mwp_hi_ram_sbe               : 1;  /**< Single-bit error for MWP_RAM_PBUF_MEM2. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem2 */
-	uint64_t mwp_lo_ram_sbe               : 1;  /**< Single-bit error for MWP_RAM_PBUF_MEM0. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem0 */
-	uint64_t fillb_m_rsp_ram_hi_sbe       : 1;  /**< Single-bit error for FILLB_M_RSP_RAM_HI. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_ram_hi */
-	uint64_t fillb_m_rsp_ram_lo_sbe       : 1;  /**< Single-bit error for FILLB_M_RSP_RAM_LO. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_ram_lo */
-	uint64_t fillb_d_rsp_ram_hi_sbe       : 1;  /**< Single-bit error for FILLB_D_RSP_RAM_HI. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_hi */
-	uint64_t fillb_d_rsp_ram_lo_sbe       : 1;  /**< Single-bit error for FILLB_D_RSP_RAM_LO. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_lo */
-	uint64_t minpad_ram_sbe               : 1;  /**< Single-bit error for MINPAD_RAM. INTERNAL: Instances: pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
-	uint64_t mwp_hi_spt_ram_sbe           : 1;  /**< Single-bit error for MWP_RAM_PBUF_MEM3. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem3 */
-	uint64_t mwp_lo_spt_ram_sbe           : 1;  /**< Single-bit error for MWP_RAM_PBUF_MEM1. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem1 */
+	uint64_t flshb_cache_lo_ram_sbe       : 1;  /**< Single-bit error for FLSHB_CACHE_LO_RAM. */
+	uint64_t flshb_cache_hi_ram_sbe       : 1;  /**< Single-bit error for FLSHB_CACHE_HI_RAM. */
+	uint64_t isrm_ca_iinst_ram_sbe        : 1;  /**< Single-bit error for ISRM_CA_IINST_RAM. */
+	uint64_t isrm_ca_cm_ram_sbe           : 1;  /**< Single-bit error for ISRM_CA_CM_RAM. */
+	uint64_t isrm_st_ram2_sbe             : 1;  /**< Single-bit error for ISRM_ST_RAM2. */
+	uint64_t isrm_st_ram1_sbe             : 1;  /**< Single-bit error for ISRM_ST_RAM1. */
+	uint64_t isrm_st_ram0_sbe             : 1;  /**< Single-bit error for ISRM_ST_RAM0. */
+	uint64_t isrd_st_ram3_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM3. */
+	uint64_t isrd_st_ram2_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM2. */
+	uint64_t isrd_st_ram1_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM1. */
+	uint64_t isrd_st_ram0_sbe             : 1;  /**< Single-bit error for ISRD_ST_RAM0. */
+	uint64_t drp_hi_ram_sbe               : 1;  /**< Single-bit error for DRP_HI_RAM. */
+	uint64_t drp_lo_ram_sbe               : 1;  /**< Single-bit error for DRP_LO_RAM. */
+	uint64_t dwp_hi_ram_sbe               : 1;  /**< Single-bit error for DWP_HI_RAM. */
+	uint64_t dwp_lo_ram_sbe               : 1;  /**< Single-bit error for DWP_LO_RAM. */
+	uint64_t mwp_hi_ram_sbe               : 1;  /**< Single-bit error for MWP_RAM_PBUF_MEM2. */
+	uint64_t mwp_lo_ram_sbe               : 1;  /**< Single-bit error for MWP_RAM_PBUF_MEM0. */
+	uint64_t fillb_m_rsp_ram_hi_sbe       : 1;  /**< Single-bit error for FILLB_M_RSP_RAM_HI. */
+	uint64_t fillb_m_rsp_ram_lo_sbe       : 1;  /**< Single-bit error for FILLB_M_RSP_RAM_LO. */
+	uint64_t fillb_d_rsp_ram_hi_sbe       : 1;  /**< Single-bit error for FILLB_D_RSP_RAM_HI. */
+	uint64_t fillb_d_rsp_ram_lo_sbe       : 1;  /**< Single-bit error for FILLB_D_RSP_RAM_LO. */
+	uint64_t minpad_ram_sbe               : 1;  /**< Single-bit error for MINPAD_RAM. */
+	uint64_t mwp_hi_spt_ram_sbe           : 1;  /**< Single-bit error for MWP_RAM_PBUF_MEM3. */
+	uint64_t mwp_lo_spt_ram_sbe           : 1;  /**< Single-bit error for MWP_RAM_PBUF_MEM1. */
 	uint64_t buf_wm_ram_sbe               : 1;  /**< Single-bit error for BUF_WM_RAM. */
 	uint64_t reserved_0_38                : 39;
 #else
@@ -11233,28 +11261,7 @@ union cvmx_pko_pdm_ecc_sbe_sts_cmb0 {
 	uint64_t pdm_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_PDM_ECC_SBE_STS0. To clear this bit,
                                                          software
                                                          must clear bits in PKO_PDM_ECC_SBE_STS0. When this bit is set, the corresponding interrupt
-                                                         is set. Throws PKO_INTSN_E::PKO_PDM_SBE_CMB0. INTERNAL: Instances:
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_hi
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.flshb.flshb_cache_lo
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.iinst_in_fif
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.cred_accum.cred_accum_ctrlr_and_mem.cred_
-                                                         accum_spr fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem0
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem1
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.mp_isr.st_mem2
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem0
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem1
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem2
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.isr.d_isr.st_mem3
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_1
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.drpbuf.ram_128k_pbuf_2
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_low
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_high
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_low
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_high
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_hi
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_lo
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_dat_fifo
-                                                         fc.core.roc.pko.pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
+                                                         is set. Throws PKO_INTSN_E::PKO_PDM_SBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -11525,10 +11532,10 @@ union cvmx_pko_pdm_isrd_dbg {
                                                          0xB = Fill response unit. */
 	uint64_t has_cred                     : 4;  /**< Has credit signals indicate there is sufficient credit to commit. The order of the bits
                                                          is:
-                                                         0xA = Flush buffer has credit
-                                                         0x9 = Fill buffer has credit
-                                                         0x8 = DW command output FIFO has credit
-                                                         0x7 = DR command output FIFO has credit */
+                                                         0xA = Flush buffer has credit.
+                                                         0x9 = Fill buffer has credit.
+                                                         0x8 = DW command output FIFO has credit.
+                                                         0x7 = DR command output FIFO has credit. */
 	uint64_t val_exec                     : 7;  /**< Valid bits for the execution units; means the unit can commit if it gets the grant of the
                                                          commit arb and other conditions are met. The order of the bits is:
                                                          0x6 = Fill response unit.
@@ -11597,10 +11604,10 @@ union cvmx_pko_pdm_isrd_dbg {
                                                          0xB = Fill response unit. */
 	uint64_t has_cred                     : 4;  /**< Has credit signals indicate there is sufficient credit to commit. The order of the bits
                                                          is:
-                                                         0xA = Flush buffer has credit
-                                                         0x9 = Fill buffer has credit
-                                                         0x8 = DW command output FIFO has credit
-                                                         0x7 = DR command output FIFO has credit */
+                                                         0xA = Flush buffer has credit.
+                                                         0x9 = Fill buffer has credit.
+                                                         0x8 = DW command output FIFO has credit.
+                                                         0x7 = DR command output FIFO has credit. */
 	uint64_t val_exec                     : 7;  /**< Valid bits for the execution units; means the unit can commit if it gets the grant of the
                                                          commit arb and other conditions are met. The order of the bits is:
                                                          0x6 = Fill response unit.
@@ -12041,8 +12048,7 @@ union cvmx_pko_pdm_sts {
 	struct cvmx_pko_pdm_sts_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_38_63               : 26;
-	uint64_t cp_stalled_thrshld_hit       : 1;  /**< Reserved. INTERNAL: This register is set to 1 if the PDM stalls the inputs for more than
-                                                         PKO_PDM_CFG_DBG[CP_STALL_THRSHLD]: Do not list field in HRM. For lab debug only. */
+	uint64_t cp_stalled_thrshld_hit       : 1;  /**< Reserved. */
 	uint64_t reserved_35_36               : 2;
 	uint64_t mwpbuf_data_val_err          : 1;  /**< Received signal that MWPBUF had data valid error. Throws
                                                          PKO_INTSN_E::PKO_MWPBUF_DATA_VAL_ERR. */
@@ -12488,55 +12494,31 @@ union cvmx_pko_peb_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_peb_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
-	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
-	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
-	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
-	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
-	uint64_t peb_sm_jmp_ram_dbe           : 1;  /**< Double-bit error for PEB_SM_JMP_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i */
-	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
-	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
-	uint64_t pd_bank2_ram_dbe             : 1;  /**< Double-bit error for PD_BANK2_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i */
-	uint64_t pd_bank1_ram_dbe             : 1;  /**< Double-bit error for PD_BANK1_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i */
-	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
-	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
-	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
-	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
-	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
-	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
-	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
-	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
-	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
-	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
-	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
-	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
-	uint64_t state_mem0_dbe               : 1;  /**< Double-bit error for STATE_MEM0. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank0_i */
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. */
+	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. */
+	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. */
+	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. */
+	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. */
+	uint64_t peb_sm_jmp_ram_dbe           : 1;  /**< Double-bit error for PEB_SM_JMP_RAM. */
+	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. */
+	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. */
+	uint64_t pd_bank2_ram_dbe             : 1;  /**< Double-bit error for PD_BANK2_RAM. */
+	uint64_t pd_bank1_ram_dbe             : 1;  /**< Double-bit error for PD_BANK1_RAM. */
+	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. */
+	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. */
+	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. */
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. */
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. */
+	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. */
+	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. */
+	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. */
+	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. */
+	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. */
+	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. */
+	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. */
+	uint64_t state_mem0_dbe               : 1;  /**< Double-bit error for STATE_MEM0. */
 	uint64_t reserved_39_40               : 2;
-	uint64_t state_mem3_dbe               : 1;  /**< Double-bit error for STATE_MEM3. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank3_i */
+	uint64_t state_mem3_dbe               : 1;  /**< Double-bit error for STATE_MEM3. */
 	uint64_t reserved_0_37                : 38;
 #else
 	uint64_t reserved_0_37                : 38;
@@ -12569,51 +12551,30 @@ union cvmx_pko_peb_ecc_dbe_sts0 {
 	} s;
 	struct cvmx_pko_peb_ecc_dbe_sts0_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
-	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
-	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
-	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
-	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. */
+	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. */
+	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. */
+	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. */
+	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. */
 	uint64_t reserved_58_58               : 1;
-	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
-	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. */
+	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. */
 	uint64_t reserved_54_55               : 2;
-	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
-	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
-	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
-	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
-	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
-	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
-	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
-	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
-	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
-	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
-	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
-	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
-	uint64_t state_mem0_dbe               : 1;  /**< Double-bit error for STATE_MEM0. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank0_i */
+	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. */
+	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. */
+	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. */
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. */
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. */
+	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. */
+	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. */
+	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. */
+	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. */
+	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. */
+	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. */
+	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. */
+	uint64_t state_mem0_dbe               : 1;  /**< Double-bit error for STATE_MEM0. */
 	uint64_t reserved_39_40               : 2;
-	uint64_t state_mem3_dbe               : 1;  /**< Double-bit error for STATE_MEM3. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank3_i */
+	uint64_t state_mem3_dbe               : 1;  /**< Double-bit error for STATE_MEM3. */
 	uint64_t reserved_0_37                : 38;
 #else
 	uint64_t reserved_0_37                : 38;
@@ -12645,50 +12606,28 @@ union cvmx_pko_peb_ecc_dbe_sts0 {
 	} cn73xx;
 	struct cvmx_pko_peb_ecc_dbe_sts0_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
-	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
-	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
-	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
-	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
-	uint64_t peb_sm_jmp_ram_dbe           : 1;  /**< Double-bit error for PEB_SM_JMP_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i */
-	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
-	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
-	uint64_t pd_bank2_ram_dbe             : 1;  /**< Double-bit error for PD_BANK2_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i */
-	uint64_t pd_bank1_ram_dbe             : 1;  /**< Double-bit error for PD_BANK1_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i */
-	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
-	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
-	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
-	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
-	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
-	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
-	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
-	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
-	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
-	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
-	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
-	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. */
+	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. */
+	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. */
+	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. */
+	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. */
+	uint64_t peb_sm_jmp_ram_dbe           : 1;  /**< Double-bit error for PEB_SM_JMP_RAM. */
+	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. */
+	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. */
+	uint64_t pd_bank2_ram_dbe             : 1;  /**< Double-bit error for PD_BANK2_RAM. */
+	uint64_t pd_bank1_ram_dbe             : 1;  /**< Double-bit error for PD_BANK1_RAM. */
+	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. */
+	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. */
+	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. */
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. */
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. */
+	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. */
+	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. */
+	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. */
+	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. */
+	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. */
+	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. */
+	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. */
 	uint64_t reserved_0_41                : 42;
 #else
 	uint64_t reserved_0_41                : 42;
@@ -12718,46 +12657,27 @@ union cvmx_pko_peb_ecc_dbe_sts0 {
 	} cn78xx;
 	struct cvmx_pko_peb_ecc_dbe_sts0_cn78xxp2 {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
-	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
-	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
-	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
-	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t iobp1_uid_fifo_ram_dbe       : 1;  /**< Double-bit error for IOBP1_UID_FIFO_RAM. */
+	uint64_t iobp0_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP0_FIFO_RAM. */
+	uint64_t iobp1_fifo_ram_dbe           : 1;  /**< Double-bit error for IOBP1_FIFO_RAM. */
+	uint64_t pdm_resp_buf_ram_dbe         : 1;  /**< Double-bit error for PDM_RESP_BUF_RAM. */
+	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. */
 	uint64_t reserved_58_58               : 1;
-	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
-	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. */
+	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. */
 	uint64_t reserved_54_55               : 2;
-	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
-	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
-	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
-	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
-	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
-	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
-	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
-	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
-	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
-	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
-	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
-	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t pd_bank0_ram_dbe             : 1;  /**< Double-bit error for PD_BANK0_RAM. */
+	uint64_t pd_var_bank_ram_dbe          : 1;  /**< Double-bit error for PD_VAR_BANK_RAM. */
+	uint64_t tx_fifo_crc_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_CRC_RAM. */
+	uint64_t tx_fifo_hdr_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_HDR_RAM. */
+	uint64_t tx_fifo_pkt_ram_dbe          : 1;  /**< Double-bit error for TX_FIFO_PKT_RAM. */
+	uint64_t add_work_fifo_dbe            : 1;  /**< Double-bit error for ADD_WORK_FIFO. */
+	uint64_t send_mem_fifo_dbe            : 1;  /**< Double-bit error for SEND_MEM_FIFO. */
+	uint64_t send_mem_stdn_fifo_dbe       : 1;  /**< Double-bit error for SEND_MEM_STDN_FIFO. */
+	uint64_t send_mem_ts_fifo_dbe         : 1;  /**< Double-bit error for SEND_MEM_TS_FIFO. */
+	uint64_t nxt_link_ptr_ram_dbe         : 1;  /**< Double-bit error for NXT_LINK_PTR_RAM. */
+	uint64_t pkt_mrk_ram_dbe              : 1;  /**< Double-bit error for PKT_MRK_RAM. */
+	uint64_t ts_addwork_ram_dbe           : 1;  /**< Double-bit error for TS_ADDWORK_RAM. */
 	uint64_t reserved_0_41                : 42;
 #else
 	uint64_t reserved_0_41                : 42;
@@ -12798,28 +12718,7 @@ union cvmx_pko_peb_ecc_dbe_sts_cmb0 {
 	uint64_t peb_dbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_PEB_ECC_DBE_STS0. To clear this bit,
                                                          software
                                                          must clear bits in PKO_PEB_ECC_DBE_STS0. When this bit is set, the corresponding interrupt
-                                                         is set. Throws PKO_INTSN_E::PKO_PEB_DBE_CMB0. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+                                                         is set. Throws PKO_INTSN_E::PKO_PEB_DBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -12840,55 +12739,31 @@ union cvmx_pko_peb_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_peb_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
-	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
-	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
-	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
-	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
-	uint64_t peb_sm_jmp_ram_sbe           : 1;  /**< Single-bit error for PEB_SM_JMP_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i */
-	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
-	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
-	uint64_t pd_bank2_ram_sbe             : 1;  /**< Single-bit error for PD_BANK2_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i */
-	uint64_t pd_bank1_ram_sbe             : 1;  /**< Single-bit error for PD_BANK1_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i */
-	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
-	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
-	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
-	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
-	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
-	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
-	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
-	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
-	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
-	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
-	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
-	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
-	uint64_t state_mem0_sbe               : 1;  /**< Single-bit error for STATE_MEM0. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank0_i */
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. */
+	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. */
+	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. */
+	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. */
+	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. */
+	uint64_t peb_sm_jmp_ram_sbe           : 1;  /**< Single-bit error for PEB_SM_JMP_RAM. */
+	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. */
+	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. */
+	uint64_t pd_bank2_ram_sbe             : 1;  /**< Single-bit error for PD_BANK2_RAM. */
+	uint64_t pd_bank1_ram_sbe             : 1;  /**< Single-bit error for PD_BANK1_RAM. */
+	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. */
+	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. */
+	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. */
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. */
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. */
+	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. */
+	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. */
+	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. */
+	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. */
+	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. */
+	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. */
+	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. */
+	uint64_t state_mem0_sbe               : 1;  /**< Single-bit error for STATE_MEM0. */
 	uint64_t reserved_39_40               : 2;
-	uint64_t state_mem3_sbe               : 1;  /**< Single-bit error for STATE_MEM3. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank3_i */
+	uint64_t state_mem3_sbe               : 1;  /**< Single-bit error for STATE_MEM3. */
 	uint64_t reserved_0_37                : 38;
 #else
 	uint64_t reserved_0_37                : 38;
@@ -12921,51 +12796,30 @@ union cvmx_pko_peb_ecc_sbe_sts0 {
 	} s;
 	struct cvmx_pko_peb_ecc_sbe_sts0_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
-	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
-	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
-	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
-	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. */
+	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. */
+	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. */
+	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. */
+	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. */
 	uint64_t reserved_58_58               : 1;
-	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
-	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. */
+	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. */
 	uint64_t reserved_54_55               : 2;
-	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
-	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
-	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
-	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
-	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
-	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
-	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
-	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
-	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
-	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
-	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
-	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
-	uint64_t state_mem0_sbe               : 1;  /**< Single-bit error for STATE_MEM0. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank0_i */
+	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. */
+	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. */
+	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. */
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. */
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. */
+	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. */
+	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. */
+	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. */
+	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. */
+	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. */
+	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. */
+	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. */
+	uint64_t state_mem0_sbe               : 1;  /**< Single-bit error for STATE_MEM0. */
 	uint64_t reserved_39_40               : 2;
-	uint64_t state_mem3_sbe               : 1;  /**< Single-bit error for STATE_MEM3. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_proc_fifo_state_bank3_i */
+	uint64_t state_mem3_sbe               : 1;  /**< Single-bit error for STATE_MEM3. */
 	uint64_t reserved_0_37                : 38;
 #else
 	uint64_t reserved_0_37                : 38;
@@ -12997,50 +12851,28 @@ union cvmx_pko_peb_ecc_sbe_sts0 {
 	} cn73xx;
 	struct cvmx_pko_peb_ecc_sbe_sts0_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
-	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
-	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
-	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
-	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
-	uint64_t peb_sm_jmp_ram_sbe           : 1;  /**< Single-bit error for PEB_SM_JMP_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i */
-	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
-	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
-	uint64_t pd_bank2_ram_sbe             : 1;  /**< Single-bit error for PD_BANK2_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i */
-	uint64_t pd_bank1_ram_sbe             : 1;  /**< Single-bit error for PD_BANK1_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i */
-	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
-	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
-	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
-	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
-	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
-	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
-	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
-	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
-	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
-	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
-	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
-	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. */
+	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. */
+	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. */
+	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. */
+	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. */
+	uint64_t peb_sm_jmp_ram_sbe           : 1;  /**< Single-bit error for PEB_SM_JMP_RAM. */
+	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. */
+	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. */
+	uint64_t pd_bank2_ram_sbe             : 1;  /**< Single-bit error for PD_BANK2_RAM. */
+	uint64_t pd_bank1_ram_sbe             : 1;  /**< Single-bit error for PD_BANK1_RAM. */
+	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. */
+	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. */
+	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. */
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. */
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. */
+	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. */
+	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. */
+	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. */
+	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. */
+	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. */
+	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. */
+	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. */
 	uint64_t reserved_0_41                : 42;
 #else
 	uint64_t reserved_0_41                : 42;
@@ -13070,46 +12902,27 @@ union cvmx_pko_peb_ecc_sbe_sts0 {
 	} cn78xx;
 	struct cvmx_pko_peb_ecc_sbe_sts0_cn78xxp2 {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i */
-	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i */
-	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i */
-	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
-	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
+	uint64_t iobp1_uid_fifo_ram_sbe       : 1;  /**< Single-bit error for IOBP1_UID_FIFO_RAM. */
+	uint64_t iobp0_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP0_FIFO_RAM. */
+	uint64_t iobp1_fifo_ram_sbe           : 1;  /**< Single-bit error for IOBP1_FIFO_RAM. */
+	uint64_t pdm_resp_buf_ram_sbe         : 1;  /**< Single-bit error for PDM_RESP_BUF_RAM. */
+	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. */
 	uint64_t reserved_58_58               : 1;
-	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
-	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i */
+	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. */
+	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. */
 	uint64_t reserved_54_55               : 2;
-	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
-	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
-	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i */
-	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i */
-	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i */
-	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i */
-	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i */
-	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i */
-	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i */
-	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i */
-	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i */
-	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. */
+	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. */
+	uint64_t tx_fifo_crc_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_CRC_RAM. */
+	uint64_t tx_fifo_hdr_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_HDR_RAM. */
+	uint64_t tx_fifo_pkt_ram_sbe          : 1;  /**< Single-bit error for TX_FIFO_PKT_RAM. */
+	uint64_t add_work_fifo_sbe            : 1;  /**< Single-bit error for ADD_WORK_FIFO. */
+	uint64_t send_mem_fifo_sbe            : 1;  /**< Single-bit error for SEND_MEM_FIFO. */
+	uint64_t send_mem_stdn_fifo_sbe       : 1;  /**< Single-bit error for SEND_MEM_STDN_FIFO. */
+	uint64_t send_mem_ts_fifo_sbe         : 1;  /**< Single-bit error for SEND_MEM_TS_FIFO. */
+	uint64_t nxt_link_ptr_ram_sbe         : 1;  /**< Single-bit error for NXT_LINK_PTR_RAM. */
+	uint64_t pkt_mrk_ram_sbe              : 1;  /**< Single-bit error for PKT_MRK_RAM. */
+	uint64_t ts_addwork_ram_sbe           : 1;  /**< Single-bit error for TS_ADDWORK_RAM. */
 	uint64_t reserved_0_41                : 42;
 #else
 	uint64_t reserved_0_41                : 42;
@@ -13150,28 +12963,7 @@ union cvmx_pko_peb_ecc_sbe_sts_cmb0 {
 	uint64_t peb_sbe_cmb0                 : 1;  /**< This bit is the logical OR of all bits in PKO_PEB_ECC_SBE_STS0. To clear this bit,
                                                          software
                                                          must clear bits in PKO_PEB_ECC_SBE_STS0. When this bit is set, the corresponding interrupt
-                                                         is set. Throws PKO_INTSN_E::PKO_PEB_SBE_CMB0. INTERNAL: Instances:
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_uid_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_iobp0_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_iobp1_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank3_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_crc_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_hdr_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_tx_fifo_i.pko_peb_tx_fifo_pkt_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_add_work_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_stdn_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_sendmem_proc_i.pko_peb_send_mem_ts_fifo_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_nxt_link_ptr_mem_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pkt_mrk_mem_i
-                                                         pko_pnr3.pko_pnr3_peb.pko_peb_proc_i.pko_peb_addwork_proc_i.pko_peb_ts_addwork_mem_i */
+                                                         is set. Throws PKO_INTSN_E::PKO_PEB_SBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -13193,7 +12985,7 @@ union cvmx_pko_peb_eco {
 	struct cvmx_pko_peb_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 32; /**< N/A */
 #else
 	uint64_t eco_rw                       : 32;
 	uint64_t reserved_32_63               : 32;
@@ -13854,15 +13646,15 @@ union cvmx_pko_pse_dq_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_dq_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dq_wt_ram_dbe                : 1;  /**< Double-bit error for DQ_WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.wt_sram */
-	uint64_t dq_rt7_dbe                   : 1;  /**< Double-bit error for DQ_RT7_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt7 */
-	uint64_t dq_rt6_dbe                   : 1;  /**< Double-bit error for DQ_RT6_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt6 */
-	uint64_t dq_rt5_dbe                   : 1;  /**< Double-bit error for DQ_RT5_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt5 */
-	uint64_t dq_rt4_dbe                   : 1;  /**< Double-bit error for DQ_RT4_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt4 */
-	uint64_t dq_rt3_dbe                   : 1;  /**< Double-bit error for DQ_RT3_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt3 */
-	uint64_t dq_rt2_dbe                   : 1;  /**< Double-bit error for DQ_RT2_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt2 */
-	uint64_t dq_rt1_dbe                   : 1;  /**< Double-bit error for DQ_RT1_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt1 */
-	uint64_t dq_rt0_dbe                   : 1;  /**< Double-bit error for DQ_RT0_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt0 */
+	uint64_t dq_wt_ram_dbe                : 1;  /**< Double-bit error for DQ_WT_RAM. */
+	uint64_t dq_rt7_dbe                   : 1;  /**< Double-bit error for DQ_RT7_RAM. */
+	uint64_t dq_rt6_dbe                   : 1;  /**< Double-bit error for DQ_RT6_RAM. */
+	uint64_t dq_rt5_dbe                   : 1;  /**< Double-bit error for DQ_RT5_RAM. */
+	uint64_t dq_rt4_dbe                   : 1;  /**< Double-bit error for DQ_RT4_RAM. */
+	uint64_t dq_rt3_dbe                   : 1;  /**< Double-bit error for DQ_RT3_RAM. */
+	uint64_t dq_rt2_dbe                   : 1;  /**< Double-bit error for DQ_RT2_RAM. */
+	uint64_t dq_rt1_dbe                   : 1;  /**< Double-bit error for DQ_RT1_RAM. */
+	uint64_t dq_rt0_dbe                   : 1;  /**< Double-bit error for DQ_RT0_RAM. */
 	uint64_t reserved_0_54                : 55;
 #else
 	uint64_t reserved_0_54                : 55;
@@ -13879,10 +13671,10 @@ union cvmx_pko_pse_dq_ecc_dbe_sts0 {
 	} s;
 	struct cvmx_pko_pse_dq_ecc_dbe_sts0_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dq_wt_ram_dbe                : 1;  /**< Double-bit error for DQ_WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.wt_sram */
+	uint64_t dq_wt_ram_dbe                : 1;  /**< Double-bit error for DQ_WT_RAM. */
 	uint64_t reserved_57_62               : 6;
-	uint64_t dq_rt1_dbe                   : 1;  /**< Double-bit error for DQ_RT1_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt1 */
-	uint64_t dq_rt0_dbe                   : 1;  /**< Double-bit error for DQ_RT0_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt0 */
+	uint64_t dq_rt1_dbe                   : 1;  /**< Double-bit error for DQ_RT1_RAM. */
+	uint64_t dq_rt0_dbe                   : 1;  /**< Double-bit error for DQ_RT0_RAM. */
 	uint64_t reserved_0_54                : 55;
 #else
 	uint64_t reserved_0_54                : 55;
@@ -13908,11 +13700,7 @@ union cvmx_pko_pse_dq_ecc_dbe_sts_cmb0 {
 	uint64_t pse_dq_dbe_cmb0              : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_DQ_ECC_DBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_DQ_ECC_DBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_DQ_DBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_dq.wt_sram
-                                                         pko_pnr2.pko_pse.pse_dq.rt0
-                                                         pko_pnr2.pko_pse.pse_dq.rt1 */
+                                                         Throws PKO_INTSN_E::PKO_PSE_DQ_DBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -13933,15 +13721,15 @@ union cvmx_pko_pse_dq_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_dq_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dq_wt_ram_sbe                : 1;  /**< Single-bit error for DQ_WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.wt_sram */
-	uint64_t dq_rt7_sbe                   : 1;  /**< Single-bit error for DQ_RT7_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt7 */
-	uint64_t dq_rt6_sbe                   : 1;  /**< Single-bit error for DQ_RT6_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt6 */
-	uint64_t dq_rt5_sbe                   : 1;  /**< Single-bit error for DQ_RT5_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt5 */
-	uint64_t dq_rt4_sbe                   : 1;  /**< Single-bit error for DQ_RT4_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt4 */
-	uint64_t dq_rt3_sbe                   : 1;  /**< Single-bit error for DQ_RT3_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt3 */
-	uint64_t dq_rt2_sbe                   : 1;  /**< Single-bit error for DQ_RT2_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt2 */
-	uint64_t dq_rt1_sbe                   : 1;  /**< Single-bit error for DQ_RT1_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt1 */
-	uint64_t dq_rt0_sbe                   : 1;  /**< Single-bit error for DQ_RT0_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt0 */
+	uint64_t dq_wt_ram_sbe                : 1;  /**< Single-bit error for DQ_WT_RAM. */
+	uint64_t dq_rt7_sbe                   : 1;  /**< Single-bit error for DQ_RT7_RAM. */
+	uint64_t dq_rt6_sbe                   : 1;  /**< Single-bit error for DQ_RT6_RAM. */
+	uint64_t dq_rt5_sbe                   : 1;  /**< Single-bit error for DQ_RT5_RAM. */
+	uint64_t dq_rt4_sbe                   : 1;  /**< Single-bit error for DQ_RT4_RAM. */
+	uint64_t dq_rt3_sbe                   : 1;  /**< Single-bit error for DQ_RT3_RAM. */
+	uint64_t dq_rt2_sbe                   : 1;  /**< Single-bit error for DQ_RT2_RAM. */
+	uint64_t dq_rt1_sbe                   : 1;  /**< Single-bit error for DQ_RT1_RAM. */
+	uint64_t dq_rt0_sbe                   : 1;  /**< Single-bit error for DQ_RT0_RAM. */
 	uint64_t reserved_0_54                : 55;
 #else
 	uint64_t reserved_0_54                : 55;
@@ -13958,10 +13746,10 @@ union cvmx_pko_pse_dq_ecc_sbe_sts0 {
 	} s;
 	struct cvmx_pko_pse_dq_ecc_sbe_sts0_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t dq_wt_ram_sbe                : 1;  /**< Single-bit error for DQ_WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.wt_sram */
+	uint64_t dq_wt_ram_sbe                : 1;  /**< Single-bit error for DQ_WT_RAM. */
 	uint64_t reserved_57_62               : 6;
-	uint64_t dq_rt1_sbe                   : 1;  /**< Single-bit error for DQ_RT1_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt1 */
-	uint64_t dq_rt0_sbe                   : 1;  /**< Single-bit error for DQ_RT0_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_dq.rt0 */
+	uint64_t dq_rt1_sbe                   : 1;  /**< Single-bit error for DQ_RT1_RAM. */
+	uint64_t dq_rt0_sbe                   : 1;  /**< Single-bit error for DQ_RT0_RAM. */
 	uint64_t reserved_0_54                : 55;
 #else
 	uint64_t reserved_0_54                : 55;
@@ -13987,12 +13775,7 @@ union cvmx_pko_pse_dq_ecc_sbe_sts_cmb0 {
 	uint64_t pse_dq_sbe_cmb0              : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_DQ_ECC_SBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_DQ_ECC_SBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_DQ_SBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_dq.wt_sram
-                                                         pko_pnr2.pko_pse.pse_dq.rt0
-                                                         pko_pnr2.pko_pse.pse_dq.rt1
-                                                         pko_pnr2.pko_pse.pse_dq.rt2 */
+                                                         Throws PKO_INTSN_E::PKO_PSE_DQ_SBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -14184,18 +13967,13 @@ union cvmx_pko_pse_pq_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_pq_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pq_cxs_ram_dbe               : 1;  /**< Double-bit error for PQ_CXS_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxs_sram */
-	uint64_t pq_cxd_ram_dbe               : 1;  /**< Double-bit error for PQ_CXD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxd_sram */
+	uint64_t pq_cxs_ram_dbe               : 1;  /**< Double-bit error for PQ_CXS_RAM. */
+	uint64_t pq_cxd_ram_dbe               : 1;  /**< Double-bit error for PQ_CXD_RAM. */
 	uint64_t irq_fifo_sram_dbe            : 1;  /**< Reserved. */
-	uint64_t tp_sram_dbe                  : 1;  /**< Double-bit error for TP_SRAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.pq.tp_sram */
-	uint64_t pq_std_ram_dbe               : 1;  /**< Double-bit error for PQ_STD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.std_sram */
-	uint64_t pq_st_ram_dbe                : 1;  /**< Double-bit error for PQ_ST_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.st_sram */
-	uint64_t pq_wmd_ram_dbe               : 1;  /**< Double-bit error for PQ_WMD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.wmd_sram */
+	uint64_t tp_sram_dbe                  : 1;  /**< Double-bit error for TP_SRAM. */
+	uint64_t pq_std_ram_dbe               : 1;  /**< Double-bit error for PQ_STD_RAM. */
+	uint64_t pq_st_ram_dbe                : 1;  /**< Double-bit error for PQ_ST_RAM. */
+	uint64_t pq_wmd_ram_dbe               : 1;  /**< Double-bit error for PQ_WMD_RAM. */
 	uint64_t pq_wms_ram_dbe               : 1;  /**< Reserved. */
 	uint64_t reserved_0_55                : 56;
 #else
@@ -14212,18 +13990,13 @@ union cvmx_pko_pse_pq_ecc_dbe_sts0 {
 	} s;
 	struct cvmx_pko_pse_pq_ecc_dbe_sts0_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pq_cxs_ram_dbe               : 1;  /**< Double-bit error for PQ_CXS_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxs_sram */
-	uint64_t pq_cxd_ram_dbe               : 1;  /**< Double-bit error for PQ_CXD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxd_sram */
+	uint64_t pq_cxs_ram_dbe               : 1;  /**< Double-bit error for PQ_CXS_RAM. */
+	uint64_t pq_cxd_ram_dbe               : 1;  /**< Double-bit error for PQ_CXD_RAM. */
 	uint64_t reserved_61_61               : 1;
-	uint64_t tp_sram_dbe                  : 1;  /**< Double-bit error for TP_SRAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.pq.tp_sram */
-	uint64_t pq_std_ram_dbe               : 1;  /**< Double-bit error for PQ_STD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.std_sram */
-	uint64_t pq_st_ram_dbe                : 1;  /**< Double-bit error for PQ_ST_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.st_sram */
-	uint64_t pq_wmd_ram_dbe               : 1;  /**< Double-bit error for PQ_WMD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.wmd_sram */
+	uint64_t tp_sram_dbe                  : 1;  /**< Double-bit error for TP_SRAM. */
+	uint64_t pq_std_ram_dbe               : 1;  /**< Double-bit error for PQ_STD_RAM. */
+	uint64_t pq_st_ram_dbe                : 1;  /**< Double-bit error for PQ_ST_RAM. */
+	uint64_t pq_wmd_ram_dbe               : 1;  /**< Double-bit error for PQ_WMD_RAM. */
 	uint64_t reserved_0_56                : 57;
 #else
 	uint64_t reserved_0_56                : 57;
@@ -14252,14 +14025,7 @@ union cvmx_pko_pse_pq_ecc_dbe_sts_cmb0 {
 	uint64_t pse_pq_dbe_cmb0              : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_PQ_ECC_DBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_PQ_ECC_DBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_PQ_DBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxs_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxd_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.tp_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.std_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.st_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.wmd_sram */
+                                                         Throws PKO_INTSN_E::PKO_PSE_PQ_DBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -14280,18 +14046,13 @@ union cvmx_pko_pse_pq_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_pq_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pq_cxs_ram_sbe               : 1;  /**< Single-bit error for PQ_CXS_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxs_sram */
-	uint64_t pq_cxd_ram_sbe               : 1;  /**< Single-bit error for PQ_CXD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxd_sram */
+	uint64_t pq_cxs_ram_sbe               : 1;  /**< Single-bit error for PQ_CXS_RAM. */
+	uint64_t pq_cxd_ram_sbe               : 1;  /**< Single-bit error for PQ_CXD_RAM. */
 	uint64_t irq_fifo_sram_sbe            : 1;  /**< Reserved. */
-	uint64_t tp_sram_sbe                  : 1;  /**< Single-bit error for TP_SRAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.pq.tp_sram */
-	uint64_t pq_std_ram_sbe               : 1;  /**< Single-bit error for PQ_STD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.std_sram */
-	uint64_t pq_st_ram_sbe                : 1;  /**< Single-bit error for PQ_ST_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.st_sram */
-	uint64_t pq_wmd_ram_sbe               : 1;  /**< Single-bit error for PQ_WMD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.wmd_sram */
+	uint64_t tp_sram_sbe                  : 1;  /**< Single-bit error for TP_SRAM. */
+	uint64_t pq_std_ram_sbe               : 1;  /**< Single-bit error for PQ_STD_RAM. */
+	uint64_t pq_st_ram_sbe                : 1;  /**< Single-bit error for PQ_ST_RAM. */
+	uint64_t pq_wmd_ram_sbe               : 1;  /**< Single-bit error for PQ_WMD_RAM. */
 	uint64_t pq_wms_ram_sbe               : 1;  /**< Reserved. */
 	uint64_t reserved_0_55                : 56;
 #else
@@ -14308,18 +14069,13 @@ union cvmx_pko_pse_pq_ecc_sbe_sts0 {
 	} s;
 	struct cvmx_pko_pse_pq_ecc_sbe_sts0_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pq_cxs_ram_sbe               : 1;  /**< Single-bit error for PQ_CXS_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxs_sram */
-	uint64_t pq_cxd_ram_sbe               : 1;  /**< Single-bit error for PQ_CXD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxd_sram */
+	uint64_t pq_cxs_ram_sbe               : 1;  /**< Single-bit error for PQ_CXS_RAM. */
+	uint64_t pq_cxd_ram_sbe               : 1;  /**< Single-bit error for PQ_CXD_RAM. */
 	uint64_t reserved_61_61               : 1;
-	uint64_t tp_sram_sbe                  : 1;  /**< Single-bit error for TP_SRAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.pq.tp_sram */
-	uint64_t pq_std_ram_sbe               : 1;  /**< Single-bit error for PQ_STD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.std_sram */
-	uint64_t pq_st_ram_sbe                : 1;  /**< Single-bit error for PQ_ST_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.st_sram */
-	uint64_t pq_wmd_ram_sbe               : 1;  /**< Single-bit error for PQ_WMD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.wmd_sram */
+	uint64_t tp_sram_sbe                  : 1;  /**< Single-bit error for TP_SRAM. */
+	uint64_t pq_std_ram_sbe               : 1;  /**< Single-bit error for PQ_STD_RAM. */
+	uint64_t pq_st_ram_sbe                : 1;  /**< Single-bit error for PQ_ST_RAM. */
+	uint64_t pq_wmd_ram_sbe               : 1;  /**< Single-bit error for PQ_WMD_RAM. */
 	uint64_t reserved_0_56                : 57;
 #else
 	uint64_t reserved_0_56                : 57;
@@ -14348,14 +14104,7 @@ union cvmx_pko_pse_pq_ecc_sbe_sts_cmb0 {
 	uint64_t pse_pq_sbe_cmb0              : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_PQ_ECC_SBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_PQ_ECC_SBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_PQ_SBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxs_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.cxd_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.tp_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.std_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.st_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.pq.wmd_sram */
+                                                         Throws PKO_INTSN_E::PKO_PSE_PQ_SBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -14645,38 +14394,24 @@ union cvmx_pko_pse_sq1_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq1_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t cxs_ram_dbe                  : 1;  /**< Double-bit error for CXS_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxs_sram */
-	uint64_t cxd_ram_dbe                  : 1;  /**< Double-bit error for CXD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxd_sram */
-	uint64_t vc1_sram_dbe                 : 1;  /**< Double-bit error for VC1_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.vc1_sram */
-	uint64_t vc0_sram_dbe                 : 1;  /**< Double-bit error for VC0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.vc0_sram */
-	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.nt_sram */
-	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.pt_sram */
-	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.rt_sram */
-	uint64_t pc_ram_dbe                   : 1;  /**< Double-bit error for PC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.pc_sram */
-	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tw_0.sq_fifo_sram */
-	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tw_1.sq_fifo_sram */
-	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tp0_sram */
-	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tp0_sram */
-	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sts1_sram */
-	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.sts0_sram */
-	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.std1_sram */
-	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.std0_sram */
-	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.wt_sram */
-	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.sc_sram */
+	uint64_t cxs_ram_dbe                  : 1;  /**< Double-bit error for CXS_RAM. */
+	uint64_t cxd_ram_dbe                  : 1;  /**< Double-bit error for CXD_RAM. */
+	uint64_t vc1_sram_dbe                 : 1;  /**< Double-bit error for VC1_SRAM. */
+	uint64_t vc0_sram_dbe                 : 1;  /**< Double-bit error for VC0_SRAM. */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. */
+	uint64_t pc_ram_dbe                   : 1;  /**< Double-bit error for PC_RAM. */
+	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. */
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. */
+	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. */
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. */
+	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM. */
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. */
+	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. */
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. */
 	uint64_t reserved_0_45                : 46;
 #else
 	uint64_t reserved_0_45                : 46;
@@ -14702,33 +14437,24 @@ union cvmx_pko_pse_sq1_ecc_dbe_sts0 {
 	} s;
 	struct cvmx_pko_pse_sq1_ecc_dbe_sts0_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t cxs_ram_dbe                  : 1;  /**< Double-bit error for CXS_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxs_sram */
-	uint64_t cxd_ram_dbe                  : 1;  /**< Double-bit error for CXD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxd_sram */
+	uint64_t cxs_ram_dbe                  : 1;  /**< Double-bit error for CXS_RAM. */
+	uint64_t cxd_ram_dbe                  : 1;  /**< Double-bit error for CXD_RAM. */
 	uint64_t reserved_61_61               : 1;
-	uint64_t vc0_sram_dbe                 : 1;  /**< Double-bit error for VC0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.vc0_sram */
-	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.nt_sram */
-	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.pt_sram */
-	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.rt_sram */
-	uint64_t pc_ram_dbe                   : 1;  /**< Double-bit error for PC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.pc_sram */
+	uint64_t vc0_sram_dbe                 : 1;  /**< Double-bit error for VC0_SRAM. */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. */
+	uint64_t pc_ram_dbe                   : 1;  /**< Double-bit error for PC_RAM. */
 	uint64_t reserved_55_55               : 1;
-	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tw_1.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. */
 	uint64_t reserved_53_53               : 1;
-	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tp0_sram */
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. */
 	uint64_t reserved_51_51               : 1;
-	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.sts0_sram */
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. */
 	uint64_t reserved_49_49               : 1;
-	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.std0_sram */
-	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.wt_sram */
-	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.sc_sram */
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. */
 	uint64_t reserved_0_45                : 46;
 #else
 	uint64_t reserved_0_45                : 46;
@@ -14768,21 +14494,7 @@ union cvmx_pko_pse_sq1_ecc_dbe_sts_cmb0 {
 	uint64_t pse_sq1_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ1_ECC_DBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_SQ1_ECC_DBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_SQ1_DBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxs_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxd_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.vc0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.nt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.pt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.pc_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.rt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tw_0.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tp0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.std0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.sts0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.wt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.sc_sram */
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ1_DBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -14803,38 +14515,24 @@ union cvmx_pko_pse_sq1_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq1_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t cxs_ram_sbe                  : 1;  /**< Single-bit error for CXS_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxs_sram */
-	uint64_t cxd_ram_sbe                  : 1;  /**< Single-bit error for CXD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxd_sram */
-	uint64_t vc1_sram_sbe                 : 1;  /**< Single-bit error for VC1_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.vc0_sram */
-	uint64_t vc0_sram_sbe                 : 1;  /**< Single-bit error for VC0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.vc1_sram */
-	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.nt_sram */
-	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.pt_sram */
-	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.rt_sram */
-	uint64_t pc_ram_sbe                   : 1;  /**< Single-bit error for PC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.pc_sram */
-	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tw_0.sq_fifo_sram */
-	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tw_1.sq_fifo_sram */
-	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tp0_sram */
-	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tp0_sram */
-	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.sts0_sram */
-	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.sts1_sram */
-	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.std0_sram */
-	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.std1_sram */
-	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.wt_sram */
-	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.sc_sram */
+	uint64_t cxs_ram_sbe                  : 1;  /**< Single-bit error for CXS_RAM. */
+	uint64_t cxd_ram_sbe                  : 1;  /**< Single-bit error for CXD_RAM. */
+	uint64_t vc1_sram_sbe                 : 1;  /**< Single-bit error for VC1_SRAM. */
+	uint64_t vc0_sram_sbe                 : 1;  /**< Single-bit error for VC0_SRAM. */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. */
+	uint64_t pc_ram_sbe                   : 1;  /**< Single-bit error for PC_RAM. */
+	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. */
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. */
+	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. */
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. */
+	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. */
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. */
+	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. */
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. */
 	uint64_t reserved_0_45                : 46;
 #else
 	uint64_t reserved_0_45                : 46;
@@ -14860,33 +14558,24 @@ union cvmx_pko_pse_sq1_ecc_sbe_sts0 {
 	} s;
 	struct cvmx_pko_pse_sq1_ecc_sbe_sts0_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t cxs_ram_sbe                  : 1;  /**< Single-bit error for CXS_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxs_sram */
-	uint64_t cxd_ram_sbe                  : 1;  /**< Single-bit error for CXD_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxd_sram */
+	uint64_t cxs_ram_sbe                  : 1;  /**< Single-bit error for CXS_RAM. */
+	uint64_t cxd_ram_sbe                  : 1;  /**< Single-bit error for CXD_RAM. */
 	uint64_t reserved_61_61               : 1;
-	uint64_t vc0_sram_sbe                 : 1;  /**< Single-bit error for VC0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.vc1_sram */
-	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.nt_sram */
-	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.pt_sram */
-	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.rt_sram */
-	uint64_t pc_ram_sbe                   : 1;  /**< Single-bit error for PC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.pc_sram */
+	uint64_t vc0_sram_sbe                 : 1;  /**< Single-bit error for VC0_SRAM. */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. */
+	uint64_t pc_ram_sbe                   : 1;  /**< Single-bit error for PC_RAM. */
 	uint64_t reserved_55_55               : 1;
-	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tw_1.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. */
 	uint64_t reserved_53_53               : 1;
-	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tp0_sram */
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. */
 	uint64_t reserved_51_51               : 1;
-	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.sts1_sram */
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. */
 	uint64_t reserved_49_49               : 1;
-	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.std1_sram */
-	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.wt_sram */
-	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq1.sc_sram */
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. */
 	uint64_t reserved_0_45                : 46;
 #else
 	uint64_t reserved_0_45                : 46;
@@ -14926,21 +14615,7 @@ union cvmx_pko_pse_sq1_ecc_sbe_sts_cmb0 {
 	uint64_t pse_sq1_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ1_ECC_SBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_SQ1_ECC_SBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_SQ1_SBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxs_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.cxd_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.vc0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.nt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.pt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.pc_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.rt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tw_0.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tp0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.std0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.sts0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.wt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.sc_sram */
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ1_SBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -15166,29 +14841,19 @@ union cvmx_pko_pse_sq2_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq2_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.nt_sram */
-	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.pt_sram */
-	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.rt_sram */
-	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tw_1.sq_fifo_sram */
-	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tw_0.sq_fifo_sram */
-	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tp1_sram */
-	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tp0_sram */
-	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sts1_sram */
-	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.sts0_sram */
-	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.std1_sram */
-	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.std0_sram */
-	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.wt_sram */
-	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.sc_sram */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. */
+	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. */
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. */
+	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. */
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. */
+	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM. */
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. */
+	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. */
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. */
 	uint64_t reserved_0_50                : 51;
 #else
 	uint64_t reserved_0_50                : 51;
@@ -15209,25 +14874,19 @@ union cvmx_pko_pse_sq2_ecc_dbe_sts0 {
 	} s;
 	struct cvmx_pko_pse_sq2_ecc_dbe_sts0_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.nt_sram */
-	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.pt_sram */
-	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.rt_sram */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. */
 	uint64_t reserved_60_60               : 1;
-	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tw_0.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. */
 	uint64_t reserved_58_58               : 1;
-	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tp0_sram */
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. */
 	uint64_t reserved_56_56               : 1;
-	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.sts0_sram */
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. */
 	uint64_t reserved_54_54               : 1;
-	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.std0_sram */
-	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.wt_sram */
-	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.sc_sram */
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. */
 	uint64_t reserved_0_50                : 51;
 #else
 	uint64_t reserved_0_50                : 51;
@@ -15262,17 +14921,7 @@ union cvmx_pko_pse_sq2_ecc_dbe_sts_cmb0 {
 	uint64_t pse_sq2_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ2_ECC_DBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_SQ2_ECC_DBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_SQ2_DBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.nt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.pt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.rt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tw_0.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tp0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.std0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.sts0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.wt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.sc_sram */
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ2_DBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -15293,29 +14942,19 @@ union cvmx_pko_pse_sq2_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq2_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.nt_sram */
-	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.pt_sram */
-	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.rt_sram */
-	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.tw_1.sq_fifo_sram */
-	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tw_0.sq_fifo_sram */
-	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq2.tp1_sram */
-	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tp0_sram */
-	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.sts1_sram */
-	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.sts0_sram */
-	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq2_pq.sq1.std1_sram */
-	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.std0_sram */
-	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.wt_sram */
-	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.sc_sram */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. */
+	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. */
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. */
+	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. */
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. */
+	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. */
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. */
+	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. */
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. */
 	uint64_t reserved_0_50                : 51;
 #else
 	uint64_t reserved_0_50                : 51;
@@ -15336,25 +14975,19 @@ union cvmx_pko_pse_sq2_ecc_sbe_sts0 {
 	} s;
 	struct cvmx_pko_pse_sq2_ecc_sbe_sts0_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.nt_sram */
-	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.pt_sram */
-	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.rt_sram */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. */
 	uint64_t reserved_60_60               : 1;
-	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tw_0.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. */
 	uint64_t reserved_58_58               : 1;
-	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tp0_sram */
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. */
 	uint64_t reserved_56_56               : 1;
-	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.sts0_sram */
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. */
 	uint64_t reserved_54_54               : 1;
-	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.std0_sram */
-	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.wt_sram */
-	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq3_pq.sq2.sc_sram */
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. */
 	uint64_t reserved_0_50                : 51;
 #else
 	uint64_t reserved_0_50                : 51;
@@ -15389,17 +15022,7 @@ union cvmx_pko_pse_sq2_ecc_sbe_sts_cmb0 {
 	uint64_t pse_sq2_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ2_ECC_SBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_SQ2_ECC_SBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_SQ2_SBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.nt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.pt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.rt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.tw_0.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.tp0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.std0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq1.sts0_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.wt_sram
-                                                         pko_pnr2.pko_pse.pse_sq3_pq.sq2.sc_sram */
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ2_SBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -15669,45 +15292,27 @@ union cvmx_pko_pse_sq3_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq3_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram */
-	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram */
-	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram */
-	uint64_t tw3_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW3_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_3.sq_fifo_sram */
-	uint64_t tw2_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW2_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_2.sq_fifo_sram */
-	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_1.sq_fifo_sram */
-	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram */
-	uint64_t tp3_sram_dbe                 : 1;  /**< Double-bit error for TP3_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp3_sram */
-	uint64_t tp2_sram_dbe                 : 1;  /**< Double-bit error for TP2_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp2_sram */
-	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp1_sram */
-	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram */
-	uint64_t sts3_ram_dbe                 : 1;  /**< Double-bit error for STS3_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts3_sram */
-	uint64_t sts2_ram_dbe                 : 1;  /**< Double-bit error for STS2_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts2_sram */
-	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts1_sram */
-	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram */
-	uint64_t std3_ram_dbe                 : 1;  /**< Double-bit error for STD3_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std3_sram */
-	uint64_t std2_ram_dbe                 : 1;  /**< Double-bit error for STD2_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std2_sram */
-	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std1_sram */
-	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram */
-	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram */
-	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. */
+	uint64_t tw3_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW3_CMD_FIFO_RAM. */
+	uint64_t tw2_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW2_CMD_FIFO_RAM. */
+	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. */
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. */
+	uint64_t tp3_sram_dbe                 : 1;  /**< Double-bit error for TP3_SRAM. */
+	uint64_t tp2_sram_dbe                 : 1;  /**< Double-bit error for TP2_SRAM. */
+	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. */
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. */
+	uint64_t sts3_ram_dbe                 : 1;  /**< Double-bit error for STS3_RAM. */
+	uint64_t sts2_ram_dbe                 : 1;  /**< Double-bit error for STS2_RAM. */
+	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM. */
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. */
+	uint64_t std3_ram_dbe                 : 1;  /**< Double-bit error for STD3_RAM. */
+	uint64_t std2_ram_dbe                 : 1;  /**< Double-bit error for STD2_RAM. */
+	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. */
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -15736,25 +15341,19 @@ union cvmx_pko_pse_sq3_ecc_dbe_sts0 {
 	} s;
 	struct cvmx_pko_pse_sq3_ecc_dbe_sts0_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram */
-	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram */
-	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. */
 	uint64_t reserved_58_60               : 3;
-	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. */
 	uint64_t reserved_54_56               : 3;
-	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram */
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. */
 	uint64_t reserved_50_52               : 3;
-	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram */
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. */
 	uint64_t reserved_46_48               : 3;
-	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram */
-	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram */
-	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -15789,17 +15388,7 @@ union cvmx_pko_pse_sq3_ecc_dbe_sts_cmb0 {
 	uint64_t pse_sq3_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ3_ECC_DBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_SQ3_ECC_DBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_SQ3_DBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ3_DBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -15820,45 +15409,27 @@ union cvmx_pko_pse_sq3_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq3_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram */
-	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram */
-	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram */
-	uint64_t tw3_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW3_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_3.sq_fifo_sram */
-	uint64_t tw2_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW2_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_2.sq_fifo_sram */
-	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_1.sq_fifo_sram */
-	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram */
-	uint64_t tp3_sram_sbe                 : 1;  /**< Single-bit error for TP3_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp3_sram */
-	uint64_t tp2_sram_sbe                 : 1;  /**< Single-bit error for TP2_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp2_sram */
-	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp1_sram */
-	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram */
-	uint64_t sts3_ram_sbe                 : 1;  /**< Single-bit error for STS3_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts3_sram */
-	uint64_t sts2_ram_sbe                 : 1;  /**< Single-bit error for STS2_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts2_sram */
-	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts1_sram */
-	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram */
-	uint64_t std3_ram_sbe                 : 1;  /**< Single-bit error for STD3_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std3_sram */
-	uint64_t std2_ram_sbe                 : 1;  /**< Single-bit error for STD2_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std2_sram */
-	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std1_sram */
-	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram */
-	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram */
-	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. */
+	uint64_t tw3_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW3_CMD_FIFO_RAM. */
+	uint64_t tw2_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW2_CMD_FIFO_RAM. */
+	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. */
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. */
+	uint64_t tp3_sram_sbe                 : 1;  /**< Single-bit error for TP3_SRAM. */
+	uint64_t tp2_sram_sbe                 : 1;  /**< Single-bit error for TP2_SRAM. */
+	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. */
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. */
+	uint64_t sts3_ram_sbe                 : 1;  /**< Single-bit error for STS3_RAM. */
+	uint64_t sts2_ram_sbe                 : 1;  /**< Single-bit error for STS2_RAM. */
+	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. */
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. */
+	uint64_t std3_ram_sbe                 : 1;  /**< Single-bit error for STD3_RAM. */
+	uint64_t std2_ram_sbe                 : 1;  /**< Single-bit error for STD2_RAM. */
+	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. */
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -15887,25 +15458,19 @@ union cvmx_pko_pse_sq3_ecc_sbe_sts0 {
 	} s;
 	struct cvmx_pko_pse_sq3_ecc_sbe_sts0_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram */
-	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram */
-	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. */
 	uint64_t reserved_58_60               : 3;
-	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram */
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. */
 	uint64_t reserved_54_56               : 3;
-	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram */
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. */
 	uint64_t reserved_50_52               : 3;
-	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram */
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. */
 	uint64_t reserved_46_48               : 3;
-	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram */
-	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram */
-	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -15940,17 +15505,7 @@ union cvmx_pko_pse_sq3_ecc_sbe_sts_cmb0 {
 	uint64_t pse_sq3_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ3_ECC_SBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_SQ3_ECC_SBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_SQ3_SBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.nt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.pt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.rt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tw_0.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tp0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.std0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sts0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.wt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sc_sram */
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ3_SBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -16134,45 +15689,27 @@ union cvmx_pko_pse_sq4_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq4_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.pt_sram */
-	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.nt_sram */
-	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq5.rt_sram */
-	uint64_t tw3_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW3_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_3.sq_fifo_sram */
-	uint64_t tw2_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW2_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_2.sq_fifo_sram */
-	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_1.sq_fifo_sram */
-	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_0.sq_fifo_sram */
-	uint64_t tp3_sram_dbe                 : 1;  /**< Double-bit error for TP3_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp3_sram */
-	uint64_t tp2_sram_dbe                 : 1;  /**< Double-bit error for TP2_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp2_sram */
-	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp1_sram */
-	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp0_sram */
-	uint64_t sts3_ram_dbe                 : 1;  /**< Double-bit error for STS3_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts3_sram */
-	uint64_t sts2_ram_dbe                 : 1;  /**< Double-bit error for STS2_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts2_sram */
-	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts1_sram */
-	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts0_sram */
-	uint64_t std3_ram_dbe                 : 1;  /**< Double-bit error for STD3_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std3_sram */
-	uint64_t std2_ram_dbe                 : 1;  /**< Double-bit error for STD2_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std2_sram */
-	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std1_sram */
-	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std0_sram */
-	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq4.wt_sram */
-	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sc_sram */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. */
+	uint64_t tw3_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW3_CMD_FIFO_RAM. */
+	uint64_t tw2_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW2_CMD_FIFO_RAM. */
+	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. */
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. */
+	uint64_t tp3_sram_dbe                 : 1;  /**< Double-bit error for TP3_SRAM. */
+	uint64_t tp2_sram_dbe                 : 1;  /**< Double-bit error for TP2_SRAM. */
+	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. */
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. */
+	uint64_t sts3_ram_dbe                 : 1;  /**< Double-bit error for STS3_SRAM. */
+	uint64_t sts2_ram_dbe                 : 1;  /**< Double-bit error for STS2_SRAM. */
+	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_SRAM. */
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_SRAM. */
+	uint64_t std3_ram_dbe                 : 1;  /**< Double-bit error for STD3_RAM. */
+	uint64_t std2_ram_dbe                 : 1;  /**< Double-bit error for STD2_RAM. */
+	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. */
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -16214,29 +15751,7 @@ union cvmx_pko_pse_sq4_ecc_dbe_sts_cmb0 {
 	uint64_t pse_sq4_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ4_ECC_DBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_SQ4_ECC_DBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_SQ4_DBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.nt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.pt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.rt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_0.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_1.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_2.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_3.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp1_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp2_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp3_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std1_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std2_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std3_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts1_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts2_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts3_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.wt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sc_sram */
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ4_DBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -16255,45 +15770,27 @@ union cvmx_pko_pse_sq4_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq4_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.nt_sram */
-	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.pt_sram */
-	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq5.rt_sram */
-	uint64_t tw3_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW3_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_3.sq_fifo_sram */
-	uint64_t tw2_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW2_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_2.sq_fifo_sram */
-	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_1.sq_fifo_sram */
-	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_0.sq_fifo_sram */
-	uint64_t tp3_sram_sbe                 : 1;  /**< Single-bit error for TP3_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp3_sram */
-	uint64_t tp2_sram_sbe                 : 1;  /**< Single-bit error for TP2_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp2_sram */
-	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp1_sram */
-	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp0_sram */
-	uint64_t sts3_ram_sbe                 : 1;  /**< Single-bit error for STS3_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts3_sram */
-	uint64_t sts2_ram_sbe                 : 1;  /**< Single-bit error for STS2_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts2_sram */
-	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts1_sram */
-	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts0_sram */
-	uint64_t std3_ram_sbe                 : 1;  /**< Single-bit error for STD3_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std3_sram */
-	uint64_t std2_ram_sbe                 : 1;  /**< Single-bit error for STD2_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std2_sram */
-	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std1_sram */
-	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std0_sram */
-	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq4.wt_sram */
-	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sc_sram */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. */
+	uint64_t tw3_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW3_CMD_FIFO_RAM. */
+	uint64_t tw2_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW2_CMD_FIFO_RAM. */
+	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. */
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. */
+	uint64_t tp3_sram_sbe                 : 1;  /**< Single-bit error for TP3_SRAM. */
+	uint64_t tp2_sram_sbe                 : 1;  /**< Single-bit error for TP2_SRAM. */
+	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. */
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. */
+	uint64_t sts3_ram_sbe                 : 1;  /**< Single-bit error for STS3_RAM. */
+	uint64_t sts2_ram_sbe                 : 1;  /**< Single-bit error for STS2_RAM. */
+	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. */
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. */
+	uint64_t std3_ram_sbe                 : 1;  /**< Single-bit error for STD3_RAM. */
+	uint64_t std2_ram_sbe                 : 1;  /**< Single-bit error for STD2_RAM. */
+	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. */
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -16335,29 +15832,7 @@ union cvmx_pko_pse_sq4_ecc_sbe_sts_cmb0 {
 	uint64_t pse_sq4_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ4_ECC_SBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_SQ4_ECC_SBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_SQ4_SBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.nt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.pt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.rt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_0.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_1.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_2.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tw_3.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp1_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp2_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.tp3_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std1_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std2_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.std3_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts1_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts2_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sts3_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.wt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.sc_sram */
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ4_SBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -16539,45 +16014,27 @@ union cvmx_pko_pse_sq5_ecc_dbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq5_ecc_dbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.pt_sram */
-	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.nt_sram */
-	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq4.rt_sram */
-	uint64_t tw3_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW3_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_3.sq_fifo_sram */
-	uint64_t tw2_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW2_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_2.sq_fifo_sram */
-	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_1.sq_fifo_sram */
-	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_0.sq_fifo_sram */
-	uint64_t tp3_sram_dbe                 : 1;  /**< Double-bit error for TP3_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp3_sram */
-	uint64_t tp2_sram_dbe                 : 1;  /**< Double-bit error for TP2_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp2_sram */
-	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp1_sram */
-	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp0_sram */
-	uint64_t sts3_ram_dbe                 : 1;  /**< Double-bit error for STS3_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts3_sram */
-	uint64_t sts2_ram_dbe                 : 1;  /**< Double-bit error for STS2_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts2_sram */
-	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts1_sram */
-	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts0_sram */
-	uint64_t std3_ram_dbe                 : 1;  /**< Double-bit error for STD3_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std3_sram */
-	uint64_t std2_ram_dbe                 : 1;  /**< Double-bit error for STD2_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std2_sram */
-	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std1_sram */
-	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std0_sram */
-	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq5.wt_sram */
-	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sc_sram */
+	uint64_t sq_pt_ram_dbe                : 1;  /**< Double-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_dbe                : 1;  /**< Double-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_dbe                   : 1;  /**< Double-bit error for RT_RAM. */
+	uint64_t tw3_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW3_CMD_FIFO_RAM. */
+	uint64_t tw2_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW2_CMD_FIFO_RAM. */
+	uint64_t tw1_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW1_CMD_FIFO_RAM. */
+	uint64_t tw0_cmd_fifo_ram_dbe         : 1;  /**< Double-bit error for TW0_CMD_FIFO_RAM. */
+	uint64_t tp3_sram_dbe                 : 1;  /**< Double-bit error for TP3_SRAM. */
+	uint64_t tp2_sram_dbe                 : 1;  /**< Double-bit error for TP2_SRAM. */
+	uint64_t tp1_sram_dbe                 : 1;  /**< Double-bit error for TP1_SRAM. */
+	uint64_t tp0_sram_dbe                 : 1;  /**< Double-bit error for TP0_SRAM. */
+	uint64_t sts3_ram_dbe                 : 1;  /**< Double-bit error for STS3_RAM. */
+	uint64_t sts2_ram_dbe                 : 1;  /**< Double-bit error for STS2_RAM. */
+	uint64_t sts1_ram_dbe                 : 1;  /**< Double-bit error for STS1_RAM. */
+	uint64_t sts0_ram_dbe                 : 1;  /**< Double-bit error for STS0_RAM. */
+	uint64_t std3_ram_dbe                 : 1;  /**< Double-bit error for STD3_RAM. */
+	uint64_t std2_ram_dbe                 : 1;  /**< Double-bit error for STD2_RAM. */
+	uint64_t std1_ram_dbe                 : 1;  /**< Double-bit error for STD1_RAM. */
+	uint64_t std0_ram_dbe                 : 1;  /**< Double-bit error for STD0_RAM. */
+	uint64_t wt_ram_dbe                   : 1;  /**< Double-bit error for WT_RAM. */
+	uint64_t sc_ram_dbe                   : 1;  /**< Double-bit error for SC_RAM. */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -16619,29 +16076,7 @@ union cvmx_pko_pse_sq5_ecc_dbe_sts_cmb0 {
 	uint64_t pse_sq5_dbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ5_ECC_DBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_SQ5_ECC_DBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_SQ5_DBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.nt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.pt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.rt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_0.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_1.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_2.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_3.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp1_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp2_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp3_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std1_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std2_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std3_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts1_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts2_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts3_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.wt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sc_sram */
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ5_DBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
@@ -16660,45 +16095,27 @@ union cvmx_pko_pse_sq5_ecc_sbe_sts0 {
 	uint64_t u64;
 	struct cvmx_pko_pse_sq5_ecc_sbe_sts0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.pt_sram */
-	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.nt_sram */
-	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq4.rt_sram */
-	uint64_t tw3_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW3_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_3.sq_fifo_sram */
-	uint64_t tw2_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW2_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_2.sq_fifo_sram */
-	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_1.sq_fifo_sram */
-	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_0.sq_fifo_sram */
-	uint64_t tp3_sram_sbe                 : 1;  /**< Single-bit error for TP3_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp3_sram */
-	uint64_t tp2_sram_sbe                 : 1;  /**< Single-bit error for TP2_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp2_sram */
-	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp1_sram */
-	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp0_sram */
-	uint64_t sts3_ram_sbe                 : 1;  /**< Single-bit error for STS3_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts3_sram */
-	uint64_t sts2_ram_sbe                 : 1;  /**< Single-bit error for STS2_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts2_sram */
-	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts1_sram */
-	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts0_sram */
-	uint64_t std3_ram_sbe                 : 1;  /**< Single-bit error for STD3_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std3_sram */
-	uint64_t std2_ram_sbe                 : 1;  /**< Single-bit error for STD2_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std2_sram */
-	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std1_sram */
-	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std0_sram */
-	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq5.wt_sram */
-	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. INTERNAL: Instances: pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sc_sram */
+	uint64_t sq_pt_ram_sbe                : 1;  /**< Single-bit error for SQ_PT_RAM. */
+	uint64_t sq_nt_ram_sbe                : 1;  /**< Single-bit error for SQ_NT_RAM. */
+	uint64_t rt_ram_sbe                   : 1;  /**< Single-bit error for RT_RAM. */
+	uint64_t tw3_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW3_CMD_FIFO_RAM. */
+	uint64_t tw2_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW2_CMD_FIFO_RAM. */
+	uint64_t tw1_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW1_CMD_FIFO_RAM. */
+	uint64_t tw0_cmd_fifo_ram_sbe         : 1;  /**< Single-bit error for TW0_CMD_FIFO_RAM. */
+	uint64_t tp3_sram_sbe                 : 1;  /**< Single-bit error for TP3_SRAM. */
+	uint64_t tp2_sram_sbe                 : 1;  /**< Single-bit error for TP2_SRAM. */
+	uint64_t tp1_sram_sbe                 : 1;  /**< Single-bit error for TP1_SRAM. */
+	uint64_t tp0_sram_sbe                 : 1;  /**< Single-bit error for TP0_SRAM. */
+	uint64_t sts3_ram_sbe                 : 1;  /**< Single-bit error for STS3_RAM. */
+	uint64_t sts2_ram_sbe                 : 1;  /**< Single-bit error for STS2_RAM. */
+	uint64_t sts1_ram_sbe                 : 1;  /**< Single-bit error for STS1_RAM. */
+	uint64_t sts0_ram_sbe                 : 1;  /**< Single-bit error for STS0_RAM. */
+	uint64_t std3_ram_sbe                 : 1;  /**< Single-bit error for STD3_RAM. */
+	uint64_t std2_ram_sbe                 : 1;  /**< Single-bit error for STD2_RAM. */
+	uint64_t std1_ram_sbe                 : 1;  /**< Single-bit error for STD1_RAM. */
+	uint64_t std0_ram_sbe                 : 1;  /**< Single-bit error for STD0_RAM. */
+	uint64_t wt_ram_sbe                   : 1;  /**< Single-bit error for WT_RAM. */
+	uint64_t sc_ram_sbe                   : 1;  /**< Single-bit error for SC_RAM. */
 	uint64_t reserved_0_42                : 43;
 #else
 	uint64_t reserved_0_42                : 43;
@@ -16740,29 +16157,7 @@ union cvmx_pko_pse_sq5_ecc_sbe_sts_cmb0 {
 	uint64_t pse_sq5_sbe_cmb0             : 1;  /**< This bit is the logical OR of all bits in PKO_PSE_SQ5_ECC_SBE_STS0.
                                                          To clear this bit, software must clear bits in PKO_PSE_SQ5_ECC_SBE_STS0.
                                                          When this bit is set, the corresponding interrupt is set.
-                                                         Throws PKO_INTSN_E::PKO_PSE_SQ5_SBE_CMB0.
-                                                         INTERNAL: Instances:
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.nt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.pt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.rt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_0.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_1.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_2.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.tw_3.sq_fifo_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp1_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp2_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq4.tp3_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std1_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std2_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.std3_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts0_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts1_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts2_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq3.sts3_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.wt_sram
-                                                         pko_pnr2.pko_pse.pse_sq5_sq3.sq5.sc_sram */
+                                                         Throws PKO_INTSN_E::PKO_PSE_SQ5_SBE_CMB0. */
 	uint64_t reserved_0_62                : 63;
 #else
 	uint64_t reserved_0_62                : 63;
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3.h b/arch/mips/include/asm/octeon/cvmx-pko3.h
index 7059519..a09d575 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3.h
@@ -492,6 +492,7 @@ typedef struct cvmx_pko3_dq_params_s {
 	int32_t	depth;
 	int32_t limit;
 #endif
+	uint64_t pad[15];
 } cvmx_pko3_dq_params_t;
 
 /* DQ depth cached value */
@@ -751,8 +752,25 @@ __cvmx_pko3_do_dma(uint8_t node, uint16_t dq, uint64_t cmds[],
 	cvmx_pko3_dq_params_t *pParam;
 
 	pParam = cvmx_pko3_dq_parameters(node, dq);
+	CVMX_PREFETCH0(pParam);
+	/* Push WB */
+	CVMX_SYNCWS;
 
 	pko_status.u64 = 0;
+	pko_send_dma_data.u64 = 0;
+
+	if (cvmx_unlikely(numwords > 15)) {
+		cvmx_dprintf("%s: ERROR: Internal error\n",
+				__FUNCTION__);
+		pko_status.u64 = ~0ull;
+		return pko_status;
+	}
+
+	/* Store the command words into CVMSEG LM */
+	for(i = 0, scr_off = scr_base; i < numwords; i++) {
+		cvmx_scratch_write64(scr_off, cmds[i]);
+		scr_off += sizeof(cmds[0]);
+	}
 
 	/* With 0 data to send, this is an IOBDMA, else LMTDMA operation */
 	if(numwords == 0) {
@@ -763,37 +781,25 @@ __cvmx_pko3_do_dma(uint8_t node, uint16_t dq, uint64_t cmds[],
 		dma_addr += (numwords - 1) << 3;
 	}
 
-	if (cvmx_unlikely(pParam->depth > pParam->limit) &&
-	    dqop == CVMX_PKO_DQ_SEND) {
-		cvmx_pko_dqx_wm_cnt_t wm_cnt;
-		wm_cnt.u64 = cvmx_read_csr_node(node,CVMX_PKO_DQX_WM_CNT(dq));
-		pParam->depth = pko_status.s.depth = wm_cnt.s.count;
+	if (cvmx_likely(dqop == CVMX_PKO_DQ_SEND)) {
+		if (cvmx_unlikely(pParam->depth > pParam->limit)) {
+			cvmx_pko_dqx_wm_cnt_t wm_cnt;
+			wm_cnt.u64 = cvmx_read_csr_node(node,
+				CVMX_PKO_DQX_WM_CNT(dq));
+			pParam->depth = pko_status.s.depth = wm_cnt.s.count;
+		}
 
-		if (pParam->depth > pParam->limit) {
+		if (cvmx_unlikely(pParam->depth > pParam->limit)) {
 			pko_status.s.dqop = dqop;
 			pko_status.s.dqstatus = PKO_DQSTATUS_NOFPABUF;
 			return pko_status;
+		} else {
+			cvmx_atomic_add32_nosync( &(pParam->depth), 1);
 		}
-	} else {
-		cvmx_atomic_add32_nosync( &(pParam->depth), 1);
-	}
-
-	if (numwords > 15) {
-		cvmx_dprintf("%s: ERROR: Internal error\n",
-				__FUNCTION__);
-		pko_status.u64 = ~0ull;
-		return pko_status;
 	}
 
-	/* Store the command words into CVMSEG LM */
-	for(i = 0, scr_off = scr_base; i < numwords; i++) {
-		cvmx_scratch_write64(scr_off, cmds[i]);
-		scr_off += sizeof(cmds[0]);
-	}
-
-	pko_send_dma_data.u64 = 0;
-
-	if (dqop != CVMX_PKO_DQ_SEND || CVMX_ENABLE_PARAMETER_CHECKING) {
+	if (cvmx_unlikely(dqop != CVMX_PKO_DQ_SEND) ||
+	    CVMX_ENABLE_PARAMETER_CHECKING) {
 		/* Request one return word */
 		pko_send_dma_data.s.rtnlen = 1;
 		/* Write all-ones into the return area */
@@ -906,7 +912,7 @@ cvmx_pko3_xmit_link_buf(int dq,cvmx_buf_ptr_pki_t pki_ptr,
 
 	/* To preserve packet order, go atomic with DQ-specific tag */
 	if (ptag != NULL)
-		cvmx_pow_tag_sw_nocheck(*ptag ^ dq, CVMX_POW_TAG_TYPE_ATOMIC);
+		cvmx_pow_tag_sw(*ptag ^ dq, CVMX_POW_TAG_TYPE_ATOMIC);
  
 	/* Do LMTDMA */
 	pko_status = __cvmx_pko3_lmtdma(node, dq, nwords, ptag != NULL);
diff --git a/arch/mips/include/asm/octeon/cvmx-pow.h b/arch/mips/include/asm/octeon/cvmx-pow.h
index ac1a9a3..bc443bd 100644
--- a/arch/mips/include/asm/octeon/cvmx-pow.h
+++ b/arch/mips/include/asm/octeon/cvmx-pow.h
@@ -40,7 +40,7 @@
 /**
  * @file
  *
- * Interface to the hardware Packet Order / Work unit.
+ * Interface to the hardware Scheduling unit.
  *
  * New, starting with SDK 1.7.0, cvmx-pow supports a number of
  * extended consistency checks. The define
@@ -59,9 +59,7 @@
  * - Illegal deschedule request.
  * - WQE pointer not matching the one attached to the core by
  *   the POW.
- *
  */
-
 #ifndef __CVMX_POW_H__
 #define __CVMX_POW_H__
 
@@ -92,15 +90,15 @@ extern "C" {
  * for distinction from legacy-style groups (0..15)
  */
 typedef union {
-	uint8_t		xgrp;
+	uint8_t xgrp;
 	/* Fields that map XGRP for backwards compatibility */
 	struct __attribute__ ((__packed__)) {
 #ifdef __BIG_ENDIAN_BITFIELD
-		uint8_t	group: 5,
-			qus: 3;
+		uint8_t	group : 5;
+		uint8_t	qus   : 3;
 #else
-		uint8_t	qus: 3,
-			group: 5;
+		uint8_t	qus   : 3;
+		uint8_t	group : 5;
 #endif
 	};
 } cvmx_xgrp_t;
@@ -112,7 +110,7 @@ typedef union {
 typedef struct {
 	uint32_t tag;
 	uint16_t index;
-	uint8_t grp;	/* Legacy group # (0..15) */
+	uint8_t grp; /* Legacy group # (0..15) */
 	uint8_t tag_type;
 } cvmx_pow_tag_info_t;
 
@@ -129,52 +127,52 @@ typedef enum {
  */
 typedef enum {
 	CVMX_POW_TAG_OP_SWTAG = 0L,
-					/**< switch the tag (only) for this PP
-                                            - the previous tag should be non-NULL in this case
-                                            - tag switch response required
-                                            - fields used: op, type, tag */
+		/**< Switch the tag (only) for this PP
+         - the previous tag should be non-NULL in this case
+         - tag switch response required
+         - fields used: op, type, tag */
 	CVMX_POW_TAG_OP_SWTAG_FULL = 1L,
-					/**< switch the tag for this PP, with full information
-                                            - this should be used when the previous tag is NULL
-                                            - tag switch response required
-                                            - fields used: address, op, grp, type, tag */
+		/**< Switch the tag for this PP, with full information
+         - this should be used when the previous tag is NULL
+         - tag switch response required
+         - fields used: address, op, grp, type, tag */
 	CVMX_POW_TAG_OP_SWTAG_DESCH = 2L,
-					/**< switch the tag (and/or group) for this PP and de-schedule
-                                            - OK to keep the tag the same and only change the group
-                                            - fields used: op, no_sched, grp, type, tag */
+		/**< Switch the tag (and/or group) for this PP and de-schedule
+         - OK to keep the tag the same and only change the group
+         - fields used: op, no_sched, grp, type, tag */
 	CVMX_POW_TAG_OP_DESCH = 3L,
-					/**< just de-schedule
-                                            - fields used: op, no_sched */
+		/**< Just de-schedule
+         - fields used: op, no_sched */
 	CVMX_POW_TAG_OP_ADDWQ = 4L,
-					/**< create an entirely new work queue entry
-                                            - fields used: address, op, qos, grp, type, tag */
+		/**< Create an entirely new work queue entry
+         - fields used: address, op, qos, grp, type, tag */
 	CVMX_POW_TAG_OP_UPDATE_WQP_GRP = 5L,
-					/**< just update the work queue pointer and grp for this PP
-                                            - fields used: address, op, grp */
+		/**< Just update the work queue pointer and grp for this PP
+         - fields used: address, op, grp */
 	CVMX_POW_TAG_OP_SET_NSCHED = 6L,
-					/**< set the no_sched bit on the de-schedule list
-                                            - does nothing if the selected entry is not on the de-schedule list
-                                            - does nothing if the stored work queue pointer does not match the address field
-                                            - fields used: address, index, op
-                                            Before issuing a *_NSCHED operation, SW must guarantee that all
-                                            prior deschedules and set/clr NSCHED operations are complete and all
-                                            prior switches are complete. The hardware provides the opsdone bit
-                                            and swdone bit for SW polling. After issuing a *_NSCHED operation,
-                                            SW must guarantee that the set/clr NSCHED is complete before
-                                            any subsequent operations. */
+		/**< Set the no_sched bit on the de-schedule list
+         - does nothing if the selected entry is not on the de-schedule list
+         - does nothing if the stored work queue pointer does not match the address field
+         - fields used: address, index, op
+         Before issuing a *_NSCHED operation, SW must guarantee that all
+         prior deschedules and set/clr NSCHED operations are complete and all
+         prior switches are complete. The hardware provides the opsdone bit
+         and swdone bit for SW polling. After issuing a *_NSCHED operation,
+         SW must guarantee that the set/clr NSCHED is complete before
+         any subsequent operations. */
 	CVMX_POW_TAG_OP_CLR_NSCHED = 7L,
-					/**< clears the no_sched bit on the de-schedule list
-                                            - does nothing if the selected entry is not on the de-schedule list
-                                            - does nothing if the stored work queue pointer does not match the address field
-                                            - fields used: address, index, op
-                                            Before issuing a *_NSCHED operation, SW must guarantee that all
-                                            prior deschedules and set/clr NSCHED operations are complete and all
-                                            prior switches are complete. The hardware provides the opsdone bit
-                                            and swdone bit for SW polling. After issuing a *_NSCHED operation,
-                                            SW must guarantee that the set/clr NSCHED is complete before
-                                            any subsequent operations. */
+		/**< Clears the no_sched bit on the de-schedule list
+         - does nothing if the selected entry is not on the de-schedule list
+         - does nothing if the stored work queue pointer does not match the address field
+         - fields used: address, index, op
+         Before issuing a *_NSCHED operation, SW must guarantee that all
+         prior deschedules and set/clr NSCHED operations are complete and all
+         prior switches are complete. The hardware provides the opsdone bit
+         and swdone bit for SW polling. After issuing a *_NSCHED operation,
+         SW must guarantee that the set/clr NSCHED is complete before
+         any subsequent operations. */
 	CVMX_POW_TAG_OP_NOP = 15L
-					/**< do nothing */
+		/**< Do nothing */
 } cvmx_pow_tag_op_t;
 
 /**
@@ -184,128 +182,171 @@ typedef union {
 	uint64_t u64;
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
-		uint64_t no_sched:1;	     /**< don't reschedule this entry. no_sched is used for CVMX_POW_TAG_OP_SWTAG_DESCH and CVMX_POW_TAG_OP_DESCH */
-		uint64_t unused:2;
-		uint64_t index:13;	     /**< contains index of entry for a CVMX_POW_TAG_OP_*_NSCHED */
-		cvmx_pow_tag_op_t op:4;
-					     /**< the operation to perform */
-		uint64_t unused2:2;
-		uint64_t qos:3;		     /**< the QOS level for the packet. qos is only used for CVMX_POW_TAG_OP_ADDWQ */
-		uint64_t grp:4;		     /**< the group that the work queue entry will be scheduled to grp is used for CVMX_POW_TAG_OP_ADDWQ, CVMX_POW_TAG_OP_SWTAG_FULL, CVMX_POW_TAG_OP_SWTAG_DESCH, and CVMX_POW_TAG_OP_UPDATE_WQP_GRP */
-		cvmx_pow_tag_type_t type:3;
-					     /**< the type of the tag. type is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
-		uint64_t tag:32;	     /**< the actual tag. tag is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
+		uint64_t no_sched :1;
+			/**< Don't reschedule this entry.
+			 no_sched is used for CVMX_POW_TAG_OP_SWTAG_DESCH and CVMX_POW_TAG_OP_DESCH */
+		uint64_t unused :2;
+		uint64_t index :13;
+			/**< Contains index of entry for a CVMX_POW_TAG_OP_*_NSCHED */
+		cvmx_pow_tag_op_t op :4;
+			/**< The operation to perform */
+		uint64_t unused2 :2;
+		uint64_t qos :3;
+			/**< The QOS level for the packet. qos is only used for CVMX_POW_TAG_OP_ADDWQ */
+		uint64_t grp :4;
+			/**< The group that the work queue entry will be scheduled to grp is used for
+			 CVMX_POW_TAG_OP_ADDWQ, CVMX_POW_TAG_OP_SWTAG_FULL, CVMX_POW_TAG_OP_SWTAG_DESCH,
+			 and CVMX_POW_TAG_OP_UPDATE_WQP_GRP */
+		cvmx_pow_tag_type_t type :3;
+			/**< The type of the tag. type is used for everything except
+			 CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and
+			 CVMX_POW_TAG_OP_*_NSCHED */
+		uint64_t tag :32;
+			/**< The actual tag. tag is used for everything except
+			 CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and
+			CVMX_POW_TAG_OP_*_NSCHED */
 #else
-		uint64_t tag:32;
-		cvmx_pow_tag_type_t type:3;
-		uint64_t grp:4;
-		uint64_t qos:3;
-		uint64_t unused2:2;
-		cvmx_pow_tag_op_t op:4;
-		uint64_t index:13;
-		uint64_t unused:2;
-		uint64_t no_sched:1;
+		uint64_t tag :32;
+		cvmx_pow_tag_type_t type :3;
+		uint64_t grp :4;
+		uint64_t qos :3;
+		uint64_t unused2 :2;
+		cvmx_pow_tag_op_t op :4;
+		uint64_t index :13;
+		uint64_t unused :2;
+		uint64_t no_sched :1;
 #endif
 	} s_cn38xx;
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
-		uint64_t no_sched:1;	     /**< don't reschedule this entry. no_sched is used for CVMX_POW_TAG_OP_SWTAG_DESCH and CVMX_POW_TAG_OP_DESCH */
-		cvmx_pow_tag_op_t op:4;
-					     /**< the operation to perform */
-		uint64_t unused1:4;
-		uint64_t index:11;	     /**< contains index of entry for a CVMX_POW_TAG_OP_*_NSCHED */
-		uint64_t unused2:1;
-		uint64_t grp:6;		     /**< the group that the work queue entry will be scheduled to grp is used for CVMX_POW_TAG_OP_ADDWQ, CVMX_POW_TAG_OP_SWTAG_FULL, CVMX_POW_TAG_OP_SWTAG_DESCH, and CVMX_POW_TAG_OP_UPDATE_WQP_GRP */
-		uint64_t unused3:3;
-		cvmx_pow_tag_type_t type:2;
-					     /**< the type of the tag. type is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
-		uint64_t tag:32;	     /**< the actual tag. tag is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
+		uint64_t no_sched :1;
+			/**< Don't reschedule this entry.
+			 no_sched is used for CVMX_POW_TAG_OP_SWTAG_DESCH and CVMX_POW_TAG_OP_DESCH */
+		cvmx_pow_tag_op_t op :4;
+			/**< The operation to perform */
+		uint64_t unused1 :4;
+		uint64_t index :11;
+			/**< Contains index of entry for a CVMX_POW_TAG_OP_*_NSCHED */
+		uint64_t unused2 :1;
+		uint64_t grp :6;
+			/**< The group that the work queue entry will be scheduled to grp is used
+			 for CVMX_POW_TAG_OP_ADDWQ, CVMX_POW_TAG_OP_SWTAG_FULL,
+			 CVMX_POW_TAG_OP_SWTAG_DESCH, and CVMX_POW_TAG_OP_UPDATE_WQP_GRP */
+		uint64_t unused3 :3;
+		cvmx_pow_tag_type_t type :2;
+			/**< The type of the tag.
+			 type is used for everything except CVMX_POW_TAG_OP_DESCH,
+			 CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
+		uint64_t tag :32;
+			/**< The actual tag.
+			 tag is used for everything except CVMX_POW_TAG_OP_DESCH,
+			 CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
 #else
-		uint64_t tag:32;
-		cvmx_pow_tag_type_t type:2;
-		uint64_t unused3:3;
-		uint64_t grp:6;
-		uint64_t unused2:1;
-		uint64_t index:11;
-		uint64_t unused1:4;
-		cvmx_pow_tag_op_t op:4;
-		uint64_t no_sched:1;
+		uint64_t tag :32;
+		cvmx_pow_tag_type_t type :2;
+		uint64_t unused3 :3;
+		uint64_t grp :6;
+		uint64_t unused2 :1;
+		uint64_t index :11;
+		uint64_t unused1 :4;
+		cvmx_pow_tag_op_t op :4;
+		uint64_t no_sched :1;
 #endif
 	} s_cn68xx_clr;
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
-		uint64_t no_sched:1;	     /**< don't reschedule this entry. no_sched is used for CVMX_POW_TAG_OP_SWTAG_DESCH and CVMX_POW_TAG_OP_DESCH */
-		cvmx_pow_tag_op_t op:4;
-					     /**< the operation to perform */
-		uint64_t unused1:12;
-		uint64_t qos:3;		     /**< contains index of entry for a CVMX_POW_TAG_OP_*_NSCHED */
-		uint64_t unused2:1;
-		uint64_t grp:6;		     /**< the group that the work queue entry will be scheduled to grp is used for CVMX_POW_TAG_OP_ADDWQ, CVMX_POW_TAG_OP_SWTAG_FULL, CVMX_POW_TAG_OP_SWTAG_DESCH, and CVMX_POW_TAG_OP_UPDATE_WQP_GRP */
-		uint64_t unused3:3;
-		cvmx_pow_tag_type_t type:2;
-					     /**< the type of the tag. type is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
-		uint64_t tag:32;	     /**< the actual tag. tag is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
+		uint64_t no_sched :1;
+			/**< Don't reschedule this entry.
+			 no_sched is used for CVMX_POW_TAG_OP_SWTAG_DESCH and CVMX_POW_TAG_OP_DESCH */
+		cvmx_pow_tag_op_t op :4;
+			/**< The operation to perform */
+		uint64_t unused1 :12;
+		uint64_t qos :3;
+			/**< Contains index of entry for a CVMX_POW_TAG_OP_*_NSCHED */
+		uint64_t unused2 :1;
+		uint64_t grp :6;
+			/**< The group that the work queue entry will be scheduled to grp is used
+			 for CVMX_POW_TAG_OP_ADDWQ, CVMX_POW_TAG_OP_SWTAG_FULL,
+			 CVMX_POW_TAG_OP_SWTAG_DESCH, and CVMX_POW_TAG_OP_UPDATE_WQP_GRP */
+		uint64_t unused3 :3;
+		cvmx_pow_tag_type_t type :2;
+			/**< The type of the tag. type is used for everything except
+			 CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and
+			 CVMX_POW_TAG_OP_*_NSCHED */
+		uint64_t tag :32;
+			/**< The actual tag. tag is used for everything except CVMX_POW_TAG_OP_DESCH,
+			 CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
 #else
-		uint64_t tag:32;
-		cvmx_pow_tag_type_t type:2;
-		uint64_t unused3:3;
-		uint64_t grp:6;
-		uint64_t unused2:1;
-		uint64_t qos:3;
-		uint64_t unused1:12;
-		cvmx_pow_tag_op_t op:4;
-		uint64_t no_sched:1;
+		uint64_t tag :32;
+		cvmx_pow_tag_type_t type :2;
+		uint64_t unused3 :3;
+		uint64_t grp :6;
+		uint64_t unused2 :1;
+		uint64_t qos :3;
+		uint64_t unused1 :12;
+		cvmx_pow_tag_op_t op :4;
+		uint64_t no_sched :1;
 #endif
 	} s_cn68xx_add;
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
-		uint64_t no_sched:1;	     /**< don't reschedule this entry. no_sched is used for CVMX_POW_TAG_OP_SWTAG_DESCH and CVMX_POW_TAG_OP_DESCH */
-		cvmx_pow_tag_op_t op:4;
-					     /**< the operation to perform */
-		uint64_t unused1:16;
-		uint64_t grp:6;		     /**< the group that the work queue entry will be scheduled to grp is used for CVMX_POW_TAG_OP_ADDWQ, CVMX_POW_TAG_OP_SWTAG_FULL, CVMX_POW_TAG_OP_SWTAG_DESCH, and CVMX_POW_TAG_OP_UPDATE_WQP_GRP */
-		uint64_t unused3:3;
-		cvmx_pow_tag_type_t type:2;
-					     /**< the type of the tag. type is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
-		uint64_t tag:32;	     /**< the actual tag. tag is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
+		uint64_t no_sched :1;
+			/**< Don't reschedule this entry.
+			 no_sched is used for CVMX_POW_TAG_OP_SWTAG_DESCH and CVMX_POW_TAG_OP_DESCH */
+		cvmx_pow_tag_op_t op :4;
+			/**< The operation to perform */
+		uint64_t unused1 :16;
+		uint64_t grp :6;
+			/**< The group that the work queue entry will be scheduled to grp is used
+			 for CVMX_POW_TAG_OP_ADDWQ, CVMX_POW_TAG_OP_SWTAG_FULL,
+			 CVMX_POW_TAG_OP_SWTAG_DESCH, and CVMX_POW_TAG_OP_UPDATE_WQP_GRP */
+		uint64_t unused3 :3;
+		cvmx_pow_tag_type_t type :2;
+			/**< The type of the tag.
+			 type is used for everything except CVMX_POW_TAG_OP_DESCH,
+			 CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
+		uint64_t tag :32;
+			/**< The actual tag.
+			 tag is used for everything except CVMX_POW_TAG_OP_DESCH,
+			 CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
 #else
-		uint64_t tag:32;
-		cvmx_pow_tag_type_t type:2;
-		uint64_t unused3:3;
-		uint64_t grp:6;
-		uint64_t unused1:16;
-		cvmx_pow_tag_op_t op:4;
-		uint64_t no_sched:1;
+		uint64_t tag :32;
+		cvmx_pow_tag_type_t type :2;
+		uint64_t unused3 :3;
+		uint64_t grp :6;
+		uint64_t unused1 :16;
+		cvmx_pow_tag_op_t op :4;
+		uint64_t no_sched :1;
 #endif
 	} s_cn68xx_other;
 
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
-		uint64_t rsvd_62_63:2;
-		/** Group that the work-queue entry will be scheduled to. Grp
-		   is used for ADDWQ, SWTAG_FULL, SWTAG_DESCH, UPD_WQP_GRP. */
-		uint64_t grp:10; /** NODE+LGROUP */
-		cvmx_pow_tag_type_t type:2; /** The type of the tag */
-		/** Don't reschedule this entry. NOSCHED is used for
-		   SWTAG_DESCH and DESCHED.*/
-		uint64_t no_sched:1;
-		uint64_t rsvd_48:1;
-		/** the operation to perform */
-		cvmx_pow_tag_op_t op:4;
-		uint64_t rsvd_42_43:2;
-		/** Address of the work-queue entry. Must be aligned on a 64-bit
-		    boundary. Used for SWTAG_FULL, ADDWQ, UPD_WQP_GRP;
-		    addr<2:0> must be zero. */
-		uint64_t wqp:42;
+		uint64_t rsvd_62_63 :2;
+		uint64_t grp :10; /** NODE+LGROUP */
+			/** Group that the work-queue entry will be scheduled to.
+			 grp is used for ADDWQ, SWTAG_FULL, SWTAG_DESCH, UPD_WQP_GRP. */
+		cvmx_pow_tag_type_t type :2;
+			/** The type of the tag */
+		uint64_t no_sched :1;
+			/** Don't reschedule this entry. NOSCHED is used for SWTAG_DESCH and DESCHED.*/
+		uint64_t rsvd_48 :1;
+		cvmx_pow_tag_op_t op :4;
+			/** The operation to perform */
+		uint64_t rsvd_42_43 :2;
+		uint64_t wqp :42;
+			/** Address of the work-queue entry. Must be aligned on a 64-bit boundary.
+			 Used for SWTAG_FULL, ADDWQ, UPD_WQP_GRP; addr<2:0> must be zero. */
 #else
-		uint64_t wqp:42;
-		uint64_t rsvd_42_43:2;
-		cvmx_pow_tag_op_t op:4; /**< the operation to perform */
-		uint64_t rsvd_48:1;
-		uint64_t no_sched:1;
-		cvmx_pow_tag_type_t type:2;
-		uint64_t grp:10;
-		uint64_t rsvd_62_63:2;
+		uint64_t wqp :42;
+		uint64_t rsvd_42_43 :2;
+		cvmx_pow_tag_op_t op :4;
+			/**< The operation to perform */
+		uint64_t rsvd_48 :1;
+		uint64_t no_sched :1;
+		cvmx_pow_tag_type_t type :2;
+		uint64_t grp :10;
+		uint64_t rsvd_62_63 :2;
 #endif
 	} s_cn78xx_other;
 
@@ -314,29 +355,29 @@ typedef union {
 union cvmx_pow_tag_req_addr {
 	uint64_t u64;
 	struct {
-		/**< Mips64 address region. Should be CVMX_IO_SEG */
-		CVMX_BITFIELD_FIELD(uint64_t mem_region:2,
-		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61:13,
-		CVMX_BITFIELD_FIELD(uint64_t is_io:1,/**< Must be one */
-	        CVMX_BITFIELD_FIELD(uint64_t did:8,
-		CVMX_BITFIELD_FIELD(uint64_t addr:40,
-				    ;)))))
+		CVMX_BITFIELD_FIELD(uint64_t mem_region :2,
+			/**< Mips64 address region. Should be CVMX_IO_SEG */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61 :13,
+		CVMX_BITFIELD_FIELD(uint64_t is_io :1,/**< Must be one */
+		CVMX_BITFIELD_FIELD(uint64_t did :8,
+		CVMX_BITFIELD_FIELD(uint64_t addr :40,
+	    ;)))))
 	} s;
 	struct {
-		/**< Mips64 address region. Should be CVMX_IO_SEG */
-		CVMX_BITFIELD_FIELD(uint64_t mem_region:2,
-		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61:13,
-		CVMX_BITFIELD_FIELD(uint64_t is_io:1,           /**< Must be one */
-		CVMX_BITFIELD_FIELD(uint64_t did:8,
-		/**<OCI node number. For SWTAG*, and UPD_WQP_GRP this must
-		   always indicate the local node, or an error will result.
-		   ADDWQ can be performed onto any node. */
-		CVMX_BITFIELD_FIELD(uint64_t node:4,
-		/**< The actual tag. Tag is used for SWTAG, SWTAG_FULL,
-		   SWTAG_DESCHED, ADDWQ. */
-		CVMX_BITFIELD_FIELD(uint64_t tag:32,
-		CVMX_BITFIELD_FIELD(uint64_t reserved_0_3:4,
-				    ;)))))))
+		CVMX_BITFIELD_FIELD(uint64_t mem_region :2,
+			/**< Mips64 address region. Should be CVMX_IO_SEG */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61 :13,
+		CVMX_BITFIELD_FIELD(uint64_t is_io :1, /**< Must be one */
+		CVMX_BITFIELD_FIELD(uint64_t did :8,
+		CVMX_BITFIELD_FIELD(uint64_t node :4,
+			/**<OCI node number. For SWTAG*, and UPD_WQP_GRP this must
+			 always indicate the local node, or an error will result.
+			 ADDWQ can be performed onto any node. */
+		CVMX_BITFIELD_FIELD(uint64_t tag :32,
+			/**< The actual tag. Tag is used for SWTAG, SWTAG_FULL,
+			 SWTAG_DESCHED, ADDWQ. */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_0_3 :4,
+	    ;)))))))
 	} s_cn78xx;
 };
 
@@ -345,195 +386,195 @@ union cvmx_pow_tag_req_addr {
  */
 typedef union {
 	uint64_t u64;
-
-    /**
-     * Address for new work request loads (did<2:0> == 0)
-     */
+	/**
+	 * Address for new work request loads (did<2:0> == 0)
+	 */
 	struct {
-		CVMX_BITFIELD_FIELD(uint64_t mem_region:2,
-					    /**< Mips64 address region. Should be CVMX_IO_SEG */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61:13,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t is_io:1,	    /**< Must be one */
-		CVMX_BITFIELD_FIELD(uint64_t did:8,		    /**< the ID of POW -- did<2:0> == 0 in this case */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_4_39:36,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t wait:1,	    /**< If set, don't return load response until work is available */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2:3,
-					    /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t mem_region :2,
+		    /**< Mips64 address region. Should be CVMX_IO_SEG */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61 :13, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t is_io :1, /**< Must be one */
+		CVMX_BITFIELD_FIELD(uint64_t did :8,
+			/**< The ID of POW -- did<2:0> == 0 in this case */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_4_39 :36, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t wait :1,
+			/**< If set, don't return load response until work is available */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2 :3, /**< Must be zero */
 		)))))));
 	} swork;
 
 	struct {
-		CVMX_BITFIELD_FIELD(uint64_t mem_region:2,      /**< Mips64 address region. Should be CVMX_IO_SEG */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61:13, /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t is_io:1,           /**< Must be one */
-		CVMX_BITFIELD_FIELD(uint64_t did:8,             /**< the ID of POW -- did<2:0> == 0 in this case */
-		CVMX_BITFIELD_FIELD(uint64_t node:4,            /**< OCI Node number */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_32_35:4,  /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t indexed:1,  /**< Indexed get_work if set */
-		CVMX_BITFIELD_FIELD(uint64_t grouped:1,  /**< get_work for group specified in index */
-		CVMX_BITFIELD_FIELD(uint64_t rtngrp:1,  /**< Return group and tt in the return if set */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_16_28:13,  /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t index:12,  /**< mask/grp/index of the request */
-		CVMX_BITFIELD_FIELD(uint64_t wait:1,            /**< If set, don't return load response until work is available */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2:3,    /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t mem_region :2,
+			/**< Mips64 address region. Should be CVMX_IO_SEG */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61 :13, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t is_io :1, /**< Must be one */
+		CVMX_BITFIELD_FIELD(uint64_t did :8,
+			/**< The ID of POW -- did<2:0> == 0 in this case */
+		CVMX_BITFIELD_FIELD(uint64_t node :4, /**< OCI Node number */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_32_35 :4, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t indexed :1, /**< Indexed get_work if set */
+		CVMX_BITFIELD_FIELD(uint64_t grouped :1, /**< get_work for group specified in index */
+		CVMX_BITFIELD_FIELD(uint64_t rtngrp :1, /**< Return group and tt in the return if set */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_16_28 :13, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t index :12, /**< mask/grp/index of the request */
+		CVMX_BITFIELD_FIELD(uint64_t wait :1,
+			/**< If set, don't return load response until work is available */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2 :3, /**< Must be zero */
 		)))))))))))));
 	} swork_78xx;
-
-    /**
-     * Address for loads to get POW internal status
-     */
+	/**
+	 * Address for loads to get POW internal status
+	 */
 	struct {
-		CVMX_BITFIELD_FIELD(uint64_t mem_region:2,
-					    /**< Mips64 address region. Should be CVMX_IO_SEG */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61:13,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t is_io:1,	    /**< Must be one */
-		CVMX_BITFIELD_FIELD(uint64_t did:8,		    /**< the ID of POW -- did<2:0> == 1 in this case */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_10_39:30,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t coreid:4,	    /**< The core id to get status for */
-		CVMX_BITFIELD_FIELD(uint64_t get_rev:1,	    /**< If set and get_cur is set, return reverse tag-list pointer rather than forward tag-list pointer */
-		CVMX_BITFIELD_FIELD(uint64_t get_cur:1,	    /**< If set, return current status rather than pending status */
-		CVMX_BITFIELD_FIELD(uint64_t get_wqp:1,	    /**< If set, get the work-queue pointer rather than tag/type */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2:3,  /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t mem_region :2,
+		    /**< Mips64 address region. Should be CVMX_IO_SEG */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61 :13, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t is_io :1, /**< Must be one */
+		CVMX_BITFIELD_FIELD(uint64_t did :8,
+			/**< The ID of POW -- did<2:0> == 1 in this case */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_10_39 :30, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t coreid :4, /**< The core id to get status for */
+		CVMX_BITFIELD_FIELD(uint64_t get_rev :1,
+			/**< If set and get_cur is set, return reverse tag-list pointer rather
+			 than forward tag-list pointer */
+		CVMX_BITFIELD_FIELD(uint64_t get_cur :1,
+			/**< If set, return current status rather than pending status */
+		CVMX_BITFIELD_FIELD(uint64_t get_wqp :1,
+			/**< If set, get the work-queue pointer rather than tag/type */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2 :3, /**< Must be zero */
 		))))))))));
 	} sstatus;
-
-    /**
-     * Address for loads to get 68XX SS0 internal status
-     */
+	/**
+	 * Address for loads to get 68XX SS0 internal status
+	 */
 	struct {
-		CVMX_BITFIELD_FIELD(uint64_t mem_region:2,
-					    /**< Mips64 address region. Should be CVMX_IO_SEG */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61:13,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t is_io:1,	    /**< Must be one */
-		CVMX_BITFIELD_FIELD(uint64_t did:8,		    /**< the ID of POW -- did<2:0> == 1 in this case */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_14_39:26,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t coreid:5,	    /**< The core id to get status for */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_6_8:3,
-		CVMX_BITFIELD_FIELD(uint64_t opcode:3,	    /**< Status operation */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2:3, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t mem_region :2,
+		    /**< Mips64 address region. Should be CVMX_IO_SEG */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61 :13, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t is_io :1, /**< Must be one */
+		CVMX_BITFIELD_FIELD(uint64_t did :8,
+			/**< The ID of POW -- did<2:0> == 1 in this case */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_14_39 :26, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t coreid :5, /**< The core id to get status for */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_6_8 :3,
+		CVMX_BITFIELD_FIELD(uint64_t opcode :3, /**< Status operation */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2 :3, /**< Must be zero */
 		)))))))));
 	} sstatus_cn68xx;
-
-    /**
-     * Address for memory loads to get POW internal state
-     */
+	/**
+	 * Address for memory loads to get POW internal state
+	 */
 	struct {
-		CVMX_BITFIELD_FIELD(uint64_t mem_region:2,
-					    /**< Mips64 address region. Should be CVMX_IO_SEG */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61:13,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t is_io:1,	    /**< Must be one */
-		CVMX_BITFIELD_FIELD(uint64_t did:8,		    /**< the ID of POW -- did<2:0> == 2 in this case */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_16_39:24,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t index:11,	    /**< POW memory index */
-		CVMX_BITFIELD_FIELD(uint64_t get_des:1,	    /**< If set, return deschedule information rather than the standard
-                                                response for work-queue index (invalid if the work-queue entry is not on the
-                                                deschedule list). */
-		CVMX_BITFIELD_FIELD(uint64_t get_wqp:1,	    /**< If set, get the work-queue pointer rather than tag/type (no effect when get_des set). */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2:3,  /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t mem_region :2,
+		    /**< Mips64 address region. Should be CVMX_IO_SEG */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61 :13, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t is_io :1, /**< Must be one */
+		CVMX_BITFIELD_FIELD(uint64_t did :8,
+			/**< The ID of POW -- did<2:0> == 2 in this case */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_16_39 :24, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t index :11, /**< POW memory index */
+		CVMX_BITFIELD_FIELD(uint64_t get_des :1,
+			/**< If set, return deschedule information rather than the standard
+			 response for work-queue index (invalid if the work-queue entry is
+			 not on the deschedule list). */
+		CVMX_BITFIELD_FIELD(uint64_t get_wqp :1,
+			/**< If set, get the work-queue pointer rather than tag/type
+			 (no effect when get_des set). */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2 :3, /**< Must be zero */
 		)))))))));
 	} smemload;
-
-    /**
-     * Address for memory loads to get SSO internal state
-     */
+	/**
+	 * Address for memory loads to get SSO internal state
+	 */
 	struct {
-		CVMX_BITFIELD_FIELD(uint64_t mem_region:2,
-					    /**< Mips64 address region. Should be CVMX_IO_SEG */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61:13,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t is_io:1,	    /**< Must be one */
-		CVMX_BITFIELD_FIELD(uint64_t did:8,		    /**< the ID of SSO - did<2:0> == 2 in this case */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_20_39:20,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t index:11,	    /**< SSO memory index */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_6_8:3,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t opcode:3,	    /**< Read TAG/WQ pointer/pending tag/next potr */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2:3, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t mem_region :2,
+		    /**< Mips64 address region. Should be CVMX_IO_SEG */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61 :13, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t is_io :1, /**< Must be one */
+		CVMX_BITFIELD_FIELD(uint64_t did :8,
+			/**< The ID of SSO - did<2:0> == 2 in this case */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_20_39 :20, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t index :11, /**< SSO memory index */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_6_8 :3, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t opcode :3,
+			/**< Read TAG/WQ pointer/pending tag/next potr */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2 :3, /**< Must be zero */
 		)))))))));
 	} smemload_cn68xx;
-
-    /**
-     * Address for index/pointer loads
-     */
+	/**
+	 * Address for index/pointer loads
+ 	 */
 	struct {
-		CVMX_BITFIELD_FIELD(uint64_t mem_region:2,
-					    /**< Mips64 address region. Should be CVMX_IO_SEG */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61:13,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t is_io:1,	    /**< Must be one */
-		CVMX_BITFIELD_FIELD(uint64_t did:8,		    /**< the ID of POW -- did<2:0> == 3 in this case */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_9_39:31,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t qosgrp:4,	    /**< when {get_rmt ==0 AND get_des_get_tail == 0}, this field selects one of
-                                                eight POW internal-input queues (0-7), one per QOS level; values 8-15 are
-                                                illegal in this case;
-                                                when {get_rmt ==0 AND get_des_get_tail == 1}, this field selects one of
-                                                16 deschedule lists (per group);
-                                                when get_rmt ==1, this field selects one of 16 memory-input queue lists.
-                                                The two memory-input queue lists associated with each QOS level are:
-                                                - qosgrp = 0, qosgrp = 8:      QOS0
-                                                - qosgrp = 1, qosgrp = 9:      QOS1
-                                                - qosgrp = 2, qosgrp = 10:     QOS2
-                                                - qosgrp = 3, qosgrp = 11:     QOS3
-                                                - qosgrp = 4, qosgrp = 12:     QOS4
-                                                - qosgrp = 5, qosgrp = 13:     QOS5
-                                                - qosgrp = 6, qosgrp = 14:     QOS6
-                                                - qosgrp = 7, qosgrp = 15:     QOS7 */
-		CVMX_BITFIELD_FIELD(uint64_t get_des_get_tail:1,
-					    /**< If set and get_rmt is clear, return deschedule list indexes
-                                                rather than indexes for the specified qos level; if set and get_rmt is set, return
-                                                the tail pointer rather than the head pointer for the specified qos level. */
-		CVMX_BITFIELD_FIELD(uint64_t get_rmt:1,	    /**< If set, return remote pointers rather than the local indexes for the specified qos level. */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2:3,   /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t mem_region :2,
+			/**< Mips64 address region. Should be CVMX_IO_SEG */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61 :13, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t is_io :1, /**< Must be one */
+		CVMX_BITFIELD_FIELD(uint64_t did :8,
+			/**< The ID of POW -- did<2:0> == 3 in this case */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_9_39 :31, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t qosgrp :4,
+			/**< When {get_rmt ==0 AND get_des_get_tail == 0}, this field selects one of
+			 eight POW internal-input queues (0-7), one per QOS level; values 8-15 are
+			 illegal in this case.
+			 When {get_rmt ==0 AND get_des_get_tail == 1}, this field selects one of
+			 16 deschedule lists (per group);
+			 When get_rmt ==1, this field selects one of 16 memory-input queue lists.
+			 The two memory-input queue lists associated with each QOS level are:
+			 - qosgrp = 0, qosgrp = 8:      QOS0
+			 - qosgrp = 1, qosgrp = 9:      QOS1
+			 - qosgrp = 2, qosgrp = 10:     QOS2
+			 - qosgrp = 3, qosgrp = 11:     QOS3
+			 - qosgrp = 4, qosgrp = 12:     QOS4
+			 - qosgrp = 5, qosgrp = 13:     QOS5
+			 - qosgrp = 6, qosgrp = 14:     QOS6
+			 - qosgrp = 7, qosgrp = 15:     QOS7 */
+		CVMX_BITFIELD_FIELD(uint64_t get_des_get_tail :1,
+			/**< If set and get_rmt is clear, return deschedule list indexes
+			 rather than indexes for the specified qos level.
+			 If set and get_rmt is set, return the tail pointer rather than the head
+			 pointer for the specified qos level. */
+		CVMX_BITFIELD_FIELD(uint64_t get_rmt :1,
+			/**< If set, return remote pointers rather than the local indexes
+			 for the specified qos level. */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2 :3, /**< Must be zero */
 		)))))))));
 	} sindexload;
-
-    /**
-     * Address for a Index/Pointer loads to get SSO internal state
-     */
+	/**
+	 * Address for a Index/Pointer loads to get SSO internal state
+	 */
 	struct {
-		CVMX_BITFIELD_FIELD(uint64_t mem_region:2,
-					    /**< Mips64 address region. Should be CVMX_IO_SEG */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61:13,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t is_io:1,	    /**< Must be one */
-		CVMX_BITFIELD_FIELD(uint64_t did:8,		    /**< the ID of SSO - did<2:0> == 2 in this case */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_15_39:25,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t qos_grp:6,	    /**< When opcode = IPL_IQ, this field specifies IQ (or QOS).
-                                                 When opcode = IPL_DESCHED, this field specifies the group.
-                                                 This field is reserved for all other opcodes. */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_6_8:3,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t opcode:3,	    /**< Read TAG/WQ pointer/pending tag/next potr */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2:3, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t mem_region :2,
+			/**< Mips64 address region. Should be CVMX_IO_SEG */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61 :13, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t is_io :1, /**< Must be one */
+		CVMX_BITFIELD_FIELD(uint64_t did :8,
+			/**< The ID of SSO - did<2:0> == 2 in this case */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_15_39 :25, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t qos_grp :6,
+			/**< When opcode = IPL_IQ, this field specifies IQ (or QOS).
+			 When opcode = IPL_DESCHED, this field specifies the group.
+			 This field is reserved for all other opcodes. */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_6_8 :3, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t opcode :3,
+			/**< Read TAG/WQ pointer/pending tag/next potr */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_0_2 :3, /**< Must be zero */
 		)))))))));
 	} sindexload_cn68xx;
-
-    /**
-     * address for NULL_RD request (did<2:0> == 4)
-     * when this is read, HW attempts to change the state to NULL if it is NULL_NULL
-     * (the hardware cannot switch from NULL_NULL to NULL if a POW entry is not available -
-     * software may need to recover by finishing another piece of work before a POW
-     * entry can ever become available.)
-     */
+	/**
+	 * Address for NULL_RD request (did<2:0> == 4)
+	 * when this is read, HW attempts to change the state to NULL if it is NULL_NULL
+	 * (the hardware cannot switch from NULL_NULL to NULL if a POW entry is not available -
+	 * software may need to recover by finishing another piece of work before a POW
+	 * entry can ever become available.)
+	 */
 	struct {
-		CVMX_BITFIELD_FIELD(uint64_t mem_region:2,
-					    /**< Mips64 address region. Should be CVMX_IO_SEG */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61:13,
-					    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t is_io:1,	    /**< Must be one */
-		CVMX_BITFIELD_FIELD(uint64_t did:8,		    /**< the ID of POW -- did<2:0> == 4 in this case */
-		CVMX_BITFIELD_FIELD(uint64_t reserved_0_39:40, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t mem_region :2,
+			/**< Mips64 address region. Should be CVMX_IO_SEG */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_49_61 :13, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t is_io :1, /**< Must be one */
+		CVMX_BITFIELD_FIELD(uint64_t did :8,
+			/**< the ID of POW -- did<2:0> == 4 in this case */
+		CVMX_BITFIELD_FIELD(uint64_t reserved_0_39 :40, /**< Must be zero */
 		)))));
 	} snull_rd;
 } cvmx_pow_load_addr_t;
@@ -543,115 +584,115 @@ typedef union {
  */
 typedef union {
 	uint64_t u64;
-
-    /**
-     * Response to new work request loads
-     */
+	/**
+	 * Response to new work request loads
+	 */
 	struct {
-		CVMX_BITFIELD_FIELD(uint64_t no_work:1,	    /**< Set when no new work queue entry was returned.
-                                                If there was de-scheduled work, the HW will definitely
-                                                return it. When this bit is set, it could mean
-                                                either mean:
-                                                - There was no work, or
-                                                - There was no work that the HW could find. This
-                                                    case can happen, regardless of the wait bit value
-                                                    in the original request, when there is work
-                                                    in the IQ's that is too deep down the list. */
-		CVMX_BITFIELD_FIELD(uint64_t pend_switch:1, /**< cn68XX and above, set if there was a pending tag switch*/
-		CVMX_BITFIELD_FIELD(uint64_t tt:2,
-		CVMX_BITFIELD_FIELD(uint64_t reserved_58_59:2,
-		CVMX_BITFIELD_FIELD(uint64_t grp:10,
-		CVMX_BITFIELD_FIELD(uint64_t reserved_42_47:6,    /**< Must be zero */
-		CVMX_BITFIELD_FIELD(uint64_t addr:42,	    /**< 36 in O1 -- the work queue pointer */
+		CVMX_BITFIELD_FIELD(uint64_t no_work :1,
+			/**< Set when no new work queue entry was returned.
+			 If there was de-scheduled work, the HW will definitely return it.
+			 When this bit is set, it could mean
+			 - There was no work, or
+			 - There was no work that the HW could find. This case can happen
+			 regardless of the wait bit value in the original request, when there
+			 is work in the IQ's that is too deep down the list. */
+		CVMX_BITFIELD_FIELD(uint64_t pend_switch :1,
+			/**< cn68XX and above, set if there was a pending tag switch*/
+		CVMX_BITFIELD_FIELD(uint64_t tt :2,
+		CVMX_BITFIELD_FIELD(uint64_t reserved_58_59 :2,
+		CVMX_BITFIELD_FIELD(uint64_t grp :10,
+		CVMX_BITFIELD_FIELD(uint64_t reserved_42_47 :6, /**< Must be zero */
+		CVMX_BITFIELD_FIELD(uint64_t addr :42, /**< 36 in O1 -- the work queue pointer */
 		)))))));
 	} s_work;
 
-    /**
-     * Result for a POW Status Load (when get_cur==0 and get_wqp==0)
-     */
+	/**
+	 * Result for a POW Status Load (when get_cur==0 and get_wqp==0)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
-		uint64_t reserved_62_63:2;
-		uint64_t pend_switch:1;
-					    /**< Set when there is a pending non-NULL SWTAG or
-                                                SWTAG_FULL, and the POW entry has not left the list for the original tag. */
-		uint64_t pend_switch_full:1;
-					    /**< Set when SWTAG_FULL and pend_switch is set. */
-		uint64_t pend_switch_null:1;
-					    /**< Set when there is a pending NULL SWTAG, or an implicit switch to NULL. */
-		uint64_t pend_desched:1;
-					    /**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
-		uint64_t pend_desched_switch:1;
-					    /**< Set when there is a pending SWTAG_DESCHED and pend_desched is set. */
-		uint64_t pend_nosched:1;
-					    /**< Set when nosched is desired and pend_desched is set. */
-		uint64_t pend_new_work:1;
-					    /**< Set when there is a pending GET_WORK. */
-		uint64_t pend_new_work_wait:1;
-					    /**< When pend_new_work is set, this bit indicates that the wait bit was set. */
-		uint64_t pend_null_rd:1;
-					    /**< Set when there is a pending NULL_RD. */
-		uint64_t pend_nosched_clr:1;
-					    /**< Set when there is a pending CLR_NSCHED. */
-		uint64_t reserved_51:1;
-		uint64_t pend_index:11;
-					    /**< This is the index when pend_nosched_clr is set. */
-		uint64_t pend_grp:4;	    /**< This is the new_grp when (pend_desched AND pend_desched_switch) is set. */
-		uint64_t reserved_34_35:2;
-		uint64_t pend_type:2;
-					    /**< This is the tag type when pend_switch or (pend_desched AND pend_desched_switch) are set. */
-		uint64_t pend_tag:32;
-					    /**< - this is the tag when pend_switch or (pend_desched AND pend_desched_switch) are set. */
+		uint64_t reserved_62_63 :2;
+		uint64_t pend_switch :1;
+			/**< Set when there is a pending non-NULL SWTAG or SWTAG_FULL, and
+			 the POW entry has not left the list for the original tag. */
+		uint64_t pend_switch_full :1;
+			/**< Set when SWTAG_FULL and pend_switch is set. */
+		uint64_t pend_switch_null :1;
+			/**< Set when there is a pending NULL SWTAG, or an implicit switch to NULL. */
+		uint64_t pend_desched :1;
+			/**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
+		uint64_t pend_desched_switch :1;
+			/**< Set when there is a pending SWTAG_DESCHED and pend_desched is set. */
+		uint64_t pend_nosched :1;
+			/**< Set when nosched is desired and pend_desched is set. */
+		uint64_t pend_new_work :1;
+			/**< Set when there is a pending GET_WORK. */
+		uint64_t pend_new_work_wait :1;
+			/**< When pend_new_work is set, this bit indicates that the wait bit was set. */
+		uint64_t pend_null_rd :1;
+			/**< Set when there is a pending NULL_RD. */
+		uint64_t pend_nosched_clr :1;
+			/**< Set when there is a pending CLR_NSCHED. */
+		uint64_t reserved_51 :1;
+		uint64_t pend_index :11;
+			/**< This is the index when pend_nosched_clr is set. */
+		uint64_t pend_grp :4;
+			/**< This is the new_grp when (pend_desched AND pend_desched_switch) is set. */
+		uint64_t reserved_34_35 :2;
+		uint64_t pend_type :2;
+			/**< This is the tag type when pend_switch or
+			 (pend_desched AND pend_desched_switch) are set. */
+		uint64_t pend_tag :32;
+			/**< This is the tag when pend_switch or
+			 (pend_desched AND pend_desched_switch) are set. */
 #else
-		uint64_t pend_tag:32;
-		uint64_t pend_type:2;
-		uint64_t reserved_34_35:2;
-		uint64_t pend_grp:4;
-		uint64_t pend_index:11;
-		uint64_t reserved_51:1;
-		uint64_t pend_nosched_clr:1;
-		uint64_t pend_null_rd:1;
-		uint64_t pend_new_work_wait:1;
-		uint64_t pend_new_work:1;
-		uint64_t pend_nosched:1;
-		uint64_t pend_desched_switch:1;
-		uint64_t pend_desched:1;
-		uint64_t pend_switch_null:1;
-		uint64_t pend_switch_full:1;
-		uint64_t pend_switch:1;
-		uint64_t reserved_62_63:2;
+		uint64_t pend_tag :32;
+		uint64_t pend_type :2;
+		uint64_t reserved_34_35 :2;
+		uint64_t pend_grp :4;
+		uint64_t pend_index :11;
+		uint64_t reserved_51 :1;
+		uint64_t pend_nosched_clr :1;
+		uint64_t pend_null_rd :1;
+		uint64_t pend_new_work_wait :1;
+		uint64_t pend_new_work :1;
+		uint64_t pend_nosched :1;
+		uint64_t pend_desched_switch :1;
+		uint64_t pend_desched :1;
+		uint64_t pend_switch_null :1;
+		uint64_t pend_switch_full :1;
+		uint64_t pend_switch :1;
+		uint64_t reserved_62_63 :2;
 #endif
 	} s_sstatus0;
-
-    /**
-     * Result for a SSO Status Load (when opcode is SL_PENDTAG)
-     */
+	/**
+	 * Result for a SSO Status Load (when opcode is SL_PENDTAG)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t pend_switch:1;
-					    /**< Set when there is a pending non-UNSCHEDULED SWTAG or
-                                                SWTAG_FULL, and the SSO entry has not left the list for the original tag. */
+			/**< Set when there is a pending non-UNSCHEDULED SWTAG or
+			 SWTAG_FULL, and the SSO entry has not left the list for the original tag. */
 		uint64_t pend_get_work:1;
-					    /**< Set when there is a pending GET_WORK */
+			/**< Set when there is a pending GET_WORK */
 		uint64_t pend_get_work_wait:1;
-					    /**< when pend_get_work is set, this biit indicates that the
-                                                 wait bit was set. */
+			/**< When pend_get_work is set, this biit indicates that the wait bit was set. */
 		uint64_t pend_nosched:1;
-					    /**< Set when nosched is desired and pend_desched is set. */
+			/**< Set when nosched is desired and pend_desched is set. */
 		uint64_t pend_nosched_clr:1;
-					    /**< Set when there is a pending CLR_NSCHED. */
+			/**< Set when there is a pending CLR_NSCHED. */
 		uint64_t pend_desched:1;
-					    /**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
+			/**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
 		uint64_t pend_alloc_we:1;
-					    /**< Set when there is a pending ALLOC_WE. */
+			/**< Set when there is a pending ALLOC_WE. */
 		uint64_t reserved_48_56:9;
 		uint64_t pend_index:11;
-					    /**< This is the index when pend_nosched_clr is set. */
+			/**< This is the index when pend_nosched_clr is set. */
 		uint64_t reserved_34_36:3;
 		uint64_t pend_type:2;
-					    /**< This is the tag type when pend_switch is set. */
+			/**< This is the tag type when pend_switch is set. */
 		uint64_t pend_tag:32;
-					    /**< This is the tag when pend_switch is set. */
+			/**< This is the tag when pend_switch is set. */
 #else
 		uint64_t pend_tag:32;
 		uint64_t pend_type:2;
@@ -667,40 +708,40 @@ typedef union {
 		uint64_t pend_switch:1;
 #endif
 	} s_sstatus0_cn68xx;
-
-    /**
-     * Result for a POW Status Load (when get_cur==0 and get_wqp==1)
-     */
+	/**
+	 * Result for a POW Status Load (when get_cur==0 and get_wqp==1)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_62_63:2;
 		uint64_t pend_switch:1;
-					    /**< Set when there is a pending non-NULL SWTAG or
-                                                SWTAG_FULL, and the POW entry has not left the list for the original tag. */
+			/**< Set when there is a pending non-NULL SWTAG or SWTAG_FULL, and
+			 the POW entry has not left the list for the original tag. */
 		uint64_t pend_switch_full:1;
-					    /**< Set when SWTAG_FULL and pend_switch is set. */
+			/**< Set when SWTAG_FULL and pend_switch is set. */
 		uint64_t pend_switch_null:1;
-					    /**< Set when there is a pending NULL SWTAG, or an implicit switch to NULL. */
+			/**< Set when there is a pending NULL SWTAG, or an implicit switch to NULL. */
 		uint64_t pend_desched:1;
-					    /**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
+			/**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
 		uint64_t pend_desched_switch:1;
-					    /**< Set when there is a pending SWTAG_DESCHED and pend_desched is set. */
+			/**< Set when there is a pending SWTAG_DESCHED and pend_desched is set. */
 		uint64_t pend_nosched:1;
-					    /**< Set when nosched is desired and pend_desched is set. */
+			/**< Set when nosched is desired and pend_desched is set. */
 		uint64_t pend_new_work:1;
-					    /**< Set when there is a pending GET_WORK. */
+			/**< Set when there is a pending GET_WORK. */
 		uint64_t pend_new_work_wait:1;
-					    /**< When pend_new_work is set, this bit indicates that the wait bit was set. */
+			/**< When pend_new_work is set, this bit indicates that the wait bit was set. */
 		uint64_t pend_null_rd:1;
-					    /**< Set when there is a pending NULL_RD. */
+			/**< Set when there is a pending NULL_RD. */
 		uint64_t pend_nosched_clr:1;
-					    /**< Set when there is a pending CLR_NSCHED. */
+			/**< Set when there is a pending CLR_NSCHED. */
 		uint64_t reserved_51:1;
 		uint64_t pend_index:11;
-					    /**< This is the index when pend_nosched_clr is set. */
-		uint64_t pend_grp:4;	    /**< This is the new_grp when (pend_desched AND pend_desched_switch) is set. */
+			/**< This is the index when pend_nosched_clr is set. */
+		uint64_t pend_grp:4;
+			/**< This is the new_grp when (pend_desched AND pend_desched_switch) is set. */
 		uint64_t pend_wqp:36;
-					    /**< This is the wqp when pend_nosched_clr is set. */
+			/**< This is the wqp when pend_nosched_clr is set. */
 #else
 		uint64_t pend_wqp:36;
 		uint64_t pend_grp:4;
@@ -719,34 +760,32 @@ typedef union {
 		uint64_t reserved_62_63:2;
 #endif
 	} s_sstatus1;
-
-    /**
-     * Result for a SSO Status Load (when opcode is SL_PENDWQP)
-     */
+	/**
+	 * Result for a SSO Status Load (when opcode is SL_PENDWQP)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t pend_switch:1;
-					    /**< Set when there is a pending non-UNSCHEDULED SWTAG or
-                                                SWTAG_FULL, and the SSO entry has not left the list for the original tag. */
+			/**< Set when there is a pending non-UNSCHEDULED SWTAG or SWTAG_FULL, and
+			 the SSO entry has not left the list for the original tag. */
 		uint64_t pend_get_work:1;
-					    /**< Set when there is a pending GET_WORK */
+			/**< Set when there is a pending GET_WORK */
 		uint64_t pend_get_work_wait:1;
-					    /**< when pend_get_work is set, this biit indicates that the
-                                                 wait bit was set. */
+			/**< when pend_get_work is set, this biit indicates that the wait bit was set. */
 		uint64_t pend_nosched:1;
-					    /**< Set when nosched is desired and pend_desched is set. */
+			/**< Set when nosched is desired and pend_desched is set. */
 		uint64_t pend_nosched_clr:1;
-					    /**< Set when there is a pending CLR_NSCHED. */
+			/**< Set when there is a pending CLR_NSCHED. */
 		uint64_t pend_desched:1;
-					    /**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
+			/**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
 		uint64_t pend_alloc_we:1;
-					    /**< Set when there is a pending ALLOC_WE. */
+			/**< Set when there is a pending ALLOC_WE. */
 		uint64_t reserved_51_56:6;
 		uint64_t pend_index:11;
-					    /**< This is the index when pend_nosched_clr is set. */
+			/**< This is the index when pend_nosched_clr is set. */
 		uint64_t reserved_38_39:2;
 		uint64_t pend_wqp:38;
-					    /**< This is the wqp when pend_nosched_clr is set. */
+			/**< This is the wqp when pend_nosched_clr is set. */
 #else
 		uint64_t pend_wqp:38;
 		uint64_t reserved_38_39:2;
@@ -765,26 +804,25 @@ typedef union {
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t pend_switch:1;
-					    /**< Set when there is a pending non-UNSCHEDULED SWTAG or
-					SWTAG_FULL, and the SSO entry has not left the list for the original tag. */
+			/**< Set when there is a pending non-UNSCHEDULED SWTAG or SWTAG_FULL, and
+			 the SSO entry has not left the list for the original tag. */
 		uint64_t pend_get_work:1;
-					    /**< Set when there is a pending GET_WORK */
+			/**< Set when there is a pending GET_WORK */
 		uint64_t pend_get_work_wait:1;
-					    /**< when pend_get_work is set, this biit indicates that the
-					 wait bit was set. */
+			/**< When pend_get_work is set, this biit indicates that the wait bit was set. */
 		uint64_t pend_nosched:1;
-					    /**< Set when nosched is desired and pend_desched is set. */
+			/**< Set when nosched is desired and pend_desched is set. */
 		uint64_t pend_nosched_clr:1;
-					    /**< Set when there is a pending CLR_NSCHED. */
+			/**< Set when there is a pending CLR_NSCHED. */
 		uint64_t pend_desched:1;
-					    /**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
+			/**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
 		uint64_t pend_alloc_we:1;
-					    /**< Set when there is a pending ALLOC_WE. */
+			/**< Set when there is a pending ALLOC_WE. */
 		uint64_t reserved_56:1;
 		uint64_t prep_index:12;
 		uint64_t reserved_42_43:2;
 		uint64_t pend_tag:42;
-					    /**< This is the wqp when pend_nosched_clr is set. */
+			/**< This is the wqp when pend_nosched_clr is set. */
 #else
 		uint64_t pend_tag:42;
 		uint64_t reserved_42_43:2;
@@ -800,25 +838,31 @@ typedef union {
 		uint64_t pend_switch:1;
 #endif
 	} s_sso_ppx_pendwqp_cn78xx;
-    /**
-     * Result for a POW Status Load (when get_cur==1, get_wqp==0, and get_rev==0)
-     */
+	/**
+	 * Result for a POW Status Load (when get_cur==1, get_wqp==0, and get_rev==0)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_62_63:2;
 		uint64_t link_index:11;
-					     /**< Points to the next POW entry in the tag list when tail == 0 (and
-                                                tag_type is not NULL or NULL_NULL). */
-		uint64_t index:11;	    /**< The POW entry attached to the core. */
-		uint64_t grp:4;		    /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
-		uint64_t head:1;	    /**< Set when this POW entry is at the head of its tag list (also set when in
-                                                the NULL or NULL_NULL state). */
-		uint64_t tail:1;	    /**< Set when this POW entry is at the tail of its tag list (also set when in the
-                                                NULL or NULL_NULL state). */
-		uint64_t tag_type:2;	    /**< The tag type attached to the core (updated when new tag list
-                                                entered on SWTAG, SWTAG_FULL, or SWTAG_DESCHED). */
-		uint64_t tag:32;	    /**< The tag attached to the core (updated when new tag list entered on
-                                                SWTAG, SWTAG_FULL, or SWTAG_DESCHED). */
+			/**< Points to the next POW entry in the tag list when tail == 0
+			 (and tag_type is not NULL or NULL_NULL).*/
+		uint64_t index:11; /**< The POW entry attached to the core.*/
+		uint64_t grp:4;
+			/**< The group attached to the core.
+			 Updated when new tag list entered on SWTAG_FULL.*/
+		uint64_t head:1;
+			/**< Set when this POW entry is at the head of its tag list
+			 (also set when in the NULL or NULL_NULL state).*/
+		uint64_t tail:1;
+			/**< Set when this POW entry is at the tail of its tag list
+			 (also set when in the NULL or NULL_NULL state).*/
+		uint64_t tag_type:2;
+			/**< The tag type attached to the core
+			 (updated when new tag list entered on SWTAG, SWTAG_FULL, or SWTAG_DESCHED).*/
+		uint64_t tag:32;
+			/**< The tag attached to the core.
+			 Updated when new tag list entered on SWTAG, SWTAG_FULL, or SWTAG_DESCHED.*/
 #else
 		uint64_t tag:32;
 		uint64_t tag_type:2;
@@ -830,26 +874,30 @@ typedef union {
 		uint64_t reserved_62_63:2;
 #endif
 	} s_sstatus2;
-
-    /**
-     * Result for a SSO Status Load (when opcode is SL_TAG)
-     */
+	/**
+	 * Result for a SSO Status Load (when opcode is SL_TAG)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_57_63:7;
-		uint64_t index:11;	    /**< The SSO entry attached to the core. */
+		uint64_t index:11; /**< The SSO entry attached to the core. */
 		uint64_t reserved_45:1;
-		uint64_t grp:6;		    /**< The group attached to the core (updated when new tag list entered on
-                                                 SWTAG_FULL). */
-		uint64_t head:1;	    /**< Set when this SSO entry is at the head of its tag list (also set when in the
-                                                 UNSCHEDULED or EMPTY state). */
-		uint64_t tail:1;	    /**< Set when this SSO entry is at the tail of its tag list (also set when in the
-                                                 UNSCHEDULED or EMPTY state). */
+		uint64_t grp:6;
+			/**< The group attached to the core.
+			 Updated when new tag list entered on SWTAG_FULL. */
+		uint64_t head:1;
+			/**< Set when this SSO entry is at the head of its tag list.
+			 Also set when in the UNSCHEDULED or EMPTY state. */
+		uint64_t tail:1;
+			/**< Set when this SSO entry is at the tail of its tag list.
+			 Also set when in the UNSCHEDULED or EMPTY state. */
 		uint64_t reserved_34_36:3;
-		uint64_t tag_type:2;	    /**< The tag type attached to the core (updated when new tag list entered
-                                                 on SWTAG, SWTAG_FULL, or SWTAG_DESCHED). */
-		uint64_t tag:32;	    /**< The tag attached to the core (updated when new tag list entered on SWTAG,
-                                                 SWTAG_FULL, or SWTAG_DESCHED). */
+		uint64_t tag_type:2;
+			/**< The tag type attached to the core.
+			 Updated when new tag list entered on SWTAG, SWTAG_FULL, or SWTAG_DESCHED. */
+		uint64_t tag:32;
+			/**< The tag attached to the core.
+			 Updated when new tag list entered on SWTAG, SWTAG_FULL, or SWTAG_DESCHED. */
 #else
 		uint64_t tag:32;
 		uint64_t tag_type:2;
@@ -886,27 +934,32 @@ typedef union {
 		uint64_t tailc:1;
 #endif
 	} s_sso_ppx_tag_cn78xx;
-
-    /**
-     * Result for a POW Status Load (when get_cur==1, get_wqp==0, and get_rev==1)
-     */
+	/**
+	 * Result for a POW Status Load (when get_cur==1, get_wqp==0, and get_rev==1)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_62_63:2;
 		uint64_t revlink_index:11;
-					    /**< Points to the prior POW entry in the tag list when head == 0
-                                                (and tag_type is not NULL or NULL_NULL). This field is unpredictable
-                                                when the core's state is NULL or NULL_NULL. */
-		uint64_t index:11;	    /**< The POW entry attached to the core. */
-		uint64_t grp:4;		    /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
-		uint64_t head:1;	    /**< Set when this POW entry is at the head of its tag list (also set when in
-                                                the NULL or NULL_NULL state). */
-		uint64_t tail:1;	    /**< Set when this POW entry is at the tail of its tag list (also set when in the
-                                                NULL or NULL_NULL state). */
-		uint64_t tag_type:2;	    /**< The tag type attached to the core (updated when new tag list
-                                                entered on SWTAG, SWTAG_FULL, or SWTAG_DESCHED). */
-		uint64_t tag:32;	    /**< The tag attached to the core (updated when new tag list entered on
-                                                SWTAG, SWTAG_FULL, or SWTAG_DESCHED). */
+			/**< Points to the prior POW entry in the tag list when head == 0
+			 (and tag_type is not NULL or NULL_NULL). This field is unpredictable
+			 when the core's state is NULL or NULL_NULL. */
+		uint64_t index:11; /**< The POW entry attached to the core. */
+		uint64_t grp:4;
+			/**< The group attached to the core.
+			 Updated when new tag list entered on SWTAG_FULL. */
+		uint64_t head:1;
+			/**< Set when this POW entry is at the head of its tag list.
+			 Also set when in the NULL or NULL_NULL state. */
+		uint64_t tail:1;
+			/**< Set when this POW entry is at the tail of its tag list.
+			 Also set when in the NULL or NULL_NULL state. */
+		uint64_t tag_type:2;
+			/**< The tag type attached to the core.
+			 Updated when new tag list entered on SWTAG, SWTAG_FULL, or SWTAG_DESCHED. */
+		uint64_t tag:32;
+			/**< The tag attached to the core.
+			 Updated when new tag list entered on SWTAG, SWTAG_FULL, or SWTAG_DESCHED. */
 #else
 		uint64_t tag:32;
 		uint64_t tag_type:2;
@@ -918,19 +971,21 @@ typedef union {
 		uint64_t reserved_62_63:2;
 #endif
 	} s_sstatus3;
-
-    /**
-     * Result for a SSO Status Load (when opcode is SL_WQP)
-     */
+	/**
+	 * Result for a SSO Status Load (when opcode is SL_WQP)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_58_63:6;
-		uint64_t index:11;	    /**< The SSO entry attached to the core. */
+		uint64_t index:11; /**< The SSO entry attached to the core. */
 		uint64_t reserved_46:1;
-		uint64_t grp:6;		    /**< The group attached to the core (updated when new tag list entered on
-                                                 SWTAG_FULL). */
+		uint64_t grp:6;
+			/**< The group attached to the core.
+			 Updated when new tag list entered on SWTAG_FULL. */
 		uint64_t reserved_38_39:2;
-		uint64_t wqp:38;	    /**< The wqp attached to the core (updated when new tag list entered on SWTAG_FULL). */
+		uint64_t wqp:38;
+			/**< The wqp attached to the core.
+			 Updated when new tag list entered on SWTAG_FULL. */
 #else
 		uint64_t wqp:38;
 		uint64_t reserved_38_39:2;
@@ -954,19 +1009,22 @@ typedef union {
 		uint64_t reserved_58_63:6;
 #endif
 	} s_sso_ppx_wqp_cn78xx;
-
-    /**
-     * Result for a POW Status Load (when get_cur==1, get_wqp==1, and get_rev==0)
-     */
+	/**
+	 * Result for a POW Status Load (when get_cur==1, get_wqp==1, and get_rev==0)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_62_63:2;
 		uint64_t link_index:11;
-					     /**< Points to the next POW entry in the tag list when tail == 0 (and
-                                                tag_type is not NULL or NULL_NULL). */
-		uint64_t index:11;	    /**< The POW entry attached to the core. */
-		uint64_t grp:4;		    /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
-		uint64_t wqp:36;	    /**< The wqp attached to the core (updated when new tag list entered on SWTAG_FULL). */
+			/**< Points to the next POW entry in the tag list when tail == 0
+			 (and tag_type is not NULL or NULL_NULL). */
+		uint64_t index:11; /**< The POW entry attached to the core. */
+		uint64_t grp:4;
+			/**< The group attached to the core.
+			 Updated when new tag list entered on SWTAG_FULL. */
+		uint64_t wqp:36;
+			/**< The wqp attached to the core.
+			 Updated when new tag list entered on SWTAG_FULL. */
 #else
 		uint64_t wqp:36;
 		uint64_t grp:4;
@@ -975,27 +1033,31 @@ typedef union {
 		uint64_t reserved_62_63:2;
 #endif
 	} s_sstatus4;
-
-    /**
-     * Result for a SSO Status Load (when opcode is SL_LINKS)
-     */
+	/**
+	 * Result for a SSO Status Load (when opcode is SL_LINKS)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_46_63:18;
-		uint64_t index:11;	    /**< The SSO entry attached to the core. */
+		uint64_t index:11; /**< The SSO entry attached to the core. */
 		uint64_t reserved_34:1;
-		uint64_t grp:6;		    /**< The group attached to the core (updated when new tag list entered on
-                                                 SWTAG_FULL). */
-		uint64_t head:1;	    /**< Set when this SSO entry is at the head of its tag list (also set when in the
-                                                 UNSCHEDULED or EMPTY state). */
-		uint64_t tail:1;	    /**< Set when this SSO entry is at the tail of its tag list (also set when in the
-                                                 UNSCHEDULED or EMPTY state). */
+		uint64_t grp:6;
+			/**< The group attached to the core
+			 (updated when new tag list entered on SWTAG_FULL). */
+		uint64_t head:1;
+			/**< Set when this SSO entry is at the head of its tag list
+			 (also set when in the UNSCHEDULED or EMPTY state). */
+		uint64_t tail:1;
+			/**< Set when this SSO entry is at the tail of its tag list
+			 (also set when in the UNSCHEDULED or EMPTY state). */
 		uint64_t reserved_24_25:2;
 		uint64_t revlink_index:11;
-					    /**< Points to the prior SSO entry in the tag list when head==0 (and tag_type is not UNSCHEDULED or EMPTY). */
+			/**< Points to the prior SSO entry in the tag list when head==0
+			 (and tag_type is not UNSCHEDULED or EMPTY). */
 		uint64_t reserved_11_12:2;
 		uint64_t link_index:11;
-					    /**< Points to the next SSO entry in the tag list when tail==0 (and tag_type is not UNSCHEDULDED or EMPTY). */
+			/**< Points to the next SSO entry in the tag list when tail==0
+			 (and tag_type is not UNSCHEDULDED or EMPTY). */
 #else
 		uint64_t link_index:11;
 		uint64_t reserved_11_12:2;
@@ -1037,19 +1099,23 @@ typedef union {
 		uint64_t tailc:1;
 #endif
 	} s_sso_ppx_links_cn78xx;
-    /**
-     * Result for a POW Status Load (when get_cur==1, get_wqp==1, and get_rev==1)
-     */
+	/**
+	 * Result for a POW Status Load (when get_cur==1, get_wqp==1, and get_rev==1)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_62_63:2;
 		uint64_t revlink_index:11;
-					    /**< Points to the prior POW entry in the tag list when head == 0
-                                                (and tag_type is not NULL or NULL_NULL). This field is unpredictable
-                                                when the core's state is NULL or NULL_NULL. */
-		uint64_t index:11;	    /**< The POW entry attached to the core. */
-		uint64_t grp:4;		    /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
-		uint64_t wqp:36;	    /**< The wqp attached to the core (updated when new tag list entered on SWTAG_FULL). */
+			/**< Points to the prior POW entry in the tag list when head == 0
+			 (and tag_type is not NULL or NULL_NULL). This field is unpredictable
+			 when the core's state is NULL or NULL_NULL. */
+		uint64_t index:11; /**< The POW entry attached to the core. */
+		uint64_t grp:4;
+			/**< The group attached to the core
+			 (updated when new tag list entered on SWTAG_FULL). */
+		uint64_t wqp:36;
+			/**< The wqp attached to the core
+			 (updated when new tag list entered on SWTAG_FULL). */
 #else
 		uint64_t wqp:36;
 		uint64_t grp:4;
@@ -1058,22 +1124,22 @@ typedef union {
 		uint64_t reserved_62_63:2;
 #endif
 	} s_sstatus5;
-
-    /**
-     * Result For POW Memory Load (get_des == 0 and get_wqp == 0)
-     */
+	/**
+	 * Result For POW Memory Load (get_des == 0 and get_wqp == 0)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_51_63:13;
 		uint64_t next_index:11;
-					     /**< The next entry in the input, free, descheduled_head list
-                                                (unpredictable if entry is the tail of the list). */
-		uint64_t grp:4;		    /**< The group of the POW entry. */
+			/**< The next entry in the input, free, descheduled_head list
+			 (unpredictable if entry is the tail of the list). */
+		uint64_t grp:4; /**< The group of the POW entry. */
 		uint64_t reserved_35:1;
-		uint64_t tail:1;	    /**< Set when this POW entry is at the tail of its tag list (also set when in the
-                                                NULL or NULL_NULL state). */
-		uint64_t tag_type:2;	    /**< The tag type of the POW entry. */
-		uint64_t tag:32;	    /**< The tag of the POW entry. */
+		uint64_t tail:1;
+			/**< Set when this POW entry is at the tail of its tag list
+			 (also set when in the NULL or NULL_NULL state). */
+		uint64_t tag_type:2; /**< The tag type of the POW entry. */
+		uint64_t tag:32; /**< The tag of the POW entry. */
 #else
 		uint64_t tag:32;
 		uint64_t tag_type:2;
@@ -1084,18 +1150,18 @@ typedef union {
 		uint64_t reserved_51_63:13;
 #endif
 	} s_smemload0;
-
-    /**
-     * Result For SSO Memory Load (opcode is ML_TAG)
-     */
+	/**
+	 * Result For SSO Memory Load (opcode is ML_TAG)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_38_63:26;
-		uint64_t tail:1;	    /**< Set when this SSO entry is at the tail of its tag list (also set when in the
-                                                NULL or NULL_NULL state). */
+		uint64_t tail:1;
+			/**< Set when this SSO entry is at the tail of its tag list
+			(also set when in the NULL or NULL_NULL state). */
 		uint64_t reserved_34_36:3;
-		uint64_t tag_type:2;	    /**< The tag type of the SSO entry. */
-		uint64_t tag:32;	    /**< The tag of the SSO entry. */
+		uint64_t tag_type:2; /**< The tag type of the SSO entry. */
+		uint64_t tag:32; /**< The tag of the SSO entry. */
 #else
 		uint64_t tag:32;
 		uint64_t tag_type:2;
@@ -1108,12 +1174,12 @@ typedef union {
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_39_63:25;
-		uint64_t tail:1;	/**< Set when this SSO entry is at
-					the tail of its tag list (also set
-					when in the NULL or NULL_NULL state). */
+		uint64_t tail:1;
+			/**< Set when this SSO entry is at the tail of its tag list
+			 (also set when in the NULL or NULL_NULL state). */
 		uint64_t reserved_34_36:3;
-		uint64_t tag_type:2;	    /**< The tag type of the SSO entry. */
-		uint64_t tag:32;	    /**< The tag of the SSO entry. */
+		uint64_t tag_type:2; /**< The tag type of the SSO entry. */
+		uint64_t tag:32; /**< The tag of the SSO entry. */
 #else
 		uint64_t tag:32;
 		uint64_t tag_type:2;
@@ -1122,17 +1188,17 @@ typedef union {
 		uint64_t reserved_38_63:26;
 #endif
 	} s_sso_iaq_ppx_tag_cn78xx;
-    /**
-     * Result For POW Memory Load (get_des == 0 and get_wqp == 1)
-     */
+	/**
+	 * Result For POW Memory Load (get_des == 0 and get_wqp == 1)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_51_63:13;
 		uint64_t next_index:11;
-					     /**< The next entry in the input, free, descheduled_head list
-                                                (unpredictable if entry is the tail of the list). */
-		uint64_t grp:4;		    /**< The group of the POW entry. */
-		uint64_t wqp:36;	    /**< The WQP held in the POW entry. */
+			/**< The next entry in the input, free, descheduled_head list
+			 (unpredictable if entry is the tail of the list). */
+		uint64_t grp:4; /**< The group of the POW entry. */
+		uint64_t wqp:36; /**< The WQP held in the POW entry. */
 #else
 		uint64_t wqp:36;
 		uint64_t grp:4;
@@ -1140,18 +1206,17 @@ typedef union {
 		uint64_t reserved_51_63:13;
 #endif
 	} s_smemload1;
-
-    /**
-     * Result For SSO Memory Load (opcode is ML_WQPGRP)
-     */
+	/**
+	 * Result For SSO Memory Load (opcode is ML_WQPGRP)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_48_63:16;
-		uint64_t nosched:1;	    /**< The nosched bit for the SSO entry. */
+		uint64_t nosched:1;	/**< The nosched bit for the SSO entry. */
 		uint64_t reserved_46:1;
-		uint64_t grp:6;		    /**< The group of the SSO entry. */
+		uint64_t grp:6; /**< The group of the SSO entry. */
 		uint64_t reserved_38_39:2;
-		uint64_t wqp:38;	    /**< The WQP held in the SSO entry. */
+		uint64_t wqp:38; /**< The WQP held in the SSO entry. */
 #else
 		uint64_t wqp:38;
 		uint64_t reserved_38_39:2;
@@ -1166,38 +1231,37 @@ typedef union {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_48_63:2;
 		uint64_t head:1;
-		uint64_t nosched:1;	    /**< The nosched bit for the SSO entry. */
+		uint64_t nosched:1; /**< The nosched bit for the SSO entry. */
 		uint64_t reserved_58_59:2;
-		uint64_t grp:10;		    /**< The group of the SSO entry. */
+		uint64_t grp:10; /**< The group of the SSO entry. */
 		uint64_t reserved_42_47:6;
-		uint64_t wqp:42;	    /**< The WQP held in the SSO entry. */
+		uint64_t wqp:42; /**< The WQP held in the SSO entry. */
 #else
-		uint64_t wqp:42;	    /**< The WQP held in the SSO entry. */
+		uint64_t wqp:42; /**< The WQP held in the SSO entry. */
 		uint64_t reserved_42_47:6;
-		uint64_t grp:10;		    /**< The group of the SSO entry. */
+		uint64_t grp:10; /**< The group of the SSO entry. */
 		uint64_t reserved_58_59:2;
-		uint64_t nosched:1;	    /**< The nosched bit for the SSO entry. */
+		uint64_t nosched:1; /**< The nosched bit for the SSO entry. */
 		uint64_t head:1;
 		uint64_t reserved_48_63:2;
 #endif
 	} s_sso_ientx_wqpgrp_cn78xx;
 
-    /**
-     * Result For POW Memory Load (get_des == 1)
-     */
+	/**
+	 * Result For POW Memory Load (get_des == 1)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_51_63:13;
 		uint64_t fwd_index:11;
-					    /**< The next entry in the tag list connected to the descheduled head. */
-		uint64_t grp:4;		    /**< The group of the POW entry. */
-		uint64_t nosched:1;	    /**< The nosched bit for the POW entry. */
-		uint64_t pend_switch:1;
-					    /**< There is a pending tag switch */
+			/**< The next entry in the tag list connected to the descheduled head. */
+		uint64_t grp:4; /**< The group of the POW entry. */
+		uint64_t nosched:1; /**< The nosched bit for the POW entry. */
+		uint64_t pend_switch:1; /**< There is a pending tag switch */
 		uint64_t pend_type:2;
-					    /**< The next tag type for the new tag list when pend_switch is set. */
+			/**< The next tag type for the new tag list when pend_switch is set. */
 		uint64_t pend_tag:32;
-					    /**< The next tag for the new tag list when pend_switch is set. */
+			/**< The next tag for the new tag list when pend_switch is set. */
 #else
 		uint64_t pend_tag:32;
 		uint64_t pend_type:2;
@@ -1208,21 +1272,20 @@ typedef union {
 		uint64_t reserved_51_63:13;
 #endif
 	} s_smemload2;
-
-    /**
-     * Result For SSO Memory Load (opcode is ML_PENTAG)
-     */
+	/**
+	 * Result For SSO Memory Load (opcode is ML_PENTAG)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_38_63:26;
 		uint64_t pend_switch:1;
-					    /**< Set when there is a pending non-UNSCHEDULED SWTAG or
-                                                 SWTAG_FULL, and the SSO entry has not left the list for the original tag. */
+			/**< Set when there is a pending non-UNSCHEDULED SWTAG or SWTAG_FULL,
+			 and the SSO entry has not left the list for the original tag. */
 		uint64_t reserved_34_36:3;
 		uint64_t pend_type:2;
-					    /**< The next tag type for the new tag list when pend_switch is set. */
+			/**< The next tag type for the new tag list when pend_switch is set. */
 		uint64_t pend_tag:32;
-					    /**< The next tag for the new tag list when pend_switch is set. */
+			/**< The next tag for the new tag list when pend_switch is set. */
 #else
 		uint64_t pend_tag:32;
 		uint64_t pend_type:2;
@@ -1234,44 +1297,45 @@ typedef union {
 
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t pend_switch		:1;  /**< Set when there is a pending SWTAG, SWTAG_DESCHED, or SWTAG_FULL to ORDERED or ATOMIC. If
-					the register read was issued after an indexed GET_WORK, the DESCHED portion of a
-					SWTAG_DESCHED cannot still be pending. */
-	uint64_t pend_get_work		:1;  /**< Set when there is a pending GET_WORK. */
-	uint64_t pend_get_work_wait	:1;  /**< When PEND_GET_WORK is set, indicates that the WAITW bit was set. */
-	uint64_t pend_nosched		:1;  /**< Set when nosched is desired and PEND_DESCHED is set. */
-	uint64_t pend_nosched_clr	:1;  /**< Set when there is a pending CLR_NSCHED. */
-	uint64_t pend_desched		:1;  /**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
-	uint64_t pend_alloc_we		:1;  /**< Set when there is a pending ALLOC_WE. */
-	uint64_t reserved_34_56		:23;
-	uint64_t pend_tt		:2;  /**< The tag type when PEND_SWITCH is set. */
-	uint64_t pend_tag		:32; /**< The tag when PEND_SWITCH is set. */
+		uint64_t pend_switch :1;
+			/**< Set when there is a pending SWTAG, SWTAG_DESCHED, or SWTAG_FULL
+		 	to ORDERED or ATOMIC. If the register read was issued after an indexed
+		 	GET_WORK, the DESCHED portion of a SWTAG_DESCHED cannot still be pending. */
+		uint64_t pend_get_work :1;  /**< Set when there is a pending GET_WORK. */
+		uint64_t pend_get_work_wait :1;
+			/**< When PEND_GET_WORK is set, indicates that the WAITW bit was set. */
+		uint64_t pend_nosched :1;  /**< Set when nosched is desired and PEND_DESCHED is set. */
+		uint64_t pend_nosched_clr :1;  /**< Set when there is a pending CLR_NSCHED. */
+		uint64_t pend_desched :1;  /**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
+		uint64_t pend_alloc_we :1;  /**< Set when there is a pending ALLOC_WE. */
+		uint64_t reserved_34_56 :23;
+		uint64_t pend_tt :2;  /**< The tag type when PEND_SWITCH is set. */
+		uint64_t pend_tag :32; /**< The tag when PEND_SWITCH is set. */
 #else
-	uint64_t pend_tag		:32;
-	uint64_t pend_tt		:2;
-	uint64_t reserved_34_56		:23;
-	uint64_t pend_alloc_we		:1;
-	uint64_t pend_desched		:1;
-	uint64_t pend_nosched_clr	:1;
-	uint64_t pend_nosched		:1;
-	uint64_t pend_get_work_wait	:1;
-	uint64_t pend_get_work		:1;
-	uint64_t pend_switch		:1;
+		uint64_t pend_tag :32;
+		uint64_t pend_tt :2;
+		uint64_t reserved_34_56 :23;
+		uint64_t pend_alloc_we :1;
+		uint64_t pend_desched :1;
+		uint64_t pend_nosched_clr :1;
+		uint64_t pend_nosched :1;
+		uint64_t pend_get_work_wait :1;
+		uint64_t pend_get_work :1;
+		uint64_t pend_switch :1;
 #endif
 	} s_sso_ppx_pendtag_cn78xx;
-
-    /**
-     * Result For SSO Memory Load (opcode is ML_LINKS)
-     */
+	/**
+	 * Result For SSO Memory Load (opcode is ML_LINKS)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_24_63:40;
 		uint64_t fwd_index:11;
-		/**< The next entry in the tag list connected to the descheduled head. */
+			/**< The next entry in the tag list connected to the descheduled head. */
 		uint64_t reserved_11_12:2;
 		uint64_t next_index:11;
-		/**< The next entry in the input, free, descheduled_head list
-		(unpredicatble if entry is the tail of the list). */
+			/**< The next entry in the input, free, descheduled_head list
+			(unpredicatble if entry is the tail of the list). */
 #else
 		uint64_t next_index:11;
 		uint64_t reserved_11_12:2;
@@ -1282,48 +1346,55 @@ typedef union {
 
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_28_63		:36;
-	uint64_t prev_index		:12;
-	/**< The previous entry in the tag chain. Unpredictable if the entry
-	 * is at the head of the list or the head of a conflicted tag chain. */
-	uint64_t reserved_13_15		:3;
-	uint64_t next_index_vld		:1;
-	/**< The NEXT_INDEX is valid. Unpredictable unless the entry is the
-	 * tail entry of an atomic tag chain. */
-	uint64_t next_index		:12;
-	/**< The next entry in the tag chain or conflicted tag chain.
-	 * Unpredictable if the entry is at the tail of the list. */
+		uint64_t reserved_28_63 :36;
+		uint64_t prev_index :12;
+			/**< The previous entry in the tag chain. Unpredictable if the entry
+			 is at the head of the list or the head of a conflicted tag chain. */
+		uint64_t reserved_13_15 :3;
+		uint64_t next_index_vld :1;
+			/**< The NEXT_INDEX is valid. Unpredictable unless the entry is the
+			 tail entry of an atomic tag chain. */
+		uint64_t next_index :12;
+			/**< The next entry in the tag chain or conflicted tag chain.
+			 Unpredictable if the entry is at the tail of the list. */
 #else
-	uint64_t next_index		:12;
-	uint64_t next_index_vld		:1;
-	uint64_t reserved_13_15		:3;
-	uint64_t prev_index		:12;
-	uint64_t reserved_28_63		:36;
+		uint64_t next_index :12;
+		uint64_t next_index_vld :1;
+		uint64_t reserved_13_15 :3;
+		uint64_t prev_index :12;
+		uint64_t reserved_28_63 :36;
 #endif
 	} s_sso_ientx_links_cn78xx;
-
-    /**
-     * Result For POW Index/Pointer Load (get_rmt == 0/get_des_get_tail == 0)
-     */
+	/**
+	 * Result For POW Index/Pointer Load (get_rmt == 0/get_des_get_tail == 0)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_52_63:12;
-		uint64_t free_val:1;	    /**< - set when there is one or more POW entries on the free list. */
-		uint64_t free_one:1;	    /**< - set when there is exactly one POW entry on the free list. */
+		uint64_t free_val:1;
+			/**< Set when there is one or more POW entries on the free list. */
+		uint64_t free_one:1;
+			/**< - Set when there is exactly one POW entry on the free list. */
 		uint64_t reserved_49:1;
 		uint64_t free_head:11;
-					    /**< - when free_val is set, indicates the first entry on the free list. */
+			/**< When free_val is set, indicates the first entry on the free list. */
 		uint64_t reserved_37:1;
 		uint64_t free_tail:11;
-					    /**< - when free_val is set, indicates the last entry on the free list. */
-		uint64_t loc_val:1;	    /**< - set when there is one or more POW entries on the input Q list selected by qosgrp. */
-		uint64_t loc_one:1;	    /**< - set when there is exactly one POW entry on the input Q list selected by qosgrp. */
+			/**< When free_val is set, indicates the last entry on the free list. */
+		uint64_t loc_val:1;
+			/**< Set when there is one or more POW entries on the input Q list
+			 selected by qosgrp. */
+		uint64_t loc_one:1;
+			/**< Set when there is exactly one POW entry on the input Q list
+			 selected by qosgrp. */
 		uint64_t reserved_23:1;
 		uint64_t loc_head:11;
-					    /**< - when loc_val is set, indicates the first entry on the input Q list selected by qosgrp. */
+			/**< When loc_val is set, indicates the first entry on the input Q list
+			 selected by qosgrp. */
 		uint64_t reserved_11:1;
 		uint64_t loc_tail:11;
-					    /**< - when loc_val is set, indicates the last entry on the input Q list selected by qosgrp. */
+			/**< When loc_val is set, indicates the last entry on the input Q list
+			 selected by qosgrp. */
 #else
 		uint64_t loc_tail:11;
 		uint64_t reserved_11:1;
@@ -1340,24 +1411,23 @@ typedef union {
 		uint64_t reserved_52_63:12;
 #endif
 	} sindexload0;
-
-    /**
-     * Result for SSO Index/Pointer Load(opcode ==
-     * IPL_IQ/IPL_DESCHED/IPL_NOSCHED)
-     */
+	/**
+	 * Result for SSO Index/Pointer Load(opcode ==
+	 * IPL_IQ/IPL_DESCHED/IPL_NOSCHED)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_28_63:36;
 		uint64_t queue_val:1;
-					    /**< - If set, one or more valid entries are in the queue. */
+			/**< - If set, one or more valid entries are in the queue. */
 		uint64_t queue_one:1;
-					    /**< - If set, exactly one valid entry is in the queue. */
+			/**< - If set, exactly one valid entry is in the queue. */
 		uint64_t reserved_24_25:2;
 		uint64_t queue_head:11;
-					    /**< - Index of entry at the head of the queue. */
+			/**< - Index of entry at the head of the queue. */
 		uint64_t reserved_11_12:2;
 		uint64_t queue_tail:11;
-					    /**< - Index of entry at the tail of the queue. */
+			/**< - Index of entry at the tail of the queue. */
 #else
 		uint64_t queue_tail:11;
 		uint64_t reserved_11_12:2;
@@ -1368,29 +1438,36 @@ typedef union {
 		uint64_t reserved_28_63:36;
 #endif
 	} sindexload0_cn68xx;
-
-    /**
-     * Result For POW Index/Pointer Load (get_rmt == 0/get_des_get_tail == 1)
-     */
+	/**
+	 * Result For POW Index/Pointer Load (get_rmt == 0/get_des_get_tail == 1)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_52_63:12;
 		uint64_t nosched_val:1;
-					    /**< - set when there is one or more POW entries on the nosched list. */
+			/**< Set when there is one or more POW entries on the nosched list. */
 		uint64_t nosched_one:1;
-					    /**< - set when there is exactly one POW entry on the nosched list. */
+			/**< Set when there is exactly one POW entry on the nosched list. */
 		uint64_t reserved_49:1;
 		uint64_t nosched_head:11;
-					     /**< - when nosched_val is set, indicates the first entry on the nosched list. */
+			/**< When nosched_val is set, indicates the first entry on the nosched list. */
 		uint64_t reserved_37:1;
 		uint64_t nosched_tail:11;
-					     /**< - when nosched_val is set, indicates the last entry on the nosched list. */
-		uint64_t des_val:1;	    /**< - set when there is one or more descheduled heads on the descheduled list selected by qosgrp. */
-		uint64_t des_one:1;	    /**< - set when there is exactly one descheduled head on the descheduled list selected by qosgrp. */
+			/**< When nosched_val is set, indicates the last entry on the nosched list. */
+		uint64_t des_val:1;
+			/**< Set when there is one or more descheduled heads on the descheduled
+			 list selected by qosgrp. */
+		uint64_t des_one:1;
+			/**< Set when there is exactly one descheduled head on the descheduled
+			 list selected by qosgrp. */
 		uint64_t reserved_23:1;
-		uint64_t des_head:11;	     /**< - when des_val is set, indicates the first descheduled head on the descheduled list selected by qosgrp. */
+		uint64_t des_head:11;
+			/**< When des_val is set, indicates the first descheduled head on
+			 the descheduled list selected by qosgrp. */
 		uint64_t reserved_11:1;
-		uint64_t des_tail:11;	     /**< - when des_val is set, indicates the last descheduled head on the descheduled list selected by qosgrp. */
+		uint64_t des_tail:11;
+			/**< When des_val is set, indicates the last descheduled head on
+			 the descheduled list selected by qosgrp. */
 #else
 		uint64_t des_tail:11;
 		uint64_t reserved_11:1;
@@ -1407,28 +1484,25 @@ typedef union {
 		uint64_t reserved_52_63:12;
 #endif
 	} sindexload1;
-
-    /**
-     * Result for SSO Index/Pointer Load(opcode == IPL_FREE0/IPL_FREE1/IPL_FREE2)
-     */
+	/**
+	 * Result for SSO Index/Pointer Load(opcode == IPL_FREE0/IPL_FREE1/IPL_FREE2)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_60_63:4;
-		uint64_t qnum_head:2;
-					    /**< - Subqueue with current head */
-		uint64_t qnum_tail:2;
-					    /**< - Subqueue with current tail */
+		uint64_t qnum_head:2; /**< - Subqueue with current head */
+		uint64_t qnum_tail:2; /**< - Subqueue with current tail */
 		uint64_t reserved_28_55:28;
 		uint64_t queue_val:1;
-					    /**< - If set, one or more valid entries are in the queue. */
+			/**< - If set, one or more valid entries are in the queue. */
 		uint64_t queue_one:1;
-					    /**< - If set, exactly one valid entry is in the queue. */
+			/**< - If set, exactly one valid entry is in the queue. */
 		uint64_t reserved_24_25:2;
 		uint64_t queue_head:11;
-					    /**< - Index of entry at the head of the queue. */
+			/**< - Index of entry at the head of the queue. */
 		uint64_t reserved_11_12:2;
 		uint64_t queue_tail:11;
-					    /**< - Index of entry at the tail of the queue. */
+			/**< - Index of entry at the tail of the queue. */
 #else
 		uint64_t queue_tail:11;
 		uint64_t reserved_11_12:2;
@@ -1442,25 +1516,27 @@ typedef union {
 		uint64_t reserved_60_63:4;
 #endif
 	} sindexload1_cn68xx;
-
-    /**
-     * Result For POW Index/Pointer Load (get_rmt == 1/get_des_get_tail == 0)
-     */
+	/**
+	 * Result For POW Index/Pointer Load (get_rmt == 1/get_des_get_tail == 0)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_39_63:25;
 		uint64_t rmt_is_head:1;
-					    /**< Set when this DRAM list is the current head (i.e. is the next to
-                                                be reloaded when the POW hardware reloads a POW entry from DRAM). The
-                                                POW hardware alternates between the two DRAM lists associated with a QOS
-                                                level when it reloads work from DRAM into the POW unit. */
-		uint64_t rmt_val:1;	    /**< Set when the DRAM portion of the input Q list selected by qosgrp
-                                                contains one or more pieces of work. */
-		uint64_t rmt_one:1;	    /**< Set when the DRAM portion of the input Q list selected by qosgrp
-                                                contains exactly one piece of work. */
+			/**< Set when this DRAM list is the current head
+			 (i.e. is the next to be reloaded when the POW hardware reloads
+			 a POW entry from DRAM). The POW hardware alternates between the two DRAM
+			 lists associated with a QOS level when it reloads work from DRAM
+			 into the POW unit. */
+		uint64_t rmt_val:1;
+			/**< Set when the DRAM portion of the input Q list selected by qosgrp
+			 contains one or more pieces of work. */
+		uint64_t rmt_one:1;
+			/**< Set when the DRAM portion of the input Q list selected by qosgrp
+			 contains exactly one piece of work. */
 		uint64_t rmt_head:36;
-					    /**< When rmt_val is set, indicates the first piece of work on the
-                                                DRAM input Q list selected by qosgrp. */
+			/**< When rmt_val is set, indicates the first piece of work on the
+			 DRAM input Q list selected by qosgrp. */
 #else
 		uint64_t rmt_head:36;
 		uint64_t rmt_one:1;
@@ -1469,25 +1545,26 @@ typedef union {
 		uint64_t reserved_39_63:25;
 #endif
 	} sindexload2;
-
-    /**
-     * Result For POW Index/Pointer Load (get_rmt == 1/get_des_get_tail == 1)
-     */
+	/**
+	 * Result For POW Index/Pointer Load (get_rmt == 1/get_des_get_tail == 1)
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t reserved_39_63:25;
 		uint64_t rmt_is_head:1;
-					    /**< - set when this DRAM list is the current head (i.e. is the next to
-                                                be reloaded when the POW hardware reloads a POW entry from DRAM). The
-                                                POW hardware alternates between the two DRAM lists associated with a QOS
-                                                level when it reloads work from DRAM into the POW unit. */
-		uint64_t rmt_val:1;	    /**< - set when the DRAM portion of the input Q list selected by qosgrp
-                                                contains one or more pieces of work. */
-		uint64_t rmt_one:1;	    /**< - set when the DRAM portion of the input Q list selected by qosgrp
-                                                contains exactly one piece of work. */
+			/**< - Set when this DRAM list is the current head (i.e. is the next to
+			 be reloaded when the POW hardware reloads a POW entry from DRAM).
+			 The POW hardware alternates between the two DRAM lists associated with a QOS
+			 level when it reloads work from DRAM into the POW unit. */
+		uint64_t rmt_val:1;
+			/**< - Set when the DRAM portion of the input Q list selected by qosgrp
+			 contains one or more pieces of work. */
+		uint64_t rmt_one:1;
+			/**< - Set when the DRAM portion of the input Q list selected by qosgrp
+			 contains exactly one piece of work. */
 		uint64_t rmt_tail:36;
-					    /**< - when rmt_val is set, indicates the last piece of work on the DRAM
-                                                input Q list selected by qosgrp. */
+			/**< - When rmt_val is set, indicates the last piece of work on the DRAM
+			 input Q list selected by qosgrp. */
 #else
 		uint64_t rmt_tail:36;
 		uint64_t rmt_one:1;
@@ -1496,19 +1573,18 @@ typedef union {
 		uint64_t reserved_39_63:25;
 #endif
 	} sindexload3;
-
-    /**
-     * Response to NULL_RD request loads
-     */
+	/**
+	 * Response to NULL_RD request loads
+	 */
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t unused:62;
 		uint64_t state:2;
-				   /**< of type cvmx_pow_tag_type_t. state is one of the following:
-                                        - CVMX_POW_TAG_TYPE_ORDERED
-                                        - CVMX_POW_TAG_TYPE_ATOMIC
-                                        - CVMX_POW_TAG_TYPE_NULL
-                                        - CVMX_POW_TAG_TYPE_NULL_NULL */
+			/**< Of type cvmx_pow_tag_type_t. state is one of the following:
+			 - CVMX_POW_TAG_TYPE_ORDERED
+			 - CVMX_POW_TAG_TYPE_ATOMIC
+			 - CVMX_POW_TAG_TYPE_NULL
+			 - CVMX_POW_TAG_TYPE_NULL_NULL */
 #else
 		uint64_t state:2;
 		uint64_t unused:62;
@@ -1566,19 +1642,14 @@ typedef union {
  *  that only contains the pointer). SW must never use did<2:0> == 2.
  */
 typedef union {
-    /**
-     * Unsigned 64 bit integer representation of store address
-     */
 	uint64_t u64;
-
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
-		uint64_t mem_reg:2;	    /**< Memory region.  Should be CVMX_IO_SEG in most cases */
-		uint64_t reserved_49_61:13;
-					    /**< Must be zero */
-		uint64_t is_io:1;	    /**< Must be one */
-		uint64_t did:8;		    /**< Device ID of POW.  Note that different sub-dids are used. */
-		uint64_t addr:40;	    /**< Address field. addr<2:0> must be zero */
+		uint64_t mem_reg:2; /**< Memory region.  Should be CVMX_IO_SEG in most cases */
+		uint64_t reserved_49_61:13; /**< Must be zero */
+		uint64_t is_io:1; /**< Must be one */
+		uint64_t did:8; /**< Device ID of POW. Note that different sub-dids are used. */
+		uint64_t addr:40; /**< Address field. addr<2:0> must be zero */
 #else
 		uint64_t addr:40;
 		uint64_t did:8;
@@ -1587,39 +1658,43 @@ typedef union {
 		uint64_t mem_reg:2;
 #endif
 	} stag;
-} cvmx_pow_tag_store_addr_t;	/* FIXME- this type is unused */
+} cvmx_pow_tag_store_addr_t; /* FIXME- this type is unused */
 
 /**
- * decode of the store data when an IOBDMA SENDSINGLE is sent to POW
+ * Decode of the store data when an IOBDMA SENDSINGLE is sent to POW
  */
 typedef union {
 	uint64_t u64;
-
 	struct {
 		CVMX_BITFIELD_FIELD(uint64_t scraddr:8,
-				    /**< the (64-bit word) location in scratchpad to write to (if len != 0) */
+			/**< the (64-bit word) location in scratchpad to write to (if len != 0) */
 		CVMX_BITFIELD_FIELD(uint64_t len:8,
-				    /**< the number of words in the response (0 => no response) */
+			/**< the number of words in the response (0 => no response) */
 		CVMX_BITFIELD_FIELD(uint64_t did:8,
-				    /**< the ID of the device on the non-coherent bus */
+			/**< the ID of the device on the non-coherent bus */
 		CVMX_BITFIELD_FIELD(uint64_t unused:36,
 		CVMX_BITFIELD_FIELD(uint64_t wait:1,
-				    /**< if set, don't return load response until work is available */
+			/**< if set, don't return load response until work is available */
 		CVMX_BITFIELD_FIELD(uint64_t unused2:3,
 		))))));
 	} s;
 	struct {
-		CVMX_BITFIELD_FIELD(uint64_t scraddr:8,/**< the (64-bit word) location in scratchpad to write to (if len != 0) */
-		CVMX_BITFIELD_FIELD(uint64_t len:8,    /**< the number of words in the response (0 => no response) */
-		CVMX_BITFIELD_FIELD(uint64_t did:8,    /**< the ID of the device on the non-coherent bus */
-		CVMX_BITFIELD_FIELD(uint64_t node:4,   /**< OCI node number, should always be local node */
+		CVMX_BITFIELD_FIELD(uint64_t scraddr:8,
+			/**< the (64-bit word) location in scratchpad to write to (if len != 0) */
+		CVMX_BITFIELD_FIELD(uint64_t len:8,
+			/**< the number of words in the response (0 => no response) */
+		CVMX_BITFIELD_FIELD(uint64_t did:8,
+			/**< the ID of the device on the non-coherent bus */
+		CVMX_BITFIELD_FIELD(uint64_t node:4,
+			/**< OCI node number, should always be local node */
 		CVMX_BITFIELD_FIELD(uint64_t unused1:4,
 		CVMX_BITFIELD_FIELD(uint64_t indexed:1,
 		CVMX_BITFIELD_FIELD(uint64_t grouped:1,
 		CVMX_BITFIELD_FIELD(uint64_t rtngrp:1,
 		CVMX_BITFIELD_FIELD(uint64_t unused2:13,
 		CVMX_BITFIELD_FIELD(uint64_t index_grp_mask:12,
-		CVMX_BITFIELD_FIELD(uint64_t wait:1,   /**< if set, don't return load response until work is available */
+		CVMX_BITFIELD_FIELD(uint64_t wait:1,
+			/**< if set, don't return load response until work is available */
 		CVMX_BITFIELD_FIELD(uint64_t unused3:3,
 		))))))))))));
 	} s_cn78xx;
@@ -1696,15 +1771,20 @@ static inline cvmx_pow_tag_info_t cvmx_pow_get_current_tag(void)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_sso_sl_ppx_tag_t sl_ppx_tag;
 		cvmx_xgrp_t xgrp;
-		int node = cvmx_get_node_num();
-		int core = cvmx_get_local_core_num();
+		int node, core;
+
+		CVMX_SYNCS;
+		node = cvmx_get_node_num();
+		core = cvmx_get_local_core_num();
 		sl_ppx_tag.u64 = cvmx_read_csr_node(node, CVMX_SSO_SL_PPX_TAG(core));
 		result.index = sl_ppx_tag.s.index;
 		result.tag_type = sl_ppx_tag.s.tt;
 		result.tag      = sl_ppx_tag.s.tag;
 
+		/* Get native XGRP value */
+		xgrp.xgrp =  sl_ppx_tag.s.grp;
+
 		/* Return legacy style group 0..15 */
-		xgrp.xgrp -=  sl_ppx_tag.s.grp;
 		result.grp = xgrp.group;
 	} else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE)) {
 		cvmx_pow_sl_tag_resp_t load_resp;
@@ -1813,12 +1893,10 @@ static inline void cvmx_pow_tag_sw_wait(void)
 		if (cvmx_likely(switch_complete))
 			break;
 		if (CVMX_ENABLE_POW_CHECKS) {
-			if (cvmx_unlikely(cvmx_get_cycle() >
-				(start_cycle + MAX_CYCLES))) {
-				cvmx_dprintf("WARNING: %s:"
-					"Tag switch is taking a long time, "
+			if (cvmx_unlikely(cvmx_get_cycle() > (start_cycle + MAX_CYCLES))) {
+				cvmx_dprintf("WARNING: %s: Tag switch is taking a long time, "
 					"possible deadlock\n", __func__);
-			start_cycle += MAX_CYCLES - 1;
+				start_cycle += MAX_CYCLES - 1;
 			}
 		}
 	}
@@ -1843,7 +1921,6 @@ static inline cvmx_wqe_t *cvmx_pow_work_request_sync_nocheck(cvmx_pow_wait_t wai
 		__cvmx_pow_warn_if_pending_switch(__func__);
 
 	ptr.u64 = 0;
-
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		ptr.swork_78xx.node = cvmx_get_node_num();
 		ptr.swork_78xx.mem_region = CVMX_IO_SEG;
@@ -1855,11 +1932,8 @@ static inline cvmx_wqe_t *cvmx_pow_work_request_sync_nocheck(cvmx_pow_wait_t wai
 		ptr.swork.is_io = 1;
 		ptr.swork.did = CVMX_OCT_DID_TAG_SWTAG;
 		ptr.swork.wait = wait;
-
 	}
-
 	result.u64 = cvmx_read_csr(ptr.u64);
-
 	if (result.s_work.no_work)
 		return NULL;
 	else
@@ -1878,13 +1952,9 @@ static inline cvmx_wqe_t *cvmx_pow_work_request_sync_nocheck(cvmx_pow_wait_t wai
  */
 static inline cvmx_wqe_t *cvmx_pow_work_request_sync(cvmx_pow_wait_t wait)
 {
-	if (CVMX_ENABLE_POW_CHECKS)
-		__cvmx_pow_warn_if_pending_switch(__func__);
-
 	/* Must not have a switch pending when requesting work */
 	cvmx_pow_tag_sw_wait();
 	return (cvmx_pow_work_request_sync_nocheck(wait));
-
 }
 
 /**
@@ -1899,9 +1969,6 @@ static inline cvmx_pow_tag_type_t cvmx_pow_work_request_null_rd(void)
 	cvmx_pow_load_addr_t ptr;
 	cvmx_pow_tag_load_resp_t result;
 
-	if (CVMX_ENABLE_POW_CHECKS)
-		__cvmx_pow_warn_if_pending_switch(__func__);
-
 	/* Must not have a switch pending when requesting work */
 	cvmx_pow_tag_sw_wait();
 
@@ -1911,23 +1978,24 @@ static inline cvmx_pow_tag_type_t cvmx_pow_work_request_null_rd(void)
 	ptr.snull_rd.did = CVMX_OCT_DID_TAG_NULL_RD;
 
 	result.u64 = cvmx_read_csr(ptr.u64);
-
-	return (cvmx_pow_tag_type_t) result.s_null_rd.state;
+	return (cvmx_pow_tag_type_t)result.s_null_rd.state;
 }
 
 /**
- * Asynchronous work request.  Work is requested from the POW unit, and should later
- * be checked with function cvmx_pow_work_response_async.
+ * Asynchronous work request.
+ * Work is requested from the POW unit, and should later be checked with
+ * function cvmx_pow_work_response_async.
  * This function does NOT wait for previous tag switches to complete,
  * so the caller must ensure that there is not a pending tag switch.
  *
  * @param scr_addr Scratch memory address that response will be returned to,
- *                  which is either a valid WQE, or a response with the invalid bit set.
- *                  Byte address, must be 8 byte aligned.
- * @param wait      1 to cause response to wait for work to become available (or timeout)
- *                  0 to cause response to return immediately
+ *     which is either a valid WQE, or a response with the invalid bit set.
+ *     Byte address, must be 8 byte aligned.
+ * @param wait 1 to cause response to wait for work to become available (or timeout)
+ *             0 to cause response to return immediately
  */
-static inline void cvmx_pow_work_request_async_nocheck(int scr_addr, cvmx_pow_wait_t wait)
+static inline void cvmx_pow_work_request_async_nocheck(int scr_addr,
+	cvmx_pow_wait_t wait)
 {
 	cvmx_pow_iobdma_store_t data;
 
@@ -1952,102 +2020,20 @@ static inline void cvmx_pow_work_request_async_nocheck(int scr_addr, cvmx_pow_wa
 }
 
 /**
- * Asynchronous work request.  Work is requested from the SSO unit, and should later
- * be checked with function cvmx_pow_work_response_async.
- * This function does NOT wait for previous tag switches to complete,
- * so the caller must ensure that there is not a pending tag switch.
- *
- * Only works on CN78XX style SSO.
- *
- * @param scr_addr Scratch memory address that response will be returned to,
- *                  which is either a valid WQE, or a response with the invalid bit set.
- *                  Byte address, must be 8 byte aligned.
- * @param xgrp      group to receive work for (0-255).
- * @param wait      1 to cause response to wait for work to become available (or timeout)
- *                  0 to cause response to return immediately
- */
-static inline void cvmx_sso_work_request_grp_async_nocheck(int scr_addr,
-	cvmx_xgrp_t xgrp, cvmx_pow_wait_t wait)
-{
-	cvmx_pow_iobdma_store_t data;
-	unsigned int node = cvmx_get_node_num();
-	if (CVMX_ENABLE_POW_CHECKS) {
-		__cvmx_pow_warn_if_pending_switch(__func__);
-		cvmx_warn_if(!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE), "Not CN78XX");
-	}
-
-	/* scr_addr must be 8 byte aligned */
-	data.u64 = 0;
-	data.s_cn78xx.scraddr = scr_addr >> 3;
-	data.s_cn78xx.len = 1;
-	data.s_cn78xx.did = CVMX_OCT_DID_TAG_SWTAG;
-	data.s_cn78xx.grouped = 1;
-	data.s_cn78xx.index_grp_mask = (node << 8) | xgrp.xgrp ;
-	data.s_cn78xx.wait = wait;
-	data.s_cn78xx.node = node;
-
-	cvmx_send_single(data.u64);
-}
-
-/**
- * Synchronous work request.  Requests work from a specific SSO group.
- * This function waits for any previous tag switch to complete before
- * requesting the new work.
- *
- * Only works on CN78XX style SSO.
- *
- * @param lgrp The local group number (within the SSO of the node of the caller) from which to get the work.
- * @param wait   When set, call stalls until work becomes avaiable, or times out.
- *               If not set, returns immediately.
- *
- * @return Returns the WQE pointer from SSO. Returns NULL if no work was available.
- */
-static inline void *cvmx_sso_work_request_grp_sync_nocheck(unsigned int lgrp, cvmx_pow_wait_t wait)
-{
-	cvmx_pow_load_addr_t ptr;
-	cvmx_pow_tag_load_resp_t result;
-	unsigned int node = cvmx_get_node_num() & 3;
-
-	if (CVMX_ENABLE_POW_CHECKS) {
-		__cvmx_pow_warn_if_pending_switch(__func__);
-		cvmx_warn_if(!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE), "Not CN78XX");
-	}
-
-	ptr.u64 = 0;
-
-	ptr.swork_78xx.mem_region = CVMX_IO_SEG;
-	ptr.swork_78xx.is_io = 1;
-	ptr.swork_78xx.did = CVMX_OCT_DID_TAG_SWTAG;
-	ptr.swork_78xx.node = node;
-	ptr.swork_78xx.grouped = 1;
-	ptr.swork_78xx.index = (lgrp & 0xff) | node << 8;
-	ptr.swork_78xx.wait = wait;
-
-	result.u64 = cvmx_read_csr(ptr.u64);
-
-	if (result.s_work.no_work)
-		return NULL;
-	else
-		return cvmx_phys_to_ptr(result.s_work.addr);
-}
-
-/**
- * Asynchronous work request.  Work is requested from the POW unit, and should later
- * be checked with function cvmx_pow_work_response_async.
+ * Asynchronous work request.
+ * Work is requested from the POW unit, and should later be checked with
+ * function cvmx_pow_work_response_async.
  * This function waits for any previous tag switch to complete before
  * requesting the new work.
  *
  * @param scr_addr Scratch memory address that response will be returned to,
- *                  which is either a valid WQE, or a response with the invalid bit set.
- *                  Byte address, must be 8 byte aligned.
- * @param wait      1 to cause response to wait for work to become available (or timeout)
- *                  0 to cause response to return immediately
+ *     which is either a valid WQE, or a response with the invalid bit set.
+ *     Byte address, must be 8 byte aligned.
+ * @param wait 1 to cause response to wait for work to become available (or timeout)
+ *             0 to cause response to return immediately
  */
 static inline void cvmx_pow_work_request_async(int scr_addr, cvmx_pow_wait_t wait)
 {
-	if (CVMX_ENABLE_POW_CHECKS)
-		__cvmx_pow_warn_if_pending_switch(__func__);
-
 	/* Must not have a switch pending when requesting work */
 	cvmx_pow_tag_sw_wait();
 	cvmx_pow_work_request_async_nocheck(scr_addr, wait);
@@ -2067,7 +2053,6 @@ static inline cvmx_wqe_t *cvmx_pow_work_response_async(int scr_addr)
 
 	CVMX_SYNCIOBDMA;
 	result.u64 = cvmx_scratch_read64(scr_addr);
-
 	if (result.s_work.no_work)
 		return NULL;
 	else
@@ -2086,7 +2071,7 @@ static inline cvmx_wqe_t *cvmx_pow_work_response_async(int scr_addr)
  */
 static inline uint64_t cvmx_pow_work_invalid(cvmx_wqe_t * wqe_ptr)
 {
-	return (wqe_ptr == NULL);	/* FIXME: improve */
+	return (wqe_ptr == NULL); /* FIXME: improve */
 }
 
 /**
@@ -2117,24 +2102,35 @@ static inline void cvmx_pow_tag_sw_nocheck(uint32_t tag, cvmx_pow_tag_type_t tag
 		cvmx_pow_tag_info_t current_tag;
 		__cvmx_pow_warn_if_pending_switch(__func__);
 		current_tag = cvmx_pow_get_current_tag();
-		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL, "%s called with NULL_NULL tag\n", __func__);
-		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL, "%s called with NULL tag\n", __func__);
-		cvmx_warn_if((current_tag.tag_type == tag_type) && (current_tag.tag == tag), "%s called to perform a tag switch to the same tag\n", __func__);
-		cvmx_warn_if(tag_type == CVMX_POW_TAG_TYPE_NULL, "%s called to perform a tag switch to NULL. Use cvmx_pow_tag_sw_null() instead\n", __func__);
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL,
+			"%s called with NULL_NULL tag\n", __func__);
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL,
+			"%s called with NULL tag\n", __func__);
+		cvmx_warn_if((current_tag.tag_type == tag_type) && (current_tag.tag == tag),
+			"%s called to perform a tag switch to the same tag\n", __func__);
+		cvmx_warn_if(tag_type == CVMX_POW_TAG_TYPE_NULL,
+			"%s called to perform a tag switch to NULL. "
+			"Use cvmx_pow_tag_sw_null() instead\n", __func__);
 	}
-
 	/* Note that WQE in DRAM is not updated here, as the POW does not read from DRAM
-	 ** once the WQE is in flight.  See hardware manual for complete details.
-	 ** It is the application's responsibility to keep track of the current tag
-	 ** value if that is important.
+	 * once the WQE is in flight.  See hardware manual for complete details.
+	 * It is the application's responsibility to keep track of the current tag
+	 * value if that is important.
 	 */
-
 	tag_req.u64 = 0;
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		tag_req.s_cn78xx_other.op   = CVMX_POW_TAG_OP_SWTAG;
-		tag_req.s_cn78xx_other.type = tag_type;
-	} else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE)) {
-		tag_req.s_cn68xx_other.op = CVMX_POW_TAG_OP_SWTAG;
+		cvmx_wqe_t *wqp = cvmx_pow_get_current_wqp();
+		if (wqp == NULL) {
+			cvmx_dprintf("ERROR: Failed to get WQE, %s\n", __func__);
+			return;
+		}
+		wqp->word1.cn78xx.tag = tag;
+		wqp->word1.cn78xx.tag_type = tag_type;
+		CVMX_SYNCWS;
+		tag_req.s_cn78xx_other.op   = CVMX_POW_TAG_OP_SWTAG;
+		tag_req.s_cn78xx_other.type = tag_type;
+	} else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE)) {
+		tag_req.s_cn68xx_other.op = CVMX_POW_TAG_OP_SWTAG;
 		tag_req.s_cn68xx_other.tag = tag;
 		tag_req.s_cn68xx_other.type = tag_type;
 	} else {
@@ -2142,7 +2138,6 @@ static inline void cvmx_pow_tag_sw_nocheck(uint32_t tag, cvmx_pow_tag_type_t tag
 		tag_req.s_cn38xx.tag = tag;
 		tag_req.s_cn38xx.type = tag_type;
 	}
-
 	ptr.u64 = 0;
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		ptr.s_cn78xx.mem_region = CVMX_IO_SEG;
@@ -2155,8 +2150,7 @@ static inline void cvmx_pow_tag_sw_nocheck(uint32_t tag, cvmx_pow_tag_type_t tag
 		ptr.s.is_io = 1;
 		ptr.s.did = CVMX_OCT_DID_TAG_SWTAG;
 	}
-
-	/* once this store arrives at POW, it will attempt the switch
+	/* Once this store arrives at POW, it will attempt the switch
 	   software must wait for the switch to complete separately */
 	cvmx_write_io(ptr.u64, tag_req.u64);
 }
@@ -2182,15 +2176,11 @@ static inline void cvmx_pow_tag_sw_nocheck(uint32_t tag, cvmx_pow_tag_type_t tag
  */
 static inline void cvmx_pow_tag_sw(uint32_t tag, cvmx_pow_tag_type_t tag_type)
 {
-	if (CVMX_ENABLE_POW_CHECKS)
-		__cvmx_pow_warn_if_pending_switch(__func__);
-
 	/* Note that WQE in DRAM is not updated here, as the POW does not read from DRAM
-	 ** once the WQE is in flight.  See hardware manual for complete details.
-	 ** It is the application's responsibility to keep track of the current tag
-	 ** value if that is important.
+	 * once the WQE is in flight.  See hardware manual for complete details.
+	 * It is the application's responsibility to keep track of the current tag
+	 * value if that is important.
 	 */
-
 	/* Ensure that there is not a pending tag switch, as a tag switch cannot be started
 	 ** if a previous switch is still pending.  */
 	cvmx_pow_tag_sw_wait();
@@ -2217,7 +2207,8 @@ static inline void cvmx_pow_tag_sw(uint32_t tag, cvmx_pow_tag_type_t tag_type)
  * @param tag_type type of tag
  * @param group      group value for the work queue entry.
  */
-static inline void cvmx_pow_tag_sw_full_nocheck(cvmx_wqe_t * wqp, uint32_t tag, cvmx_pow_tag_type_t tag_type, uint64_t group)
+static inline void cvmx_pow_tag_sw_full_nocheck(cvmx_wqe_t * wqp, uint32_t tag,
+	cvmx_pow_tag_type_t tag_type, uint64_t group)
 {
 	union cvmx_pow_tag_req_addr ptr;
 	cvmx_pow_tag_req_t tag_req;
@@ -2227,28 +2218,31 @@ static inline void cvmx_pow_tag_sw_full_nocheck(cvmx_wqe_t * wqp, uint32_t tag,
 		cvmx_pow_tag_info_t current_tag;
 		__cvmx_pow_warn_if_pending_switch(__func__);
 		current_tag = cvmx_pow_get_current_tag();
-		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL, "%s called with NULL_NULL tag\n", __func__);
-		cvmx_warn_if((current_tag.tag_type == tag_type) && (current_tag.tag == tag), "%s called to perform a tag switch to the same tag\n", __func__);
-		cvmx_warn_if(tag_type == CVMX_POW_TAG_TYPE_NULL, "%s called to perform a tag switch to NULL. Use cvmx_pow_tag_sw_null() instead\n", __func__);
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL,
+			"%s called with NULL_NULL tag\n", __func__);
+		cvmx_warn_if((current_tag.tag_type == tag_type) && (current_tag.tag == tag),
+			"%s called to perform a tag switch to the same tag\n", __func__);
+		cvmx_warn_if(tag_type == CVMX_POW_TAG_TYPE_NULL,
+			"%s called to perform a tag switch to NULL. "
+			"Use cvmx_pow_tag_sw_null() instead\n", __func__);
 		if ((wqp != cvmx_phys_to_ptr(0x80)) && cvmx_pow_get_current_wqp())
-			cvmx_warn_if(wqp != cvmx_pow_get_current_wqp(), "%s passed WQE(%p) doesn't match the address in the POW(%p)\n", __func__, wqp, cvmx_pow_get_current_wqp());
+			cvmx_warn_if(wqp != cvmx_pow_get_current_wqp(),
+				"%s passed WQE(%p) doesn't match the address in the POW(%p)\n",
+				__func__, wqp, cvmx_pow_get_current_wqp());
 	}
-
 	/* Note that WQE in DRAM is not updated here, as the POW does not read from DRAM
-	 ** once the WQE is in flight.  See hardware manual for complete details.
-	 ** It is the application's responsibility to keep track of the current tag
-	 ** value if that is important.
+	 * once the WQE is in flight.  See hardware manual for complete details.
+	 * It is the application's responsibility to keep track of the current tag
+	 * value if that is important.
 	 */
-
 	tag_req.u64 = 0;
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		unsigned xgrp;
 		uint64_t wqp_phys;
 
 		wqp_phys = cvmx_ptr_to_phys(wqp);
-
 		if(wqp_phys!= 0x80) {
-			/* If WQE is valid, use its XGRP */
+			/* If WQE is valid, use its XGRP.  WQE GRP is 10 bits, includes node # */
 			xgrp = wqp->word1.cn78xx.grp;
 			/* Use XGRP[node] too */
 			node = xgrp >> 8;
@@ -2265,13 +2259,11 @@ static inline void cvmx_pow_tag_sw_full_nocheck(cvmx_wqe_t * wqp, uint32_t tag,
 			xgrp = group << 3;
 			xgrp |= node << 8;
 		}
-
 		tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_SWTAG_FULL;
 		tag_req.s_cn78xx_other.type = tag_type;
 		tag_req.s_cn78xx_other.grp = xgrp;
 		tag_req.s_cn78xx_other.wqp = wqp_phys;
 
-		/* WQE GRP is 10 bits, includes node # */
 	}
 	else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE)) {
 		tag_req.s_cn68xx_other.op = CVMX_POW_TAG_OP_SWTAG_FULL;
@@ -2284,7 +2276,6 @@ static inline void cvmx_pow_tag_sw_full_nocheck(cvmx_wqe_t * wqp, uint32_t tag,
 		tag_req.s_cn38xx.type = tag_type;
 		tag_req.s_cn38xx.grp = group;
 	}
-
 	ptr.u64 = 0;
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		ptr.s_cn78xx.mem_region = CVMX_IO_SEG;
@@ -2298,119 +2289,41 @@ static inline void cvmx_pow_tag_sw_full_nocheck(cvmx_wqe_t * wqp, uint32_t tag,
 		ptr.s.did = CVMX_OCT_DID_TAG_SWTAG;
 		ptr.s.addr = cvmx_ptr_to_phys(wqp);
 	}
-
-	/* once this store arrives at POW, it will attempt the switch
+	/* Once this store arrives at POW, it will attempt the switch
 	   software must wait for the switch to complete separately */
 	cvmx_write_io(ptr.u64, tag_req.u64);
 }
 
 /**
- * Starts a tag switch to the provided tag value and tag type.  Completion for
- * the tag switch must be checked for separately.
- * This function does NOT update the
- * work queue entry in dram to match tag value and type, so the application must
- * keep track of these if they are important to the application.
- * This tag switch command must not be used for switches to NULL, as the tag
- * switch pending bit will be set by the switch request, but never cleared by the
- * hardware.
+ * Starts a tag switch to the provided tag value and tag type.
+ * Completion for the tag switch must be checked for separately.
+ * This function does NOT update the work queue entry in dram to match tag value
+ * and type, so the application must keep track of these if they are important
+ * to the application. This tag switch command must not be used for switches
+ * to NULL, as the tag switch pending bit will be set by the switch request,
+ * but never cleared by the hardware.
  *
  * This function must be used for tag switches from NULL.
  *
  * This function waits for any pending tag switches to complete
  * before requesting the tag switch.
  *
- * @param wqp      pointer to work queue entry to submit.  This entry is updated to match the other parameters
- * @param tag      tag value to be assigned to work queue entry
- * @param tag_type type of tag
- * @param group      group value for the work queue entry.
+ * @param wqp      Pointer to work queue entry to submit.
+ *     This entry is updated to match the other parameters
+ * @param tag      Tag value to be assigned to work queue entry
+ * @param tag_type Type of tag
+ * @param group    Group value for the work queue entry.
  */
-static inline void cvmx_pow_tag_sw_full(cvmx_wqe_t * wqp, uint32_t tag, cvmx_pow_tag_type_t tag_type, uint64_t group)
+static inline void cvmx_pow_tag_sw_full(cvmx_wqe_t * wqp, uint32_t tag,
+	cvmx_pow_tag_type_t tag_type, uint64_t group)
 {
-	if (CVMX_ENABLE_POW_CHECKS)
-		__cvmx_pow_warn_if_pending_switch(__func__);
-
-	/* Ensure that there is not a pending tag switch, as a tag switch cannot be started
-	 ** if a previous switch is still pending.  */
+	/* Ensure that there is not a pending tag switch, as a tag switch cannot
+	 * be started if a previous switch is still pending. */
 	cvmx_pow_tag_sw_wait();
 	cvmx_pow_tag_sw_full_nocheck(wqp, tag, tag_type, group);
 }
 
 /**
- * Executes SWTAG_FULL SSO command.
- * This is similiar to cvmx_pow_tag_sw_full() function, but uses linear
- * (vs. integrated group-qos) group index.
- */
-static inline void cvmx_pow_tag_sw_full_node(cvmx_wqe_t * wqp, uint32_t tag, cvmx_pow_tag_type_t tag_type, uint64_t xgrp, int node)
-{
-	union cvmx_pow_tag_req_addr ptr;
-	cvmx_pow_tag_req_t tag_req;
-	int group;
-
-	if (CVMX_ENABLE_POW_CHECKS)
-		__cvmx_pow_warn_if_pending_switch(__func__);
-
-	/* Ensure that there is not a pending tag switch, as a tag switch cannot be started
-	 ** if a previous switch is still pending.  */
-	CVMX_SYNCWS;
-	cvmx_pow_tag_sw_wait();
-
-	if (CVMX_ENABLE_POW_CHECKS) {
-		cvmx_pow_tag_info_t current_tag;
-		__cvmx_pow_warn_if_pending_switch(__func__);
-		current_tag = cvmx_pow_get_current_tag();
-		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL, "%s called with NULL_NULL tag\n", __func__);
-		cvmx_warn_if((current_tag.tag_type == tag_type) && (current_tag.tag == tag), "%s called to perform a tag switch to the same tag\n", __func__);
-		cvmx_warn_if(tag_type == CVMX_POW_TAG_TYPE_NULL, "%s called to perform a tag switch to NULL. Use cvmx_pow_tag_sw_null() instead\n", __func__);
-		if ((wqp != cvmx_phys_to_ptr(0x80)) && cvmx_pow_get_current_wqp())
-			cvmx_warn_if(wqp != cvmx_pow_get_current_wqp(), "%s passed WQE(%p) doesn't match the address in the POW(%p)\n", __func__, wqp, cvmx_pow_get_current_wqp());
-	}
-	/* Note that WQE in DRAM is not updated here, as the POW does not read from DRAM
-	 * once the WQE is in flight.
-	 */
-	group = xgrp & 0xff;
-	tag_req.u64 = 0;
-	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		uint64_t wqp_phys = cvmx_ptr_to_phys(wqp);
-
-		if(wqp_phys!= 0x80) {
-			wqp->word1.cn78xx.grp = group;
-			wqp->word1.cn78xx.tag = tag;
-			wqp->word1.cn78xx.tag_type = tag_type;
-			CVMX_SYNCWS;
-		}
-		tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_SWTAG_FULL;
-		tag_req.s_cn78xx_other.type = tag_type;
-		tag_req.s_cn78xx_other.grp = group;
-		tag_req.s_cn78xx_other.wqp = wqp_phys;
-	}
-	else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE)) {
-		tag_req.s_cn68xx_other.op = CVMX_POW_TAG_OP_SWTAG_FULL;
-		tag_req.s_cn68xx_other.tag = tag;
-		tag_req.s_cn68xx_other.type = tag_type;
-		tag_req.s_cn68xx_other.grp = group;
-	} else {
-		tag_req.s_cn38xx.op = CVMX_POW_TAG_OP_SWTAG_FULL;
-		tag_req.s_cn38xx.tag = tag;
-		tag_req.s_cn38xx.type = tag_type;
-		tag_req.s_cn38xx.grp = group;
-	}
-	ptr.u64 = 0;
-	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		ptr.s_cn78xx.mem_region = CVMX_IO_SEG;
-		ptr.s_cn78xx.is_io = 1;
-		ptr.s_cn78xx.did = CVMX_OCT_DID_TAG_SWTAG;
-		ptr.s_cn78xx.node = node;
-		ptr.s_cn78xx.tag  = tag;
-	} else {
-		ptr.s.mem_region = CVMX_IO_SEG;
-		ptr.s.is_io = 1;
-		ptr.s.did = CVMX_OCT_DID_TAG_SWTAG;
-		ptr.s.addr = cvmx_ptr_to_phys(wqp);
-	}
-	cvmx_write_io(ptr.u64, tag_req.u64);
-}
-
-/**
  * Switch to a NULL tag, which ends any ordering or
  * synchronization provided by the POW for the current
  * work queue entry.  This operation completes immediately,
@@ -2427,10 +2340,11 @@ static inline void cvmx_pow_tag_sw_null_nocheck(void)
 		cvmx_pow_tag_info_t current_tag;
 		__cvmx_pow_warn_if_pending_switch(__func__);
 		current_tag = cvmx_pow_get_current_tag();
-		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL, "%s called with NULL_NULL tag\n", __func__);
-		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL, "%s called when we already have a NULL tag\n", __func__);
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL,
+			"%s called with NULL_NULL tag\n", __func__);
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL,
+			"%s called when we already have a NULL tag\n", __func__);
 	}
-
 	tag_req.u64 = 0;
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_SWTAG;
@@ -2443,7 +2357,6 @@ static inline void cvmx_pow_tag_sw_null_nocheck(void)
 		tag_req.s_cn38xx.op = CVMX_POW_TAG_OP_SWTAG;
 		tag_req.s_cn38xx.type = CVMX_POW_TAG_TYPE_NULL;
 	}
-
 	ptr.u64 = 0;
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		ptr.s_cn78xx.mem_region = CVMX_IO_SEG;
@@ -2455,10 +2368,7 @@ static inline void cvmx_pow_tag_sw_null_nocheck(void)
 		ptr.s.is_io = 1;
 		ptr.s.did = CVMX_OCT_DID_TAG_TAG1;
 	}
-
 	cvmx_write_io(ptr.u64, tag_req.u64);
-
-	/* switch to NULL completes immediately */
 }
 
 /**
@@ -2471,30 +2381,27 @@ static inline void cvmx_pow_tag_sw_null_nocheck(void)
  */
 static inline void cvmx_pow_tag_sw_null(void)
 {
-	if (CVMX_ENABLE_POW_CHECKS)
-		__cvmx_pow_warn_if_pending_switch(__func__);
-
-	/* Ensure that there is not a pending tag switch, as a tag switch cannot be started
-	 ** if a previous switch is still pending.  */
+	/* Ensure that there is not a pending tag switch, as a tag switch cannot
+	 * be started if a previous switch is still pending. */
 	cvmx_pow_tag_sw_wait();
 	cvmx_pow_tag_sw_null_nocheck();
-
-	/* switch to NULL completes immediately */
 }
 
 /**
- * Submits work to an input queue.  This function updates the work queue entry in DRAM to match
- * the arguments given.
- * Note that the tag provided is for the work queue entry submitted, and is unrelated to the tag that
- * the core currently holds.
+ * Submits work to an input queue.
+ * This function updates the work queue entry in DRAM to match the arguments given.
+ * Note that the tag provided is for the work queue entry submitted, and
+ * is unrelated to the tag that the core currently holds.
  *
- * @param wqp      pointer to work queue entry to submit.  This entry is updated to match the other parameters
+ * @param wqp      pointer to work queue entry to submit.
+ *                 This entry is updated to match the other parameters
  * @param tag      tag value to be assigned to work queue entry
  * @param tag_type type of tag
  * @param qos      Input queue to add to.
  * @param grp      group value for the work queue entry.
  */
-static inline void cvmx_pow_work_submit(cvmx_wqe_t * wqp, uint32_t tag, cvmx_pow_tag_type_t tag_type, uint64_t qos, uint64_t grp)
+static inline void cvmx_pow_work_submit(cvmx_wqe_t * wqp, uint32_t tag,
+	cvmx_pow_tag_type_t tag_type, uint64_t qos, uint64_t grp)
 {
 	union cvmx_pow_tag_req_addr ptr;
 	cvmx_pow_tag_req_t tag_req;
@@ -2568,108 +2475,8 @@ static inline void cvmx_pow_work_submit(cvmx_wqe_t * wqp, uint32_t tag, cvmx_pow
 		ptr.s.did = CVMX_OCT_DID_TAG_TAG1;
 		ptr.s.addr = cvmx_ptr_to_phys(wqp);
 	}
-
-	/* SYNC write to memory before the work submit.  This is necessary
-	 ** as POW may read values from DRAM at this time */
-	CVMX_SYNCWS;
-	cvmx_write_io(ptr.u64, tag_req.u64);
-}
-
-/**
- * Submits work to an SSO group on any OCI node.
- * This function updates the work queue entry in DRAM to match
- * the arguments given.
- * Note that the tag provided is for the work queue entry submitted,
- * and is unrelated to the tag that the core currently holds.
- *
- * @param wqp pointer to work queue entry to submit.
- * This entry is updated to match the other parameters
- * @param tag tag value to be assigned to work queue entry
- * @param tag_type type of tag
- * @param xgrp native CN78XX group in the range 0..255
- * @param node The OCI node number for the target group
- *
- * When this function is called on a model prior to CN78XX, which does
- * not support OCI nodes, the 'node' argument is ignored, and the 'xgrp'
- * parameter is converted into 'qos' (the lower 3 bits) and 'grp' (the higher
- * 5 bits), following the backward-compatibility scheme of translating
- * between new and old style group numbers.
- */
-static inline void cvmx_pow_work_submit_node(cvmx_wqe_t * wqp, uint32_t tag, cvmx_pow_tag_type_t tag_type, uint8_t xgrp, uint8_t node)
-{
-	union cvmx_pow_tag_req_addr ptr;
-	cvmx_pow_tag_req_t tag_req;
-
-	tag_req.u64 = 0;
-	ptr.u64 = 0;
-
-	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		unsigned gxgrp;
-
-		gxgrp = xgrp & 0xff;
-		gxgrp |= node << 8;
-
-		wqp->word1.cn78xx.rsvd_0 = 0;
-		wqp->word1.cn78xx.rsvd_1 = 0;
-		wqp->word1.cn78xx.tag = tag;
-		wqp->word1.cn78xx.tag_type = tag_type;
-		wqp->word1.cn78xx.grp = gxgrp;
-		CVMX_SYNCWS;
-
-		tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_ADDWQ;
-		tag_req.s_cn78xx_other.type = tag_type;
-		tag_req.s_cn78xx_other.wqp = cvmx_ptr_to_phys(wqp);
-		tag_req.s_cn78xx_other.grp = xgrp;
-
-		ptr.s_cn78xx.did = 0x66; //CVMX_OCT_DID_TAG_TAG6;
-		ptr.s_cn78xx.mem_region = CVMX_IO_SEG;
-		ptr.s_cn78xx.is_io = 1;
-		ptr.s_cn78xx.node = node;
-		ptr.s_cn78xx.tag = tag;
-	} else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE)) {
-		/* Reset all reserved bits */
-		wqp->word1.cn68xx.zero_0 = 0;
-		wqp->word1.cn68xx.zero_1 = 0;
-		wqp->word1.cn68xx.zero_2 = 0;
-		wqp->word1.cn68xx.qos = xgrp & 0x7;
-		wqp->word1.cn68xx.grp = xgrp >> 3;
-
-		wqp->word1.tag = tag;
-		wqp->word1.tag_type = tag_type;
-
-		tag_req.s_cn68xx_add.op = CVMX_POW_TAG_OP_ADDWQ;
-		tag_req.s_cn68xx_add.type = tag_type;
-		tag_req.s_cn68xx_add.tag = tag;
-		tag_req.s_cn68xx_add.qos = xgrp & 0x7;
-		tag_req.s_cn68xx_add.grp = xgrp >> 3;
-
-		ptr.s.mem_region = CVMX_IO_SEG;
-		ptr.s.is_io = 1;
-		ptr.s.did = CVMX_OCT_DID_TAG_TAG1;
-		ptr.s.addr = cvmx_ptr_to_phys(wqp);
-	} else {
-		/* Reset all reserved bits */
-		wqp->word1.cn38xx.zero_2 = 0;
-		wqp->word1.cn38xx.qos = xgrp & 0x7;
-		wqp->word1.cn38xx.grp = xgrp >> 3;
-
-		wqp->word1.tag = tag;
-		wqp->word1.tag_type = tag_type;
-
-		tag_req.s_cn38xx.op = CVMX_POW_TAG_OP_ADDWQ;
-		tag_req.s_cn38xx.type = tag_type;
-		tag_req.s_cn38xx.tag = tag;
-		tag_req.s_cn38xx.qos = xgrp & 0x7;
-		tag_req.s_cn38xx.grp = xgrp >> 3;
-
-		ptr.s.mem_region = CVMX_IO_SEG;
-		ptr.s.is_io = 1;
-		ptr.s.did = CVMX_OCT_DID_TAG_TAG1;
-		ptr.s.addr = cvmx_ptr_to_phys(wqp);
-	}
-
-	/* SYNC write to memory before the work submit.  This is necessary
-	 ** as POW may read values from DRAM at this time */
+	/* SYNC write to memory before the work submit.
+	 * This is necessary as POW may read values from DRAM at this time */
 	CVMX_SYNCWS;
 	cvmx_write_io(ptr.u64, tag_req.u64);
 }
@@ -2710,7 +2517,6 @@ static inline void cvmx_pow_set_group_mask(uint64_t core_num, uint64_t mask)
 		__func__, (unsigned long long) core_num);
 	    return;
 	}
-
 	cvmx_warn_if(mask & (~valid_mask),
 		"%s group number range exceeded: %#llx\n",
 		__func__, (unsigned long long) mask);
@@ -2762,204 +2568,43 @@ static inline void cvmx_pow_set_group_mask(uint64_t core_num, uint64_t mask)
 }
 
 /**
- * This function sets the group mask for a core.  The group mask bits
- * indicate which groups each core will accept work from.
- *
- * @param core_num 	Processor core to apply mask to.
- * @param mask_set	7XXX has 2 sets of masks per core.
- *                  Bit 0 represents the first mask set, bit 1 -- the second.
- * @param xgrp_mask	Group mask array.
- *                  Total number of groups is divided into a number of
- *                  64-bits mask sets. Each bit in the mask, if set, enables
- *                  the core to accept work from the corresponding group.
+ * This function sets POW static priorities for a core. Each input queue has
+ * an associated priority value.
  *
- * NOTE: Each core can be configured to accept work in accordance to both
- * mask sets, with the first having higher precedence over the second,
- * or to accept work in accordance to just one of the two mask sets.
- * The 'core_num' argument represents a processor core on any node
- * in a coherent multi-chip system.
+ * @param core_num   core to apply priorities to
+ * @param priority   Vector of 8 priorities, one per POW Input Queue (0-7).
+ *                   Highest priority is 0 and lowest is 7. A priority value
+ *                   of 0xF instructs POW to skip the Input Queue when
+ *                   scheduling to this specific core.
+ *                   NOTE: priorities should not have gaps in values, meaning
+ *                         {0,1,1,1,1,1,1,1} is a valid configuration while
+ *                         {0,2,2,2,2,2,2,2} is not.
  */
-static inline void cvmx_pow_set_xgrp_mask( uint64_t core_num,
-		uint8_t mask_set, const uint64_t xgrp_mask[])
+static inline void cvmx_pow_set_priority(uint64_t core_num, const uint8_t priority[])
 {
-	cvmx_sso_ppx_sx_grpmskx_t grp_msk;
-	unsigned grp, node, core;
+	if (OCTEON_IS_MODEL(OCTEON_CN3XXX))
+		return;
 
+	/* Detect gaps between priorities and flag error */
 	if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		cvmx_dprintf(
-			"ERROR: %s is not supported on this chip)\n",
-			__FUNCTION__);
-		return;
+		int i;
+		uint32_t prio_mask = 0;
+
+		for (i = 0; i < 8; i++)
+			if (priority[i] != 0xF)
+				prio_mask |= 1 << priority[i];
+
+		if (prio_mask ^ ((1 << cvmx_pop(prio_mask)) - 1)) {
+			cvmx_dprintf("ERROR: POW static priorities should be contiguous (0x%llx)\n",
+				(unsigned long long)prio_mask);
+			return;
+		}
 	}
-	node = cvmx_coremask_core_to_node(core_num);
-	core = cvmx_coremask_core_on_node(core_num);
 
-	for (grp = 0; grp < (cvmx_sso_num_xgrp() >> 6); grp++) {
-		uint64_t reg_addr;
-
-		reg_addr = CVMX_SSO_PPX_SX_GRPMSKX(core, 0, grp),
-		grp_msk.u64 = 0;
-		if (mask_set & 1)
-			grp_msk.s.grp_msk = xgrp_mask[grp];
-		cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
-
-		reg_addr = CVMX_SSO_PPX_SX_GRPMSKX(core, 1, grp),
-		grp_msk.u64 = 0;
-		if (mask_set & 2)
-			grp_msk.s.grp_msk = xgrp_mask[grp];
-		cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
-	}
-}
-
-/**
- * This function sets the the affinity of group to the cores in 78xx.
- * It sets up all the cores in core_mask to accept work from the specified group.
- *
- * @param xgrp  	group to accept work from, 0 - 255.
- * @param core_mask	mask of all the cores which will accept work from this group
- * @param mask_set	every core has set of 2 masks which can be set to accept work
- *                      from 256 groups. At the time of get_work, cores can choose which
- *			mask_set to get work from.
- * 			'mask_set' values range from 0 to 3, where
- * 			each of the two bits represents a mask set.
- * 			Cores will be added to the mask set whith corresponding
- * 			bit set, and removed from the mask set with
- * 			corresponding bit clear.
- *
- * Note: cores can only accept work from SSO groups on the same node,
- * so the node number for the group is derived from the core number.
- *
- */
-static inline void cvmx_sso_set_group_core_affinity(cvmx_xgrp_t xgrp,
-		const cvmx_coremask_t * core_mask, uint8_t mask_set)
-{
-	cvmx_sso_ppx_sx_grpmskx_t grp_msk;
-	int core;
-	int grp_index  = xgrp.xgrp >> 6;
-	int bit_pos = xgrp.xgrp % 64;
-
-	if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		cvmx_dprintf(
-			"ERROR: %s is not supported on this chip)\n",
-			__FUNCTION__);
-		return;
-	}
-
-	cvmx_coremask_for_each_core(core, core_mask) {
-		unsigned node, ncore;
-		uint64_t reg_addr;
-
-		node = cvmx_coremask_core_to_node(core);
-		ncore = cvmx_coremask_core_on_node(core);
-
-		reg_addr = CVMX_SSO_PPX_SX_GRPMSKX(ncore, 0, grp_index);
-		grp_msk.u64 = cvmx_read_csr_node(node, reg_addr);
-
-		if(mask_set & 1)
-			grp_msk.s.grp_msk |= (1ull << bit_pos);
-		else
-			grp_msk.s.grp_msk &= ~(1ull << bit_pos);
-
-		cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
-
-		reg_addr = CVMX_SSO_PPX_SX_GRPMSKX(ncore, 1, grp_index);
-		grp_msk.u64 = cvmx_read_csr_node(node, reg_addr);
-
-		if(mask_set & 2)
-			grp_msk.s.grp_msk |= (1ull << bit_pos);
-		else
-			grp_msk.s.grp_msk &= ~(1ull << bit_pos);
-
-		cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
-	}
-}
-
-/**
- * This function sets the priority and group affinity arbitration for each group.
- *
- * @param node 		node number
- * @param xgrp  	group 0 - 255 to apply mask parameters to
- * @param priority	priority of the group relative to other groups
- *			0x0 - highest priority
- *			0x7 - lowest priority
- * @param weight	Cross-group arbitration weight to apply to this group.
- *			valid values are 1-63
- *			h/w default is 0x3f
- * @param affinity	Processor affinity arbitration weight to apply to this group.
- *			If zero, affinity is disabled.
- *			valid values are 0-15
- *			h/w default which is 0xf.
- * @param modify_mask   mask of the parameters which needs to be modified.
- *			enum cvmx_sso_group_modify_mask
- *                      to modify only priority -- set bit0
- *                      to modify only weight   -- set bit1
- *			to modify only affinity -- set bit2
- */
-static inline void cvmx_sso_set_group_priority(int node, cvmx_xgrp_t xgrp,
-			int priority, int weight, int affinity,
-		       enum cvmx_sso_group_modify_mask modify_mask)
-{
-	cvmx_sso_grpx_pri_t grp_pri;
-
-	if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		cvmx_dprintf(
-			"ERROR: %s is not supported on this chip)\n",
-			__FUNCTION__);
-		return;
-	}
-
-	if (weight <= 0)
-		weight = 0x3f;	/* Force HW default when out of range */
-
-	grp_pri.u64 = cvmx_read_csr_node(node, CVMX_SSO_GRPX_PRI(xgrp.xgrp));
-	if(grp_pri.s.weight == 0)
-		grp_pri.s.weight = 0x3f;
-	if(modify_mask & CVMX_SSO_MODIFY_GROUP_PRIORITY)
-		grp_pri.s.pri = priority;
-	if(modify_mask & CVMX_SSO_MODIFY_GROUP_WEIGHT)
-		grp_pri.s.weight = weight;
-	if(modify_mask & CVMX_SSO_MODIFY_GROUP_AFFINITY)
-		grp_pri.s.affinity = affinity;
-	cvmx_write_csr_node(node,CVMX_SSO_GRPX_PRI(xgrp.xgrp),grp_pri.u64);
-}
-
-/**
- * This function sets POW static priorities for a core. Each input queue has
- * an associated priority value.
- *
- * @param core_num   core to apply priorities to
- * @param priority   Vector of 8 priorities, one per POW Input Queue (0-7).
- *                   Highest priority is 0 and lowest is 7. A priority value
- *                   of 0xF instructs POW to skip the Input Queue when
- *                   scheduling to this specific core.
- *                   NOTE: priorities should not have gaps in values, meaning
- *                         {0,1,1,1,1,1,1,1} is a valid configuration while
- *                         {0,2,2,2,2,2,2,2} is not.
- */
-static inline void cvmx_pow_set_priority(uint64_t core_num, const uint8_t priority[])
-{
-	if (OCTEON_IS_MODEL(OCTEON_CN3XXX))
-		return;
-
-	/* Detect gaps between priorities and flag error */
-	if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		int i;
-		uint32_t prio_mask = 0;
-
-		for (i = 0; i < 8; i++)
-			if (priority[i] != 0xF)
-				prio_mask |= 1 << priority[i];
-
-		if (prio_mask ^ ((1 << cvmx_pop(prio_mask)) - 1)) {
-			cvmx_dprintf("ERROR: POW static priorities should be contiguous (0x%llx)\n", (unsigned long long)prio_mask);
-			return;
-		}
-	}
-
-	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		unsigned group;
-		unsigned node = cvmx_get_node_num();
-		cvmx_sso_grpx_pri_t grp_pri;
+	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
+		unsigned group;
+		unsigned node = cvmx_get_node_num();
+		cvmx_sso_grpx_pri_t grp_pri;
 
 		grp_pri.s.weight = 0x3f;
 		grp_pri.s.affinity = 0xf;
@@ -3044,7 +2689,8 @@ static inline void cvmx_pow_set_priority(uint64_t core_num, const uint8_t priori
  *                 - 1 : don't schedule this work
  *                 - 0 : allow this work to be scheduled.
  */
-static inline void cvmx_pow_tag_sw_desched_nocheck(uint32_t tag, cvmx_pow_tag_type_t tag_type, uint64_t group, uint64_t no_sched)
+static inline void cvmx_pow_tag_sw_desched_nocheck(uint32_t tag,
+	cvmx_pow_tag_type_t tag_type, uint64_t group, uint64_t no_sched)
 {
 	union cvmx_pow_tag_req_addr ptr;
 	cvmx_pow_tag_req_t tag_req;
@@ -3053,12 +2699,15 @@ static inline void cvmx_pow_tag_sw_desched_nocheck(uint32_t tag, cvmx_pow_tag_ty
 		cvmx_pow_tag_info_t current_tag;
 		__cvmx_pow_warn_if_pending_switch(__func__);
 		current_tag = cvmx_pow_get_current_tag();
-		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL, "%s called with NULL_NULL tag\n", __func__);
-		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL, "%s called with NULL tag. Deschedule not allowed from NULL state\n", __func__);
-		cvmx_warn_if((current_tag.tag_type != CVMX_POW_TAG_TYPE_ATOMIC)
-			     && (tag_type != CVMX_POW_TAG_TYPE_ATOMIC), "%s called where neither the before or after tag is ATOMIC\n", __func__);
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL,
+			"%s called with NULL_NULL tag\n", __func__);
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL,
+			"%s called with NULL tag. Deschedule not allowed from NULL state\n",
+			__func__);
+		cvmx_warn_if((current_tag.tag_type != CVMX_POW_TAG_TYPE_ATOMIC) &&
+			(tag_type != CVMX_POW_TAG_TYPE_ATOMIC),
+			"%s called where neither the before or after tag is ATOMIC\n", __func__);
 	}
-
 	tag_req.u64 = 0;
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_t *wqp = cvmx_pow_get_current_wqp();
@@ -3091,7 +2740,6 @@ static inline void cvmx_pow_tag_sw_desched_nocheck(uint32_t tag, cvmx_pow_tag_ty
 		tag_req.s_cn38xx.grp = group;
 		tag_req.s_cn38xx.no_sched = no_sched;
 	}
-
 	ptr.u64 = 0;
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		ptr.s.mem_region = CVMX_IO_SEG;
@@ -3104,7 +2752,7 @@ static inline void cvmx_pow_tag_sw_desched_nocheck(uint32_t tag, cvmx_pow_tag_ty
 		ptr.s.is_io = 1;
 		ptr.s.did = CVMX_OCT_DID_TAG_TAG3;
 	}
-	cvmx_write_io(ptr.u64, tag_req.u64);	/* since TAG3 is used, this store will clear the local pending switch bit */
+	cvmx_write_io(ptr.u64, tag_req.u64);
 }
 
 /**
@@ -3148,88 +2796,58 @@ static inline void cvmx_pow_tag_sw_desched_nocheck(uint32_t tag, cvmx_pow_tag_ty
  *                 - 1 : don't schedule this work
  *                 - 0 : allow this work to be scheduled.
  */
-static inline void cvmx_pow_tag_sw_desched(uint32_t tag, cvmx_pow_tag_type_t tag_type, uint64_t group, uint64_t no_sched)
+static inline void cvmx_pow_tag_sw_desched(uint32_t tag,
+	cvmx_pow_tag_type_t tag_type, uint64_t group, uint64_t no_sched)
 {
-	if (CVMX_ENABLE_POW_CHECKS)
-		__cvmx_pow_warn_if_pending_switch(__func__);
-
 	/* Need to make sure any writes to the work queue entry are complete */
 	CVMX_SYNCWS;
 	/* Ensure that there is not a pending tag switch, as a tag switch cannot be started
-	 ** if a previous switch is still pending.  */
+	 * if a previous switch is still pending.  */
 	cvmx_pow_tag_sw_wait();
 	cvmx_pow_tag_sw_desched_nocheck(tag, tag_type, group, no_sched);
 }
 
 /**
- * Performs a SWTAG_DESCHED SSO operation.
- * This is similar to the cvmx_pow_tag_sw_desched() function, but uses linear
- * (vs. unified group-qos) group index.
+ * Descchedules the current work queue entry.
+ *
+ * @param no_sched no schedule flag value to be set on the work queue entry.
+ *     If this is set the entry will not be rescheduled.
  */
-static inline void cvmx_pow_tag_sw_desched_node(uint32_t tag, cvmx_pow_tag_type_t tag_type, uint64_t xgrp, uint64_t no_sched, int node)
+static inline void cvmx_pow_desched(uint64_t no_sched)
 {
 	union cvmx_pow_tag_req_addr ptr;
 	cvmx_pow_tag_req_t tag_req;
-	int group;
-
-	if (CVMX_ENABLE_POW_CHECKS)
-		__cvmx_pow_warn_if_pending_switch(__func__);
-
-	/* Need to make sure any writes to the work queue entry are complete */
-	CVMX_SYNCWS;
-	/* Ensure that there is not a pending tag switch, as a tag switch cannot be started
-	 ** if a previous switch is still pending.  */
-	cvmx_pow_tag_sw_wait();
 
 	if (CVMX_ENABLE_POW_CHECKS) {
 		cvmx_pow_tag_info_t current_tag;
 		__cvmx_pow_warn_if_pending_switch(__func__);
 		current_tag = cvmx_pow_get_current_tag();
-		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL, "%s called with NULL_NULL tag\n", __func__);
-		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL, "%s called with NULL tag. Deschedule not allowed from NULL state\n", __func__);
-		cvmx_warn_if((current_tag.tag_type != CVMX_POW_TAG_TYPE_ATOMIC)
-			     && (tag_type != CVMX_POW_TAG_TYPE_ATOMIC), "%s called where neither the before or after tag is ATOMIC\n", __func__);
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL,
+			"%s called with NULL_NULL tag\n", __func__);
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL,
+			"%s called with NULL tag. Deschedule not expected from NULL state\n",
+			__func__);
 	}
-	group = xgrp;
+	/* Need to make sure any writes to the work queue entry are complete */
+	CVMX_SYNCWS;
+
 	tag_req.u64 = 0;
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		cvmx_wqe_t *wqp = cvmx_pow_get_current_wqp();
-		if (wqp == NULL) {
-			cvmx_dprintf("ERROR: Failed to get WQE, %s\n", __func__);
-			return;
-		}
-		group &= 0xff;
-		wqp->word1.cn78xx.tag = tag;
-		wqp->word1.cn78xx.tag_type = tag_type;
-		wqp->word1.cn78xx.grp = group;
-		CVMX_SYNCWS;
-		tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_SWTAG_DESCH;
-		tag_req.s_cn78xx_other.type = tag_type;
-		tag_req.s_cn78xx_other.grp = group;
+		tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_DESCH;
 		tag_req.s_cn78xx_other.no_sched = no_sched;
-	}
-	else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE)) {
-		group &= 0x3f;
-		tag_req.s_cn68xx_other.op = CVMX_POW_TAG_OP_SWTAG_DESCH;
-		tag_req.s_cn68xx_other.tag = tag;
-		tag_req.s_cn68xx_other.type = tag_type;
-		tag_req.s_cn68xx_other.grp = group;
+	} else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE)) {
+		tag_req.s_cn68xx_other.op = CVMX_POW_TAG_OP_DESCH;
 		tag_req.s_cn68xx_other.no_sched = no_sched;
 	} else {
-		group &= 0x0f;
-		tag_req.s_cn38xx.op = CVMX_POW_TAG_OP_SWTAG_DESCH;
-		tag_req.s_cn38xx.tag = tag;
-		tag_req.s_cn38xx.type = tag_type;
-		tag_req.s_cn38xx.grp = group;
+		tag_req.s_cn38xx.op = CVMX_POW_TAG_OP_DESCH;
 		tag_req.s_cn38xx.no_sched = no_sched;
 	}
 	ptr.u64 = 0;
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		ptr.s.mem_region = CVMX_IO_SEG;
-		ptr.s.is_io = 1;
-		ptr.s.did = CVMX_OCT_DID_TAG_TAG3;
-		ptr.s_cn78xx.node =  node;
-		ptr.s_cn78xx.tag  = tag;
+		ptr.s_cn78xx.mem_region = CVMX_IO_SEG;
+		ptr.s_cn78xx.is_io = 1;
+		ptr.s_cn78xx.did = CVMX_OCT_DID_TAG_TAG3;
+		ptr.s_cn78xx.node = cvmx_get_node_num();
 	} else {
 		ptr.s.mem_region = CVMX_IO_SEG;
 		ptr.s.is_io = 1;
@@ -3237,60 +2855,482 @@ static inline void cvmx_pow_tag_sw_desched_node(uint32_t tag, cvmx_pow_tag_type_
 	}
 	cvmx_write_io(ptr.u64, tag_req.u64);
 }
+/******************************************************************************/
+/* OCTEON3-specific functions.                                                */
+/******************************************************************************/
+/**
+ * This function sets the the affinity of group to the cores in 78xx.
+ * It sets up all the cores in core_mask to accept work from the specified group.
+ *
+ * @param xgrp  	Group to accept work from, 0 - 255.
+ * @param core_mask	Mask of all the cores which will accept work from this group
+ * @param mask_set	Every core has set of 2 masks which can be set to accept work
+ *     from 256 groups. At the time of get_work, cores can choose which mask_set
+ *     to get work from. 'mask_set' values range from 0 to 3, where	each of the
+ *     two bits represents a mask set. Cores will be added to the mask set with
+ *     corresponding bit set, and removed from the mask set with corresponding
+ *     bit clear.
+ * Note: cores can only accept work from SSO groups on the same node,
+ * so the node number for the group is derived from the core number.
+ */
+static inline void cvmx_sso_set_group_core_affinity(cvmx_xgrp_t xgrp,
+		const cvmx_coremask_t * core_mask, uint8_t mask_set)
+{
+	cvmx_sso_ppx_sx_grpmskx_t grp_msk;
+	int core;
+	int grp_index = xgrp.xgrp >> 6;
+	int bit_pos = xgrp.xgrp % 64;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
+		cvmx_dprintf( "ERROR: %s is not supported on this chip)\n", __FUNCTION__);
+		return;
+	}
+	cvmx_coremask_for_each_core(core, core_mask) {
+		unsigned node, ncore;
+		uint64_t reg_addr;
+
+		node = cvmx_coremask_core_to_node(core);
+		ncore = cvmx_coremask_core_on_node(core);
+
+		reg_addr = CVMX_SSO_PPX_SX_GRPMSKX(ncore, 0, grp_index);
+		grp_msk.u64 = cvmx_read_csr_node(node, reg_addr);
+
+		if(mask_set & 1)
+			grp_msk.s.grp_msk |= (1ull << bit_pos);
+		else
+			grp_msk.s.grp_msk &= ~(1ull << bit_pos);
+
+		cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
+
+		reg_addr = CVMX_SSO_PPX_SX_GRPMSKX(ncore, 1, grp_index);
+		grp_msk.u64 = cvmx_read_csr_node(node, reg_addr);
+
+		if(mask_set & 2)
+			grp_msk.s.grp_msk |= (1ull << bit_pos);
+		else
+			grp_msk.s.grp_msk &= ~(1ull << bit_pos);
+
+		cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
+	}
+}
 
 /**
- * Descchedules the current work queue entry.
+ * This function sets the priority and group affinity arbitration for each group.
  *
- * @param no_sched no schedule flag value to be set on the work queue entry.  If this is set
- *                 the entry will not be rescheduled.
+ * @param node 		Node number
+ * @param xgrp  	Group 0 - 255 to apply mask parameters to
+ * @param priority	Priority of the group relative to other groups
+ *     0x0 - highest priority
+ *     0x7 - lowest priority
+ * @param weight	Cross-group arbitration weight to apply to this group.
+ *     valid values are 1-63
+ *     h/w default is 0x3f
+ * @param affinity	Processor affinity arbitration weight to apply to this group.
+ *     If zero, affinity is disabled.
+ *     valid values are 0-15
+ *     h/w default which is 0xf.
+ * @param modify_mask   mask of the parameters which needs to be modified.
+ *     enum cvmx_sso_group_modify_mask
+ *     to modify only priority -- set bit0
+ *     to modify only weight   -- set bit1
+ *     to modify only affinity -- set bit2
  */
-static inline void cvmx_pow_desched(uint64_t no_sched)
+static inline void cvmx_sso_set_group_priority(int node, cvmx_xgrp_t xgrp,
+			int priority, int weight, int affinity,
+		       enum cvmx_sso_group_modify_mask modify_mask)
+{
+	cvmx_sso_grpx_pri_t grp_pri;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
+		cvmx_dprintf(
+			"ERROR: %s is not supported on this chip)\n",
+			__FUNCTION__);
+		return;
+	}
+	if (weight <= 0)
+		weight = 0x3f;	/* Force HW default when out of range */
+
+	grp_pri.u64 = cvmx_read_csr_node(node, CVMX_SSO_GRPX_PRI(xgrp.xgrp));
+	if(grp_pri.s.weight == 0)
+		grp_pri.s.weight = 0x3f;
+	if(modify_mask & CVMX_SSO_MODIFY_GROUP_PRIORITY)
+		grp_pri.s.pri = priority;
+	if(modify_mask & CVMX_SSO_MODIFY_GROUP_WEIGHT)
+		grp_pri.s.weight = weight;
+	if(modify_mask & CVMX_SSO_MODIFY_GROUP_AFFINITY)
+		grp_pri.s.affinity = affinity;
+	cvmx_write_csr_node(node,CVMX_SSO_GRPX_PRI(xgrp.xgrp),grp_pri.u64);
+}
+
+/**
+ * Asynchronous work request.
+ * Only works on CN78XX style SSO.
+ *
+ * Work is requested from the SSO unit, and should later be checked with
+ * function cvmx_pow_work_response_async.
+ * This function does NOT wait for previous tag switches to complete,
+ * so the caller must ensure that there is not a pending tag switch.
+ *
+ * @param scr_addr Scratch memory address that response will be returned to,
+ *     which is either a valid WQE, or a response with the invalid bit set.
+ *     Byte address, must be 8 byte aligned.
+ * @param xgrp  Group to receive work for (0-255).
+ * @param wait
+ *     1 to cause response to wait for work to become available (or timeout)
+ *     0 to cause response to return immediately
+ */
+static inline void cvmx_sso_work_request_grp_async_nocheck(int scr_addr,
+	cvmx_xgrp_t xgrp, cvmx_pow_wait_t wait)
+{
+	cvmx_pow_iobdma_store_t data;
+	unsigned int node = cvmx_get_node_num();
+	if (CVMX_ENABLE_POW_CHECKS) {
+		__cvmx_pow_warn_if_pending_switch(__func__);
+		cvmx_warn_if(!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE), "Not CN78XX");
+	}
+	/* scr_addr must be 8 byte aligned */
+	data.u64 = 0;
+	data.s_cn78xx.scraddr = scr_addr >> 3;
+	data.s_cn78xx.len = 1;
+	data.s_cn78xx.did = CVMX_OCT_DID_TAG_SWTAG;
+	data.s_cn78xx.grouped = 1;
+	data.s_cn78xx.index_grp_mask = (node << 8) | xgrp.xgrp ;
+	data.s_cn78xx.wait = wait;
+	data.s_cn78xx.node = node;
+
+	cvmx_send_single(data.u64);
+}
+
+/**
+ * Synchronous work request from the node-local SSO without verifying
+ * pending tag switch. It requests work from a specific SSO group.
+ *
+ * @param lgrp The local group number (within the SSO of the node of the caller)
+ *     from which to get the work.
+ * @param wait When set, call stalls until work becomes avaiable, or times out.
+ *     If not set, returns immediately.
+ *
+ * @return Returns the WQE pointer from SSO.
+ *     Returns NULL if no work was available.
+ */
+static inline void *cvmx_sso_work_request_grp_sync_nocheck(unsigned int lgrp,
+	cvmx_pow_wait_t wait)
+{
+	cvmx_pow_load_addr_t ptr;
+	cvmx_pow_tag_load_resp_t result;
+	unsigned int node = cvmx_get_node_num() & 3;
+
+	if (CVMX_ENABLE_POW_CHECKS) {
+		__cvmx_pow_warn_if_pending_switch(__func__);
+		cvmx_warn_if(!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE), "Not CN78XX");
+	}
+	ptr.u64 = 0;
+	ptr.swork_78xx.mem_region = CVMX_IO_SEG;
+	ptr.swork_78xx.is_io = 1;
+	ptr.swork_78xx.did = CVMX_OCT_DID_TAG_SWTAG;
+	ptr.swork_78xx.node = node;
+	ptr.swork_78xx.grouped = 1;
+	ptr.swork_78xx.index = (lgrp & 0xff) | node << 8;
+	ptr.swork_78xx.wait = wait;
+
+	result.u64 = cvmx_read_csr(ptr.u64);
+	if (result.s_work.no_work)
+		return NULL;
+	else
+		return cvmx_phys_to_ptr(result.s_work.addr);
+}
+
+/**
+ * Synchronous work request from the node-local SSO.
+ * It requests work from a specific SSO group.
+ * This function waits for any previous tag switch to complete before
+ * requesting the new work.
+ *
+ * @param lgrp The node-local group number from which to get the work.
+ * @param wait When set, call stalls until work becomes avaiable, or times out.
+ *     If not set, returns immediately.
+ *
+ * @return The WQE pointer or NULL, if work is not available.
+ */
+static inline void *cvmx_sso_work_request_grp_sync(unsigned int lgrp,
+	cvmx_pow_wait_t wait)
+{
+	cvmx_pow_tag_sw_wait();
+	return cvmx_sso_work_request_grp_sync_nocheck(lgrp, wait);
+}
+
+/**
+ * This function sets the group mask for a core.  The group mask bits
+ * indicate which groups each core will accept work from.
+ *
+ * @param core_num 	Processor core to apply mask to.
+ * @param mask_set	7XXX has 2 sets of masks per core.
+ *     Bit 0 represents the first mask set, bit 1 -- the second.
+ * @param xgrp_mask	Group mask array.
+ *     Total number of groups is divided into a number of
+ *     64-bits mask sets. Each bit in the mask, if set, enables
+ *     the core to accept work from the corresponding group.
+ *
+ * NOTE: Each core can be configured to accept work in accordance to both
+ * mask sets, with the first having higher precedence over the second,
+ * or to accept work in accordance to just one of the two mask sets.
+ * The 'core_num' argument represents a processor core on any node
+ * in a coherent multi-chip system.
+ */
+static inline void cvmx_pow_set_xgrp_mask( uint64_t core_num,
+		uint8_t mask_set, const uint64_t xgrp_mask[])
+{
+	cvmx_sso_ppx_sx_grpmskx_t grp_msk;
+	unsigned grp, node, core;
+	uint64_t reg_addr;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
+		cvmx_dprintf( "ERROR: %s is not supported on this chip)\n",
+			__FUNCTION__);
+		return;
+	}
+	node = cvmx_coremask_core_to_node(core_num);
+	core = cvmx_coremask_core_on_node(core_num);
+
+	for (grp = 0; grp < (cvmx_sso_num_xgrp() >> 6); grp++) {
+		reg_addr = CVMX_SSO_PPX_SX_GRPMSKX(core, 0, grp),
+		grp_msk.u64 = 0;
+		if (mask_set & 1)
+			grp_msk.s.grp_msk = xgrp_mask[grp];
+		cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
+
+		reg_addr = CVMX_SSO_PPX_SX_GRPMSKX(core, 1, grp),
+		grp_msk.u64 = 0;
+		if (mask_set & 2)
+			grp_msk.s.grp_msk = xgrp_mask[grp];
+		cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
+	}
+}
+
+/**
+ * Executes SSO SWTAG command.
+ * This is similiar to cvmx_pow_tag_sw() function, but uses linear
+ * (vs. integrated group-qos) group index.
+ */
+static inline void cvmx_pow_tag_sw_node(cvmx_wqe_t *wqp, uint32_t tag,
+	cvmx_pow_tag_type_t tag_type, int node)
 {
 	union cvmx_pow_tag_req_addr ptr;
 	cvmx_pow_tag_req_t tag_req;
 
+	if (cvmx_unlikely(!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))) {
+		cvmx_dprintf("ERROR: %s is suppored on OCTEON3 only\n", __func__);
+		return;
+	}
+	CVMX_SYNCWS;
+	cvmx_pow_tag_sw_wait();
+
 	if (CVMX_ENABLE_POW_CHECKS) {
 		cvmx_pow_tag_info_t current_tag;
 		__cvmx_pow_warn_if_pending_switch(__func__);
 		current_tag = cvmx_pow_get_current_tag();
-		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL, "%s called with NULL_NULL tag\n", __func__);
-		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL, "%s called with NULL tag. Deschedule not expected from NULL state\n", __func__);
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL,
+			"%s called with NULL_NULL tag\n", __func__);
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL,
+			"%s called with NULL tag\n", __func__);
+		cvmx_warn_if((current_tag.tag_type == tag_type) && (current_tag.tag == tag),
+			"%s called to perform a tag switch to the same tag\n", __func__);
+		cvmx_warn_if(tag_type == CVMX_POW_TAG_TYPE_NULL,
+			"%s called to perform a tag switch to NULL. "
+			"Use cvmx_pow_tag_sw_null() instead\n", __func__);
 	}
-
-	/* Need to make sure any writes to the work queue entry are complete */
+	wqp->word1.cn78xx.tag = tag;
+	wqp->word1.cn78xx.tag_type = tag_type;
 	CVMX_SYNCWS;
 
 	tag_req.u64 = 0;
-	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_DESCH;
-		tag_req.s_cn78xx_other.no_sched = no_sched;
-	} else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE)) {
-		tag_req.s_cn68xx_other.op = CVMX_POW_TAG_OP_DESCH;
-		tag_req.s_cn68xx_other.no_sched = no_sched;
-	} else {
-		tag_req.s_cn38xx.op = CVMX_POW_TAG_OP_DESCH;
-		tag_req.s_cn38xx.no_sched = no_sched;
+	tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_SWTAG;
+	tag_req.s_cn78xx_other.type = tag_type;
+
+	ptr.u64 = 0;
+	ptr.s_cn78xx.mem_region = CVMX_IO_SEG;
+	ptr.s_cn78xx.is_io = 1;
+	ptr.s_cn78xx.did = CVMX_OCT_DID_TAG_SWTAG;
+	ptr.s_cn78xx.node = node;
+	ptr.s_cn78xx.tag  = tag;
+	cvmx_write_io(ptr.u64, tag_req.u64);
+}
+
+/**
+ * Executes SSO SWTAG_FULL command.
+ * This is similiar to cvmx_pow_tag_sw_full() function, but
+ * uses linear (vs. integrated group-qos) group index.
+ */
+static inline void cvmx_pow_tag_sw_full_node(cvmx_wqe_t * wqp, uint32_t tag,
+	cvmx_pow_tag_type_t tag_type, uint8_t xgrp, int node)
+{
+	union cvmx_pow_tag_req_addr ptr;
+	cvmx_pow_tag_req_t tag_req;
+	uint16_t gxgrp;
+
+	if (cvmx_unlikely(!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))) {
+		cvmx_dprintf("ERROR: %s is suppored on OCTEON3 only\n", __func__);
+		return;
+	}
+	/* Ensure that there is not a pending tag switch, as a tag switch cannot be
+ 	 * started, if a previous switch is still pending. */
+	CVMX_SYNCWS;
+	cvmx_pow_tag_sw_wait();
+
+	if (CVMX_ENABLE_POW_CHECKS) {
+		cvmx_pow_tag_info_t current_tag;
+		__cvmx_pow_warn_if_pending_switch(__func__);
+		current_tag = cvmx_pow_get_current_tag();
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL,
+			"%s called with NULL_NULL tag\n", __func__);
+		cvmx_warn_if((current_tag.tag_type == tag_type) && (current_tag.tag == tag),
+			"%s called to perform a tag switch to the same tag\n", __func__);
+		cvmx_warn_if(tag_type == CVMX_POW_TAG_TYPE_NULL,
+			"%s called to perform a tag switch to NULL. "
+			"Use cvmx_pow_tag_sw_null() instead\n", __func__);
+		if ((wqp != cvmx_phys_to_ptr(0x80)) && cvmx_pow_get_current_wqp())
+			cvmx_warn_if(wqp != cvmx_pow_get_current_wqp(),
+				"%s passed WQE(%p) doesn't match the address in the POW(%p)\n",
+				__func__, wqp, cvmx_pow_get_current_wqp());
 	}
+	gxgrp = node;
+	gxgrp = gxgrp << 8 | xgrp;
+	wqp->word1.cn78xx.grp = gxgrp;
+	wqp->word1.cn78xx.tag = tag;
+	wqp->word1.cn78xx.tag_type = tag_type;
+	CVMX_SYNCWS;
+
+	tag_req.u64 = 0;
+	tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_SWTAG_FULL;
+	tag_req.s_cn78xx_other.type = tag_type;
+	tag_req.s_cn78xx_other.grp = xgrp;
+	tag_req.s_cn78xx_other.wqp = cvmx_ptr_to_phys(wqp);
 
 	ptr.u64 = 0;
-	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		ptr.s_cn78xx.mem_region = CVMX_IO_SEG;
-		ptr.s_cn78xx.is_io = 1;
-		ptr.s_cn78xx.did = CVMX_OCT_DID_TAG_TAG3;
-		ptr.s_cn78xx.node = cvmx_get_node_num();
-	} else {
-		ptr.s.mem_region = CVMX_IO_SEG;
-		ptr.s.is_io = 1;
-		ptr.s.did = CVMX_OCT_DID_TAG_TAG3;
+	ptr.s_cn78xx.mem_region = CVMX_IO_SEG;
+	ptr.s_cn78xx.is_io = 1;
+	ptr.s_cn78xx.did = CVMX_OCT_DID_TAG_SWTAG;
+	ptr.s_cn78xx.node = node;
+	ptr.s_cn78xx.tag  = tag;
+	cvmx_write_io(ptr.u64, tag_req.u64);
+}
+
+/**
+ * Submits work to an SSO group on any OCI node.
+ * This function updates the work queue entry in DRAM to match
+ * the arguments given.
+ * Note that the tag provided is for the work queue entry submitted,
+ * and is unrelated to the tag that the core currently holds.
+ *
+ * @param wqp pointer to work queue entry to submit.
+ * This entry is updated to match the other parameters
+ * @param tag tag value to be assigned to work queue entry
+ * @param tag_type type of tag
+ * @param xgrp native CN78XX group in the range 0..255
+ * @param node The OCI node number for the target group
+ *
+ * When this function is called on a model prior to CN78XX, which does
+ * not support OCI nodes, the 'node' argument is ignored, and the 'xgrp'
+ * parameter is converted into 'qos' (the lower 3 bits) and 'grp' (the higher
+ * 5 bits), following the backward-compatibility scheme of translating
+ * between new and old style group numbers.
+ */
+static inline void cvmx_pow_work_submit_node(cvmx_wqe_t * wqp, uint32_t tag,
+	cvmx_pow_tag_type_t tag_type, uint8_t xgrp, uint8_t node)
+{
+	union cvmx_pow_tag_req_addr ptr;
+	cvmx_pow_tag_req_t tag_req;
+	uint16_t group;
+
+	if (cvmx_unlikely(!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))) {
+		cvmx_dprintf("ERROR: %s is suppored on OCTEON3 only\n", __func__);
+		return;
 	}
+	group = node;
+	group = group << 8 | xgrp;
+	wqp->word1.cn78xx.tag = tag;
+	wqp->word1.cn78xx.tag_type = tag_type;
+	wqp->word1.cn78xx.grp = group;
+	CVMX_SYNCWS;
+
+	tag_req.u64 = 0;
+	tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_ADDWQ;
+	tag_req.s_cn78xx_other.type = tag_type;
+	tag_req.s_cn78xx_other.wqp = cvmx_ptr_to_phys(wqp);
+	tag_req.s_cn78xx_other.grp = group;
 
-	cvmx_write_io(ptr.u64, tag_req.u64);	/* since TAG3 is used, this store will clear the local pending switch bit */
+	ptr.u64 = 0;
+	ptr.s_cn78xx.did = 0x66; //CVMX_OCT_DID_TAG_TAG6;
+	ptr.s_cn78xx.mem_region = CVMX_IO_SEG;
+	ptr.s_cn78xx.is_io = 1;
+	ptr.s_cn78xx.node = node;
+	ptr.s_cn78xx.tag = tag;
+
+	/* SYNC write to memory before the work submit.  This is necessary
+	 ** as POW may read values from DRAM at this time */
+	CVMX_SYNCWS;
+	cvmx_write_io(ptr.u64, tag_req.u64);
 }
 
-/***********************************************************************************************
-** Define usage of bits within the 32 bit tag values.
-***********************************************************************************************/
+/**
+ * Executes the SSO SWTAG_DESCHED operation.
+ * This is similar to the cvmx_pow_tag_sw_desched() function, but
+ * uses linear (vs. unified group-qos) group index.
+ */
+static inline void cvmx_pow_tag_sw_desched_node(cvmx_wqe_t *wqe, uint32_t tag,
+	cvmx_pow_tag_type_t tag_type, uint8_t xgrp, uint64_t no_sched, uint8_t node)
+{
+	union cvmx_pow_tag_req_addr ptr;
+	cvmx_pow_tag_req_t tag_req;
+	uint16_t group;
+
+	if (cvmx_unlikely(!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))) {
+		cvmx_dprintf("ERROR: %s is suppored on OCTEON3 only\n", __func__);
+		return;
+	}
+	/* Need to make sure any writes to the work queue entry are complete */
+	CVMX_SYNCWS;
+	/* Ensure that there is not a pending tag switch, as a tag switch cannot
+	 * be started if a previous switch is still pending.  */
+	cvmx_pow_tag_sw_wait();
 
+	if (CVMX_ENABLE_POW_CHECKS) {
+		cvmx_pow_tag_info_t current_tag;
+		__cvmx_pow_warn_if_pending_switch(__func__);
+		current_tag = cvmx_pow_get_current_tag();
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL_NULL,
+			"%s called with NULL_NULL tag\n", __func__);
+		cvmx_warn_if(current_tag.tag_type == CVMX_POW_TAG_TYPE_NULL,
+			"%s called with NULL tag. Deschedule not allowed from NULL state\n", __func__);
+		cvmx_warn_if((current_tag.tag_type != CVMX_POW_TAG_TYPE_ATOMIC) &&
+			(tag_type != CVMX_POW_TAG_TYPE_ATOMIC),
+			"%s called where neither the before or after tag is ATOMIC\n", __func__);
+	}
+	group = node;
+	group = group << 8 | xgrp;
+	wqe->word1.cn78xx.tag = tag;
+	wqe->word1.cn78xx.tag_type = tag_type;
+	wqe->word1.cn78xx.grp = group;
+	CVMX_SYNCWS;
+
+	tag_req.u64 = 0;
+	tag_req.s_cn78xx_other.op = CVMX_POW_TAG_OP_SWTAG_DESCH;
+	tag_req.s_cn78xx_other.type = tag_type;
+	tag_req.s_cn78xx_other.grp = group;
+	tag_req.s_cn78xx_other.no_sched = no_sched;
+
+	ptr.u64 = 0;
+	ptr.s.mem_region = CVMX_IO_SEG;
+	ptr.s.is_io = 1;
+	ptr.s.did = CVMX_OCT_DID_TAG_TAG3;
+	ptr.s_cn78xx.node =  node;
+	ptr.s_cn78xx.tag  = tag;
+	cvmx_write_io(ptr.u64, tag_req.u64);
+}
+
+/******************************************************************************/
+/* Define usage of bits within the 32 bit tag values.                         */
+/******************************************************************************/
 /*
  * Number of bits of the tag used by software.  The SW bits
  * are always a contiguous block of the high starting at bit 31.
@@ -3301,35 +3341,39 @@ static inline void cvmx_pow_desched(uint64_t no_sched)
 #define CVMX_TAG_SW_SHIFT   (32 - CVMX_TAG_SW_BITS)
 
 /* Below is the list of values for the top 8 bits of the tag. */
-#define CVMX_TAG_SW_BITS_INTERNAL  0x1	/* Tag values with top byte of this value are reserved for internal executive uses */
+/* Tag values with top byte of this value are reserved for internal executive uses */
+#define CVMX_TAG_SW_BITS_INTERNAL  0x1
+
 /* The executive divides the remaining 24 bits as follows:
-**  * the upper 8 bits (bits 23 - 16 of the tag) define a subgroup
-**  * the lower 16 bits (bits 15 - 0 of the tag) define are the value with the subgroup
-** Note that this section describes the format of tags generated by software - refer to the
-** hardware documentation for a description of the tags values generated by the packet input
-** hardware.
-** Subgroups are defined here */
-#define CVMX_TAG_SUBGROUP_MASK  0xFFFF	/* Mask for the value portion of the tag */
+* the upper 8 bits (bits 23 - 16 of the tag) define a subgroup
+* the lower 16 bits (bits 15 - 0 of the tag) define are the value with
+* the subgroup. Note that this section describes the format of tags generated
+* by software - refer to the hardware documentation for a description of the tags
+* values generated by the packet input hardware.
+* Subgroups are defined here */
+#define CVMX_TAG_SUBGROUP_MASK  0xFFFF /* Mask for the value portion of the tag */
 #define CVMX_TAG_SUBGROUP_SHIFT 16
 #define CVMX_TAG_SUBGROUP_PKO  0x1
 
 /* End of executive tag subgroup definitions */
 
-/* The remaining values software bit values 0x2 - 0xff are available for application use */
+/* The remaining values software bit values 0x2 - 0xff are available
+ * for application use */
 
 /**
  * This function creates a 32 bit tag value from the two values provided.
  *
- * @param sw_bits The upper bits (number depends on configuration) are set to this value.  The remainder of
- *                bits are set by the hw_bits parameter.
- * @param hw_bits The lower bits (number depends on configuration) are set to this value.  The remainder of
- *                bits are set by the sw_bits parameter.
+ * @param sw_bits The upper bits (number depends on configuration) are set
+ *     to this value.  The remainder of bits are set by the hw_bits parameter.
+ * @param hw_bits The lower bits (number depends on configuration) are set
+ *     to this value.  The remainder of bits are set by the sw_bits parameter.
  *
  * @return 32 bit value of the combined hw and sw bits.
  */
 static inline uint32_t cvmx_pow_tag_compose(uint64_t sw_bits, uint64_t hw_bits)
 {
-	return ((((sw_bits & cvmx_build_mask(CVMX_TAG_SW_BITS)) << CVMX_TAG_SW_SHIFT) | (hw_bits & cvmx_build_mask(32 - CVMX_TAG_SW_BITS))));
+	return ((((sw_bits & cvmx_build_mask(CVMX_TAG_SW_BITS)) << CVMX_TAG_SW_SHIFT) |
+		(hw_bits & cvmx_build_mask(32 - CVMX_TAG_SW_BITS))));
 }
 
 /**
@@ -3337,7 +3381,8 @@ static inline uint32_t cvmx_pow_tag_compose(uint64_t sw_bits, uint64_t hw_bits)
  *
  * @param tag    32 bit tag value
  *
- * @return N bit software tag value, where N is configurable with the CVMX_TAG_SW_BITS define
+ * @return N bit software tag value, where N is configurable with
+ *     the CVMX_TAG_SW_BITS define
  */
 static inline uint32_t cvmx_pow_tag_get_sw_bits(uint64_t tag)
 {
@@ -3350,7 +3395,8 @@ static inline uint32_t cvmx_pow_tag_get_sw_bits(uint64_t tag)
  *
  * @param tag    32 bit tag value
  *
- * @return (32 - N) bit software tag value, where N is configurable with the CVMX_TAG_SW_BITS define
+ * @return (32 - N) bit software tag value, where N is configurable with
+ *     the CVMX_TAG_SW_BITS define
  */
 static inline uint32_t cvmx_pow_tag_get_hw_bits(uint64_t tag)
 {
@@ -3364,8 +3410,7 @@ static inline uint64_t cvmx_sso3_get_wqe_count(int node)
 	uint64_t cnt = 0;
 
 	for( grp = 0; grp < cvmx_sso_num_xgrp(); grp++) {
-		aq_cnt.u64 = cvmx_read_csr_node(node,
-				CVMX_SSO_GRPX_AQ_CNT(grp));
+		aq_cnt.u64 = cvmx_read_csr_node(node, CVMX_SSO_GRPX_AQ_CNT(grp));
 		cnt += aq_cnt.s.aq_cnt;
 	}
 	return cnt;
@@ -3381,15 +3426,12 @@ static inline uint64_t cvmx_sso_get_total_wqe_count(void)
 	else if (OCTEON_IS_MODEL(OCTEON_CN68XX))
 	{
 		cvmx_sso_iq_com_cnt_t sso_iq_com_cnt;
-
 		sso_iq_com_cnt.u64 = cvmx_read_csr(CVMX_SSO_IQ_COM_CNT);
-
 		return (sso_iq_com_cnt.s.iq_cnt);
 	}
 	else
 	{
 		cvmx_pow_iq_com_cnt_t pow_iq_com_cnt;
-
 		pow_iq_com_cnt.u64 = cvmx_read_csr(CVMX_POW_IQ_COM_CNT);
 		return(pow_iq_com_cnt.s.iq_cnt);
 	}
@@ -3402,8 +3444,7 @@ static inline uint64_t cvmx_sso_get_total_wqe_count(void)
  * version and Octeon chip.
  *
  * @param buffer Buffer to store capture into
- * @param buffer_size
- *               The size of the supplied buffer
+ * @param buffer_size The size of the supplied buffer
  *
  * @return Zero on sucess, negative on failure
  */
@@ -3413,8 +3454,7 @@ extern int cvmx_pow_capture(void *buffer, int buffer_size);
  * Dump a POW capture to the console in a human readable format.
  *
  * @param buffer POW capture from cvmx_pow_capture()
- * @param buffer_size
- *               Size of the buffer
+ * @param buffer_size Size of the buffer
  */
 extern void cvmx_pow_display(void *buffer, int buffer_size);
 
@@ -3456,3 +3496,4 @@ int cvmx_sso_config_dump(unsigned node);
 #endif
 
 #endif /* __CVMX_POW_H__ */
+
diff --git a/arch/mips/include/asm/octeon/cvmx-rnm-defs.h b/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
index 0931303..9300840 100644
--- a/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
@@ -58,7 +58,7 @@
 #define CVMX_RNM_EER_DBG CVMX_RNM_EER_DBG_FUNC()
 static inline uint64_t CVMX_RNM_EER_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_RNM_EER_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180040000018ull);
 }
@@ -69,7 +69,7 @@ static inline uint64_t CVMX_RNM_EER_DBG_FUNC(void)
 #define CVMX_RNM_EER_KEY CVMX_RNM_EER_KEY_FUNC()
 static inline uint64_t CVMX_RNM_EER_KEY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_RNM_EER_KEY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180040000010ull);
 }
@@ -80,7 +80,7 @@ static inline uint64_t CVMX_RNM_EER_KEY_FUNC(void)
 #define CVMX_RNM_SERIAL_NUM CVMX_RNM_SERIAL_NUM_FUNC()
 static inline uint64_t CVMX_RNM_SERIAL_NUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_RNM_SERIAL_NUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180040000020ull);
 }
@@ -171,8 +171,8 @@ union cvmx_rnm_ctl_status {
                                                          bit from 1 to 0. */
 	uint64_t rng_rst                      : 1;  /**< Reset the RNG. Setting this bit to 1 cancels the generation of the current random
                                                          number. The next random number is available 730 coprocessor-clock cycles after this
-                                                         bit is cleared if EXP_ENT is set to 0. The next random number is available 80
-                                                         coprocessor-clock cycles after this bit is cleared if EXP_ENT is set to 1. This bit is
+                                                         bit is cleared if [EXP_ENT] is set to 0. The next random number is available 80
+                                                         coprocessor-clock cycles after this bit is cleared if [EXP_ENT] is set to 1. This bit is
                                                          not automatically cleared. */
 	uint64_t rnm_rst                      : 1;  /**< Reset the RNM. Setting this bit to 1 drops all RNM transactions in flight and clears
                                                          all stored numbers in the random number memory. Any outstanding NCBO credits will
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index db52341..a6f3e45 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -67,7 +67,7 @@ static inline uint64_t CVMX_RST_BIST_TIMER_FUNC(void)
 #define CVMX_RST_BOOT CVMX_RST_BOOT_FUNC()
 static inline uint64_t CVMX_RST_BOOT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_RST_BOOT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001600ull);
 }
@@ -89,7 +89,7 @@ static inline uint64_t CVMX_RST_BPHY_SOFT_RST_FUNC(void)
 #define CVMX_RST_CFG CVMX_RST_CFG_FUNC()
 static inline uint64_t CVMX_RST_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_RST_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001610ull);
 }
@@ -100,7 +100,7 @@ static inline uint64_t CVMX_RST_CFG_FUNC(void)
 #define CVMX_RST_CKILL CVMX_RST_CKILL_FUNC()
 static inline uint64_t CVMX_RST_CKILL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_RST_CKILL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001638ull);
 }
@@ -126,6 +126,7 @@ static inline uint64_t CVMX_RST_CTLX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_RST_CTLX(%lu) is invalid on this chip\n", offset);
@@ -149,7 +150,7 @@ static inline uint64_t CVMX_RST_DEBUG_FUNC(void)
 #define CVMX_RST_DELAY CVMX_RST_DELAY_FUNC()
 static inline uint64_t CVMX_RST_DELAY_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_RST_DELAY not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001608ull);
 }
@@ -171,7 +172,7 @@ static inline uint64_t CVMX_RST_ECO_FUNC(void)
 #define CVMX_RST_INT CVMX_RST_INT_FUNC()
 static inline uint64_t CVMX_RST_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_RST_INT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001628ull);
 }
@@ -193,7 +194,7 @@ static inline uint64_t CVMX_RST_INT_W1S_FUNC(void)
 #define CVMX_RST_OCX CVMX_RST_OCX_FUNC()
 static inline uint64_t CVMX_RST_OCX_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_RST_OCX not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001618ull);
 }
@@ -215,7 +216,7 @@ static inline uint64_t CVMX_RST_OUT_CTL_FUNC(void)
 #define CVMX_RST_POWER_DBG CVMX_RST_POWER_DBG_FUNC()
 static inline uint64_t CVMX_RST_POWER_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_RST_POWER_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001708ull);
 }
@@ -226,7 +227,7 @@ static inline uint64_t CVMX_RST_POWER_DBG_FUNC(void)
 #define CVMX_RST_PP_POWER CVMX_RST_PP_POWER_FUNC()
 static inline uint64_t CVMX_RST_PP_POWER_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_RST_PP_POWER not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001700ull);
 }
@@ -250,6 +251,7 @@ static inline uint64_t CVMX_RST_SOFT_PRSTX(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
 		cvmx_warn("CVMX_RST_SOFT_PRSTX(%lu) is invalid on this chip\n", offset);
@@ -262,7 +264,7 @@ static inline uint64_t CVMX_RST_SOFT_PRSTX(unsigned long offset)
 #define CVMX_RST_SOFT_RST CVMX_RST_SOFT_RST_FUNC()
 static inline uint64_t CVMX_RST_SOFT_RST_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_RST_SOFT_RST not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001180006001680ull);
 }
@@ -330,19 +332,11 @@ union cvmx_rst_boot {
                                                          automatically. */
 	uint64_t reserved_37_56               : 20;
 	uint64_t c_mul                        : 7;  /**< Core-clock multiplier. C_MUL = (core-clock speed) / (ref-clock speed). 'ref-clock speed'
-                                                         should always be 50MHz.
-                                                         INTERNAL:  C_MUL is set from the pi_pll_mul pins plus 6. */
+                                                         should always be 50MHz. */
 	uint64_t pnr_mul                      : 6;  /**< Coprocessor-clock multiplier. PNR_MUL = (coprocessor-clock speed) /(ref-clock speed).
-                                                         'ref-clock speed' should always be 50MHz.
-                                                         INTERNAL:  PNR_MUL is set from the pi_pnr_pll_mul pins plus 6. */
+                                                         'ref-clock speed' should always be 50MHz. */
 	uint64_t reserved_21_23               : 3;
-	uint64_t lboot_oci                    : 3;  /**< Reserved.
-                                                         INTERNAL: Unused in non-CCPI parts.
-                                                         Last boot cause mask; resets only with DCOK.
-                                                         Warm resets due to CCPI link 2,1,0 going down.
-                                                         <20> = Reserved.
-                                                         <19> = Reserved.
-                                                         <18> = Reserved. */
+	uint64_t lboot_oci                    : 3;  /**< Reserved. */
 	uint64_t lboot_ext                    : 6;  /**< Last boot cause mask; resets only with DCOK.
                                                          <17> = Warm reset due to Cntl3 link-down or hot-reset.
                                                          <16> = Warm reset due to Cntl2 link-down or hot-reset.
@@ -563,8 +557,8 @@ union cvmx_rst_ctlx {
                                                          When RST_RCV = 0, the PERST*_L pin value is ignored. */
 	uint64_t rst_chip                     : 1;  /**< Controls whether PERST*_L causes a chip warm reset like CHIP_RESET_L. A warm/soft reset
                                                          will not change this field. On cold reset, this field is initialized to 0.
-                                                         When RST_RCV = 0, RST_CHIP is ignored.
-                                                         When RST_RCV = 1, RST_CHIP = 1, and PERST*_L asserts, a chip warm reset is generated. */
+                                                         When [RST_RCV] = 0, [RST_CHIP] is ignored.
+                                                         When [RST_RCV] = 1, [RST_CHIP] = 1, and PERST*_L asserts, a chip warm reset is generated. */
 	uint64_t rst_val                      : 1;  /**< Read-only access to PERST*_L. Unpredictable when RST_RCV = 0.
                                                          Reads as 1 when RST_RCV is equal to 1 and the
                                                          PERST*_L pin is asserted.
@@ -789,7 +783,7 @@ union cvmx_rst_power_dbg {
 	struct cvmx_rst_power_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t str                          : 3;  /**< Reserved. INTERNAL: Internal power driver strength. Resets only on cold reset. */
+	uint64_t str                          : 3;  /**< Reserved. */
 #else
 	uint64_t str                          : 3;
 	uint64_t reserved_3_63                : 61;
@@ -935,12 +929,7 @@ union cvmx_rst_thermal_alert {
 	uint64_t reserved_9_63                : 55;
 	uint64_t trip                         : 1;  /**< This field is set by the onboard temperature sensor. For diagnostic use
                                                          only. The bit can only be cleared by a deassertion of the PLL_DC_OK pin which
-                                                         completely resets the chip.
-                                                         INTERNAL: Not committed-to in 73xx HRM.
-                                                         Thermal trip pin. When set to 1, drives the THERMAL_TRIP_N pin active low. This field is
-                                                         set by the onboard temperature sensor reaching a failure threshold or writing this bit.
-                                                         The bit can only be cleared by a deassertion of the PLL_DC_OK pin which completely resets
-                                                         the chip. */
+                                                         completely resets the chip. */
 	uint64_t reserved_1_7                 : 7;
 	uint64_t alert                        : 1;  /**< Thermal alert status. When set to 1, indicates the temperature sensor is currently at the
                                                          failure threshold. */
diff --git a/arch/mips/include/asm/octeon/cvmx-sata-defs.h b/arch/mips/include/asm/octeon/cvmx-sata-defs.h
index fef85dc..c5818bc 100644
--- a/arch/mips/include/asm/octeon/cvmx-sata-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sata-defs.h
@@ -597,8 +597,6 @@ static inline uint64_t CVMX_SATA_UCTL_SPARE1_ECO_FUNC(void)
  * This register contains the pattern definition (bits 23:16 of the
  * first DWORD) and the data pattern (bits 7:0 of the second DWORD)
  * fields of the received BIST activate FIS.
- *
- * INTERNAL: See DWC_ahsata databook v4.20a.
  */
 union cvmx_sata_uahc_gbl_bistafr {
 	uint32_t u32;
@@ -634,8 +632,7 @@ typedef union cvmx_sata_uahc_gbl_bistafr cvmx_sata_uahc_gbl_bistafr_t;
 /**
  * cvmx_sata_uahc_gbl_bistcr
  *
- * INTERNAL: See DWC_ahsata databook v4.10a
- * This register is shared between SATA ports.  Before accessing this
+ * This register is shared between SATA ports. Before accessing this
  * register, first select the required port by writing the port number
  * to the SATA_UAHC_GBL_TESTR[PSEL] field.
  */
@@ -658,9 +655,9 @@ union cvmx_sata_uahc_gbl_bistcr {
 	uint32_t sdfe                         : 1;  /**< Signal detect feature enable. */
 	uint32_t reserved_11_11               : 1;
 	uint32_t llc                          : 3;  /**< Link layer control.
-                                                         <10> = RPD - repeat primitive drop enable
-                                                         <9> = DESCRAM - descrambler enable
-                                                         <8> = SCRAM - scrambler enable */
+                                                         <10> = RPD - repeat primitive drop enable.
+                                                         <9> = DESCRAM - descrambler enable.
+                                                         <8> = SCRAM - scrambler enable. */
 	uint32_t reserved_7_7                 : 1;
 	uint32_t erren                        : 1;  /**< Error enable. */
 	uint32_t flip                         : 1;  /**< Flip disparity. */
@@ -701,8 +698,6 @@ typedef union cvmx_sata_uahc_gbl_bistcr cvmx_sata_uahc_gbl_bistcr_t;
  * This register is shared between SATA ports. Before accessing this
  * register, first select the required port by writing the port number
  * to the SATA()_UAHC_GBL_TESTR[PSEL] field.
- *
- * INTERNAL: See DWC_ahsata databook v4.20a.
  */
 union cvmx_sata_uahc_gbl_bistdecr {
 	uint32_t u32;
@@ -725,8 +720,6 @@ typedef union cvmx_sata_uahc_gbl_bistdecr cvmx_sata_uahc_gbl_bistdecr_t;
  * This register is shared between SATA ports. Before accessing this
  * register, first select the required port by writing the port number
  * to the SATA()_UAHC_GBL_TESTR[PSEL] field.
- *
- * INTERNAL: See DWC_ahsata databook v4.20a.
  */
 union cvmx_sata_uahc_gbl_bistfctr {
 	uint32_t u32;
@@ -745,9 +738,6 @@ typedef union cvmx_sata_uahc_gbl_bistfctr cvmx_sata_uahc_gbl_bistfctr_t;
 
 /**
  * cvmx_sata_uahc_gbl_bistsr
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_gbl_bistsr {
 	uint32_t u32;
@@ -832,7 +822,7 @@ typedef union cvmx_sata_uahc_gbl_cap cvmx_sata_uahc_gbl_cap_t;
 /**
  * cvmx_sata_uahc_gbl_cap2
  *
- * See AHCI specification v1.3 section 3.1
+ * See AHCI specification v1.3 section 3.1.
  *
  */
 union cvmx_sata_uahc_gbl_cap2 {
@@ -865,7 +855,7 @@ typedef union cvmx_sata_uahc_gbl_cap2 cvmx_sata_uahc_gbl_cap2_t;
 /**
  * cvmx_sata_uahc_gbl_ccc_ctl
  *
- * See AHCI specification v1.3 section 3.1
+ * See AHCI specification v1.3 section 3.1.
  *
  */
 union cvmx_sata_uahc_gbl_ccc_ctl {
@@ -894,7 +884,7 @@ typedef union cvmx_sata_uahc_gbl_ccc_ctl cvmx_sata_uahc_gbl_ccc_ctl_t;
 /**
  * cvmx_sata_uahc_gbl_ccc_ports
  *
- * See AHCI specification v1.3 section 3.1
+ * See AHCI specification v1.3 section 3.1.
  *
  */
 union cvmx_sata_uahc_gbl_ccc_ports {
@@ -917,7 +907,7 @@ typedef union cvmx_sata_uahc_gbl_ccc_ports cvmx_sata_uahc_gbl_ccc_ports_t;
 /**
  * cvmx_sata_uahc_gbl_ghc
  *
- * See AHCI specification v1.3 section 3.1
+ * See AHCI specification v1.3 section 3.1.
  *
  */
 union cvmx_sata_uahc_gbl_ghc {
@@ -943,9 +933,6 @@ typedef union cvmx_sata_uahc_gbl_ghc cvmx_sata_uahc_gbl_ghc_t;
 
 /**
  * cvmx_sata_uahc_gbl_gparam1r
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_gbl_gparam1r {
 	uint32_t u32;
@@ -990,9 +977,6 @@ typedef union cvmx_sata_uahc_gbl_gparam1r cvmx_sata_uahc_gbl_gparam1r_t;
 
 /**
  * cvmx_sata_uahc_gbl_gparam2r
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_gbl_gparam2r {
 	uint32_t u32;
@@ -1097,9 +1081,6 @@ typedef union cvmx_sata_uahc_gbl_gparam2r cvmx_sata_uahc_gbl_gparam2r_t;
 
 /**
  * cvmx_sata_uahc_gbl_idr
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_gbl_idr {
 	uint32_t u32;
@@ -1119,7 +1100,7 @@ typedef union cvmx_sata_uahc_gbl_idr cvmx_sata_uahc_gbl_idr_t;
 /**
  * cvmx_sata_uahc_gbl_is
  *
- * See AHCI specification v1.3 section 3.1
+ * See AHCI specification v1.3 section 3.1.
  *
  */
 union cvmx_sata_uahc_gbl_is {
@@ -1142,8 +1123,7 @@ typedef union cvmx_sata_uahc_gbl_is cvmx_sata_uahc_gbl_is_t;
 /**
  * cvmx_sata_uahc_gbl_oobr
  *
- * INTERNAL: See DWC_ahsata databook v4.10a
- * This register is shared between SATA ports.  Before accessing this
+ * This register is shared between SATA ports. Before accessing this
  * register, first select the required port by writing the port number
  * to the SATA_UAHC_GBL_TESTR[PSEL] field.
  */
@@ -1173,7 +1153,7 @@ typedef union cvmx_sata_uahc_gbl_oobr cvmx_sata_uahc_gbl_oobr_t;
 /**
  * cvmx_sata_uahc_gbl_pi
  *
- * See AHCI specification v1.3 section 3.1
+ * See AHCI specification v1.3 section 3.1.
  *
  */
 union cvmx_sata_uahc_gbl_pi {
@@ -1197,7 +1177,7 @@ typedef union cvmx_sata_uahc_gbl_pi cvmx_sata_uahc_gbl_pi_t;
  * cvmx_sata_uahc_gbl_pparamr
  *
  * Port is selected by the SATA_UAHC_GBL_TESTR[PSEL] field.
- * INTERNAL: See DWC_ahsata databook v4.10a
+ *
  */
 union cvmx_sata_uahc_gbl_pparamr {
 	uint32_t u32;
@@ -1228,9 +1208,6 @@ typedef union cvmx_sata_uahc_gbl_pparamr cvmx_sata_uahc_gbl_pparamr_t;
 
 /**
  * cvmx_sata_uahc_gbl_testr
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_gbl_testr {
 	uint32_t u32;
@@ -1239,8 +1216,8 @@ union cvmx_sata_uahc_gbl_testr {
 	uint32_t reserved_25_31               : 7;
 	uint32_t bsel                         : 1;  /**< This field is used to select a bank for BIST or Data Protection
                                                          operation. The options for this field are:
-                                                         0x0 - BIST registers selected
-                                                         0x1 - Data Protection registers selected */
+                                                         0x0 = BIST registers selected.
+                                                         0x1 = Data Protection registers selected. */
 	uint32_t reserved_19_23               : 5;
 	uint32_t psel                         : 3;  /**< Port select. */
 	uint32_t reserved_1_15                : 15;
@@ -1274,9 +1251,6 @@ typedef union cvmx_sata_uahc_gbl_testr cvmx_sata_uahc_gbl_testr_t;
 
 /**
  * cvmx_sata_uahc_gbl_timer1ms
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_gbl_timer1ms {
 	uint32_t u32;
@@ -1297,9 +1271,6 @@ typedef union cvmx_sata_uahc_gbl_timer1ms cvmx_sata_uahc_gbl_timer1ms_t;
 
 /**
  * cvmx_sata_uahc_gbl_versionr
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_gbl_versionr {
 	uint32_t u32;
@@ -1319,7 +1290,7 @@ typedef union cvmx_sata_uahc_gbl_versionr cvmx_sata_uahc_gbl_versionr_t;
 /**
  * cvmx_sata_uahc_gbl_vs
  *
- * See AHCI specification v1.3 section 3.1
+ * See AHCI specification v1.3 section 3.1.
  *
  */
 union cvmx_sata_uahc_gbl_vs {
@@ -1341,9 +1312,6 @@ typedef union cvmx_sata_uahc_gbl_vs cvmx_sata_uahc_gbl_vs_t;
 
 /**
  * cvmx_sata_uahc_p#_ci
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_ci {
 	uint32_t u32;
@@ -1362,9 +1330,6 @@ typedef union cvmx_sata_uahc_px_ci cvmx_sata_uahc_px_ci_t;
 
 /**
  * cvmx_sata_uahc_p#_clb
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_clb {
 	uint64_t u64;
@@ -1385,9 +1350,6 @@ typedef union cvmx_sata_uahc_px_clb cvmx_sata_uahc_px_clb_t;
 
 /**
  * cvmx_sata_uahc_p#_cmd
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_cmd {
 	uint32_t u32;
@@ -1414,8 +1376,8 @@ union cvmx_sata_uahc_px_cmd {
 	uint32_t fre                          : 1;  /**< FIS-receive enable. */
 	uint32_t clo                          : 1;  /**< Command-list override. */
 	uint32_t pod                          : 1;  /**< Power-on device. R/W only if CPD = 1, else read only. */
-	uint32_t sud                          : 1;  /**< Spin-up device. R/W only if SATA_UAHC_GBL_CAP[SSS] = 1, else read only. Setting this bit
-                                                         triggers a COMRESET initialization sequence. */
+	uint32_t sud                          : 1;  /**< Spin-up device. R/W only if SATA_UAHC_GBL_CAP[SSS]=1, else read only.
+                                                         Setting this bit triggers a COMRESET initialization sequence. */
 	uint32_t st                           : 1;  /**< Start. */
 #else
 	uint32_t st                           : 1;
@@ -1451,9 +1413,6 @@ typedef union cvmx_sata_uahc_px_cmd cvmx_sata_uahc_px_cmd_t;
 
 /**
  * cvmx_sata_uahc_p#_dmacr
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_dmacr {
 	uint32_t u32;
@@ -1478,9 +1437,6 @@ typedef union cvmx_sata_uahc_px_dmacr cvmx_sata_uahc_px_dmacr_t;
 
 /**
  * cvmx_sata_uahc_p#_fb
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_fb {
 	uint64_t u64;
@@ -1501,9 +1457,6 @@ typedef union cvmx_sata_uahc_px_fb cvmx_sata_uahc_px_fb_t;
 
 /**
  * cvmx_sata_uahc_p#_fbs
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_fbs {
 	uint32_t u32;
@@ -1536,9 +1489,6 @@ typedef union cvmx_sata_uahc_px_fbs cvmx_sata_uahc_px_fbs_t;
 
 /**
  * cvmx_sata_uahc_p#_ie
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_ie {
 	uint32_t u32;
@@ -1593,9 +1543,6 @@ typedef union cvmx_sata_uahc_px_ie cvmx_sata_uahc_px_ie_t;
 
 /**
  * cvmx_sata_uahc_p#_is
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_is {
 	uint32_t u32;
@@ -1650,9 +1597,6 @@ typedef union cvmx_sata_uahc_px_is cvmx_sata_uahc_px_is_t;
 
 /**
  * cvmx_sata_uahc_p#_phycr
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_phycr {
 	uint32_t u32;
@@ -1671,9 +1615,6 @@ typedef union cvmx_sata_uahc_px_phycr cvmx_sata_uahc_px_phycr_t;
 
 /**
  * cvmx_sata_uahc_p#_physr
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_physr {
 	uint32_t u32;
@@ -1692,9 +1633,6 @@ typedef union cvmx_sata_uahc_px_physr cvmx_sata_uahc_px_physr_t;
 
 /**
  * cvmx_sata_uahc_p#_sact
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_sact {
 	uint32_t u32;
@@ -1713,9 +1651,6 @@ typedef union cvmx_sata_uahc_px_sact cvmx_sata_uahc_px_sact_t;
 
 /**
  * cvmx_sata_uahc_p#_sctl
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_sctl {
 	uint32_t u32;
@@ -1744,9 +1679,6 @@ typedef union cvmx_sata_uahc_px_sctl cvmx_sata_uahc_px_sctl_t;
 
 /**
  * cvmx_sata_uahc_p#_serr
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_serr {
 	uint32_t u32;
@@ -1803,9 +1735,6 @@ typedef union cvmx_sata_uahc_px_serr cvmx_sata_uahc_px_serr_t;
 
 /**
  * cvmx_sata_uahc_p#_sig
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_sig {
 	uint32_t u32;
@@ -1824,9 +1753,6 @@ typedef union cvmx_sata_uahc_px_sig cvmx_sata_uahc_px_sig_t;
 
 /**
  * cvmx_sata_uahc_p#_sntf
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_sntf {
 	uint32_t u32;
@@ -1847,9 +1773,6 @@ typedef union cvmx_sata_uahc_px_sntf cvmx_sata_uahc_px_sntf_t;
 
 /**
  * cvmx_sata_uahc_p#_ssts
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_ssts {
 	uint32_t u32;
@@ -1874,9 +1797,6 @@ typedef union cvmx_sata_uahc_px_ssts cvmx_sata_uahc_px_ssts_t;
 
 /**
  * cvmx_sata_uahc_p#_tfd
- *
- * INTERNAL: See DWC_ahsata databook v4.10a
- *
  */
 union cvmx_sata_uahc_px_tfd {
 	uint32_t u32;
@@ -1900,10 +1820,12 @@ typedef union cvmx_sata_uahc_px_tfd cvmx_sata_uahc_px_tfd_t;
 /**
  * cvmx_sata_uctl_bist_status
  *
- * Accessible by: always
- * Reset by: IOI reset (srst_n)
  * Results from BIST runs of SATA's memories.
  * Wait for NDONE==0, then look at defect indication.
+ *
+ * Accessible always.
+ *
+ * Reset by IOI reset.
  */
 union cvmx_sata_uctl_bist_status {
 	uint64_t u64;
@@ -1953,9 +1875,11 @@ typedef union cvmx_sata_uctl_bist_status cvmx_sata_uctl_bist_status_t;
 /**
  * cvmx_sata_uctl_ctl
  *
- * Accessible by: always
- * Reset by: IOI reset (srst_n)
  * This register controls clocks, resets, power, and BIST for the SATA.
+ *
+ * Accessible always.
+ *
+ * Reset by IOI reset.
  */
 union cvmx_sata_uctl_ctl {
 	uint64_t u64;
@@ -1974,14 +1898,15 @@ union cvmx_sata_uctl_ctl {
 	uint64_t start_bist                   : 1;  /**< Start BIST. The rising edge starts BIST on the memories in SATA. To run BIST, the host-
                                                          controller clock must be both configured and enabled, and should be configured to the
                                                          maximum available frequency given the available coprocessor clock and dividers.
-                                                         Refer to Cold Reset for clock initialization procedures. BIST defect status can be checked
-                                                         after FULL BIST completion, both of which are indicated in SATA_UCTL_BIST_STATUS. The FULL
-                                                         BIST run takes almost 80,000 host-controller clock cycles for the largest RAM. */
+                                                         Refer to Cold Reset for clock initialization procedures. BIST defect status can
+                                                         be checked after FULL BIST completion, both of which are indicated in
+                                                         SATA()_UCTL_BIST_STATUS. The FULL BIST run takes almost 80,000 host-controller
+                                                         clock cycles for the largest RAM. */
 	uint64_t reserved_31_61               : 31;
 	uint64_t a_clk_en                     : 1;  /**< Host-controller clock enable. When set to 1, the host-controller clock is generated. This
                                                          also enables access to UCTL registers 0x30-0xF8. */
 	uint64_t a_clk_byp_sel                : 1;  /**< Select the bypass input to the host-controller clock divider.
-                                                         0 = use the divided coprocessor clock from the A_CLKDIV divider
+                                                         0 = Use the divided coprocessor clock from the A_CLKDIV divider.
                                                          1 = use the bypass clock from the GPIO pins (generally bypass is only used for scan
                                                          purposes).
                                                          This signal is a multiplexer-select signal; it does not enable the host-controller clock.
@@ -1993,28 +1918,28 @@ union cvmx_sata_uctl_ctl {
                                                          This also resets the suspend-clock divider. */
 	uint64_t reserved_27_27               : 1;
 	uint64_t a_clkdiv_sel                 : 3;  /**< The host-controller clock frequency is the coprocessor-clock frequency divided by
-                                                         A_CLKDIV_SEL. The host-controller clock frequency must be at or below the requirements
-                                                         listed in Table 22-1 (Maximum ACLK Frequency).
+                                                         A_CLKDIV_SEL. The host-controller clock frequency must be at or below the minimum
+                                                         ACLK requirements.
                                                          This field can be changed only when A_CLKDIV_RST = 1. The divider values are the
                                                          following:
-                                                         0x0 = divide by 1 0x4 = divide by 6
-                                                         0x1 = divide by 2 0x5 = divide by 8
-                                                         0x2 = divide by 3 0x6 = divide by 16
-                                                         0x3 = divide by 4 0x7 = divide by 24 */
+                                                         0x0 = divide by 1.
+                                                         0x1 = divide by 2.
+                                                         0x2 = divide by 3.
+                                                         0x3 = divide by 4.
+                                                         0x4 = divide by 6.
+                                                         0x5 = divide by 8.
+                                                         0x6 = divide by 16.
+                                                         0x7 = divide by 24. */
 	uint64_t reserved_5_23                : 19;
 	uint64_t csclk_en                     : 1;  /**< Turns on the SATA UCTL interface clock (coprocessor clock). This enables access to UAHC
                                                          registers via the IOI, as well as UCTL registers starting from 0x30 via the RSL bus. */
 	uint64_t reserved_2_3                 : 2;
-	uint64_t sata_uahc_rst                : 1;  /**< Software reset; resets UAHC; active-high.
-                                                         INTERNAL: Note that soft-resetting the UAHC while it is active may cause violations of RSL
-                                                         or NCB protocols. */
+	uint64_t sata_uahc_rst                : 1;  /**< Software reset; resets UAHC; active-high. */
 	uint64_t sata_uctl_rst                : 1;  /**< Software reset; resets UCTL; active-high. Resets UAHC DMA and register shims and the UCTL
                                                          RSL registers 0x30-0xF8.
                                                          It does not reset UCTL RSL registers 0x0-0x28.
                                                          The UCTL RSL registers starting from 0x30 can be accessed only after the host-controller
-                                                         clock is active and UCTL_RST is deasserted.
-                                                         INTERNAL: Note that soft-resetting the UCTL while it is active may cause violations of
-                                                         RSL, NCB, and CIB protocols. */
+                                                         clock is active and UCTL_RST is deasserted. */
 #else
 	uint64_t sata_uctl_rst                : 1;
 	uint64_t sata_uahc_rst                : 1;
@@ -2042,30 +1967,26 @@ typedef union cvmx_sata_uctl_ctl cvmx_sata_uctl_ctl_t;
  *
  * This register can be used to disable ECC correction, insert ECC errors, and debug ECC
  * failures.
- * * The ECC_ERR* fields are captured when there are no outstanding ECC errors indicated in
- * INTSTAT and a new ECC error arrives. Prioritization for multiple events occurring on the same
- * cycle is indicated by the ECC_ERR_SOURCE enumeration: highest encoded value has highest
- * priority.
- * * The *ECC_*_DIS fields disable ECC correction; SBE and DBE errors are still reported. If
- * *ECC_*_DIS = 0x1, then no data-correction occurs.
- * * The *ECC_FLIP_SYND fields flip the syndrome<1:0> bits to generate single-bit/double-bit
- * error for testing.
- *
- * 0x0 = normal operation.
- * 0x1 = SBE on bit[0].
- * 0x2 = SBE on bit[1].
- * 0x3 = DBE on bit[1:0].
- *
- * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
- *
- * This register can be reset by IOI reset or with UCTL()_CTL[UCTL_RST].
+ *
+ * Fields ECC_ERR* are captured when there are no outstanding ECC errors indicated in INTSTAT
+ * and a new ECC error arrives. Prioritization for multiple events occurring on the same cycle is
+ * indicated by the ECC_ERR_SOURCE enumeration: highest encoded value has highest priority.
+ *
+ * Fields *ECC_DIS: Disables ECC correction, SBE and DBE errors are still reported.
+ * If ECC_DIS is 0x1, then no data-correction occurs.
+ *
+ * Fields *ECC_FLIP_SYND:  Flip the syndrom[1:0] bits to generate 1-bit/2-bits error for testing.
+ *
+ * Accessible only when SATA_UCTL_CTL[A_CLK_EN].
+ *
+ * Reset by IOI reset or SATA_UCTL_CTL[SATA_UCTL_RST].
  */
 union cvmx_sata_uctl_ecc {
 	uint64_t u64;
 	struct cvmx_sata_uctl_ecc_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_63_63               : 1;
-	uint64_t ecc_err_source               : 5;  /**< Source of ECC error, see UCTL_ECC_ERR_SOURCE_E. */
+	uint64_t ecc_err_source               : 5;  /**< Source of ECC error, see SATA_UCTL_ECC_ERR_SOURCE_E. */
 	uint64_t ecc_err_syndrome             : 18; /**< Syndrome bits of the ECC error. */
 	uint64_t ecc_err_address              : 8;  /**< RAM address of the ECC error. */
 	uint64_t reserved_24_31               : 8;
@@ -2116,9 +2037,11 @@ typedef union cvmx_sata_uctl_ecc cvmx_sata_uctl_ecc_t;
 /**
  * cvmx_sata_uctl_intstat
  *
- * Accessible by: always
- * Reset by: IOI reset (srst_n)
- * Summary of different bits of RSL interrupts.
+ * Summary of different bits of interrupts.
+ *
+ * Accessible always.
+ *
+ * Reset by IOI reset.
  */
 union cvmx_sata_uctl_intstat {
 	uint64_t u64;
@@ -2208,13 +2131,17 @@ typedef union cvmx_sata_uctl_intstat cvmx_sata_uctl_intstat_t;
 /**
  * cvmx_sata_uctl_shim_cfg
  *
- * Accessible by: only when A_CLKDIV_EN
- * Reset by: IOI reset (srst_n) or SATA_UCTL_CTL[SATA_UCTL_RST]
  * This register allows configuration of various shim (UCTL) features.
+ *
  * Fields XS_NCB_OOB_* are captured when there are no outstanding OOB errors indicated in INTSTAT
  * and a new OOB error arrives.
+ *
  * Fields XS_BAD_DMA_* are captured when there are no outstanding DMA errors indicated in INTSTAT
  * and a new DMA error arrives.
+ *
+ * Accessible only when SATA_UCTL_CTL[A_CLK_EN].
+ *
+ * Reset by IOI reset or SATA_UCTL_CTL[SATA_UCTL_RST].
  */
 union cvmx_sata_uctl_shim_cfg {
 	uint64_t u64;
@@ -2294,9 +2221,11 @@ typedef union cvmx_sata_uctl_shim_cfg cvmx_sata_uctl_shim_cfg_t;
 /**
  * cvmx_sata_uctl_spare0
  *
- * Accessible by: always
- * Reset by: IOI reset (srst_n)
  * This register is spare.
+ *
+ * Accessible only when SATA_UCTL_CTL[A_CLK_EN].
+ *
+ * Reset by IOI reset or SATA_UCTL_CTL[SATA_UCTL_RST].
  */
 union cvmx_sata_uctl_spare0 {
 	uint64_t u64;
@@ -2315,9 +2244,11 @@ typedef union cvmx_sata_uctl_spare0 cvmx_sata_uctl_spare0_t;
 /**
  * cvmx_sata_uctl_spare0_eco
  *
- * Accessible by: always
- * Reset by: IOI reset (srst_n)
  * This register is spare.
+ *
+ * Accessible always.
+ *
+ * Reset by IOI reset.
  */
 union cvmx_sata_uctl_spare0_eco {
 	uint64_t u64;
@@ -2337,9 +2268,11 @@ typedef union cvmx_sata_uctl_spare0_eco cvmx_sata_uctl_spare0_eco_t;
 /**
  * cvmx_sata_uctl_spare1
  *
- * Accessible by: only when A_CLKDIV_EN
- * Reset by: IOI reset (srst_n) or SATA_UCTL_CTL[SATA_UCTL_RST]
  * This register is spare.
+ *
+ * Accessible only when SATA_UCTL_CTL[A_CLK_EN].
+ *
+ * Reset by IOI reset or SATA_UCTL_CTL[SATA_UCTL_RST].
  */
 union cvmx_sata_uctl_spare1 {
 	uint64_t u64;
@@ -2358,16 +2291,18 @@ typedef union cvmx_sata_uctl_spare1 cvmx_sata_uctl_spare1_t;
 /**
  * cvmx_sata_uctl_spare1_eco
  *
- * Accessible by: only when A_CLKDIV_EN
- * Reset by: IOI reset (srst_n) or SATA_UCTL_CTL[SATA_UCTL_RST]
  * This register is spare.
+ *
+ * Accessible only when SATA_UCTL_CTL[A_CLK_EN].
+ *
+ * Reset by IOI reset or SATA_UCTL_CTL[SATA_UCTL_RST].
  */
 union cvmx_sata_uctl_spare1_eco {
 	uint64_t u64;
 	struct cvmx_sata_uctl_spare1_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 32; /**< N/A */
 #else
 	uint64_t eco_rw                       : 32;
 	uint64_t reserved_32_63               : 32;
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index 07b905a..1e04d25 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -61,13 +61,17 @@ static inline uint64_t CVMX_SLI_BIST_STATUS_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000580ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000010580ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000028580ull;
 			return 0x0000000000028580ull;
 			break;
 	}
@@ -83,12 +87,16 @@ static inline uint64_t CVMX_SLI_BIST_STATUS_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000580ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000010580ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000028580ull;
 			return 0x0000000000028580ull;
 	}
 	return 0x0000000000028580ull;
@@ -98,7 +106,7 @@ static inline uint64_t CVMX_SLI_BIST_STATUS_FUNC(void)
 #define CVMX_SLI_CIU_INT_ENB CVMX_SLI_CIU_INT_ENB_FUNC()
 static inline uint64_t CVMX_SLI_CIU_INT_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_CIU_INT_ENB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000027110ull);
 }
@@ -109,7 +117,7 @@ static inline uint64_t CVMX_SLI_CIU_INT_ENB_FUNC(void)
 #define CVMX_SLI_CIU_INT_SUM CVMX_SLI_CIU_INT_SUM_FUNC()
 static inline uint64_t CVMX_SLI_CIU_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_CIU_INT_SUM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000027100ull);
 }
@@ -135,15 +143,20 @@ static inline uint64_t CVMX_SLI_CTL_PORTX(unsigned long offset)
 			if ((offset <= 3))
 				return 0x0000000000000050ull + ((offset) & 3) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x00000000000106E0ull + ((offset) & 3) * 16;
-			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x00000000000106E0ull + ((offset) & 3) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x00000000000286E0ull + ((offset) & 3) * 16;
 			if ((offset <= 3))
 				return 0x00000000000286E0ull + ((offset) & 3) * 16;
 			break;
+
+			break;
 	}
 	cvmx_warn("CVMX_SLI_CTL_PORTX (offset = %lu) not supported on this chip\n", offset);
 	return 0x00000000000286E0ull + ((offset) & 3) * 16;
@@ -161,11 +174,15 @@ static inline uint64_t CVMX_SLI_CTL_PORTX(unsigned long offset)
 			return 0x0000000000010050ull + (offset) * 16;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000050ull + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000106E0ull + (offset) * 16;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000000000106E0ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000000000286E0ull + (offset) * 16;
 			return 0x00000000000286E0ull + (offset) * 16;
+
 	}
 	return 0x00000000000286E0ull + (offset) * 16;
 }
@@ -179,13 +196,17 @@ static inline uint64_t CVMX_SLI_CTL_STATUS_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000570ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000010570ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000028570ull;
 			return 0x0000000000028570ull;
 			break;
 	}
@@ -201,12 +222,16 @@ static inline uint64_t CVMX_SLI_CTL_STATUS_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000570ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000010570ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000028570ull;
 			return 0x0000000000028570ull;
 	}
 	return 0x0000000000028570ull;
@@ -221,13 +246,17 @@ static inline uint64_t CVMX_SLI_DATA_OUT_CNT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000005F0ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x00000000000105F0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x00000000000285F0ull;
 			return 0x00000000000285F0ull;
 			break;
 	}
@@ -243,12 +272,16 @@ static inline uint64_t CVMX_SLI_DATA_OUT_CNT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000005F0ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000000000105F0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000000000285F0ull;
 			return 0x00000000000285F0ull;
 	}
 	return 0x00000000000285F0ull;
@@ -284,7 +317,6 @@ static inline uint64_t CVMX_SLI_DMAX_CNT(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
@@ -292,6 +324,13 @@ static inline uint64_t CVMX_SLI_DMAX_CNT(unsigned long offset)
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return 0x0000000000010400ull + ((offset) & 1) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return 0x0000000000028400ull + ((offset) & 1) * 16;
 			if ((offset <= 1))
 				return 0x0000000000028400ull + ((offset) & 1) * 16;
 			break;
@@ -307,12 +346,16 @@ static inline uint64_t CVMX_SLI_DMAX_CNT(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000400ull + (offset) * 16;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000010400ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000028400ull + (offset) * 16;
 			return 0x0000000000028400ull + (offset) * 16;
 	}
 	return 0x0000000000028400ull + (offset) * 16;
@@ -326,7 +369,6 @@ static inline uint64_t CVMX_SLI_DMAX_INT_LEVEL(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
@@ -334,6 +376,13 @@ static inline uint64_t CVMX_SLI_DMAX_INT_LEVEL(unsigned long offset)
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return 0x00000000000103E0ull + ((offset) & 1) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return 0x00000000000283E0ull + ((offset) & 1) * 16;
 			if ((offset <= 1))
 				return 0x00000000000283E0ull + ((offset) & 1) * 16;
 			break;
@@ -349,12 +398,16 @@ static inline uint64_t CVMX_SLI_DMAX_INT_LEVEL(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000003E0ull + (offset) * 16;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000000000103E0ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000000000283E0ull + (offset) * 16;
 			return 0x00000000000283E0ull + (offset) * 16;
 	}
 	return 0x00000000000283E0ull + (offset) * 16;
@@ -368,7 +421,6 @@ static inline uint64_t CVMX_SLI_DMAX_TIM(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 1))
@@ -376,6 +428,13 @@ static inline uint64_t CVMX_SLI_DMAX_TIM(unsigned long offset)
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 1))
+					return 0x0000000000010420ull + ((offset) & 1) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 1))
+					return 0x0000000000028420ull + ((offset) & 1) * 16;
 			if ((offset <= 1))
 				return 0x0000000000028420ull + ((offset) & 1) * 16;
 			break;
@@ -391,12 +450,16 @@ static inline uint64_t CVMX_SLI_DMAX_TIM(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000420ull + (offset) * 16;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000010420ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000028420ull + (offset) * 16;
 			return 0x0000000000028420ull + (offset) * 16;
 	}
 	return 0x0000000000028420ull + (offset) * 16;
@@ -422,7 +485,7 @@ static inline uint64_t CVMX_SLI_INT_ENB_PORTX(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_SLI_INT_ENB_PORTX(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000000340ull + ((offset) & 3) * 16;
@@ -434,7 +497,7 @@ static inline uint64_t CVMX_SLI_INT_ENB_PORTX(unsigned long offset)
 #define CVMX_SLI_INT_SUM CVMX_SLI_INT_SUM_FUNC()
 static inline uint64_t CVMX_SLI_INT_SUM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_INT_SUM not supported on this chip\n");
 	return 0x0000000000000330ull;
 }
@@ -490,6 +553,7 @@ static inline uint64_t CVMX_SLI_MACX_PFX_DMA_VF_INT(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_SLI_MACX_PFX_DMA_VF_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return 0x0000000000027280ull + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -502,6 +566,7 @@ static inline uint64_t CVMX_SLI_MACX_PFX_DMA_VF_INT_ENB(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_SLI_MACX_PFX_DMA_VF_INT_ENB(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return 0x0000000000027500ull + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -514,6 +579,7 @@ static inline uint64_t CVMX_SLI_MACX_PFX_FLR_VF_INT(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_SLI_MACX_PFX_FLR_VF_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return 0x0000000000027400ull + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -526,6 +592,7 @@ static inline uint64_t CVMX_SLI_MACX_PFX_INT_ENB(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_SLI_MACX_PFX_INT_ENB(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return 0x0000000000027080ull + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -538,6 +605,7 @@ static inline uint64_t CVMX_SLI_MACX_PFX_INT_SUM(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_SLI_MACX_PFX_INT_SUM(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return 0x0000000000027000ull + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -550,6 +618,7 @@ static inline uint64_t CVMX_SLI_MACX_PFX_MBOX_INT(unsigned long offset, unsigned
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_SLI_MACX_PFX_MBOX_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return 0x0000000000027380ull + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -562,6 +631,7 @@ static inline uint64_t CVMX_SLI_MACX_PFX_PKT_VF_INT(unsigned long offset, unsign
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_SLI_MACX_PFX_PKT_VF_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return 0x0000000000027300ull + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -574,6 +644,7 @@ static inline uint64_t CVMX_SLI_MACX_PFX_PKT_VF_INT_ENB(unsigned long offset, un
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_SLI_MACX_PFX_PKT_VF_INT_ENB(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return 0x0000000000027580ull + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -586,6 +657,7 @@ static inline uint64_t CVMX_SLI_MACX_PFX_PP_VF_INT(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_SLI_MACX_PFX_PP_VF_INT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return 0x0000000000027200ull + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -598,6 +670,7 @@ static inline uint64_t CVMX_SLI_MACX_PFX_PP_VF_INT_ENB(unsigned long offset, uns
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_SLI_MACX_PFX_PP_VF_INT_ENB(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return 0x0000000000027480ull + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -614,13 +687,17 @@ static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003D70ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000013D70ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000023D70ull;
 			return 0x0000000000023D70ull;
 			break;
 	}
@@ -636,12 +713,16 @@ static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003D70ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000013D70ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000023D70ull;
 			return 0x0000000000023D70ull;
 	}
 	return 0x0000000000023D70ull;
@@ -655,12 +736,16 @@ static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT2_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000013E10ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000013E10ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000023E10ull;
 			return 0x0000000000023E10ull;
 			break;
 	}
@@ -675,11 +760,15 @@ static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT2_FUNC(void)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000013E10ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000013E10ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000023E10ull;
 			return 0x0000000000023E10ull;
 	}
 	return 0x0000000000023E10ull;
@@ -694,13 +783,17 @@ static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003E00ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000003E00ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000020050ull;
 			return 0x0000000000020050ull;
 			break;
 	}
@@ -716,12 +809,16 @@ static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003E00ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000003E00ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000020050ull;
 			return 0x0000000000020050ull;
 	}
 	return 0x0000000000020050ull;
@@ -736,13 +833,17 @@ static inline uint64_t CVMX_SLI_MEM_ACCESS_CTL_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000002F0ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x00000000000102F0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x00000000000282F0ull;
 			return 0x00000000000282F0ull;
 			break;
 	}
@@ -758,12 +859,16 @@ static inline uint64_t CVMX_SLI_MEM_ACCESS_CTL_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000002F0ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000000000102F0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000000000282F0ull;
 			return 0x00000000000282F0ull;
 	}
 	return 0x00000000000282F0ull;
@@ -777,7 +882,6 @@ static inline uint64_t CVMX_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if (((offset >= 12) && (offset <= 27)))
@@ -785,6 +889,13 @@ static inline uint64_t CVMX_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if (((offset >= 12) && (offset <= 27)))
+					return 0x00000000000100E0ull + ((offset) & 31) * 16 - 16*12;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if (((offset >= 12) && (offset <= 27)))
+					return 0x00000000000280E0ull + ((offset) & 31) * 16 - 16*12;
 			if (((offset >= 12) && (offset <= 27)))
 				return 0x00000000000280E0ull + ((offset) & 31) * 16 - 16*12;
 			break;
@@ -800,12 +911,16 @@ static inline uint64_t CVMX_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000000E0ull + (offset) * 16 - 16*12;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000000000100E0ull + (offset) * 16 - 16*12;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000000000280E0ull + (offset) * 16 - 16*12;
 			return 0x00000000000280E0ull + (offset) * 16 - 16*12;
 	}
 	return 0x00000000000280E0ull + (offset) * 16 - 16*12;
@@ -816,12 +931,16 @@ static inline uint64_t CVMX_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 static inline uint64_t CVMX_SLI_MEM_CTL_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000285E0ull;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000105E0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x00000000000105E0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x00000000000285E0ull;
+			return 0x00000000000285E0ull;
 			break;
 	}
 	cvmx_warn("CVMX_SLI_MEM_CTL not supported on this chip\n");
@@ -832,11 +951,15 @@ static inline uint64_t CVMX_SLI_MEM_CTL_FUNC(void)
 static inline uint64_t CVMX_SLI_MEM_CTL_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000285E0ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000105E0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000000000105E0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000000000285E0ull;
+			return 0x00000000000285E0ull;
 	}
 	return 0x00000000000285E0ull;
 }
@@ -846,12 +969,16 @@ static inline uint64_t CVMX_SLI_MEM_CTL_FUNC(void)
 static inline uint64_t CVMX_SLI_MEM_INT_SUM_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000285D0ull;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000105D0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x00000000000105D0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x00000000000285D0ull;
+			return 0x00000000000285D0ull;
 			break;
 	}
 	cvmx_warn("CVMX_SLI_MEM_INT_SUM not supported on this chip\n");
@@ -862,11 +989,15 @@ static inline uint64_t CVMX_SLI_MEM_INT_SUM_FUNC(void)
 static inline uint64_t CVMX_SLI_MEM_INT_SUM_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000285D0ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000105D0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000000000105D0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000000000285D0ull;
+			return 0x00000000000285D0ull;
 	}
 	return 0x00000000000285D0ull;
 }
@@ -875,14 +1006,19 @@ static inline uint64_t CVMX_SLI_MEM_INT_SUM_FUNC(void)
 static inline uint64_t CVMX_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 64))
-				return 0x0000000000000000ull + ((offset) & 127) * 16;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 64))
+					return 0x0000000000016000ull + ((offset) & 127) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 64))
+					return 0x0000000000000000ull + ((offset) & 127) * 16;
 			if ((offset <= 64))
-				return 0x0000000000016000ull + ((offset) & 127) * 16;
+				return 0x0000000000000000ull + ((offset) & 127) * 16;
 			break;
 	}
 	cvmx_warn("CVMX_SLI_MSIXX_TABLE_ADDR (offset = %lu) not supported on this chip\n", offset);
@@ -892,11 +1028,15 @@ static inline uint64_t CVMX_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
 static inline uint64_t CVMX_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000000000ull + (offset) * 16;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000016000ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000016000ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000000000ull + (offset) * 16;
+			return 0x0000000000000000ull + (offset) * 16;
 	}
 	return 0x0000000000000000ull + (offset) * 16;
 }
@@ -905,14 +1045,19 @@ static inline uint64_t CVMX_SLI_MSIXX_TABLE_ADDR(unsigned long offset)
 static inline uint64_t CVMX_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 64))
-				return 0x0000000000000008ull + ((offset) & 127) * 16;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 64))
+					return 0x0000000000016008ull + ((offset) & 127) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 64))
+					return 0x0000000000000008ull + ((offset) & 127) * 16;
 			if ((offset <= 64))
-				return 0x0000000000016008ull + ((offset) & 127) * 16;
+				return 0x0000000000000008ull + ((offset) & 127) * 16;
 			break;
 	}
 	cvmx_warn("CVMX_SLI_MSIXX_TABLE_DATA (offset = %lu) not supported on this chip\n", offset);
@@ -922,11 +1067,15 @@ static inline uint64_t CVMX_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 static inline uint64_t CVMX_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000000008ull + (offset) * 16;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000016008ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000016008ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000000008ull + (offset) * 16;
+			return 0x0000000000000008ull + (offset) * 16;
 	}
 	return 0x0000000000000008ull + (offset) * 16;
 }
@@ -935,7 +1084,7 @@ static inline uint64_t CVMX_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 static inline uint64_t CVMX_SLI_MSIX_MACX_PF_TABLE_ADDR(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3)))))
 		cvmx_warn("CVMX_SLI_MSIX_MACX_PF_TABLE_ADDR(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000017C00ull + ((offset) & 3) * 16;
 }
@@ -946,7 +1095,7 @@ static inline uint64_t CVMX_SLI_MSIX_MACX_PF_TABLE_ADDR(unsigned long offset)
 static inline uint64_t CVMX_SLI_MSIX_MACX_PF_TABLE_DATA(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3)))))
 		cvmx_warn("CVMX_SLI_MSIX_MACX_PF_TABLE_DATA(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000017C08ull + ((offset) & 3) * 16;
 }
@@ -958,12 +1107,16 @@ static inline uint64_t CVMX_SLI_MSIX_MACX_PF_TABLE_DATA(unsigned long offset)
 static inline uint64_t CVMX_SLI_MSIX_PBA0_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000001000ull;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000017000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000017000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000001000ull;
+			return 0x0000000000001000ull;
 			break;
 	}
 	cvmx_warn("CVMX_SLI_MSIX_PBA0 not supported on this chip\n");
@@ -974,11 +1127,15 @@ static inline uint64_t CVMX_SLI_MSIX_PBA0_FUNC(void)
 static inline uint64_t CVMX_SLI_MSIX_PBA0_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000001000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000017000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000017000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000001000ull;
+			return 0x0000000000001000ull;
 	}
 	return 0x0000000000001000ull;
 }
@@ -988,12 +1145,16 @@ static inline uint64_t CVMX_SLI_MSIX_PBA0_FUNC(void)
 static inline uint64_t CVMX_SLI_MSIX_PBA1_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000001008ull;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000017010ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000017010ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000001008ull;
+			return 0x0000000000001008ull;
 			break;
 	}
 	cvmx_warn("CVMX_SLI_MSIX_PBA1 not supported on this chip\n");
@@ -1004,11 +1165,15 @@ static inline uint64_t CVMX_SLI_MSIX_PBA1_FUNC(void)
 static inline uint64_t CVMX_SLI_MSIX_PBA1_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000001008ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000017010ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000017010ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000001008ull;
+			return 0x0000000000001008ull;
 	}
 	return 0x0000000000001008ull;
 }
@@ -1066,13 +1231,17 @@ static inline uint64_t CVMX_SLI_MSI_RCV0_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003C10ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000013C10ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000023C10ull;
 			return 0x0000000000023C10ull;
 			break;
 	}
@@ -1088,12 +1257,16 @@ static inline uint64_t CVMX_SLI_MSI_RCV0_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003C10ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000013C10ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000023C10ull;
 			return 0x0000000000023C10ull;
 	}
 	return 0x0000000000023C10ull;
@@ -1108,13 +1281,17 @@ static inline uint64_t CVMX_SLI_MSI_RCV1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003C20ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000013C20ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000023C20ull;
 			return 0x0000000000023C20ull;
 			break;
 	}
@@ -1130,12 +1307,16 @@ static inline uint64_t CVMX_SLI_MSI_RCV1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003C20ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000013C20ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000023C20ull;
 			return 0x0000000000023C20ull;
 	}
 	return 0x0000000000023C20ull;
@@ -1150,13 +1331,17 @@ static inline uint64_t CVMX_SLI_MSI_RCV2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003C30ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000013C30ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000023C30ull;
 			return 0x0000000000023C30ull;
 			break;
 	}
@@ -1172,12 +1357,16 @@ static inline uint64_t CVMX_SLI_MSI_RCV2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003C30ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000013C30ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000023C30ull;
 			return 0x0000000000023C30ull;
 	}
 	return 0x0000000000023C30ull;
@@ -1192,13 +1381,17 @@ static inline uint64_t CVMX_SLI_MSI_RCV3_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003C40ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000013C40ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000023C40ull;
 			return 0x0000000000023C40ull;
 			break;
 	}
@@ -1214,12 +1407,16 @@ static inline uint64_t CVMX_SLI_MSI_RCV3_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003C40ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000013C40ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000023C40ull;
 			return 0x0000000000023C40ull;
 	}
 	return 0x0000000000023C40ull;
@@ -1234,13 +1431,17 @@ static inline uint64_t CVMX_SLI_MSI_RD_MAP_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003CA0ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000013CA0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000023CA0ull;
 			return 0x0000000000023CA0ull;
 			break;
 	}
@@ -1256,12 +1457,16 @@ static inline uint64_t CVMX_SLI_MSI_RD_MAP_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003CA0ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000013CA0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000023CA0ull;
 			return 0x0000000000023CA0ull;
 	}
 	return 0x0000000000023CA0ull;
@@ -1364,13 +1569,17 @@ static inline uint64_t CVMX_SLI_MSI_WR_MAP_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003C90ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000013C90ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000023C90ull;
 			return 0x0000000000023C90ull;
 			break;
 	}
@@ -1386,12 +1595,16 @@ static inline uint64_t CVMX_SLI_MSI_WR_MAP_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003C90ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000013C90ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000023C90ull;
 			return 0x0000000000023C90ull;
 	}
 	return 0x0000000000023C90ull;
@@ -1401,7 +1614,7 @@ static inline uint64_t CVMX_SLI_MSI_WR_MAP_FUNC(void)
 #define CVMX_SLI_NQM_RSP_ERR_SND_DBG CVMX_SLI_NQM_RSP_ERR_SND_DBG_FUNC()
 static inline uint64_t CVMX_SLI_NQM_RSP_ERR_SND_DBG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_NQM_RSP_ERR_SND_DBG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F0000028800ull);
 }
@@ -1417,13 +1630,17 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003CB0ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000013CB0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000023CB0ull;
 			return 0x0000000000023CB0ull;
 			break;
 	}
@@ -1439,12 +1656,16 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003CB0ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000013CB0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000023CB0ull;
 			return 0x0000000000023CB0ull;
 	}
 	return 0x0000000000023CB0ull;
@@ -1459,13 +1680,17 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000650ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000010650ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000028650ull;
 			return 0x0000000000028650ull;
 			break;
 	}
@@ -1481,12 +1706,16 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000650ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000010650ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000028650ull;
 			return 0x0000000000028650ull;
 	}
 	return 0x0000000000028650ull;
@@ -1501,13 +1730,17 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000660ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000010660ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000028660ull;
 			return 0x0000000000028660ull;
 			break;
 	}
@@ -1523,12 +1756,16 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000660ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000010660ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000028660ull;
 			return 0x0000000000028660ull;
 	}
 	return 0x0000000000028660ull;
@@ -1543,13 +1780,17 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B3_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000670ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000010670ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000028670ull;
 			return 0x0000000000028670ull;
 			break;
 	}
@@ -1565,12 +1806,16 @@ static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B3_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000670ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000010670ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000028670ull;
 			return 0x0000000000028670ull;
 	}
 	return 0x0000000000028670ull;
@@ -1589,12 +1834,17 @@ static inline uint64_t CVMX_SLI_PKTX_CNTS(unsigned long offset)
 			if ((offset <= 31))
 				return 0x0000000000002400ull + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return 0x0000000000012400ull + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return 0x0000000000012400ull + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return 0x00000000000100B0ull + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return 0x00000000000100B0ull + ((offset) & 127) * 0x20000ull;
 			break;
@@ -1613,10 +1863,14 @@ static inline uint64_t CVMX_SLI_PKTX_CNTS(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000002400ull + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000012400ull + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000012400ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000000000100B0ull + (offset) * 0x20000ull;
 			return 0x00000000000100B0ull + (offset) * 0x20000ull;
 	}
 	return 0x00000000000100B0ull + (offset) * 0x20000ull;
@@ -1627,6 +1881,7 @@ static inline uint64_t CVMX_SLI_PKTX_ERROR_INFO(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
 		cvmx_warn("CVMX_SLI_PKTX_ERROR_INFO(%lu) is invalid on this chip\n", offset);
 	return 0x00000000000100C0ull + ((offset) & 127) * 0x20000ull;
@@ -1638,15 +1893,20 @@ static inline uint64_t CVMX_SLI_PKTX_ERROR_INFO(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKTX_INPUT_CONTROL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return 0x0000000000014000ull + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return 0x0000000000010000ull + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return 0x0000000000010000ull + ((offset) & 127) * 0x20000ull;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return 0x0000000000014000ull + ((offset) & 63) * 16;
-			break;
 	}
 	cvmx_warn("CVMX_SLI_PKTX_INPUT_CONTROL (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000010000ull + ((offset) & 127) * 0x20000ull;
@@ -1655,11 +1915,15 @@ static inline uint64_t CVMX_SLI_PKTX_INPUT_CONTROL(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKTX_INPUT_CONTROL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000010000ull + (offset) * 0x20000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000014000ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000014000ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000010000ull + (offset) * 0x20000ull;
+			return 0x0000000000010000ull + (offset) * 0x20000ull;
 	}
 	return 0x0000000000010000ull + (offset) * 0x20000ull;
 }
@@ -1677,12 +1941,17 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_BADDR(unsigned long offset)
 			if ((offset <= 31))
 				return 0x0000000000002800ull + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return 0x0000000000012800ull + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return 0x0000000000012800ull + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return 0x0000000000010010ull + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return 0x0000000000010010ull + ((offset) & 127) * 0x20000ull;
 			break;
@@ -1701,10 +1970,14 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_BADDR(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000002800ull + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000012800ull + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000012800ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000010010ull + (offset) * 0x20000ull;
 			return 0x0000000000010010ull + (offset) * 0x20000ull;
 	}
 	return 0x0000000000010010ull + (offset) * 0x20000ull;
@@ -1723,12 +1996,17 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset)
 			if ((offset <= 31))
 				return 0x0000000000002C00ull + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return 0x0000000000012C00ull + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return 0x0000000000012C00ull + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return 0x0000000000010020ull + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return 0x0000000000010020ull + ((offset) & 127) * 0x20000ull;
 			break;
@@ -1747,10 +2025,14 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000002C00ull + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000012C00ull + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000012C00ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000010020ull + (offset) * 0x20000ull;
 			return 0x0000000000010020ull + (offset) * 0x20000ull;
 	}
 	return 0x0000000000010020ull + (offset) * 0x20000ull;
@@ -1769,12 +2051,17 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
 			if ((offset <= 31))
 				return 0x0000000000003000ull + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return 0x0000000000013000ull + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return 0x0000000000013000ull + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return 0x0000000000010030ull + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return 0x0000000000010030ull + ((offset) & 127) * 0x20000ull;
 			break;
@@ -1793,10 +2080,14 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003000ull + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000013000ull + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000013000ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000010030ull + (offset) * 0x20000ull;
 			return 0x0000000000010030ull + (offset) * 0x20000ull;
 	}
 	return 0x0000000000010030ull + (offset) * 0x20000ull;
@@ -1822,15 +2113,20 @@ static inline uint64_t CVMX_SLI_PKTX_INSTR_HEADER(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKTX_INT_LEVELS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return 0x0000000000014400ull + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return 0x00000000000100A0ull + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return 0x00000000000100A0ull + ((offset) & 127) * 0x20000ull;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return 0x0000000000014400ull + ((offset) & 63) * 16;
-			break;
 	}
 	cvmx_warn("CVMX_SLI_PKTX_INT_LEVELS (offset = %lu) not supported on this chip\n", offset);
 	return 0x00000000000100A0ull + ((offset) & 127) * 0x20000ull;
@@ -1839,11 +2135,15 @@ static inline uint64_t CVMX_SLI_PKTX_INT_LEVELS(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKTX_INT_LEVELS(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000100A0ull + (offset) * 0x20000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000014400ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000014400ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000000000100A0ull + (offset) * 0x20000ull;
+			return 0x00000000000100A0ull + (offset) * 0x20000ull;
 	}
 	return 0x00000000000100A0ull + (offset) * 0x20000ull;
 }
@@ -1868,6 +2168,7 @@ static inline uint64_t CVMX_SLI_PKTX_MBOX_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
 		cvmx_warn("CVMX_SLI_PKTX_MBOX_INT(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000010210ull + ((offset) & 127) * 0x20000ull;
@@ -1879,15 +2180,20 @@ static inline uint64_t CVMX_SLI_PKTX_MBOX_INT(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKTX_OUTPUT_CONTROL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return 0x0000000000014800ull + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return 0x0000000000010050ull + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return 0x0000000000010050ull + ((offset) & 127) * 0x20000ull;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return 0x0000000000014800ull + ((offset) & 63) * 16;
-			break;
 	}
 	cvmx_warn("CVMX_SLI_PKTX_OUTPUT_CONTROL (offset = %lu) not supported on this chip\n", offset);
 	return 0x0000000000010050ull + ((offset) & 127) * 0x20000ull;
@@ -1896,11 +2202,15 @@ static inline uint64_t CVMX_SLI_PKTX_OUTPUT_CONTROL(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKTX_OUTPUT_CONTROL(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000010050ull + (offset) * 0x20000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000014800ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000014800ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000010050ull + (offset) * 0x20000ull;
+			return 0x0000000000010050ull + (offset) * 0x20000ull;
 	}
 	return 0x0000000000010050ull + (offset) * 0x20000ull;
 }
@@ -1918,12 +2228,17 @@ static inline uint64_t CVMX_SLI_PKTX_OUT_SIZE(unsigned long offset)
 			if ((offset <= 31))
 				return 0x0000000000000C00ull + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return 0x0000000000010C00ull + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return 0x0000000000010C00ull + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return 0x0000000000010060ull + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return 0x0000000000010060ull + ((offset) & 127) * 0x20000ull;
 			break;
@@ -1942,10 +2257,14 @@ static inline uint64_t CVMX_SLI_PKTX_OUT_SIZE(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000C00ull + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000010C00ull + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000010C00ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000010060ull + (offset) * 0x20000ull;
 			return 0x0000000000010060ull + (offset) * 0x20000ull;
 	}
 	return 0x0000000000010060ull + (offset) * 0x20000ull;
@@ -1956,6 +2275,7 @@ static inline uint64_t CVMX_SLI_PKTX_PF_VF_MBOX_SIGX(unsigned long offset, unsig
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 63)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 63)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 63))))))
 		cvmx_warn("CVMX_SLI_PKTX_PF_VF_MBOX_SIGX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return 0x0000000000010200ull + (((offset) & 1) + ((block_id) & 63) * 0x4000ull) * 8;
@@ -1976,12 +2296,17 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_BADDR(unsigned long offset)
 			if ((offset <= 31))
 				return 0x0000000000001400ull + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return 0x0000000000011400ull + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return 0x0000000000011400ull + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return 0x0000000000010070ull + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return 0x0000000000010070ull + ((offset) & 127) * 0x20000ull;
 			break;
@@ -2000,10 +2325,14 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_BADDR(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000001400ull + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000011400ull + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000011400ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000010070ull + (offset) * 0x20000ull;
 			return 0x0000000000010070ull + (offset) * 0x20000ull;
 	}
 	return 0x0000000000010070ull + (offset) * 0x20000ull;
@@ -2022,12 +2351,17 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset)
 			if ((offset <= 31))
 				return 0x0000000000001800ull + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return 0x0000000000011800ull + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return 0x0000000000011800ull + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return 0x0000000000010080ull + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return 0x0000000000010080ull + ((offset) & 127) * 0x20000ull;
 			break;
@@ -2046,10 +2380,14 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000001800ull + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000011800ull + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000011800ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000010080ull + (offset) * 0x20000ull;
 			return 0x0000000000010080ull + (offset) * 0x20000ull;
 	}
 	return 0x0000000000010080ull + (offset) * 0x20000ull;
@@ -2068,12 +2406,17 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 			if ((offset <= 31))
 				return 0x0000000000001C00ull + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return 0x0000000000011C00ull + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return 0x0000000000011C00ull + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return 0x0000000000010090ull + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return 0x0000000000010090ull + ((offset) & 127) * 0x20000ull;
 			break;
@@ -2092,10 +2435,14 @@ static inline uint64_t CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000001C00ull + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000011C00ull + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000011C00ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000010090ull + (offset) * 0x20000ull;
 			return 0x0000000000010090ull + (offset) * 0x20000ull;
 	}
 	return 0x0000000000010090ull + (offset) * 0x20000ull;
@@ -2106,6 +2453,7 @@ static inline uint64_t CVMX_SLI_PKTX_VF_INT_SUM(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 127))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
 		cvmx_warn("CVMX_SLI_PKTX_VF_INT_SUM(%lu) is invalid on this chip\n", offset);
 	return 0x00000000000100D0ull + ((offset) & 127) * 0x20000ull;
@@ -2117,7 +2465,7 @@ static inline uint64_t CVMX_SLI_PKTX_VF_INT_SUM(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKTX_VF_SIG(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SLI_PKTX_VF_SIG(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000014C00ull + ((offset) & 63) * 16;
 }
@@ -2128,7 +2476,7 @@ static inline uint64_t CVMX_SLI_PKTX_VF_SIG(unsigned long offset)
 #define CVMX_SLI_PKT_BIST_STATUS CVMX_SLI_PKT_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_SLI_PKT_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_BIST_STATUS not supported on this chip\n");
 	return 0x0000000000029220ull;
 }
@@ -2144,13 +2492,17 @@ static inline uint64_t CVMX_SLI_PKT_CNT_INT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000001130ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000011130ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000029130ull;
 			return 0x0000000000029130ull;
 			break;
 	}
@@ -2166,12 +2518,16 @@ static inline uint64_t CVMX_SLI_PKT_CNT_INT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000001130ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000011130ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000029130ull;
 			return 0x0000000000029130ull;
 	}
 	return 0x0000000000029130ull;
@@ -2247,7 +2603,7 @@ static inline uint64_t CVMX_SLI_PKT_DPADDR_FUNC(void)
 #define CVMX_SLI_PKT_GBL_CONTROL CVMX_SLI_PKT_GBL_CONTROL_FUNC()
 static inline uint64_t CVMX_SLI_PKT_GBL_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_GBL_CONTROL not supported on this chip\n");
 	return 0x0000000000029210ull;
 }
@@ -2269,7 +2625,7 @@ static inline uint64_t CVMX_SLI_PKT_INPUT_CONTROL_FUNC(void)
 #define CVMX_SLI_PKT_INSTR_ENB CVMX_SLI_PKT_INSTR_ENB_FUNC()
 static inline uint64_t CVMX_SLI_PKT_INSTR_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_INSTR_ENB not supported on this chip\n");
 	return 0x0000000000001000ull;
 }
@@ -2303,12 +2659,16 @@ static inline uint64_t CVMX_SLI_PKT_INSTR_SIZE_FUNC(void)
 static inline uint64_t CVMX_SLI_PKT_INT_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000029160ull;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000011160ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000011160ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000029160ull;
+			return 0x0000000000029160ull;
 			break;
 	}
 	cvmx_warn("CVMX_SLI_PKT_INT not supported on this chip\n");
@@ -2319,11 +2679,15 @@ static inline uint64_t CVMX_SLI_PKT_INT_FUNC(void)
 static inline uint64_t CVMX_SLI_PKT_INT_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000029160ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000011160ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000011160ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000029160ull;
+			return 0x0000000000029160ull;
 	}
 	return 0x0000000000029160ull;
 }
@@ -2363,12 +2727,17 @@ static inline uint64_t CVMX_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 			if ((offset <= 31))
 				return 0x0000000000002000ull + ((offset) & 31) * 16;
 			break;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 63))
-				return 0x0000000000012000ull + ((offset) & 63) * 16;
+
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 63))
+					return 0x0000000000012000ull + ((offset) & 63) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 127))
+					return 0x0000000000010040ull + ((offset) & 127) * 0x20000ull;
 			if ((offset <= 127))
 				return 0x0000000000010040ull + ((offset) & 127) * 0x20000ull;
 			break;
@@ -2387,10 +2756,14 @@ static inline uint64_t CVMX_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000002000ull + (offset) * 16;
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000012000ull + (offset) * 16;
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000012000ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000010040ull + (offset) * 0x20000ull;
 			return 0x0000000000010040ull + (offset) * 0x20000ull;
 	}
 	return 0x0000000000010040ull + (offset) * 0x20000ull;
@@ -2405,13 +2778,17 @@ static inline uint64_t CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000001200ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000011200ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000029200ull;
 			return 0x0000000000029200ull;
 			break;
 	}
@@ -2427,12 +2804,16 @@ static inline uint64_t CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000001200ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000011200ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000029200ull;
 			return 0x0000000000029200ull;
 	}
 	return 0x0000000000029200ull;
@@ -2443,12 +2824,16 @@ static inline uint64_t CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 static inline uint64_t CVMX_SLI_PKT_IN_INT_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000029150ull;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000011150ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000011150ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000029150ull;
+			return 0x0000000000029150ull;
 			break;
 	}
 	cvmx_warn("CVMX_SLI_PKT_IN_INT not supported on this chip\n");
@@ -2459,11 +2844,15 @@ static inline uint64_t CVMX_SLI_PKT_IN_INT_FUNC(void)
 static inline uint64_t CVMX_SLI_PKT_IN_INT_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000029150ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000011150ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000011150ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000029150ull;
+			return 0x0000000000029150ull;
 	}
 	return 0x0000000000029150ull;
 }
@@ -2472,7 +2861,7 @@ static inline uint64_t CVMX_SLI_PKT_IN_INT_FUNC(void)
 #define CVMX_SLI_PKT_IN_JABBER CVMX_SLI_PKT_IN_JABBER_FUNC()
 static inline uint64_t CVMX_SLI_PKT_IN_JABBER_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_IN_JABBER not supported on this chip\n");
 	return 0x0000000000029170ull;
 }
@@ -2505,7 +2894,7 @@ static inline uint64_t CVMX_SLI_PKT_IPTR_FUNC(void)
 #define CVMX_SLI_PKT_MAC0_SIG0 CVMX_SLI_PKT_MAC0_SIG0_FUNC()
 static inline uint64_t CVMX_SLI_PKT_MAC0_SIG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_SLI_PKT_MAC0_SIG0 not supported on this chip\n");
 	return 0x0000000000011300ull;
 }
@@ -2516,7 +2905,7 @@ static inline uint64_t CVMX_SLI_PKT_MAC0_SIG0_FUNC(void)
 #define CVMX_SLI_PKT_MAC0_SIG1 CVMX_SLI_PKT_MAC0_SIG1_FUNC()
 static inline uint64_t CVMX_SLI_PKT_MAC0_SIG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_SLI_PKT_MAC0_SIG1 not supported on this chip\n");
 	return 0x0000000000011310ull;
 }
@@ -2527,7 +2916,7 @@ static inline uint64_t CVMX_SLI_PKT_MAC0_SIG1_FUNC(void)
 #define CVMX_SLI_PKT_MAC1_SIG0 CVMX_SLI_PKT_MAC1_SIG0_FUNC()
 static inline uint64_t CVMX_SLI_PKT_MAC1_SIG0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_SLI_PKT_MAC1_SIG0 not supported on this chip\n");
 	return 0x0000000000011320ull;
 }
@@ -2538,7 +2927,7 @@ static inline uint64_t CVMX_SLI_PKT_MAC1_SIG0_FUNC(void)
 #define CVMX_SLI_PKT_MAC1_SIG1 CVMX_SLI_PKT_MAC1_SIG1_FUNC()
 static inline uint64_t CVMX_SLI_PKT_MAC1_SIG1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_SLI_PKT_MAC1_SIG1 not supported on this chip\n");
 	return 0x0000000000011330ull;
 }
@@ -2550,6 +2939,7 @@ static inline uint64_t CVMX_SLI_PKT_MACX_PFX_RINFO(unsigned long offset, unsigne
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
 		cvmx_warn("CVMX_SLI_PKT_MACX_PFX_RINFO(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return 0x0000000000029030ull + (((offset) & 1) + ((block_id) & 3) * 0x2ull) * 16;
@@ -2561,7 +2951,7 @@ static inline uint64_t CVMX_SLI_PKT_MACX_PFX_RINFO(unsigned long offset, unsigne
 static inline uint64_t CVMX_SLI_PKT_MACX_RINFO(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 3)))))
 		cvmx_warn("CVMX_SLI_PKT_MACX_RINFO(%lu) is invalid on this chip\n", offset);
 	return 0x0000000000011030ull + ((offset) & 3) * 16;
 }
@@ -2573,12 +2963,16 @@ static inline uint64_t CVMX_SLI_PKT_MACX_RINFO(unsigned long offset)
 static inline uint64_t CVMX_SLI_PKT_MEM_CTL_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000029120ull;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000011120ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000011120ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000029120ull;
+			return 0x0000000000029120ull;
 			break;
 	}
 	cvmx_warn("CVMX_SLI_PKT_MEM_CTL not supported on this chip\n");
@@ -2589,11 +2983,15 @@ static inline uint64_t CVMX_SLI_PKT_MEM_CTL_FUNC(void)
 static inline uint64_t CVMX_SLI_PKT_MEM_CTL_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000029120ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000011120ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000011120ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000029120ull;
+			return 0x0000000000029120ull;
 	}
 	return 0x0000000000029120ull;
 }
@@ -2607,13 +3005,17 @@ static inline uint64_t CVMX_SLI_PKT_OUTPUT_WMARK_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000001180ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000011180ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000029180ull;
 			return 0x0000000000029180ull;
 			break;
 	}
@@ -2629,12 +3031,16 @@ static inline uint64_t CVMX_SLI_PKT_OUTPUT_WMARK_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000001180ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000011180ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000029180ull;
 			return 0x0000000000029180ull;
 	}
 	return 0x0000000000029180ull;
@@ -2655,7 +3061,7 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BMODE_FUNC(void)
 #define CVMX_SLI_PKT_OUT_BP_EN CVMX_SLI_PKT_OUT_BP_EN_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN not supported on this chip\n");
 	return 0x0000000000001240ull;
 }
@@ -2666,7 +3072,7 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_FUNC(void)
 #define CVMX_SLI_PKT_OUT_BP_EN2_W1C CVMX_SLI_PKT_OUT_BP_EN2_W1C_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN2_W1C_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN2_W1C not supported on this chip\n");
 	return 0x0000000000029290ull;
 }
@@ -2677,7 +3083,7 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN2_W1C_FUNC(void)
 #define CVMX_SLI_PKT_OUT_BP_EN2_W1S CVMX_SLI_PKT_OUT_BP_EN2_W1S_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN2_W1S_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN2_W1S not supported on this chip\n");
 	return 0x0000000000029270ull;
 }
@@ -2688,7 +3094,7 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN2_W1S_FUNC(void)
 #define CVMX_SLI_PKT_OUT_BP_EN_W1C CVMX_SLI_PKT_OUT_BP_EN_W1C_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_W1C_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN_W1C not supported on this chip\n");
 	return 0x0000000000029280ull;
 }
@@ -2699,7 +3105,7 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_W1C_FUNC(void)
 #define CVMX_SLI_PKT_OUT_BP_EN_W1S CVMX_SLI_PKT_OUT_BP_EN_W1S_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_W1S_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN_W1S not supported on this chip\n");
 	return 0x0000000000029260ull;
 }
@@ -2710,7 +3116,7 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_W1S_FUNC(void)
 #define CVMX_SLI_PKT_OUT_ENB CVMX_SLI_PKT_OUT_ENB_FUNC()
 static inline uint64_t CVMX_SLI_PKT_OUT_ENB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_ENB not supported on this chip\n");
 	return 0x0000000000001010ull;
 }
@@ -2732,7 +3138,7 @@ static inline uint64_t CVMX_SLI_PKT_PCIE_PORT_FUNC(void)
 #define CVMX_SLI_PKT_PKIND_VALID CVMX_SLI_PKT_PKIND_VALID_FUNC()
 static inline uint64_t CVMX_SLI_PKT_PKIND_VALID_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_PKIND_VALID not supported on this chip\n");
 	return 0x0000000000029190ull;
 }
@@ -2755,12 +3161,16 @@ static inline uint64_t CVMX_SLI_PKT_PORT_IN_RST_FUNC(void)
 static inline uint64_t CVMX_SLI_PKT_RING_RST_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000291E0ull;
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000111E0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x00000000000111E0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x00000000000291E0ull;
+			return 0x00000000000291E0ull;
 			break;
 	}
 	cvmx_warn("CVMX_SLI_PKT_RING_RST not supported on this chip\n");
@@ -2771,11 +3181,15 @@ static inline uint64_t CVMX_SLI_PKT_RING_RST_FUNC(void)
 static inline uint64_t CVMX_SLI_PKT_RING_RST_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000291E0ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return 0x00000000000111E0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000000000111E0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000000000291E0ull;
+			return 0x00000000000291E0ull;
 	}
 	return 0x00000000000291E0ull;
 }
@@ -2822,13 +3236,17 @@ static inline uint64_t CVMX_SLI_PKT_TIME_INT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000001140ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000011140ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000029140ull;
 			return 0x0000000000029140ull;
 			break;
 	}
@@ -2844,12 +3262,16 @@ static inline uint64_t CVMX_SLI_PKT_TIME_INT_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000001140ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000011140ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000029140ull;
 			return 0x0000000000029140ull;
 	}
 	return 0x0000000000029140ull;
@@ -2881,7 +3303,7 @@ static inline uint64_t CVMX_SLI_PORTX_PKIND(unsigned long offset)
 #define CVMX_SLI_PP_PKT_CSR_CONTROL CVMX_SLI_PP_PKT_CSR_CONTROL_FUNC()
 static inline uint64_t CVMX_SLI_PP_PKT_CSR_CONTROL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PP_PKT_CSR_CONTROL not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00011F00000282D0ull);
 }
@@ -2893,12 +3315,16 @@ static inline uint64_t CVMX_SLI_PP_PKT_CSR_CONTROL_FUNC(void)
 static inline uint64_t CVMX_SLI_S2C_END_MERGE_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
+			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000025000ull);
-			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000015000ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00011F0000015000ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00011F0000025000ull);
+			return CVMX_ADD_IO_SEG(0x00011F0000025000ull);
 			break;
 	}
 	cvmx_warn("CVMX_SLI_S2C_END_MERGE not supported on this chip\n");
@@ -2909,11 +3335,15 @@ static inline uint64_t CVMX_SLI_S2C_END_MERGE_FUNC(void)
 static inline uint64_t CVMX_SLI_S2C_END_MERGE_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000025000ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000015000ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00011F0000015000ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00011F0000025000ull);
+			return CVMX_ADD_IO_SEG(0x00011F0000025000ull);
 	}
 	return CVMX_ADD_IO_SEG(0x00011F0000025000ull);
 }
@@ -2934,12 +3364,18 @@ static inline uint64_t CVMX_SLI_S2M_PORTX_CTL(unsigned long offset)
 				return 0x0000000000013D80ull + ((offset) & 3) * 16;
 			break;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000000000003D80ull + ((offset) & 3) * 16;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return 0x0000000000013D80ull + ((offset) & 3) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return 0x0000000000023D80ull + ((offset) & 3) * 16;
 			if ((offset <= 3))
 				return 0x0000000000023D80ull + ((offset) & 3) * 16;
 			break;
@@ -2959,10 +3395,14 @@ static inline uint64_t CVMX_SLI_S2M_PORTX_CTL(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000013D80ull + (offset) * 16;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000003D80ull + (offset) * 16;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000013D80ull + (offset) * 16;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000023D80ull + (offset) * 16;
 			return 0x0000000000023D80ull + (offset) * 16;
 	}
 	return 0x0000000000023D80ull + (offset) * 16;
@@ -2977,13 +3417,17 @@ static inline uint64_t CVMX_SLI_SCRATCH_1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000003C0ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x00000000000103C0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x00000000000283C0ull;
 			return 0x00000000000283C0ull;
 			break;
 	}
@@ -2999,12 +3443,16 @@ static inline uint64_t CVMX_SLI_SCRATCH_1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000003C0ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000000000103C0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000000000283C0ull;
 			return 0x00000000000283C0ull;
 	}
 	return 0x00000000000283C0ull;
@@ -3019,13 +3467,17 @@ static inline uint64_t CVMX_SLI_SCRATCH_2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000003D0ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x00000000000103D0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x00000000000283D0ull;
 			return 0x00000000000283D0ull;
 			break;
 	}
@@ -3041,12 +3493,16 @@ static inline uint64_t CVMX_SLI_SCRATCH_2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000003D0ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000000000103D0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000000000283D0ull;
 			return 0x00000000000283D0ull;
 	}
 	return 0x00000000000283D0ull;
@@ -3061,13 +3517,17 @@ static inline uint64_t CVMX_SLI_STATE1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000620ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000010620ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000028620ull;
 			return 0x0000000000028620ull;
 			break;
 	}
@@ -3083,12 +3543,16 @@ static inline uint64_t CVMX_SLI_STATE1_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000620ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000010620ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000028620ull;
 			return 0x0000000000028620ull;
 	}
 	return 0x0000000000028620ull;
@@ -3103,13 +3567,17 @@ static inline uint64_t CVMX_SLI_STATE2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000630ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000010630ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000028630ull;
 			return 0x0000000000028630ull;
 			break;
 	}
@@ -3125,12 +3593,16 @@ static inline uint64_t CVMX_SLI_STATE2_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000630ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000010630ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000028630ull;
 			return 0x0000000000028630ull;
 	}
 	return 0x0000000000028630ull;
@@ -3145,13 +3617,17 @@ static inline uint64_t CVMX_SLI_STATE3_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000640ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000010640ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000028640ull;
 			return 0x0000000000028640ull;
 			break;
 	}
@@ -3167,12 +3643,16 @@ static inline uint64_t CVMX_SLI_STATE3_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000640ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000010640ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000028640ull;
 			return 0x0000000000028640ull;
 	}
 	return 0x0000000000028640ull;
@@ -3198,13 +3678,17 @@ static inline uint64_t CVMX_SLI_WINDOW_CTL_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000002E0ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x00000000000102E0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x00000000000282E0ull;
 			return 0x00000000000282E0ull;
 			break;
 	}
@@ -3220,12 +3704,16 @@ static inline uint64_t CVMX_SLI_WINDOW_CTL_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x00000000000002E0ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x00000000000102E0ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x00000000000282E0ull;
 			return 0x00000000000282E0ull;
 	}
 	return 0x00000000000282E0ull;
@@ -3240,13 +3728,17 @@ static inline uint64_t CVMX_SLI_WIN_RD_ADDR_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000010ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000000010ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000020010ull;
 			return 0x0000000000020010ull;
 			break;
 	}
@@ -3262,12 +3754,16 @@ static inline uint64_t CVMX_SLI_WIN_RD_ADDR_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000010ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000000010ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000020010ull;
 			return 0x0000000000020010ull;
 	}
 	return 0x0000000000020010ull;
@@ -3282,13 +3778,17 @@ static inline uint64_t CVMX_SLI_WIN_RD_DATA_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000040ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000000040ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000020040ull;
 			return 0x0000000000020040ull;
 			break;
 	}
@@ -3304,12 +3804,16 @@ static inline uint64_t CVMX_SLI_WIN_RD_DATA_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000040ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000000040ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000020040ull;
 			return 0x0000000000020040ull;
 	}
 	return 0x0000000000020040ull;
@@ -3324,13 +3828,17 @@ static inline uint64_t CVMX_SLI_WIN_WR_ADDR_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000000ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000020000ull;
 			return 0x0000000000020000ull;
 			break;
 	}
@@ -3346,12 +3854,16 @@ static inline uint64_t CVMX_SLI_WIN_WR_ADDR_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000000ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000000000ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000020000ull;
 			return 0x0000000000020000ull;
 	}
 	return 0x0000000000020000ull;
@@ -3366,13 +3878,17 @@ static inline uint64_t CVMX_SLI_WIN_WR_DATA_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000020ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000000020ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000020020ull;
 			return 0x0000000000020020ull;
 			break;
 	}
@@ -3388,12 +3904,16 @@ static inline uint64_t CVMX_SLI_WIN_WR_DATA_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000020ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000000020ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000020020ull;
 			return 0x0000000000020020ull;
 	}
 	return 0x0000000000020020ull;
@@ -3408,13 +3928,17 @@ static inline uint64_t CVMX_SLI_WIN_WR_MASK_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000030ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return 0x0000000000000030ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return 0x0000000000020030ull;
 			return 0x0000000000020030ull;
 			break;
 	}
@@ -3430,12 +3954,16 @@ static inline uint64_t CVMX_SLI_WIN_WR_MASK_FUNC(void)
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return 0x0000000000000030ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return 0x0000000000000030ull;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return 0x0000000000020030ull;
 			return 0x0000000000020030ull;
 	}
 	return 0x0000000000020030ull;
@@ -3697,8 +4225,8 @@ union cvmx_sli_ciu_int_enb {
 	uint64_t m2_un_wi                     : 1;  /**< Enables SLI_CIU_INT_SUM[M2_UN_WI] to generate an interrupt to the CIU. */
 	uint64_t m2_un_b0                     : 1;  /**< Enables SLI_CIU_INT_SUM[M2_UN_B0] to generate an interrupt to the CIU. */
 	uint64_t m2_up_wi                     : 1;  /**< Enables SLI_CIU_INT_SUM[M2_UP_WI] to generate an interrupt to the CIU. */
-	uint64_t m2_up_b0                     : 1;  /**< Enables SLI_CIU_INT[M2_UP_B0] to generate an interrupt to the CIU. */
-	uint64_t m1_un_wi                     : 1;  /**< Enables SLI_CIU_INT[M1_UN_WI] to generate an interrupt to the CIU. */
+	uint64_t m2_up_b0                     : 1;  /**< Enables SLI_CIU_INT_SUM[M2_UP_B0] to generate an interrupt to the CIU. */
+	uint64_t m1_un_wi                     : 1;  /**< Enables SLI_CIU_INT_SUM[M1_UN_WI] to generate an interrupt to the CIU. */
 	uint64_t m1_un_b0                     : 1;  /**< Enables SLI_CIU_INT_SUM[M1_UN_B0] to generate an interrupt to the CIU. */
 	uint64_t m1_up_wi                     : 1;  /**< Enables SLI_CIU_INT_SUM[M1_UP_WI] to generate an interrupt to the CIU. */
 	uint64_t m1_up_b0                     : 1;  /**< Enables SLI_CIU_INT_SUM[M1_UP_B0] to generate an interrupt to the CIU. */
@@ -3709,13 +4237,13 @@ union cvmx_sli_ciu_int_enb {
 	uint64_t m3p0_pppf_err                : 1;  /**< Enables SLI_CIU_INT_SUM[M3P0_PPPF_ERR] to generate an interrupt to the CIU. */
 	uint64_t m3p0_pktpf_err               : 1;  /**< Enables SLI_CIU_INT_SUM[M3P0_PKTPF_ERR] to generate an interrupt to the CIU. */
 	uint64_t m3p0_dmapf_err               : 1;  /**< Enables SLI_CIU_INT_SUM[M3P0_DMAPF_ERR] to generate an interrupt to the CIU. */
-	uint64_t m2p0_pppf_err                : 1;  /**< Enables SLI_CIU_INT[M2P0_PPPF_ERR] to generate an interrupt to the CIU. */
+	uint64_t m2p0_pppf_err                : 1;  /**< Enables SLI_CIU_INT_SUM[M2P0_PPPF_ERR] to generate an interrupt to the CIU. */
 	uint64_t m2p0_ppvf_err                : 1;  /**< Enables SLI_CIU_INT_SUM[M2P0_PPVF_ERR] to generate an interrupt to the CIU. */
 	uint64_t m2p0_pktpf_err               : 1;  /**< Enables SLI_CIU_INT_SUM[M2P0_PKTPF_ERR] to generate an interrupt to the CIU. */
 	uint64_t m2p0_pktvf_err               : 1;  /**< Enables SLI_CIU_INT_SUM[M2P0_PKTVF_ERR] to generate an interrupt to the CIU. */
 	uint64_t m2p0_dmapf_err               : 1;  /**< Enables SLI_CIU_INT_SUM[M2P0_DMAPF_ERR] to generate an interrupt to the CIU. */
-	uint64_t m2p0_dmavf_err               : 1;  /**< Enables SLI_CIU_INT[M2P0_DMAVF_ERR] to generate an interrupt to the CIU. */
-	uint64_t m1p0_pppf_err                : 1;  /**< Enables SLI_CIU_INT[M1P0_PPPF_ERR] to generate an interrupt to the CIU. */
+	uint64_t m2p0_dmavf_err               : 1;  /**< Enables SLI_CIU_INT_SUM[M2P0_DMAVF_ERR] to generate an interrupt to the CIU. */
+	uint64_t m1p0_pppf_err                : 1;  /**< Enables SLI_CIU_INT_SUM[M1P0_PPPF_ERR] to generate an interrupt to the CIU. */
 	uint64_t m1p0_pktpf_err               : 1;  /**< Enables SLI_CIU_INT_SUM[M1P0_PKTPF_ERR] to generate an interrupt to the CIU. */
 	uint64_t m1p0_dmapf_err               : 1;  /**< Enables SLI_CIU_INT_SUM[M1P0_DMAPF_ERR] to generate an interrupt to the CIU. */
 	uint64_t m0p1_pppf_err                : 1;  /**< Enables SLI_CIU_INT_SUM[M0P1_PPPF_ERR] to generate an interrupt to the CIU. */
@@ -3791,6 +4319,7 @@ union cvmx_sli_ciu_int_enb {
 #endif
 	} s;
 	struct cvmx_sli_ciu_int_enb_s         cn73xx;
+	struct cvmx_sli_ciu_int_enb_s         cn78xxp2;
 	struct cvmx_sli_ciu_int_enb_s         cnf75xx;
 };
 typedef union cvmx_sli_ciu_int_enb cvmx_sli_ciu_int_enb_t;
@@ -4041,6 +4570,7 @@ union cvmx_sli_ciu_int_sum {
 #endif
 	} s;
 	struct cvmx_sli_ciu_int_sum_s         cn73xx;
+	struct cvmx_sli_ciu_int_sum_s         cn78xxp2;
 	struct cvmx_sli_ciu_int_sum_s         cnf75xx;
 };
 typedef union cvmx_sli_ciu_int_sum cvmx_sli_ciu_int_sum_t;
@@ -5819,7 +6349,6 @@ union cvmx_sli_int_enb_portx {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} cn78xx;
-	struct cvmx_sli_int_enb_portx_cn78xx  cn78xxp2;
 	struct cvmx_sli_int_enb_portx_cn61xx  cnf71xx;
 };
 typedef union cvmx_sli_int_enb_portx cvmx_sli_int_enb_portx_t;
@@ -6726,7 +7255,6 @@ union cvmx_sli_int_sum {
 	uint64_t reserved_60_63               : 4;
 #endif
 	} cn78xx;
-	struct cvmx_sli_int_sum_cn78xx        cn78xxp2;
 	struct cvmx_sli_int_sum_cn61xx        cnf71xx;
 };
 typedef union cvmx_sli_int_sum cvmx_sli_int_sum_t;
@@ -6850,6 +7378,7 @@ union cvmx_sli_macx_pfx_dma_vf_int {
 #endif
 	} s;
 	struct cvmx_sli_macx_pfx_dma_vf_int_s cn73xx;
+	struct cvmx_sli_macx_pfx_dma_vf_int_s cn78xxp2;
 	struct cvmx_sli_macx_pfx_dma_vf_int_s cnf75xx;
 };
 typedef union cvmx_sli_macx_pfx_dma_vf_int cvmx_sli_macx_pfx_dma_vf_int_t;
@@ -6870,6 +7399,7 @@ union cvmx_sli_macx_pfx_dma_vf_int_enb {
 #endif
 	} s;
 	struct cvmx_sli_macx_pfx_dma_vf_int_enb_s cn73xx;
+	struct cvmx_sli_macx_pfx_dma_vf_int_enb_s cn78xxp2;
 	struct cvmx_sli_macx_pfx_dma_vf_int_enb_s cnf75xx;
 };
 typedef union cvmx_sli_macx_pfx_dma_vf_int_enb cvmx_sli_macx_pfx_dma_vf_int_enb_t;
@@ -6890,6 +7420,7 @@ union cvmx_sli_macx_pfx_flr_vf_int {
 #endif
 	} s;
 	struct cvmx_sli_macx_pfx_flr_vf_int_s cn73xx;
+	struct cvmx_sli_macx_pfx_flr_vf_int_s cn78xxp2;
 	struct cvmx_sli_macx_pfx_flr_vf_int_s cnf75xx;
 };
 typedef union cvmx_sli_macx_pfx_flr_vf_int cvmx_sli_macx_pfx_flr_vf_int_t;
@@ -6973,6 +7504,7 @@ union cvmx_sli_macx_pfx_int_enb {
 #endif
 	} s;
 	struct cvmx_sli_macx_pfx_int_enb_s    cn73xx;
+	struct cvmx_sli_macx_pfx_int_enb_s    cn78xxp2;
 	struct cvmx_sli_macx_pfx_int_enb_s    cnf75xx;
 };
 typedef union cvmx_sli_macx_pfx_int_enb cvmx_sli_macx_pfx_int_enb_t;
@@ -7080,6 +7612,7 @@ union cvmx_sli_macx_pfx_int_sum {
 #endif
 	} s;
 	struct cvmx_sli_macx_pfx_int_sum_s    cn73xx;
+	struct cvmx_sli_macx_pfx_int_sum_s    cn78xxp2;
 	struct cvmx_sli_macx_pfx_int_sum_s    cnf75xx;
 };
 typedef union cvmx_sli_macx_pfx_int_sum cvmx_sli_macx_pfx_int_sum_t;
@@ -7102,6 +7635,7 @@ union cvmx_sli_macx_pfx_mbox_int {
 #endif
 	} s;
 	struct cvmx_sli_macx_pfx_mbox_int_s   cn73xx;
+	struct cvmx_sli_macx_pfx_mbox_int_s   cn78xxp2;
 	struct cvmx_sli_macx_pfx_mbox_int_s   cnf75xx;
 };
 typedef union cvmx_sli_macx_pfx_mbox_int cvmx_sli_macx_pfx_mbox_int_t;
@@ -7127,6 +7661,7 @@ union cvmx_sli_macx_pfx_pkt_vf_int {
 #endif
 	} s;
 	struct cvmx_sli_macx_pfx_pkt_vf_int_s cn73xx;
+	struct cvmx_sli_macx_pfx_pkt_vf_int_s cn78xxp2;
 	struct cvmx_sli_macx_pfx_pkt_vf_int_s cnf75xx;
 };
 typedef union cvmx_sli_macx_pfx_pkt_vf_int cvmx_sli_macx_pfx_pkt_vf_int_t;
@@ -7147,6 +7682,7 @@ union cvmx_sli_macx_pfx_pkt_vf_int_enb {
 #endif
 	} s;
 	struct cvmx_sli_macx_pfx_pkt_vf_int_enb_s cn73xx;
+	struct cvmx_sli_macx_pfx_pkt_vf_int_enb_s cn78xxp2;
 	struct cvmx_sli_macx_pfx_pkt_vf_int_enb_s cnf75xx;
 };
 typedef union cvmx_sli_macx_pfx_pkt_vf_int_enb cvmx_sli_macx_pfx_pkt_vf_int_enb_t;
@@ -7170,6 +7706,7 @@ union cvmx_sli_macx_pfx_pp_vf_int {
 #endif
 	} s;
 	struct cvmx_sli_macx_pfx_pp_vf_int_s  cn73xx;
+	struct cvmx_sli_macx_pfx_pp_vf_int_s  cn78xxp2;
 	struct cvmx_sli_macx_pfx_pp_vf_int_s  cnf75xx;
 };
 typedef union cvmx_sli_macx_pfx_pp_vf_int cvmx_sli_macx_pfx_pp_vf_int_t;
@@ -7190,6 +7727,7 @@ union cvmx_sli_macx_pfx_pp_vf_int_enb {
 #endif
 	} s;
 	struct cvmx_sli_macx_pfx_pp_vf_int_enb_s cn73xx;
+	struct cvmx_sli_macx_pfx_pp_vf_int_enb_s cn78xxp2;
 	struct cvmx_sli_macx_pfx_pp_vf_int_enb_s cnf75xx;
 };
 typedef union cvmx_sli_macx_pfx_pp_vf_int_enb cvmx_sli_macx_pfx_pp_vf_int_enb_t;
@@ -7383,7 +7921,9 @@ union cvmx_sli_mem_access_ctl {
 	uint64_t reserved_14_63               : 50;
 	uint64_t max_word                     : 4;  /**< Maximum number of words. Specifies the maximum number of words to merge into a single
                                                          write operation from the cores to the MAC. Legal values are 1 to 16, with 0 treated as 16. */
-	uint64_t timer                        : 10; /**< N/A */
+	uint64_t timer                        : 10; /**< Merge timer. When the SLI starts a core-to-MAC write, TIMER specifies the maximum wait, in
+                                                         coprocessor-clock cycles, to merge additional write operations from the cores into one
+                                                         large write. The values for this field range from 1 to 1024, with 0 treated as 1024. */
 #else
 	uint64_t timer                        : 10;
 	uint64_t max_word                     : 4;
@@ -7439,14 +7979,14 @@ union cvmx_sli_mem_access_subidx {
                                                            * ADDRTYPE<0> is the relaxed-order attribute.
                                                            * ADDRTYPE<1> is the no-snoop attribute.
                                                          For SRIO:
-                                                           * ADDRTYPE<1:0> help select an SRIO*_S2M_TYPE* entry.
+                                                           * ADDRTYPE<1:0> help select an SRIO()_S2M_TYPE() entry.
                                                          Not used for reads and IOBDMAs. */
 	uint64_t rtype                        : 2;  /**< Read type. ADDRTYPE<1:0> for read operations to this subID.
                                                          For PCIE:
                                                            * ADDRTYPE<0> is the relaxed-order attribute.
                                                            * ADDRTYPE<1> is the no-snoop attribute.
                                                          For SRIO:
-                                                           * ADDRTYPE<1:0> help select an SRIO*_S2M_TYPE* entry.
+                                                           * ADDRTYPE<1:0> help select an SRIO()_S2M_TYPE() entry.
                                                          Not used for writes and atomics. */
 	uint64_t reserved_0_29                : 30;
 #else
@@ -7597,7 +8137,7 @@ union cvmx_sli_mem_access_subidx {
 #endif
 	} cn73xx;
 	struct cvmx_sli_mem_access_subidx_cn61xx cn78xx;
-	struct cvmx_sli_mem_access_subidx_cn61xx cn78xxp2;
+	struct cvmx_sli_mem_access_subidx_cn73xx cn78xxp2;
 	struct cvmx_sli_mem_access_subidx_cn61xx cnf71xx;
 	struct cvmx_sli_mem_access_subidx_cn73xx cnf75xx;
 };
@@ -8354,7 +8894,6 @@ union cvmx_sli_msix_macx_pf_table_addr {
 #endif
 	} s;
 	struct cvmx_sli_msix_macx_pf_table_addr_s cn78xx;
-	struct cvmx_sli_msix_macx_pf_table_addr_s cn78xxp2;
 };
 typedef union cvmx_sli_msix_macx_pf_table_addr cvmx_sli_msix_macx_pf_table_addr_t;
 
@@ -8378,7 +8917,6 @@ union cvmx_sli_msix_macx_pf_table_data {
 #endif
 	} s;
 	struct cvmx_sli_msix_macx_pf_table_data_s cn78xx;
-	struct cvmx_sli_msix_macx_pf_table_data_s cn78xxp2;
 };
 typedef union cvmx_sli_msix_macx_pf_table_data cvmx_sli_msix_macx_pf_table_data_t;
 
@@ -8482,6 +9020,7 @@ union cvmx_sli_nqm_rsp_err_snd_dbg {
 #endif
 	} s;
 	struct cvmx_sli_nqm_rsp_err_snd_dbg_s cn73xx;
+	struct cvmx_sli_nqm_rsp_err_snd_dbg_s cn78xxp2;
 	struct cvmx_sli_nqm_rsp_err_snd_dbg_s cnf75xx;
 };
 typedef union cvmx_sli_nqm_rsp_err_snd_dbg cvmx_sli_nqm_rsp_err_snd_dbg_t;
@@ -8772,7 +9311,7 @@ union cvmx_sli_pktx_cnts {
 	uint64_t po_int                       : 1;
 #endif
 	} cn78xx;
-	struct cvmx_sli_pktx_cnts_cn78xx      cn78xxp2;
+	struct cvmx_sli_pktx_cnts_s           cn78xxp2;
 	struct cvmx_sli_pktx_cnts_cn61xx      cnf71xx;
 	struct cvmx_sli_pktx_cnts_s           cnf75xx;
 };
@@ -8817,6 +9356,7 @@ union cvmx_sli_pktx_error_info {
 #endif
 	} s;
 	struct cvmx_sli_pktx_error_info_s     cn73xx;
+	struct cvmx_sli_pktx_error_info_s     cn78xxp2;
 	struct cvmx_sli_pktx_error_info_s     cnf75xx;
 };
 typedef union cvmx_sli_pktx_error_info cvmx_sli_pktx_error_info_t;
@@ -8893,7 +9433,7 @@ union cvmx_sli_pktx_input_control {
                                                          response for a read associated with the rings.
                                                          [RST] applies to both this input ring and to the output ring of the same
                                                          index.
-                                                         Software canot clear [RST] from 1->0 until the [QUIET] bit is a 1.
+                                                         Software must not clear [RST] from 1->0 until the [QUIET] bit is a 1.
                                                          A ring reset may clear all state associated with the input and
                                                          output rings, so software must completely re-initialize both
                                                          before reusing them.
@@ -8904,33 +9444,34 @@ union cvmx_sli_pktx_input_control {
                                                          only write [ENB] to a 1 once [QUIET] is a 1.
                                                          In the PF, [ENB] is also SLI_PKT_INSTR_ENB<i>. */
 	uint64_t pbp_dhi                      : 13; /**< Not used by hardware, but may be cleared by hardware when [RST] is set. */
-	uint64_t d_nsr                        : 1;  /**< If [USE_CSR]=1, [D_NSR] is ADDRTYPE<1> for First Direct and Gather DPTR
-                                                         reads. ADDRTYPE<1> is the no-snoop attribute for PCIe. (DPTR Format 0)
-                                                         ADDRTYPE<1> helps select an SRIO*_S2M_TYPE* entry with sRIO.
-                                                         If [USE_CSR]=0, [D_NSR] is MACADD<61> for First Direct and Gather DPTR
-                                                         reads. (ADDRTYPE<1> comes from DPTR<61> in these cases when [USE_CSR]=0.)
-                                                         (DPTR Format 1) */
-	uint64_t d_esr                        : 2;  /**< If [USE_CSR]=1, [D_ESR] is ES<1:0> for First Direct and Gather DPTR reads.
-                                                         ES<1:0> is the endian-swap attribute for these MAC memory space reads.
-                                                         Enumerated by SLI_ENDIANSWAP_E.
-                                                         (DPTR Format 0)
-                                                         If [USE_CSR]=0, [D_NSR] is MACADD<63:62> for First Direct and Gather DPTR
-                                                         reads. (ES<1:0> comes from DPTR<63:62> in these cases when [USE_CSR]=0.)
-                                                         (DPTR Format 1) */
-	uint64_t d_ror                        : 1;  /**< If [USE_CSR]=1, [D_ROR] is ADDRTYPE<0> for First Direct and Gather DPTR
-                                                         reads. ADDRTYPE<0> is the relaxed-order attribute for PCIe. (DPTR Format 0)
-                                                         It helps select an SRIO*_S2M_TYPE* entry with sRIO.
-                                                         If [USE_CSR]=0, [D_NSR] is MACADD<60> for First Direct and Gather DPTR
-                                                         reads. (ADDRTYPE<0> comes from DPTR<60> in these cases when [USE_CSR]=0.)
-                                                         (DPTR Format 1) */
+	uint64_t d_nsr                        : 1;  /**< If [USE_CSR]=1 (DPTR Format 0), [D_NSR] is ADDRTYPE<1> for First Direct and
+                                                         Gather DPTR reads. ADDRTYPE<1> is the no-snoop attribute for PCIe.
+                                                         ADDRTYPE<1> helps select an SRIO()_S2M_TYPE() entry with sRIO.
+                                                         If [USE_CSR]=0 (DPTR Format 1), [D_NSR] is MACADD<61> for First Direct and
+                                                         Gather DPTR reads. (ADDRTYPE<1> comes from DPTR<61> in these cases when
+                                                         [USE_CSR]=0.) */
+	uint64_t d_esr                        : 2;  /**< If [USE_CSR]=1 (DPTR Format 0), [D_ESR] is ES<1:0> for First Direct and Gather
+                                                         DPTR reads. ES<1:0> is the endian-swap attribute for these MAC memory space
+                                                         reads. Enumerated by SLI_ENDIANSWAP_E.
+                                                         If [USE_CSR]=0 (DPTR Format 1), [D_NSR] is MACADD<63:62> for First Direct and
+                                                         Gather DPTR reads. (ES<1:0> comes from DPTR<63:62> in these cases when
+                                                         [USE_CSR]=0.) */
+	uint64_t d_ror                        : 1;  /**< If [USE_CSR]=1 (DPTR Format 0), [D_ROR] is ADDRTYPE<0> for First Direct and
+                                                         Gather DPTR reads. ADDRTYPE<0> is the relaxed-order attribute for PCIe. It helps
+                                                         select an SRIO()_S2M_TYPE() entry with sRIO.
+                                                         If [USE_CSR]=0 (DPTR Format 1), [D_NSR] is MACADD<60> for First Direct and
+                                                         Gather DPTR reads. (ADDRTYPE<0> comes from DPTR<60> in these cases when
+                                                         [USE_CSR]=0.) */
 	uint64_t use_csr                      : 1;  /**< When set to 1, [D_ROR], [D_ESR], and [D_NSR] are used for ROR, ESR, and NSR,
-                                                         respectively. (DPTR Format 0) When clear to 0, <63:60> from a First Direct
-                                                         or Gather DPTR are used. (DPTR Format 1) The bits not used for ROR, ESR,
-                                                         and NSR become bits <63:60> of the address used to fetch packet data. */
+                                                         respectively.
+                                                         (DPTR Format 0) When clear to 0, <63:60> from a First Direct or Gather DPTR are
+                                                         used.
+                                                         (DPTR Format 1) The bits not used for ROR, ESR, and NSR become bits <63:60> of
+                                                         the address used to fetch packet data. */
 	uint64_t nsr                          : 1;  /**< [NSR] is ADDRTYPE<1> for input instruction reads (from
                                                          SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads. ADDRTYPE<1>
                                                          is the no-snoop attribute for PCIe.
-                                                         [NSR] helps select an SRIO*_S2M_TYPE* entry with sRIO. */
+                                                         [NSR] helps select an SRIO()_S2M_TYPE() entry with sRIO. */
 	uint64_t esr                          : 2;  /**< [ESR] is ES<1:0> for input instruction reads (from
                                                          SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads. ES<1:0> is
                                                          the endian-swap attribute for these MAC memory space reads.
@@ -8938,7 +9479,7 @@ union cvmx_sli_pktx_input_control {
 	uint64_t ror                          : 1;  /**< [ROR] is ADDRTYPE<0> for input instruction reads (from
                                                          SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads.
                                                          ADDRTYPE<0> is the relaxed-order attribute for PCIe.
-                                                         It helps select an SRIO*_S2M_TYPE* entry with sRIO. */
+                                                         It helps select an SRIO()_S2M_TYPE() entry with sRIO. */
 #else
 	uint64_t ror                          : 1;
 	uint64_t esr                          : 2;
@@ -8995,7 +9536,7 @@ union cvmx_sli_pktx_input_control {
                                                          response for a read associated with the rings.
                                                          [RST] applies to both this input ring and to the output ring of the same
                                                          index.
-                                                         Software canot clear [RST] from 1->0 until the [QUIET] bit is a 1.
+                                                         Software must not clear [RST] from 1->0 until the [QUIET] bit is a 1.
                                                          A ring reset may clear all state associated with the input and
                                                          output rings, so software must completely re-initialize both
                                                          before reusing them.
@@ -9011,22 +9552,23 @@ union cvmx_sli_pktx_input_control {
                                                          If [USE_CSR]=0, [D_NSR] is MACADD<61> for First Direct and Gather DPTR
                                                          reads. (ADDRTYPE<1> comes from DPTR<61> in these cases when [USE_CSR]=0.)
                                                          (DPTR Format 1) */
-	uint64_t d_esr                        : 2;  /**< If [USE_CSR]=1, [D_ESR] is ES<1:0> for First Direct and Gather DPTR reads.
-                                                         ES<1:0> is the endian-swap attribute for these MAC memory space reads.
-                                                         Enumerated by SLI_ENDIANSWAP_E.
-                                                         (DPTR Format 0)
-                                                         If [USE_CSR]=0, [D_NSR] is MACADD<63:62> for First Direct and Gather DPTR
-                                                         reads. (ES<1:0> comes from DPTR<63:62> in these cases when [USE_CSR]=0.)
-                                                         (DPTR Format 1) */
+	uint64_t d_esr                        : 2;  /**< If [USE_CSR]=1 (DPTR Format 0), [D_ESR] is ES<1:0> for First Direct and Gather
+                                                         DPTR reads. ES<1:0> is the endian-swap attribute for these MAC memory space
+                                                         reads. Enumerated by SLI_ENDIANSWAP_E.
+                                                         If [USE_CSR]=0 (DPTR Format 1), [D_NSR] is MACADD<63:62> for First Direct and
+                                                         Gather DPTR reads. (ES<1:0> comes from DPTR<63:62> in these cases when
+                                                         [USE_CSR]=0.) */
 	uint64_t d_ror                        : 1;  /**< If [USE_CSR]=1, [D_ROR] is ADDRTYPE<0> for First Direct and Gather DPTR
                                                          reads. ADDRTYPE<0> is the relaxed-order attribute for PCIe. (DPTR Format 0)
                                                          If [USE_CSR]=0, [D_NSR] is MACADD<60> for First Direct and Gather DPTR
                                                          reads. (ADDRTYPE<0> comes from DPTR<60> in these cases when [USE_CSR]=0.)
                                                          (DPTR Format 1) */
 	uint64_t use_csr                      : 1;  /**< When set to 1, [D_ROR], [D_ESR], and [D_NSR] are used for ROR, ESR, and NSR,
-                                                         respectively. (DPTR Format 0) When clear to 0, <63:60> from a First Direct
-                                                         or Gather DPTR are used. (DPTR Format 1) The bits not used for ROR, ESR,
-                                                         and NSR become bits <63:60> of the address used to fetch packet data. */
+                                                         respectively.
+                                                         (DPTR Format 0) When clear to 0, <63:60> from a First Direct or Gather DPTR are
+                                                         used.
+                                                         (DPTR Format 1) The bits not used for ROR, ESR, and NSR become bits <63:60> of
+                                                         the address used to fetch packet data. */
 	uint64_t nsr                          : 1;  /**< [NSR] is ADDRTYPE<1> for input instruction reads (from
                                                          SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads. ADDRTYPE<1>
                                                          is the no-snoop attribute for PCIe. */
@@ -9083,14 +9625,14 @@ union cvmx_sli_pktx_input_control {
                                                          0x1 = 2 Instructions.
                                                          0x2 = 3 Instructions.
                                                          0x3 = 4 Instructions. */
-	uint64_t is_64b                       : 1;  /**< When IS_64B=1, instruction input ring i uses 64B. */
+	uint64_t is_64b                       : 1;  /**< When IS_64B=1, instruction input ring i uses 64B versus 32B. */
 	uint64_t rst                          : 1;  /**< Packet reset. When [RST]=1, the rings are in reset. [RST] can be set
                                                          by software writing a 1 to the field, by hardware upon receipt of an
                                                          FLR to an associated function, or by hardware when it receives an error
                                                          response for a read associated with the rings.
                                                          [MAC_NUM] applies to both this input ring and to the output ring of the same
                                                          index.
-                                                         Software should not clear [RST] from 1->0 until [RST] has been asserted
+                                                         Software must not clear [RST] from 1->0 until [RST] has been asserted
                                                          for at least 2ms. A ring reset may clear all state associated with the
                                                          input and output rings, so software must completely re-initialize both
                                                          before reusing them.
@@ -9099,32 +9641,35 @@ union cvmx_sli_pktx_input_control {
                                                          [ENB] clear.
                                                          In the PF, [ENB] is also SLI_PKT_INSTR_ENB<i>. */
 	uint64_t pbp_dhi                      : 13; /**< Not used by hardware, but may be cleared by hardware when [RST] is set. */
-	uint64_t d_nsr                        : 1;  /**< If [USE_CSR]=1, [D_NSR] is ADDRTYPE<1> for First Direct and Gather DPTR
-                                                         reads. ADDRTYPE<1> is the no-snoop attribute for PCIe. (DPTR Format 0)
-                                                         If [USE_CSR]=0, [D_NSR] is MACADD<61> for First Direct and Gather DPTR
-                                                         reads. (ADDRTYPE<1> comes from DPTR<61> in these cases when [USE_CSR]=0.)
-                                                         (DPTR Format 1) */
-	uint64_t d_esr                        : 2;  /**< If [USE_CSR]=1, [D_ESR] is ES<1:0> for First Direct and Gather DPTR reads.
-                                                         ES<1:0> is the endian-swap attribute for these MAC memory space reads.
-                                                         (DPTR Format 0)
-                                                         If [USE_CSR]=0, [D_NSR] is MACADD<63:62> for First Direct and Gather DPTR
-                                                         reads. (ES<1:0> comes from DPTR<63:62> in these cases when [USE_CSR]=0.)
-                                                         (DPTR Format 1) */
-	uint64_t d_ror                        : 1;  /**< If [USE_CSR]=1, [D_ROR] is ADDRTYPE<0> for First Direct and Gather DPTR
-                                                         reads. ADDRTYPE<0> is the relaxed-order attribute for PCIe. (DPTR Format 0)
-                                                         If [USE_CSR]=0, [D_NSR] is MACADD<60> for First Direct and Gather DPTR
-                                                         reads. (ADDRTYPE<0> comes from DPTR<60> in these cases when [USE_CSR]=0.)
-                                                         (DPTR Format 1) */
+	uint64_t d_nsr                        : 1;  /**< If [USE_CSR]=1 (DPTR Format 0), [D_NSR] is ADDRTYPE<1> for First Direct and
+                                                         Gather DPTR reads. ADDRTYPE<1> is the no-snoop attribute for PCIe.
+                                                         If [USE_CSR]=0 (DPTR Format 1), [D_NSR] is MACADD<61> for First Direct and
+                                                         Gather DPTR reads. (ADDRTYPE<1> comes from DPTR<61> in these cases when
+                                                         [USE_CSR]=0.) */
+	uint64_t d_esr                        : 2;  /**< If [USE_CSR]=1 (DPTR Format 0), [D_ESR] is ES<1:0> for First Direct and Gather
+                                                         DPTR reads. ES<1:0> is the endian-swap attribute for these MAC memory space
+                                                         reads. Enumerated by SLI_ENDIANSWAP_E.
+                                                         If [USE_CSR]=0 (DPTR Format 1), [D_NSR] is MACADD<63:62> for First Direct and
+                                                         Gather DPTR reads. (ES<1:0> comes from DPTR<63:62> in these cases when
+                                                         [USE_CSR]=0.) */
+	uint64_t d_ror                        : 1;  /**< If [USE_CSR]=1 (DPTR Format 0), [D_ROR] is ADDRTYPE<0> for First Direct and
+                                                         Gather DPTR reads. ADDRTYPE<0> is the relaxed-order attribute for PCIe.
+                                                         If [USE_CSR]=0 (DPTR Format 1), [D_NSR] is MACADD<60> for First Direct and
+                                                         Gather DPTR reads. (ADDRTYPE<0> comes from DPTR<60> in these cases when
+                                                         [USE_CSR]=0.) */
 	uint64_t use_csr                      : 1;  /**< When set to 1, [D_ROR], [D_ESR], and [D_NSR] are used for ROR, ESR, and NSR,
-                                                         respectively. (DPTR Format 0) When clear to 0, <63:60> from a First Direct
-                                                         or Gather DPTR are used. (DPTR Format 1) The bits not used for ROR, ESR,
-                                                         and NSR become bits <63:60> of the address used to fetch packet data. */
+                                                         respectively.
+                                                         (DPTR Format 0) When clear to 0, <63:60> from a First Direct or Gather DPTR are
+                                                         used.
+                                                         (DPTR Format 1) The bits not used for ROR, ESR, and NSR become bits <63:60> of
+                                                         the address used to fetch packet data. */
 	uint64_t nsr                          : 1;  /**< [NSR] is ADDRTYPE<1> for input instruction reads (from
                                                          SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads. ADDRTYPE<1>
                                                          is the no-snoop attribute for PCIe. */
 	uint64_t esr                          : 2;  /**< [ESR] is ES<1:0> for input instruction reads (from
                                                          SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads. ES<1:0> is
-                                                         the endian-swap attribute for these MAC memory space reads. */
+                                                         the endian-swap attribute for these MAC memory space reads.
+                                                         Enumerated by SLI_ENDIANSWAP_E. */
 	uint64_t ror                          : 1;  /**< [ROR] is ADDRTYPE<0> for input instruction reads (from
                                                          SLI_PKT()_INSTR_BADDR+) and First Indirect DPTR reads.
                                                          ADDRTYPE<0> is the relaxed-order attribute for PCIe. */
@@ -9148,7 +9693,7 @@ union cvmx_sli_pktx_input_control {
 	uint64_t reserved_39_63               : 25;
 #endif
 	} cn78xx;
-	struct cvmx_sli_pktx_input_control_cn78xx cn78xxp2;
+	struct cvmx_sli_pktx_input_control_cn73xx cn78xxp2;
 	struct cvmx_sli_pktx_input_control_cn73xx cnf75xx;
 };
 typedef union cvmx_sli_pktx_input_control cvmx_sli_pktx_input_control_t;
@@ -9559,6 +10104,7 @@ union cvmx_sli_pktx_mbox_int {
 #endif
 	} s;
 	struct cvmx_sli_pktx_mbox_int_s       cn73xx;
+	struct cvmx_sli_pktx_mbox_int_s       cn78xxp2;
 	struct cvmx_sli_pktx_mbox_int_s       cnf75xx;
 };
 typedef union cvmx_sli_pktx_mbox_int cvmx_sli_pktx_mbox_int_t;
@@ -9575,7 +10121,7 @@ union cvmx_sli_pktx_out_size {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_23_63               : 41;
 	uint64_t isize                        : 7;  /**< Info bytes size (bytes) for this ring. Legal sizes are 0 to 120. Not used in buffer-
-                                                         pointer-only mode. Writes of [ISIZE] greater than 120 will set [ISIZE] to 120. */
+                                                         pointer-only mode. */
 	uint64_t bsize                        : 16; /**< Buffer size (bytes) for this ring. Legal values have to be greater then 128.
                                                          Writes of [BSIZE] less than 128 will set [BSIZE] to 128. */
 #else
@@ -9592,11 +10138,23 @@ union cvmx_sli_pktx_out_size {
 	struct cvmx_sli_pktx_out_size_s       cn68xxp1;
 	struct cvmx_sli_pktx_out_size_s       cn70xx;
 	struct cvmx_sli_pktx_out_size_s       cn70xxp1;
-	struct cvmx_sli_pktx_out_size_s       cn73xx;
+	struct cvmx_sli_pktx_out_size_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_22_63               : 42;
+	uint64_t isize                        : 6;  /**< Info bytes size (bytes) for this ring. Legal sizes are 0 to 120. Not used in buffer-
+                                                         pointer-only mode. */
+	uint64_t bsize                        : 16; /**< Buffer size (bytes) for this ring. Legal values have to be greater then 128.
+                                                         Writes of [BSIZE] less than 128 will set [BSIZE] to 128. */
+#else
+	uint64_t bsize                        : 16;
+	uint64_t isize                        : 6;
+	uint64_t reserved_22_63               : 42;
+#endif
+	} cn73xx;
 	struct cvmx_sli_pktx_out_size_s       cn78xx;
-	struct cvmx_sli_pktx_out_size_s       cn78xxp2;
+	struct cvmx_sli_pktx_out_size_cn73xx  cn78xxp2;
 	struct cvmx_sli_pktx_out_size_s       cnf71xx;
-	struct cvmx_sli_pktx_out_size_s       cnf75xx;
+	struct cvmx_sli_pktx_out_size_cn73xx  cnf75xx;
 };
 typedef union cvmx_sli_pktx_out_size cvmx_sli_pktx_out_size_t;
 
@@ -9631,27 +10189,27 @@ union cvmx_sli_pktx_output_control {
                                                          has no effect on any non-SLI_MAC()_PF()_INT_SUM interrupt. */
 	uint64_t iptr                         : 1;  /**< When IPTR=1, packet output ring is in info-pointer mode; otherwise the packet output ring
                                                          is in buffer-pointer-only mode. */
-	uint64_t es                           : 2;  /**< If [DPTR]=1, [ES] is ES<1:0> for buffer/info write operations to buffer/info
-                                                         pair MAC memory space addresses fetched from packet output ring. ES<1:0> is the
-                                                         endian-swap attribute for these MAC memory space writes. (DPTR Format 0)
-                                                         If [DPTR]=0, [ES] is MACADD<63:62> for buffer/info write operations to buffer/info
-                                                         pair MAC memory space addresses fetched from packet output ring. (<63:62> of the
-                                                         buffer or info pointer is ES<1:0> for the writes in this case when [DPTR]=0.)
-                                                         (DPTR Format 1) */
-	uint64_t nsr                          : 1;  /**< If [DPTR]=1, [NSR] is ADDRTYPE<1> for buffer/info write operations to buffer/info
-                                                         pair MAC memory space addresses fetched from packet output ring. ADDRTYPE<1> is
-                                                         the no-snoop attribute for PCIe. (DPTR Format 0)
-                                                         If [DPTR]=0, [NSR] is MACADD<61> for buffer/info write operations to buffer/info
-                                                         pair MAC memory space addresses fetched from packet output ring. (<61> of the
-                                                         buffer or info pointer is ADDRTYPE<1> for the writes in this case when [DPTR]=0.)
-                                                         (DPTR Format 1) */
-	uint64_t ror                          : 1;  /**< If [DPTR]=1, [ROR] is ADDRTYPE<0> for buffer/info write operations to buffer/info
-                                                         pair MAC memory space addresses fetched from packet output ring. ADDRTYPE<0> is
-                                                         the relaxed-order attribute for PCIe. (DPTR Format 0)
-                                                         If [DPTR]=0, [ROR] is MACADD<60> for buffer/info write operations to buffer/info
-                                                         pair MAC memory space addresses fetched from packet output ring. (<60> of the
-                                                         buffer or info pointer is ADDRTYPE<0> for the writes in this case when [DPTR]=0.)
-                                                         (DPTR Format 1) */
+	uint64_t es                           : 2;  /**< If [DPTR]=1 (DPTR Format 0), [ES] is ES<1:0> for buffer/info write operations to
+                                                         buffer/info pair MAC memory space addresses fetched from packet output
+                                                         ring. ES<1:0> is the endian-swap attribute for these MAC memory space writes.
+                                                         If [DPTR]=0 (DPTR Format 1), [ES] is MACADD<63:62> for buffer/info write
+                                                         operations to buffer/info pair MAC memory space addresses fetched from packet
+                                                         output ring. (<63:62> of the buffer or info pointer is ES<1:0> for the writes in
+                                                         this case when [DPTR]=0.) */
+	uint64_t nsr                          : 1;  /**< If [DPTR]=1 (DPTR Format 0), [NSR] is ADDRTYPE<1> for buffer/info write
+                                                         operations to buffer/info pair MAC memory space addresses fetched from packet
+                                                         output ring. ADDRTYPE<1> is the no-snoop attribute for PCIe.
+                                                         If [DPTR]=0 (DPTR Format 1), [NSR] is MACADD<61> for buffer/info write
+                                                         operations to buffer/info pair MAC memory space addresses fetched from packet
+                                                         output ring. (<61> of the buffer or info pointer is ADDRTYPE<1> for the writes
+                                                         in this case when [DPTR]=0.) */
+	uint64_t ror                          : 1;  /**< If [DPTR]=1 (DPTR Format 0), [ROR] is ADDRTYPE<0> for buffer/info write
+                                                         operations to buffer/info pair MAC memory space addresses fetched from packet
+                                                         output ring. ADDRTYPE<0> is the relaxed-order attribute for PCIe.
+                                                         If [DPTR]=0 (DPTR Format 1), [ROR] is MACADD<60> for buffer/info write
+                                                         operations to buffer/info pair MAC memory space addresses fetched from packet
+                                                         output ring. (<60> of the buffer or info pointer is ADDRTYPE<0> for the writes
+                                                         in this case when [DPTR]=0.) */
 	uint64_t dptr                         : 1;  /**< Determines [ES,NSR,ROR] usage and the format of buffer/info pointers. When set,
                                                          buffer/info pointers are DPTR format 0. When clear, buffer/info pointers
                                                          are DPTR format 1. */
@@ -9715,10 +10273,6 @@ typedef union cvmx_sli_pktx_output_control cvmx_sli_pktx_output_control_t;
  * Each PF and VF can only access the rings that its owns as programmed by SLI_PKT_MAC()_RINFO.
  * The signaling is ring based. If a VF owns more than one ring it can ignore the other
  * rings registers if not needed.
- *
- * INTERNAL:
- *   VERIF - PF Write SIG0 interrupts VF owning the same ring. VF Write SIG0 no interrupt.
- *   VERIF - VF Write SIG1 interrupts PF owning the same ring. PF Write SIG1 no interrupt.
  */
 union cvmx_sli_pktx_pf_vf_mbox_sigx {
 	uint64_t u64;
@@ -9731,6 +10285,7 @@ union cvmx_sli_pktx_pf_vf_mbox_sigx {
 #endif
 	} s;
 	struct cvmx_sli_pktx_pf_vf_mbox_sigx_s cn73xx;
+	struct cvmx_sli_pktx_pf_vf_mbox_sigx_s cn78xxp2;
 	struct cvmx_sli_pktx_pf_vf_mbox_sigx_s cnf75xx;
 };
 typedef union cvmx_sli_pktx_pf_vf_mbox_sigx cvmx_sli_pktx_pf_vf_mbox_sigx_t;
@@ -9879,6 +10434,7 @@ union cvmx_sli_pktx_vf_int_sum {
 #endif
 	} s;
 	struct cvmx_sli_pktx_vf_int_sum_s     cn73xx;
+	struct cvmx_sli_pktx_vf_int_sum_s     cn78xxp2;
 	struct cvmx_sli_pktx_vf_int_sum_s     cnf75xx;
 };
 typedef union cvmx_sli_pktx_vf_int_sum cvmx_sli_pktx_vf_int_sum_t;
@@ -9899,7 +10455,6 @@ union cvmx_sli_pktx_vf_sig {
 #endif
 	} s;
 	struct cvmx_sli_pktx_vf_sig_s         cn78xx;
-	struct cvmx_sli_pktx_vf_sig_s         cn78xxp2;
 };
 typedef union cvmx_sli_pktx_vf_sig cvmx_sli_pktx_vf_sig_t;
 
@@ -9914,36 +10469,14 @@ union cvmx_sli_pkt_bist_status {
 	struct cvmx_sli_pkt_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_22_63               : 42;
-	uint64_t bist                         : 22; /**< BIST results. Hardware sets a bit in BIST for memory that fails.
-                                                         INTERNAL:
-                                                           poi_fifo_status,
-                                                           psf_fifo_status,
-                                                           pdf_fifo_status,
-                                                           pbn_fifo_status,
-                                                           pfp_fifo_status,
-                                                           pcsr_pout_size_bstatus,
-                                                           gii_imem_bstatus,
-                                                           pcsr_in_done_bstatus,
-                                                           pcsr_instr_mem_bstatus,
-                                                           pcsr_slist_bstatus,
-                                                           pfm_mem_bstatus,
-                                                           pif_fifo_bstatus,
-                                                           msix_mailbox_bstatus,
-                                                           msix_vfdata_bstatus | msix_vfaddr_bstatus,
-                                                           pop_mem0_bstatus,
-                                                           pop_mem1_bstatus,
-                                                           pout_int_bstatus,
-                                                           prd_gdata_fifo_bstatus,
-                                                           prd_glist_rd_fifo_bstatus,
-                                                           prd_pblk_rd_fifo_bstatus,
-                                                           prd_pkt_rd_fifo_bstatus,
-                                                           pwc_ififo_bstatus */
+	uint64_t bist                         : 22; /**< BIST results. Hardware sets a bit in BIST for memory that fails. */
 #else
 	uint64_t bist                         : 22;
 	uint64_t reserved_22_63               : 42;
 #endif
 	} s;
 	struct cvmx_sli_pkt_bist_status_s     cn73xx;
+	struct cvmx_sli_pkt_bist_status_s     cn78xxp2;
 	struct cvmx_sli_pkt_bist_status_s     cnf75xx;
 };
 typedef union cvmx_sli_pkt_bist_status cvmx_sli_pkt_bist_status_t;
@@ -10266,6 +10799,7 @@ union cvmx_sli_pkt_gbl_control {
 #endif
 	} s;
 	struct cvmx_sli_pkt_gbl_control_s     cn73xx;
+	struct cvmx_sli_pkt_gbl_control_s     cn78xxp2;
 	struct cvmx_sli_pkt_gbl_control_s     cnf75xx;
 };
 typedef union cvmx_sli_pkt_gbl_control cvmx_sli_pkt_gbl_control_t;
@@ -10408,7 +10942,7 @@ union cvmx_sli_pkt_in_donex_cnts {
 	uint64_t po_int                       : 1;
 #endif
 	} cn78xx;
-	struct cvmx_sli_pkt_in_donex_cnts_cn78xx cn78xxp2;
+	struct cvmx_sli_pkt_in_donex_cnts_s   cn78xxp2;
 	struct cvmx_sli_pkt_in_donex_cnts_cn61xx cnf71xx;
 	struct cvmx_sli_pkt_in_donex_cnts_s   cnf75xx;
 };
@@ -10495,6 +11029,7 @@ union cvmx_sli_pkt_in_jabber {
 #endif
 	} s;
 	struct cvmx_sli_pkt_in_jabber_s       cn73xx;
+	struct cvmx_sli_pkt_in_jabber_s       cn78xxp2;
 	struct cvmx_sli_pkt_in_jabber_s       cnf75xx;
 };
 typedef union cvmx_sli_pkt_in_jabber cvmx_sli_pkt_in_jabber_t;
@@ -10755,7 +11290,6 @@ union cvmx_sli_pkt_instr_enb {
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cn70xx;
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cn70xxp1;
 	struct cvmx_sli_pkt_instr_enb_s       cn78xx;
-	struct cvmx_sli_pkt_instr_enb_s       cn78xxp2;
 	struct cvmx_sli_pkt_instr_enb_cn61xx  cnf71xx;
 };
 typedef union cvmx_sli_pkt_instr_enb cvmx_sli_pkt_instr_enb_t;
@@ -10983,6 +11517,7 @@ union cvmx_sli_pkt_macx_pfx_rinfo {
 #endif
 	} s;
 	struct cvmx_sli_pkt_macx_pfx_rinfo_s  cn73xx;
+	struct cvmx_sli_pkt_macx_pfx_rinfo_s  cn78xxp2;
 	struct cvmx_sli_pkt_macx_pfx_rinfo_s  cnf75xx;
 };
 typedef union cvmx_sli_pkt_macx_pfx_rinfo cvmx_sli_pkt_macx_pfx_rinfo_t;
@@ -11013,7 +11548,6 @@ union cvmx_sli_pkt_macx_rinfo {
 #endif
 	} s;
 	struct cvmx_sli_pkt_macx_rinfo_s      cn78xx;
-	struct cvmx_sli_pkt_macx_rinfo_s      cn78xxp2;
 };
 typedef union cvmx_sli_pkt_macx_rinfo cvmx_sli_pkt_macx_rinfo_t;
 
@@ -11033,7 +11567,6 @@ union cvmx_sli_pkt_mac0_sig0 {
 #endif
 	} s;
 	struct cvmx_sli_pkt_mac0_sig0_s       cn78xx;
-	struct cvmx_sli_pkt_mac0_sig0_s       cn78xxp2;
 };
 typedef union cvmx_sli_pkt_mac0_sig0 cvmx_sli_pkt_mac0_sig0_t;
 
@@ -11053,7 +11586,6 @@ union cvmx_sli_pkt_mac0_sig1 {
 #endif
 	} s;
 	struct cvmx_sli_pkt_mac0_sig1_s       cn78xx;
-	struct cvmx_sli_pkt_mac0_sig1_s       cn78xxp2;
 };
 typedef union cvmx_sli_pkt_mac0_sig1 cvmx_sli_pkt_mac0_sig1_t;
 
@@ -11073,7 +11605,6 @@ union cvmx_sli_pkt_mac1_sig0 {
 #endif
 	} s;
 	struct cvmx_sli_pkt_mac1_sig0_s       cn78xx;
-	struct cvmx_sli_pkt_mac1_sig0_s       cn78xxp2;
 };
 typedef union cvmx_sli_pkt_mac1_sig0 cvmx_sli_pkt_mac1_sig0_t;
 
@@ -11093,7 +11624,6 @@ union cvmx_sli_pkt_mac1_sig1 {
 #endif
 	} s;
 	struct cvmx_sli_pkt_mac1_sig1_s       cn78xx;
-	struct cvmx_sli_pkt_mac1_sig1_s       cn78xxp2;
 };
 typedef union cvmx_sli_pkt_mac1_sig1 cvmx_sli_pkt_mac1_sig1_t;
 
@@ -11125,8 +11655,8 @@ union cvmx_sli_pkt_mem_ctl {
 	uint64_t pop1_ecc                     : 1;  /**< When set Packet Out Pointer memory1 will have an ECC not generated and checked. */
 	uint64_t pop0_fs                      : 2;  /**< Used to flip the synd for packet-out-pointer memory0. */
 	uint64_t pop0_ecc                     : 1;  /**< When set packet-out-pointer memory0 will have an ECC not generated and checked. */
-	uint64_t pfp_fs                       : 2;  /**< Reserved. INTERNAL: Placeholder. ECC not implemented due to critical path. */
-	uint64_t pfp_ecc                      : 1;  /**< Reserved. INTERNAL: Placeholder. ECC not implemented due to critical path. */
+	uint64_t pfp_fs                       : 2;  /**< Reserved. */
+	uint64_t pfp_ecc                      : 1;  /**< Reserved. */
 	uint64_t pbn_fs                       : 2;  /**< Used to flip the synd for pointer-base-number memory. */
 	uint64_t pbn_ecc                      : 1;  /**< When set pointer-base-number memory will have an ECC not generated and checked. */
 	uint64_t pdf_fs                       : 2;  /**< Used to flip the synd for packet-data-info memory. */
@@ -11191,8 +11721,8 @@ union cvmx_sli_pkt_mem_ctl {
 	uint64_t pop1_ecc                     : 1;  /**< When set Packet Out Pointer memory1 will have an ECC not generated and checked. */
 	uint64_t pop0_fs                      : 2;  /**< Used to flip the synd for packet-out-pointer memory0. */
 	uint64_t pop0_ecc                     : 1;  /**< When set packet-out-pointer memory0 will have an ECC not generated and checked. */
-	uint64_t pfp_fs                       : 2;  /**< Reserved. INTERNAL: Placeholder. ECC not implemented due to critical path. */
-	uint64_t pfp_ecc                      : 1;  /**< Reserved. INTERNAL: Placeholder. ECC not implemented due to critical path. */
+	uint64_t pfp_fs                       : 2;  /**< Reserved. */
+	uint64_t pfp_ecc                      : 1;  /**< Reserved. */
 	uint64_t pbn_fs                       : 2;  /**< Used to flip the synd for pointer-base-number memory. */
 	uint64_t pbn_ecc                      : 1;  /**< When set pointer-base-number memory will have an ECC not generated and checked. */
 	uint64_t pdf_fs                       : 2;  /**< Used to flip the synd for packet-data-info memory. */
@@ -11259,8 +11789,8 @@ union cvmx_sli_pkt_mem_ctl {
 	uint64_t pop1_ecc                     : 1;  /**< When set Packet Out Pointer memory1 will have an ECC not generated and checked. */
 	uint64_t pop0_fs                      : 2;  /**< Used to flip the synd for packet-out-pointer memory0. */
 	uint64_t pop0_ecc                     : 1;  /**< When set packet-out-pointer memory0 will have an ECC not generated and checked. */
-	uint64_t pfp_fs                       : 2;  /**< Reserved. INTERNAL: Placeholder. ECC not implemented due to critical path. */
-	uint64_t pfp_ecc                      : 1;  /**< Reserved. INTERNAL: Placeholder. ECC not implemented due to critical path. */
+	uint64_t pfp_fs                       : 2;  /**< Reserved. */
+	uint64_t pfp_ecc                      : 1;  /**< Reserved. */
 	uint64_t pbn_fs                       : 2;  /**< Used to flip the synd for pointer-base-number memory. */
 	uint64_t pbn_ecc                      : 1;  /**< When set pointer-base-number memory will have an ECC not generated and checked. */
 	uint64_t pdf_fs                       : 2;  /**< Used to flip the synd for packet-data-info memory. */
@@ -11302,7 +11832,7 @@ union cvmx_sli_pkt_mem_ctl {
 	uint64_t reserved_44_63               : 20;
 #endif
 	} cn78xx;
-	struct cvmx_sli_pkt_mem_ctl_cn78xx    cn78xxp2;
+	struct cvmx_sli_pkt_mem_ctl_cn73xx    cn78xxp2;
 	struct cvmx_sli_pkt_mem_ctl_cn73xx    cnf75xx;
 };
 typedef union cvmx_sli_pkt_mem_ctl cvmx_sli_pkt_mem_ctl_t;
@@ -11370,7 +11900,6 @@ union cvmx_sli_pkt_out_bp_en {
 	} cn68xx;
 	struct cvmx_sli_pkt_out_bp_en_cn68xx  cn68xxp1;
 	struct cvmx_sli_pkt_out_bp_en_s       cn78xx;
-	struct cvmx_sli_pkt_out_bp_en_s       cn78xxp2;
 };
 typedef union cvmx_sli_pkt_out_bp_en cvmx_sli_pkt_out_bp_en_t;
 
@@ -11393,7 +11922,6 @@ union cvmx_sli_pkt_out_bp_en2_w1c {
 #endif
 	} s;
 	struct cvmx_sli_pkt_out_bp_en2_w1c_s  cn73xx;
-	struct cvmx_sli_pkt_out_bp_en2_w1c_s  cnf75xx;
 };
 typedef union cvmx_sli_pkt_out_bp_en2_w1c cvmx_sli_pkt_out_bp_en2_w1c_t;
 
@@ -11416,7 +11944,6 @@ union cvmx_sli_pkt_out_bp_en2_w1s {
 #endif
 	} s;
 	struct cvmx_sli_pkt_out_bp_en2_w1s_s  cn73xx;
-	struct cvmx_sli_pkt_out_bp_en2_w1s_s  cnf75xx;
 };
 typedef union cvmx_sli_pkt_out_bp_en2_w1s cvmx_sli_pkt_out_bp_en2_w1s_t;
 
@@ -11439,6 +11966,7 @@ union cvmx_sli_pkt_out_bp_en_w1c {
 #endif
 	} s;
 	struct cvmx_sli_pkt_out_bp_en_w1c_s   cn73xx;
+	struct cvmx_sli_pkt_out_bp_en_w1c_s   cn78xxp2;
 	struct cvmx_sli_pkt_out_bp_en_w1c_s   cnf75xx;
 };
 typedef union cvmx_sli_pkt_out_bp_en_w1c cvmx_sli_pkt_out_bp_en_w1c_t;
@@ -11462,6 +11990,7 @@ union cvmx_sli_pkt_out_bp_en_w1s {
 #endif
 	} s;
 	struct cvmx_sli_pkt_out_bp_en_w1s_s   cn73xx;
+	struct cvmx_sli_pkt_out_bp_en_w1s_s   cn78xxp2;
 	struct cvmx_sli_pkt_out_bp_en_w1s_s   cnf75xx;
 };
 typedef union cvmx_sli_pkt_out_bp_en_w1s cvmx_sli_pkt_out_bp_en_w1s_t;
@@ -11504,7 +12033,6 @@ union cvmx_sli_pkt_out_enb {
 	struct cvmx_sli_pkt_out_enb_cn61xx    cn70xx;
 	struct cvmx_sli_pkt_out_enb_cn61xx    cn70xxp1;
 	struct cvmx_sli_pkt_out_enb_s         cn78xx;
-	struct cvmx_sli_pkt_out_enb_s         cn78xxp2;
 	struct cvmx_sli_pkt_out_enb_cn61xx    cnf71xx;
 };
 typedef union cvmx_sli_pkt_out_enb cvmx_sli_pkt_out_enb_t;
@@ -11596,6 +12124,7 @@ union cvmx_sli_pkt_pkind_valid {
 #endif
 	} s;
 	struct cvmx_sli_pkt_pkind_valid_s     cn73xx;
+	struct cvmx_sli_pkt_pkind_valid_s     cn78xxp2;
 	struct cvmx_sli_pkt_pkind_valid_s     cnf75xx;
 };
 typedef union cvmx_sli_pkt_pkind_valid cvmx_sli_pkt_pkind_valid_t;
@@ -11937,6 +12466,7 @@ union cvmx_sli_pp_pkt_csr_control {
 #endif
 	} s;
 	struct cvmx_sli_pp_pkt_csr_control_s  cn73xx;
+	struct cvmx_sli_pp_pkt_csr_control_s  cn78xxp2;
 	struct cvmx_sli_pp_pkt_csr_control_s  cnf75xx;
 };
 typedef union cvmx_sli_pp_pkt_csr_control cvmx_sli_pp_pkt_csr_control_t;
@@ -11944,7 +12474,7 @@ typedef union cvmx_sli_pp_pkt_csr_control cvmx_sli_pp_pkt_csr_control_t;
 /**
  * cvmx_sli_s2c_end_merge
  *
- * Writing this CSR will cause a merge to end.
+ * Writing this register will cause a merge to end.
  *
  */
 union cvmx_sli_s2c_end_merge {
@@ -11983,30 +12513,31 @@ union cvmx_sli_s2m_portx_ctl {
                                                          remote chip access. This field, when set, disables this and treats all access to
                                                          be for the local CCPI. */
 	uint64_t wind_d                       : 1;  /**< Window disable. When set to 1, disables access to the window registers from the MAC port. */
-	uint64_t bar0_d                       : 1;  /**< BAR0 disable. When set to 1, disables access from the MAC to BAR0 for the following
+	uint64_t bar0_d                       : 1;  /**< BAR0 disable. When set, disables access from the MAC to BAR0 for the following
                                                          address offsets:
-                                                           SLI_WIN_WR_ADDR
-                                                           SLI_WIN_RD_ADDR
-                                                           SLI_WIN_WR_DATA
-                                                           SLI_WIN_WR_MASK
-                                                           SLI_WIN_RD_DATA
-                                                           SLI_MAC_CREDIT_CNT
-                                                           SLI_S2M_PORT(0..3)_CTL
-                                                           SLI_MAC_CREDIT_CNT2
-                                                           SLI_S2C_END_MERGE
-                                                           SLI_CIU_INT_SUM
-                                                           SLI_CIU_INT_ENB
-                                                           SLI_MAC(0..3)_PF(0..1)_FLR_VF_INT
-                                                           SLI_MEM_ACCESS_SUBID(12..27)
-                                                           SLI_PP_PKT_CSR_CONTROL
-                                                           SLI_WINDOW_CTL
-                                                           SLI_MEM_ACCESS_CTL
-                                                           SLI_CTL_STATUS
-                                                           SLI_BIST_STATUS
-                                                           SLI_MEM_INT_SUM
-                                                           SLI_MEM_CTL
-                                                           SLI_CTL_PORT(0..3)
-                                                           SLI_PKT_MEM_CTL */
+                                                           SLI_WIN_WR_ADDR,
+                                                           SLI_WIN_RD_ADDR,
+                                                           SLI_WIN_WR_DATA,
+                                                           SLI_WIN_WR_MASK,
+                                                           SLI_WIN_RD_DATA,
+                                                           SLI_MAC_CREDIT_CNT,
+                                                           SLI_S2M_PORT()_CTL,
+                                                           SLI_MAC_CREDIT_CNT2,
+                                                           SLI_S2C_END_MERGE,
+                                                           SLI_CIU_INT_SUM,
+                                                           SLI_CIU_INT_ENB,
+                                                           SLI_MAC()_PF()_FLR_VF_INT,
+                                                           SLI_MEM_ACCESS_SUBID(),
+                                                           SLI_PP_PKT_CSR_CONTROL,
+                                                           SLI_WINDOW_CTL,
+                                                           SLI_MEM_ACCESS_CTL,
+                                                           SLI_CTL_STATUS,
+                                                           SLI_BIST_STATUS,
+                                                           SLI_MEM_INT_SUM,
+                                                           SLI_MEM_CTL,
+                                                           SLI_CTL_PORT(),
+                                                           SLI_PKT_MEM_CTL.
+                                                         If [BAR0_D] is set, [WIND_D] should also be set. */
 	uint64_t reserved_0_2                 : 3;
 #else
 	uint64_t reserved_0_2                 : 3;
@@ -12068,31 +12599,31 @@ union cvmx_sli_s2m_portx_ctl {
                                                          remote chip access. This field, when set, disables this and treats all access to
                                                          be for the local CCPI. */
 	uint64_t wind_d                       : 1;  /**< Window disable. When set to 1, disables access to the window registers from the MAC port. */
-	uint64_t bar0_d                       : 1;  /**< BAR0 disable. When set to 1, disables access from the MAC to BAR0 for the following
+	uint64_t bar0_d                       : 1;  /**< BAR0 disable. When set, disables access from the MAC to BAR0 for the following
                                                          address offsets:
-                                                           SLI_WIN_WR_ADDR
-                                                           SLI_WIN_RD_ADDR
-                                                           SLI_WIN_WR_DATA
-                                                           SLI_WIN_WR_MASK
-                                                           SLI_WIN_RD_DATA
-                                                           SLI_MAC_CREDIT_CNT
-                                                           SLI_S2M_PORT(0..3)_CTL
-                                                           SLI_MAC_CREDIT_CNT2
-                                                           SLI_S2C_END_MERGE
-                                                           SLI_CIU_INT_SUM
-                                                           SLI_CIU_INT_ENB
-                                                           SLI_MAC(0..3)_PF(0..1)_FLR_VF_INT
-                                                           SLI_MEM_ACCESS_SUBID(12..27)
-                                                           SLI_PP_PKT_CSR_CONTROL
-                                                           SLI_WINDOW_CTL
-                                                           SLI_MEM_ACCESS_CTL
-                                                           SLI_CTL_STATUS
-                                                           SLI_BIST_STATUS
-                                                           SLI_MEM_INT_SUM
-                                                           SLI_MEM_CTL
-                                                           SLI_CTL_PORT(0..3)
-                                                           SLI_NQM_RSP_ERR_SND_DBG
-                                                           SLI_PKT_MEM_CTL */
+                                                           SLI_WIN_WR_ADDR,
+                                                           SLI_WIN_RD_ADDR,
+                                                           SLI_WIN_WR_DATA,
+                                                           SLI_WIN_WR_MASK,
+                                                           SLI_WIN_RD_DATA,
+                                                           SLI_MAC_CREDIT_CNT,
+                                                           SLI_S2M_PORT()_CTL,
+                                                           SLI_MAC_CREDIT_CNT2,
+                                                           SLI_S2C_END_MERGE,
+                                                           SLI_CIU_INT_SUM,
+                                                           SLI_CIU_INT_ENB,
+                                                           SLI_MAC()_PF()_FLR_VF_INT,
+                                                           SLI_MEM_ACCESS_SUBID(),
+                                                           SLI_PP_PKT_CSR_CONTROL,
+                                                           SLI_WINDOW_CTL,
+                                                           SLI_MEM_ACCESS_CTL,
+                                                           SLI_CTL_STATUS,
+                                                           SLI_BIST_STATUS,
+                                                           SLI_MEM_INT_SUM,
+                                                           SLI_MEM_CTL,
+                                                           SLI_CTL_PORT(),
+                                                           SLI_PKT_MEM_CTL.
+                                                         If [BAR0_D] is set, [WIND_D] should also be set. */
 	uint64_t ld_cmd                       : 2;  /**< When SLI issues a load command to the L2C that is to be cached, this field selects the
                                                          type of load command to use:
                                                          0x0 = LDD.
@@ -12119,7 +12650,7 @@ union cvmx_sli_s2m_portx_ctl {
                                                          remote chip access. This field, when set, disables this and treats all access to
                                                          be for the local CCPI. */
 	uint64_t wind_d                       : 1;  /**< Window disable. When set to 1, disables access to the window registers from the MAC port. */
-	uint64_t bar0_d                       : 1;  /**< BAR0 disable. When set to 1, disables access from the MAC to BAR0 for the following
+	uint64_t bar0_d                       : 1;  /**< BAR0 disable. When set, disables access from the MAC to BAR0 for the following
                                                          address offsets:
                                                          * 0x0-0x32F.
                                                          * 0x3CD0.
@@ -12140,7 +12671,7 @@ union cvmx_sli_s2m_portx_ctl {
 	uint64_t reserved_6_63                : 58;
 #endif
 	} cn78xx;
-	struct cvmx_sli_s2m_portx_ctl_cn78xx  cn78xxp2;
+	struct cvmx_sli_s2m_portx_ctl_cn73xx  cn78xxp2;
 	struct cvmx_sli_s2m_portx_ctl_cn61xx  cnf71xx;
 	struct cvmx_sli_s2m_portx_ctl_cn73xx  cnf75xx;
 };
diff --git a/arch/mips/include/asm/octeon/cvmx-smix-defs.h b/arch/mips/include/asm/octeon/cvmx-smix-defs.h
index 52948b9..317c18f 100644
--- a/arch/mips/include/asm/octeon/cvmx-smix-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-smix-defs.h
@@ -80,6 +80,12 @@ static inline uint64_t CVMX_SMIX_CLK(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180000003818ull) + ((offset) & 1) * 128;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180000003818ull) + ((offset) & 3) * 128;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180000003818ull) + ((offset) & 3) * 128;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003818ull) + ((offset) & 3) * 128;
@@ -110,6 +116,10 @@ static inline uint64_t CVMX_SMIX_CLK(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003818ull) + (offset) * 128;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180000003818ull) + (offset) * 128;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180000003818ull) + (offset) * 128;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003818ull) + (offset) * 128;
 	}
@@ -144,6 +154,12 @@ static inline uint64_t CVMX_SMIX_CMD(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180000003800ull) + ((offset) & 1) * 128;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180000003800ull) + ((offset) & 3) * 128;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180000003800ull) + ((offset) & 3) * 128;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003800ull) + ((offset) & 3) * 128;
@@ -174,6 +190,10 @@ static inline uint64_t CVMX_SMIX_CMD(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003800ull) + (offset) * 128;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180000003800ull) + (offset) * 128;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180000003800ull) + (offset) * 128;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003800ull) + (offset) * 128;
 	}
@@ -208,6 +228,12 @@ static inline uint64_t CVMX_SMIX_EN(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180000003820ull) + ((offset) & 1) * 128;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180000003820ull) + ((offset) & 3) * 128;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180000003820ull) + ((offset) & 3) * 128;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003820ull) + ((offset) & 3) * 128;
@@ -238,6 +264,10 @@ static inline uint64_t CVMX_SMIX_EN(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003820ull) + (offset) * 128;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180000003820ull) + (offset) * 128;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180000003820ull) + (offset) * 128;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003820ull) + (offset) * 128;
 	}
@@ -272,6 +302,12 @@ static inline uint64_t CVMX_SMIX_RD_DAT(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180000003810ull) + ((offset) & 1) * 128;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180000003810ull) + ((offset) & 3) * 128;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180000003810ull) + ((offset) & 3) * 128;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003810ull) + ((offset) & 3) * 128;
@@ -302,6 +338,10 @@ static inline uint64_t CVMX_SMIX_RD_DAT(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003810ull) + (offset) * 128;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180000003810ull) + (offset) * 128;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180000003810ull) + (offset) * 128;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003810ull) + (offset) * 128;
 	}
@@ -336,6 +376,12 @@ static inline uint64_t CVMX_SMIX_WR_DAT(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x0001180000003808ull) + ((offset) & 1) * 128;
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180000003808ull) + ((offset) & 3) * 128;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset <= 3))
+					return CVMX_ADD_IO_SEG(0x0001180000003808ull) + ((offset) & 3) * 128;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return CVMX_ADD_IO_SEG(0x0001180000003808ull) + ((offset) & 3) * 128;
@@ -366,6 +412,10 @@ static inline uint64_t CVMX_SMIX_WR_DAT(unsigned long offset)
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003808ull) + (offset) * 128;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180000003808ull) + (offset) * 128;
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180000003808ull) + (offset) * 128;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001180000003808ull) + (offset) * 128;
 	}
@@ -377,8 +427,8 @@ static inline uint64_t CVMX_SMIX_WR_DAT(unsigned long offset)
  * cvmx_smi#_clk
  *
  * This register determines the SMI timing characteristics.
- * If software wants to change SMI CLK timing parameters (SAMPLE/SAMPLE_HI), software
- * must delay the SMI_CLK CSR write by at least 512 coprocessor-clocks after the
+ * If software wants to change SMI CLK timing parameters ([SAMPLE]/[SAMPLE_HI]), software
+ * must delay the SMI_()_CLK CSR write by at least 512 coprocessor-clocks after the
  * previous SMI operation is finished.
  */
 union cvmx_smix_clk {
@@ -403,8 +453,8 @@ union cvmx_smix_clk {
                                                          frame the transaction. */
 	uint64_t sample                       : 4;  /**< Sample read data. Specifies the number of coprocessor clock cycles after the rising edge
                                                          of SMIn_MDC to wait before sampling read data.
-                                                         _ (SAMPLE_HI,SAMPLE) > 1
-                                                         _ (SAMPLE_HI,SAMPLE) + 3 <= 2 * PHASE */
+                                                         _ ([SAMPLE_HI],[SAMPLE]) > 1
+                                                         _ ([SAMPLE_HI],[SAMPLE]) + 3 <= 2 * [PHASE] */
 	uint64_t phase                        : 8;  /**< MDC clock phase. Specifies the number of coprocessor clock cycles that make up an SMIn_MDC
                                                          phase.
                                                          _ PHASE > 2 */
@@ -496,7 +546,7 @@ union cvmx_smix_cmd {
 	uint64_t reserved_18_63               : 46;
 	uint64_t phy_op                       : 2;  /**< PHY opcode, depending on SMI_()_CLK[MODE] setting.
                                                          * If SMI_()_CLK[MODE] = 0 (<=1Gbs / Clause 22):
-                                                         0 = write operation, encoded in the frame as 01
+                                                         0 = write operation, encoded in the frame as 01.
                                                          1 = read operation, encoded in the frame as 10.
                                                          * If SMI_()_CLK[MODE] = 1 (>1Gbs / Clause 45):
                                                          0x0 = Address.
diff --git a/arch/mips/include/asm/octeon/cvmx-spemx-defs.h b/arch/mips/include/asm/octeon/cvmx-spemx-defs.h
index 49dc0ae..7fd2554 100644
--- a/arch/mips/include/asm/octeon/cvmx-spemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-spemx-defs.h
@@ -688,11 +688,7 @@ union cvmx_spemx_cfg_rd {
                                                                  clear. Must be zero in RC mode. 0..63 are legal values for
                                                                  PF0 and PF1. 0..1026 are legal values for PF2.
                                                          <11:0>  Selects the PCIe config space register being read in the
-                                                                 function.
-                                                         INTERNAL:
-                                                           <25:24> is dbi_func_num to the core.
-                                                           <23>    is dbi_vfunc_active to the core.
-                                                           <22:12> is dbi_vfunc_num to the core. */
+                                                                 function. */
 #else
 	uint64_t addr                         : 32;
 	uint64_t data                         : 32;
@@ -730,12 +726,7 @@ union cvmx_spemx_cfg_wr {
                                                                  clear. Must be zero in RC mode. 0..63 are legal values for
                                                                  PF0 and PF1. 0..1026 are legal values for PF2.
                                                          <11:0>  Selects the PCIe config space register being written in the
-                                                                 function.
-                                                         INTERNAL:
-                                                           <31>    asserts dbi_cs2 at PCIe core.
-                                                           <25:24> is dbi_func_num to the core.
-                                                           <23>    is dbi_vfunc_active to the core.
-                                                           <22:12> is dbi_vfunc_num to the core. */
+                                                                 function. */
 #else
 	uint64_t addr                         : 32;
 	uint64_t data                         : 32;
@@ -971,101 +962,71 @@ union cvmx_spemx_dbg_info {
 	uint64_t p0_ecrc_e                    : 1;  /**< Received an PF0 ECRC error.
                                                          Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_ECRC_E. */
 	uint64_t p0_rawwpp                    : 1;  /**< Received a PF0 write with poisoned payload.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RAWWPP.
-                                                         INTERNAL: radm_rcvd_wreq_poisoned */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RAWWPP. */
 	uint64_t p0_racpp                     : 1;  /**< Received a PF0 completion with poisoned payload.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RACPP.
-                                                         INTERNAL: radm_rcvd_cpl_poisoned */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RACPP. */
 	uint64_t p0_ramtlp                    : 1;  /**< Received a PF0 malformed TLP.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RAMTLP.
-                                                         INTERNAL: radm_mlf_tlp_err */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RAMTLP. */
 	uint64_t p0_rarwdns                   : 1;  /**< Received a request which device does not support.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RARWDNS.
-                                                         INTERNAL: radm_rcvd_req_ur. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RARWDNS. */
 	uint64_t p0_caar                      : 1;  /**< Completer PF0 aborted a request. This bit is never set because CNXXXX does not generate
                                                          completer aborts.
                                                          Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_CAAR. */
 	uint64_t p0_racca                     : 1;  /**< Received a PF0 completion with CA status.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RACCA.
-                                                         INTERNAL: radm_rcvd_cpl_ca */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RACCA. */
 	uint64_t p0_racur                     : 1;  /**< Received a PF0 completion with UR status.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RACUR.
-                                                         INTERNAL: radm_rcvd_cpl_ur */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RACUR. */
 	uint64_t p0_rauc                      : 1;  /**< Received an PF0 unexpected completion.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RAUC.
-                                                         INTERNAL: radm_unexp_cpl_err */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_P0_RAUC. */
 	uint64_t rqo                          : 1;  /**< Receive queue overflow. Normally happens only when flow control advertisements are
                                                          ignored.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RQO.
-                                                         INTERNAL: radm_qoverflow. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RQO. */
 	uint64_t fcuv                         : 1;  /**< Flow control update violation.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_FCUV.
-                                                         INTERNAL: (opt. checks) int_xadm_fc_prot_err. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_FCUV. */
 	uint64_t rpe                          : 1;  /**< PHY reported an 8B/10B decode error (RxStatus = 0x4) or disparity error (RxStatus =
                                                          0x7).
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RPE.
-                                                         INTERNAL: rmlh_rcvd_err. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RPE. */
 	uint64_t fcpvwt                       : 1;  /**< Flow control protocol violation (watchdog timer).
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_FCPVWT.
-                                                         INTERNAL: rtlh_fc_prot_err. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_FCPVWT. */
 	uint64_t dpeoosd                      : 1;  /**< DLLP protocol error (out of sequence DLLP).
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_DPEOOSD.
-                                                         INTERNAL: rdlh_prot_err. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_DPEOOSD. */
 	uint64_t rtwdle                       : 1;  /**< Received TLP with datalink layer error.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RTWDLE.
-                                                         INTERNAL: rdlh_bad_tlp_err. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RTWDLE. */
 	uint64_t rdwdle                       : 1;  /**< Received DLLP with datalink layer error.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RDWDLE.
-                                                         INTERNAL: rdlh_bad_dllp_err. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RDWDLE. */
 	uint64_t mre                          : 1;  /**< Maximum number of retries exceeded.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_MRE.
-                                                         INTERNAL: xdlh_replay_num_rlover_err. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_MRE. */
 	uint64_t rte                          : 1;  /**< Replay timer expired. This bit is set when the REPLAY_TIMER expires in the PCIe core. The
                                                          probability of this bit being set increases with the traffic load.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RTE.
-                                                         INTERNAL: xdlh_replay_timeout_err. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RTE. */
 	uint64_t acto                         : 1;  /**< A completion timeout occurred.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_ACTO.
-                                                         INTERNAL: pedc_radm_cpl_timeout. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_ACTO. */
 	uint64_t rvdm                         : 1;  /**< Received vendor-defined message.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RVDM.
-                                                         INTERNAL: pedc_radm_vendor_msg. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RVDM. */
 	uint64_t rumep                        : 1;  /**< Received unlock message (EP mode only).
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RUMEP.
-                                                         INTERNAL: pedc_radm_msg_unlock. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RUMEP. */
 	uint64_t rptamrc                      : 1;  /**< Received PME turnoff acknowledge message (RC mode only).
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RPTAMRC.
-                                                         INTERNAL: pedc_radm_pm_to_ack. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RPTAMRC. */
 	uint64_t rpmerc                       : 1;  /**< Received PME message (RC mode only).
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RPMERC.
-                                                         INTERNAL: pedc_radm_pm_pme. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RPMERC. */
 	uint64_t rfemrc                       : 1;  /**< Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
                                                          is set.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RFEMRC.
-                                                         INTERNAL: pedc_radm_fatal_err. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RFEMRC. */
 	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message (RC mode only).
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RNFEMRC.
-                                                         INTERNAL: pedc_radm_nonfatal_err. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RNFEMRC. */
 	uint64_t rcemrc                       : 1;  /**< Received correctable error message (RC mode only).
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RCEMRC.
-                                                         INTERNAL: pedc_radm_correctable_err. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RCEMRC. */
 	uint64_t rpoison                      : 1;  /**< Received poisoned TLP.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RPOISON.
-                                                         INTERNAL: pedc__radm_trgt1_poisoned & pedc__radm_trgt1_hv. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RPOISON. */
 	uint64_t recrce                       : 1;  /**< Received ECRC error.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RECRCE.
-                                                         INTERNAL: pedc_radm_trgt1_ecrc_err & pedc__radm_trgt1_eot. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RECRCE. */
 	uint64_t rtlplle                      : 1;  /**< Received TLP has link layer error.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RTLPLLE.
-                                                         INTERNAL: pedc_radm_trgt1_dllp_abort & pedc__radm_trgt1_eot. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RTLPLLE. */
 	uint64_t rtlpmal                      : 1;  /**< Received TLP is malformed or a message. If the core receives a MSG (or Vendor Message) or
                                                          if a received AtomicOp viloates address/length rules, this bit is set as well.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RTLPMAL.
-                                                         INTERNAL: pedc_radm_trgt1_tlp_abort & pedc__radm_trgt1_eot. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RTLPMAL. */
 	uint64_t spoison                      : 1;  /**< Poisoned TLP sent.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_SPOISON.
-                                                         INTERNAL: peai__client0_tlp_ep & peai__client0_tlp_hv or peai__client1_tlp_ep
-                                                                   & peai__client1_tlp_hv (atomic_op). */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_SPOISON. */
 #else
 	uint64_t spoison                      : 1;
 	uint64_t rtlpmal                      : 1;
@@ -1291,7 +1252,7 @@ union cvmx_spemx_eco {
 	struct cvmx_spemx_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t eco_rw                       : 8;  /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 8;  /**< N/A */
 #else
 	uint64_t eco_rw                       : 8;
 	uint64_t reserved_8_63                : 56;
@@ -1570,21 +1531,16 @@ union cvmx_spemx_int_sum {
 	uint64_t up_b1                        : 1;  /**< Received P-TLP for BAR1 when BAR1 index valid is not set.
                                                          Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_UP_B1. */
 	uint64_t pf2_pmei                     : 1;  /**< PF2 PME interrupt. This is a level-sensitive interrupt.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_PF2_PMEI.
-                                                         INTERNAL: cfg_pme_int */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_PF2_PMEI. */
 	uint64_t pf1_pmei                     : 1;  /**< PF1 PME interrupt. This is a level-sensitive interrupt.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_PF1_PMEI.
-                                                         INTERNAL: cfg_pme_int */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_PF1_PMEI. */
 	uint64_t pf0_pmei                     : 1;  /**< PF0 PME interrupt. This is a level-sensitive interrupt.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_PF0_PMEI.
-                                                         INTERNAL: cfg_pme_int */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_PF0_PMEI. */
 	uint64_t se                           : 1;  /**< System error, RC mode only.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_SE.
-                                                         INTERNAL: cfg_sys_err_rc */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_SE. */
 	uint64_t aeri                         : 1;  /**< Advanced error reporting interrupt, RC mode only.
                                                          This is a level-sensitive interrupt.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_AERI.
-                                                         INTERNAL: cfg_aer_rc_err_int */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_AERI. */
 #else
 	uint64_t aeri                         : 1;
 	uint64_t se                           : 1;
@@ -1616,8 +1572,6 @@ typedef union cvmx_spemx_int_sum cvmx_spemx_int_sum_t;
  *
  * This register specifies the starting address for memory requests that are to be forwarded to
  * the NQM in RC mode.
- *
- * INTERNAL: Make this CSR visible when bug 22564 gets fixed.
  */
 union cvmx_spemx_nqm_bar0_start {
 	uint64_t u64;
@@ -1818,29 +1772,22 @@ union cvmx_spemx_pf1_dbg_info {
 	uint64_t p1_ecrc_e                    : 1;  /**< Received an PF1 ECRC error.
                                                          Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_ECRC_E. */
 	uint64_t p1_rawwpp                    : 1;  /**< Received a PF1 write with poisoned payload.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RAWWPP.
-                                                         INTERNAL: radm_rcvd_wreq_poisoned */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RAWWPP. */
 	uint64_t p1_racpp                     : 1;  /**< Received a PF1 completion with poisoned payload.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RACPP.
-                                                         INTERNAL: radm_rcvd_cpl_poisoned */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RACPP. */
 	uint64_t p1_ramtlp                    : 1;  /**< Received a PF1 malformed TLP.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RAMTLP.
-                                                         INTERNAL: radm_mlf_tlp_err */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RAMTLP. */
 	uint64_t p1_rarwdns                   : 1;  /**< Received a request which device does not support.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RARWDNS.
-                                                         INTERNAL: radm_rcvd_req_ur. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RARWDNS. */
 	uint64_t p1_caar                      : 1;  /**< Completer PF1 aborted a request. This bit is never set because CNXXXX does not generate
                                                          completer aborts.
                                                          Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_CAAR. */
 	uint64_t p1_racca                     : 1;  /**< Received a PF1 completion with CA status.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RACCA.
-                                                         INTERNAL: radm_rcvd_cpl_ca */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RACCA. */
 	uint64_t p1_racur                     : 1;  /**< Received a PF1 completion with UR status.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RACUR.
-                                                         INTERNAL: radm_rcvd_cpl_ur */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RACUR. */
 	uint64_t p1_rauc                      : 1;  /**< Received an PF1 unexpected completion.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RAUC.
-                                                         INTERNAL: radm_unexp_cpl_err */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P1_RAUC. */
 	uint64_t reserved_0_21                : 22;
 #else
 	uint64_t reserved_0_21                : 22;
@@ -1881,29 +1828,22 @@ union cvmx_spemx_pf2_dbg_info {
 	uint64_t p2_ecrc_e                    : 1;  /**< Received an PF2 ECRC error.
                                                          Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_ECRC_E. */
 	uint64_t p2_rawwpp                    : 1;  /**< Received a PF2 write with poisoned payload.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RAWWPP.
-                                                         INTERNAL: radm_rcvd_wreq_poisoned */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RAWWPP. */
 	uint64_t p2_racpp                     : 1;  /**< Received a PF2 completion with poisoned payload.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RACPP.
-                                                         INTERNAL: radm_rcvd_cpl_poisoned */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RACPP. */
 	uint64_t p2_ramtlp                    : 1;  /**< Received a PF2 malformed TLP.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RAMTLP.
-                                                         INTERNAL: radm_mlf_tlp_err */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RAMTLP. */
 	uint64_t p2_rarwdns                   : 1;  /**< Received a request which device does not support.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RARWDNS.
-                                                         INTERNAL: radm_rcvd_req_ur. */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RARWDNS. */
 	uint64_t p2_caar                      : 1;  /**< Completer PF2 aborted a request. This bit is never set because CNXXXX does not generate
                                                          completer aborts.
                                                          Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_CAAR. */
 	uint64_t p2_racca                     : 1;  /**< Received a PF2 completion with CA status.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RACCA.
-                                                         INTERNAL: radm_rcvd_cpl_ca */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RACCA. */
 	uint64_t p2_racur                     : 1;  /**< Received a PF2 completion with UR status.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RACUR.
-                                                         INTERNAL: radm_rcvd_cpl_ur */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RACUR. */
 	uint64_t p2_rauc                      : 1;  /**< Received an PF2 unexpected completion.
-                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RAUC.
-                                                         INTERNAL: radm_unexp_cpl_err */
+                                                         Throws corresponding SPEM_INTSN_E::SPEM(0)_ERROR_P2_RAUC. */
 	uint64_t reserved_0_21                : 22;
 #else
 	uint64_t reserved_0_21                : 22;
diff --git a/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h b/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
index 97731cd..906abaa 100644
--- a/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
@@ -4868,9 +4868,9 @@ union cvmx_sriomaintx_pe_llc {
 	uint32_t ex_addr                      : 3;  /**< Controls the number of address bits generated by
                                                          PE as a source and processed by the PE as a
                                                          target of an operation.
-                                                         0x1 = 34-bit Addresses
-                                                         0x2 = 50-bit Addresses
-                                                         0x4 = 66-bit Addresses
+                                                         0x1 = 34-bit Addresses.
+                                                         0x2 = 50-bit Addresses.
+                                                         0x4 = 66-bit Addresses.
                                                          All other encodings are reserved. */
 #else
 	uint32_t ex_addr                      : 3;
@@ -4911,12 +4911,12 @@ union cvmx_sriomaintx_port_0_ctl {
 	uint32_t ov_width                     : 3;  /**< Override Port Width.  Writing this register causes
                                                          the port to reinitialize.
                                                          0x0 = No override all lanes possible.
-                                                         0x1 = Reserved
+                                                         0x1 = Reserved.
                                                          0x2 = Force single-lane, lane 0.
                                                          If Ln 0 is unavailable try lane 2 then lane 1.
-                                                         0x3 = Force single-lane, lane 2
+                                                         0x3 = Force single-lane, lane 2.
                                                          If Ln 2 is unavailable try lane 1 then lane 0.
-                                                         0x4 = Reserved
+                                                         0x4 = Reserved.
                                                          0x5 = Enable two-lane, disable four-lane.
                                                          0x6 = Enable four-lane, disable two-lane.
                                                          0x7 = All lanes sizes enabled. */
@@ -5081,12 +5081,12 @@ union cvmx_sriomaintx_port_0_ctl {
 	uint32_t ov_width                     : 3;  /**< Override Port Width.  Writing this register causes
                                                          the port to reinitialize.
                                                          0x0 = No override all lanes possible.
-                                                         0x1 = Reserved
+                                                         0x1 = Reserved.
                                                          0x2 = Force single-lane, lane 0.
                                                          If Ln 0 is unavailable try lane 2 then lane 1.
-                                                         0x3 = Force single-lane, lane 2
+                                                         0x3 = Force single-lane, lane 2.
                                                          If Ln 2 is unavailable try lane 1 then lane 0.
-                                                         0x4 = Reserved
+                                                         0x4 = Reserved.
                                                          0x5 = Enable two-lane, disable four-lane.
                                                          0x6 = Enable four-lane, disable two-lane.
                                                          0x7 = All lanes sizes enabled. */
diff --git a/arch/mips/include/asm/octeon/cvmx-sriox-defs.h b/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
index aac32f1..4e72a03 100644
--- a/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
@@ -1257,42 +1257,7 @@ union cvmx_sriox_bist_status {
 	struct cvmx_sriox_bist_status_cnf75xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_34_63               : 30;
-	uint64_t status                       : 34; /**< Bist status set bit indicates failure.
-                                                         INTERNAL:
-                                                         33 = fc.core.roc.srio.srio_mac.tx_buffer.memory.ram0.
-                                                         32 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram01.
-                                                         31 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram00.
-                                                         30 = fc.core.roc.srio.mgmt.spf.rx_spf_mem.
-                                                         29 = fc.core.roc.srio.mgmt.spf.tx_spf_mem.
-                                                         28 = fc.core.roc.srio.sli.idec.lram.
-                                                         27 = fc.core.roc.srio.sli.ififo.mram0. (sclk bist)
-                                                         26 = fc.core.roc.srio.sli.ififo.mram1. (sclk bist)
-                                                         25 = fc.core.roc.srio.sli.ififo.cram.  (sclk bist)
-                                                         24 = fc.core.roc.srio.sli.ififo.bell.dbell_mem.
-                                                         23 = fc.core.roc.srio.sli.tag.otag.
-                                                         22 = fc.core.roc.srio.sli.tag.itag.
-                                                         21 = fc.core.roc.srio.sli.ofifo.hs_pfifo.sram. (sclk bist)
-                                                         20 = fc.core.roc.srio.sli.ofifo.rtn.rtn.
-                                                         19 = fc.core.roc.srio.sli.ofifo.sh_bulk.m3.
-                                                         18 = fc.core.roc.srio.sli.ofifo.sh_bulk.m2.
-                                                         17 = fc.core.roc.srio.sli.ofifo.sh_bulk.m1.
-                                                         16 = fc.core.roc.srio.sli.ofifo.sh_bulk.m0.
-                                                         15 = fc.core.roc.srio.sli.ofifo.sh_pfifo3.sram. (sclk bist)
-                                                         14 = fc.core.roc.srio.sli.ofifo.sh_pfifo2.sram. (sclk bist)
-                                                         13 = fc.core.roc.srio.sli.ofifo.sh_pfifo1.sram. (sclk bist)
-                                                         12 = fc.core.roc.srio.sli.ofifo.sh_pfifo0.sram. (sclk bist)
-                                                         11 = fc.core.roc.srio.sli.oarb.cmd_fifo.m1.
-                                                         10 = fc.core.roc.srio.sli.oarb.cmd_fifo.m0.
-                                                         9 = fc.core.roc.srio.omsg.sil.mem.
-                                                         8 = fc.core.roc.srio.omsg.fif1.mem2.
-                                                         7 = fc.core.roc.srio.omsg.fif1.mem0_l.
-                                                         6 = fc.core.roc.srio.omsg.fif1.mem0_h.
-                                                         5 = fc.core.roc.srio.omsg.fif0.mem2.
-                                                         4 = fc.core.roc.srio.omsg.fif0.mem0_l.
-                                                         3 = fc.core.roc.srio.omsg.fif0.mem0_h.
-                                                         2 = fc.core.roc.srio.imsg.pre.dat_mem.
-                                                         1 = fc.core.roc.srio.imsg.pre.hdr_mem.
-                                                         0 = fc.core.roc.srio.imsg.pre.csr_mem. */
+	uint64_t status                       : 34; /**< Bist status set bit indicates failure. */
 #else
 	uint64_t status                       : 34;
 	uint64_t reserved_34_63               : 30;
@@ -1314,30 +1279,7 @@ union cvmx_sriox_ecc_ctrl {
 	uint64_t ecc_dis                      : 1;  /**< Disable ECC Checking on all SRIO internal memories.
                                                          Typically set to zero. */
 	uint64_t reserved_44_62               : 19;
-	uint64_t flip                         : 44; /**< Error Insertion Bits for ECC syndromes.  Two per RAM.  Typically set to zero.
-                                                          INTERNAL:
-                                                          - 43:42 = fc.core.roc.srio.srio_mac.tx_buffer.memory.ram0.
-                                                          - 41:40 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram01.
-                                                          - 39:38 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram00.
-                                                          - 37:36 = fc.core.roc.srio.mgmt.spf.rx_spf_mem.
-                                                          - 35:34 = fc.core.roc.srio.mgmt.spf.tx_spf_mem.
-                                                          - 33:32 = fc.core.roc.srio.sli.tag.otag.
-                                                          - 31:30 = fc.core.roc.srio.sli.tag.itag.
-                                                          - 29:28 = fc.core.roc.srio.sli.ofifo.rtn.rtn.
-                                                          - 27:26 = fc.core.roc.srio.sli.ofifo.sh_bulk.m3.
-                                                          - 25:24 = fc.core.roc.srio.sli.ofifo.sh_bulk.m2.
-                                                          - 23:22 = fc.core.roc.srio.sli.ofifo.sh_bulk.m1.
-                                                          - 21:20 = fc.core.roc.srio.sli.ofifo.sh_bulk.m0.
-                                                          - 19:18 = Reserved.
-                                                          - 17:16 = Reserved.
-                                                          - 15:14 = fc.core.roc.srio.omsg.sil.mem.
-                                                          - 13:12 = fc.core.roc.srio.omsg.fif1.mem2.
-                                                          - 11:10 = fc.core.roc.srio.omsg.fif1.mem0_l.
-                                                         - 9:8   = fc.core.roc.srio.omsg.fif1.mem0_h.
-                                                         - 7:6   = fc.core.roc.srio.omsg.fif0.mem2.
-                                                         - 5:4   = fc.core.roc.srio.omsg.fif0.mem0_l.
-                                                         - 3:2   = fc.core.roc.srio.omsg.fif0.mem0_h.
-                                                         - 1:0   = fc.core.roc.srio.imsg.pre.csr_mem. */
+	uint64_t flip                         : 44; /**< Error Insertion Bits for ECC syndromes.  Two per RAM.  Typically set to zero. */
 #else
 	uint64_t flip                         : 44;
 	uint64_t reserved_44_62               : 19;
@@ -1359,55 +1301,9 @@ union cvmx_sriox_ecc_status {
 	struct cvmx_sriox_ecc_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
-	uint64_t dbe                          : 22; /**< Double Bit Error detected.  Set bit indicates failure.
-                                                         INTERNAL:
-                                                         53 = fc.core.roc.srio.srio_mac.tx_buffer.memory.ram0.
-                                                         52 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram01.
-                                                         51 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram00.
-                                                         50 = fc.core.roc.srio.mgmt.spf.rx_spf_mem.
-                                                         49 = fc.core.roc.srio.mgmt.spf.tx_spf_mem.
-                                                         48 = fc.core.roc.srio.sli.tag.otag.
-                                                         47 = fc.core.roc.srio.sli.tag.itag.
-                                                         46 = fc.core.roc.srio.sli.ofifo.rtn.rtn.
-                                                         45 = fc.core.roc.srio.sli.ofifo.sh_bulk.m3.
-                                                         44 = fc.core.roc.srio.sli.ofifo.sh_bulk.m2.
-                                                         43 = fc.core.roc.srio.sli.ofifo.sh_bulk.m1.
-                                                         42 = fc.core.roc.srio.sli.ofifo.sh_bulk.m0.
-                                                         41 = Reserved.
-                                                         40 = Reserved.
-                                                         39 = fc.core.roc.srio.omsg.sil.mem.
-                                                         38 = fc.core.roc.srio.omsg.fif1.mem2.
-                                                         37 = fc.core.roc.srio.omsg.fif1.mem0_l.
-                                                         36 = fc.core.roc.srio.omsg.fif1.mem0_h.
-                                                         35 = fc.core.roc.srio.omsg.fif0.mem2.
-                                                         34 = fc.core.roc.srio.omsg.fif0.mem0_l.
-                                                         33 = fc.core.roc.srio.omsg.fif0.mem0_h.
-                                                         32 = fc.core.roc.srio.imsg.pre.csr_mem. */
+	uint64_t dbe                          : 22; /**< Double Bit Error detected.  Set bit indicates failure. */
 	uint64_t reserved_22_31               : 10;
-	uint64_t sbe                          : 22; /**< Single Bit Error detected.  Set bit indicates failure.
-                                                         INTERNAL:
-                                                         21 = fc.core.roc.srio.srio_mac.tx_buffer.memory.ram0.
-                                                         20 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram01.
-                                                         19 = fc.core.roc.srio.srio_mac.rx_buffer.memory.ram00.
-                                                         18 = fc.core.roc.srio.mgmt.spf.rx_spf_mem.
-                                                         17 = fc.core.roc.srio.mgmt.spf.tx_spf_mem.
-                                                         16 = fc.core.roc.srio.sli.tag.otag.
-                                                         15 = fc.core.roc.srio.sli.tag.itag.
-                                                         14 = fc.core.roc.srio.sli.ofifo.rtn.rtn.
-                                                         13 = fc.core.roc.srio.sli.ofifo.sh_bulk.m3.
-                                                         12 = fc.core.roc.srio.sli.ofifo.sh_bulk.m2.
-                                                         11 = fc.core.roc.srio.sli.ofifo.sh_bulk.m1.
-                                                         10 = fc.core.roc.srio.sli.ofifo.sh_bulk.m0.
-                                                         9 = Reserved.
-                                                         8 = Reserved.
-                                                         7 = fc.core.roc.srio.omsg.sil.mem.
-                                                         6 = fc.core.roc.srio.omsg.fif1.mem2.
-                                                         5 = fc.core.roc.srio.omsg.fif1.mem0_l.
-                                                         4 = fc.core.roc.srio.omsg.fif1.mem0_h.
-                                                         3 = fc.core.roc.srio.omsg.fif0.mem2.
-                                                         2 = fc.core.roc.srio.omsg.fif0.mem0_l.
-                                                         1 = fc.core.roc.srio.omsg.fif0.mem0_h.
-                                                         0 = fc.core.roc.srio.imsg.pre.csr_mem. */
+	uint64_t sbe                          : 22; /**< Single Bit Error detected.  Set bit indicates failure. */
 #else
 	uint64_t sbe                          : 22;
 	uint64_t reserved_22_31               : 10;
@@ -3261,7 +3157,7 @@ union cvmx_sriox_omsg_ctrlx {
 	uint64_t u64;
 	struct cvmx_sriox_omsg_ctrlx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t testmode                     : 1;  /**< Reserved. INTERNAL: Controller test mode (keep as RSVD in HRM). */
+	uint64_t testmode                     : 1;  /**< Reserved. */
 	uint64_t reserved_37_62               : 26;
 	uint64_t silo_max                     : 5;  /**< Sets max number outgoing segments for this controller.
                                                          Valid range is 0x01 .. 0x10  Note that lower
diff --git a/arch/mips/include/asm/octeon/cvmx-sso-defs.h b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
index 4a55525..1bf5d69 100644
--- a/arch/mips/include/asm/octeon/cvmx-sso-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
@@ -68,6 +68,7 @@ static inline uint64_t CVMX_SSO_ACTIVE_CYCLESX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 2))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 2)))))
 		cvmx_warn("CVMX_SSO_ACTIVE_CYCLESX(%lu) is invalid on this chip\n", offset);
@@ -80,7 +81,7 @@ static inline uint64_t CVMX_SSO_ACTIVE_CYCLESX(unsigned long offset)
 #define CVMX_SSO_AW_ADD CVMX_SSO_AW_ADD_FUNC()
 static inline uint64_t CVMX_SSO_AW_ADD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_AW_ADD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000002080ull);
 }
@@ -91,7 +92,7 @@ static inline uint64_t CVMX_SSO_AW_ADD_FUNC(void)
 #define CVMX_SSO_AW_CFG CVMX_SSO_AW_CFG_FUNC()
 static inline uint64_t CVMX_SSO_AW_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_AW_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000010F0ull);
 }
@@ -113,7 +114,7 @@ static inline uint64_t CVMX_SSO_AW_ECO_FUNC(void)
 #define CVMX_SSO_AW_READ_ARB CVMX_SSO_AW_READ_ARB_FUNC()
 static inline uint64_t CVMX_SSO_AW_READ_ARB_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_AW_READ_ARB not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000002090ull);
 }
@@ -124,7 +125,7 @@ static inline uint64_t CVMX_SSO_AW_READ_ARB_FUNC(void)
 #define CVMX_SSO_AW_STATUS CVMX_SSO_AW_STATUS_FUNC()
 static inline uint64_t CVMX_SSO_AW_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_AW_STATUS not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000010E0ull);
 }
@@ -135,7 +136,7 @@ static inline uint64_t CVMX_SSO_AW_STATUS_FUNC(void)
 #define CVMX_SSO_AW_TAG_LATENCY_PC CVMX_SSO_AW_TAG_LATENCY_PC_FUNC()
 static inline uint64_t CVMX_SSO_AW_TAG_LATENCY_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_AW_TAG_LATENCY_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020A8ull);
 }
@@ -146,7 +147,7 @@ static inline uint64_t CVMX_SSO_AW_TAG_LATENCY_PC_FUNC(void)
 #define CVMX_SSO_AW_TAG_REQ_PC CVMX_SSO_AW_TAG_REQ_PC_FUNC()
 static inline uint64_t CVMX_SSO_AW_TAG_REQ_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_AW_TAG_REQ_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020A0ull);
 }
@@ -157,7 +158,7 @@ static inline uint64_t CVMX_SSO_AW_TAG_REQ_PC_FUNC(void)
 #define CVMX_SSO_AW_WE CVMX_SSO_AW_WE_FUNC()
 static inline uint64_t CVMX_SSO_AW_WE_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_AW_WE not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001080ull);
 }
@@ -179,7 +180,7 @@ static inline uint64_t CVMX_SSO_BIST_STAT_FUNC(void)
 #define CVMX_SSO_BIST_STATUS0 CVMX_SSO_BIST_STATUS0_FUNC()
 static inline uint64_t CVMX_SSO_BIST_STATUS0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_BIST_STATUS0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001200ull);
 }
@@ -190,7 +191,7 @@ static inline uint64_t CVMX_SSO_BIST_STATUS0_FUNC(void)
 #define CVMX_SSO_BIST_STATUS1 CVMX_SSO_BIST_STATUS1_FUNC()
 static inline uint64_t CVMX_SSO_BIST_STATUS1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_BIST_STATUS1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001208ull);
 }
@@ -201,7 +202,7 @@ static inline uint64_t CVMX_SSO_BIST_STATUS1_FUNC(void)
 #define CVMX_SSO_BIST_STATUS2 CVMX_SSO_BIST_STATUS2_FUNC()
 static inline uint64_t CVMX_SSO_BIST_STATUS2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_BIST_STATUS2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001210ull);
 }
@@ -234,7 +235,7 @@ static inline uint64_t CVMX_SSO_DS_PC_FUNC(void)
 #define CVMX_SSO_ECC_CTL0 CVMX_SSO_ECC_CTL0_FUNC()
 static inline uint64_t CVMX_SSO_ECC_CTL0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_ECC_CTL0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001280ull);
 }
@@ -245,7 +246,7 @@ static inline uint64_t CVMX_SSO_ECC_CTL0_FUNC(void)
 #define CVMX_SSO_ECC_CTL1 CVMX_SSO_ECC_CTL1_FUNC()
 static inline uint64_t CVMX_SSO_ECC_CTL1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_ECC_CTL1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001288ull);
 }
@@ -256,7 +257,7 @@ static inline uint64_t CVMX_SSO_ECC_CTL1_FUNC(void)
 #define CVMX_SSO_ECC_CTL2 CVMX_SSO_ECC_CTL2_FUNC()
 static inline uint64_t CVMX_SSO_ECC_CTL2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_ECC_CTL2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001290ull);
 }
@@ -278,7 +279,7 @@ static inline uint64_t CVMX_SSO_ERR_FUNC(void)
 #define CVMX_SSO_ERR0 CVMX_SSO_ERR0_FUNC()
 static inline uint64_t CVMX_SSO_ERR0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_ERR0 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001240ull);
 }
@@ -289,7 +290,7 @@ static inline uint64_t CVMX_SSO_ERR0_FUNC(void)
 #define CVMX_SSO_ERR1 CVMX_SSO_ERR1_FUNC()
 static inline uint64_t CVMX_SSO_ERR1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_ERR1 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001248ull);
 }
@@ -300,7 +301,7 @@ static inline uint64_t CVMX_SSO_ERR1_FUNC(void)
 #define CVMX_SSO_ERR2 CVMX_SSO_ERR2_FUNC()
 static inline uint64_t CVMX_SSO_ERR2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_ERR2 not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001250ull);
 }
@@ -356,6 +357,7 @@ static inline uint64_t CVMX_SSO_GRPX_AQ_CNT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_GRPX_AQ_CNT(%lu) is invalid on this chip\n", offset);
@@ -369,6 +371,7 @@ static inline uint64_t CVMX_SSO_GRPX_AQ_THR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_GRPX_AQ_THR(%lu) is invalid on this chip\n", offset);
@@ -382,6 +385,7 @@ static inline uint64_t CVMX_SSO_GRPX_DS_PC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_GRPX_DS_PC(%lu) is invalid on this chip\n", offset);
@@ -395,6 +399,7 @@ static inline uint64_t CVMX_SSO_GRPX_EXT_PC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_GRPX_EXT_PC(%lu) is invalid on this chip\n", offset);
@@ -408,6 +413,7 @@ static inline uint64_t CVMX_SSO_GRPX_IAQ_THR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_GRPX_IAQ_THR(%lu) is invalid on this chip\n", offset);
@@ -421,6 +427,7 @@ static inline uint64_t CVMX_SSO_GRPX_INT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_GRPX_INT(%lu) is invalid on this chip\n", offset);
@@ -434,6 +441,7 @@ static inline uint64_t CVMX_SSO_GRPX_INT_CNT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_GRPX_INT_CNT(%lu) is invalid on this chip\n", offset);
@@ -447,6 +455,7 @@ static inline uint64_t CVMX_SSO_GRPX_INT_THR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_GRPX_INT_THR(%lu) is invalid on this chip\n", offset);
@@ -460,6 +469,7 @@ static inline uint64_t CVMX_SSO_GRPX_PRI(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_GRPX_PRI(%lu) is invalid on this chip\n", offset);
@@ -473,6 +483,7 @@ static inline uint64_t CVMX_SSO_GRPX_TAQ_THR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_GRPX_TAQ_THR(%lu) is invalid on this chip\n", offset);
@@ -486,6 +497,7 @@ static inline uint64_t CVMX_SSO_GRPX_TS_PC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_GRPX_TS_PC(%lu) is invalid on this chip\n", offset);
@@ -499,6 +511,7 @@ static inline uint64_t CVMX_SSO_GRPX_WA_PC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_GRPX_WA_PC(%lu) is invalid on this chip\n", offset);
@@ -512,6 +525,7 @@ static inline uint64_t CVMX_SSO_GRPX_WS_PC(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_GRPX_WS_PC(%lu) is invalid on this chip\n", offset);
@@ -524,7 +538,7 @@ static inline uint64_t CVMX_SSO_GRPX_WS_PC(unsigned long offset)
 #define CVMX_SSO_GWE_CFG CVMX_SSO_GWE_CFG_FUNC()
 static inline uint64_t CVMX_SSO_GWE_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_GWE_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001098ull);
 }
@@ -535,7 +549,7 @@ static inline uint64_t CVMX_SSO_GWE_CFG_FUNC(void)
 #define CVMX_SSO_GWE_RANDOM CVMX_SSO_GWE_RANDOM_FUNC()
 static inline uint64_t CVMX_SSO_GWE_RANDOM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_GWE_RANDOM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000010B0ull);
 }
@@ -580,6 +594,7 @@ static inline uint64_t CVMX_SSO_IENTX_LINKS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_SSO_IENTX_LINKS(%lu) is invalid on this chip\n", offset);
@@ -593,6 +608,7 @@ static inline uint64_t CVMX_SSO_IENTX_PENDTAG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_SSO_IENTX_PENDTAG(%lu) is invalid on this chip\n", offset);
@@ -606,6 +622,7 @@ static inline uint64_t CVMX_SSO_IENTX_QLINKS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_SSO_IENTX_QLINKS(%lu) is invalid on this chip\n", offset);
@@ -619,6 +636,7 @@ static inline uint64_t CVMX_SSO_IENTX_TAG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_SSO_IENTX_TAG(%lu) is invalid on this chip\n", offset);
@@ -632,6 +650,7 @@ static inline uint64_t CVMX_SSO_IENTX_WQPGRP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1023))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4095))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_SSO_IENTX_WQPGRP(%lu) is invalid on this chip\n", offset);
@@ -645,6 +664,7 @@ static inline uint64_t CVMX_SSO_IPL_CONFX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_IPL_CONFX(%lu) is invalid on this chip\n", offset);
@@ -658,6 +678,7 @@ static inline uint64_t CVMX_SSO_IPL_DESCHEDX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_IPL_DESCHEDX(%lu) is invalid on this chip\n", offset);
@@ -671,6 +692,7 @@ static inline uint64_t CVMX_SSO_IPL_FREEX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 4))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 4))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 4)))))
 		cvmx_warn("CVMX_SSO_IPL_FREEX(%lu) is invalid on this chip\n", offset);
@@ -684,6 +706,7 @@ static inline uint64_t CVMX_SSO_IPL_IAQX(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_IPL_IAQX(%lu) is invalid on this chip\n", offset);
@@ -751,7 +774,7 @@ static inline uint64_t CVMX_SSO_IQ_THRX(unsigned long offset)
 #define CVMX_SSO_NOS_CNT CVMX_SSO_NOS_CNT_FUNC()
 static inline uint64_t CVMX_SSO_NOS_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_NOS_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001040ull);
 }
@@ -762,7 +785,7 @@ static inline uint64_t CVMX_SSO_NOS_CNT_FUNC(void)
 #define CVMX_SSO_NW_TIM CVMX_SSO_NW_TIM_FUNC()
 static inline uint64_t CVMX_SSO_NW_TIM_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_NW_TIM not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001028ull);
 }
@@ -795,7 +818,7 @@ static inline uint64_t CVMX_SSO_OTH_ECC_ST_FUNC(void)
 #define CVMX_SSO_PAGE_CNT CVMX_SSO_PAGE_CNT_FUNC()
 static inline uint64_t CVMX_SSO_PAGE_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_PAGE_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001090ull);
 }
@@ -829,6 +852,7 @@ static inline uint64_t CVMX_SSO_PPX_ARB(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_SSO_PPX_ARB(%lu) is invalid on this chip\n", offset);
@@ -864,6 +888,7 @@ static inline uint64_t CVMX_SSO_PPX_SX_GRPMSKX(unsigned long a, unsigned long b,
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((a <= 15)) && ((b <= 1)) && ((c == 0)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((a <= 47)) && ((b <= 1)) && ((c <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((a <= 47)) && ((b <= 1)) && ((c <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((a <= 15)) && ((b <= 1)) && ((c == 0))))))
 		cvmx_warn("CVMX_SSO_PPX_SX_GRPMSKX(%lu,%lu,%lu) is invalid on this chip\n", a, b, c);
@@ -924,6 +949,10 @@ static inline uint64_t CVMX_SSO_RESET_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+					return CVMX_ADD_IO_SEG(0x00016700000010F8ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+					return CVMX_ADD_IO_SEG(0x00016700000010F8ull);
 			return CVMX_ADD_IO_SEG(0x00016700000010F8ull);
 			break;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
@@ -941,6 +970,10 @@ static inline uint64_t CVMX_SSO_RESET_FUNC(void)
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x00016700000010F8ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x00016700000010F8ull);
 			return CVMX_ADD_IO_SEG(0x00016700000010F8ull);
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x00016700000010F0ull);
@@ -997,6 +1030,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_LINKS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_LINKS(%lu) is invalid on this chip\n", offset);
@@ -1010,6 +1044,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_PENDTAG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_PENDTAG(%lu) is invalid on this chip\n", offset);
@@ -1023,6 +1058,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_PENDWQP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_PENDWQP(%lu) is invalid on this chip\n", offset);
@@ -1036,6 +1072,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_TAG(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_TAG(%lu) is invalid on this chip\n", offset);
@@ -1049,6 +1086,7 @@ static inline uint64_t CVMX_SSO_SL_PPX_WQP(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 15))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 47))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 15)))))
 		cvmx_warn("CVMX_SSO_SL_PPX_WQP(%lu) is invalid on this chip\n", offset);
@@ -1062,6 +1100,7 @@ static inline uint64_t CVMX_SSO_TAQX_LINK(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 319))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 1279))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1279))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 319)))))
 		cvmx_warn("CVMX_SSO_TAQX_LINK(%lu) is invalid on this chip\n", offset);
@@ -1075,6 +1114,7 @@ static inline uint64_t CVMX_SSO_TAQX_WAEX_TAG(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 12)) && ((block_id <= 319)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 12)) && ((block_id <= 1279)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 1279)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 12)) && ((block_id <= 319))))))
 		cvmx_warn("CVMX_SSO_TAQX_WAEX_TAG(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1088,6 +1128,7 @@ static inline uint64_t CVMX_SSO_TAQX_WAEX_WQP(unsigned long offset, unsigned lon
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 12)) && ((block_id <= 319)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 12)) && ((block_id <= 1279)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 1279)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 12)) && ((block_id <= 319))))))
 		cvmx_warn("CVMX_SSO_TAQX_WAEX_WQP(%lu,%lu) is invalid on this chip\n", offset, block_id);
@@ -1100,7 +1141,7 @@ static inline uint64_t CVMX_SSO_TAQX_WAEX_WQP(unsigned long offset, unsigned lon
 #define CVMX_SSO_TAQ_ADD CVMX_SSO_TAQ_ADD_FUNC()
 static inline uint64_t CVMX_SSO_TAQ_ADD_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_TAQ_ADD not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020E0ull);
 }
@@ -1111,7 +1152,7 @@ static inline uint64_t CVMX_SSO_TAQ_ADD_FUNC(void)
 #define CVMX_SSO_TAQ_CNT CVMX_SSO_TAQ_CNT_FUNC()
 static inline uint64_t CVMX_SSO_TAQ_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_TAQ_CNT not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020C0ull);
 }
@@ -1123,6 +1164,7 @@ static inline uint64_t CVMX_SSO_TIAQX_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_TIAQX_STATUS(%lu) is invalid on this chip\n", offset);
@@ -1136,6 +1178,7 @@ static inline uint64_t CVMX_SSO_TOAQX_STATUS(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_TOAQX_STATUS(%lu) is invalid on this chip\n", offset);
@@ -1203,7 +1246,7 @@ static inline uint64_t CVMX_SSO_WQ_INT_CNTX(unsigned long offset)
 #define CVMX_SSO_WQ_INT_PC CVMX_SSO_WQ_INT_PC_FUNC()
 static inline uint64_t CVMX_SSO_WQ_INT_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_WQ_INT_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001020ull);
 }
@@ -1236,7 +1279,7 @@ static inline uint64_t CVMX_SSO_WQ_IQ_DIS_FUNC(void)
 #define CVMX_SSO_WS_CFG CVMX_SSO_WS_CFG_FUNC()
 static inline uint64_t CVMX_SSO_WS_CFG_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_WS_CFG not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000001088ull);
 }
@@ -1270,6 +1313,7 @@ static inline uint64_t CVMX_SSO_XAQX_HEAD_NEXT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_XAQX_HEAD_NEXT(%lu) is invalid on this chip\n", offset);
@@ -1283,6 +1327,7 @@ static inline uint64_t CVMX_SSO_XAQX_HEAD_PTR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_XAQX_HEAD_PTR(%lu) is invalid on this chip\n", offset);
@@ -1296,6 +1341,7 @@ static inline uint64_t CVMX_SSO_XAQX_TAIL_NEXT(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_XAQX_TAIL_NEXT(%lu) is invalid on this chip\n", offset);
@@ -1309,6 +1355,7 @@ static inline uint64_t CVMX_SSO_XAQX_TAIL_PTR(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 63))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 255))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 63)))))
 		cvmx_warn("CVMX_SSO_XAQX_TAIL_PTR(%lu) is invalid on this chip\n", offset);
@@ -1321,7 +1368,7 @@ static inline uint64_t CVMX_SSO_XAQX_TAIL_PTR(unsigned long offset)
 #define CVMX_SSO_XAQ_AURA CVMX_SSO_XAQ_AURA_FUNC()
 static inline uint64_t CVMX_SSO_XAQ_AURA_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_XAQ_AURA not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x0001670000002100ull);
 }
@@ -1332,7 +1379,7 @@ static inline uint64_t CVMX_SSO_XAQ_AURA_FUNC(void)
 #define CVMX_SSO_XAQ_LATENCY_PC CVMX_SSO_XAQ_LATENCY_PC_FUNC()
 static inline uint64_t CVMX_SSO_XAQ_LATENCY_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_XAQ_LATENCY_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020B8ull);
 }
@@ -1343,7 +1390,7 @@ static inline uint64_t CVMX_SSO_XAQ_LATENCY_PC_FUNC(void)
 #define CVMX_SSO_XAQ_REQ_PC CVMX_SSO_XAQ_REQ_PC_FUNC()
 static inline uint64_t CVMX_SSO_XAQ_REQ_PC_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SSO_XAQ_REQ_PC not supported on this chip\n");
 	return CVMX_ADD_IO_SEG(0x00016700000020B0ull);
 }
@@ -1469,7 +1516,7 @@ union cvmx_sso_aw_eco {
 	struct cvmx_sso_aw_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t eco_rw                       : 8;  /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 8;  /**< N/A */
 #else
 	uint64_t eco_rw                       : 8;
 	uint64_t reserved_8_63                : 56;
@@ -1727,17 +1774,7 @@ union cvmx_sso_bist_status0 {
 	struct cvmx_sso_bist_status0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
-	uint64_t bist                         : 10; /**< Memory BIST status. 0 = pass, 1 = fail. INTERNAL:
-                                                         <9> = WES.
-                                                         <8> = FFF.
-                                                         <7> = XAQ.
-                                                         <6> = QTC.
-                                                         <5> = INP.
-                                                         <4> = LLM.
-                                                         <3> = TIAQ_HPTR.
-                                                         <2> = TIAQ_TPTR.
-                                                         <1> = TOAQ_HPTR.
-                                                         <0> = TOAQ_TPTR. */
+	uint64_t bist                         : 10; /**< Memory BIST status. 0 = pass, 1 = fail. */
 #else
 	uint64_t bist                         : 10;
 	uint64_t reserved_10_63               : 54;
@@ -1761,14 +1798,7 @@ union cvmx_sso_bist_status1 {
 	struct cvmx_sso_bist_status1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
-	uint64_t bist                         : 7;  /**< Memory BIST status. 0 = pass, 1 = fail. INTERNAL:
-                                                         <6> = THRINT.
-                                                         <5> = MASK.
-                                                         <4> = GDW.
-                                                         <3> = QIDX.
-                                                         <2> = TPTR.
-                                                         <1> = HPTR.
-                                                         <0> = CNTR. */
+	uint64_t bist                         : 7;  /**< Memory BIST status. 0 = pass, 1 = fail. */
 #else
 	uint64_t bist                         : 7;
 	uint64_t reserved_7_63                : 57;
@@ -1792,16 +1822,7 @@ union cvmx_sso_bist_status2 {
 	struct cvmx_sso_bist_status2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
-	uint64_t bist                         : 9;  /**< Memory BIST status. 0 = pass, 1 = fail. INTERNAL:
-                                                         <8> = PC_WS.
-                                                         <7> = PC_WA.
-                                                         <6> = PC_TS.
-                                                         <5> = PC_DS.
-                                                         <4> = NCB0.
-                                                         <3> = PND.
-                                                         <2> = OTH.
-                                                         <1> = NIDX.
-                                                         <0> = PIDX. */
+	uint64_t bist                         : 9;  /**< Memory BIST status. 0 = pass, 1 = fail. */
 #else
 	uint64_t bist                         : 9;
 	uint64_t reserved_9_63                : 55;
@@ -2592,8 +2613,7 @@ union cvmx_sso_grpx_iaq_thr {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_61_63               : 3;
 	uint64_t grp_cnt                      : 13; /**< Group's entry count. Number of internal entries allocated to IAQ, conflicted work, or CQ
-                                                         in this group. INTERNAL: Increments on admission to IAQ, decrements on scheduling into
-                                                         work slot. */
+                                                         in this group. */
 	uint64_t reserved_45_47               : 3;
 	uint64_t max_thr                      : 13; /**< Max threshold for this internal admission queue. If non-zero, must be >= [RSVD_THR] + 4.
                                                          To insure full streaming performance to all cores, should be at least 208. Must not be
@@ -2914,7 +2934,7 @@ union cvmx_sso_gw_eco {
 	struct cvmx_sso_gw_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t eco_rw                       : 8;  /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 8;  /**< N/A */
 #else
 	uint64_t eco_rw                       : 8;
 	uint64_t reserved_8_63                : 56;
@@ -3034,18 +3054,7 @@ union cvmx_sso_gwe_random {
 	uint64_t reserved_16_63               : 48;
 	uint64_t rnd                          : 16; /**< Current random value, with low 8 bits indicating first group to start next get-work search
                                                          at. Changes on each work search, even if unsuccessful or retried. For diagnostic use only,
-                                                         must not be zero. INTERNAL: Uses 16, 15, 13, 4 tap LFSR (this choice is important to
-                                                         insure even group probabilities) with the formula:
-                                                         _ grp_to_start_arb_at = RND[7:0];
-                                                         _ RND_next[15:8] = RND[7:0];
-                                                         _ RND_next[7] = ^(RND[15:0] & 0xd008);
-                                                         _ RND_next[6] = ^(RND[15:0] & 0x6804);
-                                                         _ RND_next[5] = ^(RND[15:0] & 0x3402);
-                                                         _ RND_next[4] = ^(RND[15:0] & 0x1a01);
-                                                         _ RND_next[3] = ^(RND[15:0] & 0xdd08);
-                                                         _ RND_next[2] = ^(RND[15:0] & 0x6e84);
-                                                         _ RND_next[1] = ^(RND[15:0] & 0x3742);
-                                                         _ RND_next[0] = ^(RND[15:0] & 0x1ba1); */
+                                                         must not be zero. */
 #else
 	uint64_t rnd                          : 16;
 	uint64_t reserved_16_63               : 48;
@@ -3140,7 +3149,7 @@ union cvmx_sso_ientx_links {
 	uint64_t prev_index                   : 10; /**< The previous entry in the tag chain. Unpredictable if the entry is at the head of the list
                                                          or the head of a conflicted tag chain. */
 	uint64_t reserved_11_15               : 5;
-	uint64_t next_index_vld               : 1;  /**< The NEXT_INDEX is valid. Unpredictable unless the entry is the tail entry of an atomic tag chain. */
+	uint64_t next_index_vld               : 1;  /**< The [NEXT_INDEX] is valid. Unpredictable unless the entry is the tail entry of an atomic tag chain. */
 	uint64_t next_index                   : 10; /**< The next entry in the tag chain or conflicted tag chain. Unpredictable if the entry is at
                                                          the tail of the list. */
 #else
@@ -3157,7 +3166,7 @@ union cvmx_sso_ientx_links {
 	uint64_t prev_index                   : 12; /**< The previous entry in the tag chain. Unpredictable if the entry is at the head of the list
                                                          or the head of a conflicted tag chain. */
 	uint64_t reserved_13_15               : 3;
-	uint64_t next_index_vld               : 1;  /**< The NEXT_INDEX is valid. Unpredictable unless the entry is the tail entry of an atomic tag chain. */
+	uint64_t next_index_vld               : 1;  /**< The [NEXT_INDEX] is valid. Unpredictable unless the entry is the tail entry of an atomic tag chain. */
 	uint64_t next_index                   : 12; /**< The next entry in the tag chain or conflicted tag chain. Unpredictable if the entry is at
                                                          the tail of the list. */
 #else
@@ -3241,7 +3250,7 @@ union cvmx_sso_ientx_tag {
 	uint64_t reserved_39_63               : 25;
 	uint64_t tailc                        : 1;  /**< The SSO entry is the tail of tag chain that is conflicted. No conflicted chain exists if
                                                          TAIL is also set on the same entry. */
-	uint64_t tail                         : 1;  /**< The SSO entry is the tail of tag chain that is descheduled. INTERNAL: Read from the SOC. */
+	uint64_t tail                         : 1;  /**< The SSO entry is the tail of tag chain that is descheduled. */
 	uint64_t reserved_34_36               : 3;
 	uint64_t tt                           : 2;  /**< The tag type of the SSO entry. Enumerated by SSO_TT_E. */
 	uint64_t tag                          : 32; /**< The tag of the SSO entry. */
@@ -3275,9 +3284,7 @@ union cvmx_sso_ientx_wqpgrp {
 	uint64_t head                         : 1;  /**< SSO entry is at the head of a tag chain that is descheduled. */
 	uint64_t nosched                      : 1;  /**< The nosched bit for the SSO entry. */
 	uint64_t reserved_58_59               : 2;
-	uint64_t grp                          : 10; /**< Group of the SSO entry.
-                                                         INTERNAL:
-                                                         The upper bits are not stored in the RAM, but rather indicate the OCI node number. */
+	uint64_t grp                          : 10; /**< Group of the SSO entry. */
 	uint64_t reserved_42_47               : 6;
 	uint64_t wqp                          : 42; /**< Work queue pointer held in the SSO entry. */
 #else
@@ -3296,9 +3303,7 @@ union cvmx_sso_ientx_wqpgrp {
 	uint64_t head                         : 1;  /**< SSO entry is at the head of a tag chain that is descheduled. */
 	uint64_t nosched                      : 1;  /**< The nosched bit for the SSO entry. */
 	uint64_t reserved_56_59               : 4;
-	uint64_t grp                          : 8;  /**< Group of the SSO entry.
-                                                         INTERNAL:
-                                                         The upper bits are not stored in the RAM, but rather indicate the OCI node number. */
+	uint64_t grp                          : 8;  /**< Group of the SSO entry. */
 	uint64_t reserved_42_47               : 6;
 	uint64_t wqp                          : 42; /**< Work queue pointer held in the SSO entry. */
 #else
@@ -4321,9 +4326,7 @@ union cvmx_sso_sl_ppx_links {
 	uint64_t reserved_60_62               : 3;
 	uint64_t index                        : 12; /**< The SSO entry attached to the core. */
 	uint64_t reserved_38_47               : 10;
-	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
-                                                         INTERNAL:
-                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
 	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t reserved_0_25                : 26;
@@ -4345,9 +4348,7 @@ union cvmx_sso_sl_ppx_links {
 	uint64_t reserved_58_62               : 5;
 	uint64_t index                        : 10; /**< The SSO entry attached to the core. */
 	uint64_t reserved_36_47               : 12;
-	uint64_t grp                          : 8;  /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
-                                                         INTERNAL:
-                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t grp                          : 8;  /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
 	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t reserved_21_25               : 5;
@@ -4539,9 +4540,7 @@ union cvmx_sso_sl_ppx_tag {
 	uint64_t reserved_60_62               : 3;
 	uint64_t index                        : 12; /**< The SSO entry attached to the core. */
 	uint64_t reserved_46_47               : 2;
-	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
-                                                         INTERNAL:
-                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
 	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t tt                           : 2;  /**< The tag type attached to the core (updated when new tag list entered on SWTAG, SWTAG_FULL,
@@ -4567,9 +4566,7 @@ union cvmx_sso_sl_ppx_tag {
 	uint64_t reserved_58_62               : 5;
 	uint64_t index                        : 10; /**< The SSO entry attached to the core. */
 	uint64_t reserved_44_47               : 4;
-	uint64_t grp                          : 8;  /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
-                                                         INTERNAL:
-                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t grp                          : 8;  /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
 	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t tt                           : 2;  /**< The tag type attached to the core (updated when new tag list entered on SWTAG, SWTAG_FULL,
@@ -4605,9 +4602,7 @@ union cvmx_sso_sl_ppx_wqp {
 	struct cvmx_sso_sl_ppx_wqp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_58_63               : 6;
-	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
-                                                         INTERNAL:
-                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
 	uint64_t reserved_42_47               : 6;
 	uint64_t wqp                          : 42; /**< The WQP attached to the core (updated when new tag list entered on SWTAG_FULL.) */
 #else
@@ -4620,9 +4615,7 @@ union cvmx_sso_sl_ppx_wqp {
 	struct cvmx_sso_sl_ppx_wqp_cn73xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_56_63               : 8;
-	uint64_t grp                          : 8;  /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
-                                                         INTERNAL:
-                                                         The upper two bits are hardcoded to the node number. */
+	uint64_t grp                          : 8;  /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
 	uint64_t reserved_42_47               : 6;
 	uint64_t wqp                          : 42; /**< The WQP attached to the core (updated when new tag list entered on SWTAG_FULL.) */
 #else
@@ -4778,10 +4771,10 @@ union cvmx_sso_tiaqx_status {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t wae_head                     : 4;  /**< Head's WAE number within current cache line, 0-12. This provides the second index into
                                                          SSO_TAQ()_WAE()_TAG and SSO_TAQ()_WAE()_WQP. */
-	uint64_t wae_tail                     : 4;  /**< When WAE_USED is non-zero, this provides the next free WAE number in the cache line of the
-                                                         tail entry. If 0, the next entry will be placed at the beginning of a new cache line. This
-                                                         provides the second index into
-                                                         SSO_TAQ()_WAE()_TAG and SSO_TAQ()_WAE()_WQP. */
+	uint64_t wae_tail                     : 4;  /**< When [WAE_USED] is non-zero, this provides the next free WAE number in the cache
+                                                         line of the tail entry. If 0x0, the next entry will be placed at the beginning of
+                                                         a new cache line. This provides the second index into SSO_TAQ()_WAE()_TAG and
+                                                         SSO_TAQ()_WAE()_WQP. */
 	uint64_t reserved_47_55               : 9;
 	uint64_t wae_used                     : 15; /**< Number of WAEs in use. */
 	uint64_t reserved_23_31               : 9;
@@ -5135,16 +5128,7 @@ union cvmx_sso_ws_cfg {
 	struct cvmx_sso_ws_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_56_63               : 8;
-	uint64_t ocla_bp                      : 8;  /**< Enable OCLA backpressure stalls. For diagnostic use only.
-                                                         INTERNAL:
-                                                         <55> = NCBB input fifo stall (ncbo).
-                                                         <54> = Work-slot response. (arbrsp).
-                                                         <53> = Work-slot switching of descheduled work entries. (arbx).
-                                                         <52> = Work-slot SWTAG response. (arbs).
-                                                         <51> = Work-slot access to get-work engine. (arbgw).
-                                                         <50> = Work-slot CAM access. (arbc).
-                                                         <49> = Work-slot RAM access. (arbr).
-                                                         <48> = Work-slot pushes to AQ, CQ, DQ. (arbq). */
+	uint64_t ocla_bp                      : 8;  /**< Enable OCLA backpressure stalls. For diagnostic use only. */
 	uint64_t reserved_7_47                : 41;
 	uint64_t aw_clk_dis                   : 1;  /**< Reserved. */
 	uint64_t gw_clk_dis                   : 1;  /**< Reserved. */
@@ -5170,16 +5154,7 @@ union cvmx_sso_ws_cfg {
 	struct cvmx_sso_ws_cfg_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_56_63               : 8;
-	uint64_t ocla_bp                      : 8;  /**< Enable OCLA backpressure stalls. For diagnostic use only.
-                                                         INTERNAL:
-                                                         <55> = NCBB input fifo stall (ncbo).
-                                                         <54> = Work-slot response. (arbrsp).
-                                                         <53> = Work-slot switching of descheduled work entries. (arbx).
-                                                         <52> = Work-slot SWTAG response. (arbs).
-                                                         <51> = Work-slot access to get-work engine. (arbgw).
-                                                         <50> = Work-slot CAM access. (arbc).
-                                                         <49> = Work-slot RAM access. (arbr).
-                                                         <48> = Work-slot pushes to AQ, CQ, DQ. (arbq). */
+	uint64_t ocla_bp                      : 8;  /**< Enable OCLA backpressure stalls. For diagnostic use only. */
 	uint64_t reserved_5_47                : 43;
 	uint64_t disable_pw                   : 1;  /**< Reserved. */
 	uint64_t arbc_step_en                 : 1;  /**< Enable single-stepping WS CAM arbiter, twice per 16 clocks. For diagnostic use only. */
@@ -5210,7 +5185,7 @@ union cvmx_sso_ws_eco {
 	struct cvmx_sso_ws_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t eco_rw                       : 8;  /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 8;  /**< N/A */
 #else
 	uint64_t eco_rw                       : 8;
 	uint64_t reserved_8_63                : 56;
@@ -5257,9 +5232,7 @@ union cvmx_sso_xaqx_head_next {
 	struct cvmx_sso_xaqx_head_next_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
-	uint64_t ptr                          : 35; /**< Pointer, divided by 128 bytes.
-                                                         INTERNAL:
-                                                         For peak performance, all XAQ buffers should reside on the local node's memory. */
+	uint64_t ptr                          : 35; /**< Pointer, divided by 128 bytes. */
 	uint64_t reserved_0_6                 : 7;
 #else
 	uint64_t reserved_0_6                 : 7;
@@ -5287,9 +5260,7 @@ union cvmx_sso_xaqx_head_ptr {
 	struct cvmx_sso_xaqx_head_ptr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
-	uint64_t ptr                          : 35; /**< Pointer, divided by 128 bytes.
-                                                         INTERNAL:
-                                                         For peak performance, all XAQ buffers should reside on the local node's memory. */
+	uint64_t ptr                          : 35; /**< Pointer, divided by 128 bytes. */
 	uint64_t reserved_5_6                 : 2;
 	uint64_t cl                           : 5;  /**< Cache line number in buffer. Cache line zero contains the next pointer. */
 #else
@@ -5318,9 +5289,7 @@ union cvmx_sso_xaqx_tail_next {
 	struct cvmx_sso_xaqx_tail_next_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
-	uint64_t ptr                          : 35; /**< Pointer, divided by 128 bytes.
-                                                         INTERNAL:
-                                                         For peak performance, all XAQ buffers should reside on the local node's memory. */
+	uint64_t ptr                          : 35; /**< Pointer, divided by 128 bytes. */
 	uint64_t reserved_0_6                 : 7;
 #else
 	uint64_t reserved_0_6                 : 7;
@@ -5349,9 +5318,7 @@ union cvmx_sso_xaqx_tail_ptr {
 	struct cvmx_sso_xaqx_tail_ptr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
-	uint64_t ptr                          : 35; /**< Pointer, divided by 128 bytes.
-                                                         INTERNAL:
-                                                         For peak performance, all XAQ buffers should reside on the local node's memory. */
+	uint64_t ptr                          : 35; /**< Pointer, divided by 128 bytes. */
 	uint64_t reserved_5_6                 : 2;
 	uint64_t cl                           : 5;  /**< Cache line number in buffer. Cache line zero contains the next pointer. */
 #else
@@ -5376,8 +5343,7 @@ union cvmx_sso_xaq_aura {
 	struct cvmx_sso_xaq_aura_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
-	uint64_t node                         : 2;  /**< Reserved. INTERNAL:
-                                                         Node number of current chip, to ensure that the aura is on the local node. */
+	uint64_t node                         : 2;  /**< Reserved. */
 	uint64_t laura                        : 10; /**< FPA local-node aura to use for SSO XAQ allocations and frees. The FPA aura
                                                          selected by LAURA must correspond to a pool where the buffers (after any
                                                          FPA_POOL()_CFG[BUF_OFFSET]) are at least 4 KB. */
diff --git a/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h b/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h
index a5b70a9..47ba545 100644
--- a/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-uahcx-defs.h
@@ -56,6 +56,7 @@
 static inline uint64_t CVMX_UAHCX_CAPLENGTH(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_CAPLENGTH(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000000ull);
@@ -67,6 +68,7 @@ static inline uint64_t CVMX_UAHCX_CAPLENGTH(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_CONFIG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_CONFIG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000058ull);
@@ -78,6 +80,7 @@ static inline uint64_t CVMX_UAHCX_CONFIG(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_CRCR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_CRCR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000038ull);
@@ -89,6 +92,7 @@ static inline uint64_t CVMX_UAHCX_CRCR(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_DBOFF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_DBOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000014ull);
@@ -100,6 +104,7 @@ static inline uint64_t CVMX_UAHCX_DBOFF(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_DBX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 64)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 64)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_DBX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000480ull) + (((offset) & 127) + ((block_id) & 0) * 0x0ull) * 4;
@@ -111,6 +116,7 @@ static inline uint64_t CVMX_UAHCX_DBX(unsigned long offset, unsigned long block_
 static inline uint64_t CVMX_UAHCX_DCBAAP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_DCBAAP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000050ull);
@@ -122,6 +128,7 @@ static inline uint64_t CVMX_UAHCX_DCBAAP(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_DNCTRL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_DNCTRL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000034ull);
@@ -388,6 +395,7 @@ static inline uint64_t CVMX_UAHCX_EHCI_USBSTS(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_ERDPX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_ERDPX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000478ull);
@@ -399,6 +407,7 @@ static inline uint64_t CVMX_UAHCX_ERDPX(unsigned long offset, unsigned long bloc
 static inline uint64_t CVMX_UAHCX_ERSTBAX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_ERSTBAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000470ull);
@@ -410,6 +419,7 @@ static inline uint64_t CVMX_UAHCX_ERSTBAX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_UAHCX_ERSTSZX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_ERSTSZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000468ull);
@@ -421,6 +431,7 @@ static inline uint64_t CVMX_UAHCX_ERSTSZX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_UAHCX_GBUSERRADDR(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GBUSERRADDR(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C130ull);
@@ -432,6 +443,7 @@ static inline uint64_t CVMX_UAHCX_GBUSERRADDR(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GCTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GCTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C110ull);
@@ -443,6 +455,7 @@ static inline uint64_t CVMX_UAHCX_GCTL(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GDBGBMU(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GDBGBMU(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C16Cull);
@@ -454,6 +467,7 @@ static inline uint64_t CVMX_UAHCX_GDBGBMU(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GDBGEPINFO(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GDBGEPINFO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C178ull);
@@ -465,6 +479,7 @@ static inline uint64_t CVMX_UAHCX_GDBGEPINFO(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GDBGFIFOSPACE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GDBGFIFOSPACE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C160ull);
@@ -476,6 +491,7 @@ static inline uint64_t CVMX_UAHCX_GDBGFIFOSPACE(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GDBGLNMCC(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GDBGLNMCC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C168ull);
@@ -487,6 +503,7 @@ static inline uint64_t CVMX_UAHCX_GDBGLNMCC(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GDBGLSP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GDBGLSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C174ull);
@@ -498,6 +515,7 @@ static inline uint64_t CVMX_UAHCX_GDBGLSP(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GDBGLSPMUX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GDBGLSPMUX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C170ull);
@@ -509,6 +527,7 @@ static inline uint64_t CVMX_UAHCX_GDBGLSPMUX(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GDBGLTSSM(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GDBGLTSSM(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C164ull);
@@ -520,6 +539,7 @@ static inline uint64_t CVMX_UAHCX_GDBGLTSSM(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GDMAHLRATIO(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GDMAHLRATIO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C624ull);
@@ -531,6 +551,7 @@ static inline uint64_t CVMX_UAHCX_GDMAHLRATIO(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GFLADJ(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GFLADJ(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C630ull);
@@ -542,6 +563,7 @@ static inline uint64_t CVMX_UAHCX_GFLADJ(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GGPIO(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GGPIO(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C124ull);
@@ -553,6 +575,7 @@ static inline uint64_t CVMX_UAHCX_GGPIO(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GHWPARAMS0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GHWPARAMS0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C140ull);
@@ -564,6 +587,7 @@ static inline uint64_t CVMX_UAHCX_GHWPARAMS0(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GHWPARAMS1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GHWPARAMS1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C144ull);
@@ -575,6 +599,7 @@ static inline uint64_t CVMX_UAHCX_GHWPARAMS1(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GHWPARAMS2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GHWPARAMS2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C148ull);
@@ -586,6 +611,7 @@ static inline uint64_t CVMX_UAHCX_GHWPARAMS2(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GHWPARAMS3(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GHWPARAMS3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C14Cull);
@@ -597,6 +623,7 @@ static inline uint64_t CVMX_UAHCX_GHWPARAMS3(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GHWPARAMS4(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GHWPARAMS4(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C150ull);
@@ -608,6 +635,7 @@ static inline uint64_t CVMX_UAHCX_GHWPARAMS4(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GHWPARAMS5(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GHWPARAMS5(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C154ull);
@@ -619,6 +647,7 @@ static inline uint64_t CVMX_UAHCX_GHWPARAMS5(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GHWPARAMS6(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GHWPARAMS6(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C158ull);
@@ -630,6 +659,7 @@ static inline uint64_t CVMX_UAHCX_GHWPARAMS6(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GHWPARAMS7(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GHWPARAMS7(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C15Cull);
@@ -641,6 +671,7 @@ static inline uint64_t CVMX_UAHCX_GHWPARAMS7(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GHWPARAMS8(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GHWPARAMS8(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C600ull);
@@ -652,6 +683,7 @@ static inline uint64_t CVMX_UAHCX_GHWPARAMS8(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GPMSTS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GPMSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C114ull);
@@ -663,6 +695,7 @@ static inline uint64_t CVMX_UAHCX_GPMSTS(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GPRTBIMAP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GPRTBIMAP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C138ull);
@@ -674,6 +707,7 @@ static inline uint64_t CVMX_UAHCX_GPRTBIMAP(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GPRTBIMAP_FS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GPRTBIMAP_FS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C188ull);
@@ -685,6 +719,7 @@ static inline uint64_t CVMX_UAHCX_GPRTBIMAP_FS(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GPRTBIMAP_HS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GPRTBIMAP_HS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C180ull);
@@ -696,6 +731,7 @@ static inline uint64_t CVMX_UAHCX_GPRTBIMAP_HS(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GRLSID(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GRLSID(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C120ull);
@@ -707,6 +743,7 @@ static inline uint64_t CVMX_UAHCX_GRLSID(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GRXFIFOPRIHST(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GRXFIFOPRIHST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C61Cull);
@@ -718,6 +755,7 @@ static inline uint64_t CVMX_UAHCX_GRXFIFOPRIHST(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GRXFIFOSIZX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 2)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 2)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_GRXFIFOSIZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C380ull) + (((offset) & 3) + ((block_id) & 0) * 0x0ull) * 4;
@@ -729,6 +767,7 @@ static inline uint64_t CVMX_UAHCX_GRXFIFOSIZX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_UAHCX_GRXTHRCFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GRXTHRCFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C10Cull);
@@ -740,6 +779,7 @@ static inline uint64_t CVMX_UAHCX_GRXTHRCFG(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GSBUSCFG0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GSBUSCFG0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C100ull);
@@ -751,6 +791,7 @@ static inline uint64_t CVMX_UAHCX_GSBUSCFG0(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GSBUSCFG1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GSBUSCFG1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C104ull);
@@ -762,6 +803,7 @@ static inline uint64_t CVMX_UAHCX_GSBUSCFG1(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GSTS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C118ull);
@@ -773,6 +815,7 @@ static inline uint64_t CVMX_UAHCX_GSTS(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GTXFIFOPRIHST(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GTXFIFOPRIHST(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C618ull);
@@ -784,6 +827,7 @@ static inline uint64_t CVMX_UAHCX_GTXFIFOPRIHST(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GTXFIFOSIZX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 2)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 2)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_GTXFIFOSIZX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C300ull) + (((offset) & 3) + ((block_id) & 0) * 0x0ull) * 4;
@@ -795,6 +839,7 @@ static inline uint64_t CVMX_UAHCX_GTXFIFOSIZX(unsigned long offset, unsigned lon
 static inline uint64_t CVMX_UAHCX_GTXTHRCFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GTXTHRCFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C108ull);
@@ -806,6 +851,7 @@ static inline uint64_t CVMX_UAHCX_GTXTHRCFG(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GUCTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GUCTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C12Cull);
@@ -817,6 +863,7 @@ static inline uint64_t CVMX_UAHCX_GUCTL(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GUCTL1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GUCTL1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C11Cull);
@@ -828,6 +875,7 @@ static inline uint64_t CVMX_UAHCX_GUCTL1(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GUID(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_GUID(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000C128ull);
@@ -839,6 +887,7 @@ static inline uint64_t CVMX_UAHCX_GUID(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_GUSB2I2CCTLX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_GUSB2I2CCTLX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C240ull);
@@ -850,6 +899,7 @@ static inline uint64_t CVMX_UAHCX_GUSB2I2CCTLX(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_UAHCX_GUSB2PHYCFGX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_GUSB2PHYCFGX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C200ull);
@@ -861,6 +911,7 @@ static inline uint64_t CVMX_UAHCX_GUSB2PHYCFGX(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_UAHCX_GUSB3PIPECTLX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_GUSB3PIPECTLX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000C2C0ull);
@@ -872,6 +923,7 @@ static inline uint64_t CVMX_UAHCX_GUSB3PIPECTLX(unsigned long offset, unsigned l
 static inline uint64_t CVMX_UAHCX_HCCPARAMS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_HCCPARAMS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000010ull);
@@ -883,6 +935,7 @@ static inline uint64_t CVMX_UAHCX_HCCPARAMS(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_HCSPARAMS1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_HCSPARAMS1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000004ull);
@@ -894,6 +947,7 @@ static inline uint64_t CVMX_UAHCX_HCSPARAMS1(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_HCSPARAMS2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_HCSPARAMS2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000008ull);
@@ -905,6 +959,7 @@ static inline uint64_t CVMX_UAHCX_HCSPARAMS2(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_HCSPARAMS3(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_HCSPARAMS3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000000Cull);
@@ -916,6 +971,7 @@ static inline uint64_t CVMX_UAHCX_HCSPARAMS3(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_IMANX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_IMANX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000460ull);
@@ -927,6 +983,7 @@ static inline uint64_t CVMX_UAHCX_IMANX(unsigned long offset, unsigned long bloc
 static inline uint64_t CVMX_UAHCX_IMODX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_IMODX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000464ull);
@@ -938,6 +995,7 @@ static inline uint64_t CVMX_UAHCX_IMODX(unsigned long offset, unsigned long bloc
 static inline uint64_t CVMX_UAHCX_MFINDEX(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_MFINDEX(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000440ull);
@@ -1309,6 +1367,7 @@ static inline uint64_t CVMX_UAHCX_OHCI0_INSNREG07(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_PAGESIZE(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_PAGESIZE(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000028ull);
@@ -1320,6 +1379,7 @@ static inline uint64_t CVMX_UAHCX_PAGESIZE(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_PORTHLPMC_20X(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_PORTHLPMC_20X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000042Cull);
@@ -1331,6 +1391,7 @@ static inline uint64_t CVMX_UAHCX_PORTHLPMC_20X(unsigned long offset, unsigned l
 static inline uint64_t CVMX_UAHCX_PORTHLPMC_SSX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_PORTHLPMC_SSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x000168000000043Cull);
@@ -1342,6 +1403,7 @@ static inline uint64_t CVMX_UAHCX_PORTHLPMC_SSX(unsigned long offset, unsigned l
 static inline uint64_t CVMX_UAHCX_PORTLI_20X(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_PORTLI_20X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000428ull);
@@ -1353,6 +1415,7 @@ static inline uint64_t CVMX_UAHCX_PORTLI_20X(unsigned long offset, unsigned long
 static inline uint64_t CVMX_UAHCX_PORTLI_SSX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_PORTLI_SSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000438ull);
@@ -1364,6 +1427,7 @@ static inline uint64_t CVMX_UAHCX_PORTLI_SSX(unsigned long offset, unsigned long
 static inline uint64_t CVMX_UAHCX_PORTPMSC_20X(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_PORTPMSC_20X(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000424ull);
@@ -1375,6 +1439,7 @@ static inline uint64_t CVMX_UAHCX_PORTPMSC_20X(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_UAHCX_PORTPMSC_SSX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_PORTPMSC_SSX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000434ull);
@@ -1386,6 +1451,7 @@ static inline uint64_t CVMX_UAHCX_PORTPMSC_SSX(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_UAHCX_PORTSCX(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset <= 1)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UAHCX_PORTSCX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001680000000420ull) + (((offset) & 1) + ((block_id) & 0) * 0x0ull) * 16;
@@ -1397,6 +1463,7 @@ static inline uint64_t CVMX_UAHCX_PORTSCX(unsigned long offset, unsigned long bl
 static inline uint64_t CVMX_UAHCX_RTSOFF(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_RTSOFF(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000018ull);
@@ -1408,6 +1475,7 @@ static inline uint64_t CVMX_UAHCX_RTSOFF(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_SUPTPRT2_DW0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000890ull);
@@ -1419,6 +1487,7 @@ static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW0(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_SUPTPRT2_DW1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000894ull);
@@ -1430,6 +1499,7 @@ static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW1(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_SUPTPRT2_DW2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000898ull);
@@ -1441,6 +1511,7 @@ static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW2(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW3(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_SUPTPRT2_DW3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x000168000000089Cull);
@@ -1452,6 +1523,7 @@ static inline uint64_t CVMX_UAHCX_SUPTPRT2_DW3(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_SUPTPRT3_DW0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016800000008A0ull);
@@ -1463,6 +1535,7 @@ static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW0(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_SUPTPRT3_DW1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016800000008A4ull);
@@ -1474,6 +1547,7 @@ static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW1(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW2(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_SUPTPRT3_DW2(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016800000008A8ull);
@@ -1485,6 +1559,7 @@ static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW2(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW3(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_SUPTPRT3_DW3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00016800000008ACull);
@@ -1496,6 +1571,7 @@ static inline uint64_t CVMX_UAHCX_SUPTPRT3_DW3(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_USBCMD(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_USBCMD(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000020ull);
@@ -1507,6 +1583,7 @@ static inline uint64_t CVMX_UAHCX_USBCMD(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_USBLEGCTLSTS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_USBLEGCTLSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000884ull);
@@ -1518,6 +1595,7 @@ static inline uint64_t CVMX_UAHCX_USBLEGCTLSTS(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_USBLEGSUP(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_USBLEGSUP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000880ull);
@@ -1529,6 +1607,7 @@ static inline uint64_t CVMX_UAHCX_USBLEGSUP(unsigned long offset)
 static inline uint64_t CVMX_UAHCX_USBSTS(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UAHCX_USBSTS(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001680000000024ull);
@@ -1630,8 +1709,6 @@ typedef union cvmx_uahcx_crcr cvmx_uahcx_crcr_t;
  * or UCTL()_CTL[UAHC_RST],
  * or UAHC()_GCTL[CORESOFTRESET],
  * or UAHC()_USBCMD[HCRST], or UAHC()_USBCMD[LHCRST].
- *
- * INTERNAL: xHCI spec, page 32: there are UAHC()_HCSPARAMS1[MAXSLOTS]+1 doorbell registers.
  */
 union cvmx_uahcx_dbx {
 	uint32_t u32;
@@ -2790,8 +2867,6 @@ typedef union cvmx_uahcx_erstszx cvmx_uahcx_erstszx_t;
  * regardless of which AXI transaction received the error.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.12.
  */
 union cvmx_uahcx_gbuserraddr {
 	uint64_t u64;
@@ -2813,7 +2888,6 @@ typedef union cvmx_uahcx_gbuserraddr cvmx_uahcx_gbuserraddr_t;
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.5.
  */
 union cvmx_uahcx_gctl {
 	uint32_t u32;
@@ -2858,10 +2932,7 @@ union cvmx_uahcx_gctl {
                                                          When you reset PHYs (using UAHC()_GUSB2PHYCFG() or UAHC()_GUSB3PIPECTL()), you must keep
                                                          the
                                                          core in reset state until PHY clocks are stable. This controls the bus, RAM, and MAC
-                                                         domain resets.
-                                                         INTERNAL: Refer to Reset Generation on Synopsys Databook page 250.
-                                                         Under soft reset, accesses to UAHC()_* CSRs other than UAHC()_GCTL may fail (timeout).
-                                                         This bit is for debug purposes only. Use UAHC()_USBCMD[HCRST] for soft reset. */
+                                                         domain resets. */
 	uint32_t sofitpsync                   : 1;  /**< Synchronize ITP to reference clock. In host mode, if this bit is set to:
                                                          0 = The core keeps the UTMI/ULPI PHY on the first port in non-suspended state whenever
                                                          there is a SuperSpeed port that is not in Rx.Detect, SS.Disable, and U3 state.
@@ -2900,18 +2971,14 @@ union cvmx_uahcx_gctl {
                                                          * Speed enumeration
                                                          * HNP/SRP
                                                          * Suspend and resume
-                                                         0x2 = N/A
+                                                         0x2 = N/A.
                                                          0x3 = Enables bits <0> and <1> scale-down timing values.
                                                          SuperSpeed mode:
                                                          0x0 = Disables all scale-downs. Actual timing values are used.
                                                          0x1 = Enables scaled down SuperSpeed timing and repeat values including:
                                                          * Number of TxEq training sequences reduce to eight
                                                          * LFPS polling burst time reduce to 100 ns
-                                                         * LFPS warm reset receive reduce to 30 us.
-                                                         INTERNAL: Refer to the rtl_vip_scaledown_mapping.xls file under <workspace>/sim/SoC_sim
-                                                         directory for the complete list.
-                                                         0x2 = No TxEq training sequences are sent. Overrides bit<4>.
-                                                         0x3 = Enables bits<0> and <1> scale-down timing values. */
+                                                         * LFPS warm reset receive reduce to 30 us. */
 	uint32_t disscramble                  : 1;  /**< Disable scrambling. Transmit request to link partner on next transition to recovery or polling. */
 	uint32_t u2exit_lfps                  : 1;  /**< LFPS U2 exit.
                                                          0 = The link treats 248ns LFPS as a valid U2 exit.
@@ -2954,8 +3021,6 @@ typedef union cvmx_uahcx_gctl cvmx_uahcx_gctl_t;
  * See description in UAHC()_GDBGFIFOSPACE.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.5.
  */
 union cvmx_uahcx_gdbgbmu {
 	uint32_t u32;
@@ -3006,9 +3071,6 @@ typedef union cvmx_uahcx_gdbgepinfo cvmx_uahcx_gdbgepinfo_t;
  * is needed for the silicon, contact customer support with a dump of these registers.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.2.
- * INTERNAL: Contact Synopsys directly.
  */
 union cvmx_uahcx_gdbgfifospace {
 	uint32_t u32;
@@ -3046,8 +3108,6 @@ typedef union cvmx_uahcx_gdbgfifospace cvmx_uahcx_gdbgfifospace_t;
  * See description in UAHC()_GDBGFIFOSPACE.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.4.
  */
 union cvmx_uahcx_gdbglnmcc {
 	uint32_t u32;
@@ -3094,9 +3154,6 @@ typedef union cvmx_uahcx_gdbglsp cvmx_uahcx_gdbglsp_t;
  * See description in UAHC()_GDBGFIFOSPACE.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.6.
- * INTERNAL: This register is for Synopsys internal use only.
  */
 union cvmx_uahcx_gdbglspmux {
 	uint32_t u32;
@@ -3109,8 +3166,7 @@ union cvmx_uahcx_gdbglspmux {
                                                          using a mux) this signal with other trace signals in your system to generate a common
                                                          trace signal, you can use this feature. */
 	uint32_t endbc                        : 1;  /**< Enable debugging of the debug capability LSP. Use HOSTSELECT to select the DbC LSP debug
-                                                         information presented in the GDBGLSP register.
-                                                         INTERNAL: Note this can only be used if DebugCapabaility was enabled at compile. */
+                                                         information presented in the GDBGLSP register. */
 	uint32_t reserved_14_14               : 1;
 	uint32_t hostselect                   : 14; /**< Host select. Selects the LSP debug information presented in UAHC()_GDBGLSP. */
 #else
@@ -3134,8 +3190,6 @@ typedef union cvmx_uahcx_gdbglspmux cvmx_uahcx_gdbglspmux_t;
  * See description in UAHC()_GDBGFIFOSPACE.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.3.
  */
 union cvmx_uahcx_gdbgltssm {
 	uint32_t u32;
@@ -3151,7 +3205,7 @@ union cvmx_uahcx_gdbgltssm {
                                                          _ <15> RX polarity.
                                                          _ <14> TX Detect RX/loopback.
                                                          _ <13:11> LTSSM PHY command state.
-                                                         _ 0x0 = PHY_IDLE (PHY command state is in IDLE. No PHY request is pending.)
+                                                         _ 0x0 = PHY_IDLE (PHY command state is in IDLE. No PHY request is pending).
                                                          _ 0x1 = PHY_DET (Request to start receiver detection).
                                                          _ 0x2 = PHY_DET_3 (Wait for Phy_Status (receiver detection)).
                                                          _ 0x3 = PHY_PWR_DLY (delay Pipe3_PowerDown P0 -> P1/P2/P3 request).
@@ -3206,8 +3260,6 @@ typedef union cvmx_uahcx_gdbgltssm cvmx_uahcx_gdbgltssm_t;
  * is always awarded; there is no idle.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.5.
  */
 union cvmx_uahcx_gdmahlratio {
 	uint32_t u32;
@@ -3240,8 +3292,6 @@ typedef union cvmx_uahcx_gdmahlratio cvmx_uahcx_gdmahlratio_t;
  * REF_CLK signal.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.6.
  */
 union cvmx_uahcx_gfladj {
 	uint32_t u32;
@@ -3280,9 +3330,7 @@ union cvmx_uahcx_gfladj {
                                                          GFLADJ_REFCLK_LPM_SEL = 1, UAHC()_GCTL[SOFITPSYNC] must not be set to 1.
                                                          When GFLADJ_REFCLK_LPM_SEL = 1 the overloading of the suspend control of the USB 2.0 first
                                                          port PHY (UTMI) with USB 3.0 port states is removed. Note that the REF_CLK frequencies
-                                                         supported in this mode are 16/17/19.2/20/24/39.7/40 MHz.
-                                                         INTERNAL: The utmi_clk[0] signal of the core must be connected to the FREECLK of the PHY.
-                                                         If you set this bit to 1, UAHC()_GUSB2PHYCFG()[U2_FREECLK_EXISTS] must be set to 0. */
+                                                         supported in this mode are 16/17/19.2/20/24/39.7/40 MHz. */
 	uint32_t reserved_22_22               : 1;
 	uint32_t gfladj_refclk_fladj          : 14; /**< This field indicates the frame length adjustment to be applied when SOF/ITP counter is
                                                          running off of the REF_CLK. This register value is used to adjust:.
@@ -3340,8 +3388,6 @@ typedef union cvmx_uahcx_gfladj cvmx_uahcx_gfladj_t;
  * debugging.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.9.
  */
 union cvmx_uahcx_ggpio {
 	uint32_t u32;
@@ -3363,8 +3409,7 @@ typedef union cvmx_uahcx_ggpio cvmx_uahcx_ggpio_t;
  * cvmx_uahc#_ghwparams0
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.1.
+ *
  */
 union cvmx_uahcx_ghwparams0 {
 	uint32_t u32;
@@ -3394,8 +3439,7 @@ typedef union cvmx_uahcx_ghwparams0 cvmx_uahcx_ghwparams0_t;
  * cvmx_uahc#_ghwparams1
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.2.
+ *
  */
 union cvmx_uahcx_ghwparams1 {
 	uint32_t u32;
@@ -3404,8 +3448,7 @@ union cvmx_uahcx_ghwparams1 {
 	uint32_t en_dbc                       : 1;  /**< Enable debug capability. */
 	uint32_t rm_opt_features              : 1;  /**< Remove optional features. */
 	uint32_t sync_rst                     : 1;  /**< Synchronous reset coding. */
-	uint32_t ram_bus_clks_sync            : 1;  /**< RAM_CLK and BUS_CLK are synchronous. INTERNAL: (appears to be orthogonal from the
-                                                         RAM_CLK_TO_BUS_CLK parameter) */
+	uint32_t ram_bus_clks_sync            : 1;  /**< RAM_CLK and BUS_CLK are synchronous. */
 	uint32_t mac_ram_clks_sync            : 1;  /**< MAC3_CLK and RAM_CLK are synchronous. */
 	uint32_t mac_phy_clks_sync            : 1;  /**< MAC3_CLK and PHY_CLK are synchronous. */
 	uint32_t en_pwropt                    : 2;  /**< Power optimization mode:
@@ -3446,8 +3489,7 @@ typedef union cvmx_uahcx_ghwparams1 cvmx_uahcx_ghwparams1_t;
  * cvmx_uahc#_ghwparams2
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.3.
+ *
  */
 union cvmx_uahcx_ghwparams2 {
 	uint32_t u32;
@@ -3468,7 +3510,6 @@ typedef union cvmx_uahcx_ghwparams2 cvmx_uahcx_ghwparams2_t;
  *
  * This register contains the hardware configuration options selected at compile-time.
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.4.
  */
 union cvmx_uahcx_ghwparams3 {
 	uint32_t u32;
@@ -3508,8 +3549,7 @@ typedef union cvmx_uahcx_ghwparams3 cvmx_uahcx_ghwparams3_t;
  * cvmx_uahc#_ghwparams4
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.5.
+ *
  */
 union cvmx_uahcx_ghwparams4 {
 	uint32_t u32;
@@ -3545,8 +3585,7 @@ typedef union cvmx_uahcx_ghwparams4 cvmx_uahcx_ghwparams4_t;
  * cvmx_uahc#_ghwparams5
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.6.
+ *
  */
 union cvmx_uahcx_ghwparams5 {
 	uint32_t u32;
@@ -3576,8 +3615,7 @@ typedef union cvmx_uahcx_ghwparams5 cvmx_uahcx_ghwparams5_t;
  * cvmx_uahc#_ghwparams6
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.7.
+ *
  */
 union cvmx_uahcx_ghwparams6 {
 	uint32_t u32;
@@ -3617,8 +3655,7 @@ typedef union cvmx_uahcx_ghwparams6 cvmx_uahcx_ghwparams6_t;
  * cvmx_uahc#_ghwparams7
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.8.
+ *
  */
 union cvmx_uahcx_ghwparams7 {
 	uint32_t u32;
@@ -3640,8 +3677,7 @@ typedef union cvmx_uahcx_ghwparams7 cvmx_uahcx_ghwparams7_t;
  * cvmx_uahc#_ghwparams8
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.3.9.
+ *
  */
 union cvmx_uahcx_ghwparams8 {
 	uint32_t u32;
@@ -3667,9 +3703,6 @@ typedef union cvmx_uahcx_ghwparams8 cvmx_uahcx_ghwparams8_t;
  * assistance is needed for the silicon, contact Customer Support with a dump of these registers.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.1.
- * INTERNAL: Contact Synopsys directly.
  */
 union cvmx_uahcx_gpmsts {
 	uint32_t u32;
@@ -3718,8 +3751,6 @@ typedef union cvmx_uahcx_gpmsts cvmx_uahcx_gpmsts_t;
  * register should always be 0.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.2.1.
  */
 union cvmx_uahcx_gprtbimap {
 	uint64_t u64;
@@ -3747,8 +3778,6 @@ typedef union cvmx_uahcx_gprtbimap cvmx_uahcx_gprtbimap_t;
  * low-speed bus-instance, so this register should always be 0x0.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.2.3.
  */
 union cvmx_uahcx_gprtbimap_fs {
 	uint64_t u64;
@@ -3776,8 +3805,6 @@ typedef union cvmx_uahcx_gprtbimap_fs cvmx_uahcx_gprtbimap_fs_t;
  * register should always be 0.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.2.2.
  */
 union cvmx_uahcx_gprtbimap_hs {
 	uint64_t u64;
@@ -3799,18 +3826,13 @@ typedef union cvmx_uahcx_gprtbimap_hs cvmx_uahcx_gprtbimap_hs_t;
  * cvmx_uahc#_grlsid
  *
  * This is a read-only register that contains the release number of the core.
- * INTERNAL: Original name: GSNPSID = Synopsys ID.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.8.
+ *
  */
 union cvmx_uahcx_grlsid {
 	uint32_t u32;
 	struct cvmx_uahcx_grlsid_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t releaseid                    : 32; /**< Software can use this register to configure release-specific features in the driver.
-                                                         INTERNAL: Synopsys ID
-                                                          * SynopsysID[31:16] indicates Core Identification Number. 0x5533 is ASCII for
-                                                         U3 (DWC_usb3).
-                                                          * SynopsysID[15:0] indicates the release number. Current Release is 2.50a. */
+	uint32_t releaseid                    : 32; /**< Software can use this register to configure release-specific features in the driver. */
 #else
 	uint32_t releaseid                    : 32;
 #endif
@@ -3845,8 +3867,6 @@ typedef union cvmx_uahcx_grlsid cvmx_uahcx_grlsid_t;
  * SuperSpeed, 1 high-speed, and 1 full-speed/low-speed).
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.3.
  */
 union cvmx_uahcx_grxfifoprihst {
 	uint32_t u32;
@@ -3874,10 +3894,6 @@ typedef union cvmx_uahcx_grxfifoprihst cvmx_uahcx_grxfifoprihst_t;
  * Reset values = 0:[0x0000_0084] 1:[0x0084_0104] 2:[0x0188_0180].
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.6.2.
- * INTERNAL: For more information, see the BMU section in Block Descriptions on Synopsys Databook
- * page 238.
  */
 union cvmx_uahcx_grxfifosizx {
 	uint32_t u32;
@@ -3886,10 +3902,7 @@ union cvmx_uahcx_grxfifosizx {
 	uint32_t rxfstaddr                    : 16; /**< RxFIFOn RAM start address. This field contains the memory start address for RxFIFOn. The
                                                          reset value is derived from configuration parameters. */
 	uint32_t rxfdep                       : 16; /**< RxFIFOn depth. This value is in terms of RX RAM Data width.
-                                                         minimum value = 0x20, maximum value = 0x4000.
-                                                         INTERNAL: For more information, see the Hardware Integration chapter of the Synopsys
-                                                         Databook.
-                                                         The reset value is derived from configuration parameters. */
+                                                         minimum value = 0x20, maximum value = 0x4000. */
 #else
 	uint32_t rxfdep                       : 16;
 	uint32_t rxfstaddr                    : 16;
@@ -3922,8 +3935,6 @@ typedef union cvmx_uahcx_grxfifosizx cvmx_uahcx_grxfifosizx_t;
  * A larger RX threshold affects the performance since the scheduler is idle during this time.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.4.
  */
 union cvmx_uahcx_grxthrcfg {
 	uint32_t u32;
@@ -3974,10 +3985,6 @@ typedef union cvmx_uahcx_grxthrcfg cvmx_uahcx_grxthrcfg_t;
  * priority over other burst lengths. The core always performs the largest burst when enabled.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: The AXI cache signals are not connected in Cavium's hookup, so the *REQINFO fields
- * can be ignored.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.1.
  */
 union cvmx_uahcx_gsbuscfg0 {
 	uint32_t u32;
@@ -4040,8 +4047,6 @@ typedef union cvmx_uahcx_gsbuscfg0 cvmx_uahcx_gsbuscfg0_t;
  * before starting any transactions on AXI.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.2.
  */
 union cvmx_uahcx_gsbuscfg1 {
 	uint32_t u32;
@@ -4081,7 +4086,6 @@ typedef union cvmx_uahcx_gsbuscfg1 cvmx_uahcx_gsbuscfg1_t;
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.6.
  */
 union cvmx_uahcx_gsts {
 	uint32_t u32;
@@ -4098,8 +4102,7 @@ union cvmx_uahcx_gsts {
 	uint32_t buserraddrvld                : 1;  /**< Bus-error address valid. Indicates that UAHC()_GBUSERRADDR is valid and reports the
                                                          first bus address that encounters a bus error. */
 	uint32_t reserved_2_3                 : 2;
-	uint32_t curmod                       : 2;  /**< Current mode of operation. Always 0x1. INTERNAL: May vary from 0x1 if you write
-                                                         UAHC()_GCTL[PRTCAPDIR]!=0x1. */
+	uint32_t curmod                       : 2;  /**< Current mode of operation. Always 0x1. */
 #else
 	uint32_t curmod                       : 2;
 	uint32_t reserved_2_3                 : 2;
@@ -4142,8 +4145,6 @@ typedef union cvmx_uahcx_gsts cvmx_uahcx_gsts_t;
  * SuperSpeed, 1 high-speed, and 1 full-speed/low-speed).
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.2.
  */
 union cvmx_uahcx_gtxfifoprihst {
 	uint32_t u32;
@@ -4173,10 +4174,6 @@ typedef union cvmx_uahcx_gtxfifoprihst cvmx_uahcx_gtxfifoprihst_t;
  * Reset values = 0:[0x0000_0082] 1:[0x0082_0103] 2:[0x0185_0205].
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.6.1.
- * INTERNAL: For more information, refer to the BMU section in Block Descriptions on Synopsys
- * Databook page 238.
  */
 union cvmx_uahcx_gtxfifosizx {
 	uint32_t u32;
@@ -4185,10 +4182,7 @@ union cvmx_uahcx_gtxfifosizx {
 	uint32_t txfstaddr                    : 16; /**< Transmit FIFOn RAM start address. Contains the memory start address for TxFIFOn. The reset
                                                          is value derived from configuration parameters. */
 	uint32_t txfdep                       : 16; /**< TxFIFOn depth. This value is in terms of TX RAM data width.
-                                                         minimum value = 0x20, maximum value = 0x8000.
-                                                         INTERNAL: For more information, see the Hardware Integration chapter of the Synopsys
-                                                         Databook.
-                                                         The reset value derived from configuration parameters. */
+                                                         minimum value = 0x20, maximum value = 0x8000. */
 #else
 	uint32_t txfdep                       : 16;
 	uint32_t txfstaddr                    : 16;
@@ -4218,8 +4212,6 @@ typedef union cvmx_uahcx_gtxfifosizx cvmx_uahcx_gtxfifosizx_t;
  * * A larger threshold affects the performance, since the scheduler is idle during this time.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.3.
  */
 union cvmx_uahcx_gtxthrcfg {
 	uint32_t u32;
@@ -4267,8 +4259,6 @@ typedef union cvmx_uahcx_gtxthrcfg cvmx_uahcx_gtxthrcfg_t;
  * mode. Most of the options are used to improve host inter-operability with different devices.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.11.
  */
 union cvmx_uahcx_guctl {
 	uint32_t u32;
@@ -4391,7 +4381,6 @@ typedef union cvmx_uahcx_guctl cvmx_uahcx_guctl_t;
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.7.
  */
 union cvmx_uahcx_guctl1 {
 	uint32_t u32;
@@ -4424,8 +4413,6 @@ typedef union cvmx_uahcx_guctl1 cvmx_uahcx_guctl1_t;
  * * As a scratch register.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.10.
  */
 union cvmx_uahcx_guid {
 	uint32_t u32;
@@ -4447,8 +4434,6 @@ typedef union cvmx_uahcx_guid cvmx_uahcx_guid_t;
  * This register is reserved for future use.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.5.2.
  */
 union cvmx_uahcx_gusb2i2cctlx {
 	uint32_t u32;
@@ -4473,9 +4458,6 @@ typedef union cvmx_uahcx_gusb2i2cctlx cvmx_uahcx_gusb2i2cctlx_t;
  * implemented.
  *
  * Do not make changes to this register after the initial programming.
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.5.1.
- * Reset by: IOI reset or UCTL()_CTL[UAHC_RST].
  */
 union cvmx_uahcx_gusb2phycfgx {
 	uint32_t u32;
@@ -4575,9 +4557,6 @@ typedef union cvmx_uahcx_gusb2phycfgx cvmx_uahcx_gusb2phycfgx_t;
  * implemented.
  *
  * Do not make changes to this register after the initial programming.
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.5.4.
- * Reset by: IOI reset or UCTL()_CTL[UAHC_RST].
  */
 union cvmx_uahcx_gusb3pipectlx {
 	uint32_t u32;
@@ -4612,14 +4591,10 @@ union cvmx_uahcx_gusb3pipectlx {
                                                          0 = Core does U1/U2/U3 exit in PHY power state P0 (default behavior).
                                                          1 = Core does U1/U2/U3 exit in PHY power state P1/P2/P3 respectively.
                                                          This bit is added for SuperSpeed PHY workaround where SuperSpeed PHY injects a glitch on
-                                                         pipe3_RxElecIdle while receiving Ux exit LFPS, and pipe3_PowerDown change is in progress.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
-                                                         Synopsys PHY. */
+                                                         pipe3_RxElecIdle while receiving Ux exit LFPS, and pipe3_PowerDown change is in progress. */
 	uint32_t ping_enchance_en             : 1;  /**< Ping enhancement enable. When set to 1, the downstream-port U1-ping-receive timeout
                                                          becomes 500 ms instead of 300 ms. Minimum Ping.LFPS receive duration is 8 ns (one mac3_clk
-                                                         cycle). This field is valid for the downstream port only.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
-                                                         Synopsys PHY. */
+                                                         cycle). This field is valid for the downstream port only. */
 	uint32_t u1u2exitfail_to_recov        : 1;  /**< U1U2exit fail to recovery. When set to 1, and U1/U2 LFPS handshake fails, the LTSSM
                                                          transitions from U1/U2 to recovery instead of SS.inactive.
                                                          If recovery fails, then the LTSSM can enter SS.Inactive. This is an enhancement only. It
@@ -4628,33 +4603,26 @@ union cvmx_uahcx_gusb3pipectlx {
                                                          0 = if immediate Ux exit (remotely initiated, or locally initiated) happens, the core does
                                                          not request P1/P2/P3 power state change.
                                                          1 = the core always requests PHY power change from P0 to P1/P2/P3 during U0 to U1/U2/U3
-                                                         transition.
-                                                         INTERNAL: Note: This bit should be set to 1 for Synopsys PHY. For third-party SuperSpeed
-                                                         PHY, check with your PHY vendor. */
+                                                         transition. */
 	uint32_t startrxdetu3rxdet            : 1;  /**< Start receiver detection in U3/Rx.Detect.
                                                          If DISRXDETU3RXDET is set to 1 during reset, and the link is in U3 or Rx.Detect state, the
                                                          core starts receiver detection on rising edge of this bit.
                                                          This bit is valid for downstream ports only, and this feature must not be enabled for
-                                                         normal operation.
-                                                         INTERNAL: If have to use this feature, contact Synopsys. */
+                                                         normal operation. */
 	uint32_t disrxdetu3rxdet              : 1;  /**< Disable receiver detection in U3/Rx.Detect. When set to 1, the core does not do receiver
                                                          detection in U3 or Rx.Detect state. If STARTRXDETU3RXDET is set to 1 during reset,
                                                          receiver detection starts manually.
                                                          This bit is valid for downstream ports only, and this feature must not be enabled for
-                                                         normal operation.
-                                                         INTERNAL: If have to use this feature, contact Synopsys. */
+                                                         normal operation. */
 	uint32_t delaypx                      : 3;  /**< Delay P1P2P3. Delay P0 to P1/P2/P3 request when entering U1/U2/U3 until (DELAYPX * 8)
                                                          8B10B error occurs, or Pipe3_RxValid drops to 0.
-                                                         DELAYPXTRANSENTERUX must reset to 1 to enable this functionality.
-                                                         INTERNAL: Should always be 0x1 for a Synopsys PHY. */
+                                                         DELAYPXTRANSENTERUX must reset to 1 to enable this functionality. */
 	uint32_t delaypxtransenterux          : 1;  /**< Delay PHY power change from P0 to P1/P2/P3 when link state changing from U0 to U1/U2/U3
                                                          respectively.
                                                          0 = when entering U1/U2/U3, transition to P1/P2/P3 without checking for Pipe3_RxElecIlde
                                                          and pipe3_RxValid.
                                                          1 = when entering U1/U2/U3, delay the transition to P1/P2/P3 until the pipe3 signals,
-                                                         Pipe3_RxElecIlde is 1 and pipe3_RxValid is 0.
-                                                         INTERNAL: Note: This bit should be set to '1' for Synopsys PHY. It is also used by third-
-                                                         party SuperSpeed PHY. */
+                                                         Pipe3_RxElecIlde is 1 and pipe3_RxValid is 0. */
 	uint32_t suspend_en                   : 1;  /**< Suspend USB3.0 SuperSpeed PHY (Suspend_en). When set to 1, and if suspend conditions are
                                                          valid, the USB 3.0 PHY enters suspend mode. */
 	uint32_t datwidth                     : 2;  /**< PIPE data width.
@@ -4663,15 +4631,10 @@ union cvmx_uahcx_gusb3pipectlx {
                                                          0x2 = 8 bits.
                                                          0x3 = reserved.
                                                          One clock cycle after reset, these bits receive the value seen on the pipe3_DataBusWidth.
-                                                         This will always be 0x0.
-                                                         INTERNAL: The simulation testbench uses the coreConsultant parameter to configure the VIP.
-                                                         INTERNAL: These bits in the coreConsultant parameter should match your PHY data width and
-                                                         the pipe3_DataBusWidth port. */
+                                                         This will always be 0x0. */
 	uint32_t abortrxdetinu2               : 1;  /**< Abort RX Detect in U2. When set to 1, and the link state is U2, the core aborts receiver
                                                          detection if it receives U2 exit LFPS from the remote link partner.
-                                                         This bit is for downstream port only.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
-                                                         Synopsys PHY. */
+                                                         This bit is for downstream port only. */
 	uint32_t skiprxdet                    : 1;  /**< Skip RX detect. When set to 1, the core skips RX detection if pipe3_RxElecIdle is low.
                                                          Skip is defined as waiting for the appropriate timeout, then repeating the operation. */
 	uint32_t lfpsp0algn                   : 1;  /**< LFPS P0 align. When set to 1:
@@ -4685,14 +4648,9 @@ union cvmx_uahcx_gusb3pipectlx {
                                                          0 = P0 is always entered as an intermediate state during transitions between P2 and P3, as
                                                          defined in the PIPE3 specification.
                                                          1 = the core transitions directly from Phy power state P2 to P3 or from state P3 to P2.
-                                                         According to PIPE3 specification, any direct transition between P3 and P2 is illegal.
-                                                         INTERNAL: This bit is used only for some non-Synopsys PHYs that cannot do LFPS in P3.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
-                                                         Synopsys PHY. */
+                                                         According to PIPE3 specification, any direct transition between P3 and P2 is illegal. */
 	uint32_t p3exsigp2                    : 1;  /**< P3 exit signal in P2. When set to 1, the core always changes the PHY power state to P2,
-                                                         before attempting a U3 exit handshake.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
-                                                         Synopsys PHY. */
+                                                         before attempting a U3 exit handshake. */
 	uint32_t lfpsfilt                     : 1;  /**< LFPS filter. When set to 1, filter LFPS reception with pipe3_RxValid in PHY power state
                                                          P0, ignore LFPS reception from the PHY unless both pipe3_Rxelecidle and pipe3_RxValid are
                                                          deasserted. */
diff --git a/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h b/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
index 0542913..487c370 100644
--- a/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
@@ -65,8 +65,13 @@ static inline uint64_t CVMX_UCTLX_BIST_STATUS(unsigned long offset)
 				return CVMX_ADD_IO_SEG(0x000118006F0000A0ull);
 			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset == 0))
-				return CVMX_ADD_IO_SEG(0x0001180068000008ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				if ((offset == 0))
+					return CVMX_ADD_IO_SEG(0x0001180068000008ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				if ((offset == 0))
+					return CVMX_ADD_IO_SEG(0x0001180068000008ull);
+
 			break;
 	}
 	cvmx_warn("CVMX_UCTLX_BIST_STATUS (offset = %lu) not supported on this chip\n", offset);
@@ -83,7 +88,11 @@ static inline uint64_t CVMX_UCTLX_BIST_STATUS(unsigned long offset __attribute__
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x000118006F0000A0ull);
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x0001180068000008ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				return CVMX_ADD_IO_SEG(0x0001180068000008ull);
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+				return CVMX_ADD_IO_SEG(0x0001180068000008ull);
+
 	}
 	return CVMX_ADD_IO_SEG(0x000118006F0000A0ull);
 }
@@ -107,6 +116,7 @@ static inline uint64_t CVMX_UCTLX_CLK_RST_CTL(unsigned long offset)
 static inline uint64_t CVMX_UCTLX_CTL(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UCTLX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180068000000ull);
@@ -118,6 +128,7 @@ static inline uint64_t CVMX_UCTLX_CTL(unsigned long offset)
 static inline uint64_t CVMX_UCTLX_ECC(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UCTLX_ECC(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800680000F0ull);
@@ -174,6 +185,7 @@ static inline uint64_t CVMX_UCTLX_ERTO_CTL(unsigned long offset)
 static inline uint64_t CVMX_UCTLX_HOST_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UCTLX_HOST_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800680000E0ull);
@@ -200,6 +212,7 @@ static inline uint64_t CVMX_UCTLX_IF_ENA(unsigned long offset)
 static inline uint64_t CVMX_UCTLX_INTSTAT(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UCTLX_INTSTAT(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180068000030ull);
@@ -271,6 +284,7 @@ static inline uint64_t CVMX_UCTLX_ORTO_CTL(unsigned long offset)
 static inline uint64_t CVMX_UCTLX_PORTX_CFG_HS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UCTLX_PORTX_CFG_HS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180068000040ull);
@@ -282,6 +296,7 @@ static inline uint64_t CVMX_UCTLX_PORTX_CFG_HS(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_UCTLX_PORTX_CFG_SS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UCTLX_PORTX_CFG_SS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180068000048ull);
@@ -293,6 +308,7 @@ static inline uint64_t CVMX_UCTLX_PORTX_CFG_SS(unsigned long offset, unsigned lo
 static inline uint64_t CVMX_UCTLX_PORTX_CR_DBG_CFG(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UCTLX_PORTX_CR_DBG_CFG(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180068000050ull);
@@ -304,6 +320,7 @@ static inline uint64_t CVMX_UCTLX_PORTX_CR_DBG_CFG(unsigned long offset, unsigne
 static inline uint64_t CVMX_UCTLX_PORTX_CR_DBG_STATUS(unsigned long offset, unsigned long block_id)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && (((offset == 0)) && ((block_id == 0)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset == 0)) && ((block_id == 0))))))
 		cvmx_warn("CVMX_UCTLX_PORTX_CR_DBG_STATUS(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180068000058ull);
@@ -329,6 +346,7 @@ static inline uint64_t CVMX_UCTLX_PPAF_WM(unsigned long offset)
 static inline uint64_t CVMX_UCTLX_SHIM_CFG(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UCTLX_SHIM_CFG(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800680000E8ull);
@@ -340,6 +358,7 @@ static inline uint64_t CVMX_UCTLX_SHIM_CFG(unsigned long offset)
 static inline uint64_t CVMX_UCTLX_SPARE0(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UCTLX_SPARE0(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180068000010ull);
@@ -351,6 +370,7 @@ static inline uint64_t CVMX_UCTLX_SPARE0(unsigned long offset)
 static inline uint64_t CVMX_UCTLX_SPARE1(unsigned long offset)
 {
 	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) && ((offset == 0))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset == 0)))))
 		cvmx_warn("CVMX_UCTLX_SPARE1(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800680000F8ull);
@@ -662,10 +682,7 @@ union cvmx_uctlx_ctl {
                                                          0x2 = Reserved.
                                                          0x3 = Reserved.
                                                          This value can be changed only during UPHY_RST.
-                                                         If REF_CLK_SEL = 0x0, then the reference clock input cannot be spread-spectrum.
-                                                         INTERNAL: For the 0x1 selection, reference clock source for SuperSpeed PLL is from the USB
-                                                         pads, reference clock source for HighSpeed PLL is PLL_REF_CLK. But in 78xx, PLL_REF_CLK
-                                                         cannot be routed to USB without violating jitter requirements */
+                                                         If REF_CLK_SEL = 0x0, then the reference clock input cannot be spread-spectrum. */
 	uint64_t ssc_en                       : 1;  /**< Spread-spectrum clock enable. Enables spread-spectrum clock production in the SuperSpeed
                                                          function. If the input reference clock for the SuperSpeed PLL is already spread-spectrum,
                                                          then do not enable this feature. The clocks sourced to the SuperSpeed function must have
@@ -706,10 +723,7 @@ union cvmx_uctlx_ctl {
                                                          legal values are as follows:
                                                          0x27 = External reference clock 100 MHz.
                                                          All other values are reserved.
-                                                         This value may only be changed during UPHY_RST.
-                                                         INTERNAL: 0x2A = External reference clock 24 MHz.
-                                                         0x31 = External reference clock 20 MHz.
-                                                         0x38 = External reference clock 19.2 MHz. */
+                                                         This value may only be changed during UPHY_RST. */
 	uint64_t reserved_31_31               : 1;
 	uint64_t h_clk_en                     : 1;  /**< Controller-clock enable. When set to 1, the controller clock is generated. This also
                                                          enables access to UCTL registers 0x30-0xF8. */
@@ -720,8 +734,7 @@ union cvmx_uctlx_ctl {
                                                          You must still set H_CLK_EN separately. H_CLK_BYP_SEL select should not be changed
                                                          unless H_CLK_EN is disabled.
                                                          The bypass clock can be selected and running even if the controller-clock dividers are not
-                                                         running.
-                                                         INTERNAL: Generally bypass is only used for scan purposes. */
+                                                         running. */
 	uint64_t h_clkdiv_rst                 : 1;  /**< Controller-clock divider reset. Divided clocks are not generated while the divider is
                                                          being reset.
                                                          This also resets the suspend-clock divider. */
@@ -745,12 +758,7 @@ union cvmx_uctlx_ctl {
                                                          * The controller-clock frequency must be at or above 62.5 MHz for any USB2 operation.
                                                          * The controller-clock frequency must be at or above
                                                          90 MHz for full-rate USB2 operation.
-                                                         This field can be changed only when H_CLKDIV_RST = 1.
-                                                         INTERNAL: 150MHz is from the maximum of Synopsys DWC_usb3 Databook v2.50a, table A-16, row
-                                                         1, col 12. Synopsys DWC_usb3 Databook v2.50a, table A-17, row 7, col 9. Synopsys DWC_usb3
-                                                         Databook v2.50a, table A-16, row 7, col 9. HOST2>62.5MHz in HOST mode is from Synopsys
-                                                         DWC_usb3 Databook v2.50a, section A.12.5, 3rd bullet in Note on page 894. HOST2>90MHz was
-                                                         arrived at from some math: 62.5MHz + (diff between row 1 and 2, col 12 of table A-16). */
+                                                         This field can be changed only when H_CLKDIV_RST = 1. */
 	uint64_t reserved_22_23               : 2;
 	uint64_t usb3_port_perm_attach        : 1;  /**< Indicates this port is permanently attached. This is a strap signal; it should be modified
                                                          only when UPHY_RST is asserted. */
@@ -783,16 +791,12 @@ union cvmx_uctlx_ctl {
                                                          registers via the IOI, as well as UCTL registers starting from 0x30 via the RSL bus. */
 	uint64_t reserved_3_3                 : 1;
 	uint64_t uphy_rst                     : 1;  /**< PHY reset; resets UPHY; active-high. */
-	uint64_t uahc_rst                     : 1;  /**< Software reset; resets UAHC; active-high.
-                                                         INTERNAL: Note that soft-resetting the UAHC while it is active may cause violations of RSL
-                                                         or NCB protocols. */
+	uint64_t uahc_rst                     : 1;  /**< Software reset; resets UAHC; active-high. */
 	uint64_t uctl_rst                     : 1;  /**< Software reset; resets UCTL; active-high.
                                                          Resets UAHC DMA and register shims. Resets UCTL RSL registers 0x30-0xF8.
                                                          Does not reset UCTL RSL registers 0x0-0x28.
                                                          UCTL RSL registers starting from 0x30 can be accessed only after the controller clock is
-                                                         active and UCTL_RST is deasserted.
-                                                         INTERNAL: Note that soft-resetting the UCTL while it is active may cause violations of
-                                                         RSL, NCB, and CIB protocols. */
+                                                         active and UCTL_RST is deasserted. */
 #else
 	uint64_t uctl_rst                     : 1;
 	uint64_t uahc_rst                     : 1;
@@ -1411,8 +1415,6 @@ typedef union cvmx_uctlx_orto_ctl cvmx_uctlx_orto_ctl_t;
  * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
  *
  * This register can be reset by IOI reset or UCTL()_CTL[UCTL_RST].
- *
- * INTERNAL: All these settings are for high-speed functionality, connect on DVDD power domain.
  */
 union cvmx_uctlx_portx_cfg_hs {
 	uint64_t u64;
@@ -1458,8 +1460,8 @@ union cvmx_uctlx_portx_cfg_hs {
                                                          preemphasis duration is defined in terms of unit amounts. One unit of preemphasis duration
                                                          is approximately 580 ps and is defined as 1* preemphasis duration. This signal is valid
                                                          only if either TX_PREEMP_AMP_TUNE0[1] or TX_PREEMP_AMP_TUNE0[0] is set to 1.
-                                                         0 = 2*, long preemphasis current duration (design default)
-                                                         1 = 1*, short preemphasis current duration
+                                                         0 = 2*, long preemphasis current duration (design default).
+                                                         1 = 1*, short preemphasis current duration.
                                                          If this signal is not used, set it to 0. */
 	uint64_t tx_res_tune                  : 2;  /**< USB source-impedance adjustment. Some applications require additional devices to be added
                                                          on the USB, such as a series switch, which can add significant series resistance. This bus
@@ -1527,8 +1529,6 @@ typedef union cvmx_uctlx_portx_cfg_hs cvmx_uctlx_portx_cfg_hs_t;
  * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UCTL_RST].
- *
- * INTERNAL: All these settings are for high-speed functionality, connect on DVDD power domain.
  */
 union cvmx_uctlx_portx_cfg_ss {
 	uint64_t u64;
@@ -1601,8 +1601,7 @@ union cvmx_uctlx_portx_cfg_ss {
                                                          In general, the parameter controls are static signals to be set prior to taking the PHY
                                                          out of reset. However, you can dynamically change these values on-the-fly for test
                                                          purposes. In this case, changes to the transmitter to reflect the current value occur only
-                                                         after the pipeP_tx_deemph[1:0] input changes.
-                                                         INTERNAL: Default value is package dependant. */
+                                                         after the pipeP_tx_deemph[1:0] input changes. */
 	uint64_t pcs_tx_deemph_6db            : 6;  /**< Fine-tune transmitter driver deemphasis when set to 6db.
                                                          This static value sets the TX driver deemphasis value when pipeP_tx_deemph[1:0] is set to
                                                          0x2 (according to the PIPE3 specification). This bus is provided for completeness and as a
@@ -1612,16 +1611,14 @@ union cvmx_uctlx_portx_cfg_ss {
                                                          In general, the parameter controls are static signals to be set prior to taking the PHY
                                                          out of reset. However, you can dynamically change these values on-the-fly for test
                                                          purposes. In this case, changes to the transmitter to reflect the current value occur only
-                                                         after the pipeP_tx_deemph[1:0] input changes.
-                                                         INTERNAL: Default value is package dependant. */
+                                                         after the pipeP_tx_deemph[1:0] input changes. */
 	uint64_t pcs_tx_swing_full            : 7;  /**< Launch amplitude of the transmitter. Sets the launch amplitude of the transmitter. The
                                                          values for transmit amplitude are derived from the following equation:
                                                          TX amplitude (V) = vptx * ((pcs_tx_swing_full + 1)/128)
                                                          In general, the parameter controls are static signals to be set prior to taking the PHY
                                                          out of reset. However, you can dynamically change these values on-the-fly for test
                                                          purposes. In this case, changes to the transmitter to reflect the current value occur only
-                                                         after the pipeP_tx_deemph[1:0] input changes.
-                                                         INTERNAL: Default value is package dependant. */
+                                                         after the pipeP_tx_deemph[1:0] input changes. */
 	uint64_t lane0_tx_term_offset         : 5;  /**< Transmitter termination offset. Reserved, set to 0x0. */
 	uint64_t reserved_6_7                 : 2;
 	uint64_t res_tune_ack                 : 1;  /**< Resistor tune acknowledge. While asserted, indicates a resistor tune is in progress. */
@@ -1662,61 +1659,6 @@ typedef union cvmx_uctlx_portx_cfg_ss cvmx_uctlx_portx_cfg_ss_t;
  * This register is accessible only when UCTL()_CTL[H_CLK_EN] = 1.
  *
  * This register can be reset by IOI reset or with UCTL()_CTL[UCTL_RST].
- *
- * INTERNAL: (In body of HRM)
- * To access the PHY registers indirectly through the CR interface, the HCLK must be running,
- * UCTL_RST must be deasserted, and UPHY_RST must be deasserted. Software is responsible for
- * ensuring that only one indirect access is ongoing at a time.
- *
- * To read a PHY register via indirect CR interface:
- *   1. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [DATA_IN] with the <<address>> of the register,
- *     * [CAP_ADDR], [CAP_DATA], [READ], and [WRITE] fields 0x0.
- *   2. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [DATA_IN] with the <<address>> of the register,
- *     * [CAP_ADDR] field 0x1,
- *     * [CAP_DATA], [READ], and [WRITE] fields 0x0.
- *   3. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x1.
- *   4. Write UCTL_PORTn_CR_DBG_CFG with all 0x0's.
- *   5. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x0.
- *   6. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [READ] field 0x1,
- *     * [DATA_IN], [CAP_ADDR], [CAP_DATA], and [WRITE] fields 0x0.
- *   7. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x1.
- *   8. Read UCTL_PORTn_CR_DBG_STATUS[DATA_OUT]. This is the <<read data>>.
- *   9. Write UCTL_PORTn_CR_DBG_CFG with all 0x0's.
- *   10. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x0.
- *
- * To write a PHY register via indirect CR interface:
- *   1. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [DATA_IN] with the <<address>> of the register,
- *     * [CAP_ADDR], [CAP_DATA], [READ], and [WRITE] fields 0x0.
- *   2. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [DATA_IN] with the <<address>> of the register,
- *     * [CAP_ADDR] field 0x1,
- *     * [CAP_DATA], [READ], and [WRITE] fields 0x0.
- *   3. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x1.
- *   4. Write UCTL_PORTn_CR_DBG_CFG with all 0x0's.
- *   5. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x0.
- *   6. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [DATA_IN] with the <<write data>>,
- *     * [CAP_ADDR], [CAP_DATA], [READ], and [WRITE] fields 0x0.
- *   7. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [DATA_IN] with the write data,
- *     * [CAP_DATA] field 0x1,
- *     * [CAP_ADDR], [READ], and [WRITE] fields 0x0.
- *   8. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x1.
- *   9. Write UCTL_PORTn_CR_DBG_CFG with all 0x0's.
- *   10. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x0.
- *   11. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [WRITE] field 0x1,
- *     * [DATA_IN], [CAP_ADDR], and [READ] fields 0x0.
- *   12. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x1.
- *   13. Write UCTL_PORTn_CR_DBG_CFG with all 0x0's.
- *   14. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x0.
- *
- * For partial writes, a read-modify write is required. Note that the CAP_ADDR steps (1-5)
- * do not have to be repeated until the address needs changed.
  */
 union cvmx_uctlx_portx_cr_dbg_cfg {
 	uint64_t u64;
@@ -1827,7 +1769,7 @@ union cvmx_uctlx_shim_cfg {
                                                          <56:51> = Core/IOI-device number. Note that for IOI devices, <56> is always 0.
                                                          <50:48> = SubID. */
 	uint64_t xm_bad_dma_wrn               : 1;  /**< Read/write error log for bad DMA access from UAHC.
-                                                         0 = read error log, 1 = write error log */
+                                                         0 = read error log, 1 = write error log. */
 	uint64_t reserved_44_46               : 3;
 	uint64_t xm_bad_dma_type              : 4;  /**< ErrType error log for bad DMA access from UAHC. Encodes the type of error encountered
                                                          (error largest encoded value has priority). See UCTL_XM_BAD_DMA_TYPE_E. */
diff --git a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
index 542cfee..5fcbf28 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
@@ -1551,7 +1551,6 @@ typedef union cvmx_usbdrdx_uahc_crcr cvmx_usbdrdx_uahc_crcr_t;
  * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.1.
  */
 union cvmx_usbdrdx_uahc_dalepena {
 	uint32_t u32;
@@ -1562,19 +1561,17 @@ union cvmx_usbdrdx_uahc_dalepena {
                                                          with one bit for each of the 32 possible endpoints. Even numbers are for
                                                          USB OUT endpoints, and odd numbers are for USB IN endpoints, as
                                                          follows:
-                                                          Bit[0]: USB EP0-OUT
-                                                          Bit[1]: USB EP0-IN
-                                                          Bit[2]: USB EP1-OUT
-                                                          Bit[3]: USB EP1-IN
+                                                          <0> = USB EP0-OUT.
+                                                          <1> = USB EP0-IN.
+                                                          <2> = USB EP1-OUT.
+                                                          <3> = USB EP1-IN.
                                                          The entity programming this register must set bits 0 and 1 because they
                                                          enable control endpoints that map to physical endpoints (resources) after
                                                          USBReset.
                                                          Application software clears these bits for all endpoints (other than EP0-OUT
                                                          and EP0-IN) after detecting a USB reset. After receiving SetConfiguration
                                                          and SetInterface requests, the application must program endpoint registers
-                                                         accordingly and set these bits.
-                                                         INTERNAL: For more information, see 'Flexible Endpoint Mapping' on Synopsys DWC_usb3
-                                                         Databook v2.50a, page 82. */
+                                                         accordingly and set these bits. */
 #else
 	uint32_t usbactep                     : 32;
 #endif
@@ -1595,9 +1592,6 @@ typedef union cvmx_usbdrdx_uahc_dalepena cvmx_usbdrdx_uahc_dalepena_t;
  * or USBDRD()_UCTL_CTL[UAHC_RST],
  * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
  * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
- *
- * INTERNAL: xHCI spec, page 32: there are USBDRD()_UAHC_HCSPARAMS1[MAXSLOTS]+1 doorbell
- * registers.
  */
 union cvmx_usbdrdx_uahc_dbx {
 	uint32_t u32;
@@ -1678,7 +1672,6 @@ typedef union cvmx_usbdrdx_uahc_dcbaap cvmx_usbdrdx_uahc_dcbaap_t;
  * commands or enumeration. Do not make changes to this register after initial programming.
  *
  * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.1.
  */
 union cvmx_usbdrdx_uahc_dcfg {
 	uint32_t u32;
@@ -1691,46 +1684,45 @@ union cvmx_usbdrdx_uahc_dcfg {
                                                          with the NumP field set to 0 and PP set to 0 for IN endpoints, the core
                                                          attempts to search for another stream (CStream) to initiate to the host.
                                                          However, there are two situations where this behavior is not optimal:
-                                                          - When the host is setting PP=0 even though it has not finished the
+                                                         * When the host is setting PP=0 even though it has not finished the
                                                          stream, or
-                                                          - When the endpoint on the device is configured with one transfer
+                                                         * When the endpoint on the device is configured with one transfer
                                                          resource and therefore does not have any other streams to initiate to the
                                                          host.
                                                          When this bit is set to 0x1, the core ignores the Packet Pending bit for the
                                                          purposes of stream selection and does not search for another stream when
                                                          it receives DP(PP=0) or ACK(NumP=0, PP=0). This can enhance the
                                                          performance when the device system bus bandwidth is low */
-	uint32_t lpmcap                       : 1;  /**< LPM Capable.
+	uint32_t lpmcap                       : 1;  /**< LPM capable.
                                                          The application uses this bit to control the controller's core LPM
                                                          capabilities. If the core operates as a non-LPM-capable device, it cannot
                                                          respond to LPM transactions.
-                                                           0x0: LPM capability is not enabled.
-                                                           0x1: LPM capability is enabled. */
-	uint32_t nump                         : 5;  /**< Number of Receive Buffers.
+                                                           0x0 = LPM capability is not enabled.
+                                                           0x1 = LPM capability is enabled. */
+	uint32_t nump                         : 5;  /**< Number of receive buffers.
                                                          This bit indicates the number of receive buffers to be reported in the ACK
                                                          TP.
                                                          The DWC_usb3 controller uses this field if USBDRD()_UAHC_GRXTHRCFG[USBRXPKTCNTSEL]
                                                          is set to 0x0. The application can program this value based on RxFIFO size,
                                                          buffer sizes programmed in descriptors, and system latency.
                                                          For an OUT endpoint, this field controls the number of receive buffers
-                                                         reported in the NumP field of the ACK TP transmitted by the core.
-                                                         INTERNAL: Note: This bit is used in host mode when Debug Capability is enabled. */
+                                                         reported in the NumP field of the ACK TP transmitted by the core. */
 	uint32_t intrnum                      : 5;  /**< Interrupt number.
                                                          Indicates interrupt/EventQ number on which non-endpoint-specific device-related
                                                          interrupts (see DEVT) are generated. */
 	uint32_t reserved_10_11               : 2;
-	uint32_t devaddr                      : 7;  /**< Device Address.
-                                                         The application must perform the following
-                                                          - Program this field after every SetAddress request.
-                                                          - Reset this field to zero after USB reset. */
-	uint32_t devspd                       : 3;  /**< Device Speed.
+	uint32_t devaddr                      : 7;  /**< Device address.
+                                                         The application must perform the following:
+                                                          * Program this field after every SetAddress request.
+                                                          * Reset this field to zero after USB reset. */
+	uint32_t devspd                       : 3;  /**< Device speed.
                                                          Indicates the speed at which the application requires the core to connect, or
                                                          the maximum speed the application can support. However, the actual bus
                                                          speed is determined only after the chirp sequence is completed, and is
                                                          based on the speed of the USB host to which the core is connected.
-                                                           - 0x0: High-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz).
-                                                           - 0x1: Full-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz).
-                                                           - 0x4: SuperSpeed (USB 3.0 PHY clock is 125 MHz or 250 MHz). */
+                                                           0x0 = High-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz).
+                                                           0x1 = Full-speed (USB 2.0 PHY clock is 30 MHz or 60 MHz).
+                                                           0x4 = SuperSpeed (USB 3.0 PHY clock is 125 MHz or 250 MHz). */
 #else
 	uint32_t devspd                       : 3;
 	uint32_t devaddr                      : 7;
@@ -1755,7 +1747,6 @@ typedef union cvmx_usbdrdx_uahc_dcfg cvmx_usbdrdx_uahc_dcfg_t;
  * This register controls devlice mode.
  *
  * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.2.
  */
 union cvmx_usbdrdx_uahc_dctl {
 	uint32_t u32;
@@ -1778,20 +1769,15 @@ union cvmx_usbdrdx_uahc_dctl {
                                                             cleared is 30ms in SuperSpeed and 10ms in High/Full/LowSpeed.
                                                             If the software attempts a connect after the soft disconnect or detects a
                                                             disconnect event, it must set USBDRD()_UAHC_DCTL[ULSTCHNGREQ] to
-                                                            "Rx.Detect" before reasserting the Run/Stop bit.
-                                                            INTERNAL: 3. When the USB or Link is in a lower power state and the Two Power Rails
-                                                            configuration is selected, software writes 0 to this bit to indicate that it is going
-                                                            to turn off the Core Power Rail. After the software turns on the Core Power Rail
-                                                            again and re-initializes the device controller, it must set this bit to start the
-                                                            device controller. For more details, see Low Power Operation on page 599. */
+                                                            "Rx.Detect" before reasserting the Run/Stop bit. */
 	uint32_t csftrst                      : 1;  /**< Core Soft Reset.
                                                          Resets the all clock domains as follows:
-                                                         - Clears the interrupts and all the CSRs except the following registers:
+                                                         * Clears the interrupts and all the CSRs except the following registers:
                                                            GCTL, GUCTL, GSTS, GSNPSID, GGPIO, GUID, GUSB2PHYCFGn registers,
                                                            GUSB3PIPECTLn registers, DCFG, DCTL, DEVTEN, DSTS
-                                                         - All module state machines (except the SoC Bus Slave Unit) are reset to the
+                                                         * All module state machines (except the SoC Bus Slave Unit) are reset to the
                                                             IDLE state, and all the TxFIFOs and the RxFIFO are flushed.
-                                                         - Any transactions on the SoC bus Master are terminated as soon as possible,
+                                                         * Any transactions on the SoC bus Master are terminated as soon as possible,
                                                            after gracefully completing the last data phase of a SoC bus transfer. Any
                                                            transactions on the USB are terminated immediately.
                                                          The application can write this bit at any time to reset the core. This is a self-clearing
@@ -1822,26 +1808,24 @@ union cvmx_usbdrdx_uahc_dctl {
                                                           response).
                                                           LPMCAP is 0x1 and this bit is 0:
                                                           The core responds with an ACK upon a successful LPM transaction,
-                                                              which requires all of the following are satisfied
-                                                              - There are no PID/CRC5 errors in both the EXT token and the LPM token
+                                                              which requires all of the following are satisfied:
+                                                              * There are no PID/CRC5 errors in both the EXT token and the LPM token
                                                               (if not true, inactivity results in a timeout ERROR)
-                                                              - A valid bLinkState = 0001B (L1) is received in the LPM transaction (else
+                                                              * A valid bLinkState = 0001B (L1) is received in the LPM transaction (else
                                                               STALL)
-                                                              - No data is pending in the Transmit FIFO and OUT endpoints not in flow
+                                                              * No data is pending in the Transmit FIFO and OUT endpoints not in flow
                                                               controlled state (else NYET)
                                                           LPMCAP is 0x1 and this bit is 1:
                                                          The core responds with an ACK upon a successful LPM, independent
                                                              of transmit FIFO status and OUT endpoint flow control state. The LPM
-                                                             transaction is successful if all of the following are satisfied.
-                                                             - There are no PID/CRC5 errors in both the EXT token and the LPM token
+                                                             transaction is successful if all of the following are satisfied:
+                                                             * There are no PID/CRC5 errors in both the EXT token and the LPM token
                                                              (else ERROR)
-                                                             - A valid bLinkState = 0001B (L1) is received in the LPM transaction (else
+                                                             * A valid bLinkState = 0001B (L1) is received in the LPM transaction (else
                                                              STALL) */
 	uint32_t reserved_20_22               : 3;
-	uint32_t keepconnect                  : 1;  /**< Always write 0.
-                                                         INTERNAL: Writing this bit to 0x1 does nothing since we don't have hibernation feature. */
-	uint32_t l1hibernationen              : 1;  /**< Always write 0.
-                                                         INTERNAL: Writing this bit to 0x1 does nothing since we don't have hibernation feature. */
+	uint32_t keepconnect                  : 1;  /**< Always write 0. */
+	uint32_t l1hibernationen              : 1;  /**< Always write 0. */
 	uint32_t crs                          : 1;  /**< Controller Restore State.
                                                          This command is similar to the USBDRD()_UAHC_USBCMD[CRS] bit in host mode and
                                                          initiates the restore process. When software sets this bit to 1, the controller
@@ -1963,7 +1947,6 @@ typedef union cvmx_usbdrdx_uahc_dctl cvmx_usbdrdx_uahc_dctl_t;
  * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.5.
  */
 union cvmx_usbdrdx_uahc_depcmdx {
 	uint32_t u32;
@@ -2053,8 +2036,7 @@ union cvmx_usbdrdx_uahc_depcmdx {
                                                          transfer
                                                                resources to be assigned than have been configured in the hardware.
                                                          In response to a End Transfer command:
-                                                         _ [15:12] = 0x1: Indicates an invalid transfer resource was specified.
-                                                         INTERNAL: For abort handling, see also Synopsys DWC_usb3 Databook v2.50a, Section 8.4. */
+                                                         _ [15:12] = 0x1: Indicates an invalid transfer resource was specified. */
 	uint32_t hipri_forcerm                : 1;  /**< HighPriority: Only valid for Start Transfer command.
                                                          ForceRM: Only valid for End Transfer command. */
 	uint32_t cmdact                       : 1;  /**< Software sets this bit to 1 to enable the device endpoint controller to
@@ -2112,7 +2094,6 @@ typedef union cvmx_usbdrdx_uahc_depcmdx cvmx_usbdrdx_uahc_depcmdx_t;
  * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.4.
  */
 union cvmx_usbdrdx_uahc_depcmdpar0_x {
 	uint32_t u32;
@@ -2140,7 +2121,6 @@ typedef union cvmx_usbdrdx_uahc_depcmdpar0_x cvmx_usbdrdx_uahc_depcmdpar0_x_t;
  * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.3.
  */
 union cvmx_usbdrdx_uahc_depcmdpar1_x {
 	uint32_t u32;
@@ -2168,7 +2148,6 @@ typedef union cvmx_usbdrdx_uahc_depcmdpar1_x cvmx_usbdrdx_uahc_depcmdpar1_x_t;
  * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.2.2.
  */
 union cvmx_usbdrdx_uahc_depcmdpar2_x {
 	uint32_t u32;
@@ -2193,7 +2172,6 @@ typedef union cvmx_usbdrdx_uahc_depcmdpar2_x cvmx_usbdrdx_uahc_depcmdpar2_x_t;
  * If an enable bit is set to 0, the event will not be generated.
  *
  * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.2.
  */
 union cvmx_usbdrdx_uahc_devten {
 	uint32_t u32;
@@ -2207,8 +2185,7 @@ union cvmx_usbdrdx_uahc_devten {
 	uint32_t sofen                        : 1;  /**< Start of (micro)Frame Enable.
                                                          For debug purposes only; normally software must disable this event. */
 	uint32_t u3l2l1suspen                 : 1;  /**< U3/L2-L1 Suspend Event Enable. */
-	uint32_t hibernationreqevten          : 1;  /**< This bit enables/disables the generation of the Hibernation Request Event.
-                                                         INTERNAL: Writing this bit to 0x1 does nothing since we don't have hibernation feature. */
+	uint32_t hibernationreqevten          : 1;  /**< This bit enables/disables the generation of the Hibernation Request Event. */
 	uint32_t wkupevten                    : 1;  /**< Resume/Remote Wakeup Detected Event Enable. */
 	uint32_t ulstcngen                    : 1;  /**< USB/Link State Change Event Enable. */
 	uint32_t connectdoneen                : 1;  /**< Connection Done Enable. */
@@ -2249,7 +2226,6 @@ typedef union cvmx_usbdrdx_uahc_devten cvmx_usbdrdx_uahc_devten_t;
  * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.5.
  */
 union cvmx_usbdrdx_uahc_dgcmd {
 	uint32_t u32;
@@ -2257,9 +2233,9 @@ union cvmx_usbdrdx_uahc_dgcmd {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_16_31               : 16;
 	uint32_t cmdstatus                    : 1;  /**< Command Status.
-                                                         - 1: CmdErr - Indicates that the device controller encountered an error
-                                                             while processing the command.
-                                                         - 0: Indicates command success */
+                                                         0 = Indicates command success.
+                                                         1 = CmdErr - Indicates that the device controller encountered an error
+                                                            while processing the command. */
 	uint32_t reserved_11_14               : 4;
 	uint32_t cmdact                       : 1;  /**< Command Active.
                                                          The software sets this bit to 1 to enable the device controller to execute the
@@ -2300,8 +2276,6 @@ typedef union cvmx_usbdrdx_uahc_dgcmd cvmx_usbdrdx_uahc_dgcmd_t;
  * USBDRD()_UAHC_GCTL[CORESOFTRESET] or
  * USBDRD()_UAHC_USBCMD[HCRST] or USBDRD()_UAHC_USBCMD[LHCRST] or
  * USBDRD()_UAHC_DCTL[CSFTRST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.4.
  */
 union cvmx_usbdrdx_uahc_dgcmdpar {
 	uint32_t u32;
@@ -2356,7 +2330,6 @@ typedef union cvmx_usbdrdx_uahc_dnctrl cvmx_usbdrdx_uahc_dnctrl_t;
  * events.
  *
  * This register can be reset by IOI reset or USBDRD()_UCTL_CTL[UAHC_RST].
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.3.1.3.
  */
 union cvmx_usbdrdx_uahc_dsts {
 	uint32_t u32;
@@ -2364,8 +2337,7 @@ union cvmx_usbdrdx_uahc_dsts {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_30_31               : 2;
 	uint32_t dcnrd                        : 1;  /**< Device Controller Not Ready.
-                                                         Will always read-as-zero.
-                                                         INTERNAL: Bit is only used with hibernation. */
+                                                         Will always read-as-zero. */
 	uint32_t sre                          : 1;  /**< Save/Restore Error.
                                                          This bit is currently not supported. */
 	uint32_t reserved_26_27               : 2;
@@ -2373,14 +2345,12 @@ union cvmx_usbdrdx_uahc_dsts {
                                                          This bit is similar to the USBDRD()_USBSTS[RSS] in host mode.
                                                          When the controller has finished the restore process, it will complete the
                                                          command by setting RSS to 0.
-                                                         Will always read-as-zero.
-                                                         INTERNAL: Bit is only used with hibernation. */
+                                                         Will always read-as-zero. */
 	uint32_t sss                          : 1;  /**< Save State Status.
                                                          This bit is similar to the USBDRD()_UAHC_USBSTS[SSS] in host mode.
                                                          When the controller has finished the save process, it will complete the
                                                          command by setting SSS to 0.
-                                                         Will always read-as-zero.
-                                                         INTERNAL: Bit is only used with hibernation. */
+                                                         Will always read-as-zero. */
 	uint32_t coreidle                     : 1;  /**< Core Idle.
                                                          The bit indicates that the core finished transferring all RxFIFO data to
                                                          system memory, writing out all completed descriptors, and all Event Counts
@@ -2395,26 +2365,26 @@ union cvmx_usbdrdx_uahc_dsts {
                                                            idle and the lower layer finishes the disconnect process. */
 	uint32_t usblnkst                     : 4;  /**< USB/Link State.
                                                          In SuperSpeed mode, uses LTSSM State:
-                                                            0x0: U0.
-                                                            0x1: U1.
-                                                            0x2: U2.
-                                                            0x3: U3.
-                                                            0x4: SS_DIS.
-                                                            0x5: RX_DET.
-                                                            0x6: SS_INACT.
-                                                            0x7: POLL.
-                                                            0x8: RECOV.
-                                                            0x9: HRESET.
-                                                            0xa: CMPLY.
-                                                            0xb: LPBK.
-                                                            0xf: Resume/Reset.
+                                                            0x0 = U0.
+                                                            0x1 = U1.
+                                                            0x2 = U2.
+                                                            0x3 = U3.
+                                                            0x4 = SS_DIS.
+                                                            0x5 = RX_DET.
+                                                            0x6 = SS_INACT.
+                                                            0x7 = POLL.
+                                                            0x8 = RECOV.
+                                                            0x9 = HRESET.
+                                                            0xa = CMPLY.
+                                                            0xb = LPBK.
+                                                            0xf = Resume/Reset.
                                                             others: Reserved.
                                                          In High/Full/LowSpeed mode:
-                                                            0x0: On state.
-                                                            0x2: Sleep (L1) state.
-                                                            0x3: Suspend (L2) state.
-                                                            0x4: Disconnected state (Default state).
-                                                            0x5: Early Suspend state.
+                                                            0x0 = On state.
+                                                            0x2 = Sleep (L1) state.
+                                                            0x3 = Suspend (L2) state.
+                                                            0x4 = Disconnected state (Default state).
+                                                            0x5 = Early Suspend state.
                                                             others: Reserved.
                                                          The link state Resume/Reset indicates that the core received a resume or
                                                          USB reset request from the host while the link was in hibernation. Software
@@ -2423,11 +2393,11 @@ union cvmx_usbdrdx_uahc_dsts {
 	uint32_t rxfifoempty                  : 1;  /**< RxFIFO Empty Indication. */
 	uint32_t soffn                        : 14; /**< Frame/MicroFrame Number of the Received SOF.
                                                          When the core is operating at high-speed,
-                                                         - [16:6] indicates the frame number.
-                                                         - [5:3] indicates the microframe number.
+                                                           <16:6> = Frame number.
+                                                           <5:3> = Microframe number.
                                                          When the core is operating at full-speed,
-                                                         - [16:14] is not used, software can ignore these 3 bits.
-                                                         - [13:3] indicates the frame number. */
+                                                           <16:14> = Not used, software can ignore these 3 bits.
+                                                           <13:3> = Frame number. */
 	uint32_t connectspd                   : 3;  /**< Connected Speed.
                                                          Indicates the speed at which the controller core has come up after speed
                                                          detection through a chirp sequence.
@@ -2563,8 +2533,6 @@ typedef union cvmx_usbdrdx_uahc_erstszx cvmx_usbdrdx_uahc_erstszx_t;
  * regardless of which AXI transaction received the error.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.12.
  */
 union cvmx_usbdrdx_uahc_gbuserraddr {
 	uint64_t u64;
@@ -2589,7 +2557,6 @@ typedef union cvmx_usbdrdx_uahc_gbuserraddr cvmx_usbdrdx_uahc_gbuserraddr_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.5.
  */
 union cvmx_usbdrdx_uahc_gctl {
 	uint32_t u32;
@@ -2617,11 +2584,8 @@ union cvmx_usbdrdx_uahc_gctl {
                                                          needs to programmed is: Power Down Scale = 10500/16 = 657 (rounded up; and fastest
                                                          frequency used). */
 	uint32_t masterfiltbypass             : 1;  /**< Master filter bypass. Not relevant for Cavium's configuration. */
-	uint32_t bypssetaddr                  : 1;  /**< Bypass SetAddress in Device Mode
-                                                         Always set to 0.
-                                                         INTERNAL: When set, core uses the value in USBDRD()_UAHC_DCFG[DEVADDR] directly
-                                                         for comparing the device address tokens. In simulation, this can be used to avoid
-                                                         sending a SET_ADDRESS command. */
+	uint32_t bypssetaddr                  : 1;  /**< Bypass SetAddress in Device Mode.
+                                                         Always set to 0. */
 	uint32_t u2rstecn                     : 1;  /**< If the SuperSpeed commenction fails during POLL or LMP exchange, the device connects
                                                          at non-SuperSpeed mode. If this bit is set, then device attemps three more times to
                                                          connect at SuperSpeed, even if it previously failed to operate in SuperSpeed mode.
@@ -2641,15 +2605,9 @@ union cvmx_usbdrdx_uahc_gctl {
                                                          USBDRD()_UAHC_GRLSID, USBDRD()_UAHC_GGPIO, USBDRD()_UAHC_GUID,
                                                          USBDRD()_UAHC_GUSB2PHYCFG(),
                                                          USBDRD()_UAHC_GUSB3PIPECTL().
-                                                         When you reset PHYs (using USBDRD()_UAHC_GUSB2PHYCFG() or USBDRD()_UAHC_GUSB3PIPECTL()),
-                                                         you
-                                                         must keep the
-                                                         core in reset state until PHY clocks are stable. This controls the bus, RAM, and MAC
-                                                         domain resets.
-                                                         INTERNAL: Refer to Reset Generation on Synopsys Databook page 250.
-                                                         Under soft reset, accesses to USBDRD()_UAHC_* CSRs other than USBDRD()_UAHC_GCTL may fail
-                                                         (timeout).
-                                                         This bit is for debug purposes only. Use USBDRD()_UAHC_USBCMD[HCRST] for soft reset. */
+                                                         When you reset PHYs (using USBDRD()_UAHC_GUSB2PHYCFG() or
+                                                         USBDRD()_UAHC_GUSB3PIPECTL()), you must keep the core in reset state until PHY
+                                                         clocks are stable. This controls the bus, RAM, and MAC domain resets. */
 	uint32_t sofitpsync                   : 1;  /**< Synchronize ITP to reference clock. In host mode, if this bit is set to:
                                                          0 = The core keeps the UTMI/ULPI PHY on the first port in non-suspended state whenever
                                                          there is a SuperSpeed port that is not in Rx.Detect, SS.Disable, and U3 state.
@@ -2699,11 +2657,7 @@ union cvmx_usbdrdx_uahc_gctl {
                                                          0x1 = Enables scaled down SuperSpeed timing and repeat values including:
                                                          * Number of TxEq training sequences reduce to eight
                                                          * LFPS polling burst time reduce to 100 ns
-                                                         * LFPS warm reset receive reduce to 30 us.
-                                                         INTERNAL: Refer to the rtl_vip_scaledown_mapping.xls file under <workspace>/sim/SoC_sim
-                                                         directory for the complete list.
-                                                         0x2 = No TxEq training sequences are sent. Overrides bit<4>.
-                                                         0x3 = Enables bits<0> and <1> scale-down timing values. */
+                                                         * LFPS warm reset receive reduce to 30 us. */
 	uint32_t disscramble                  : 1;  /**< Disable scrambling. Transmit request to link partner on next transition to recovery or polling. */
 	uint32_t u2exit_lfps                  : 1;  /**< LFPS U2 exit.
                                                          0 = The link treats 248ns LFPS as a valid U2 exit.
@@ -2749,8 +2703,6 @@ typedef union cvmx_usbdrdx_uahc_gctl cvmx_usbdrdx_uahc_gctl_t;
  * See description in USBDRD()_UAHC_GDBGFIFOSPACE.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.5.
  */
 union cvmx_usbdrdx_uahc_gdbgbmu {
 	uint32_t u32;
@@ -2805,9 +2757,6 @@ typedef union cvmx_usbdrdx_uahc_gdbgepinfo cvmx_usbdrdx_uahc_gdbgepinfo_t;
  * is needed for the silicon, contact customer support with a dump of these registers.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.2.
- * INTERNAL: Contact Synopsys directly.
  */
 union cvmx_usbdrdx_uahc_gdbgfifospace {
 	uint32_t u32;
@@ -2847,8 +2796,6 @@ typedef union cvmx_usbdrdx_uahc_gdbgfifospace cvmx_usbdrdx_uahc_gdbgfifospace_t;
  * See description in USBDRD()_UAHC_GDBGFIFOSPACE.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.4.
  */
 union cvmx_usbdrdx_uahc_gdbglnmcc {
 	uint32_t u32;
@@ -2899,9 +2846,6 @@ typedef union cvmx_usbdrdx_uahc_gdbglsp cvmx_usbdrdx_uahc_gdbglsp_t;
  * See description in USBDRD()_UAHC_GDBGFIFOSPACE.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.6.
- * INTERNAL: This register is for Synopsys internal use only.
  */
 union cvmx_usbdrdx_uahc_gdbglspmux {
 	uint32_t u32;
@@ -2914,8 +2858,7 @@ union cvmx_usbdrdx_uahc_gdbglspmux {
                                                          using a mux) this signal with other trace signals in your system to generate a common
                                                          trace signal, you can use this feature. */
 	uint32_t endbc                        : 1;  /**< Enable debugging of the debug capability LSP. Use HOSTSELECT to select the DbC LSP debug
-                                                         information presented in the GDBGLSP register.
-                                                         INTERNAL: Note this can only be used if DebugCapabaility was enabled at compile. */
+                                                         information presented in the GDBGLSP register. */
 	uint32_t reserved_14_14               : 1;
 	uint32_t hostselect                   : 14; /**< Host select. Selects the LSP debug information presented in USBDRD()_UAHC_GDBGLSP. */
 #else
@@ -2942,8 +2885,6 @@ typedef union cvmx_usbdrdx_uahc_gdbglspmux cvmx_usbdrdx_uahc_gdbglspmux_t;
  * See description in USBDRD()_UAHC_GDBGFIFOSPACE.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.3.
  */
 union cvmx_usbdrdx_uahc_gdbgltssm {
 	uint32_t u32;
@@ -3016,8 +2957,6 @@ typedef union cvmx_usbdrdx_uahc_gdbgltssm cvmx_usbdrdx_uahc_gdbgltssm_t;
  * is always awarded; there is no idle.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.5.
  */
 union cvmx_usbdrdx_uahc_gdmahlratio {
 	uint32_t u32;
@@ -3054,8 +2993,6 @@ typedef union cvmx_usbdrdx_uahc_gdmahlratio cvmx_usbdrdx_uahc_gdmahlratio_t;
  * or USBDRD()_UCTL_CTL[UAHC_RST],
  * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
  * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.7.1.
  */
 union cvmx_usbdrdx_uahc_gevntadrx {
 	uint64_t u64;
@@ -3095,8 +3032,6 @@ typedef union cvmx_usbdrdx_uahc_gevntadrx cvmx_usbdrdx_uahc_gevntadrx_t;
  * or USBDRD()_UCTL_CTL[UAHC_RST],
  * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
  * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.7.3.
  */
 union cvmx_usbdrdx_uahc_gevntcountx {
 	uint32_t u32;
@@ -3131,8 +3066,6 @@ typedef union cvmx_usbdrdx_uahc_gevntcountx cvmx_usbdrdx_uahc_gevntcountx_t;
  * or USBDRD()_UCTL_CTL[UAHC_RST],
  * or USBDRD()_UAHC_GCTL[CORESOFTRESET],
  * or USBDRD()_UAHC_USBCMD[HCRST], or USBDRD()_UAHC_USBCMD[LHCRST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.7.2.
  */
 union cvmx_usbdrdx_uahc_gevntsizx {
 	uint32_t u32;
@@ -3181,8 +3114,6 @@ typedef union cvmx_usbdrdx_uahc_gevntsizx cvmx_usbdrdx_uahc_gevntsizx_t;
  * REF_CLK signal.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.6.
  */
 union cvmx_usbdrdx_uahc_gfladj {
 	uint32_t u32;
@@ -3221,9 +3152,7 @@ union cvmx_usbdrdx_uahc_gfladj {
                                                          GFLADJ_REFCLK_LPM_SEL = 1, USBDRD()_UAHC_GCTL[SOFITPSYNC] must not be set to 1.
                                                          When GFLADJ_REFCLK_LPM_SEL = 1 the overloading of the suspend control of the USB 2.0 first
                                                          port PHY (UTMI) with USB 3.0 port states is removed. Note that the REF_CLK frequencies
-                                                         supported in this mode are 16/17/19.2/20/24/39.7/40 MHz.
-                                                         INTERNAL: The utmi_clk[0] signal of the core must be connected to the FREECLK of the PHY.
-                                                         If you set this bit to 1, USBDRD()_UAHC_GUSB2PHYCFG()[U2_FREECLK_EXISTS] must be set to 0. */
+                                                         supported in this mode are 16/17/19.2/20/24/39.7/40 MHz. */
 	uint32_t reserved_22_22               : 1;
 	uint32_t gfladj_refclk_fladj          : 14; /**< This field indicates the frame length adjustment to be applied when SOF/ITP counter is
                                                          running off of the REF_CLK. This register value is used to adjust:.
@@ -3283,8 +3212,6 @@ typedef union cvmx_usbdrdx_uahc_gfladj cvmx_usbdrdx_uahc_gfladj_t;
  * debugging.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.9.
  */
 union cvmx_usbdrdx_uahc_ggpio {
 	uint32_t u32;
@@ -3308,8 +3235,7 @@ typedef union cvmx_usbdrdx_uahc_ggpio cvmx_usbdrdx_uahc_ggpio_t;
  * cvmx_usbdrd#_uahc_ghwparams0
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.1.
+ *
  */
 union cvmx_usbdrdx_uahc_ghwparams0 {
 	uint32_t u32;
@@ -3341,8 +3267,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams0 cvmx_usbdrdx_uahc_ghwparams0_t;
  * cvmx_usbdrd#_uahc_ghwparams1
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.2.
+ *
  */
 union cvmx_usbdrdx_uahc_ghwparams1 {
 	uint32_t u32;
@@ -3351,8 +3276,7 @@ union cvmx_usbdrdx_uahc_ghwparams1 {
 	uint32_t en_dbc                       : 1;  /**< Enable debug capability. */
 	uint32_t rm_opt_features              : 1;  /**< Remove optional features. */
 	uint32_t sync_rst                     : 1;  /**< Synchronous reset coding. */
-	uint32_t ram_bus_clks_sync            : 1;  /**< RAM_CLK and BUS_CLK are synchronous. INTERNAL: (appears to be orthogonal from the
-                                                         RAM_CLK_TO_BUS_CLK parameter) */
+	uint32_t ram_bus_clks_sync            : 1;  /**< RAM_CLK and BUS_CLK are synchronous. */
 	uint32_t mac_ram_clks_sync            : 1;  /**< MAC3_CLK and RAM_CLK are synchronous. */
 	uint32_t mac_phy_clks_sync            : 1;  /**< MAC3_CLK and PHY_CLK are synchronous. */
 	uint32_t en_pwropt                    : 2;  /**< Power optimization mode:
@@ -3395,8 +3319,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams1 cvmx_usbdrdx_uahc_ghwparams1_t;
  * cvmx_usbdrd#_uahc_ghwparams2
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.3.
+ *
  */
 union cvmx_usbdrdx_uahc_ghwparams2 {
 	uint32_t u32;
@@ -3419,7 +3342,6 @@ typedef union cvmx_usbdrdx_uahc_ghwparams2 cvmx_usbdrdx_uahc_ghwparams2_t;
  *
  * This register contains the hardware configuration options selected at compile-time.
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.4.
  */
 union cvmx_usbdrdx_uahc_ghwparams3 {
 	uint32_t u32;
@@ -3461,8 +3383,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams3 cvmx_usbdrdx_uahc_ghwparams3_t;
  * cvmx_usbdrd#_uahc_ghwparams4
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.5.
+ *
  */
 union cvmx_usbdrdx_uahc_ghwparams4 {
 	uint32_t u32;
@@ -3500,8 +3421,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams4 cvmx_usbdrdx_uahc_ghwparams4_t;
  * cvmx_usbdrd#_uahc_ghwparams5
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.6.
+ *
  */
 union cvmx_usbdrdx_uahc_ghwparams5 {
 	uint32_t u32;
@@ -3533,8 +3453,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams5 cvmx_usbdrdx_uahc_ghwparams5_t;
  * cvmx_usbdrd#_uahc_ghwparams6
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.7.
+ *
  */
 union cvmx_usbdrdx_uahc_ghwparams6 {
 	uint32_t u32;
@@ -3576,8 +3495,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams6 cvmx_usbdrdx_uahc_ghwparams6_t;
  * cvmx_usbdrd#_uahc_ghwparams7
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.3.8.
+ *
  */
 union cvmx_usbdrdx_uahc_ghwparams7 {
 	uint32_t u32;
@@ -3601,8 +3519,7 @@ typedef union cvmx_usbdrdx_uahc_ghwparams7 cvmx_usbdrdx_uahc_ghwparams7_t;
  * cvmx_usbdrd#_uahc_ghwparams8
  *
  * This register contains the hardware configuration options selected at compile-time.
- * INTERNAL: Register field names refer to Synopsys DWC_USB3_* parameters of the same suffix.
- *           See Synopsys DWC_usb3 Databook v2.20a, section 6.2.3.9.
+ *
  */
 union cvmx_usbdrdx_uahc_ghwparams8 {
 	uint32_t u32;
@@ -3630,9 +3547,6 @@ typedef union cvmx_usbdrdx_uahc_ghwparams8 cvmx_usbdrdx_uahc_ghwparams8_t;
  * assistance is needed for the silicon, contact Customer Support with a dump of these registers.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.4.1.
- * INTERNAL: Contact Synopsys directly.
  */
 union cvmx_usbdrdx_uahc_gpmsts {
 	uint32_t u32;
@@ -3683,8 +3597,6 @@ typedef union cvmx_usbdrdx_uahc_gpmsts cvmx_usbdrdx_uahc_gpmsts_t;
  * register should always be 0.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.2.1.
  */
 union cvmx_usbdrdx_uahc_gprtbimap {
 	uint64_t u64;
@@ -3714,8 +3626,6 @@ typedef union cvmx_usbdrdx_uahc_gprtbimap cvmx_usbdrdx_uahc_gprtbimap_t;
  * low-speed bus-instance, so this register should always be 0x0.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.2.3.
  */
 union cvmx_usbdrdx_uahc_gprtbimap_fs {
 	uint64_t u64;
@@ -3745,8 +3655,6 @@ typedef union cvmx_usbdrdx_uahc_gprtbimap_fs cvmx_usbdrdx_uahc_gprtbimap_fs_t;
  * register should always be 0.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.2.2.
  */
 union cvmx_usbdrdx_uahc_gprtbimap_hs {
 	uint64_t u64;
@@ -3770,18 +3678,13 @@ typedef union cvmx_usbdrdx_uahc_gprtbimap_hs cvmx_usbdrdx_uahc_gprtbimap_hs_t;
  * cvmx_usbdrd#_uahc_grlsid
  *
  * This is a read-only register that contains the release number of the core.
- * INTERNAL: Original name: GSNPSID = Synopsys ID.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.8.
+ *
  */
 union cvmx_usbdrdx_uahc_grlsid {
 	uint32_t u32;
 	struct cvmx_usbdrdx_uahc_grlsid_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t releaseid                    : 32; /**< Software can use this register to configure release-specific features in the driver.
-                                                         INTERNAL: Synopsys ID
-                                                          * SynopsysID[31:16] indicates Core Identification Number. 0x5533 is ASCII for
-                                                         U3 (DWC_usb3).
-                                                          * SynopsysID[15:0] indicates the release number. Current Release is 2.50a. */
+	uint32_t releaseid                    : 32; /**< Software can use this register to configure release-specific features in the driver. */
 #else
 	uint32_t releaseid                    : 32;
 #endif
@@ -3818,8 +3721,6 @@ typedef union cvmx_usbdrdx_uahc_grlsid cvmx_usbdrdx_uahc_grlsid_t;
  * SuperSpeed, 1 high-speed, and 1 full-speed/low-speed).
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.3.
  */
 union cvmx_usbdrdx_uahc_grxfifoprihst {
 	uint32_t u32;
@@ -3849,10 +3750,6 @@ typedef union cvmx_usbdrdx_uahc_grxfifoprihst cvmx_usbdrdx_uahc_grxfifoprihst_t;
  * Reset values = 0:[0x0000_0084] 1:[0x0084_0104] 2:[0x0188_0180].
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.6.2.
- * INTERNAL: For more information, see the BMU section in Block Descriptions on Synopsys Databook
- * page 238.
  */
 union cvmx_usbdrdx_uahc_grxfifosizx {
 	uint32_t u32;
@@ -3861,10 +3758,7 @@ union cvmx_usbdrdx_uahc_grxfifosizx {
 	uint32_t rxfstaddr                    : 16; /**< RxFIFOn RAM start address. This field contains the memory start address for RxFIFOn. The
                                                          reset value is derived from configuration parameters. */
 	uint32_t rxfdep                       : 16; /**< RxFIFOn depth. This value is in terms of RX RAM Data width.
-                                                         minimum value = 0x20, maximum value = 0x4000.
-                                                         INTERNAL: For more information, see the Hardware Integration chapter of the Synopsys
-                                                         Databook.
-                                                         The reset value is derived from configuration parameters. */
+                                                         minimum value = 0x20, maximum value = 0x4000. */
 #else
 	uint32_t rxfdep                       : 16;
 	uint32_t rxfstaddr                    : 16;
@@ -3899,8 +3793,6 @@ typedef union cvmx_usbdrdx_uahc_grxfifosizx cvmx_usbdrdx_uahc_grxfifosizx_t;
  * A larger RX threshold affects the performance since the scheduler is idle during this time.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.4.
  */
 union cvmx_usbdrdx_uahc_grxthrcfg {
 	uint32_t u32;
@@ -3959,10 +3851,6 @@ typedef union cvmx_usbdrdx_uahc_grxthrcfg cvmx_usbdrdx_uahc_grxthrcfg_t;
  * priority over other burst lengths. The core always performs the largest burst when enabled.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: The AXI cache signals are not connected in Cavium's hookup, so the *REQINFO fields
- * can be ignored.
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.1.
  */
 union cvmx_usbdrdx_uahc_gsbuscfg0 {
 	uint32_t u32;
@@ -4027,8 +3915,6 @@ typedef union cvmx_usbdrdx_uahc_gsbuscfg0 cvmx_usbdrdx_uahc_gsbuscfg0_t;
  * before starting any transactions on AXI.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.2.
  */
 union cvmx_usbdrdx_uahc_gsbuscfg1 {
 	uint32_t u32;
@@ -4070,7 +3956,6 @@ typedef union cvmx_usbdrdx_uahc_gsbuscfg1 cvmx_usbdrdx_uahc_gsbuscfg1_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.6.
  */
 union cvmx_usbdrdx_uahc_gsts {
 	uint32_t u32;
@@ -4136,8 +4021,6 @@ typedef union cvmx_usbdrdx_uahc_gsts cvmx_usbdrdx_uahc_gsts_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST],
  * or USBDRD()_UAHC_GCTL[CORESOFTRESET].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.1.
  */
 union cvmx_usbdrdx_uahc_gtxfifopridev {
 	uint32_t u32;
@@ -4168,9 +4051,9 @@ typedef union cvmx_usbdrdx_uahc_gtxfifopridev cvmx_usbdrdx_uahc_gtxfifopridev_t;
  *
  *   1. Among the FIFOs in the same speed group (SuperSpeed or HighSpeed/FullSpeed/LowSpeed):
  *
- *     a. High-priority TXFIFOs are granted access using round-robin arbitration
+ * _   a. High-priority TXFIFOs are granted access using round-robin arbitration
  *
- *     b. Low-priority TXFIFOs are granted access using round-robin arbitration only after the
+ * _   b. Low-priority TXFIFOs are granted access using round-robin arbitration only after the
  *        high priority TXFIFOs have no further processing to do (i.e., either the TXQs are empty
  *        or thecorresponding TXFIFOs are full).
  *
@@ -4185,8 +4068,6 @@ typedef union cvmx_usbdrdx_uahc_gtxfifopridev cvmx_usbdrdx_uahc_gtxfifopridev_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST],
  * or USBDRD()_UAHC_GCTL[CORESOFTRESET].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.9.2.
  */
 union cvmx_usbdrdx_uahc_gtxfifoprihst {
 	uint32_t u32;
@@ -4218,10 +4099,6 @@ typedef union cvmx_usbdrdx_uahc_gtxfifoprihst cvmx_usbdrdx_uahc_gtxfifoprihst_t;
  * Reset values = 0:[0x0000_0082] 1:[0x0082_0103] 2:[0x0185_0205].
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.6.1.
- * INTERNAL: For more information, refer to the BMU section in Block Descriptions on Synopsys
- * Databook page 238.
  */
 union cvmx_usbdrdx_uahc_gtxfifosizx {
 	uint32_t u32;
@@ -4230,10 +4107,7 @@ union cvmx_usbdrdx_uahc_gtxfifosizx {
 	uint32_t txfstaddr                    : 16; /**< Transmit FIFOn RAM start address. Contains the memory start address for TxFIFOn. The reset
                                                          is value derived from configuration parameters. */
 	uint32_t txfdep                       : 16; /**< TxFIFOn depth. This value is in terms of TX RAM data width.
-                                                         minimum value = 0x20, maximum value = 0x8000.
-                                                         INTERNAL: For more information, see the Hardware Integration chapter of the Synopsys
-                                                         Databook.
-                                                         The reset value derived from configuration parameters. */
+                                                         minimum value = 0x20, maximum value = 0x8000. */
 #else
 	uint32_t txfdep                       : 16;
 	uint32_t txfstaddr                    : 16;
@@ -4265,8 +4139,6 @@ typedef union cvmx_usbdrdx_uahc_gtxfifosizx cvmx_usbdrdx_uahc_gtxfifosizx_t;
  * * A larger threshold affects the performance, since the scheduler is idle during this time.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.3.
  */
 union cvmx_usbdrdx_uahc_gtxthrcfg {
 	uint32_t u32;
@@ -4316,8 +4188,6 @@ typedef union cvmx_usbdrdx_uahc_gtxthrcfg cvmx_usbdrdx_uahc_gtxthrcfg_t;
  * mode. Most of the options are used to improve host inter-operability with different devices.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.11.
  */
 union cvmx_usbdrdx_uahc_guctl {
 	uint32_t u32;
@@ -4668,7 +4538,6 @@ typedef union cvmx_usbdrdx_uahc_guctl cvmx_usbdrdx_uahc_guctl_t;
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
  *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.7.
  */
 union cvmx_usbdrdx_uahc_guctl1 {
 	uint32_t u32;
@@ -4704,8 +4573,6 @@ typedef union cvmx_usbdrdx_uahc_guctl1 cvmx_usbdrdx_uahc_guctl1_t;
  * * As a scratch register.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.50a, section 6.2.1.10.
  */
 union cvmx_usbdrdx_uahc_guid {
 	uint32_t u32;
@@ -4729,8 +4596,6 @@ typedef union cvmx_usbdrdx_uahc_guid cvmx_usbdrdx_uahc_guid_t;
  * This register is reserved for future use.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UAHC_RST].
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.5.2.
  */
 union cvmx_usbdrdx_uahc_gusb2i2cctlx {
 	uint32_t u32;
@@ -4757,8 +4622,6 @@ typedef union cvmx_usbdrdx_uahc_gusb2i2cctlx cvmx_usbdrdx_uahc_gusb2i2cctlx_t;
  * implemented.
  *
  * Do not make changes to this register after the initial programming.
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.5.1.
  */
 union cvmx_usbdrdx_uahc_gusb2phycfgx {
 	uint32_t u32;
@@ -4789,7 +4652,7 @@ union cvmx_usbdrdx_uahc_gusb2phycfgx {
                                                          USB turnaround time is a critical certification criteria when using long cables and five
                                                          hub levels.
                                                          When the MAC interface is 8-bit UTMI+/ULPI, the required values for this field is 0x9. */
-	uint32_t xcvrdly                      : 1;  /**< Transceiver Delay
+	uint32_t xcvrdly                      : 1;  /**< Transceiver delay.
                                                          Enables a delay between the assertion of the UTMI Transceiver Select signal (for
                                                          HighSpeed) and the assertion of the TxValid signal during a HighSpeed Chirp.
                                                          When this bit is set to 1, a delay of approximately 2.5us is introduced from
@@ -4868,8 +4731,6 @@ typedef union cvmx_usbdrdx_uahc_gusb2phycfgx cvmx_usbdrdx_uahc_gusb2phycfgx_t;
  * implemented.
  *
  * Do not make changes to this register after the initial programming.
- *
- * INTERNAL: See Synopsys DWC_usb3 Databook v2.20a, section 6.2.5.4.
  */
 union cvmx_usbdrdx_uahc_gusb3pipectlx {
 	uint32_t u32;
@@ -4905,14 +4766,10 @@ union cvmx_usbdrdx_uahc_gusb3pipectlx {
                                                          0 = Core does U1/U2/U3 exit in PHY power state P0 (default behavior).
                                                          1 = Core does U1/U2/U3 exit in PHY power state P1/P2/P3 respectively.
                                                          This bit is added for SuperSpeed PHY workaround where SuperSpeed PHY injects a glitch on
-                                                         pipe3_RxElecIdle while receiving Ux exit LFPS, and pipe3_PowerDown change is in progress.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
-                                                         Synopsys PHY. */
+                                                         pipe3_RxElecIdle while receiving Ux exit LFPS, and pipe3_PowerDown change is in progress. */
 	uint32_t ping_enchance_en             : 1;  /**< Ping enhancement enable. When set to 1, the downstream-port U1-ping-receive timeout
                                                          becomes 500 ms instead of 300 ms. Minimum Ping.LFPS receive duration is 8 ns (one mac3_clk
-                                                         cycle). This field is valid for the downstream port only.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
-                                                         Synopsys PHY. */
+                                                         cycle). This field is valid for the downstream port only. */
 	uint32_t u1u2exitfail_to_recov        : 1;  /**< U1U2exit fail to recovery. When set to 1, and U1/U2 LFPS handshake fails, the LTSSM
                                                          transitions from U1/U2 to recovery instead of SS.inactive.
                                                          If recovery fails, then the LTSSM can enter SS.Inactive. This is an enhancement only. It
@@ -4921,33 +4778,26 @@ union cvmx_usbdrdx_uahc_gusb3pipectlx {
                                                          0 = if immediate Ux exit (remotely initiated, or locally initiated) happens, the core does
                                                          not request P1/P2/P3 power state change.
                                                          1 = the core always requests PHY power change from P0 to P1/P2/P3 during U0 to U1/U2/U3
-                                                         transition.
-                                                         INTERNAL: Note: This bit should be set to 1 for Synopsys PHY. For third-party SuperSpeed
-                                                         PHY, check with your PHY vendor. */
+                                                         transition. */
 	uint32_t startrxdetu3rxdet            : 1;  /**< Start receiver detection in U3/Rx.Detect.
                                                          If DISRXDETU3RXDET is set to 1 during reset, and the link is in U3 or Rx.Detect state, the
                                                          core starts receiver detection on rising edge of this bit.
                                                          This bit is valid for downstream ports only, and this feature must not be enabled for
-                                                         normal operation.
-                                                         INTERNAL: If have to use this feature, contact Synopsys. */
+                                                         normal operation. */
 	uint32_t disrxdetu3rxdet              : 1;  /**< Disable receiver detection in U3/Rx.Detect. When set to 1, the core does not do receiver
                                                          detection in U3 or Rx.Detect state. If STARTRXDETU3RXDET is set to 1 during reset,
                                                          receiver detection starts manually.
                                                          This bit is valid for downstream ports only, and this feature must not be enabled for
-                                                         normal operation.
-                                                         INTERNAL: If have to use this feature, contact Synopsys. */
+                                                         normal operation. */
 	uint32_t delaypx                      : 3;  /**< Delay P1P2P3. Delay P0 to P1/P2/P3 request when entering U1/U2/U3 until (DELAYPX * 8)
                                                          8B10B error occurs, or Pipe3_RxValid drops to 0.
-                                                         DELAYPXTRANSENTERUX must reset to 1 to enable this functionality.
-                                                         INTERNAL: Should always be 0x1 for a Synopsys PHY. */
+                                                         DELAYPXTRANSENTERUX must reset to 1 to enable this functionality. */
 	uint32_t delaypxtransenterux          : 1;  /**< Delay PHY power change from P0 to P1/P2/P3 when link state changing from U0 to U1/U2/U3
                                                          respectively.
                                                          0 = when entering U1/U2/U3, transition to P1/P2/P3 without checking for Pipe3_RxElecIlde
                                                          and pipe3_RxValid.
                                                          1 = when entering U1/U2/U3, delay the transition to P1/P2/P3 until the pipe3 signals,
-                                                         Pipe3_RxElecIlde is 1 and pipe3_RxValid is 0.
-                                                         INTERNAL: Note: This bit should be set to '1' for Synopsys PHY. It is also used by third-
-                                                         party SuperSpeed PHY. */
+                                                         Pipe3_RxElecIlde is 1 and pipe3_RxValid is 0. */
 	uint32_t suspend_en                   : 1;  /**< Suspend USB3.0 SuperSpeed PHY (Suspend_en). When set to 1, and if suspend conditions are
                                                          valid, the USB 3.0 PHY enters suspend mode. */
 	uint32_t datwidth                     : 2;  /**< PIPE data width.
@@ -4956,15 +4806,10 @@ union cvmx_usbdrdx_uahc_gusb3pipectlx {
                                                          0x2 = 8 bits.
                                                          0x3 = reserved.
                                                          One clock cycle after reset, these bits receive the value seen on the pipe3_DataBusWidth.
-                                                         This will always be 0x0.
-                                                         INTERNAL: The simulation testbench uses the coreConsultant parameter to configure the VIP.
-                                                         INTERNAL: These bits in the coreConsultant parameter should match your PHY data width and
-                                                         the pipe3_DataBusWidth port. */
+                                                         This will always be 0x0. */
 	uint32_t abortrxdetinu2               : 1;  /**< Abort RX Detect in U2. When set to 1, and the link state is U2, the core aborts receiver
                                                          detection if it receives U2 exit LFPS from the remote link partner.
-                                                         This bit is for downstream port only.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
-                                                         Synopsys PHY. */
+                                                         This bit is for downstream port only. */
 	uint32_t skiprxdet                    : 1;  /**< Skip RX detect. When set to 1, the core skips RX detection if pipe3_RxElecIdle is low.
                                                          Skip is defined as waiting for the appropriate timeout, then repeating the operation. */
 	uint32_t lfpsp0algn                   : 1;  /**< LFPS P0 align. When set to 1:
@@ -4978,14 +4823,9 @@ union cvmx_usbdrdx_uahc_gusb3pipectlx {
                                                          0 = P0 is always entered as an intermediate state during transitions between P2 and P3, as
                                                          defined in the PIPE3 specification.
                                                          1 = the core transitions directly from Phy power state P2 to P3 or from state P3 to P2.
-                                                         According to PIPE3 specification, any direct transition between P3 and P2 is illegal.
-                                                         INTERNAL: This bit is used only for some non-Synopsys PHYs that cannot do LFPS in P3.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
-                                                         Synopsys PHY. */
+                                                         According to PIPE3 specification, any direct transition between P3 and P2 is illegal. */
 	uint32_t p3exsigp2                    : 1;  /**< P3 exit signal in P2. When set to 1, the core always changes the PHY power state to P2,
-                                                         before attempting a U3 exit handshake.
-                                                         INTERNAL: Note: This bit is used by third-party SuperSpeed PHY. It should be set to 0 for
-                                                         Synopsys PHY. */
+                                                         before attempting a U3 exit handshake. */
 	uint32_t lfpsfilt                     : 1;  /**< LFPS filter. When set to 1, filter LFPS reception with pipe3_RxValid in PHY power state
                                                          P0, ignore LFPS reception from the PHY unless both pipe3_Rxelecidle and pipe3_RxValid are
                                                          deasserted. */
@@ -6055,10 +5895,7 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          0x2 = Reserved.
                                                          0x3 = Reserved.
                                                          This value can be changed only during UPHY_RST.
-                                                         If REF_CLK_SEL = 0x0, then the reference clock input cannot be spread-spectrum.
-                                                         INTERNAL: For the 0x1 selection, reference clock source for SuperSpeed PLL is from the USB
-                                                         pads, reference clock source for HighSpeed PLL is PLL_REF_CLK. But in 78xx, PLL_REF_CLK
-                                                         cannot be routed to USB without violating jitter requirements */
+                                                         If REF_CLK_SEL = 0x0, then the reference clock input cannot be spread-spectrum. */
 	uint64_t ssc_en                       : 1;  /**< Spread-spectrum clock enable. Enables spread-spectrum clock production in the SuperSpeed
                                                          function. If the input reference clock for the SuperSpeed PLL is already spread-spectrum,
                                                          then do not enable this feature. The clocks sourced to the SuperSpeed function must have
@@ -6091,14 +5928,7 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          All other values are reserved.
                                                          This value may only be changed during UPHY_RST.
                                                          Note: If REF_CLK_SEL = 0x2 or 0x3, then MPLL_MULTPLIER, REF_CLK_DIV2, and SSC_REF_CLK_SEL
-                                                         must all be programmed to the same frequency setting.
-                                                           INTERNAL: If REF_CLK_SEL = 0x0 or 0x1, then:
-                                                                       0x0 is the only legal value.
-                                                                     If REF_CLK_SEL = 0x2 or 0x3, then:
-                                                                       0x108: if DLMC_REF_CLK* is 19.2MHz, 24MHz, 26MHz, 38.4MHz, 48MHz,
-                                                                                         52MHz, 76.8MHz, 96MHz, 104MHz.
-                                                                       0x0:   if DLMC_REF_CLK* is another supported frequency (see list in
-                                                                              MPLL_MULTIPLIER description). */
+                                                         must all be programmed to the same frequency setting. */
 	uint64_t mpll_multiplier              : 7;  /**< Multiplies the reference clock to a frequency suitable for intended operating speed. The
                                                          legal values are:
                                                            If REF_CLK_SEL = 0x0 or 0x1, then:
@@ -6110,30 +5940,7 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          All other values are reserved.
                                                          This value may only be changed during UPHY_RST.
                                                          Note: If REF_CLK_SEL = 0x2 or 0x3, then MPLL_MULTPLIER, REF_CLK_DIV2, and SSC_REF_CLK_SEL
-                                                         must all be programmed to the same frequency setting.
-                                                           INTERNAL: If REF_CLK_SEL = 0x0 or 0x1, then:
-                                                                        0x19 = 100  MHz on DLMC_REF_CLK*
-                                                                        0x68 =  24  MHz on DLMC_REF_CLK*
-                                                                        0x7D =  20  MHz on DLMC_REF_CLK*
-                                                                        0x02 =  19.2MHz on DLMC_REF_CLK*
-                                                                     If REF_CLK_SEL = 0x2 or 0x3, then:
-                                                                        0x02 =  19.2MHz on DLMC_REF_CLK*
-                                                                        0x7D =  20  MHz on DLMC_REF_CLK*
-                                                                        0x68 =  24  MHz on DLMC_REF_CLK*
-                                                                        0x64 =  25  MHz on DLMC_REF_CLK*
-                                                                        0x60 =  26  MHz on DLMC_REF_CLK*
-                                                                        0x41 =  38.4MHz on DLMC_REF_CLK*
-                                                                        0x7D =  40  MHz on DLMC_REF_CLK*
-                                                                        0x34 =  48  MHz on DLMC_REF_CLK*
-                                                                        0x32 =  50  MHz on DLMC_REF_CLK*
-                                                                        0x30 =  52  MHz on DLMC_REF_CLK*
-                                                                        0x41 =  76.8MHz on DLMC_REF_CLK*
-                                                                        0x1A =  96  MHz on DLMC_REF_CLK*
-                                                                        0x19 =  100 MHz on DLMC_REF_CLK*
-                                                                        0x30 =  104 MHz on DLMC_REF_CLK* if REF_CLK_DIV2 = 0x1
-                                                                        0x18 =  104 MHz on DLMC_REF_CLK* if REF_CLK_DIV2 = 0x0
-                                                                        0x28 =  125 MHz on DLMC_REF_CLK*
-                                                                        0x19 =  200 MHz on DLMC_REF_CLK* */
+                                                         must all be programmed to the same frequency setting. */
 	uint64_t ref_ssp_en                   : 1;  /**< Enables reference clock to the prescaler for SuperSpeed function. This should always be
                                                          enabled since this output clock is used to drive the UAHC suspend-mode clock during
                                                          low-power states.
@@ -6150,15 +5957,7 @@ union cvmx_usbdrdx_uctl_ctl {
                                                                   MPLL_MULTIPLIER description).
                                                          This value can be changed only during UPHY_RST.
                                                          Note: If REF_CLK_SEL = 0x2 or 0x3, then MPLL_MULTPLIER, REF_CLK_DIV2, and SSC_REF_CLK_SEL
-                                                         must all be programmed to the same frequency setting.
-                                                           INTERNAL: If REF_CLK_SEL = 0x0 or 0x1, then:
-                                                                       all DLMC_REF_CLK* frequencies: 0x0 is the only legal value.
-                                                                     If REF_CLK_SEL = 0x2 or 0x3, then:
-                                                                       0x1: if DLMC_REF_CLK* is 125MHz.
-                                                                       0x1: if DLMC_REF_CLK* is 40MHz, 76.8MHz, or 200MHz.
-                                                                       0x0 or 0x1 if DLMC_REF_CLK* is 104MHz (depending on MPLL_MULTIPLIER setting)
-                                                                       0x0: if DLMC_REF_CLK* is another supported frequency (see list in
-                                                                            MPLL_MULTIPLIER description). */
+                                                         must all be programmed to the same frequency setting. */
 	uint64_t ref_clk_fsel                 : 6;  /**< Selects the reference clock frequency for the SuperSpeed and high-speed PLL blocks.
                                                          The legal values are:
                                                            If REF_CLK_SEL = 0x0 or 0x1, then:
@@ -6169,14 +5968,7 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          This value may only be changed during UPHY_RST.
                                                          Note: When REF_CLK_SEL = 0x2 or 0x3, the MPLL_MULTIPLIER, REF_CLK_DIV2, and
                                                          SSC_REF_CLK_SEL settings are used to configure the SuperSpeed reference clock
-                                                         multiplier.
-                                                           INTERNAL: If REF_CLK_SEL = 0x0 or 0x1, then:
-                                                                       0x27 = 100  MHz on DLMC_REF_CLK*
-                                                                       0x2A =  24  MHz on DLMC_REF_CLK*
-                                                                       0x31 =  20  MHz on DLMC_REF_CLK*
-                                                                       0x38 =  19.2MHz on DLMC_REF_CLK*
-                                                                     If REF_CLK_SEL = 0x2 or 0x3, then:
-                                                                       0x07 is the only legal value. */
+                                                         multiplier. */
 	uint64_t reserved_31_31               : 1;
 	uint64_t h_clk_en                     : 1;  /**< Controller-clock enable. When set to 1, the controller clock is generated. This also
                                                          enables access to UCTL registers 0x30-0xF8. */
@@ -6187,8 +5979,7 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          You must still set H_CLK_EN separately. H_CLK_BYP_SEL select should not be changed
                                                          unless H_CLK_EN is disabled.
                                                          The bypass clock can be selected and running even if the controller-clock dividers are not
-                                                         running.
-                                                         INTERNAL: Generally bypass is only used for scan purposes. */
+                                                         running. */
 	uint64_t h_clkdiv_rst                 : 1;  /**< Controller-clock divider reset. Divided clocks are not generated while the divider is
                                                          being reset.
                                                          This also resets the suspend-clock divider. */
@@ -6215,16 +6006,7 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          for full-rate USB2 operation.
                                                          If DRD_MODE = HOST, the hclk frequency must be at or above 62.5MHz
                                                          for any USB2 operation.
-                                                         This field can be changed only when H_CLKDIV_RST = 1.
-                                                         INTERNAL: 150MHz is from the maximum of:
-                                                                     Synopsys DWC_usb3 Databook v2.50a, table A-16, row 1, col 12.
-                                                                     Synopsys DWC_usb3 Databook v2.50a, table A-17, row 7, col 9.
-                                                                     Synopsys DWC_usb3 Databook v2.50a, table A-16, row 7, col 9.
-                                                                   DEVICE>125MHz is from Synopsys DWC_usb3 Databook v2.50a, section A.12.4.
-                                                                   HOST2>62.5MHz in HOST mode is from Synopsys DWC_usb3 Databook v2.50a,
-                                                                     section A.12.5, 3rd bullet in Note on page 894.
-                                                                   HOST2>90MHz was arrived at from some math: 62.5MHz +
-                                                                     (diff between row 1 and 2, col 12 of table A-16). */
+                                                         This field can be changed only when H_CLKDIV_RST = 1. */
 	uint64_t reserved_22_23               : 2;
 	uint64_t usb3_port_perm_attach        : 1;  /**< Indicates this port is permanently attached. This is a strap signal; it should be modified
                                                          only when UPHY_RST is asserted. */
@@ -6259,16 +6041,12 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          1 - Device
                                                          0 - Host */
 	uint64_t uphy_rst                     : 1;  /**< PHY reset; resets UPHY; active-high. */
-	uint64_t uahc_rst                     : 1;  /**< Software reset; resets UAHC; active-high.
-                                                         INTERNAL: Note that soft-resetting the UAHC while it is active may cause violations of RSL
-                                                         or NCB protocols. */
+	uint64_t uahc_rst                     : 1;  /**< Software reset; resets UAHC; active-high. */
 	uint64_t uctl_rst                     : 1;  /**< Software reset; resets UCTL; active-high.
                                                          Resets UAHC DMA and register shims. Resets UCTL RSL registers 0x30-0xF8.
                                                          Does not reset UCTL RSL registers 0x0-0x28.
                                                          UCTL RSL registers starting from 0x30 can be accessed only after the controller clock is
-                                                         active and UCTL_RST is deasserted.
-                                                         INTERNAL: Note that soft-resetting the UCTL while it is active may cause violations of
-                                                         RSL, NCB, and CIB protocols. */
+                                                         active and UCTL_RST is deasserted. */
 #else
 	uint64_t uctl_rst                     : 1;
 	uint64_t uahc_rst                     : 1;
@@ -6720,8 +6498,6 @@ typedef union cvmx_usbdrdx_uctl_portx_cfg_hs cvmx_usbdrdx_uctl_portx_cfg_hs_t;
  * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
- *
- * INTERNAL: All these settings are for high-speed functionality, connect on DVDD power domain.
  */
 union cvmx_usbdrdx_uctl_portx_cfg_ss {
 	uint64_t u64;
@@ -6794,8 +6570,7 @@ union cvmx_usbdrdx_uctl_portx_cfg_ss {
                                                          In general, the parameter controls are static signals to be set prior to taking the PHY
                                                          out of reset. However, you can dynamically change these values on-the-fly for test
                                                          purposes. In this case, changes to the transmitter to reflect the current value occur only
-                                                         after the pipeP_tx_deemph[1:0] input changes.
-                                                         INTERNAL: Default value is package dependant. */
+                                                         after the pipeP_tx_deemph[1:0] input changes. */
 	uint64_t pcs_tx_deemph_6db            : 6;  /**< Fine-tune transmitter driver deemphasis when set to 6db.
                                                          This static value sets the TX driver deemphasis value when pipeP_tx_deemph[1:0] is set to
                                                          0x2 (according to the PIPE3 specification). This bus is provided for completeness and as a
@@ -6805,16 +6580,14 @@ union cvmx_usbdrdx_uctl_portx_cfg_ss {
                                                          In general, the parameter controls are static signals to be set prior to taking the PHY
                                                          out of reset. However, you can dynamically change these values on-the-fly for test
                                                          purposes. In this case, changes to the transmitter to reflect the current value occur only
-                                                         after the pipeP_tx_deemph[1:0] input changes.
-                                                         INTERNAL: Default value is package dependant. */
+                                                         after the pipeP_tx_deemph[1:0] input changes. */
 	uint64_t pcs_tx_swing_full            : 7;  /**< Launch amplitude of the transmitter. Sets the launch amplitude of the transmitter. The
                                                          values for transmit amplitude are derived from the following equation:
                                                          TX amplitude (V) = vptx * ((pcs_tx_swing_full + 1)/128)
                                                          In general, the parameter controls are static signals to be set prior to taking the PHY
                                                          out of reset. However, you can dynamically change these values on-the-fly for test
                                                          purposes. In this case, changes to the transmitter to reflect the current value occur only
-                                                         after the pipeP_tx_deemph[1:0] input changes.
-                                                         INTERNAL: Default value is package dependant. */
+                                                         after the pipeP_tx_deemph[1:0] input changes. */
 	uint64_t lane0_tx_term_offset         : 5;  /**< Transmitter termination offset. Reserved, set to 0x0. */
 	uint64_t reserved_6_7                 : 2;
 	uint64_t res_tune_ack                 : 1;  /**< Resistor tune acknowledge. While asserted, indicates a resistor tune is in progress. */
@@ -6857,61 +6630,6 @@ typedef union cvmx_usbdrdx_uctl_portx_cfg_ss cvmx_usbdrdx_uctl_portx_cfg_ss_t;
  * This register is accessible only when USBDRD()_UCTL_CTL[H_CLK_EN] = 1.
  *
  * This register can be reset by IOI reset or with USBDRD()_UCTL_CTL[UCTL_RST].
- *
- * INTERNAL: (In body of HRM)
- * To access the PHY registers indirectly through the CR interface, the HCLK must be running,
- * UCTL_RST must be deasserted, and UPHY_RST must be deasserted. Software is responsible for
- * ensuring that only one indirect access is ongoing at a time.
- *
- * To read a PHY register via indirect CR interface:
- *   1. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [DATA_IN] with the <<address>> of the register,
- *     * [CAP_ADDR], [CAP_DATA], [READ], and [WRITE] fields 0x0.
- *   2. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [DATA_IN] with the <<address>> of the register,
- *     * [CAP_ADDR] field 0x1,
- *     * [CAP_DATA], [READ], and [WRITE] fields 0x0.
- *   3. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x1.
- *   4. Write UCTL_PORTn_CR_DBG_CFG with all 0x0's.
- *   5. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x0.
- *   6. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [READ] field 0x1,
- *     * [DATA_IN], [CAP_ADDR], [CAP_DATA], and [WRITE] fields 0x0.
- *   7. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x1.
- *   8. Read UCTL_PORTn_CR_DBG_STATUS[DATA_OUT]. This is the <<read data>>.
- *   9. Write UCTL_PORTn_CR_DBG_CFG with all 0x0's.
- *   10. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x0.
- *
- * To write a PHY register via indirect CR interface:
- *   1. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [DATA_IN] with the <<address>> of the register,
- *     * [CAP_ADDR], [CAP_DATA], [READ], and [WRITE] fields 0x0.
- *   2. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [DATA_IN] with the <<address>> of the register,
- *     * [CAP_ADDR] field 0x1,
- *     * [CAP_DATA], [READ], and [WRITE] fields 0x0.
- *   3. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x1.
- *   4. Write UCTL_PORTn_CR_DBG_CFG with all 0x0's.
- *   5. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x0.
- *   6. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [DATA_IN] with the <<write data>>,
- *     * [CAP_ADDR], [CAP_DATA], [READ], and [WRITE] fields 0x0.
- *   7. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [DATA_IN] with the write data,
- *     * [CAP_DATA] field 0x1,
- *     * [CAP_ADDR], [READ], and [WRITE] fields 0x0.
- *   8. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x1.
- *   9. Write UCTL_PORTn_CR_DBG_CFG with all 0x0's.
- *   10. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x0.
- *   11. Write UCTL_PORTn_CR_DBG_CFG with:
- *     * [WRITE] field 0x1,
- *     * [DATA_IN], [CAP_ADDR], and [READ] fields 0x0.
- *   12. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x1.
- *   13. Write UCTL_PORTn_CR_DBG_CFG with all 0x0's.
- *   14. Poll for UCTL_PORTn_CR_DBG_STATUS[ACK] 0x0.
- *
- * For partial writes, a read-modify write is required. Note that the CAP_ADDR steps (1-5)
- * do not have to be repeated until the address needs changed.
  */
 union cvmx_usbdrdx_uctl_portx_cr_dbg_cfg {
 	uint64_t u64;
@@ -7103,7 +6821,7 @@ union cvmx_usbdrdx_uctl_spare0_eco {
 	struct cvmx_usbdrdx_uctl_spare0_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 32; /**< N/A */
 #else
 	uint64_t eco_rw                       : 32;
 	uint64_t reserved_32_63               : 32;
@@ -7147,7 +6865,7 @@ union cvmx_usbdrdx_uctl_spare1_eco {
 	struct cvmx_usbdrdx_uctl_spare1_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t eco_rw                       : 32; /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 32; /**< N/A */
 #else
 	uint64_t eco_rw                       : 32;
 	uint64_t reserved_32_63               : 32;
diff --git a/arch/mips/include/asm/octeon/cvmx-xcv-defs.h b/arch/mips/include/asm/octeon/cvmx-xcv-defs.h
index aff8b60..a816045 100644
--- a/arch/mips/include/asm/octeon/cvmx-xcv-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-xcv-defs.h
@@ -226,14 +226,14 @@ union cvmx_xcv_ctl {
 	uint64_t reserved_4_63                : 60;
 	uint64_t lpbk_ext                     : 1;  /**< Enable external loopback mode. External loopback loops the RX datapath to the TX
                                                          datapath. For correct operation, the following CSRs must be configured:
-                                                         * XCV_CTL[SPEED]          = 0x2
-                                                         * XCV_DLL_CTL[REFCLK_SEL] = 1
-                                                         * XCV_RESET[CLKRST]       = 1 */
+                                                         * XCV_CTL[SPEED]          = 0x2.
+                                                         * XCV_DLL_CTL[REFCLK_SEL] = 1.
+                                                         * XCV_RESET[CLKRST]       = 1. */
 	uint64_t lpbk_int                     : 1;  /**< Enable internal loopback mode. Internal loopback loops the TX datapath to the RX
                                                          datapath. For correct operation, the following CSRs must be configured:
-                                                         * XCV_CTL[SPEED]          = 0x2
-                                                         * XCV_DLL_CTL[REFCLK_SEL] = 0
-                                                         * XCV_RESET[CLKRST]       = 0 */
+                                                         * XCV_CTL[SPEED]          = 0x2.
+                                                         * XCV_DLL_CTL[REFCLK_SEL] = 0.
+                                                         * XCV_RESET[CLKRST]       = 0. */
 	uint64_t speed                        : 2;  /**< XCV operational speed:
                                                          0x0 = 10 Mbps.
                                                          0x1 = 100 Mbps.
@@ -305,7 +305,7 @@ union cvmx_xcv_dll_ctl {
 	uint64_t clkrx_set                    : 7;  /**< RX clock delay setting to use in bypass mode.
                                                          Skews RXC from RXD. */
 	uint64_t clktx_byp                    : 1;  /**< Bypass the TX clock delay setting.
-                                                         Skews TXC from TXD,TXCTL.
+                                                         Skews TXC from TXD, TXCTL.
                                                          By default, clock and data and sourced
                                                          synchronously. */
 	uint64_t clktx_set                    : 7;  /**< TX clock delay setting to use in bypass mode.
@@ -319,9 +319,7 @@ union cvmx_xcv_dll_ctl {
                                                          0x0 = RGMII REFCLK.
                                                          0x1 = RGMII RXC (1000Mbs only).
                                                          0x2 = Divided coprocessor clk.
-                                                         0x3 = Reserved.
-                                                         INTERNAL: Some programming magic could allow for 10/100 operation if
-                                                         critical, use encoding 0x1 but some programming restrictions would apply. */
+                                                         0x3 = Reserved. */
 #else
 	uint64_t refclk_sel                   : 2;
 	uint64_t reserved_2_7                 : 6;
@@ -346,7 +344,7 @@ union cvmx_xcv_eco {
 	struct cvmx_xcv_eco_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t eco_rw                       : 16; /**< INTERNAL: Reserved for ECO usage. */
+	uint64_t eco_rw                       : 16; /**< N/A */
 #else
 	uint64_t eco_rw                       : 16;
 	uint64_t reserved_16_63               : 48;
diff --git a/arch/mips/include/asm/octeon/octeon-model.h b/arch/mips/include/asm/octeon/octeon-model.h
index 004ac53..2b2db2c 100644
--- a/arch/mips/include/asm/octeon/octeon-model.h
+++ b/arch/mips/include/asm/octeon/octeon-model.h
@@ -43,7 +43,7 @@
  * File defining different Octeon model IDs and macros to
  * compare them.
  *
- * <hr>$Revision: 124439 $<hr>
+ * <hr>$Revision: 127653 $<hr>
  */
 
 #ifndef __OCTEON_MODEL_H__
@@ -104,6 +104,7 @@ extern "C" {
 #define OCTEON_CNF75XX_PASS1_X  (OCTEON_CNF75XX_PASS1_0 | OM_IGNORE_MINOR_REVISION)
 
 #define OCTEON_CN73XX_PASS1_0   0x000d9700
+#define OCTEON_CN73XX_PASS1_1   0x000d9701
 #define OCTEON_CN73XX           (OCTEON_CN73XX_PASS1_0 | OM_IGNORE_REVISION)
 #define OCTEON_CN73XX_PASS1_X   (OCTEON_CN73XX_PASS1_0 | OM_IGNORE_MINOR_REVISION)
 
@@ -125,7 +126,7 @@ extern "C" {
 #define OCTEON_CN78XX_PASS1_1   0x000d9501
 #define OCTEON_CN78XX_PASS2_0   0x000d9508
 
-#define OCTEON_CN78XX           (OCTEON_CN78XX_PASS1_0 | OM_IGNORE_REVISION)
+#define OCTEON_CN78XX           (OCTEON_CN78XX_PASS2_0 | OM_IGNORE_REVISION)
 #define OCTEON_CN78XX_PASS1_X   (OCTEON_CN78XX_PASS1_0 | OM_IGNORE_MINOR_REVISION)
 #define OCTEON_CN78XX_PASS2_X   (OCTEON_CN78XX_PASS2_0 | OM_IGNORE_MINOR_REVISION)
 
-- 
2.6.2

