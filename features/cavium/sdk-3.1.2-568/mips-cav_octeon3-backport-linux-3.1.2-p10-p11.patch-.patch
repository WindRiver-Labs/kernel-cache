From b70c90baf3280b25db472f65c0d8b279b8344ece Mon Sep 17 00:00:00 2001
From: Zhenbo Gao <zhenbo.gao@windriver.com>
Date: Tue, 16 Jan 2018 14:10:03 +0800
Subject: [PATCH] mips/cav_octeon3: backport linux-3.1.2-p10-p11.patch from
 Cavium official website

linux-3.1.2-p10-p11.patch is from sdk_3.1.2_update_p11.tgz,
which is got from Cavium official support website.

Signed-off-by: Zhenbo Gao <zhenbo.gao@windriver.com>
---
 .../executive/cvmx-appcfg-transport.c              |    8 +-
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c |   45 +-
 .../mips/cavium-octeon/executive/cvmx-helper-pki.c |   73 ++-
 arch/mips/cavium-octeon/executive/cvmx-l2c.c       |   30 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |    7 +-
 arch/mips/cavium-octeon/executive/cvmx-pki.c       |   13 +-
 arch/mips/cavium-octeon/setup.c                    |   57 ++-
 arch/mips/include/asm/octeon/cvmx-app-init.h       |    4 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     |  778 +++++++++++++++++++-
 arch/mips/include/asm/octeon/cvmx-helper-util.h    |   22 +-
 arch/mips/include/asm/octeon/cvmx-l2c.h            |    5 +-
 arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h   |   55 ++-
 arch/mips/include/asm/octeon/cvmx-pciercx-defs.h   |   55 ++-
 drivers/net/ethernet/octeon/octeon3-ethernet.c     |   33 +-
 drivers/watchdog/octeon-wdt-main.c                 |   27 +-
 15 files changed, 1100 insertions(+), 112 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-appcfg-transport.c b/arch/mips/cavium-octeon/executive/cvmx-appcfg-transport.c
index 21b155b..832884e 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-appcfg-transport.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-appcfg-transport.c
@@ -410,7 +410,6 @@ int __cvmx_import_app_config(void)
 	const cvmx_bootmem_named_block_desc_t *block_desc;
 	int pko_cfg_sz;
 	int64_t app_config_addr;
-	int res = 0, dbg = 0;
 
 	/* find named block */
 	block_desc = cvmx_bootmem_find_named_block(cvmx_appcfg_transport_block_name);
@@ -431,12 +430,7 @@ int __cvmx_import_app_config(void)
 	/* read fpa pool config from named block */
 	__cvmx_import_fpa_config(app_config_addr);
 
-	/* import is done, now delete the named block */
-	res = cvmx_bootmem_free_named(cvmx_appcfg_transport_block_name);
-	if (dbg)
-		cvmx_dprintf("free transport config block res=%d\n", res);
-
-	return !res;
+	return 0;
 }
 
 /**
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index 00e671b..2dc45c5 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -982,10 +982,11 @@ EXPORT_SYMBOL(cvmx_helper_get_port_phy_present);
 int __cvmx_helper_init_port_valid(void)
 {
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
-	int i, j, n;
+	int i, j, node;
 	bool valid;
 	static void *fdt_addr = 0;
 	int rc;
+	cvmx_coremask_t *pcm = &cvmx_sysinfo_get()->core_mask;
 
 	if (fdt_addr == 0)
 		fdt_addr = __cvmx_phys_addr_to_ptr(cvmx_sysinfo_get()->fdt_addr,
@@ -1003,24 +1004,32 @@ int __cvmx_helper_init_port_valid(void)
 		 * clear them.
 		 *
 		 * Also clear any ports that are not defined in the device tree.
+		 * Apply this to each node.
 		 */
-		for (i = 0; i < CVMX_HELPER_MAX_GMX; i++) {
-			int j;
-			for (j = 0; j < cvmx_helper_interface_enumerate(i); j++) {
-				cvmx_bgxx_cmrx_config_t cmr_config;
-				cmr_config.u64 = cvmx_read_csr(CVMX_BGXX_CMRX_CONFIG(j, i));
+		for (node = 0; node < CVMX_MAX_NODES; node++) { 
+			if (!cvmx_coremask_get64_node(pcm, node))
+				continue;
+			for (i = 0; i < CVMX_HELPER_MAX_GMX; i++) {
+				int j;
+				int xiface = cvmx_helper_node_interface_to_xiface(node, i);
+				for (j = 0; j < cvmx_helper_interface_enumerate(i); j++) {
+					cvmx_bgxx_cmrx_config_t cmr_config;
+					cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(j, i));
 #if defined(CVMX_BUILD_FOR_STANDALONE) || defined(CVMX_BUILD_FOR_LINUX_USER)
-				if (cmr_config.s.mix_en)
-					cvmx_helper_set_port_valid(i, j, false);
-				else 
+					if (cmr_config.s.mix_en)
+						cvmx_helper_set_port_valid(xiface, j, false);
+					else 
 #endif
-				if ((cmr_config.s.lane_to_sds == 0xe4 &&
-				     cmr_config.s.lmac_type != 4 &&
-				     cmr_config.s.lmac_type != 1 &&
-				     cmr_config.s.lmac_type != 5) ||
-				    (cvmx_helper_get_port_fdt_node_offset(i, j) ==
-				     CVMX_HELPER_CFG_INVALID_VALUE))
-					cvmx_helper_set_port_valid(i, j, false);
+					if ((cmr_config.s.lane_to_sds == 0xe4 &&
+						cmr_config.s.lmac_type != 4 &&
+						cmr_config.s.lmac_type != 1 &&
+						cmr_config.s.lmac_type != 5) ||
+						((cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) &&
+						(cvmx_helper_get_port_fdt_node_offset(xiface, j) ==
+								  CVMX_HELPER_CFG_INVALID_VALUE)))
+						cvmx_helper_set_port_valid(xiface, j, false);
+				}
+
 			}
 		}
 		return rc;
@@ -1029,7 +1038,7 @@ int __cvmx_helper_init_port_valid(void)
 	/* TODO: Update this to behave more like 78XX */
 	for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
 
-		n = cvmx_helper_interface_enumerate(i);
+		int n = cvmx_helper_interface_enumerate(i);
 		for (j = 0; j < n; j++) {
 			int ipd_port = cvmx_helper_get_ipd_port(i, j);
 			valid = (__cvmx_helper_board_get_port_from_dt(fdt_addr,
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
index 9bef4ed..b56bbf9 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
@@ -1106,43 +1106,56 @@ int cvmx_helper_pki_init_port(int ipd_port, struct cvmx_pki_prt_schd *prtsch)
 			qpg_cfg.grp_bad = qossch->sso_grp;
 			cvmx_pki_write_qpg_entry(xp.node, prtsch->qpg_base + qos, &qpg_cfg);
 			if (pki_helper_debug)
-				cvmx_dprintf("pki-helper:port-init: port %d qos %d has port_add %d aura %d grp %d\n",
+				cvmx_dprintf("%s: port %d qos %d "
+				"has port_add %d aura %d grp %d\n",
+				__func__,
 				ipd_port, qos, qossch->port_add,
 				qossch->aura_num, qossch->sso_grp);
-		}
-	} else
+		} /* for qos 0 ... num_qos */
+	} else {
 		qpg_cfg.port_add = 0;
 		qpg_cfg.aura_num = prtsch->aura_num;
 		qpg_cfg.grp_ok = prtsch->sso_grp;
 		qpg_cfg.grp_bad = prtsch->sso_grp;
 		cvmx_pki_write_qpg_entry(xp.node, prtsch->qpg_base, &qpg_cfg);
-		/* Allocate style here and map it to the port */
-		rs = cvmx_pki_style_alloc(xp.node, prtsch->style);
-		if (rs == CVMX_RESOURCE_ALREADY_RESERVED) {
-			cvmx_dprintf("pki-helper: INFO: style will be shared\n");
-		} else if (rs == CVMX_RESOURCE_ALLOC_FAILED) {
-			cvmx_dprintf("pki-helper: ERROR: style not available\n");
-			return CVMX_RESOURCE_ALLOC_FAILED;
-		} else {
-			prtsch->style = rs;
-			if (pki_helper_debug)
-				cvmx_dprintf("pki-helper:port-init: port %d has style %d\n",
-					ipd_port, prtsch->style);
-			style_cfg = pki_dflt_style[xp.node];
-			style_cfg.parm_cfg.qpg_qos = prtsch->qpg_qos;
-			style_cfg.parm_cfg.qpg_base = prtsch->qpg_base;
-			style_cfg.parm_cfg.qpg_port_msb = 0;
-			style_cfg.parm_cfg.qpg_port_sh = 0;
-			style_cfg.parm_cfg.mbuff_size = mbuff_size;
-			cvmx_pki_write_style_config(xp.node, prtsch->style,
-				CVMX_PKI_CLUSTER_ALL, &style_cfg);
-		}
-		pknd = cvmx_helper_get_pknd(xiface, cvmx_helper_get_interface_index_num(ipd_port));
-		cvmx_pki_read_pkind_config(xp.node, pknd, &pknd_cfg);
-		pknd_cfg.initial_style = prtsch->style;
-		pknd_cfg.fcs_pres = __cvmx_helper_get_has_fcs(xiface);
-		cvmx_pki_write_pkind_config(xp.node, pknd, &pknd_cfg);
-		return 0;
+
+		if (pki_helper_debug)
+			cvmx_dprintf("%s: non-qos port %d has aura %d grp %d\n",
+					__func__,
+					ipd_port, prtsch->aura_num, prtsch->sso_grp);
+	}
+	/* LR: The rest of code is common for qos and non-qos ports */
+
+	/* Allocate style here and map it to the port */
+	rs = cvmx_pki_style_alloc(xp.node, prtsch->style);
+	if (rs == CVMX_RESOURCE_ALREADY_RESERVED) {
+		cvmx_dprintf("%s INFO: style will be shared\n",__func__);
+	} else if (rs == CVMX_RESOURCE_ALLOC_FAILED) {
+		cvmx_dprintf("%s ERROR: style not available\n",__func__);
+		return CVMX_RESOURCE_ALLOC_FAILED;
+	}
+	prtsch->style = rs;
+	if (pki_helper_debug)
+		cvmx_dprintf("%s: port %d has style %d\n", __func__, ipd_port, prtsch->style);
+
+	/* Config STYLE to above QPG table base entry */
+	style_cfg = pki_dflt_style[xp.node];
+	style_cfg.parm_cfg.qpg_qos = prtsch->qpg_qos;
+	style_cfg.parm_cfg.qpg_base = prtsch->qpg_base;
+	style_cfg.parm_cfg.qpg_port_msb = 0;
+	style_cfg.parm_cfg.qpg_port_sh = 0;
+	style_cfg.parm_cfg.mbuff_size = mbuff_size;
+	cvmx_pki_write_style_config(xp.node, prtsch->style,
+			CVMX_PKI_CLUSTER_ALL, &style_cfg);
+	/* Update PKND with initial STYLE */
+	pknd = cvmx_helper_get_pknd(xiface,
+			cvmx_helper_get_interface_index_num(ipd_port));
+
+	cvmx_pki_read_pkind_config(xp.node, pknd, &pknd_cfg);
+	pknd_cfg.initial_style = prtsch->style;
+	pknd_cfg.fcs_pres = __cvmx_helper_get_has_fcs(xiface);
+	cvmx_pki_write_pkind_config(xp.node, pknd, &pknd_cfg);
+	return 0;
 }
 EXPORT_SYMBOL(cvmx_helper_pki_init_port);
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-l2c.c b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
index 14fddd5..2eec9d2 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-l2c.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
@@ -43,7 +43,7 @@
  * Implementation of the Level 2 Cache (L2C) control,
  * measurement, and debugging facilities.
  *
- * <hr>$Revision: 154262 $<hr>
+ * <hr>$Revision: 158623 $<hr>
  *
  */
 
@@ -1132,12 +1132,17 @@ uint64_t cvmx_l2c_tqdl2d_to_index_7xxx(int node, int tad)
  *
  * @return	index address to pass to the LTGL2I cache operation (3)
  */
-uint64_t cvmx_l2c_ttgx_to_index_7xxx(int node, int tad)
+uint64_t cvmx_l2c_ttgx_to_index_7xxx(int node, int tad, bool remote)
 {
 	union cvmx_l2c_ttgx_err l2c_ttgx_err;
+	union cvmx_l2c_rtgx_err l2c_rtgx_err;
 	uint64_t cindex;
+	bool is78 = OCTEON_IS_MODEL(OCTEON_CN78XX);
 
-	l2c_ttgx_err.u64 = cvmx_read_csr_node(node, CVMX_L2C_TTGX_ERR(tad));
+	if (remote && is78)
+		l2c_rtgx_err.u64 = cvmx_read_csr_node(node, CVMX_L2C_RTGX_ERR(tad));
+	else
+		l2c_ttgx_err.u64 = cvmx_read_csr_node(node, CVMX_L2C_TTGX_ERR(tad));
 
 	/* Figure out the index to pass to the cache 3 instruction
 	 * Note that this is poorly documented and in many cases the HRM is
@@ -1148,7 +1153,7 @@ uint64_t cvmx_l2c_ttgx_to_index_7xxx(int node, int tad)
 	 * Please see the comments for each chip model for the correct
 	 * mapping.
 	 */
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+	if (is78 && !remote) {
 		/* This applies to t88 as well.
 		 *
 		 * payload<24> = remote node
@@ -1162,8 +1167,21 @@ uint64_t cvmx_l2c_ttgx_to_index_7xxx(int node, int tad)
 		/* cindex = (tad & 7) << 7; */	/* 7:9 are the tad */
 		cindex = l2c_ttgx_err.cn78xx.l2idx << 7;	/* 7:19 index */
 		cindex |= l2c_ttgx_err.cn78xx.way << 20;	/* 20:23 way */
-		if (cvmx_get_node_num() != (unsigned)node)
-			cindex |= 1 << 24;
+	} else if (is78 && remote) {
+		/* This applies to t88 as well.
+		 *
+		 * payload<24> = remote node
+		 * payload<23:20> = L2DIDX<10:7>   = way[3:0]
+		 * payload<19:13> = L2DIDX<6:0>    = index<12:6>
+		 * payload<12:11> = L2DIDX<12:11>  = index<5:4>
+		 * payload<10>    = QDNUM<2>       = index<3>
+		 * payload<9:7>   = TAD[2:0]       = index<0:2> = addr<7:9?
+		 */
+
+		/* cindex = (tad & 7) << 7; */	/* 7:9 are the tad */
+		cindex = l2c_rtgx_err.s.l2idx << 7;	/* 7:19 index */
+		cindex |= l2c_rtgx_err.s.way << 20;	/* 20:23 way */
+		cindex |= 1 << 24;			/* Remote tag */
 	} else if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
 		/* payload<24:22> = 0
 		 * payload<18:17> = L2DIDX<10:9> = way[1:0]
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index bd0ea9b..eea979a 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 153133 $<hr>
+ * <hr>$Revision: 160740 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1509,7 +1509,10 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 	pcie_port &= 0x3;
 	qlm = __cvmx_pcie_get_qlm(node, pcie_port);
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	if (qlm < 0) {
+	/* Configure PCIe based on device tree. */
+	if ((qlm < 0) &&
+			(OCTEON_IS_OCTEON3()) &&
+			(!OCTEON_IS_MODEL(OCTEON_CN70XX))) {
 		cvmx_gserx_cfg_t gserx_cfg;
 
 		/* Check for hotplugged endpoints */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pki.c b/arch/mips/cavium-octeon/executive/cvmx-pki.c
index e0755aa..4b5a1d4 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pki.c
@@ -109,13 +109,17 @@ void cvmx_pki_reset(int node)
 	cvmx_pki_sft_rst_t sft_rst;
 
 	sft_rst.u64 = cvmx_read_csr_node(node, CVMX_PKI_SFT_RST);
-	while (sft_rst.s.active != 0)
-		sft_rst.u64 = cvmx_read_csr_node(node, CVMX_PKI_SFT_RST);
+	if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_PKI_SFT_RST,
+					cvmx_pki_sft_rst_t, active, ==, 0, 10000)) {
+		cvmx_dprintf("PKI_SFT_RST is not active\n");
+	}
 
 	sft_rst.s.rst = 1;
 	cvmx_write_csr_node(node, CVMX_PKI_SFT_RST, sft_rst.u64);
-	while (sft_rst.s.busy != 0)
-		sft_rst.u64 = cvmx_read_csr_node(node, CVMX_PKI_SFT_RST);
+	if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_PKI_SFT_RST,
+					cvmx_pki_sft_rst_t, busy, ==, 0, 10000)) {
+		cvmx_dprintf("PKI_SFT_RST is busy\n");
+	}
 }
 
 /**
@@ -152,6 +156,7 @@ void __cvmx_pki_free_ptr(int node)
 	/* Disable caching of any data and return all the prefetched buffers to FPA. */
 	buf_ctl.s.fpa_cac_dis = 1;
 	cvmx_write_csr_node(node, CVMX_PKI_BUF_CTL, buf_ctl.u64);
+	buf_ctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_BUF_CTL);
 }
 
 /**
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index ec27f07..0986434 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -404,8 +404,56 @@ const char *octeon_board_type_string(void)
 const char *get_system_type(void)
 	__attribute__ ((alias("octeon_board_type_string")));
 
+/* Try for a DIDTO of about 250 mS */
+static unsigned int calc_didto(void)
+{
+	unsigned int bit = 0;
+	u64 clk = octeon_get_clock_rate();
+
+	clk >>= 2; /* cycles in 250mS */
+	do {
+		clk >>= 1;
+		if (clk)
+			bit++;
+	} while (clk);
+
+	if (bit > 31)
+		return 0;
+
+	if (OCTEON_IS_OCTEON1PLUS()) {
+		switch (bit) {
+		case 31:
+			return 0;
+		case 30:
+			return 1;
+		default:
+			return 2;
+		}
+	} else {
+		switch (bit) {
+		case 31:
+			return 0;
+		case 30:
+			return 1;
+		case 29:
+			return 2;
+		case 28:
+			return 4;
+		case 27:
+			return 5;
+		case 26:
+			return 6;
+		default:
+			return 7;
+		}
+	}
+}
+
+
+
 void octeon_user_io_init(void)
 {
+	unsigned int v;
 	union octeon_cvmemctl cvmmemctl;
 
 	/* Get the current settings for CP0_CVMMEMCTL_REG */
@@ -466,8 +514,9 @@ void octeon_user_io_init(void)
 	 * = 231, 1 = 230, 2 = 229, 3 = 214. Actual time-out is
 	 * between 1x and 2x this interval. For example, with
 	 * DIDTTO=3, expiration interval is between 16K and 32K. */
-	cvmmemctl.s.didtto = 0;
-	cvmmemctl.s.didtto2 = 0;
+	v = calc_didto();
+	cvmmemctl.s.didtto = v & 3;
+	cvmmemctl.s.didtto2 = (v >> 2) & 1;
 	/* R/W If set, the (mem) CSR clock never turns off. */
 	cvmmemctl.s.csrckalwys = 0;
 	/* R/W If set, mclk never turns off. */
@@ -1045,8 +1094,8 @@ void __init plat_mem_setup(void)
         if (system_limit > max_memory)
                 system_limit = max_memory;
 
-	/* Try to get 256MB (or more) of 32-bit memory */
-	mem_32_size = system_limit <= (16ull * (1ull << 30)) ? 256 * (1 << 20) : 512 * (1 << 20);
+	/* Try to get 512MB of 32-bit memory */
+	mem_32_size = 512 * (1 << 20);
 
 	cvmx_bootmem_lock();
 	limit_max = 0xffffffffull;
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index ef817bd..9fa8cf3 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -41,7 +41,7 @@
  * @file
  * Header file for simple executive application initialization.  This defines
  * part of the ABI between the bootloader and the application.
- * <hr>$Revision: 156174 $<hr>
+ * <hr>$Revision: 160974 $<hr>
  *
  */
 
@@ -324,6 +324,7 @@ enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_NICX40E = 84,
 	CVMX_BOARD_TYPE_NIC23 = 85,	/* Same as NIC73 */
 	CVMX_BOARD_TYPE_EBB7500 = 87,
+	CVMX_BOARD_TYPE_COPPERHEAD = 89,
 	CVMX_BOARD_TYPE_MAX,
 	/* NOTE:  256-257 are being used by a customer. */
 
@@ -478,6 +479,7 @@ static inline const char *cvmx_board_type_to_string(enum cvmx_board_types_enum t
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NICX40E)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC23)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB7500)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_COPPERHEAD)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
 
 		/* Customer boards listed here */
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index 881b6d9..0db400a 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -2473,6 +2473,106 @@ static inline uint64_t CVMX_GSERX_SCRATCH(unsigned long offset)
 #define CVMX_GSERX_SCRATCH(offset) (CVMX_ADD_IO_SEG(0x0001180090000020ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SLICEX_CEI_6G_SR_MODE(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_SLICEX_CEI_6G_SR_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090460268ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+}
+#else
+#define CVMX_GSERX_SLICEX_CEI_6G_SR_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460268ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SLICEX_KR_MODE(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_SLICEX_KR_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090460250ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+}
+#else
+#define CVMX_GSERX_SLICEX_KR_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460250ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SLICEX_KX4_MODE(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_SLICEX_KX4_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090460248ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+}
+#else
+#define CVMX_GSERX_SLICEX_KX4_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460248ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SLICEX_KX_MODE(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_SLICEX_KX_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090460240ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+}
+#else
+#define CVMX_GSERX_SLICEX_KX_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460240ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SLICEX_PCIE1_MODE(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_SLICEX_PCIE1_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090460228ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+}
+#else
+#define CVMX_GSERX_SLICEX_PCIE1_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460228ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SLICEX_PCIE2_MODE(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_SLICEX_PCIE2_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090460230ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+}
+#else
+#define CVMX_GSERX_SLICEX_PCIE2_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460230ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SLICEX_PCIE3_MODE(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_SLICEX_PCIE3_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090460238ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+}
+#else
+#define CVMX_GSERX_SLICEX_PCIE3_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460238ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SLICEX_QSGMII_MODE(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_SLICEX_QSGMII_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090460260ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+}
+#else
+#define CVMX_GSERX_SLICEX_QSGMII_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460260ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SLICEX_RX_LDLL_CTRL(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_SLICEX_RX_LDLL_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090460218ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+}
+#else
+#define CVMX_GSERX_SLICEX_RX_LDLL_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460218ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+
 static inline uint64_t CVMX_GSERX_SLICEX_RX_SDLL_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
@@ -2487,6 +2587,17 @@ static inline uint64_t CVMX_GSERX_SLICEX_RX_SDLL_CTRL(unsigned long offset, unsi
 #define CVMX_GSERX_SLICEX_RX_SDLL_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460220ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SLICEX_SGMII_MODE(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && ((block_id <= 6))))))
+		cvmx_warn("CVMX_GSERX_SLICEX_SGMII_MODE(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090460258ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152;
+}
+#else
+#define CVMX_GSERX_SLICEX_SGMII_MODE(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460258ull) + (((offset) & 1) + ((block_id) & 7) * 0x8ull) * 2097152)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SLICE_CFG(unsigned long offset)
 {
 	if (!(
@@ -6688,23 +6799,17 @@ union cvmx_gserx_lanex_tx_cfg_0 {
 	uint64_t cfg_tx_swing                 : 5;  /**< TX output swing control.
                                                          Default swing encoding when GSER()_LANE()_TX_CFG_1[TX_SWING_OVRRD_EN] is
                                                          asserted.
-                                                         Recommended settings:
-                                                         When auto-negotiated link training is not present, including XFI and all
-                                                         protocols <= 6.25Gbaud except PCIe, the transmit swing should be manually
-                                                         over-ridden. GSER()_LANE()_TX_CFG_1[TX_SWING_OVRRD_EN] should be set
-                                                         and [CFG_TX_SWING] configures the swing. A transmit swing change should be
-                                                         followed by a control interface configuration over-ride to force the
-                                                         new setting - see GSER()_LANE()_PCS_CTLIFC_2[CTLIFC_OVRRD_REQ].
-                                                         [CFG_TX_SWING] should be derived from signal integrity simulations
-                                                         with the IBIS-AMI model supplied by Cavium when auto-negotiated link
-                                                         training is not present and link speed <= 6.25 Gbaud.
-                                                         <pre>
-                                                             Frequency          Possibly useful [CFG_TX_SWING] value
-                                                             --------------------------------------------------------
-                                                              6.25 Gbaud             0xa
-                                                              10.3125 Gbaud          0xd
-                                                              other                  0x7
-                                                         </pre> */
+                                                         It is recommended to not use the GSER()_LANE()_TX_CFG_0[CFG_TX_SWING],
+                                                         GSER()_LANE()_TX_CFG_1[TX_SWING_OVRRD_EN,TX_PREMPTAP_OVRRD_VAL], or
+                                                         GSER()_LANE()_TX_PRE_EMPHASIS[CFG_TX_PREMPTAP] override registers for 10BASE-KR
+                                                         or PCIe links in which the transmitter is adapted by the respective
+                                                         hardware-controlled link training protocols.
+                                                         The [CFG_TX_SWING] value for transmitter swing should be derived from
+                                                         signal integrity simulations with IBIS-AMI models supplied by Cavium.
+                                                         A transmit swing change should be followed by a control interface configuration
+                                                         over-ride to force the new setting - see
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CTLIFC_OVRRD_REQ]. */
+
 	uint64_t fast_rdet_mode               : 1;  /**< Assert to enable fast RX detection. For simulation purposes only. */
 	uint64_t fast_tristate_mode           : 1;  /**< Assert to enable fast tristate power up. For simulation purposes only. */
 	uint64_t reserved_0_0                 : 1;
@@ -9901,6 +10006,580 @@ union cvmx_gserx_scratch {
 typedef union cvmx_gserx_scratch cvmx_gserx_scratch_t;
 
 /**
+ * cvmx_gser#_slice#_cei_6g_sr_mode
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ *
+ * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ */
+union cvmx_gserx_slicex_cei_6g_sr_mode {
+	uint64_t u64;
+	struct cvmx_gserx_slicex_cei_6g_sr_mode_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t slice_spare_1_0              : 2;  /**< Controls enable of pcs_sds_rx_div33 for lane 0 and 1 in the slice:
+                                                         Bit 13 controls enable for lane 0.
+                                                         Bit 14 controls enable for lane 1. */
+	uint64_t rx_ldll_isel                 : 2;  /**< Controls charge pump current for lane DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_sdll_isel                 : 2;  /**< Controls charge pump current for slice DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_pi_bwsel                  : 3;  /**< Controls PI different data rates:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x6 = 4 GHz.
+                                                         0x7 = 5.15625 GHz.
+                                                         All other values in this field are reserved. */
+	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved. */
+	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved. */
+#else
+	uint64_t rx_sdll_bwsel                : 3;
+	uint64_t rx_ldll_bwsel                : 3;
+	uint64_t rx_pi_bwsel                  : 3;
+	uint64_t rx_sdll_isel                 : 2;
+	uint64_t rx_ldll_isel                 : 2;
+	uint64_t slice_spare_1_0              : 2;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_slicex_cei_6g_sr_mode_s cn73xx;
+};
+typedef union cvmx_gserx_slicex_cei_6g_sr_mode cvmx_gserx_slicex_cei_6g_sr_mode_t;
+
+/**
+ * cvmx_gser#_slice#_kr_mode
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ *
+ * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ */
+union cvmx_gserx_slicex_kr_mode {
+	uint64_t u64;
+	struct cvmx_gserx_slicex_kr_mode_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t slice_spare_1_0              : 2;  /**< Controls enable of pcs_sds_rx_div33 for lane 0 and 1 in the slice:
+                                                         Bit 13 controls enable for lane 0.
+                                                         Bit 14 controls enable for lane 1. */
+	uint64_t rx_ldll_isel                 : 2;  /**< Controls charge pump current for lane DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_sdll_isel                 : 2;  /**< Controls charge pump current for slice DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_pi_bwsel                  : 3;  /**< Controls PI different data rates:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x6 = 4 GHz.
+                                                         0x7 = 5.15625 GHz.
+                                                         All other values in this field are reserved. */
+	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved. */
+	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved. */
+#else
+	uint64_t rx_sdll_bwsel                : 3;
+	uint64_t rx_ldll_bwsel                : 3;
+	uint64_t rx_pi_bwsel                  : 3;
+	uint64_t rx_sdll_isel                 : 2;
+	uint64_t rx_ldll_isel                 : 2;
+	uint64_t slice_spare_1_0              : 2;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_slicex_kr_mode_s    cn73xx;
+};
+typedef union cvmx_gserx_slicex_kr_mode cvmx_gserx_slicex_kr_mode_t;
+
+/**
+ * cvmx_gser#_slice#_kx4_mode
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ *
+ * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ */
+union cvmx_gserx_slicex_kx4_mode {
+	uint64_t u64;
+	struct cvmx_gserx_slicex_kx4_mode_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t slice_spare_1_0              : 2;  /**< Controls enable of pcs_sds_rx_div33 for lane 0 and 1 in the slice:
+                                                         Bit 13 controls enable for lane 0.
+                                                         Bit 14 controls enable for lane 1. */
+	uint64_t rx_ldll_isel                 : 2;  /**< Controls charge pump current for lane DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_sdll_isel                 : 2;  /**< Controls charge pump current for slice DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_pi_bwsel                  : 3;  /**< Controls PI different data rates:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x6 = 4 GHz.
+                                                         0x7 = 5.15625 GHz.
+                                                         All other values in this field are reserved. */
+	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved. */
+	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved. */
+#else
+	uint64_t rx_sdll_bwsel                : 3;
+	uint64_t rx_ldll_bwsel                : 3;
+	uint64_t rx_pi_bwsel                  : 3;
+	uint64_t rx_sdll_isel                 : 2;
+	uint64_t rx_ldll_isel                 : 2;
+	uint64_t slice_spare_1_0              : 2;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_slicex_kx4_mode_s   cn73xx;
+};
+typedef union cvmx_gserx_slicex_kx4_mode cvmx_gserx_slicex_kx4_mode_t;
+
+/**
+ * cvmx_gser#_slice#_kx_mode
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ *
+ * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ */
+union cvmx_gserx_slicex_kx_mode {
+	uint64_t u64;
+	struct cvmx_gserx_slicex_kx_mode_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t slice_spare_1_0              : 2;  /**< Controls enable of pcs_sds_rx_div33 for lane 0 and 1 in the slice:
+                                                         Bit 13 controls enable for lane 0.
+                                                         Bit 14 controls enable for lane 1. */
+	uint64_t rx_ldll_isel                 : 2;  /**< Controls charge pump current for lane DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_sdll_isel                 : 2;  /**< Controls charge pump current for slice DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_pi_bwsel                  : 3;  /**< Controls PI different data rates:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x6 = 4 GHz.
+                                                         0x7 = 5.15625 GHz.
+                                                         All other values in this field are reserved. */
+	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved. */
+	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved. */
+#else
+	uint64_t rx_sdll_bwsel                : 3;
+	uint64_t rx_ldll_bwsel                : 3;
+	uint64_t rx_pi_bwsel                  : 3;
+	uint64_t rx_sdll_isel                 : 2;
+	uint64_t rx_ldll_isel                 : 2;
+	uint64_t slice_spare_1_0              : 2;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_slicex_kx_mode_s    cn73xx;
+};
+typedef union cvmx_gserx_slicex_kx_mode cvmx_gserx_slicex_kx_mode_t;
+
+/**
+ * cvmx_gser#_slice#_pcie1_mode
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ *
+ * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ */
+union cvmx_gserx_slicex_pcie1_mode {
+	uint64_t u64;
+	struct cvmx_gserx_slicex_pcie1_mode_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t slice_spare_1_0              : 2;  /**< Controls enable of pcs_sds_rx_div33 for lane 0 and 1 in the slice:
+                                                         Bit 13 controls enable for lane 0.
+                                                         Bit 14 controls enable for lane 1. */
+	uint64_t rx_ldll_isel                 : 2;  /**< Controls charge pump current for lane DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_sdll_isel                 : 2;  /**< Controls charge pump current for slice DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_pi_bwsel                  : 3;  /**< Controls PI different data rates:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x6 = 4 GHz.
+                                                         0x7 = 5.15625 GHz.
+                                                         All other values in this field are reserved.
+                                                         In SATA Mode program RX_PI_BWSEL = 0x1. */
+	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved.
+                                                         In SATA Mode program RX_LDLL_BWSEL = 0x1. */
+	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved.
+                                                         In SATA Mode program RX_SDLL_BWSEL = 0x1. */
+#else
+	uint64_t rx_sdll_bwsel                : 3;
+	uint64_t rx_ldll_bwsel                : 3;
+	uint64_t rx_pi_bwsel                  : 3;
+	uint64_t rx_sdll_isel                 : 2;
+	uint64_t rx_ldll_isel                 : 2;
+	uint64_t slice_spare_1_0              : 2;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_slicex_pcie1_mode_s cn73xx;
+};
+typedef union cvmx_gserx_slicex_pcie1_mode cvmx_gserx_slicex_pcie1_mode_t;
+
+/**
+ * cvmx_gser#_slice#_pcie2_mode
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ *
+ * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ */
+union cvmx_gserx_slicex_pcie2_mode {
+	uint64_t u64;
+	struct cvmx_gserx_slicex_pcie2_mode_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t slice_spare_1_0              : 2;  /**< Controls enable of pcs_sds_rx_div33 for lane 0 and 1 in the slice:
+                                                         Bit 13 controls enable for lane 0.
+                                                         Bit 14 controls enable for lane 1. */
+	uint64_t rx_ldll_isel                 : 2;  /**< Controls charge pump current for lane DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_sdll_isel                 : 2;  /**< Controls charge pump current for slice DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_pi_bwsel                  : 3;  /**< Controls PI different data rates:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x6 = 4 GHz.
+                                                         0x7 = 5.15625 GHz.
+                                                         All other values in this field are reserved.
+                                                         In SATA Mode program RX_PI_BWSEL = 0x1. */
+	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved.
+                                                         In SATA Mode program RX_LDLL_BWSEL = 0x1. */
+	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved.
+                                                         In SATA Mode program RX_SDLL_BWSEL = 0x1. */
+#else
+	uint64_t rx_sdll_bwsel                : 3;
+	uint64_t rx_ldll_bwsel                : 3;
+	uint64_t rx_pi_bwsel                  : 3;
+	uint64_t rx_sdll_isel                 : 2;
+	uint64_t rx_ldll_isel                 : 2;
+	uint64_t slice_spare_1_0              : 2;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_slicex_pcie2_mode_s cn73xx;
+};
+typedef union cvmx_gserx_slicex_pcie2_mode cvmx_gserx_slicex_pcie2_mode_t;
+
+/**
+ * cvmx_gser#_slice#_pcie3_mode
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ *
+ * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ */
+union cvmx_gserx_slicex_pcie3_mode {
+	uint64_t u64;
+	struct cvmx_gserx_slicex_pcie3_mode_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t slice_spare_1_0              : 2;  /**< Controls enable of pcs_sds_rx_div33 for lane 0 and 1 in the slice:
+                                                         Bit 13 controls enable for lane 0.
+                                                         Bit 14 controls enable for lane 1. */
+	uint64_t rx_ldll_isel                 : 2;  /**< Controls charge pump current for lane DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_sdll_isel                 : 2;  /**< Controls charge pump current for slice DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_pi_bwsel                  : 3;  /**< Controls PI different data rates:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x6 = 4 GHz.
+                                                         0x7 = 5.15625 GHz.
+                                                         All other values in this field are reserved.
+                                                         In SATA Mode program RX_PI_BWSEL = 0x1. */
+	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved.
+                                                         In SATA Mode program RX_LDLL_BWSEL = 0x1. */
+	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved.
+                                                         In SATA Mode program RX_SDLL_BWSEL = 0x1. */
+#else
+	uint64_t rx_sdll_bwsel                : 3;
+	uint64_t rx_ldll_bwsel                : 3;
+	uint64_t rx_pi_bwsel                  : 3;
+	uint64_t rx_sdll_isel                 : 2;
+	uint64_t rx_ldll_isel                 : 2;
+	uint64_t slice_spare_1_0              : 2;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_slicex_pcie3_mode_s cn73xx;
+};
+typedef union cvmx_gserx_slicex_pcie3_mode cvmx_gserx_slicex_pcie3_mode_t;
+
+/**
+ * cvmx_gser#_slice#_qsgmii_mode
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ *
+ * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ */
+union cvmx_gserx_slicex_qsgmii_mode {
+	uint64_t u64;
+	struct cvmx_gserx_slicex_qsgmii_mode_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t slice_spare_1_0              : 2;  /**< Controls enable of pcs_sds_rx_div33 for lane 0 and 1 in the slice:
+                                                         Bit 13 controls enable for lane 0.
+                                                         Bit 14 controls enable for lane 1. */
+	uint64_t rx_ldll_isel                 : 2;  /**< Controls charge pump current for lane DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_sdll_isel                 : 2;  /**< Controls charge pump current for slice DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_pi_bwsel                  : 3;  /**< Controls PI different data rates:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x6 = 4 GHz.
+                                                         0x7 = 5.15625 GHz.
+                                                         All other values in this field are reserved. */
+	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved. */
+	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved. */
+#else
+	uint64_t rx_sdll_bwsel                : 3;
+	uint64_t rx_ldll_bwsel                : 3;
+	uint64_t rx_pi_bwsel                  : 3;
+	uint64_t rx_sdll_isel                 : 2;
+	uint64_t rx_ldll_isel                 : 2;
+	uint64_t slice_spare_1_0              : 2;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_slicex_qsgmii_mode_s cn73xx;
+};
+typedef union cvmx_gserx_slicex_qsgmii_mode cvmx_gserx_slicex_qsgmii_mode_t;
+
+/**
+ * cvmx_gser#_slice#_rx_ldll_ctrl
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ *
+ * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ */
+union cvmx_gserx_slicex_rx_ldll_ctrl {
+	uint64_t u64;
+	struct cvmx_gserx_slicex_rx_ldll_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t pcs_sds_rx_ldll_tune         : 3;  /**< Tuning bits for the regulator and loop filter.
+                                                         Bit 7 controls the initial value of the regulator output,
+                                                         0 for 0.9V and 1 for 0.925V.
+                                                         Bits 6:5 are connected to the loop filter, to reduce
+                                                         its corner frequency (for testing purposes).
+                                                         This parameter is for debugging purposes and should not
+                                                         be written in normal operation. */
+	uint64_t pcs_sds_rx_ldll_swsel        : 4;  /**< DMON control, selects which signal is passed to the output
+                                                         of DMON:
+                                                         0x8 = vdda_int
+                                                         0x4 = pi clock (output of the PI)
+                                                         0x2 = dllout[1] (second output clock phase, out of 4 phases,
+                                                               of the Lane DLL)
+                                                         0x1 = dllout[0] (first output clock phase, out of 4 phases,
+                                                               of the Lane DLL).  Ensure that
+                                                               GSER()_SLICE_RX_SDLL_CTRL[PCS_SDS_RX_SDLL_SWSEL]=0x0 during
+                                                               this test.
+                                                         This parameter is for debugging purposes and should not
+                                                         be written in normal operation. */
+	uint64_t reserved_0_0                 : 1;
+#else
+	uint64_t reserved_0_0                 : 1;
+	uint64_t pcs_sds_rx_ldll_swsel        : 4;
+	uint64_t pcs_sds_rx_ldll_tune         : 3;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_gserx_slicex_rx_ldll_ctrl_s cn73xx;
+};
+typedef union cvmx_gserx_slicex_rx_ldll_ctrl cvmx_gserx_slicex_rx_ldll_ctrl_t;
+
+/**
  * cvmx_gser#_slice#_rx_sdll_ctrl
  *
  * These registers are for diagnostic use only.
@@ -9976,6 +10655,71 @@ union cvmx_gserx_slicex_rx_sdll_ctrl {
 typedef union cvmx_gserx_slicex_rx_sdll_ctrl cvmx_gserx_slicex_rx_sdll_ctrl_t;
 
 /**
+ * cvmx_gser#_slice#_sgmii_mode
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ *
+ * Slice 1 does not exist on GSER4, GSER5, or GSER6.
+ */
+union cvmx_gserx_slicex_sgmii_mode {
+	uint64_t u64;
+	struct cvmx_gserx_slicex_sgmii_mode_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t slice_spare_1_0              : 2;  /**< Controls enable of pcs_sds_rx_div33 for lane 0 and 1 in the slice:
+                                                         Bit 13 controls enable for lane 0.
+                                                         Bit 14 controls enable for lane 1. */
+	uint64_t rx_ldll_isel                 : 2;  /**< Controls charge pump current for lane DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_sdll_isel                 : 2;  /**< Controls charge pump current for slice DLL:
+                                                         0x0 = 500 uA.
+                                                         0x1 = 1000 uA.
+                                                         0x2 = 250 uA.
+                                                         0x3 = 330 uA. */
+	uint64_t rx_pi_bwsel                  : 3;  /**< Controls PI different data rates:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x6 = 4 GHz.
+                                                         0x7 = 5.15625 GHz.
+                                                         All other values in this field are reserved. */
+	uint64_t rx_ldll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved. */
+	uint64_t rx_sdll_bwsel                : 3;  /**< Controls capacitors in delay line for different data rates; should be set
+                                                         based on the PLL clock frequency as follows:
+                                                         0x0 = 2.5 GHz.
+                                                         0x1 = 3.125 GHz.
+                                                         0x3 = 4 GHz.
+                                                         0x5 = 5.15625 GHz.
+                                                         0x6 = 5.65 GHz.
+                                                         0x7 = 6.25 GHz.
+                                                         All other values in this field are reserved. */
+#else
+	uint64_t rx_sdll_bwsel                : 3;
+	uint64_t rx_ldll_bwsel                : 3;
+	uint64_t rx_pi_bwsel                  : 3;
+	uint64_t rx_sdll_isel                 : 2;
+	uint64_t rx_ldll_isel                 : 2;
+	uint64_t slice_spare_1_0              : 2;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_slicex_sgmii_mode_s cn73xx;
+};
+typedef union cvmx_gserx_slicex_sgmii_mode cvmx_gserx_slicex_sgmii_mode_t;
+
+/**
  * cvmx_gser#_slice_cfg
  *
  * These registers are for diagnostic use only.
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-util.h b/arch/mips/include/asm/octeon/cvmx-helper-util.h
index d9d005a..93d191f 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-util.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-util.h
@@ -42,7 +42,7 @@
  *
  * Small helper utilities.
  *
- * <hr>$Revision: 153454 $<hr>
+ * <hr>$Revision: 160838 $<hr>
  */
 
 #ifndef __CVMX_HELPER_UTIL_H__
@@ -67,6 +67,7 @@ typedef char cvmx_bpid_t;
 
 /* Maximum range for normalized (a.k.a. IPD) port numbers (12-bit field) */
 #define	CVMX_PKO3_IPD_NUM_MAX	0x1000	//FIXME- take it from someplace else ?
+#define	CVMX_PKO3_DQ_NUM_MAX	 0x400	// 78xx has 1024 queues
 
 #define CVMX_PKO3_IPD_PORT_NULL (CVMX_PKO3_IPD_NUM_MAX-1)
 #define CVMX_PKO3_IPD_PORT_LOOP 0
@@ -90,6 +91,25 @@ static inline int cvmx_helper_node_to_ipd_port(int node, int index)
 	return (node << 12) + index;
 }
 
+struct cvmx_xdq {
+	int node;
+	int queue;
+};
+typedef struct cvmx_xdq cvmx_xdq_t;
+
+static inline struct cvmx_xdq cvmx_helper_queue_to_xdq(int queue)
+{
+	struct cvmx_xdq r;
+	r.queue = queue & (CVMX_PKO3_DQ_NUM_MAX - 1);
+	r.node = (queue >> 10) & CVMX_NODE_MASK;
+	return r;
+}
+
+static inline int cvmx_helper_node_to_dq(int node, int queue)
+{
+	return (node << 10) + queue;
+}
+
 struct cvmx_xiface {
 	int node;
 	int interface;
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c.h b/arch/mips/include/asm/octeon/cvmx-l2c.h
index 3eb9962..4cddca0 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c.h
@@ -43,7 +43,7 @@
  * Interface to the Level 2 Cache (L2C) control, measurement, and debugging
  * facilities.
  *
- * <hr>$Revision: 154261 $<hr>
+ * <hr>$Revision: 158623 $<hr>
  *
  */
 
@@ -437,12 +437,13 @@ uint64_t cvmx_l2c_tqdl2d_to_index_7xxx(int node, int tad);
  *
  * @param	node	CPU node number
  * @param	tad	TAD interface
+ * @param	remote	true for remote tag index (78XX only)
  *
  * @return	index address to pass to the LTGL2I cache operation (3)
  *
  * TODO: This code needs to be corrected or validated.
  */
-uint64_t cvmx_l2c_ttgx_to_index_7xxx(int node, int tad);
+uint64_t cvmx_l2c_ttgx_to_index_7xxx(int node, int tad, bool remote);
 
 /**
  * Returns the L2 tag that will be used for the given physical address
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index bee83ad..cf42752 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -13972,7 +13972,60 @@ union cvmx_pcieepx_cfg554 {
 	uint32_t reserved_27_31               : 5;
 #endif
 	} s;
-	struct cvmx_pcieepx_cfg554_s          cn73xx;
+	struct cvmx_pcieepx_cfg554_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_25_31               : 7;
+	uint32_t iif                          : 1;  /**< Include initial FOM. Include, or not, the FOM feedback from the initial preset evaluation
+                                                         performed in the EQ master, when finding the highest FOM among all preset evaluations. */
+	uint32_t prv                          : 16; /**< Preset request vector. Requesting of presets during the initial part of the EQ master
+                                                         phase. Encoding scheme as follows:
+                                                         Bit [15:0] = 0x0: No preset is requested and evaluated in the EQ master phase.
+                                                         Bit [i] = 1: Preset=i is requested and evaluated in the EQ master phase.
+                                                         _ 0b0000000000000000 = No preset req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxxxx1 = Preset 0 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxxx1x = Preset 1 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxx1xx = Preset 2 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxx1xxx = Preset 3 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxx1xxxx = Preset 4 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxx1xxxxx = Preset 5 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxx1xxxxxx = Preset 6 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxx1xxxxxxx = Preset 7 req/evaluated in EQ master phase.
+                                                         _ 0b00000xx1xxxxxxxx = Preset 8 req/evaluated in EQ master phase.
+                                                         _ 0b00000x1xxxxxxxxx = Preset 9 req/evaluated in EQ master phase.
+                                                         _ 0b000001xxxxxxxxxx = Preset 10 req/evaluated in EQ master phase.
+                                                         _ All other encodings = Reserved. */
+	uint32_t reserved_6_7                 : 2;
+	uint32_t p23td                        : 1;  /**< Phase2_3 2 ms timeout disable. Determine behavior in Phase2 for USP (Phase3 if DSP) when
+                                                         the PHY does not respond within 2 ms to the assertion of RxEqEval:
+                                                         0 = Abort the current evaluation; stop any attempt to modify the remote transmitter
+                                                         settings. Phase2 will be terminated by the 24 ms timeout.
+                                                         1 = Ignore the 2 ms timeout and continue as normal. This is used to support PHYs that
+                                                         require more than 2 ms to respond to the assertion of RxEqEval. */
+	uint32_t bt                           : 1;  /**< Behavior after 24 ms timeout (when optimal settings are not found).
+                                                         For a USP: determine the next LTSSM state from Phase2:
+                                                         0 = Recovery.Speed.
+                                                         1 = Recovry.Equalization.Phase3.
+                                                         For a DSP: determine the next LTSSM state from Phase3:
+                                                         0 = Recovery.Speed.
+                                                         1 = Recovry.Equalization.RcrLock.
+                                                         When optimal settings are not found:
+                                                         * Equalization phase 3 successful status bit is not set in the link status register.
+                                                         * Equalization phase 3 complete status bit is set in the link status register. */
+	uint32_t fm                           : 4;  /**< Feedback mode.
+                                                         0 = Direction of change (not supported).
+                                                         1 = Figure of merit.
+                                                         2-15 = Reserved. */
+#else
+	uint32_t fm                           : 4;
+	uint32_t bt                           : 1;
+	uint32_t p23td                        : 1;
+	uint32_t reserved_6_7                 : 2;
+	uint32_t prv                          : 16;
+	uint32_t iif                          : 1;
+	uint32_t reserved_25_31               : 7;
+#endif
+	} cn73xx;
+
 	struct cvmx_pcieepx_cfg554_s          cn78xx;
 	struct cvmx_pcieepx_cfg554_s          cn78xxp2;
 	struct cvmx_pcieepx_cfg554_s          cnf75xx;
diff --git a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
index c8b23c9..0773922 100644
--- a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
@@ -11112,7 +11112,60 @@ union cvmx_pciercx_cfg554 {
 	uint32_t reserved_27_31               : 5;
 #endif
 	} s;
-	struct cvmx_pciercx_cfg554_s          cn73xx;
+	
+	struct cvmx_pciercx_cfg554_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_25_31               : 7;
+	uint32_t iif                          : 1;  /**< Include initial FOM. Include, or not, the FOM feedback from the initial preset evaluation
+                                                         performed in the EQ master, when finding the highest FOM among all preset evaluations. */
+	uint32_t prv                          : 16; /**< Preset request vector. Requesting of presets during the initial part of the EQ master
+                                                         phase. Encoding scheme as follows:
+                                                         Bit [15:0] = 0x0: No preset is requested and evaluated in the EQ master phase.
+                                                         Bit [i] = 1: Preset=i is requested and evaluated in the EQ master phase.
+                                                         _ 0b0000000000000000 = No preset req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxxxx1 = Preset 0 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxxx1x = Preset 1 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxx1xx = Preset 2 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxx1xxx = Preset 3 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxx1xxxx = Preset 4 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxx1xxxxx = Preset 5 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxx1xxxxxx = Preset 6 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxx1xxxxxxx = Preset 7 req/evaluated in EQ master phase.
+                                                         _ 0b00000xx1xxxxxxxx = Preset 8 req/evaluated in EQ master phase.
+                                                         _ 0b00000x1xxxxxxxxx = Preset 9 req/evaluated in EQ master phase.
+                                                         _ 0b000001xxxxxxxxxx = Preset 10 req/evaluated in EQ master phase.
+                                                         _ All other encodings = Reserved. */
+	uint32_t reserved_6_7                 : 2;
+	uint32_t p23td                        : 1;  /**< Phase2_3 2 ms timeout disable. Determine behavior in Phase2 for USP (Phase3 if DSP) when
+                                                         the PHY does not respond within 2 ms to the assertion of RxEqEval:
+                                                         0 = Abort the current evaluation; stop any attempt to modify the remote transmitter
+                                                         settings. Phase2 will be terminated by the 24 ms timeout.
+                                                         1 = Ignore the 2 ms timeout and continue as normal. This is used to support PHYs that
+                                                         require more than 2 ms to respond to the assertion of RxEqEval. */
+	uint32_t bt                           : 1;  /**< Behavior after 24 ms timeout (when optimal settings are not found).
+                                                         For a USP: determine the next LTSSM state from Phase2:
+                                                         0 = Recovery.Speed.
+                                                         1 = Recovry.Equalization.Phase3.
+                                                         For a DSP: determine the next LTSSM state from Phase3:
+                                                         0 = Recovery.Speed.
+                                                         1 = Recovry.Equalization.RcrLock.
+                                                         When optimal settings are not found:
+                                                         * Equalization phase 3 successful status bit is not set in the link status register.
+                                                         * Equalization phase 3 complete status bit is set in the link status register. */
+	uint32_t fm                           : 4;  /**< Feedback mode.
+                                                         0 = Direction of change (not supported).
+                                                         1 = Figure of merit.
+                                                         2-15 = Reserved. */
+#else
+	uint32_t fm                           : 4;
+	uint32_t bt                           : 1;
+	uint32_t p23td                        : 1;
+	uint32_t reserved_6_7                 : 2;
+	uint32_t prv                          : 16;
+	uint32_t iif                          : 1;
+	uint32_t reserved_25_31               : 7;
+#endif
+	} cn73xx;
 	struct cvmx_pciercx_cfg554_s          cn78xx;
 	struct cvmx_pciercx_cfg554_s          cn78xxp2;
 	struct cvmx_pciercx_cfg554_s          cnf75xx;
diff --git a/drivers/net/ethernet/octeon/octeon3-ethernet.c b/drivers/net/ethernet/octeon/octeon3-ethernet.c
index ebc93ba..f26943a 100644
--- a/drivers/net/ethernet/octeon/octeon3-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon3-ethernet.c
@@ -303,7 +303,7 @@ static int wait_pko_response;
 module_param(wait_pko_response, int, 0644);
 MODULE_PARM_DESC(use_tx_queues, "Wait for response after each pko command.");
 
-static int num_packet_buffers = 4096;
+static int num_packet_buffers = 768;
 module_param(num_packet_buffers, int, S_IRUGO);
 MODULE_PARM_DESC(num_packet_buffers, "Number of packet buffers to allocate per port.");
 
@@ -1532,7 +1532,7 @@ static int octeon3_eth_common_ndo_init(struct net_device	*netdev,
 	int ipd_port, node_dq;
 	int base_rx_grp;
 	int first_skip, later_skip;
-	struct cvmx_xport xdq;
+	struct cvmx_xdq xdq;
 	int r, i;
 	int aura;
 
@@ -1572,9 +1572,9 @@ static int octeon3_eth_common_ndo_init(struct net_device	*netdev,
 		return -ENODEV;
 
 	node_dq = cvmx_pko3_get_queue_base(ipd_port);
-	xdq = cvmx_helper_ipd_port_to_xport(node_dq);
+	xdq = cvmx_helper_queue_to_xdq(node_dq);
 
-	priv->pko_queue = xdq.port;
+	priv->pko_queue = xdq.queue;
 	octeon_fpa3_aura_init(priv->numa_node, oen->pki_packet_pool, -1, &aura,
 			      num_packet_buffers, num_packet_buffers * 2);
 	priv->pki_laura = aura;
@@ -1979,7 +1979,7 @@ static int octeon3_eth_ndo_start_xmit(struct sk_buff *skb, struct net_device *ne
 	void **work;
 	bool can_recycle_skb = false;
 	int gaura = 0;
-	void *buffers_needed = NULL;
+	atomic64_t *buffers_needed = NULL;
 	void **buf = NULL;
 	unsigned int mss;
 
@@ -2003,16 +2003,19 @@ static int octeon3_eth_ndo_start_xmit(struct sk_buff *skb, struct net_device *ne
 		buf = (void **)PTR_ALIGN(skb->head, 128);
 		magic = (uint64_t)buf[SKB_AURA_OFFSET];
 		if (likely(buf[SKB_PTR_OFFSET] == skb) &&
-		    likely((magic & 0xfffffffffffff000) == SKB_AURA_MAGIC)) {
+				likely((magic & 0xfffffffffffff000) == SKB_AURA_MAGIC)) {
 			int		node;
 			int		aura;
 
-			can_recycle_skb = true;
 			gaura = magic & 0xfff;
 			node = gaura >> 10;
 			aura = gaura & 0x3ff;
 			buffers_needed = aura2bufs_needed[node][aura];
-			buf[SKB_AURA_OFFSET] = NULL;
+			/* Only allow aura overfill of up to 5 extra buffers. */
+			if (atomic64_read(buffers_needed) > -5) {
+				can_recycle_skb = true;
+				buf[SKB_AURA_OFFSET] = NULL;
+			}
 		}
 	}
 
@@ -2190,15 +2193,11 @@ static int octeon3_eth_ndo_start_xmit(struct sk_buff *skb, struct net_device *ne
 	if (likely(can_recycle_skb)) {
 		cvmx_pko_send_free_t	send_free;
 
-		/* Subtract 1 from buffers_needed. */
-		send_mem.u64 = 0;
-		send_mem.s.subdc4 = CVMX_PKO_SENDSUBDC_MEM;
-		send_mem.s.dsz = MEMDSZ_B64;
-		send_mem.s.alg = MEMALG_SUB;
-		send_mem.s.offset = 1;
-		send_mem.s.addr = virt_to_phys(buffers_needed);
-		cvmx_scratch_write64(scr_off, send_mem.u64);
-		scr_off += sizeof(buf_ptr);
+		/* Account for the recycled buffer now, so any backlog
+		 * in the PKO doesn't inadvertently increase the total
+		 * number of buffers in flight for the input port.
+		 */
+		atomic64_dec(buffers_needed);
 
 		/* Free buffer when finished with the packet */
 		send_free.u64 = 0;
diff --git a/drivers/watchdog/octeon-wdt-main.c b/drivers/watchdog/octeon-wdt-main.c
index 2a442a3..8b83a6b 100644
--- a/drivers/watchdog/octeon-wdt-main.c
+++ b/drivers/watchdog/octeon-wdt-main.c
@@ -74,6 +74,7 @@
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-boot-vector.h>
 #include <asm/octeon/cvmx-ciu2-defs.h>
+#include <asm/octeon/cvmx-gserx-defs.h>
 
 /* Watchdog interrupt major block number (8 MSBs of intsn) */
 #define WD_BLOCK_NUMBER		0x01
@@ -281,6 +282,30 @@ void octeon_wdt_nmi_stage3(u64 reg[32])
 	}
 
 	octeon_wdt_write_string("*** Chip soft reset soon ***\r\n");
+	/*
+	 * G-30204: We must trigger a soft reset before watchdog
+	 * does an incomplete job of doing it.
+	 */
+	if (OCTEON_IS_OCTEON3() && !OCTEON_IS_MODEL(OCTEON_CN70XX)) {
+		u64 scr;
+		unsigned int node = cvmx_get_node_num();
+		unsigned int lcore = cvmx_get_local_core_num();
+		union cvmx_ciu_wdogx ciu_wdog;
+
+		/*
+		 * Wait for other cores to print out information, but
+		 * not too long.  Do the soft reset before watchdog
+		 * can trigger it.
+		 */
+		do {
+			ciu_wdog.u64 = cvmx_read_csr_node(node, CVMX_CIU_WDOGX(lcore));
+		} while (ciu_wdog.s.cnt > 0x10000);
+
+		scr = cvmx_read_csr_node(0, CVMX_GSERX_SCRATCH(0));
+		scr |= 1 << 11; /* Indicate watchdog in bit 11 */
+		cvmx_write_csr_node(0, CVMX_GSERX_SCRATCH(0), scr);
+		cvmx_write_csr_node(0, CVMX_RST_SOFT_RST, 1);
+	}
 }
 
 static int octeon_wdt_cpu_to_irq(int cpu)
@@ -644,7 +669,7 @@ static int __init octeon_wdt_init(void)
 
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
 		counter_shift = 9;
-	else if (octeon_has_feature(OCTEON_FEATURE_CIU3))
+	else if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		counter_shift = 10;
 	else
 		counter_shift = 8;
-- 
1.7.5.4

