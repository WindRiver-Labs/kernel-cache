From 62c1b318b93762655d407b5d5fd6eb40faf4381a Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Fri, 11 Jul 2014 14:39:04 -0700
Subject: [PATCH 615/974] netdev: octeon3-ethernet: Add workaround for 78xx
 pass 1.x bug PKO-20096.

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-pko3.c | 110 +++++++++++++++++++++++++-
 arch/mips/include/asm/octeon/cvmx-pko3.h      |  19 ++++-
 drivers/net/ethernet/octeon/octeon-bgx-port.c |  53 +++++++++++++
 3 files changed, 177 insertions(+), 5 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index f80a196..196e9be 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -870,15 +870,34 @@ int cvmx_pko3_interface_options(int xiface, int index,
 	unsigned fifo_num;
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 
+	if (debug)
+		cvmx_dprintf("%s: intf %u:%u/%u fcs=%d pad=%d\n",
+			__func__, xi.node, xi.interface, index,
+			fcs_enable, pad_enable);
+
 	mac_num = __cvmx_pko3_get_mac_num(xiface, index);
-	if(mac_num < 0)
+	if(mac_num < 0) {
+		cvmx_dprintf("ERROR: %s: invalid interface %u:%u/%u\n",
+			__func__, xi.node, xi.interface, index);
 		return -1;
+	}
 
 	pko_mac_cfg.u64 = cvmx_read_csr_node(xi.node, CVMX_PKO_MACX_CFG(mac_num));
 
 	/* If MAC is not assigned, return an error */
-	if (pko_mac_cfg.s.fifo_num == 0x1f)
+	if (pko_mac_cfg.s.fifo_num == 0x1f) {
+		cvmx_dprintf("ERROR: %s: unused interface %u:%u/%u\n",
+			__func__, xi.node, xi.interface, index);
 		return -1;
+	}
+
+	if (pko_mac_cfg.s.min_pad_ena == pad_enable &&
+	    pko_mac_cfg.s.fcs_ena == fcs_enable) {
+		if (debug)
+			cvmx_dprintf("%s: mac %#x unchanged\n",
+				__func__, mac_num);
+		return 0;
+	}
 
 	/* WORKAROUND: Pass1 won't allow change any bits unless FIFO_NUM=0x1f */
 	fifo_num = pko_mac_cfg.s.fifo_num;
@@ -957,6 +976,93 @@ int cvmx_pko3_internal_buffer_count(unsigned node)
 	return avail2;
 }
 
+/**
+ * @INTERNAL
+ *
+ * Get actual PKO FIFO buffer size for a given port
+ *
+ * Since the FIFOs are allocated dynamically based on supply/demand
+ * heuristics, it may be useful in some instances to know the
+ * actual FIFO size allocated to any specific port at run time.
+ *
+ * @param xiface global interface number
+ * @param index port index on interface
+ * @return Returns the per-port FIFO size in bytes, or 0 if the port
+ * has not been configured, or a negative number if the interface and
+ * index numbers are not valid.
+ */
+int
+cvmx_pko3_port_fifo_size(unsigned int xiface, unsigned index)
+{
+	unsigned node;
+	unsigned mac_num;
+	unsigned fifo_grp, fifo_off;
+	cvmx_pko_macx_cfg_t pko_mac_cfg;
+	cvmx_pko_ptgfx_cfg_t pko_ptgfx_cfg;
+        cvmx_xiface_t xi = cvmx_helper_xiface_to_node_interface(xiface);
+	int ret;
+
+	node = xi.node;
+	ret = __cvmx_pko3_get_mac_num(xiface, index);
+	if( ret < 0)
+		return ret;
+
+	if (debug)
+		cvmx_dprintf("%s: iface=%u:%u/%u mac %d\n",
+			__func__, xi.node, xi.interface, index, ret);
+
+	mac_num = ret;
+
+	/* Check for the special value on onused MACs */
+	if (mac_num == 0x1f)
+		return 0;
+
+	pko_mac_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_MACX_CFG(mac_num));
+
+	fifo_grp = pko_mac_cfg.s.fifo_num >> 2;
+	fifo_off = pko_mac_cfg.s.fifo_num & 0x3;
+	pko_ptgfx_cfg.u64 = cvmx_read_csr_node(node,
+		CVMX_PKO_PTGFX_CFG(fifo_grp));
+
+	ret = (2 <<10) + (1 << 9);	/* set 2.5KBytes base FIFO size */
+
+	switch (pko_ptgfx_cfg.s.size) {
+		case 0:
+			/* 2.5l, 2.5k, 2.5k, 2.5k */
+			break;
+		case 1:
+			/* 5.0k, 0.0k, 2.5k, 2.5k */
+			if (fifo_off == 1)
+				ret = 0;
+			if (fifo_off == 0)
+				ret *= 2;
+			break;
+		case 2:
+			/* 2.5k, 2.5k, 5.0k, 0.0k */
+			if (fifo_off == 3)
+				ret = 0;
+			if (fifo_off == 2)
+				ret *= 2;
+			break;
+		case 3:
+			/* 5k, 0, 5k, 0 */
+			if ((fifo_off & 1) != 0)
+				ret = 0;
+			ret *= 2;
+			break;
+		case 4:
+			/* 10k, 0, 0, 0 */
+			if (fifo_off != 0)
+				ret = 0;
+			ret *= 4;
+			break;
+		default:
+			ret = -1;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(cvmx_pko3_port_fifo_size);
+
 /******************************************************************************
 *
 * New PKO3 API - Experimental
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3.h b/arch/mips/include/asm/octeon/cvmx-pko3.h
index cff2e6a..d1362051e 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3.h
@@ -386,7 +386,7 @@ static inline int cvmx_pko_setup_channel_credit_level(int node, int level)
 /**
  * @INTERNAL
  *
- * Get address for LMTDMA/LMTST data buffer
+ * Get scratch offset for LMTDMA/LMTST data buffer
  *
  */
 static inline unsigned
@@ -395,11 +395,23 @@ cvmx_pko3_lmtdma_scr_base(void)
 	return CVMX_PKO_LMTLINE * CVMX_CACHE_LINE_SIZE;
 }
 
+/**
+ * @INTERNAL
+ *
+ * Get address for LMTDMA/LMTST data buffer
+ *
+ */
+static inline uint64_t *
+cvmx_pko3_cvmseg_addr(void)
+{
+	const unsigned scr = CVMX_PKO_LMTLINE * CVMX_CACHE_LINE_SIZE;
+	return (uint64_t *) (CVMX_SCRATCH_BASE + scr);
+}
+
 /*
  * @INTERNAL  
  * Deliver PKO SEND commands via CVMSEG LM and LMTDMA/LMTTST.
- * The command should be already stored in the address
- * returned by 'cvmx_pko3_lmtdma_bufaddr()'.
+ * The command should be already stored in the CVMSEG address.
  *
  * @param node is the destination node
  * @param dq is the destonation descriptor queue.
@@ -792,6 +804,7 @@ extern int cvmx_pko3_interface_options(int xiface, int index,
  */
 extern void cvmx_pko3_dq_options(unsigned node, unsigned dq, bool min_pad);
 
+extern int cvmx_pko3_port_fifo_size(unsigned int xiface, unsigned index);
 
 /* Packet descriptor - PKO3 command buffer + internal state */
 typedef struct cvmx_pko3_pdesc_s {
diff --git a/drivers/net/ethernet/octeon/octeon-bgx-port.c b/drivers/net/ethernet/octeon/octeon-bgx-port.c
index 0ee7c45..3273f69 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-port.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-port.c
@@ -34,11 +34,13 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/list.h>
+#include <linux/if_vlan.h>
 
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-helper-util.h>
 #include <asm/octeon/cvmx-helper-cfg.h>
 #include <asm/octeon/cvmx-bgxx-defs.h>
+#include <asm/octeon/cvmx-pko3.h>
 
 #include "octeon-bgx.h"
 
@@ -290,6 +292,46 @@ int bgx_port_disable(struct net_device *netdev)
 }
 EXPORT_SYMBOL(bgx_port_disable);
 
+static int get_max_78xx_pass1_x_mtu(int xiface, int index)
+{
+	int	fifo_size;
+	int	max_mtu = 1500;
+
+	/* Due to errata PKO-20096, the mtu must be limited.
+	 * PKO-20096 causes PKO to lock up when calculating the L4
+	 * checksum for large packets. How large the packets can be
+	 * depends on the amount of pko fifo assigned to the port.
+	 *
+	 *   FIFO size                Max frame size
+	 *	2.5 KB				1920
+	 *	5.0 KB				4480
+	 *     10.0 KB				9600
+	 *
+	 * The maximum mtu is set to the largest frame size minus the
+	 * l2 header.
+	 */
+	fifo_size = cvmx_pko3_port_fifo_size(xiface, index);
+
+	switch (fifo_size) {
+	case 2560:
+		max_mtu = 1920 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
+		break;
+
+	case 5120:
+		max_mtu = 4480 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
+		break;
+
+	case 10240:
+		max_mtu = 9600 - ETH_HLEN - ETH_FCS_LEN - (2 * VLAN_HLEN);
+		break;
+
+	default:
+		break;
+	}
+
+	return max_mtu;
+}
+
 int bgx_port_change_mtu(struct net_device *netdev, int new_mtu)
 {
 	union cvmx_bgxx_cmrx_config cfg;
@@ -299,6 +341,17 @@ int bgx_port_change_mtu(struct net_device *netdev, int new_mtu)
 	if (new_mtu < 60 || new_mtu > 65392)
 		return -EINVAL;
 
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+		int	max_mtu;
+
+		max_mtu = get_max_78xx_pass1_x_mtu(priv->xiface, priv->index);
+		if (new_mtu > max_mtu) {
+			new_mtu = max_mtu;
+			netdev_warn(netdev, "Maximum MTU supported is %d",
+				    max_mtu);
+		}
+	}
+
 	netdev->mtu = new_mtu;
 
 	max_frame = round_up(new_mtu + ETH_HLEN + ETH_FCS_LEN, 8);
-- 
2.6.2

