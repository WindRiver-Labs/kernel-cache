From c84fc46d1cfc4508d018c22c6782e27f2e6f157f Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@cavium.com>
Date: Mon, 2 Nov 2015 10:47:01 -0800
Subject: [PATCH 161/184] mips: i2c-octeon: bump version to 2.6, preen comments

Comment some of the more obscure interface bits & functions.
Rename _unblock() to bitbang_unblock(), to distinguish from the other
bus/interface reset methods employed in _start().

Bumped DRV_VERSION to 2.6

Signed-off-by: Peter Swain <pswain@cavium.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/i2c/busses/i2c-octeon.c | 30 +++++++++++++++++-------------
 1 file changed, 17 insertions(+), 13 deletions(-)

diff --git a/drivers/i2c/busses/i2c-octeon.c b/drivers/i2c/busses/i2c-octeon.c
index a0919b3..d52b000 100644
--- a/drivers/i2c/busses/i2c-octeon.c
+++ b/drivers/i2c/busses/i2c-octeon.c
@@ -27,8 +27,7 @@
 
 #define DRV_NAME "i2c-octeon"
 
-/* The previous out-of-tree version was implicitly version 1.0. */
-#define DRV_VERSION	"2.5"
+#define DRV_VERSION	"2.6"
 
 /* register offsets */
 #define SW_TWSI		0x00
@@ -57,9 +56,9 @@
 /* Controller command and status bits */
 #define TWSI_CTL_CE   0x80	/* HighLevelController enable */
 #define TWSI_CTL_ENAB 0x40	/* bus enable */
-#define TWSI_CTL_STA  0x20	/* master-mode start */
-#define TWSI_CTL_STP  0x10	/* master-mode stop */
-#define TWSI_CTL_IFLG 0x08	/* bus idle */
+#define TWSI_CTL_STA  0x20	/* master-mode start, hw clears when done */
+#define TWSI_CTL_STP  0x10	/* master-mode stop, hw clears when done */
+#define TWSI_CTL_IFLG 0x08	/* hw event, sw writes 0 to ack */
 #define TWSI_CTL_AAK  0x04	/* Assert ACK */
 
 /* Some status values - named with value, as HRM speaks of values */
@@ -207,7 +206,7 @@ static inline u8 octeon_i2c_read_sw(struct octeon_i2c *i2c, u64 eop_reg)
  * @i2c: The struct octeon_i2c.
  * @data: Value to be written.
  */
-static void octeon_i2c_write_int(struct octeon_i2c *i2c, u64 data)
+static inline void octeon_i2c_write_int(struct octeon_i2c *i2c, u64 data)
 {
 	writeqflush(data, i2c->twsi_base + TWSI_INT);
 }
@@ -294,14 +293,14 @@ static void octeon_i2c_hlc_int_disable78(struct octeon_i2c *i2c)
 }
 
 /**
- * octeon_i2c_unblock - unblock the bus.
+ * bitbang_unblock - unblock the bus.
  * @i2c: The struct octeon_i2c.
  *
  * If there was a reset while a device was driving 0 to bus,
  * bus is blocked. We toggle it free manually by some clock
  * cycles and send a stop.
  */
-static void octeon_i2c_unblock(struct octeon_i2c *i2c)
+static void bitbang_unblock(struct octeon_i2c *i2c)
 {
 	int i;
 
@@ -613,7 +612,7 @@ unstick:
 				 * May be a client is holding SDA low?
 				 * Let's try to free it.
 				 */
-				octeon_i2c_unblock(i2c);
+				bitbang_unblock(i2c);
 				break;
 
 			case 2:
@@ -640,7 +639,7 @@ static void octeon_i2c_stop(struct octeon_i2c *i2c)
 }
 
 /**
- * octeon_i2c_write - send data to the bus.
+ * octeon_i2c_write - send data to the bus via low-level controller.
  * @i2c: The struct octeon_i2c.
  * @target: Target address.
  * @data: Pointer to the data to be sent.
@@ -688,10 +687,10 @@ static int octeon_i2c_write(struct octeon_i2c *i2c, int target,
 }
 
 /**
- * octeon_i2c_read - receive data from the bus.
+ * octeon_i2c_read - receive data from the bus via low-level controller.
  * @i2c: The struct octeon_i2c.
  * @target: Target address.
- * @data: Pointer to the location to store the datae .
+ * @data: Pointer to the location to store the data.
  * @length: Length of the data.
  * @last: is last msg in combined operation?
  *
@@ -728,6 +727,7 @@ static int octeon_i2c_read(struct octeon_i2c *i2c, int target,
 					SW_TWSI_EOP_TWSI_DATA);
 		}
 
+		/* NAK last recv'd byte, as a no-more-please */
 		if (last && i == length - 1)
 			ctl &= ~TWSI_CTL_AAK;
 
@@ -741,7 +741,7 @@ static int octeon_i2c_read(struct octeon_i2c *i2c, int target,
 	return 0;
 }
 
-static bool octeon_i2c_hlc_test_ready(struct octeon_i2c *i2c)
+static inline bool octeon_i2c_hlc_test_ready(struct octeon_i2c *i2c)
 {
 	u64 v = __raw_readq(i2c->twsi_base + SW_TWSI);
 	return (v & SW_TWSI_V) == 0;
@@ -810,6 +810,7 @@ static int octeon_i2c_hlc_wait(struct octeon_i2c *i2c)
 	return 0;
 }
 
+/* high-level-controller pure read of up to 8 bytes */
 static int octeon_i2c_simple_read(struct octeon_i2c *i2c, struct i2c_msg *msgs)
 {
 	u64 cmd;
@@ -854,6 +855,7 @@ err:
 	return ret;
 }
 
+/* high-level-controller pure write of up to 8 bytes */
 static int octeon_i2c_simple_write(struct octeon_i2c *i2c, struct i2c_msg *msgs)
 {
 	u64 cmd;
@@ -904,6 +906,7 @@ err:
 	return ret;
 }
 
+/* high-level-controller composite write+read, msg0=addr, msg1=data */
 static int octeon_i2c_ia_read(struct octeon_i2c *i2c, struct i2c_msg *msgs)
 {
 	u64 cmd;
@@ -958,6 +961,7 @@ err:
 	return ret;
 }
 
+/* high-level-controller composite write+write, m[0]len<=2, m[1]len<=8 */
 static int octeon_i2c_ia_write(struct octeon_i2c *i2c, struct i2c_msg *msgs)
 {
 	u64 cmd;
-- 
1.9.1

