From 1b34fb775b51261dfbc7e4ad0bd76517b850eeda Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@cavium.com>
Date: Mon, 2 Nov 2015 10:47:01 -0800
Subject: [PATCH 959/974] mips: i2c-octeon: bump version to 2.6, preen comments

Comment some of the more obscure interface bits & functions.
Rename _unblock() to bitbang_unblock(), to distinguish from the other
bus/interface reset methods employed in _start().

Bumped DRV_VERSION to 2.6

Signed-off-by: Peter Swain <pswain@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/i2c/busses/i2c-octeon.c | 30 +++++++++++++++++-------------
 1 file changed, 17 insertions(+), 13 deletions(-)

diff --git a/drivers/i2c/busses/i2c-octeon.c b/drivers/i2c/busses/i2c-octeon.c
index 43a7789..fe93a7f 100644
--- a/drivers/i2c/busses/i2c-octeon.c
+++ b/drivers/i2c/busses/i2c-octeon.c
@@ -28,8 +28,7 @@
 
 #define DRV_NAME "i2c-octeon"
 
-/* The previous out-of-tree version was implicitly version 1.0. */
-#define DRV_VERSION	"2.5"
+#define DRV_VERSION	"2.6"
 
 /* register offsets */
 #define SW_TWSI		0x00
@@ -58,9 +57,9 @@
 /* Controller command and status bits */
 #define TWSI_CTL_CE   0x80	/* HighLevelController enable */
 #define TWSI_CTL_ENAB 0x40	/* bus enable */
-#define TWSI_CTL_STA  0x20	/* master-mode start */
-#define TWSI_CTL_STP  0x10	/* master-mode stop */
-#define TWSI_CTL_IFLG 0x08	/* bus idle */
+#define TWSI_CTL_STA  0x20	/* master-mode start, hw clears when done */
+#define TWSI_CTL_STP  0x10	/* master-mode stop, hw clears when done */
+#define TWSI_CTL_IFLG 0x08	/* hw event, sw writes 0 to ack */
 #define TWSI_CTL_AAK  0x04	/* Assert ACK */
 
 /* Some status values - named with value, as HRM speaks of values */
@@ -208,7 +207,7 @@ static inline u8 octeon_i2c_read_sw(struct octeon_i2c *i2c, u64 eop_reg)
  * @i2c: The struct octeon_i2c.
  * @data: Value to be written.
  */
-static void octeon_i2c_write_int(struct octeon_i2c *i2c, u64 data)
+static inline void octeon_i2c_write_int(struct octeon_i2c *i2c, u64 data)
 {
 	writeqflush(data, i2c->twsi_base + TWSI_INT);
 }
@@ -295,14 +294,14 @@ static void octeon_i2c_hlc_int_disable78(struct octeon_i2c *i2c)
 }
 
 /**
- * octeon_i2c_unblock - unblock the bus.
+ * bitbang_unblock - unblock the bus.
  * @i2c: The struct octeon_i2c.
  *
  * If there was a reset while a device was driving 0 to bus,
  * bus is blocked. We toggle it free manually by some clock
  * cycles and send a stop.
  */
-static void octeon_i2c_unblock(struct octeon_i2c *i2c)
+static void bitbang_unblock(struct octeon_i2c *i2c)
 {
 	int i;
 
@@ -614,7 +613,7 @@ unstick:
 				 * May be a client is holding SDA low?
 				 * Let's try to free it.
 				 */
-				octeon_i2c_unblock(i2c);
+				bitbang_unblock(i2c);
 				break;
 
 			case 2:
@@ -641,7 +640,7 @@ static void octeon_i2c_stop(struct octeon_i2c *i2c)
 }
 
 /**
- * octeon_i2c_write - send data to the bus.
+ * octeon_i2c_write - send data to the bus via low-level controller.
  * @i2c: The struct octeon_i2c.
  * @target: Target address.
  * @data: Pointer to the data to be sent.
@@ -689,10 +688,10 @@ static int octeon_i2c_write(struct octeon_i2c *i2c, int target,
 }
 
 /**
- * octeon_i2c_read - receive data from the bus.
+ * octeon_i2c_read - receive data from the bus via low-level controller.
  * @i2c: The struct octeon_i2c.
  * @target: Target address.
- * @data: Pointer to the location to store the datae .
+ * @data: Pointer to the location to store the data.
  * @length: Length of the data.
  * @last: is last msg in combined operation?
  *
@@ -729,6 +728,7 @@ static int octeon_i2c_read(struct octeon_i2c *i2c, int target,
 					SW_TWSI_EOP_TWSI_DATA);
 		}
 
+		/* NAK last recv'd byte, as a no-more-please */
 		if (last && i == length - 1)
 			ctl &= ~TWSI_CTL_AAK;
 
@@ -742,7 +742,7 @@ static int octeon_i2c_read(struct octeon_i2c *i2c, int target,
 	return 0;
 }
 
-static bool octeon_i2c_hlc_test_ready(struct octeon_i2c *i2c)
+static inline bool octeon_i2c_hlc_test_ready(struct octeon_i2c *i2c)
 {
 	u64 v = __raw_readq(i2c->twsi_base + SW_TWSI);
 	return (v & SW_TWSI_V) == 0;
@@ -811,6 +811,7 @@ static int octeon_i2c_hlc_wait(struct octeon_i2c *i2c)
 	return 0;
 }
 
+/* high-level-controller pure read of up to 8 bytes */
 static int octeon_i2c_simple_read(struct octeon_i2c *i2c, struct i2c_msg *msgs)
 {
 	u64 cmd;
@@ -855,6 +856,7 @@ err:
 	return ret;
 }
 
+/* high-level-controller pure write of up to 8 bytes */
 static int octeon_i2c_simple_write(struct octeon_i2c *i2c, struct i2c_msg *msgs)
 {
 	u64 cmd;
@@ -905,6 +907,7 @@ err:
 	return ret;
 }
 
+/* high-level-controller composite write+read, msg0=addr, msg1=data */
 static int octeon_i2c_ia_read(struct octeon_i2c *i2c, struct i2c_msg *msgs)
 {
 	u64 cmd;
@@ -959,6 +962,7 @@ err:
 	return ret;
 }
 
+/* high-level-controller composite write+write, m[0]len<=2, m[1]len<=8 */
 static int octeon_i2c_ia_write(struct octeon_i2c *i2c, struct i2c_msg *msgs)
 {
 	u64 cmd;
-- 
2.6.2

