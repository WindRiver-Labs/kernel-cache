From d83a9e1d3a5a6b94cacd6598161fa98e51906839 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 10 Nov 2014 17:34:35 -0800
Subject: [PATCH 018/184] MIPS: Supply OCTEON-II specific read/write lock
 implementation.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: c6907be6bddb65574b2ce85da5bf55f345e27fa4
Description:

LL/SC on many cores really slows things down.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/spinlock.h | 157 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 157 insertions(+)

diff --git a/arch/mips/include/asm/spinlock.h b/arch/mips/include/asm/spinlock.h
index 1fca2e0..415f7e5 100644
--- a/arch/mips/include/asm/spinlock.h
+++ b/arch/mips/include/asm/spinlock.h
@@ -208,8 +208,163 @@ static inline unsigned int arch_spin_trylock(arch_spinlock_t *lock)
  * needs to get a irq-safe write-lock, but readers can get non-irqsafe
  * read-locks.
  */
+#ifdef CONFIG_CAVIUM_OCTEON2
 
 /*
+ * With OCTEON atomics, read/write locks are like this:
+ *
+ * Read lock: Atomically increment the lock variable.  If the old
+ * value didn't have any of bits 16..31 set, then the lock operation
+ * succeeded.  If the high order bits were set, then a writer is
+ * trying to enter, and we decrement the lock variable and wait until
+ * the high order bits are clear and try again.
+ *
+ * Write lock: Atomically add 0x10000 to the variable.  If the old
+ * value was zero, then the lock operation succeeded.  Otherwise, if
+ * bits 16.31 contain 1, we are the only writer waiting, so wait until
+ * the low order bits are all zero indicating the readers have all
+ * released the lock.  If more than one writer is indicated, undo the
+ * addition and wait until the lock variable becomes zero and try
+ * again.
+ *
+ * The unlock operations just apply the inverse atomic operation.
+ */
+
+#define arch_read_can_lock(rw)	(((rw)->lock & 0xffff0000) == 0)
+#define arch_write_can_lock(rw) (!(rw)->lock)
+
+static inline void arch_read_lock(arch_rwlock_t *rw)
+{
+	unsigned int tmp;
+	unsigned int mask = 0xffff0000;
+
+	__asm__ __volatile__(
+		".set	push				\n"
+		"	.set	noreorder		\n"
+		"1:	lai	%[tmp], (%[rw])		\n"
+		"	and	%[tmp], %[tmp], %[mask]	\n"
+		"	beqz	%[tmp], 2f		\n"
+		"	 nop				\n"
+		"	lad	%[tmp], (%[rw])		\n"
+		"3:	ll	%[tmp], 0(%[rw])	\n"
+		"	and	%[tmp], %[tmp], %[mask]	\n"
+		"	beqz	%[tmp], 1b		\n"
+		"	 nop				\n"
+		"	pause				\n"
+		"	b	3b			\n"
+		"	 nop				\n"
+		"2:					\n"
+		"	.set	pop"
+		: [tmp] "=&r" (tmp)
+		: [mask] "r" (mask), [rw] "r" (rw) : "memory");
+}
+
+static inline void arch_read_unlock(arch_rwlock_t *rw)
+{
+	int dec = -1;
+
+	__asm__ __volatile__(
+		"saa	%[dec], (%[rw])			\n"
+		"	pref	26, 0(%[rw]) #nudge	\n"
+		: : [dec] "r" (dec), [rw] "r" (rw) : "memory");
+}
+
+static inline void arch_write_lock(arch_rwlock_t *rw)
+{
+	unsigned int tmp;
+	unsigned int mask = 0xffff0000;
+	int inc = 0x10000;
+	int dec = -inc;
+
+	__asm__ __volatile__(
+		".set	push				\n"
+		"	.set	noreorder		\n"
+		"1:	laa	%[tmp], (%[rw]), %[inc]	\n"
+		"	beqz	%[tmp], 2f		\n"
+		"	 nop				\n"
+		"	and	%[tmp], %[tmp], %[mask]	\n"
+		"	bnez	%[tmp],4f		\n"
+		"	 nop				\n"
+		"5:	ll	%[tmp], 0(%[rw])	\n"
+		"	beq	%[tmp], %[inc], 2f	\n"
+		"	 nop				\n"
+		"	pause				\n"
+		"	b	5b			\n"
+		"	 nop				\n"
+		"4:	laa	%[tmp], (%[rw]), %[dec]	\n"
+		"3:	ll	%[tmp], 0(%[rw])	\n"
+		"	beqz	%[tmp], 1b		\n"
+		"	 nop				\n"
+		"	pause				\n"
+		"	b	3b			\n"
+		"	 nop				\n"
+		"2:					\n"
+		"	.set	pop"
+		: [tmp] "=&r" (tmp)
+		: [mask] "r" (mask), [inc] "r" (inc), [dec] "r" (dec), [rw] "r" (rw)
+		: "memory");
+}
+
+static inline void arch_write_unlock(arch_rwlock_t *rw)
+{
+	int dec = -0x10000;
+
+	smp_mb();
+	__asm__ __volatile__(
+		"saa	%[dec], (%[rw])			\n"
+		"	pref	26, 0(%[rw]) #nudge	\n"
+		: : [dec] "r" (dec), [rw] "r" (rw)  : "memory");
+}
+
+static inline int arch_read_trylock(arch_rwlock_t *rw)
+{
+	unsigned int tmp;
+	unsigned int mask = 0xffff0000;
+	int m1 = -1;
+	int ret;
+
+	__asm__ __volatile__(
+		".set	push				\n"
+		"	.set	noreorder		\n"
+		"1:	lai	%[tmp], (%[rw])		\n"
+		"	and	%[tmp], %[tmp], %[mask]	\n"
+		"	beqz	%[tmp], 2f		\n"
+		"	 li	%[ret], 1		\n"
+		"	saa	%[m1], (%[rw])		\n"
+		"	pref	26, 0(%[rw]) #nudge	\n"
+		"	li	%[ret], 0		\n"
+		"2:					\n"
+		"	.set	pop"
+		: [tmp] "=&r" (tmp), [ret] "=&r" (ret)
+		: [mask] "r" (mask), [m1] "r" (m1), [rw] "r" (rw) : "memory");
+	return ret;
+}
+
+static inline int arch_write_trylock(arch_rwlock_t *rw)
+{
+	unsigned int tmp;
+	int inc = 0x10000;
+	int dec = -inc;
+	int ret;
+
+	__asm__ __volatile__(
+		".set	push				\n"
+		"	.set	noreorder		\n"
+		"1:	laa	%[tmp], (%[rw]), %[inc]	\n"
+		"	beqz	%[tmp], 2f		\n"
+		"	 li	%[ret], 1		\n"
+		"	saa	%[dec], (%[rw])		\n"
+		"	pref	26, 0(%[rw]) #nudge	\n"
+		"	li	%[ret], 0		\n"
+		"2:					\n"
+		"	.set	pop"
+		: [tmp] "=&r" (tmp), [ret] "=&r" (ret)
+		: [inc] "r" (inc), [dec] "r" (dec), [rw] "r" (rw) : "memory");
+	return ret;
+}
+
+#else
+/*
  * read_can_lock - would read_trylock() succeed?
  * @lock: the rwlock in question.
  */
@@ -415,6 +570,8 @@ static inline int arch_write_trylock(arch_rwlock_t *rw)
 	return ret;
 }
 
+#endif /* CONFIG_CAVIUM_OCTEON2 */
+
 #define arch_read_lock_flags(lock, flags) arch_read_lock(lock)
 #define arch_write_lock_flags(lock, flags) arch_write_lock(lock)
 
-- 
1.9.1

