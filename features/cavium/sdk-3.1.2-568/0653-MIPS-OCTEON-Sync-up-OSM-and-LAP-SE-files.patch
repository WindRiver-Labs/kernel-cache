From 87a7eb110514241664477c03f192947cd06e3ac0 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@localhost.localdomain>
Date: Fri, 25 Jul 2014 18:05:50 -0700
Subject: [PATCH 653/974] MIPS: OCTEON: Sync up OSM and LAP SE files

Signed-off-by: Chandrakala Chavva <cchavva@localhost.localdomain>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/Makefile   |   3 +-
 arch/mips/cavium-octeon/executive/cvmx-lap.c | 625 +++++++++++++++++++++++++++
 arch/mips/cavium-octeon/executive/cvmx-osm.c | 223 ++++++++++
 arch/mips/include/asm/octeon/cvmx-asm.h      |   6 +-
 arch/mips/include/asm/octeon/cvmx-lap.h      | 221 ++++++++++
 arch/mips/include/asm/octeon/cvmx-osm.h      |  60 +++
 6 files changed, 1136 insertions(+), 2 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-lap.c
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-osm.c
 create mode 100644 arch/mips/include/asm/octeon/cvmx-lap.h
 create mode 100644 arch/mips/include/asm/octeon/cvmx-osm.h

diff --git a/arch/mips/cavium-octeon/executive/Makefile b/arch/mips/cavium-octeon/executive/Makefile
index fd744c0..06bdadc 100644
--- a/arch/mips/cavium-octeon/executive/Makefile
+++ b/arch/mips/cavium-octeon/executive/Makefile
@@ -23,7 +23,8 @@ obj-y += cvmx-pko.o cvmx-spi.o cvmx-cmd-queue.o cvmx-helper-cfg.o	\
 	cvmx-pki-resources.o cvmx-bgx.o cvmx-pko3-queue.o		\
 	cvmx-helper-bgx.o cvmx-pko3.o cvmx-helper-pki.o			\
 	cvmx-helper-pko3.o cvmx-pko3-resources.o cvmx-helper-pko.o	\
-	cvmx-helper-ipd.o cvmx-sso-resources.o cvmx-ocla.o cvmx-boot-vector.o
+	cvmx-helper-ipd.o cvmx-sso-resources.o cvmx-ocla.o cvmx-boot-vector.o \
+	cvmx-lap.o cvmx-osm.o
 
 obj-y += cvmx-helper-errata.o cvmx-helper-jtag.o
 obj-y += cvmx-pcie.o
diff --git a/arch/mips/cavium-octeon/executive/cvmx-lap.c b/arch/mips/cavium-octeon/executive/cvmx-lap.c
new file mode 100644
index 0000000..bcc724c
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-lap.c
@@ -0,0 +1,625 @@
+/***********************license start***************
+ * Copyright (c) 2014  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Support library for the LAP
+ *
+ */
+
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/irqflags.h>
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-pko3.h>
+#include <asm/octeon/cvmx-lapx-defs.h>
+#include <asm/octeon/cvmx-osm-defs.h>
+#include <asm/octeon/cvmx-lap.h>
+#else
+#include <stdio.h>
+#include <string.h>
+#include "cvmx.h"
+#include "cvmx-spinlock.h"
+#include "cvmx-pko3.h"
+#include "cvmx-lapx-defs.h"
+#include "cvmx-lap.h"
+#endif /*CVMX_BUILD_FOR_LINUX_KERNEL*/
+
+
+#define LAP_BIST_RESULT_MASK 0x1cfull
+#define NUM_EQ_BUFS 2
+static CVMX_SHARED int max_labs[CVMX_LAP_MAX_LAPS];
+
+static CVMX_SHARED int32_t gbl_labs_in_use_cnt[CVMX_LAP_MAX_LAPS];
+
+/**
+ * soft reset
+ *
+ * @param lap_num - lap number to be reset (0 or 1)
+ * @return 0 on success non zero on failure
+ */
+int cvmx_lap_soft_reset(int lap_num)
+{
+	cvmx_lapx_sft_rst_t soft_rst;
+
+	if ((lap_num != 0) && (lap_num != 1)) {
+		cvmx_dprintf("Invalid lap num %d\n", lap_num);
+		return -1;
+	}
+	soft_rst.u64 = cvmx_read_csr(CVMX_LAPX_SFT_RST(lap_num));
+	soft_rst.s.reset = 1;
+	cvmx_write_csr(CVMX_LAPX_SFT_RST(lap_num), soft_rst.u64);
+	do {
+		soft_rst.u64 = cvmx_read_csr(CVMX_LAPX_SFT_RST(lap_num));
+		//TODO timeout
+	} while(soft_rst.s.busy);
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_lap_soft_reset);
+
+/**
+ * Software lab management
+ *
+ * @param lap_num - lap number (0 or 1)
+ * @return 1 if lab is allocated 0 otherwise
+ */
+int cvmx_lap_mgr_get_lab(int lap_num)
+{
+	int32_t val;
+
+	lap_num &= 1;
+	do {
+		val = cvmx_atomic_get32(&gbl_labs_in_use_cnt[lap_num]);
+		if (val >= max_labs[lap_num]) {
+			return 0;
+		}
+	} while (!cvmx_atomic_compare_and_store32((uint32_t *)&gbl_labs_in_use_cnt[lap_num],(uint32_t)val,(uint32_t)(val+1)));
+	return 1;
+}
+EXPORT_SYMBOL(cvmx_lap_mgr_get_lab);
+
+/**
+ * Software lab management
+ *
+ * @param lap_num - lap number (0 or 1) 
+ */
+void cvmx_lap_mgr_put_lab(int lap_num)
+{
+	lap_num &= 1;
+	cvmx_atomic_add32(&gbl_labs_in_use_cnt[lap_num], -1); 
+}
+EXPORT_SYMBOL(cvmx_lap_mgr_put_lab);
+
+/**
+ * Fill exeception queue
+ *
+ * @param lap_num - lap number (0 or 1)
+ * @param num_bufs - number of buffers to be queued to exeception queue
+ * @return number of labs queued
+ */
+int cvmx_lap_fill_eq(int lap_num, int num_bufs)
+{
+	cvmx_lap_send_lmtdma_t send_dma;
+	uint64_t dma_addr;
+	cvmx_lap_ctl_rtn_t rtn_ctl;
+	int done, itr;
+	int num_labs_qued = 0;
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	unsigned long flags;
+#endif
+#define DUMMY_CMD_LEN (5)
+	uint64_t dummy_cmd[DUMMY_CMD_LEN] = {0x100008000000000llu,
+					     0x680000000llu,
+					     0x0llu,
+					     0x0llu,
+					     0x0llu};
+	
+	while (num_labs_qued < num_bufs) {
+		unsigned scr_off = CVMX_PKO_LMTLINE * CVMX_CACHE_LINE_SIZE;
+		/* LMTDMA globally ordered */
+		dma_addr = CVMX_LMTDMA_ORDERED_IO_ADDR;
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+		/* dont want to be preempted in the middle of LMTDMA */
+		local_irq_save(flags);
+#endif
+		for (itr = 0; itr < DUMMY_CMD_LEN; itr++) {
+			cvmx_scratch_write64(scr_off, dummy_cmd[itr]);
+			scr_off += 8;
+		}
+		dma_addr += ((DUMMY_CMD_LEN - 1) << 3);
+		cvmx_scratch_write64(scr_off, 0); 
+
+		/* Check for LABs in software as a workaround for the
+		   Errata (LAP-20136). */
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) &&
+		   (!cvmx_lap_mgr_get_lab(lap_num))) {
+			cvmx_dprintf("software lab manager: no labs\n");
+			break;
+		}
+		send_dma.u64 = 0;
+		send_dma.s.scraddr = scr_off >> 3;
+		send_dma.s.rtnlen = 5; //we only want the first word 
+		send_dma.s.did = CVMX_LAPX_DID(lap_num);
+		send_dma.s.node = cvmx_get_node_num();
+		send_dma.s.cmd = CVMX_LAP_SEND;
+		send_dma.s.df = 1;
+		send_dma.s.ds = 1;
+		send_dma.s.eq = 1;
+		CVMX_SYNCW;
+		cvmx_write64_uint64(dma_addr, send_dma.u64);
+		CVMX_SYNCIOBDMA;
+		done = 0;
+		do {
+			rtn_ctl.u64 = cvmx_scratch_read64(scr_off);
+			/* Apply the workaround for Errata (LAP-20342) */
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) &&
+				rtn_ctl.s.err == CVMX_LAP_LAB_OUT) { 
+				//cvmx_dprintf("no labs to queue to eq\n");
+				done = 1;
+			} else if  (rtn_ctl.s.timeout) {
+				//cvmx_dprintf("lab queuing to eq timeout\n");
+				num_labs_qued++;
+				done = 1;
+			} else if (rtn_ctl.u64) {
+				num_labs_qued++;
+				done = 1;
+			}
+		} while(!done);
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL	
+		local_irq_restore(flags);
+#endif
+		/* Manage LABs in software as a workaround for the
+		   Errata (LAP-20136). */
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+			cvmx_lap_mgr_put_lab(lap_num); 
+	}
+	return num_labs_qued;
+}
+EXPORT_SYMBOL(cvmx_lap_fill_eq);
+
+
+/**
+ * initialize LAP with given config
+ *
+ * @param lap_num - lap number (0 or 1)
+ * @param lap_config - lap configuration 
+ * @return 0 on success nonzero on failure
+ */
+int cvmx_lap_init(int lap_num, cvmx_lap_config_t *lap_config)
+{
+	cvmx_lapx_bist_result_t bist_result;
+	cvmx_lapx_cfg_t lap_cfg;
+	cvmx_lapx_xid_pos_t xid_pos;
+	cvmx_lapx_quex_cfg_t que_cfg;
+	cvmx_lapx_timeout_t timeout;
+
+	int itr;
+	lap_num &= 1;
+
+	if ((lap_num != 0) && (lap_num != 1)) {
+		cvmx_dprintf("Invalid lap num %d\n", lap_num);
+		return -1;
+	}
+
+	/* bist */
+	bist_result.u64 = cvmx_read_csr(CVMX_LAPX_BIST_RESULT(lap_num));
+	if (bist_result.u64 &  LAP_BIST_RESULT_MASK) {
+		cvmx_dprintf("Bist failed\n");
+		if (bist_result.s.nbr)
+			cvmx_dprintf("NBR bist failed\n");
+		if (bist_result.s.edat)
+			cvmx_dprintf("EDAT bist failed\n");
+		if (bist_result.s.emsk)
+			cvmx_dprintf("EMSK bist failed\n");
+		if (bist_result.s.lab_dat)
+			cvmx_dprintf("LAB_DAT bist failed\n");
+		if (bist_result.s.ctl_nxt)
+			cvmx_dprintf("CTL_NXT bist failed\n");
+		if (bist_result.s.ctl_sta)
+			cvmx_dprintf("CTL_STA bist failed\n");
+	} 
+	
+	/* configure lap */
+	xid_pos.u64 = cvmx_read_csr(CVMX_LAPX_XID_POS(lap_num));
+	xid_pos.s.as_only = lap_config->xid_pos.s.as_only;
+	xid_pos.s.rtn_wd  = lap_config->xid_pos.s.rtn_wd;
+	xid_pos.s.rtn_lsb = lap_config->xid_pos.s.rtn_lsb; 
+	xid_pos.s.req_wd  = lap_config->xid_pos.s.req_wd;
+	xid_pos.s.req_lsb = lap_config->xid_pos.s.req_lsb; 
+	cvmx_write_csr(CVMX_LAPX_XID_POS(lap_num), xid_pos.u64);
+	
+	for (itr =0; itr < CVMX_LAP_QUEUES_PER_LAP; itr++) {
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+			/* Apply workaround for Errata (LAP-20300) */
+			que_cfg.u64 = cvmx_read_csr(CVMX_LAPX_QUEX_CFG(lap_num, itr));
+			que_cfg.s.max_labs = lap_config->max_labs[CVMX_LAP_QUEUES_PER_LAP-itr];
+			cvmx_write_csr(CVMX_LAPX_QUEX_CFG(lap_num, itr),que_cfg.u64); 
+		} else {
+			que_cfg.u64 = cvmx_read_csr(CVMX_LAPX_QUEX_CFG(lap_num, itr));
+			que_cfg.s.max_labs = lap_config->max_labs[itr];
+			cvmx_write_csr(CVMX_LAPX_QUEX_CFG(lap_num, itr),que_cfg.u64); 
+		}
+	}
+	
+	/* Apply the workaround for Errata (LAP-20620). */
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+		timeout.u64 = cvmx_read_csr(CVMX_LAPX_TIMEOUT(lap_num));
+		timeout.s.iobdma = 0xff;
+		timeout.s.resp = 0x201;
+		cvmx_write_csr(CVMX_LAPX_TIMEOUT(lap_num), timeout.u64);
+	}
+	switch (lap_config->lab_size) {
+	case 0x0:
+		max_labs[lap_num] = 128;
+		break;
+	case 0x1:
+		max_labs[lap_num] = 170;
+		break;
+	case 0x2:
+		max_labs[lap_num] = 256;
+		break;
+	default:
+		max_labs[lap_num] = 256;
+		lap_config->lab_size = 0x2;
+		break;
+	}
+ 
+	/* enable */ 
+	lap_cfg.u64 = cvmx_read_csr(CVMX_LAPX_CFG(lap_num));
+	lap_cfg.s.ooo = lap_config->ooo;
+	lap_cfg.s.lab_size =  lap_config->lab_size;
+	lap_cfg.s.ena = 1;
+	cvmx_write_csr(CVMX_LAPX_CFG(lap_num), lap_cfg.u64);
+
+	for (itr =0; itr < CVMX_LAP_MAX_EXCEPTION_REGS; itr++) {
+		if (lap_config->exp_valid[itr]) {
+			cvmx_write_csr(CVMX_LAPX_EXPX_DATA(itr, lap_num), lap_config->exp_data[itr]);
+			cvmx_write_csr(CVMX_LAPX_EXPX_VALID(itr, lap_num), lap_config->exp_valid[itr]);
+		}
+	}
+   
+	/* setup exception queue */
+	if (cvmx_lap_fill_eq(lap_num, NUM_EQ_BUFS) != (NUM_EQ_BUFS)) {
+		cvmx_dprintf("unable to fill Exception queue\n");
+		return -1;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_lap_init);
+
+/**
+ * LMTDMA send operation. This will send request and receive the response data
+ *
+ * @param lap_num  - lap number (0 or 1)
+ * @param channel  - Channel number
+ * @param req_ptr  - Request buffer pointer
+ * @param req_len  - Request length (in bytes)
+ * @param rsp_ptr  - Response buffer pointer
+ * @param rsp_size - Response buffer size 
+ *                   (should be more than expected response size)
+ *
+ * @return size of Response (>=0) on success else negative (-1) for error
+ */
+int cvmx_lap_send_lmtdma(int lap_num, int channel, void * req_ptr, int req_len, 
+			void * rsp_ptr, int rsp_size)
+{
+	const unsigned scr_base = CVMX_PKO_LMTLINE * CVMX_CACHE_LINE_SIZE;
+	cvmx_lap_send_lmtdma_t send_dma;
+	cvmx_lap_rd_iobdma_t iobdma;
+	cvmx_lap_ctl_rtn_t rtn_ctl;
+	uint64_t dma_addr;
+	int done, lab, itr, num_words;
+	unsigned scr_off;
+	uint64_t rtn_addr;
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	unsigned long kflags = 0;
+#endif
+	if ((!req_ptr) || (!rsp_ptr) || 
+	    (!req_len) || (rsp_size < 8)) {
+		cvmx_dprintf("Invalid request or response\n");
+		return -1;
+	}
+		
+	num_words = (req_len >> 3) + ((req_len & 0x7)?1:0);
+	/* LMTDMA globally ordered */
+	dma_addr = CVMX_LMTDMA_ORDERED_IO_ADDR;
+	dma_addr += (num_words - 1) << 3;
+
+	/* Manage LAB entries in software based on the Errata (LAP-20136) */
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) &&
+		(!cvmx_lap_mgr_get_lab(lap_num))) {
+		cvmx_dprintf("software lab manager: no labs\n");
+		return -1;
+	}
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	local_irq_save(kflags);
+#endif
+	for (itr = 0, scr_off = scr_base; itr < num_words; itr++) { 
+		cvmx_scratch_write64(scr_off, ((uint64_t *) req_ptr)[itr]);
+		scr_off += 8;
+	}
+	rtn_addr = scr_off;
+	cvmx_scratch_write64(rtn_addr, 0); 
+	send_dma.u64 = 0;
+	send_dma.s.scraddr = rtn_addr >> 3;
+	send_dma.s.rtnlen = rsp_size>>3; 
+	send_dma.s.did = CVMX_LAPX_DID(lap_num);
+	send_dma.s.node = cvmx_get_node_num();
+	send_dma.s.chan = channel;
+	send_dma.s.cmd = CVMX_LAP_SEND;
+	done = 0;
+
+	CVMX_SYNCW;
+	cvmx_write64_uint64(dma_addr, send_dma.u64);
+	CVMX_SYNCIOBDMA;
+
+	do {
+		rtn_ctl.u64 = cvmx_scratch_read64(rtn_addr);
+		/* Apply the workaround for Errata (LAP-20342) */
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) &&
+			rtn_ctl.s.err == CVMX_LAP_LAB_OUT) { 
+			done = 1;
+		} else if (rtn_ctl.s.timeout) {
+				lab = rtn_ctl.s.lab;
+				/* cvmx_dprintf("lab = 0x%x\n", lab); */
+				/* IOBDMA globally ordered */
+				dma_addr = CVMX_IOBDMA_ORDERED_IO_ADDR;
+				cvmx_scratch_write64(rtn_addr, 0); 
+				iobdma.u64 = 0;
+				iobdma.s.scraddr = rtn_addr >> 3;
+				iobdma.s.rtnlen = 8;
+				iobdma.s.did = CVMX_LAPX_DID(lap_num);
+				iobdma.s.node = cvmx_get_node_num();
+				iobdma.s.cmd = CVMX_LAP_RTN;
+				iobdma.s.lab = lab;
+				CVMX_SYNCW;
+				cvmx_write64_uint64(dma_addr, iobdma.u64); 
+				CVMX_SYNCIOBDMA;
+		} else if (rtn_ctl.u64) {
+			done = 1;
+		}
+	} while(!done);
+
+	if (rtn_ctl.s.err) {
+		/* Manage LAB entries in software based on the Errata (LAP-20136) */
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+			cvmx_lap_mgr_put_lab(lap_num);
+		cvmx_dprintf("lmtdma error %d\n", rtn_ctl.s.err);
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+		local_irq_restore(kflags);
+#endif
+		return -1;
+	}
+	
+	if (rsp_size < (rtn_ctl.s.length*8)) {
+		/* Manage LAB entries in software based on the Errata (LAP-20136) */
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+			cvmx_lap_mgr_put_lab(lap_num);
+		cvmx_dprintf("insufficient rsp buffer size %d return size %d\n",
+			      rsp_size, rtn_ctl.s.length * 8);
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+		local_irq_restore(kflags);
+#endif
+		return -1;
+	}
+
+	for (itr = 0; itr < rtn_ctl.s.length; itr++) {
+		((uint64_t *) rsp_ptr)[itr] = cvmx_scratch_read64(rtn_addr + itr*8);
+	}
+
+	/* Manage LAB entries in software based on the Errata (LAP-20136) */
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+		cvmx_lap_mgr_put_lab(lap_num);
+
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	local_irq_restore(kflags);
+#endif
+	return rtn_ctl.s.length;
+}
+
+EXPORT_SYMBOL(cvmx_lap_send_lmtdma);
+
+/**
+ * LMTDMA send operation with immediate time out.
+ * This will send request and get LAB (transaction ID) as response
+ *
+ * @param lap_num  - lap number (0 or 1)
+ * @param channel  - Channel number
+ * @param req_ptr  - Request buffer pointer
+ * @param req_len  - Request length (in bytes)
+ *
+ * @return LAB (transaction ID >=0) in case of success 
+ * 		else negative (-1) for error
+ */
+int cvmx_lap_send_lmtdma_ito(int lap_num, int channel, 
+				void * req_ptr, int req_len)
+{
+	const unsigned scr_base = CVMX_PKO_LMTLINE * CVMX_CACHE_LINE_SIZE;
+	cvmx_lap_send_lmtdma_t send_dma;
+	cvmx_lap_ctl_rtn_t rtn_ctl;
+	uint64_t dma_addr;
+	int done, lab, itr, num_words;
+	unsigned scr_off;
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	unsigned long kflags = 0;
+#endif
+	if ((!req_ptr) || (!req_len)) {
+		cvmx_dprintf("Invalid request\n");
+		return -1;
+	}
+		
+	num_words = (req_len >> 3) + ((req_len & 0x7)?1:0);
+	/* LMTDMA globally ordered */
+	dma_addr = CVMX_LMTDMA_ORDERED_IO_ADDR;
+	dma_addr += (num_words - 1) << 3;
+
+	/* Manage LAB entries in software based on the Errata (LAP-20136) */
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) &&
+		(!cvmx_lap_mgr_get_lab(lap_num))) {
+		cvmx_dprintf("software lab manager: no labs\n");
+		return -1;
+	}
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	local_irq_save(kflags);
+#endif
+	for (itr = 0, scr_off = scr_base; itr < num_words; itr++) { 
+		cvmx_scratch_write64(scr_off, ((uint64_t *) req_ptr)[itr]);
+		scr_off += 8;
+	}
+	
+	cvmx_scratch_write64(scr_off, 0); 
+	send_dma.u64 = 0;
+	send_dma.s.scraddr = scr_off >> 3;
+	send_dma.s.rtnlen = 1;
+	send_dma.s.did = CVMX_LAPX_DID(lap_num);
+	send_dma.s.node = cvmx_get_node_num();
+	send_dma.s.chan = channel;
+	send_dma.s.cmd = CVMX_LAP_SEND;
+	send_dma.s.ito = 1;
+	send_dma.s.df = 1;
+	done = 0;
+	lab = -1;
+
+	CVMX_SYNCW;
+	cvmx_write64_uint64(dma_addr, send_dma.u64);
+	CVMX_SYNCIOBDMA;
+
+	do {
+		rtn_ctl.u64 = cvmx_scratch_read64(scr_off);
+		//cvmx_dprintf("rtn_ctl.u64 = 0x%llx\n", (unsigned long long) rtn_ctl.u64);
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X) &&
+			rtn_ctl.s.err == CVMX_LAP_LAB_OUT) { 
+			done = 1;
+		} else if (rtn_ctl.s.timeout) {
+			lab = rtn_ctl.s.lab;
+			done = 1;
+		} else if (rtn_ctl.u64) {
+			done = 1;
+		}
+	} while(!done);
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	local_irq_restore(kflags);
+#endif
+	return lab;
+}
+
+EXPORT_SYMBOL(cvmx_lap_send_lmtdma_ito);
+
+/**
+ * IOBDMA read operation by providing LAB identifier
+ * This will send IOBDMA read request with LAB (transaction ID)
+ * and receive response data for the request that was sent earlier.
+ *
+ * @param lap_num  - lap number (0 or 1)
+ * @param lab_id   - LAB (transaction ID >= 0) 
+ * 			(which is received by cvmx_lap_send_lmtdma_ito() call)
+ * @param offset   - Beginning word number from IOBDMA response buffer 
+ * 			(default value 0)
+ * @param rsp_ptr  - Response buffer pointer
+ * @param rsp_size - Response buffer size 
+ * 			(should be more than expected response size)
+ *
+ * @return size of Response (>=0) on success 
+ * 	else negative (-1) for error
+ */
+int cvmx_lap_read_iobdma(int lap_num, int lab_id,  int offset, 
+			void * rsp_ptr, int rsp_size)
+{
+	cvmx_lap_rd_iobdma_t iobdma;
+	cvmx_lap_ctl_rtn_t rtn_ctl;
+	uint64_t dma_addr;
+	int itr = 0;
+	const unsigned scr_base = CVMX_PKO_LMTLINE * CVMX_CACHE_LINE_SIZE;
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	unsigned long kflags = 0;
+#endif
+	 
+	if ((lab_id < 0) || (!rsp_ptr) || (rsp_size < 8))
+	{
+		cvmx_dprintf("Invalid request or response\n");
+		return -1;
+	}
+
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	local_irq_save(kflags);
+#endif
+	/* IOBDMA globally ordered */
+	dma_addr = CVMX_IOBDMA_ORDERED_IO_ADDR;
+	cvmx_scratch_write64(scr_base, 0); 
+	iobdma.u64 = 0;
+	rtn_ctl.u64 = 0;
+	iobdma.s.scraddr = (scr_base >> 3);
+	iobdma.s.rtnlen = rsp_size >> 3;
+	iobdma.s.did = CVMX_LAPX_DID(lap_num);
+	iobdma.s.node = cvmx_get_node_num();
+	iobdma.s.offset = offset;
+	iobdma.s.cmd = CVMX_LAP_RTN;
+	iobdma.s.lab = lab_id;
+	CVMX_SYNCW;
+	cvmx_write64_uint64(dma_addr, iobdma.u64);
+	CVMX_SYNCIOBDMA; 
+	rtn_ctl.u64 = cvmx_scratch_read64(scr_base);
+
+	if (rsp_size < (rtn_ctl.s.length*8)) {
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+			cvmx_lap_mgr_put_lab(lap_num);
+ 
+		cvmx_dprintf("insufficient rsp buffer size %d return size %d\n",
+			      rsp_size, rtn_ctl.s.length * 8);
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+		local_irq_restore(kflags);
+#endif
+		return -1;
+	}
+
+	for (itr = 0; itr < rtn_ctl.s.length; itr++) {
+		((uint64_t *) rsp_ptr)[itr] = cvmx_scratch_read64(scr_base + itr*8);
+	}
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+		cvmx_lap_mgr_put_lab(lap_num);
+ 
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	local_irq_restore(kflags);
+#endif
+	return rtn_ctl.s.length;
+}
+EXPORT_SYMBOL(cvmx_lap_read_iobdma);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-osm.c b/arch/mips/cavium-octeon/executive/cvmx-osm.c
new file mode 100644
index 0000000..2717195
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-osm.c
@@ -0,0 +1,223 @@
+/***********************license start***************
+ * Copyright (c) 2014  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Support library for the OSM
+ *
+ */
+
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-spinlock.h>
+#include <asm/octeon/cvmx-osm-defs.h>
+#include <asm/octeon/cvmx-osm.h>
+#else
+#include <stdio.h>
+#include <string.h>
+#include "cvmx.h"
+#include "cvmx-spinlock.h"
+#include "cvmx-osm-defs.h"
+#include "cvmx-osm.h"
+#endif /* CVMX_BUILD_FOR_LINUX_KERNEL */
+
+
+static CVMX_SHARED cvmx_spinlock_t cvmx_osm_lock=CVMX_SPINLOCK_UNLOCKED_INITIALIZER;
+static CVMX_SHARED int cvmx_osm_init_done;
+static const char * cvmx_osm_bank_names[] = 
+		{"DISABLED", "HFA", "HNA", "ASE-TWC", "ASE-BWC", "ASE-RWC"};
+
+/**
+ * Initilaize OSM
+ *
+ * @return 0 on success non zero on failure
+ */
+int cvmx_osm_init(void)
+{
+	cvmx_osm_memx_bist_status_t bist_status;
+	cvmx_osm_bankx_ctrl_t bank_ctrl;
+	int itr;
+
+	cvmx_spinlock_lock(&cvmx_osm_lock);
+	if (cvmx_osm_init_done) {
+		cvmx_spinlock_unlock(&cvmx_osm_lock);
+		return 0;
+	}
+	
+	for (itr = 0; itr < 8; itr++) {
+		bist_status.u64 = cvmx_read_csr(CVMX_OSM_MEMX_BIST_STATUS(itr));
+		if (bist_status.s.bist_status) {
+			cvmx_spinlock_unlock(&cvmx_osm_lock);
+			cvmx_dprintf("OSM MEM %d bist error\n", itr);
+			return -1;
+		}
+	}
+
+	for (itr = 0; itr < CVMX_OSM_MAX_BANKS; itr++) {
+		bank_ctrl.u64 = cvmx_read_csr(CVMX_OSM_BANKX_CTRL(itr));
+		bank_ctrl.s.bank_assign = CVMX_OSM_DISABLED;
+		cvmx_write_csr(CVMX_OSM_BANKX_CTRL(itr), bank_ctrl.u64);
+		bank_ctrl.u64 = cvmx_read_csr(CVMX_OSM_BANKX_CTRL(itr));
+	}
+
+	cvmx_osm_init_done = 1;
+	cvmx_spinlock_unlock(&cvmx_osm_lock);
+
+	return 0;
+}   
+EXPORT_SYMBOL(cvmx_osm_init);
+
+
+/**
+ * Reserve consecutive banks in OSM
+ *
+ * @param start_bank_num - starting bank number 
+ * @param num_banks - number of banks
+ * @param bank_assign - bank requester
+ * @return 0 on success non zero on failure
+ *
+ */
+int cvmx_osm_reserve_banks(int start_bank_num,
+				int num_banks,
+				cvmx_osm_bank_assign_e_t bank_assign)
+{
+	int itr;
+	cvmx_osm_bankx_ctrl_t bank_ctrl;
+
+	if (start_bank_num < 0 )
+		return -1;
+	if ((start_bank_num + num_banks) > CVMX_OSM_MAX_BANKS)
+		return -1;
+
+	cvmx_spinlock_lock(&cvmx_osm_lock);
+	for (itr = start_bank_num; itr < start_bank_num + num_banks; itr++) {
+		bank_ctrl.u64 = cvmx_read_csr(CVMX_OSM_BANKX_CTRL(itr));
+		if (bank_ctrl.s.bank_assign != CVMX_OSM_DISABLED) {
+			cvmx_spinlock_unlock(&cvmx_osm_lock);
+			return -1;
+		}
+	}
+	for (itr = start_bank_num; itr < start_bank_num + num_banks; itr++) {
+		bank_ctrl.u64 = cvmx_read_csr(CVMX_OSM_BANKX_CTRL(itr));
+		bank_ctrl.s.bank_assign = bank_assign;
+		cvmx_write_csr(CVMX_OSM_BANKX_CTRL(itr), bank_ctrl.u64);
+		bank_ctrl.u64 = cvmx_read_csr(CVMX_OSM_BANKX_CTRL(itr));
+	}
+	cvmx_spinlock_unlock(&cvmx_osm_lock);
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_osm_reserve_banks);
+
+/**
+ * Release consecutive banks in OSM
+ *
+ * @param start_bank_num - starting bank number 
+ * @param num_banks - number of banks
+ * @param bank_assign - bank owner
+ * @return 0 on success non zero on failure
+ *
+ */
+int cvmx_osm_release_banks(int start_bank_num,
+				int num_banks,
+				cvmx_osm_bank_assign_e_t bank_owner)
+{
+	int itr;
+	cvmx_osm_bankx_ctrl_t bank_ctrl;
+
+	if (start_bank_num < 0 )
+		return -1;
+	if ((start_bank_num + num_banks) > CVMX_OSM_MAX_BANKS)
+		return -1;
+
+	cvmx_spinlock_lock(&cvmx_osm_lock);
+	for (itr = start_bank_num; itr < start_bank_num + num_banks; itr++) {
+		bank_ctrl.u64 = cvmx_read_csr(CVMX_OSM_BANKX_CTRL(itr));
+		if (bank_owner == bank_ctrl.s.bank_assign) {
+			bank_ctrl.s.bank_assign = CVMX_OSM_DISABLED;
+		}
+		cvmx_write_csr(CVMX_OSM_BANKX_CTRL(itr), bank_ctrl.u64);
+	}
+	cvmx_spinlock_unlock(&cvmx_osm_lock);
+	return 0;
+}
+EXPORT_SYMBOL(cvmx_osm_release_banks);
+
+/**
+ * Check if an OSM bank is free
+ *
+ * @param bank_num - bank number 
+ * @return 1 if the bank is free else 0
+ *
+ */
+int cvmx_osm_is_bank_free(int bank_num)
+{
+	cvmx_osm_bankx_ctrl_t bank_ctrl;
+
+	if (bank_num < 0 )
+		return 0;
+	if (bank_num > (CVMX_OSM_MAX_BANKS-1))
+		return 0;
+
+	cvmx_spinlock_lock(&cvmx_osm_lock);
+	bank_ctrl.u64 = cvmx_read_csr(CVMX_OSM_BANKX_CTRL(bank_num));
+	cvmx_spinlock_unlock(&cvmx_osm_lock);
+	return (bank_ctrl.s.bank_assign == CVMX_OSM_DISABLED);
+}
+EXPORT_SYMBOL(cvmx_osm_is_bank_free);
+
+/**
+ * Dump the allocation of OSM banks
+ *
+ */
+void cvmx_osm_dump_banks(void)
+{
+	int itr;
+	cvmx_osm_bankx_ctrl_t bank_ctrl;
+
+	for (itr = 0; itr < CVMX_OSM_MAX_BANKS; itr++) {
+		bank_ctrl.u64 = cvmx_read_csr(CVMX_OSM_BANKX_CTRL(itr));
+		cvmx_dprintf("Bank-%d Assigned to %s\n", 
+			      itr, cvmx_osm_bank_names[bank_ctrl.s.bank_assign]);
+	}
+}
+EXPORT_SYMBOL(cvmx_osm_dump_banks);
diff --git a/arch/mips/include/asm/octeon/cvmx-asm.h b/arch/mips/include/asm/octeon/cvmx-asm.h
index 2a79a42..aa58f1e 100644
--- a/arch/mips/include/asm/octeon/cvmx-asm.h
+++ b/arch/mips/include/asm/octeon/cvmx-asm.h
@@ -42,7 +42,7 @@
  *
  * This is file defines ASM primitives for the executive.
 
- * <hr>$Revision: 95100 $<hr>
+ * <hr>$Revision: 102444 $<hr>
  *
  *
  */
@@ -772,6 +772,10 @@ extern "C" {
 	       "=m"(__a[offset + 4]), "=m"(__a[offset + 5]), "=m"(__a[offset + 6]), "=m"(__a[offset + 7]) : \
 	       [rsrc] "d" (data), [rbase] "d" (__a)); }
 
+/* IOBDMA/LMTDMA IO addresses */
+#define CVMX_LMTDMA_ORDERED_IO_ADDR 0xffffffffffffa400ull
+#define CVMX_IOBDMA_ORDERED_IO_ADDR 0xffffffffffffa200ull
+
 #ifdef	__cplusplus
 /* *INDENT-OFF* */
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-lap.h b/arch/mips/include/asm/octeon/cvmx-lap.h
new file mode 100644
index 0000000..0a63063
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-lap.h
@@ -0,0 +1,221 @@
+/***********************license start***************
+ * Copyright (c) 2014  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * This file contains defines for the LAP interface
+ */
+#ifndef __CVMX_LAP_H__
+#define __CVMX_LAP_H__
+
+#define CVMX_LAP_MAX_LAPS (2)
+#define CVMX_LAP_QUEUES_PER_LAP 3
+#define CVMX_LAP_MAX_LAB_SIZE 128
+#define CVMX_LAP_MIN_LAB_SIZE 64
+
+#define CVMX_LAPX_DID(x) (0x0C+x)
+
+typedef enum {
+    CVMX_LAP_SEND = 8,
+    CVMX_LAP_RTN,
+} cvmx_lap_cmd_e_t;
+
+typedef enum {
+    CVMX_LAP_NONE,
+    CVMX_LAP_TERMINATE,
+    CVMX_LAP_EOP_SKIP,
+    CVMX_LAP_PARITY,
+    CVMX_LAP_LAB_OUT,
+    CVMX_LAP_LAB_INVALID,
+    CVMX_LAP_RESP_TIME,
+    CVMX_LAP_MISMATCH,
+    CVMX_LAP_XID_BAD,
+    CVMX_LAP_TOO_BIG
+} cvmx_lap_err_e_t;
+
+#define CVMX_LAP_MAX_EXCEPTION_REGS (16)
+typedef struct  {
+    int lab_size;
+    int ooo;
+    int max_labs[CVMX_LAP_QUEUES_PER_LAP];
+    cvmx_lapx_xid_pos_t xid_pos;
+    uint64_t exp_valid[CVMX_LAP_MAX_EXCEPTION_REGS];
+    uint64_t exp_data[CVMX_LAP_MAX_EXCEPTION_REGS];
+} cvmx_lap_config_t;
+
+typedef union {
+    uint64_t u64;
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t scraddr:8;
+        uint64_t rtnlen:8;
+        uint64_t did:8;
+        uint64_t node:4;
+        uint64_t cmd:4;
+        uint64_t df:1;
+        uint64_t ds:1;
+        uint64_t eq:1;
+        uint64_t chan:1;
+        uint64_t ito:1;
+        uint64_t rsvd:27;
+#else
+        uint64_t rsvd:27;
+        uint64_t ito:1;
+        uint64_t chan:1;
+        uint64_t eq:1;
+        uint64_t ds:1;
+        uint64_t df:1;
+        uint64_t cmd:4;
+        uint64_t node:4;
+        uint64_t did:8;
+        uint64_t rtnlen:8;
+        uint64_t scraddr:8;
+#endif
+    } s;
+} cvmx_lap_send_lmtdma_t;
+
+
+typedef union {
+    uint64_t u64;
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t scraddr:8;
+        uint64_t rtnlen:8;
+        uint64_t did:8;
+        uint64_t node:4;
+        uint64_t cmd:4;
+        uint64_t df:1;
+        uint64_t rsvd1:3;
+        uint64_t ito:1;
+        uint64_t rsvd2:3;
+        uint64_t lab:8;
+        uint64_t rsvd3:9;
+        uint64_t offset:4;
+        uint64_t rsvd4:3;
+#else
+        uint64_t rsvd4:3;
+        uint64_t offset:4;
+        uint64_t rsvd3:9;
+        uint64_t lab:8;
+        uint64_t rsvd2:3;
+        uint64_t ito:1;
+        uint64_t rsvd1:3;
+        uint64_t df:1;
+        uint64_t cmd:4;
+        uint64_t node:4;
+        uint64_t did:8;
+        uint64_t rtnlen:8;
+        uint64_t scraddr:8;
+#endif
+    } s;
+} cvmx_lap_rd_iobdma_t;
+
+
+typedef union {
+    uint64_t u64;
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t rsvd1:7;
+        uint64_t as0:15;
+        uint64_t rsvd2:2;
+        uint64_t proto:1;
+        uint64_t as1:6;
+        uint64_t chan:1;
+        uint64_t as2:8;
+        uint64_t rsvd3:24;
+#else
+        uint64_t rsvd3:24;
+        uint64_t as2:8;
+        uint64_t chan:1;
+        uint64_t as1:6;
+        uint64_t proto:1;
+        uint64_t rsvd2:2;
+        uint64_t as0:15;
+        uint64_t rsvd1:7;
+#endif
+    } s;
+} cvmx_lap_ctl_req_t;
+
+typedef union {
+    uint64_t u64;
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t rsvd1:2;
+        uint64_t length:5;
+        uint64_t as0:15;
+        uint64_t rsvd2:2;
+        uint64_t proto:1;
+        uint64_t as1:6;
+        uint64_t chan:1;
+        uint64_t as2:8;
+        uint64_t timeout:1;
+        uint64_t eqne:1;
+        uint64_t err:6;
+        uint64_t rsvd3:8;
+        uint64_t lab:8;
+#else
+        uint64_t lab:8;
+        uint64_t rsvd3:8;
+        uint64_t err:6;
+        uint64_t eqne:1;
+        uint64_t timeout:1;
+        uint64_t as2:8;
+        uint64_t chan:1;
+        uint64_t as1:6;
+        uint64_t proto:1;
+        uint64_t rsvd2:2;
+        uint64_t as0:15;
+        uint64_t length:5;
+        uint64_t rsvd1:2;
+#endif
+    } s;
+} cvmx_lap_ctl_rtn_t;
+
+
+int cvmx_lap_soft_reset(int lap_num);
+int cvmx_lap_init(int lap_num, cvmx_lap_config_t *lap_config);
+int cvmx_lap_fill_eq(int lap_num, int num_bufs);
+int  cvmx_lap_mgr_get_lab(int lap_num);
+void cvmx_lap_mgr_put_lab(int lap_num);
+int cvmx_lap_send_lmtdma(int lap_num,  int channel, void * req_ptr, int req_len, 
+			 void * rsp_ptr, int rsp_size);
+int cvmx_lap_send_lmtdma_ito(int lap_num, int channel, void * req_ptr, int req_len);
+int cvmx_lap_read_iobdma(int lap_num, int lab_id, int offset, void * rsp_ptr, int rsp_size);
+#endif /* __CVMX_LAP_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-osm.h b/arch/mips/include/asm/octeon/cvmx-osm.h
new file mode 100644
index 0000000..e39b86e
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-osm.h
@@ -0,0 +1,60 @@
+/***********************license start***************
+ * Copyright (c) 2014  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+#ifndef __CVMX_OSM_H__
+#define __CVMX_OSM_H__
+
+#define CVMX_OSM_MAX_BANKS (64)
+
+typedef enum {
+	CVMX_OSM_DISABLED,
+	CVMX_OSM_DFA,
+	CVMX_OSM_HNA,
+	CVMX_OSM_TWC,
+	CVMX_OSM_BWC,
+	CVMX_OSM_RWC, 
+} cvmx_osm_bank_assign_e_t;
+
+int cvmx_osm_init(void);
+int cvmx_osm_reserve_banks(int start_bank_num, int num_banks, 
+			cvmx_osm_bank_assign_e_t bank_assign);
+int cvmx_osm_release_banks(int start_bank_num, int num_banks,
+			cvmx_osm_bank_assign_e_t bank_owner);
+int cvmx_osm_is_bank_free(int bank_num);
+void cvmx_osm_dump_banks(void);
+#endif /*__CVMX_OSM_H__ */
-- 
2.6.2

