From 30c112d6e725b2518478a192bea57ea839b2c7ff Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Fri, 6 Mar 2015 13:53:42 -0800
Subject: [PATCH 095/184] netdev: octeon-bgx_nexus: Create mix devices using
 device tree or module parameter data.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 62e6e1e0c00119f9cbb51626cb1ca2757aba7647
Description:

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/octeon/octeon-bgx-nexus.c | 262 ++++++++++++++++++++++---
 1 file changed, 230 insertions(+), 32 deletions(-)

diff --git a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
index d698877..109a2a1 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
@@ -30,6 +30,7 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/list.h>
+#include <linux/ctype.h>
 
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-helper-util.h>
@@ -42,13 +43,56 @@
 static atomic_t bgx_nexus_once;
 static atomic_t request_ethernet3_once;
 
-static int bgx_mix_port = -1;
-module_param(bgx_mix_port, int, S_IRUGO);
-MODULE_PARM_DESC(bgx_mix_port, "MIX port foo.");
+static char *mix_port;
+module_param(mix_port, charp, S_IRUGO);
+MODULE_PARM_DESC(mix_port, "Specifies which ports connect to MIX interfaces.");
 
-static int bgx_mix_port1 = -1;
-module_param(bgx_mix_port1, int, S_IRUGO);
-MODULE_PARM_DESC(bgx_mix_port1, "MIX port foo-prime.");
+#define MAX_NODES		2
+#define MAX_MIX_PER_NODE	2
+#define MAX_BGX_PER_NODE	6
+#define MAX_LMAC_PER_NODE	4
+
+#define MAX_MIX			(MAX_NODES * MAX_MIX_PER_NODE)
+
+/* mix_port_lmac:		Describes a lmac that connects to a mix port.
+ *				The lmac must be on the same node as the mix.
+ *
+ *  node:			Node of the lmac.
+ *  bgx:			Bgx of the lmac.
+ *  lmac:			Lmac index.
+ */
+struct mix_port_lmac {
+	int	node;
+	int	bgx;
+	int	lmac;
+};
+
+/* mix_ports_lmacs contains all the lmacs connected to mix ports */
+static struct mix_port_lmac mix_port_lmacs[MAX_MIX];
+
+/* is_lmac_to_mix:		Search the list of lmacs connected to mix'es
+ *				for a match.
+ *
+ *  node:			Numa node of lmac to search for.
+ *  bgx:			Bgx of lmac to search for.
+ *  lmac:			Lmac index to search for.
+ *
+ *  returns:			true if the lmac is connected to a mix, false
+ *				otherwise.
+ */
+static bool is_lmac_to_mix(int node, int bgx, int lmac)
+{
+	int	i;
+
+	for (i = 0; i < MAX_MIX; i++) {
+		if (mix_port_lmacs[i].node == node &&
+		    mix_port_lmacs[i].bgx == bgx &&
+		    mix_port_lmacs[i].lmac == lmac)
+			return true;
+	}
+
+	return false;
+}
 
 static int bgx_probe(struct platform_device *pdev)
 {
@@ -94,10 +138,7 @@ static int bgx_probe(struct platform_device *pdev)
 		if (r)
 			return -ENODEV;
 
-		if (bgx_mix_port == ((numa_node << 8) | (interface << 4) | port))
-			is_mix = true;
-		if (bgx_mix_port1 == ((numa_node << 8) | (interface << 4) | port))
-			is_mix = true;
+		is_mix = is_lmac_to_mix(numa_node, interface, port);
 
 		/* Connect to PKI/PKO */
 		cmr_config.u64 = cvmx_read_csr_node(numa_node, CVMX_BGXX_CMRX_CONFIG(port, interface));
@@ -132,6 +173,183 @@ static int bgx_probe(struct platform_device *pdev)
 	return 0;
 }
 
+/* bgx_mix_init_from_fdt:	Initialize the list of lmacs that connect to mix
+ *				ports from information in the device tree.
+ *
+ *  returns:			Zero on success, error otherwise.
+ */
+static int bgx_mix_init_from_fdt(void)
+{
+	struct device_node	*node;
+	struct device_node	*parent = NULL;
+	int			mix = 0;
+
+	for_each_compatible_node(node, NULL, "cavium,octeon-7890-mix") {
+		struct device_node	*lmac_fdt_node;
+		const __be32		*reg;
+		u64			addr;
+
+		/* Get the fdt node of the lmac connected to this mix */
+		lmac_fdt_node = of_parse_phandle(node, "cavium,mac-handle", 0);
+		if (!lmac_fdt_node)
+			goto err;
+
+		/* Get the numa node and bgx of the lmac */
+		parent = of_get_parent(lmac_fdt_node);
+		if (!parent)
+			goto err;
+		reg = of_get_property(parent, "reg", NULL);
+		if (!reg)
+			goto err;
+		addr = of_translate_address(parent, reg);
+		of_node_put(parent);
+		parent = NULL;
+
+		mix_port_lmacs[mix].node = (addr >> 36) & 0x7;
+		mix_port_lmacs[mix].bgx = (addr >> 24) & 0xf;
+
+		/* Get the lmac index */
+		reg = of_get_property(lmac_fdt_node, "reg", NULL);
+		if (!reg)
+			goto err;
+
+		mix_port_lmacs[mix].lmac = *reg;
+
+		mix++;
+		if (mix >= MAX_MIX)
+			break;
+	}
+
+	return 0;
+ err:
+	pr_warn("Invalid device tree mix port information\n");
+	for (mix = 0; mix < MAX_MIX; mix++) {
+		mix_port_lmacs[mix].node = -1;
+		mix_port_lmacs[mix].bgx = -1;
+		mix_port_lmacs[mix].lmac = -1;
+	}
+	if (parent)
+		of_node_put(parent);
+
+	return -EINVAL;
+}
+
+/* bgx_mix_init_from_param:	Initialize the list of lmacs that connect to mix
+ *				ports from information in the "mix_port"
+ *				parameter. The mix_port parameter format is as
+ *				follows:
+ *				mix_port=nbl
+ *				where:
+ *					n = node
+ *					b = bgx
+ *					l = lmac
+ *				There can be up to 4 lmacs defined separated by
+ *				commas. For example to select node0, bgx0, lmac0
+ *				and node0, bgx4, lamc0, the mix_port parameter
+ *				would be: mix_port=000,040
+ *
+ *  returns:			Zero on success, error otherwise.
+ */
+static int bgx_mix_init_from_param(void)
+{
+	char	*p = mix_port;
+	int	mix = 0;
+	int	i;
+
+	while (*p) {
+		int	node = -1;
+		int	bgx = -1;
+		int	lmac = -1;
+
+		if (strlen(p) < 3)
+			goto err;
+
+		/* Get the numa node */
+		if (!isdigit(*p))
+			goto err;
+		node = *p - '0';
+		if (node >= MAX_NODES)
+			goto err;
+
+		/* Get the bgx */
+		p++;
+		if (!isdigit(*p))
+			goto err;
+		bgx = *p - '0';
+		if (bgx >= MAX_BGX_PER_NODE)
+			goto err;
+
+		/* Get the lmac index */
+		p++;
+		if (!isdigit(*p))
+			goto err;
+		lmac = *p - '0';
+		if (lmac >= 2)
+			goto err;
+
+		/* Only one lmac0 and one lmac1 per node is supported */
+		for (i = 0; i < MAX_MIX; i++) {
+			if (mix_port_lmacs[i].node == node &&
+			    mix_port_lmacs[i].lmac == lmac)
+				goto err;
+		}
+
+		mix_port_lmacs[mix].node = node;
+		mix_port_lmacs[mix].bgx = bgx;
+		mix_port_lmacs[mix].lmac = lmac;
+
+		p++;
+		if (*p == ',')
+			p++;
+
+		mix++;
+		if (mix >= MAX_MIX)
+			break;
+	}
+
+	return 0;
+ err:
+	pr_warn("Invalid parameter mix_port=%s\n", mix_port);
+	for (mix = 0; mix < MAX_MIX; mix++) {
+		mix_port_lmacs[mix].node = -1;
+		mix_port_lmacs[mix].bgx = -1;
+		mix_port_lmacs[mix].lmac = -1;
+	}
+	return -EINVAL;
+}
+
+/* bgx_mix_port_lmacs_init:	Initialize the mix_port_lmacs variable with the
+ *				lmacs that connect to mic ports.
+ *
+ *  returns:			Zero on success, error otherwise.
+ */
+static int bgx_mix_port_lmacs_init(void)
+{
+	int	mix;
+
+	/* Start with no mix ports configured */
+	for (mix = 0; mix < MAX_MIX; mix++) {
+		mix_port_lmacs[mix].node = -1;
+		mix_port_lmacs[mix].bgx = -1;
+		mix_port_lmacs[mix].lmac = -1;
+	}
+
+	/* Check if no mix port should be configured */
+	if (mix_port && !strcmp(mix_port, "none"))
+		return 0;
+
+	/* Configure the mix ports using information from the device tree if no
+	 * parameter was passed. Otherwise, use the information in the module
+	 * parameter.
+	 */
+	if (!mix_port)
+		bgx_mix_init_from_fdt();
+	else
+		bgx_mix_init_from_param();
+
+	return 0;
+}
+
 static int bgx_remove(struct platform_device *pdev)
 {
 	return 0;
@@ -169,32 +387,12 @@ EXPORT_SYMBOL(bgx_nexus_load);
 
 static int __init bgx_driver_init(void)
 {
-	int p0 = bgx_mix_port & 0xf;
-	int p1 = bgx_mix_port1 & 0xf;
 	int r;
 
-	if (bgx_mix_port != -1 && bgx_mix_port1 != -1 && p1 == p0) {
-		pr_err("ERROR: octeon-bgx-nexus: bgx_mix_port and bgx_mix_port1 conflict (%03x:%03x)\n",
-		       bgx_mix_port, bgx_mix_port1);
-		r = -EINVAL;
-		goto err;
-	}
-
-	if (bgx_mix_port != -1 && p0 > 1) {
-		pr_err("ERROR: octeon-bgx-nexus: bgx_mix_port invalid (%03x)\n",
-		       bgx_mix_port);
-		r = -EINVAL;
-		goto err;
-	}
-	if (bgx_mix_port1 != -1 && p1 > 1) {
-		pr_err("ERROR: octeon-bgx-nexus: bgx_mix_port1 invalid (%03x)\n",
-		       bgx_mix_port1);
-		r = -EINVAL;
-		goto err;
-	}
+	bgx_mix_port_lmacs_init();
 
 	r = platform_driver_register(&bgx_driver);
-err:
+
 	return r;
 }
 
-- 
1.9.1

