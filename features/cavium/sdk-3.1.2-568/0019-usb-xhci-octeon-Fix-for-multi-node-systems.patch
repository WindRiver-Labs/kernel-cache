From ee9e3448d2aae7603c8c53e820277938ecb4490e Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 12 Nov 2014 15:21:33 -0800
Subject: [PATCH 019/184] usb: xhci-octeon: Fix for multi-node systems.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 13d5d9c7006a0afc842218d444bc2038be45127d
Description:

Adjust dwc3/core.c to match.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/usb/dwc3/core.c        |   6 +-
 drivers/usb/host/xhci-octeon.c | 227 ++++++++++++++++++++---------------------
 2 files changed, 111 insertions(+), 122 deletions(-)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 01d6b8d..0c776c6 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -47,7 +47,7 @@
 
 #include "debug.h"
 
-extern void octeon3_usb_phy_reset(int index);
+extern void octeon3_usb_phy_reset(u64 base);
 extern int xhci_octeon_start(struct platform_device *pdev);
 extern int xhci_octeon_stop(struct platform_device *pdev);
 #if IS_ENABLED(CONFIG_USB_XHCI_HCD_OCTEON)
@@ -75,7 +75,6 @@ static int dwc3_core_soft_reset(struct dwc3 *dwc)
 {
 	u32		reg;
 	int		ret = 0;
-	int		index;
 
 	/* Before Resetting PHY, put Core in Reset */
 	reg = dwc3_readl(dwc->regs, DWC3_GCTL);
@@ -92,9 +91,8 @@ static int dwc3_core_soft_reset(struct dwc3 *dwc)
 	reg |= DWC3_GUSB2PHYCFG_PHYSOFTRST;
 	dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);
 
-	index = (((uint64_t)(dwc->regs) & 0x10000000000ull) ? 1:0);
 #if IS_ENABLED(CONFIG_USB_XHCI_HCD_OCTEON)
-	octeon3_usb_phy_reset(index);
+	octeon3_usb_phy_reset((u64)dwc->regs);
 #else
 	usb_phy_init(dwc->usb2_phy);
 	usb_phy_init(dwc->usb3_phy);
diff --git a/drivers/usb/host/xhci-octeon.c b/drivers/usb/host/xhci-octeon.c
index e153500..a713019 100644
--- a/drivers/usb/host/xhci-octeon.c
+++ b/drivers/usb/host/xhci-octeon.c
@@ -21,18 +21,30 @@
 #include <asm/octeon/cvmx-usbdrdx-defs.h>
 #include <asm/octeon/cvmx-gpio-defs.h>
 
+#define UCTL_CTL	0
+#define UCTL_HOST_CFG	0xe0
+#define UCTL_SHIM_CFG	0xe8
+
 #define OCTEON_USB3_MIN_H_CLK_RATE	(150000000)
 #define OCTEON_USB3_MAX_H_CLK_RATE	(300000000)
 #define OCTEON_USB3_NUM_CLK_DEV_SEL	(8)
 
-static DEFINE_MUTEX(octeon3_usb1_clocks_mutex);
-static DEFINE_MUTEX(octeon3_usb2_clocks_mutex);
-static int octeon3_usb1_clock_start_cnt;
-static int octeon3_usb2_clock_start_cnt;
+static DEFINE_MUTEX(octeon3_usb_clocks_mutex);
+static int octeon3_usb_clock_start_cnt[4][2]; /* 4 nodes x 2 indexes */
+
 static uint8_t clk_div[OCTEON_USB3_NUM_CLK_DEV_SEL] = {1, 2, 4, 6, 8,
 							16, 24, 32};
 
-static int octeon3_usb_config_power(struct platform_device *pdev, int index)
+static int octeon3_usb_base2index(u64 base)
+{
+	return (base >> 24) & 1;
+}
+static int octeon3_usb_base2node(u64 base)
+{
+	return (base >> 36) & 3;
+}
+
+static int octeon3_usb_config_power(struct device_node *node, u64 base)
 {
 	union cvmx_usbdrdx_uctl_host_cfg uctl_host_cfg;
 	union cvmx_gpio_bit_cfgx gpio_bit;
@@ -40,14 +52,15 @@ static int octeon3_usb_config_power(struct platform_device *pdev, int index)
 	int power_active_low;
 	int gpio;
 	int len;
+	int index = octeon3_usb_base2index(base);
 
-	if (of_find_property(pdev->dev.of_node, "power", &len) != NULL) {
+	if (of_find_property(node, "power", &len) != NULL) {
 		if (len == 12) {
-			of_property_read_u32_array(pdev->dev.of_node, "power", gpio_pwr, 3);
+			of_property_read_u32_array(node, "power", gpio_pwr, 3);
 			power_active_low = gpio_pwr[2] & 0x01;
 			gpio = gpio_pwr[1];
 		} else if (len == 8) {
-			of_property_read_u32_array(pdev->dev.of_node, "power", gpio_pwr, 2);
+			of_property_read_u32_array(node, "power", gpio_pwr, 2);
 			power_active_low = 0;
 			gpio = gpio_pwr[1];
 		} else {
@@ -66,22 +79,22 @@ static int octeon3_usb_config_power(struct platform_device *pdev, int index)
 			cvmx_write_csr(CVMX_GPIO_XBIT_CFGX(gpio), gpio_bit.u64);
 		}
 		/* Enable XHCI power control and set if active high or low */
-		uctl_host_cfg.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_HOST_CFG(index));
+		uctl_host_cfg.u64 = cvmx_read_csr(base + UCTL_HOST_CFG);
 		uctl_host_cfg.s.ppc_en = 1;
 		uctl_host_cfg.s.ppc_active_high_en = !power_active_low;
-		cvmx_write_csr(CVMX_USBDRDX_UCTL_HOST_CFG(index), uctl_host_cfg.u64);
+		cvmx_write_csr(base + UCTL_HOST_CFG, uctl_host_cfg.u64);
 	} else {
 		pr_err("No power GPIO device tree entry\n");
 		/* Disable XHCI power control and set if active high*/
-		uctl_host_cfg.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_HOST_CFG(index));
+		uctl_host_cfg.u64 = cvmx_read_csr(base + UCTL_HOST_CFG);
 		uctl_host_cfg.s.ppc_en = 0;
 		uctl_host_cfg.s.ppc_active_high_en = 0;
-		cvmx_write_csr(CVMX_USBDRDX_UCTL_HOST_CFG(index), uctl_host_cfg.u64);
+		cvmx_write_csr(base + UCTL_HOST_CFG, uctl_host_cfg.u64);
 	}
 	return 0;
 }
 
-static void octeon3_usb_clocks_start(struct platform_device *pdev, int index)
+static int octeon3_usb_clocks_start(struct device *dev, u64 base)
 {
 	u32 clock_rate = 100000000;
 	union cvmx_usbdrdx_uctl_ctl uctl_ctl;
@@ -89,40 +102,31 @@ static void octeon3_usb_clocks_start(struct platform_device *pdev, int index)
 	u64 div;
 	int mpll_mul;
 	int i;
-	uint64_t h_clk_rate;
+	u64 h_clk_rate;
+	u64 uctl_ctl_reg = base + UCTL_CTL;
+	int index = octeon3_usb_base2index(base);
 
-	if (index == 0) {
-		mutex_lock(&octeon3_usb1_clocks_mutex);
-		octeon3_usb1_clock_start_cnt++;
-		if (octeon3_usb1_clock_start_cnt != 1)
-			goto exit;
-	} else {
-		mutex_lock(&octeon3_usb2_clocks_mutex);
-		octeon3_usb2_clock_start_cnt++;
-		if (octeon3_usb2_clock_start_cnt != 1)
-			goto exit;
-	}
-	if (pdev->dev.of_node) {
+	if (dev->of_node) {
 		const char *ss_clock_type;
 		const char *hs_clock_type;
 
-		i = of_property_read_u32(pdev->dev.of_node,
+		i = of_property_read_u32(dev->of_node,
 					 "refclk-frequency", &clock_rate);
 		if (i) {
 			pr_err("No UCTL \"refclk-frequency\"\n");
-			goto exit;
+			return -EINVAL;
 		}
-		i = of_property_read_string(pdev->dev.of_node,
+		i = of_property_read_string(dev->of_node,
 					    "refclk-type-ss", &ss_clock_type);
 		if (i) {
 			pr_err("No UCTL \"refclk-type-ss\"\n");
-			goto exit;
+			return -EINVAL;
 		}
-		i = of_property_read_string(pdev->dev.of_node,
+		i = of_property_read_string(dev->of_node,
 					    "refclk-type-hs", &hs_clock_type);
 		if (i) {
 			pr_err("No UCTL \"refclk-type-hs\"\n");
-			goto exit;
+			return -EINVAL;
 		}
 		if (strcmp("dlmc_ref_clk0", ss_clock_type) == 0) {
 			if (strcmp(hs_clock_type, "dlmc_ref_clk0") == 0)
@@ -153,7 +157,7 @@ static void octeon3_usb_clocks_start(struct platform_device *pdev, int index)
 
 	} else {
 		pr_err("No USB UCTL device node\n");
-		goto exit;
+		return -EINVAL;
 	}
 
 	/*
@@ -169,16 +173,16 @@ static void octeon3_usb_clocks_start(struct platform_device *pdev, int index)
 	/* Step 3: program the port power control feature if desired, later */
 
 	/* Step 4: Assert all resets */
-	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);
 	uctl_ctl.s.uphy_rst = 1;
 	uctl_ctl.s.uahc_rst = 1;
 	uctl_ctl.s.uctl_rst = 1;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
+	cvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);
 
 	/* Step 5a: Reset the clock dividers */
-	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);
 	uctl_ctl.s.h_clkdiv_rst = 1;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
+	cvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);
 
 	/* 5b */
 	/* Step 5b: Select controller clock frequency */
@@ -188,26 +192,26 @@ static void octeon3_usb_clocks_start(struct platform_device *pdev, int index)
 				 h_clk_rate >= OCTEON_USB3_MIN_H_CLK_RATE)
 			break;
 	}
-	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);
 	uctl_ctl.s.h_clkdiv_sel = div;
 	uctl_ctl.s.h_clk_en = 1;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
-	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	cvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);
+	uctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);
 	if ((div != uctl_ctl.s.h_clkdiv_sel) || (!uctl_ctl.s.h_clk_en)) {
-		dev_err(&pdev->dev, "ERROR: usb controller clock init\n");
-			goto exit;
+		dev_err(dev, "ERROR: usb controller clock init\n");
+			return -EINVAL;
 	}
 
 	/* Step 5c: Deassert the controller clock divider reset */
-	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);
 	uctl_ctl.s.h_clkdiv_rst = 0;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
+	cvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);
 
 	/* Step ??*/
 	udelay(10);
 
 	/* Step 6a-6d & 7: Reference clock configuration */
-	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);
 	uctl_ctl.s.ssc_en =0;
 	uctl_ctl.s.ref_ssp_en = 1;
 	uctl_ctl.s.ref_clk_sel = ref_clk_sel;
@@ -231,68 +235,53 @@ static void octeon3_usb_clocks_start(struct platform_device *pdev, int index)
 	uctl_ctl.s.mpll_multiplier = mpll_mul;
 	uctl_ctl.s.ss_power_en = 1;
 	uctl_ctl.s.hs_power_en = 1;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
+	cvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);
 
 	/* Step 9a */
-	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);
 	uctl_ctl.s.uctl_rst = 0;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
+	cvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);
 
 	/* Configure power */
-	if (octeon3_usb_config_power(pdev, index)) {
-		pr_err("Error configuring power for USB%d\n", index);
-		goto exit;
+	if (octeon3_usb_config_power(dev->of_node, base)) {
+		dev_err(dev, "Error configuring power.\n");
+		return -EINVAL;
 	}
 
 	/* Step 9b */
-	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);
 	uctl_ctl.s.uahc_rst = 0;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
+	cvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);
 
 	/* Step 9c*/
 	ndelay(200);
 
 	/* Step 10*/
-	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);
 	uctl_ctl.s.csclk_en = 1;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
+	cvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);
 
 	/*Step 11*/
-	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.u64 = cvmx_read_csr(uctl_ctl_reg);
 	uctl_ctl.s.drd_mode = 0;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
+	cvmx_write_csr(uctl_ctl_reg, uctl_ctl.u64);
 
 	octeon_error_tree_enable(CVMX_ERROR_GROUP_USB, index);
-exit:
-	if (index == 0)
-		mutex_unlock(&octeon3_usb1_clocks_mutex);
-	else
-		mutex_unlock(&octeon3_usb2_clocks_mutex);
 
+	return 0;
 }
 
-static void octeon3_usb_clocks_stop(int index)
+static void octeon3_usb_clocks_stop(u64 base)
 {
-	if (index == 0) {
-		mutex_lock(&octeon3_usb1_clocks_mutex);
-		octeon3_usb1_clock_start_cnt--;
-		if (octeon3_usb1_clock_start_cnt == 0)
-			octeon_error_tree_disable(CVMX_ERROR_GROUP_USB, index);
-		mutex_unlock(&octeon3_usb1_clocks_mutex);
-	} else {
-		mutex_lock(&octeon3_usb2_clocks_mutex);
-		octeon3_usb2_clock_start_cnt--;
-		if (octeon3_usb2_clock_start_cnt == 0 )
-			octeon_error_tree_disable(CVMX_ERROR_GROUP_USB, index);
-		mutex_unlock(&octeon3_usb2_clocks_mutex);
-	}
+	int index = octeon3_usb_base2index(base);
+
+	octeon_error_tree_disable(CVMX_ERROR_GROUP_USB, index);
 }
-EXPORT_SYMBOL(octeon3_usb_clocks_stop);
 
-void octeon3_usb_set_endian_mode(int index)
+void octeon3_usb_set_endian_mode(u64 base)
 {
 	union cvmx_usbdrdx_uctl_shim_cfg shim_cfg;
-	shim_cfg.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_SHIM_CFG(index));
+	shim_cfg.u64 = cvmx_read_csr(base + UCTL_SHIM_CFG);
 #ifdef __BIG_ENDIAN
 	shim_cfg.s.dma_endian_mode = 1;
 	shim_cfg.s.csr_endian_mode = 1;
@@ -300,46 +289,50 @@ void octeon3_usb_set_endian_mode(int index)
 	shim_cfg.s.dma_endian_mode = 0;
 	shim_cfg.s.csr_endian_mode = 0;
 #endif
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_SHIM_CFG(index), shim_cfg.u64);
+	cvmx_write_csr(base + UCTL_SHIM_CFG, shim_cfg.u64);
 }
 EXPORT_SYMBOL(octeon3_usb_set_endian_mode);
 
-void octeon3_usb_phy_reset(int index)
+void octeon3_usb_phy_reset(u64 base)
 {
 	union cvmx_usbdrdx_uctl_ctl uctl_ctl;
+	int index = (base >> 40) & 1;
+	int node = octeon3_usb_base2node(base);
 
-	uctl_ctl.u64 = cvmx_read_csr(CVMX_USBDRDX_UCTL_CTL(index));
+	uctl_ctl.u64 = cvmx_read_csr_node(node, CVMX_USBDRDX_UCTL_CTL(index));
 	uctl_ctl.s.uphy_rst = 0;
-	cvmx_write_csr(CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
+	cvmx_write_csr_node(node, CVMX_USBDRDX_UCTL_CTL(index), uctl_ctl.u64);
 }
 EXPORT_SYMBOL(octeon3_usb_phy_reset);
 
 int xhci_octeon_start(struct platform_device *pdev)
 {
 	struct resource *res_mem;
-	int host_ctrl;
-	struct platform_device *pr_pdev;
+	struct platform_device *parent_pdev;
+	int node, index;
+	u64 base;
 
-	pr_pdev = container_of(pdev->dev.parent, struct platform_device, dev);
-	res_mem = platform_get_resource(pr_pdev, IORESOURCE_MEM, 0);
+	parent_pdev = container_of(pdev->dev.parent, struct platform_device, dev);
+	res_mem = platform_get_resource(parent_pdev, IORESOURCE_MEM, 0);
 	if (res_mem == NULL) {
-		dev_err(&pr_pdev->dev, "found no memory resource\n");
+		dev_err(&parent_pdev->dev, "found no memory resource\n");
 		return -ENXIO;
 	}
-	switch (res_mem->start) {
-	case 0x1180068000000:
-		host_ctrl = 0;
-		break;
-	case 0x1180069000000:
-		host_ctrl = 1;
-		break;
-	default:
-		dev_err(&pdev->dev, "incorrect memory resource address\n");
-		return -ENXIO;
+	index = octeon3_usb_base2index(res_mem->start);
+	node = octeon3_usb_base2node(res_mem->start);
+
+	/* Hack alert:  Should use ioremap() */
+	base = res_mem->start | 0x8000000000000000ull;
+
+	mutex_lock(&octeon3_usb_clocks_mutex);
+	octeon3_usb_clock_start_cnt[node][index]++;
+	if (octeon3_usb_clock_start_cnt[node][index] == 1) {
+		octeon3_usb_clocks_start(&parent_pdev->dev, base);
+		octeon3_usb_set_endian_mode(base);
+		dev_info(&parent_pdev->dev, "clocks initialized.\n");
 	}
-	octeon3_usb_clocks_start(pr_pdev, host_ctrl);
-	octeon3_usb_set_endian_mode(host_ctrl);
-	dev_info(&pr_pdev->dev, "clocks initialized.\n");
+	mutex_unlock(&octeon3_usb_clocks_mutex);
+
 	return 0;
 }
 EXPORT_SYMBOL(xhci_octeon_start);
@@ -347,28 +340,26 @@ EXPORT_SYMBOL(xhci_octeon_start);
 int xhci_octeon_stop(struct platform_device *pdev)
 {
 	struct resource *res_mem;
-	int host_ctrl;
-	struct platform_device *pr_pdev;
+	struct platform_device *parent_pdev;
+	int node, index;
 
-	pr_pdev = container_of(pdev->dev.parent, struct platform_device, dev);
+	parent_pdev = container_of(pdev->dev.parent, struct platform_device, dev);
 
-	res_mem = platform_get_resource(pr_pdev, IORESOURCE_MEM, 0);
+	res_mem = platform_get_resource(parent_pdev, IORESOURCE_MEM, 0);
 	if (res_mem == NULL) {
-		dev_err(&pr_pdev->dev, "found no memory resource\n");
+		dev_err(&parent_pdev->dev, "found no memory resource\n");
 		return -ENXIO;
 	}
-	switch (res_mem->start) {
-	case 0x1180068000000:
-		host_ctrl = 0;
-		break;
-	case 0x1180069000000:
-		host_ctrl = 1;
-		break;
-	default:
-		dev_err(&pdev->dev, "incorrect memory resource address\n");
-		return -ENXIO;
-	}
-	octeon3_usb_clocks_stop(host_ctrl);
+	index = octeon3_usb_base2index(res_mem->start);
+	node = octeon3_usb_base2node(res_mem->start);
+
+
+	mutex_lock(&octeon3_usb_clocks_mutex);
+	octeon3_usb_clock_start_cnt[node][index]--;
+	if (octeon3_usb_clock_start_cnt[node][index] == 0)
+		octeon3_usb_clocks_stop(res_mem->start);
+	mutex_unlock(&octeon3_usb_clocks_mutex);
+
 	platform_set_drvdata(pdev, NULL);
 	return 0;
 }
-- 
1.9.1

