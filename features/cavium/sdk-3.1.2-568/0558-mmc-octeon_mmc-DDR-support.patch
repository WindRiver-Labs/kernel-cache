From aa7100639ed766620c4baf16c4c0e43f59c249df Mon Sep 17 00:00:00 2001
From: Peter Swain <peter.swain@cavium.com>
Date: Thu, 27 Feb 2014 13:46:59 -0800
Subject: [PATCH 558/974] mmc: octeon_mmc DDR support

Minimal changes to enable DDR signalling.
Requires tigter timing so may fail on some FDT settings

Signed-off-by: Peter Swain <pswain@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/mmc/host/octeon_mmc.c | 28 +++++++++++++++++++++++++++-
 1 file changed, 27 insertions(+), 1 deletion(-)

diff --git a/drivers/mmc/host/octeon_mmc.c b/drivers/mmc/host/octeon_mmc.c
index 34aa565..5d5a4eb 100644
--- a/drivers/mmc/host/octeon_mmc.c
+++ b/drivers/mmc/host/octeon_mmc.c
@@ -111,6 +111,11 @@ module_param(bb_size, int, S_IRUGO);
 MODULE_PARM_DESC(limit_max_blk,
 		 "Size of DMA linearizing buffer (max transfer size).");
 
+static bool ddr = 1;
+module_param(ddr, bool, S_IRUGO);
+MODULE_PARM_DESC(ddr,
+		 "enable DoubleDataRate clocking");
+
 #if 1
 #define octeon_mmc_dbg trace_printk
 #else
@@ -800,6 +805,7 @@ static void octeon_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	struct octeon_mmc_host	*host;
 	int bus_width;
 	int clock;
+	bool ddr;
 	int hs_timing;
 	int power_class = 10;
 	int clk_period;
@@ -852,7 +858,13 @@ static void octeon_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		bus_width = 0;
 		break;
 	}
+
 	hs_timing = (ios->timing == MMC_TIMING_MMC_HS);
+	ddr = (bus_width && ios->timing >= MMC_TIMING_UHS_DDR50);
+
+	if (ddr && bus_width)
+		bus_width |= 4;
+
 	if (ios->clock) {
 		slot->clock = ios->clock;
 		slot->bus_width = bus_width;
@@ -1057,11 +1069,25 @@ static int __init octeon_init_slot(struct octeon_mmc_host *host, int id,
 	mmc->f_max = max_freq;
 	mmc->caps = MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED |
 		    MMC_CAP_8_BIT_DATA | MMC_CAP_4_BIT_DATA |
-		    MMC_CAP_ERASE | MMC_CAP_CMD23;
+		    MMC_CAP_ERASE;
 	mmc->ocr_avail = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30 |
 			 MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
 			 MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36;
 
+	/* post-sdk23 caps */
+	mmc->caps |=
+		((mmc->f_max >= 12000000) * MMC_CAP_UHS_SDR12) |
+		((mmc->f_max >= 25000000) * MMC_CAP_UHS_SDR25) |
+		((mmc->f_max >= 50000000) * MMC_CAP_UHS_SDR50) |
+		MMC_CAP_CMD23;
+
+	if (host->global_pwr_gpio >= 0)
+		mmc->caps |= MMC_CAP_POWER_OFF_CARD;
+
+	/* "1.8v" capability is actually 1.8-or-3.3v */
+	if (ddr)
+		mmc->caps |= MMC_CAP_UHS_DDR50 | MMC_CAP_1_8V_DDR;
+
 	mmc->max_segs = 64;
 	mmc->max_seg_size = host->linear_buf_size;
 	mmc->max_req_size = host->linear_buf_size;
-- 
2.6.2

