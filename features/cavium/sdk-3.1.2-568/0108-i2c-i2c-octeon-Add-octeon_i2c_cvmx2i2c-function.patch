From f8f9c65571ec490c31d60bab8423a45c6a75ed00 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 26 Nov 2012 12:03:00 -0800
Subject: [PATCH 108/974] i2c: i2c-octeon: Add octeon_i2c_cvmx2i2c() function.

... to allow interaction with cvmx-twsi code.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/include/asm/octeon/octeon.h |  2 ++
 drivers/i2c/busses/i2c-octeon.c       | 29 +++++++++++++++++++++++++++++
 2 files changed, 31 insertions(+)

diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 9767c98..a8b573f 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -400,4 +400,6 @@ static inline int octeon_error_tree_disable(enum cvmx_error_groups group, int un
 }
 #endif
 
+int octeon_i2c_cvmx2i2c(unsigned int cvmx_twsi_bus_num);
+
 #endif /* __ASM_OCTEON_OCTEON_H */
diff --git a/drivers/i2c/busses/i2c-octeon.c b/drivers/i2c/busses/i2c-octeon.c
index a2d38fd..a5c8da3 100644
--- a/drivers/i2c/busses/i2c-octeon.c
+++ b/drivers/i2c/busses/i2c-octeon.c
@@ -81,6 +81,7 @@ struct octeon_i2c {
 	struct device *dev;
 	int broken_irq_mode;
 	bool octeon_i2c_hlc_enabled;
+	int cvmx_channel;
 };
 
 /**
@@ -904,6 +905,17 @@ static int octeon_i2c_initlowlevel(struct octeon_i2c *i2c)
 	return 0;
 }
 
+static int octeon_i2c_cvmx_map[2] = {-ENODEV, -ENODEV};
+
+int octeon_i2c_cvmx2i2c(unsigned int cvmx_twsi_bus_num)
+{
+	if (cvmx_twsi_bus_num < ARRAY_SIZE(octeon_i2c_cvmx_map))
+		return octeon_i2c_cvmx_map[cvmx_twsi_bus_num];
+	else
+		return -ENODEV;
+}
+EXPORT_SYMBOL(octeon_i2c_cvmx2i2c);
+
 static int octeon_i2c_probe(struct platform_device *pdev)
 {
 	int irq, result = 0;
@@ -921,6 +933,7 @@ static int octeon_i2c_probe(struct platform_device *pdev)
 		result = -ENOMEM;
 		goto out;
 	}
+	i2c->cvmx_channel = -1;
 	i2c->dev = &pdev->dev;
 
 	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -948,6 +961,17 @@ static int octeon_i2c_probe(struct platform_device *pdev)
 
 	i2c->sys_freq = octeon_get_io_clock_rate();
 
+	switch (res_mem->start) {
+	case 0x1180000001000:
+		i2c->cvmx_channel = 0;
+		break;
+	case 0x1180000001200:
+		i2c->cvmx_channel = 1;
+		break;
+	default:
+		break;
+	}
+
 	if (!devm_request_mem_region(&pdev->dev, res_mem->start, resource_size(res_mem),
 				     res_mem->name)) {
 		dev_err(i2c->dev, "request_mem_region failed\n");
@@ -992,6 +1016,9 @@ static int octeon_i2c_probe(struct platform_device *pdev)
 	}
 	dev_info(i2c->dev, "version %s\n", DRV_VERSION);
 
+	if (i2c->cvmx_channel >= 0)
+		octeon_i2c_cvmx_map[i2c->cvmx_channel] = i2c->adap.nr;
+
 	return 0;
 
 out:
@@ -1002,6 +1029,8 @@ static int octeon_i2c_remove(struct platform_device *pdev)
 {
 	struct octeon_i2c *i2c = platform_get_drvdata(pdev);
 
+	if (i2c->cvmx_channel >= 0)
+		octeon_i2c_cvmx_map[i2c->cvmx_channel] = -ENODEV;
 	i2c_del_adapter(&i2c->adap);
 	return 0;
 };
-- 
2.6.2

