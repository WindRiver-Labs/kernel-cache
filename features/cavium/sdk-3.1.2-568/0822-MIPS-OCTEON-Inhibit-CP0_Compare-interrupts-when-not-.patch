From 9540594792619d4d45616d3df4c0a3982a7c7108 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Sun, 13 Jul 2014 18:05:50 -0700
Subject: [PATCH 822/974] MIPS: OCTEON: Inhibit CP0_Compare interrupts when not
 needed.

This prevents unwanted interrupts when the CP0_Count wraps around, and
allows for tickless mode to truly not generate timer interrupts.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c | 25 ++++++++++++++++++++++++-
 arch/mips/kernel/cevt-r4k.c          | 11 +++++++++++
 2 files changed, 35 insertions(+), 1 deletion(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index fa7331e..cf5d27a 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -145,6 +145,9 @@ int octeon_cpu_for_coreid(int coreid)
 #endif
 }
 
+static DEFINE_PER_CPU(bool, octeon_irq_core_ack_masked[8]);
+static DEFINE_PER_CPU(bool, octeon_irq_core_inhibited[8]);
+
 static void octeon_irq_core_ack(struct irq_data *data)
 {
 	struct octeon_core_chip_data *cd = irq_data_get_irq_chip_data(data);
@@ -156,6 +159,7 @@ static void octeon_irq_core_ack(struct irq_data *data)
 	 * interrupt code.
 	 */
 	clear_c0_status(0x100 << bit);
+	__this_cpu_write(octeon_irq_core_ack_masked[bit], true);
 	/* The two user interrupts must be cleared manually. */
 	if (bit < 2)
 		clear_c0_cause(0x100 << bit);
@@ -164,13 +168,32 @@ static void octeon_irq_core_ack(struct irq_data *data)
 static void octeon_irq_core_eoi(struct irq_data *data)
 {
 	struct octeon_core_chip_data *cd = irq_data_get_irq_chip_data(data);
+	unsigned int bit = cd->bit;
+	bool inhibited = __this_cpu_read(octeon_irq_core_inhibited[bit]);
 
 	/*
 	 * We don't need to disable IRQs to make these atomic since
 	 * they are already disabled earlier in the low level
 	 * interrupt code.
 	 */
-	set_c0_status(0x100 << cd->bit);
+	if (!inhibited)
+		set_c0_status(0x100 << bit);
+	__this_cpu_write(octeon_irq_core_ack_masked[bit], false);
+}
+
+void octeon_irq_core_inhibit_bit(unsigned int bit, bool v)
+{
+	unsigned long flags;
+	bool masked;
+
+	raw_local_irq_save(flags);
+
+	masked = __this_cpu_read(octeon_irq_core_ack_masked[bit]);
+	__this_cpu_write(octeon_irq_core_inhibited[bit], v);
+
+	if (!masked && !v)
+		set_c0_status(0x100 << bit);
+	raw_local_irq_restore(flags);
 }
 
 static void octeon_irq_core_set_enable_local(void *arg)
diff --git a/arch/mips/kernel/cevt-r4k.c b/arch/mips/kernel/cevt-r4k.c
index 02033ea..3022546 100644
--- a/arch/mips/kernel/cevt-r4k.c
+++ b/arch/mips/kernel/cevt-r4k.c
@@ -17,6 +17,15 @@
 #include <asm/cevt-r4k.h>
 #include <asm/gic.h>
 
+#ifdef CONFIG_CAVIUM_OCTEON_SOC
+void octeon_irq_core_inhibit_bit(unsigned int bit, bool v);
+#else
+static void octeon_irq_core_inhibit_bit(unsigned int bit, bool v)
+{
+	return;
+}
+#endif
+
 /*
  * The SMTC Kernel for the 34K, 1004K, et. al. replaces several
  * of these routines with SMTC-specific variants.
@@ -33,6 +42,7 @@ static int mips_next_event(unsigned long delta,
 	cnt += delta;
 	write_c0_compare(cnt);
 	res = ((int)(read_c0_count() - cnt) >= 0) ? -ETIME : 0;
+	octeon_irq_core_inhibit_bit(cp0_compare_irq, false);
 	return res;
 }
 
@@ -71,6 +81,7 @@ irqreturn_t c0_compare_interrupt(int irq, void *dev_id)
 	if (!r2 || (read_c0_cause() & (1 << 30))) {
 		/* Clear Count/Compare Interrupt */
 		write_c0_compare(read_c0_compare());
+		octeon_irq_core_inhibit_bit(cp0_compare_irq, true);
 		cd = &per_cpu(mips_clockevent_device, cpu);
 #ifdef CONFIG_CEVT_GIC
 		if (!gic_present)
-- 
2.6.2

