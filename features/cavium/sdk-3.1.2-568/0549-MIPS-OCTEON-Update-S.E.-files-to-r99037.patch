From 628c70bda61b9bb141bb3091f0754f1f9c4d23d5 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Sat, 22 Feb 2014 13:46:59 -0800
Subject: [PATCH 549/974] MIPS: OCTEON: Update S.E. files to r99037.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-agl.c       |  7 +-
 arch/mips/cavium-octeon/executive/cvmx-bch.c       | 46 ++--------
 .../mips/cavium-octeon/executive/cvmx-helper-agl.c |  4 +-
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c | 39 +++++++--
 .../mips/cavium-octeon/executive/cvmx-helper-pki.c |  9 +-
 .../cavium-octeon/executive/cvmx-helper-util.c     | 19 ++++-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      | 98 +++++++++++++++-------
 .../mips/cavium-octeon/executive/cvmx-pko3-queue.c | 10 +--
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      |  3 +-
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       | 39 ++++-----
 arch/mips/cavium-octeon/executive/cvmx-range.c     | 39 ++++-----
 arch/mips/cavium-octeon/executive/octeon-feature.c |  1 +
 arch/mips/include/asm/octeon/cvmx-agl.h            | 13 +--
 arch/mips/include/asm/octeon/cvmx-helper-bgx.h     | 17 ++++
 arch/mips/include/asm/octeon/cvmx-helper-pki.h     |  1 +
 arch/mips/include/asm/octeon/cvmx-ipd.h            |  6 +-
 arch/mips/include/asm/octeon/cvmx-pki.h            |  5 ++
 arch/mips/include/asm/octeon/cvmx-pko3.h           | 82 ++++++++++++++----
 arch/mips/include/asm/octeon/cvmx-wqe.h            |  2 +-
 arch/mips/include/asm/octeon/octeon-feature.h      |  7 ++
 20 files changed, 276 insertions(+), 171 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-agl.c b/arch/mips/cavium-octeon/executive/cvmx-agl.c
index 7e595f6..ad0b487 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-agl.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-agl.c
@@ -128,11 +128,10 @@ cvmx_helper_link_info_t cvmx_agl_link_get(int port)
  *
  * @param port   interface port to set the link.
  * @param link_info  Link status
- * @param mode   0 = MII, 1 = RGMII mode
  *
  * @return       0 on success and 1 on failure
  */
-int cvmx_agl_link_set(int port, cvmx_helper_link_info_t link_info, int mode)
+int cvmx_agl_link_set(int port, cvmx_helper_link_info_t link_info)
 {
 	cvmx_agl_gmx_prtx_cfg_t agl_gmx_prtx;
 
@@ -208,11 +207,13 @@ int cvmx_agl_link_set(int port, cvmx_helper_link_info_t link_info, int mode)
 
 	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_OCTEON3()) {
 		cvmx_agl_gmx_txx_clk_t agl_clk;
+		cvmx_agl_prtx_ctl_t prt_ctl;
+		prt_ctl.u64 = cvmx_read_csr(CVMX_AGL_PRTX_CTL(port));
 		agl_clk.u64 = cvmx_read_csr(CVMX_AGL_GMX_TXX_CLK(port));
 		/* MII (both speeds) and RGMII 1000 setting */
 		agl_clk.s.clk_cnt = 1;
 		/* Check other speeds for RGMII mode */
-		if ((mode == CVMX_MGMT_PORT_RGMII_MODE) || OCTEON_IS_OCTEON3()) {
+		if ((prt_ctl.s.mode == 0) || OCTEON_IS_OCTEON3()) {
 			if (link_info.s.speed == 10)
 				agl_clk.s.clk_cnt = 50;
 			else if (link_info.s.speed == 100)
diff --git a/arch/mips/cavium-octeon/executive/cvmx-bch.c b/arch/mips/cavium-octeon/executive/cvmx-bch.c
index 25ed7cf..c90a78d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bch.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bch.c
@@ -53,8 +53,6 @@
 # include <asm/octeon/cvmx-fpa1.h>
 # include <asm/octeon/cvmx-helper-fpa.h>
 # include <asm/octeon/cvmx-cmd-queue.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
 #elif defined(CVMX_BUILD_FOR_UBOOT)
 # include <common.h>
 # include <asm/arch/cvmx.h>
@@ -90,8 +88,6 @@ extern int cvm_oct_mem_fill_fpa(int pool, int elements);
 extern int cvm_oct_alloc_fpa_pool(int pool, int size);
 #endif
 
-static uint8_t *bounce_buff;
-
 /**
  * Initialize the BCH block
  *
@@ -107,24 +103,19 @@ int cvmx_bch_initialize(void)
 
 	/* Initialize FPA pool for BCH pool buffers */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	int bch_aura, i;
-	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL, bch_aura = CVMX_FPA_OUTPUT_BUFFER_POOL;
-	bch_pool_size = CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE << 4;
+	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL;
+	bch_pool_size = CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE;
 
 	debug("pool: %d, pool size: %llu\n", bch_pool, bch_pool_size);
 	/* Setup the FPA */
 	cvmx_fpa1_enable();
 
+	bch_pool = cvm_oct_alloc_fpa_pool(bch_pool, bch_pool_size);
 	if (bch_pool < 0) {
 		pr_err("cvm_oct_alloc_fpa_pool(%d, %lld)\n", bch_pool, bch_pool_size);
 		return -ENOMEM;
 	}
-	
-	for (i = 0; i < 16; i++) {
-		cvmx_fpa1_free(kmalloc(bch_pool_size, GFP_KERNEL), bch_pool, 0);
-	}
-	
-	
+	cvm_oct_mem_fill_fpa(bch_pool, 128);
 #else
 	bch_pool = (int)cvmx_fpa_get_bch_pool();
 	bch_pool_size = cvmx_fpa_get_bch_pool_block_size();
@@ -141,7 +132,6 @@ int cvmx_bch_initialize(void)
 			"BCH Buffers");
 
 #endif
-	bounce_buff = cvmx_fpa1_alloc(bch_pool);
 	result = cvmx_cmd_queue_initialize(CVMX_CMD_QUEUE_BCH, 0, bch_pool,
 					   bch_pool_size);
 
@@ -180,7 +170,6 @@ EXPORT_SYMBOL(cvmx_bch_initialize);
 int cvmx_bch_shutdown(void)
 {
 	cvmx_bch_ctl_t bch_ctl;
-	int bch_pool;
 
 	debug("%s: ENTER\n", __func__);
 	bch_ctl.u64 = cvmx_read_csr(CVMX_BCH_CTL);
@@ -188,26 +177,8 @@ int cvmx_bch_shutdown(void)
 	cvmx_write_csr(CVMX_BCH_CTL, bch_ctl.u64);
 	cvmx_wait(4);
 
-#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL;
-#else
-	bch_pool = (int)cvmx_fpa_get_bch_pool();
-#endif
-	cvmx_fpa1_free(bounce_buff, bch_pool, 0);
 	cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_BCH);
 
-#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	/* FIXME: BCH cleanup in SE : AJ */
-	{
-		int i;
-		for (i = 0; i < 16; i++) {
-			kfree(cvmx_fpa1_alloc(bch_pool));
-		}
-	}
-#else
-	cvmx_fpa_shutdown_pool(bch_pool);
-#endif
-	/* AJ: Fix for FPA3 */
 	return 0;
 }
 EXPORT_SYMBOL(cvmx_bch_shutdown);
@@ -257,12 +228,6 @@ int cvmx_bch_encode(const void *block, uint16_t block_size,
 
 	debug("%s(%p, %u, %u, %p, %p) ENTRY\n", __func__, block, block_size,
 	      ecc_level, ecc, response);
-	/* there was a problem when the first argument is used directly
-	 * despite of the fact it was 8-byte aligned (maybe not proper
-	 * cvmx_prt_to_phys), so we copy data to dedicated 'bounce_buff'
-	 * and set command.s.iword.prt to cvmx_ptr_to_phys((void *)bounce_buff)
-	 */
-	memcpy(bounce_buff, block, block_size);
 	memset(&result, 0, sizeof(result));
 	memset(&command, 0, sizeof(command));
 	command.s.cword.ecc_gen = CVMX_BCH_INST_ECC_GENERATION;
@@ -270,8 +235,7 @@ int cvmx_bch_encode(const void *block, uint16_t block_size,
 	command.s.cword.size = block_size;
 
 	command.s.oword.ptr = cvmx_ptr_to_phys(ecc);
-/*	command.s.iword.ptr = cvmx_ptr_to_phys((void *)block);*/
-	command.s.iword.ptr = cvmx_ptr_to_phys((void *)bounce_buff);
+	command.s.iword.ptr = cvmx_ptr_to_phys((void *)block);
 	command.s.resp.ptr = cvmx_ptr_to_phys((void *)response);
 	debug("Command: cword: 0x%llx, oword: 0x%llx, iword: 0x%llx, resp: 0x%llx\n",
 	      command.u64[0], command.u64[1], command.u64[2], command.u64[3]);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-agl.c b/arch/mips/cavium-octeon/executive/cvmx-helper-agl.c
index 7a7d8f4..1d43c49 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-agl.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-agl.c
@@ -231,7 +231,7 @@ int __cvmx_helper_agl_enable(int interface)
 		do_link_set = 0;
 #endif
 	if (do_link_set)
-		cvmx_agl_link_set(port, cvmx_agl_link_get(ipd_port), 1);
+		cvmx_agl_link_set(port, cvmx_agl_link_get(ipd_port));
 
 	return 0;
 }
@@ -269,5 +269,5 @@ int __cvmx_helper_agl_link_set(int ipd_port, cvmx_helper_link_info_t link_info)
 {
 	int interface = cvmx_helper_get_interface_num(ipd_port);
 	int port = cvmx_helper_agl_get_port(interface);
-	return cvmx_agl_link_set(port, link_info, 1);
+	return cvmx_agl_link_set(port, link_info);
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 191ec8e..b1c71ff 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -155,7 +155,7 @@ static void __cvmx_bgx_common_init(int xiface)
 		cmr_config.s.enable = 0;
 		cmr_config.s.lmac_type = lmac_type;
 		cmr_config.s.lane_to_sds = ((lane_to_sds == 1) ? index
-					     : ((lane_to_sds == 0) 
+					     : ((lane_to_sds == 0)
 						 ? (index ? 0xe : 4) : lane_to_sds));
 		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
 	}
@@ -193,7 +193,7 @@ static void __cvmx_bgx_common_init(int xiface)
                 cvmx_write_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_OR(interface), chan_msk_or.u64);
 		/* set rx back pressure (bp_on) on value */
 		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_BP_ON(index, interface), bgx_rx_bp_on.u64);
-	}                                                   
+	}
 }
 
 /**
@@ -855,7 +855,7 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 
 		}
 	}
-	
+
 	/* 3e. Program all other relevant BGX configuration while
 	       BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] = 0. This includes all things
 	       described in this chapter. */
@@ -902,7 +902,7 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 		/* 5. If the auto-negotiation protocol is successful,
 		    BGX(0..5)_SPU(0..3)_AN_ADV[AN_COMPLETE] is set along with
 		    BGX(0..5)_SPU(0..3)_INT[AN_COMPLETE] when the link is up. */
-	
+
 		/* 3h. Set BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] = 1 and
 		    BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 0 to enable the LMAC. */
 		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
@@ -1012,7 +1012,7 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 		if (spu_status2.s.rcvflt) {
 			cvmx_dprintf("ERROR: %d:BGX%d:%d: Receive fault, need to retry\n",
 					node, interface, index);
-			
+
 			if (use_training) {
 				cvmx_bgxx_spux_br_pmd_control_t pmd_control;
 				spu_int.u64 = 0;
@@ -1132,7 +1132,7 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_xaui_link_get(int xipd_port)
 	result.u64 = 0;
 
 	spu_status1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_STATUS1(index, interface));
-	
+
 	if (spu_status1.s.rcv_lnk) {
 		int lanes;
 		int qlm = cvmx_qlm_interface(xiface);
@@ -1277,3 +1277,30 @@ void cvmx_helper_bgx_rx_pause_ctl(unsigned node, unsigned interface,
 	frm_ctl.s.ctl_drp = ctl_drp;
 	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(port, interface), frm_ctl.u64);
 }
+
+/**
+ * This function configures the receive action taken for multicast, broadcast
+ * and dmac filter match packets.
+ * @param node		node number.
+ * @param interface	interface number
+ * @param port		port number
+ * @param cam_accept	0: reject packets on dmac filter match
+ *                      1: accept packet on dmac filter match
+ * @param mcast_mode	0x0 = Force reject all multicast packets
+ *                      0x1 = Force accept all multicast packets
+ *                      0x2 = Use the address filter CAM
+ * @param bcast_accept  0 = Reject all broadcast packets
+ *                      1 = Accept all broadcast packets
+ */
+void cvmx_helper_bgx_rx_adr_ctl(unsigned node, unsigned interface, unsigned port,
+                                 unsigned cam_accept, unsigned mcast_mode, unsigned bcast_accept)
+{
+        cvmx_bgxx_cmrx_rx_adr_ctl_t adr_ctl;
+
+        adr_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_RX_ADR_CTL(port, interface));
+        adr_ctl.s.cam_accept = cam_accept;
+        adr_ctl.s.mcst_mode = mcast_mode;
+        adr_ctl.s.bcst_accept = bcast_accept;
+
+        cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_ADR_CTL(port, interface), adr_ctl.u64);
+}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
index 9f7f1b9..30fdce6 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
@@ -80,13 +80,6 @@ struct cvmx_pki_sso_grp_config {
 	uint8_t core_mask_set;
 };
 
-struct cvmx_pki_aura_config {
-	int aura_num;
-	int pool_num;
-	int buffer_count;
-};
-
-
 static CVMX_SHARED int pki_helper_debug;
 
 CVMX_SHARED bool cvmx_pki_dflt_init[CVMX_MAX_NODES] = {[0 ... CVMX_MAX_NODES-1] = 1};
@@ -100,7 +93,7 @@ CVMX_SHARED struct cvmx_pki_pool_config pki_dflt_pool[CVMX_MAX_NODES] = { [0 ...
 	.buffer_size = 2048,
 	.buffer_count = 0} };
 
-static CVMX_SHARED struct cvmx_pki_aura_config pki_dflt_aura[CVMX_MAX_NODES] = { [0 ... CVMX_MAX_NODES-1] = {
+CVMX_SHARED struct cvmx_pki_aura_config pki_dflt_aura[CVMX_MAX_NODES] = { [0 ... CVMX_MAX_NODES-1] = {
 	.aura_num = 0,
 	.pool_num = -1,
 	.buffer_count = 0} };
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
index 4dc4cad..68bbd1e 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
@@ -346,6 +346,16 @@ int cvmx_helper_dump_packet(cvmx_wqe_t *work)
 	return 0;
 }
 
+void copy_ptr_maybe_swap(uint64_t *dst, uint64_t *src, bool swap)
+{
+        uint64_t t;
+
+        t = *src;
+        if (swap)
+                t = __builtin_bswap64 (t);
+        *dst = t;
+}
+
 /**
  * Extract packet data buffer pointer from work queue entry.
  *
@@ -396,7 +406,14 @@ cvmx_buf_ptr_t cvmx_wqe_get_packet_ptr(cvmx_wqe_t *work)
 
 			vptr = cvmx_phys_to_ptr(lptr.s.addr);
 
-			memcpy(&nptr, vptr - 8, 8);
+			/* Errata (PKI-20776) PKI_BUFLINK_S's are endian-swapped
+                        CN78XX pass 1.x has a bug where the packet pointer in each segment is
+                        written in the opposite endianness of the configured mode. Fix these
+                        here */
+                        if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+                                copy_ptr_maybe_swap((uint64_t*)&nptr, (uint64_t*)(vptr - 8), 1);
+                        else
+                                copy_ptr_maybe_swap((uint64_t*)&nptr, (uint64_t*)(vptr - 8), 0);
 
 			lptr.u64=0;
 			lptr.s.pool = pool;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index 299b470..21ba947 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 98763 $<hr>
+ * <hr>$Revision: 98966 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -374,6 +374,63 @@ static void __cvmx_pcie_rc_initialize_config_space(int pcie_port)
 		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG034(pcie_port),
 				     pciercx_cfg034.u32);
 	}
+
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		int qlm = pcie_port; /* FIXME */
+		int speed = cvmx_qlm_get_gbaud_mhz(qlm);
+		cvmx_pemx_cfg_t pem_cfg;
+		cvmx_pciercx_cfg040_t cfg040;
+		cvmx_pciercx_cfg452_t cfg452;
+
+		/* Make sure the PEM agrees with GSERX about the speed
+  		   its going to try */
+		switch(speed) {
+		case 2500: /* Gen1 */
+			pem_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(pcie_port));
+			pem_cfg.s.md = 0;
+			cvmx_write_csr(CVMX_PEMX_CFG(pcie_port), pem_cfg.u64);
+
+			/* Set the target link speed */
+			cfg040.u32 = cvmx_pcie_cfgx_read(pcie_port,
+						CVMX_PCIERCX_CFG040(pcie_port));	
+			cfg040.s.tls = 1;
+			cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG040(pcie_port),
+						cfg040.u32);
+			break;
+		case 5000: /* Gen2 */
+			pem_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(pcie_port));
+			pem_cfg.s.md = 1;
+			cvmx_write_csr(CVMX_PEMX_CFG(pcie_port), pem_cfg.u64);
+
+			/* Set the target link speed */
+			cfg040.u32 = cvmx_pcie_cfgx_read(pcie_port,
+						CVMX_PCIERCX_CFG040(pcie_port));	
+			cfg040.s.tls = 2;
+			cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG040(pcie_port),
+						cfg040.u32);
+			break;
+		case 8000: /* Gen3 */
+			pem_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(pcie_port));
+			pem_cfg.s.md = 2;
+			cvmx_write_csr(CVMX_PEMX_CFG(pcie_port), pem_cfg.u64);
+
+			/* Set the target link speed */
+			cfg040.u32 = cvmx_pcie_cfgx_read(pcie_port,
+						CVMX_PCIERCX_CFG040(pcie_port));	
+			cfg040.s.tls = 3;
+			cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG040(pcie_port),
+						cfg040.u32);
+			break;
+		default:
+			break;
+		}
+		
+		/* Link Width Mode (PCIERCn_CFG452[LME]) */
+		pem_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(pcie_port));
+		cfg452.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG452(pcie_port));	
+		cfg452.s.lme = (pem_cfg.cn78xx.lanes8) ? 0xf : 0x7;
+		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG452(pcie_port), cfg452.u32);
+	}
 }
 
 /**
@@ -895,28 +952,18 @@ static int __cvmx_pcie_rc_initialize_link_gen2(int pcie_port)
 	cvmx_pciercx_cfg032_t pciercx_cfg032;
 	cvmx_pciercx_cfg448_t pciercx_cfg448;
 
+	if (OCTEON_IS_OCTEON3()) {
+		if (CVMX_WAIT_FOR_FIELD64(CVMX_PEMX_ON(pcie_port), cvmx_pemx_on_t, pemoor, ==, 1, 100000)) {
+			cvmx_dprintf("PCIe: Port %d PEM not on, skipping\n", pcie_port);
+			return -1;
+		}
+	}
+
 	/* Bring up the link */
 	pem_ctl_status.u64 = cvmx_read_csr(CVMX_PEMX_CTL_STATUS(pcie_port));
 	pem_ctl_status.s.lnk_enb = 1;
 	cvmx_write_csr(CVMX_PEMX_CTL_STATUS(pcie_port), pem_ctl_status.u64);
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
-		int lane;
-		cvmx_gserx_lanex_pwr_ctrl_t pwr_ctrl;
-
-		for (lane = 0; lane < 4; lane++) {
-			pwr_ctrl.u64 = cvmx_read_csr(CVMX_GSERX_LANEX_PWR_CTRL(lane, pcie_port));
-
-			pwr_ctrl.s.rx_resetn_ovrrd_en = 1;
-			cvmx_write_csr(CVMX_GSERX_LANEX_PWR_CTRL(lane, pcie_port), pwr_ctrl.u64);
-			cvmx_wait(1000);
-			pwr_ctrl.u64 = cvmx_read_csr(CVMX_GSERX_LANEX_PWR_CTRL(lane, pcie_port));
-
-			pwr_ctrl.s.rx_resetn_ovrrd_en = 0;
-			cvmx_write_csr(CVMX_GSERX_LANEX_PWR_CTRL(lane, pcie_port), pwr_ctrl.u64);
-		}
-	}
-
 	/* Wait for the link to come up */
 	start_cycle = cvmx_get_cycle();
 	do {
@@ -1037,6 +1084,7 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 				     pcie_port);
 			return -1;
 		} else if (mode != CVMX_QLM_MODE_PCIE &&
+			   mode != CVMX_QLM_MODE_PCIE_1X8 &&
 			   mode != CVMX_QLM_MODE_PCIE_1X2 &&
 			   mode != CVMX_QLM_MODE_PCIE_2X1 &&
 			   mode != CVMX_QLM_MODE_PCIE_1X1) {
@@ -1242,19 +1290,6 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 	/* Wait for PCIe reset to complete */
 	cvmx_wait_usec(1000);
 
-	/* For CN7XXX we must turn the PEM on */
-	if (OCTEON_IS_OCTEON3()) {
-		cvmx_pemx_on_t pemx_on;
-
-		pemx_on.u64 = cvmx_read_csr(CVMX_PEMX_ON(pcie_port));
-		pemx_on.s.pemon = 1;
-		cvmx_write_csr(CVMX_PEMX_ON(pcie_port), pemx_on.u64);
-		if (CVMX_WAIT_FOR_FIELD64(CVMX_PEMX_ON(pcie_port), cvmx_pemx_on_t, pemoor, ==, 1, 100000)) {
-			cvmx_dprintf("PCIe: Port %d PEM not on, skipping\n", pcie_port);
-			return -1;
-		}
-	}
-
 	/* Check and make sure PCIe came out of reset. If it doesn't the board
 	   probably hasn't wired the clocks up and the interface should be
 	   skipped */
@@ -1432,6 +1467,7 @@ int cvmx_pcie_rc_initialize(int pcie_port)
 		result = __cvmx_pcie_rc_initialize_gen1(pcie_port);
 	else
 		result = __cvmx_pcie_rc_initialize_gen2(pcie_port);
+
 #if !defined(CVMX_BUILD_FOR_LINUX_KERNEL) || defined(CONFIG_CAVIUM_DECODE_RSL)
 	if (result == 0)
 		cvmx_error_enable_group(CVMX_ERROR_GROUP_PCI, pcie_port);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
index af14f93..7d4c6d0 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
@@ -299,8 +299,8 @@ static uint16_t cvmx_pko3_chan_2_xchan(uint16_t ipd_port)
 	static const uint8_t xchan_base[16] = {
 		/* IPD 0x000 */ 0x3c0 >> 4,	/* LBK */
 		/* IPD 0x100 */ 0x380 >> 4,	/* DPI */
-		/* IPD 0x200 */ 0xff,		/* not used */
-		/* IPD 0x300 */ 0xff,		/* not used */
+		/* IPD 0x200 */ 0xfff >> 4,	/* not used */
+		/* IPD 0x300 */ 0xfff >> 4,	/* not used */
 		/* IPD 0x400 */ 0x000 >> 4,	/* ILK0 */
 		/* IPD 0x500 */ 0x100 >> 4,	/* ILK1 */
 		/* IPD 0x600 */ 0xfff >> 4,	/* not used */
@@ -311,13 +311,13 @@ static uint16_t cvmx_pko3_chan_2_xchan(uint16_t ipd_port)
 		/* IPD 0xb00 */ 0x2c0 >> 4,	/* BGX3 */
 		/* IPD 0xc00 */ 0x300 >> 4,	/* BGX4 */
 		/* IPD 0xd00 */ 0x340 >> 4,	/* BGX5 */
-		/* IPD 0xe00 */ 0xff,		/* not used */
-		/* IPD 0xf00 */ 0xff		/* not used */
+		/* IPD 0xe00 */ 0xfff >> 4,	/* not used */
+		/* IPD 0xf00 */ 0xfff >> 4	/* not used */
 	};
 
 	xchan = ipd_port >> 8;
 
-	/* ILKx has 8 bits logican channels, others just 6 */
+	/* ILKx has 8 bits logical channels, others just 6 */
 	if (((xchan & 0xfe) == 0x04))
 		off = ipd_port & 0xff;
 	else
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index ff9c378..74ad10c 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -744,7 +744,8 @@ static int cvmx_pko_setup_macs(int node)
 				mac_credit = 4 * 1024; /* 4KB fifo */
 				break;
 			default: /* BGX */
-				mac_credit = mac_fifo_cnt * 8 * 1024;
+				/* 8K in BGX + 16 so PKO doesn't deadlock with BGX on large packets */
+				mac_credit = mac_fifo_cnt * 8 * 1024 + 16;
 				break;
 		} /* switch mac_num */
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index 911109f..74459e6 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 98310 $<hr>
+ * <hr>$Revision: 98868 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -178,27 +178,24 @@ int cvmx_qlm_interface(int xiface)
 		int qlm;
 
 		if (xi.interface < 6) {
-			gconfig.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_CMR_GLOBAL_CONFIG(xi.interface));
-			if (gconfig.s.pmux_sds_sel) { /* Only QLM2 * QLM3 present */
-				if (xi.interface < 2)
-					qlm = xi.interface + 2;
+			if (xi.interface < 2) {
+				gconfig.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_CMR_GLOBAL_CONFIG(xi.interface));
+				if (gconfig.s.pmux_sds_sel)
+					qlm = xi.interface + 2; /* QLM 2 or 3 */
 				else
-					qlm = -1;
-			} else { /* QLM0, QLM1, QLM4 - QLM7 are present */
-				if (xi.interface < 2)
-					qlm = xi.interface;
-				else
-					qlm = xi.interface + 2;
-			}
+					qlm = xi.interface; /* QLM 0 or 1 */
+			} else
+				qlm = xi.interface + 2; /* QLM 4-7 */
+
 			/* make sure the QLM is powered up and out of reset */
-			if (qlm != -1) {
-				phy_ctl.u64 = cvmx_read_csr_node(xi.node, CVMX_GSERX_PHY_CTL(qlm));
-				if (phy_ctl.s.phy_pd || phy_ctl.s.phy_reset)
-					return -1;
-				gserx_cfg.u64 = cvmx_read_csr_node(xi.node, CVMX_GSERX_CFG(qlm));
-				if (gserx_cfg.s.bgx)
-					return qlm;
-			}
+			phy_ctl.u64 = cvmx_read_csr_node(xi.node, CVMX_GSERX_PHY_CTL(qlm));
+			if (phy_ctl.s.phy_pd || phy_ctl.s.phy_reset)
+				return -1;
+			gserx_cfg.u64 = cvmx_read_csr_node(xi.node, CVMX_GSERX_CFG(qlm));
+			if (gserx_cfg.s.bgx)
+				return qlm;
+			else
+				return -1;
 		} else if (xi.interface >= 7) { /* ILK */
 			int qlm;
 			for (qlm = 4; qlm < 8; qlm++) {
@@ -1274,7 +1271,7 @@ enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx(int node, int qlm)
 	} else if (gserx_cfg.s.bgx) {
 		cvmx_bgxx_cmrx_config_t cmr_config;
 		cvmx_bgxx_spux_br_pmd_control_t pmd_control;
-		int bgx = (qlm > 2) ? (qlm - 2) : qlm;
+		int bgx = (qlm < 2) ? qlm : qlm - 2;
 		
 		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(0, bgx));
 		pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(0, bgx));
diff --git a/arch/mips/cavium-octeon/executive/cvmx-range.c b/arch/mips/cavium-octeon/executive/cvmx-range.c
index 62c4662..6557f51 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-range.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-range.c
@@ -52,7 +52,7 @@ int cvmx_range_memory_size(int nelements)
 	return sizeof(uint64_t) * (nelements + 1);
 }
 
-int cvmx_range_init (uint64_t range_addr, int size)
+int cvmx_range_init(uint64_t range_addr, int size)
 {
 	uint64_t i;
 	uint64_t lsize = size;
@@ -70,9 +70,10 @@ static int64_t cvmx_range_find_next_available(uint64_t range_addr, uint64_t inde
 	uint64_t i;
 	uint64_t size = cvmx_read64_uint64(addr_of_size(range_addr));
 
-	while ((index % align) != 0) index++;
+	while ((index % align) != 0)
+		index++;
 
-	for(i=index; i<size; i+=align) {
+	for (i = index; i < size; i += align) {
 		uint64_t r_owner = cvmx_read64_uint64(addr_of_element(range_addr,i));
 		//cvmx_dprintf("index=%d owner=%llx\n", (int) i, (unsigned long long) r_owner);
 		if (r_owner == CVMX_RANGE_AVAILABLE)
@@ -81,7 +82,7 @@ static int64_t cvmx_range_find_next_available(uint64_t range_addr, uint64_t inde
 	return -1;
 }
 
-int cvmx_range_alloc (uint64_t range_addr, uint64_t owner, uint64_t cnt, int align)
+int cvmx_range_alloc(uint64_t range_addr, uint64_t owner, uint64_t cnt, int align)
 {
 	uint64_t i=0, size;
 	int64_t first_available;
@@ -90,14 +91,14 @@ int cvmx_range_alloc (uint64_t range_addr, uint64_t owner, uint64_t cnt, int ali
 	//	     (unsigned long long) range_addr, (unsigned long long) owner, (int)cnt);
 	size = cvmx_read64_uint64(addr_of_size(range_addr));
 	//cvmx_dprintf("%s: size=%d\n", __FUNCTION__, size);
-	while(i<size) {
+	while (i < size) {
 		uint64_t available_cnt=0;
 		first_available = cvmx_range_find_next_available(range_addr, i, align);
 		if (first_available == -1)
 			return -1;
 		i = first_available;
 		//cvmx_dprintf("%s: first_available=%d \n", __FUNCTION__, (int) first_available);
-		while((available_cnt != cnt) && (i < size)) {
+		while ((available_cnt != cnt) && (i < size)) {
 			uint64_t r_owner = cvmx_read64_uint64(addr_of_element(range_addr,i));
 			if (r_owner == CVMX_RANGE_AVAILABLE)
 				available_cnt++;
@@ -107,7 +108,7 @@ int cvmx_range_alloc (uint64_t range_addr, uint64_t owner, uint64_t cnt, int ali
 			//cvmx_dprintf("%s: first_available=%d available=%d \n", __FUNCTION__,
 			//	     (int) first_available, (int) available_cnt);
 			uint64_t j;
-			for(j=first_available; j < first_available + cnt; j++) {
+			for (j = first_available; j < first_available + cnt; j++) {
 				uint64_t a = addr_of_element(range_addr,j);
 				//cvmx_dprintf("%s: j=%d a=%llx \n", __FUNCTION__, (int) j, (unsigned long long) a);
 				cvmx_write64_uint64(a, owner);
@@ -127,12 +128,12 @@ int  cvmx_range_alloc_non_contiguos(uint64_t range_addr, uint64_t owner, uint64_
 	uint64_t element_index = 0;
 
 	size = cvmx_read64_uint64(addr_of_size(range_addr));
-	for(i=0; i<size; i++) {
+	for (i = 0; i < size; i++) {
 		uint64_t r_owner = cvmx_read64_uint64(addr_of_element(range_addr,i));
 		//cvmx_dprintf("index=%d owner=%llx\n", (int) i, (unsigned long long) r_owner);
-		if (r_owner == CVMX_RANGE_AVAILABLE) {
+		if (r_owner == CVMX_RANGE_AVAILABLE)
 			elements[element_index++] = (int) i;
-		}
+
 		if (element_index == cnt)
 			break;
 	}
@@ -141,7 +142,7 @@ int  cvmx_range_alloc_non_contiguos(uint64_t range_addr, uint64_t owner, uint64_
 			     " available=%d\n", (int)cnt, (int) element_index);
 		return -1;
 	}
-	for(i=0; i<cnt; i++) {
+	for (i = 0; i < cnt; i++) {
 		uint64_t a = addr_of_element(range_addr,elements[i]);
 		cvmx_write64_uint64(a, owner);
 	}
@@ -159,7 +160,7 @@ int cvmx_range_reserve(uint64_t range_addr, uint64_t owner, uint64_t base, uint6
 		cvmx_dprintf("ERROR: invalid base or cnt size=%d base+cnt=%d \n", (int) size, (int)up);
 		return -1;
 	}
-	for(i=base; i<up; i++) {
+	for (i = base; i < up; i++) {
 		r_owner = cvmx_read64_uint64(addr_of_element(range_addr,i));
 		//cvmx_dprintf("%d: %llx\n", (int) i,(unsigned long long) r_owner);
 		if (r_owner != CVMX_RANGE_AVAILABLE) {
@@ -167,7 +168,7 @@ int cvmx_range_reserve(uint64_t range_addr, uint64_t owner, uint64_t base, uint6
 			return -1;
 		}
 	}
-	for(i=base; i<up; i++) {
+	for (i = base; i < up; i++) {
 		cvmx_write64_uint64(addr_of_element(range_addr,i), owner);
 	}
 	return base;
@@ -179,7 +180,7 @@ int cvmx_range_free_with_owner(uint64_t range_addr, uint64_t owner)
 	int found = -1;
 
 	size = cvmx_read64_uint64(addr_of_size(range_addr));
-	for(i=0; i<size; i++) {
+	for (i = 0; i < size; i++) {
 		uint64_t r_owner = cvmx_read64_uint64(addr_of_element(range_addr,i));
 		if (r_owner == owner) {
 			cvmx_write64_uint64(addr_of_element(range_addr,i), CVMX_RANGE_AVAILABLE);
@@ -196,7 +197,7 @@ int __cvmx_range_is_allocated(uint64_t range_addr, int bases[], int count)
 
 	cnt = count;
 	size = cvmx_read64_uint64(addr_of_size(range_addr));
-	for(i=0; i<cnt; i++) {
+	for (i = 0; i < cnt; i++) {
 		uint64_t base = bases[i];
 		if (base >= size) {
 			cvmx_dprintf("ERROR: invalid base or cnt size=%d "
@@ -221,7 +222,7 @@ int cvmx_range_free_mutiple(uint64_t range_addr, int bases[], int count)
 	if (__cvmx_range_is_allocated(range_addr, bases, count) != 1) {
 		return -1;
 	}
-	for(i=0; i<cnt; i++) {
+	for (i = 0; i < cnt; i++) {
 		uint64_t base = bases[i];
 		cvmx_write64_uint64(addr_of_element(range_addr, base),
 				    CVMX_RANGE_AVAILABLE);
@@ -239,20 +240,20 @@ int cvmx_range_free_with_base(uint64_t range_addr, int base, int cnt)
 		cvmx_dprintf("ERROR: invalid base or cnt size=%d base+cnt=%d \n", (int) size, (int)up);
 		return -1;
 	}
-	for(i=base; i<up; i++) {
+	for (i = base; i < up; i++) {
 		cvmx_write64_uint64(addr_of_element(range_addr,i), CVMX_RANGE_AVAILABLE);
 	}
 	return 0;
 }
 
-void cvmx_range_show (uint64_t range_addr)
+void cvmx_range_show(uint64_t range_addr)
 {
 	uint64_t pval, val, size, pindex, i;
 
 	size = cvmx_read64_uint64(addr_of_size(range_addr));
 	pval = cvmx_read64_uint64(addr_of_element(range_addr, 0));
 	pindex = 0;
-	for(i=1; i<size; i++) {
+	for (i = 1; i < size; i++) {
 		val = cvmx_read64_uint64(addr_of_element(range_addr,i));
 		if (val != pval) {
 			cvmx_dprintf ("i=%d : %llx \n", (int) pindex, (unsigned long long)pval);
diff --git a/arch/mips/cavium-octeon/executive/octeon-feature.c b/arch/mips/cavium-octeon/executive/octeon-feature.c
index 4b0d8df..6b3036d 100644
--- a/arch/mips/cavium-octeon/executive/octeon-feature.c
+++ b/arch/mips/cavium-octeon/executive/octeon-feature.c
@@ -139,6 +139,7 @@ void __init octeon_feature_init(void)
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_PKI);
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_OCLA);
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_FAU);
+	OCTEON_FEATURE_SET(OCTEON_FEATURE_PKO3);
 
 	val = OCTEON_FEATURE_SUCCESS;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-agl.h b/arch/mips/include/asm/octeon/cvmx-agl.h
index 0aaf50e..86bc47f 100644
--- a/arch/mips/include/asm/octeon/cvmx-agl.h
+++ b/arch/mips/include/asm/octeon/cvmx-agl.h
@@ -61,15 +61,6 @@ extern "C" {
 /* *INDENT-ON* */
 #endif
 
-/**
- * Enum of MIX interface modes
- */
-typedef enum {
-	CVMX_MGMT_PORT_NONE = 0,
-	CVMX_MGMT_PORT_MII_MODE,
-	CVMX_MGMT_PORT_RGMII_MODE,
-} cvmx_mgmt_port_mode_t;
-
 /*
  * @param port port to enable
  *
@@ -84,12 +75,10 @@ extern cvmx_helper_link_info_t cvmx_agl_link_get(int port);
  *
  * @param port   interface port to set the link.
  * @param link_info  Link status
- * @param mode   0 = MII, 1 = RGMII mode
  *
  * @return       0 on success and 1 on failure
  */
-extern int cvmx_agl_link_set(int port, cvmx_helper_link_info_t link_info,
-			     int mode);
+extern int cvmx_agl_link_set(int port, cvmx_helper_link_info_t link_info);
 
 /**
  * Disables the sending of flow control (pause) frames on the specified
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-bgx.h b/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
index 70b614a..3a1307c 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
@@ -210,4 +210,21 @@ extern void __cvmx_helper_bgx_xaui_config_pfc(unsigned node,
  */
 extern void cvmx_helper_bgx_rx_pause_ctl(unsigned node, unsigned interface,
 				  unsigned port, unsigned ctl_bck, unsigned ctl_drp);
+
+/**
+ * This function configures the receive action taken for multicast, broadcast
+ * and dmac filter match packets.
+ * @param node		node number.
+ * @param interface	interface number
+ * @param port		port number
+ * @param cam_accept	0: reject packets on dmac filter match
+ *                      1: accept packet on dmac filter match
+ * @param mcast_mode	0x0 = Force reject all multicast packets
+ *                      0x1 = Force accept all multicast packets
+ *                      0x2 = Use the address filter CAM
+ * @param bcast_accept  0 = Reject all broadcast packets
+ *                      1 = Accept all broadcast packets
+ */
+extern void cvmx_helper_bgx_rx_adr_ctl(unsigned node, unsigned interface, unsigned port,
+                                unsigned cam_accept, unsigned mcast_mode, unsigned bcast_accept);
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-pki.h b/arch/mips/include/asm/octeon/cvmx-helper-pki.h
index 049328a..abf7645 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-pki.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-pki.h
@@ -139,6 +139,7 @@ struct cvmx_pki_global_schd {
 extern CVMX_SHARED bool cvmx_pki_dflt_init[CVMX_MAX_NODES];
 
 extern CVMX_SHARED struct cvmx_pki_pool_config pki_dflt_pool[CVMX_MAX_NODES];
+extern CVMX_SHARED struct cvmx_pki_aura_config pki_dflt_aura[CVMX_MAX_NODES];
 extern uint64_t style_qpg_base_map[CVMX_MAX_NODES];
 extern CVMX_SHARED struct cvmx_pki_style_config pki_dflt_style[CVMX_MAX_NODES];
 extern CVMX_SHARED struct cvmx_pki_pkind_config pki_dflt_pkind[CVMX_MAX_NODES];
diff --git a/arch/mips/include/asm/octeon/cvmx-ipd.h b/arch/mips/include/asm/octeon/cvmx-ipd.h
index 67f9cc1..a97b045 100644
--- a/arch/mips/include/asm/octeon/cvmx-ipd.h
+++ b/arch/mips/include/asm/octeon/cvmx-ipd.h
@@ -42,7 +42,7 @@
  *
  * Interface to the hardware Input Packet Data unit.
  *
- * <hr>$Revision: 95049 $<hr>
+ * <hr>$Revision: 98855 $<hr>
  */
 
 #ifndef __CVMX_IPD_H__
@@ -111,7 +111,7 @@ static inline int64_t cvmx_fpa_get_packet_pool(void)
 {
 	if (octeon_has_feature(OCTEON_FEATURE_PKI)) {
 		int node = cvmx_get_node_num();
-		return pki_dflt_pool[node].pool_num;
+		return pki_dflt_aura[node].aura_num;
 	}
 	return (cvmx_ipd_cfg.packet_pool.pool_num);
 }
@@ -147,7 +147,7 @@ static inline int64_t cvmx_fpa_get_wqe_pool(void)
 {
 	if (octeon_has_feature(OCTEON_FEATURE_PKI)) {
 		int node = cvmx_get_node_num();
-		return pki_dflt_pool[node].pool_num;
+		return pki_dflt_aura[node].aura_num;
 	}
 	return (cvmx_ipd_cfg.wqe_pool.pool_num);
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-pki.h b/arch/mips/include/asm/octeon/cvmx-pki.h
index 261fcc3..d521dfa 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki.h
@@ -248,6 +248,11 @@ struct cvmx_pki_qpg_config {
 	int  grp_bad;
 };
 
+struct cvmx_pki_aura_config {
+	int aura_num;
+	int pool_num;
+	int buffer_count;
+};
 
 /* This is per style structure for configuring port parameters, it is kind of of profile
    which can be assigned to any port. If multiple ports are assigned same style be aware
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3.h b/arch/mips/include/asm/octeon/cvmx-pko3.h
index 34630e5..4619b83 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2014  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -459,7 +459,6 @@ __cvmx_pko3_do_dma(uint8_t node, uint16_t dq, uint64_t cmds[],
 
 	/* build store data for DMA */
 	pko_send_dma_data.s.scraddr = scr_off >> 3;
-	pko_send_dma_data.s.rtnlen = 1;
 	pko_send_dma_data.s.did = 0x51;
 	pko_send_dma_data.s.node = node;
 	pko_send_dma_data.s.dqop = dqop;
@@ -495,6 +494,70 @@ __cvmx_pko3_do_dma(uint8_t node, uint16_t dq, uint64_t cmds[],
 	return pko_status;
 }
 
+/*
+ * Transmit simple packets through pko
+ *
+ * @INTERNAL
+ *
+ * @param dq is a global destination queue number 
+ * @param bptr specifies packet data virtual address
+ * @param len is the total packet len of the packet in bufptr.
+ * @param gaura is the aura to free packet buffers after trasnmit.
+ *
+ * @return returns 0 if successful and -1 on failure.
+ *
+ * This function is a short-cut, and is only useful for sending
+ * very simple packets that are all contained in a single buffer,
+ * do not require any type of completion notification.
+ * The virtual address pointer to packet data may be pointing
+ * to a buffer obtained from FPA, in which case the 'gaura'
+ * argument should contain the global AURA number where the buffer
+ * should be freed on completion. If the buffer does not need to be
+ * freed by PKO, specify 'gaura' as -1.
+ * Other features such as L3/L4 checksum calculation are not
+ * available via this function.
+ *
+ * NOTE: This is a provisional API, and is subject to change.
+ */
+static inline int
+cvmx_pko3_xmit_simple(int dq, void * bptr, unsigned len, int gaura)
+{
+	cvmx_pko_query_rtn_t pko_status;
+	cvmx_pko_send_hdr_t *hdr_s;
+	cvmx_pko_buf_ptr_t *gtr_s;
+	unsigned node;
+	uint64_t cmd[2];	/* minimal command: 2 words exactly */
+
+	/* Separa global DQ# into node and local DQ */
+	node = dq >> 10;
+	dq &= (1 << 10)-1;
+
+	/* Setup command word pointers */
+	hdr_s = (void *)&cmd[0];
+	gtr_s = (void *)&cmd[1];
+
+	/* Fill in header */
+	hdr_s->u64 = 0;
+	hdr_s->s.total = len;
+	hdr_s->s.df = (gaura < 0);
+	hdr_s->s.ii = 1;
+	hdr_s->s.aura = (gaura >= 0)? gaura: 0;
+
+	/* Fill in gather */
+	gtr_s->u64 = 0;
+	gtr_s->s.subdc3 = CVMX_PKO_SENDSUBDC_GATHER;
+	gtr_s->s.addr = cvmx_ptr_to_phys(bptr);
+	gtr_s->s.size = len;
+
+	/* Do LMTDMA */
+	pko_status = __cvmx_pko3_do_dma(node, dq, cmd, 2, CVMX_PKO_DQ_SEND);
+
+	if (cvmx_likely(pko_status.s.dqstatus == PKO_DQSTATUS_PASS))
+		return 0;
+	else
+		return -1;
+}
+
 /**
  * @INTERNAL
  *
@@ -566,21 +629,6 @@ int cvmx_pko3_hw_init_global(int node, uint16_t aura);
  */
 int cvmx_pko3_hw_disable(int node);
 
-#if 0 //deprecated
-/*
- * Transmit packets through pko on specified node and queue.
- *
- * @param dq is the queue to write the commands to.
- * @param bufptr specifies packet in linked or gather mode.
- * @param packet_len is the total packet len of the packet in bufptr.
- * @param aura_free is the aura to free packet buffers after trasnmit.
- * @return returns 0 if successful and -1 on failure.
- *
- * NOTE: This is a provisional API, and is subject to change.
- */
-int cvmx_pko_transmit_packet(int dq, cvmx_buf_ptr_pki_t bufptr,
-			     int packet_len, int aura_free);
-#endif
 
 /* Define legacy type here to break circular dependency */
 typedef struct cvmx_pko_port_status cvmx_pko_port_status_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-wqe.h b/arch/mips/include/asm/octeon/cvmx-wqe.h
index 9d7f73d..85a17bd 100644
--- a/arch/mips/include/asm/octeon/cvmx-wqe.h
+++ b/arch/mips/include/asm/octeon/cvmx-wqe.h
@@ -1011,7 +1011,7 @@ typedef struct {
 	/**
          * WORD 5/6/7 may be extended here if WQE_HSZ is set to !0
 	 */
-        uint64_t        wqe_data[10];
+        uint64_t        wqe_data[11];
 
 } CVMX_CACHE_LINE_ALIGNED cvmx_wqe_78xx_t;
 
diff --git a/arch/mips/include/asm/octeon/octeon-feature.h b/arch/mips/include/asm/octeon/octeon-feature.h
index e2dd056..28b6436 100644
--- a/arch/mips/include/asm/octeon/octeon-feature.h
+++ b/arch/mips/include/asm/octeon/octeon-feature.h
@@ -156,6 +156,8 @@ typedef enum {
 				/**<  Octeon has FPA first seen on 78XX */
 	OCTEON_FEATURE_CN78XX_WQE,
 				/**<  CN78XX has different fields in word0 - word2 */
+	OCTEON_FEATURE_PKO3,
+  				/**< Octeon has enhanced PKO block */
 	OCTEON_FEATURE_SPI,
 				/**< Octeon supports SPI interfaces */
 	OCTEON_FEATURE_ZIP3,
@@ -443,6 +445,11 @@ static inline int octeon_has_feature_OCTEON_FEATURE_PKI(void)
 	return (OCTEON_IS_MODEL(OCTEON_CN78XX));
 }
 
+static inline int octeon_has_feature_OCTEON_FEATURE_PKO3(void)
+{
+	return (OCTEON_IS_MODEL(OCTEON_CN78XX));
+}
+
 static inline int octeon_has_feature_OCTEON_FEATURE_OCLA(void)
 {
 	return (OCTEON_IS_MODEL(OCTEON_CN70XX)
-- 
2.6.2

