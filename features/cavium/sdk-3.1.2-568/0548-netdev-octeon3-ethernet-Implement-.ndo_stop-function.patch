From d96090d6e0564a20d5a0b399c410360cf6618b82 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 20 Feb 2014 13:46:59 -0800
Subject: [PATCH 548/974] netdev: octeon3-ethernet: Implement .ndo_stop
 function.

Now we can UP and DOWN the interface multiple times and it still
works.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/octeon/octeon-bgx-port.c  | 14 +++++++++-
 drivers/net/ethernet/octeon/octeon3-ethernet.c | 38 ++++++++++++++++++++++++++
 2 files changed, 51 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/octeon/octeon-bgx-port.c b/drivers/net/ethernet/octeon/octeon-bgx-port.c
index aaf8753..c572c4f 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-port.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-port.c
@@ -226,6 +226,17 @@ EXPORT_SYMBOL(bgx_port_enable);
 
 int bgx_port_disable(struct net_device *netdev)
 {
+	struct bgx_port_priv *priv = bgx_port_netdev2priv(netdev);
+	cvmx_helper_link_info_t link_info;
+
+	if (priv->phydev)
+		phy_disconnect(priv->phydev);
+	priv->phydev = NULL;
+
+	netif_carrier_off(netdev);
+	link_info.u64 = 0;
+	cvmx_helper_link_set(priv->ipd_port, link_info);
+
 	return 0;
 }
 EXPORT_SYMBOL(bgx_port_disable);
@@ -234,13 +245,14 @@ int bgx_port_change_mtu(struct net_device *netdev, int new_mtu)
 {
 	union cvmx_bgxx_cmrx_config cfg;
 	struct bgx_port_priv *priv = bgx_port_netdev2priv(netdev);
+	int max_frame;
 
 	if (new_mtu < 60 || new_mtu > 65392)
 		return -EINVAL;
 
 	netdev->mtu = new_mtu;
 
-	int max_frame = round_up(new_mtu + ETH_HLEN + ETH_FCS_LEN, 8);
+	max_frame = round_up(new_mtu + ETH_HLEN + ETH_FCS_LEN, 8);
 
 	cfg.u64 = cvmx_read_csr_node(priv->numa_node, CVMX_BGXX_CMRX_CONFIG(priv->index, priv->bgx_interface));
 	if (cfg.s.lmac_type == 0)
diff --git a/drivers/net/ethernet/octeon/octeon3-ethernet.c b/drivers/net/ethernet/octeon/octeon3-ethernet.c
index b7266fe..03e3efc 100644
--- a/drivers/net/ethernet/octeon/octeon3-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon3-ethernet.c
@@ -751,6 +751,43 @@ err:
 	return r;
 }
 
+static int octeon3_eth_ndo_stop(struct net_device *netdev)
+{
+	struct octeon3_ethernet *priv = netdev_priv(netdev);
+	void **w;
+	struct sk_buff *skb;
+	int r;
+
+	r = bgx_port_disable(netdev);
+	if (r)
+		goto err;
+
+	msleep(20);
+
+	/* Wait for SSO to drain */
+	while (cvmx_read_csr_node(priv->numa_node, CVMX_SSO_GRPX_AQ_CNT(priv->rx_grp)))
+		msleep(20);
+
+	octeon3_eth_sso_irq_set_armed(priv->numa_node, priv->rx_grp, false);
+
+	free_irq(priv->rx_irq, netdev);
+
+	msleep(20);
+
+	/* Free the packet buffers */
+	for (;;) {
+		w = cvmx_fpa3_alloc_aura(priv->numa_node, priv->pki_laura);
+		if (!w)
+			break;
+		skb = w[0];
+		dev_kfree_skb(skb);
+	}
+
+
+err:
+	return r;
+}
+
 static int octeon3_eth_ndo_start_xmit(struct sk_buff *skb, struct net_device *netdev)
 {
 	struct sk_buff *skb_tmp;
@@ -986,6 +1023,7 @@ static const struct net_device_ops octeon3_eth_netdev_ops = {
 	.ndo_init		= octeon3_eth_ndo_init,
 	.ndo_uninit		= octeon3_eth_ndo_uninit,
 	.ndo_open		= octeon3_eth_ndo_open,
+	.ndo_stop		= octeon3_eth_ndo_stop,
 	.ndo_start_xmit		= octeon3_eth_ndo_start_xmit,
 	.ndo_get_stats64	= octeon3_eth_ndo_get_stats64,
 	.ndo_set_rx_mode	= bgx_port_set_rx_filtering,
-- 
2.6.2

