From 0d0267eaa79a6e07305766e5f541617077d6972e Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Sun, 1 Sep 2013 16:27:46 -0700
Subject: [PATCH 289/974] MIPS/EDAC: Poll for all error bis in L2C_INT CSR.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/edac/octeon_edac-l2c.c | 49 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 49 insertions(+)

diff --git a/drivers/edac/octeon_edac-l2c.c b/drivers/edac/octeon_edac-l2c.c
index 8017604..b8ca36a 100644
--- a/drivers/edac/octeon_edac-l2c.c
+++ b/drivers/edac/octeon_edac-l2c.c
@@ -62,9 +62,58 @@ static void _octeon_l2c_poll_oct2(struct edac_device_ctl_info *l2c, int tad)
 {
 	union cvmx_l2c_err_tdtx err_tdtx, err_tdtx_reset;
 	union cvmx_l2c_err_ttgx err_ttgx, err_ttgx_reset;
+	union cvmx_l2c_int_reg l2c_int_reg;
+	bool l2c_clear = false;
 	char buf1[64];
 	char buf2[80];
 
+	/* Poll for L2C bigrd/bigwr/holewr/holerd */
+	l2c_int_reg.u64 = cvmx_read_csr(CVMX_L2C_INT_REG);
+	if (l2c_int_reg.s.bigrd) {
+		snprintf(buf1, sizeof(buf1),
+			"Read reference past L2C_BIG_CTL[MAXDRAM] occurred:");
+		l2c_clear = true;
+	}
+	if (l2c_int_reg.s.bigwr) {
+		snprintf(buf1, sizeof(buf1),
+			"Write reference past L2C_BIG_CTL[MAXDRAM] occurred:");
+		l2c_clear = true;
+	}
+	if (l2c_int_reg.s.vrtpe) {
+		snprintf(buf1, sizeof(buf1),
+			"L2C_VRT_MEM read found a parity error");
+		l2c_clear = true;
+	}
+	if (l2c_int_reg.s.vrtadrng) {
+		snprintf(buf1, sizeof(buf1),
+			"Address outside of virtualization range");
+		l2c_clear = true;
+	}
+	if (l2c_int_reg.s.vrtidrng) {
+		snprintf(buf1, sizeof(buf1),
+			"Virtualization ID out of range");
+		l2c_clear = true;
+	}
+	if (l2c_int_reg.s.vrtwr) {
+		snprintf(buf1, sizeof(buf1),
+			"Virtualization ID prevented a write");
+		l2c_clear = true;
+	}
+	if (l2c_int_reg.s.holewr) {
+		snprintf(buf1, sizeof(buf1),
+			"Write reference to 256MB hole occurred:");
+		l2c_clear = true;
+	}
+	if (l2c_int_reg.s.holerd) {
+		snprintf(buf1, sizeof(buf1),
+			"Read reference to 256MB hole occurred:");
+		l2c_clear = true;
+	}
+	if (l2c_clear) {
+		edac_device_handle_ce(l2c, tad, 1, buf1);
+		cvmx_write_csr(CVMX_L2C_INT_REG, l2c_int_reg.u64);
+	}
+
 	err_tdtx_reset.u64 = 0;
 	err_tdtx.u64 = cvmx_read_csr(CVMX_L2C_ERR_TDTX(tad));
 	if (err_tdtx.s.dbe || err_tdtx.s.sbe ||
-- 
2.6.2

