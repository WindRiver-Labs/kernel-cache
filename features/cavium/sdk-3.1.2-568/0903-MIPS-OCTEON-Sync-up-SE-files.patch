From 7710a75654c1d0d2fd8d6aeb8b1bd2ae9a7bf127 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Thu, 10 Jul 2014 18:05:50 -0700
Subject: [PATCH 903/974] MIPS:OCTEON: Sync up SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |   22 +-
 .../cavium-octeon/executive/cvmx-helper-board.c    |   19 +-
 .../cavium-octeon/executive/cvmx-helper-pko3.c     |    2 +
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |   10 +-
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |   44 +-
 arch/mips/include/asm/octeon/cvmx-app-init.h       |    6 +-
 arch/mips/include/asm/octeon/cvmx-fpa3.h           |    3 +-
 arch/mips/include/asm/octeon/cvmx-gpio-defs.h      |   16 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     |  279 +++-
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       |   16 +-
 arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h   | 1060 +++++++++------
 arch/mips/include/asm/octeon/cvmx-pciercx-defs.h   | 1350 ++++++++++++--------
 arch/mips/include/asm/octeon/cvmx-pemx-defs.h      |   36 +-
 arch/mips/include/asm/octeon/cvmx-qlm.h            |   12 +-
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |    8 +-
 15 files changed, 1917 insertions(+), 966 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 7f169c1..11264ce 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -1321,9 +1321,11 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 		use_training = 1;
 
 	/* Disable packet reception */
-	spu_misc_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, xi.interface));
+	spu_misc_control.u64 = cvmx_read_csr_node(node,
+						  CVMX_BGXX_SPUX_MISC_CONTROL(index, xi.interface));
 	spu_misc_control.s.rx_packet_dis = 1;
-	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, xi.interface), spu_misc_control.u64);
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_MISC_CONTROL(index, xi.interface),
+			    spu_misc_control.u64);
 
 	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM) {
 		cvmx_bgxx_spux_an_control_t spu_an_control;
@@ -1403,10 +1405,10 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 			}
 		}
 
-		if (mode == CVMX_HELPER_INTERFACE_MODE_XFI
-		    || mode == CVMX_HELPER_INTERFACE_MODE_XLAUI
-		    || mode == CVMX_HELPER_INTERFACE_MODE_10G_KR
-		    || mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4) {
+		if (mode == CVMX_HELPER_INTERFACE_MODE_XFI    ||
+		    mode == CVMX_HELPER_INTERFACE_MODE_XLAUI  ||
+		    mode == CVMX_HELPER_INTERFACE_MODE_10G_KR ||
+		    mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4) {
 			if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BR_STATUS1(index, xi.interface),
 					  cvmx_bgxx_spux_br_status1_t, blk_lock, ==, 1, 10000)) {
 				//cvmx_dprintf("ERROR: %d:BGX%d:%d: BASE-R PCS block not locked\n", node, interface, index);
@@ -1549,16 +1551,16 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_xaui_link_get(int xipd_port)
 	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, xi.interface));
 	smu_rx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_RX_CTL(index, xi.interface));
 
-	if ((smu_tx_ctl.s.ls == 0)
-	    && (smu_rx_ctl.s.status == 0)
-	    && (spu_status1.s.rcv_lnk)) {
+	if ((smu_tx_ctl.s.ls == 0)     &&
+	    (smu_rx_ctl.s.status == 0) &&
+	    (spu_status1.s.rcv_lnk)) {
 		int lanes;
 		int qlm = cvmx_qlm_interface(xiface);
 		uint64_t speed;
 		cvmx_helper_interface_mode_t mode;
 		result.s.link_up = 1;
 		result.s.full_duplex = 1;
-		speed = cvmx_qlm_get_gbaud_mhz(qlm);
+		speed = cvmx_qlm_get_gbaud_mhz_node(node, qlm);
 		mode = cvmx_helper_interface_get_mode(xiface);
 		lanes = 4 / cvmx_helper_ports_on_interface(xiface);
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
index 9c6a6a2..9a60f66 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
@@ -470,6 +470,20 @@ static void __cvmx_mdio_addr_to_node_bus(uint64_t addr, int *node, int *bus)
 				    __func__, (unsigned long long) addr);
 			break;
 		}
+	} else if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		switch (addr) {
+		case 0x0001180000003800:
+			*bus = 0;
+			break;
+		case 0x0001180000003880:
+			*bus = 1;
+			break;
+		default:
+			*bus = -1;
+			cvmx_printf("%s: Invalid SMI bus address 0x%llx\n",
+				    __func__, (unsigned long long) addr);
+			break;
+		}
 	} else {
 		switch (addr) {
 		case 0x0001180000001800:
@@ -1842,9 +1856,8 @@ __get_marvell_phy_link_state(cvmx_phy_info_t *phy_info)
 			phy_status |= 1 << 11;
 	}
 
-	/* Only return a link if the PHY has finished auto negotiation
-	   and set the resolved bit (bit 11) */
-	if (phy_status & (1 << 11)) {
+	/* Link is up = Speed/Duplex Resolved + RT-Link Up + G-Link Up. */
+	if ((phy_status & 0x0c08) == 0x0c08) {
 		result.s.link_up = 1;
 		result.s.full_duplex = ((phy_status >> 13) & 1);
 		switch ((phy_status >> 14) & 3) {
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index fe7abab..aaf4ffe 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -223,6 +223,8 @@ static int __cvmx_pko3_config_chan_interface( int xiface, unsigned num_chans,
 
 	if (num_queues == 0)
 		num_queues = 1;
+	if ((cvmx_pko3_num_level_queues(CVMX_PKO_DESCR_QUEUES) / num_chans) < 3)
+		num_queues = 1;
 
 	if (prioritized && num_queues > 1)
 		prio = num_queues;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index ee3fee3..52caee3 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 118139 $<hr>
+ * <hr>$Revision: 121092 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1721,8 +1721,12 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		}
 	}
 
-	/* Set Octeon's BAR0 to decode 0-16KB. It overlaps with Bar2 */
-	CVMX_WRITE_CSR(CVMX_PEMX_P2N_BAR0_START(pcie_port), 0);
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		/* Disable Octeon's BAR0. We can't waste 8MB of address space */
+		CVMX_WRITE_CSR(CVMX_PEMX_P2N_BAR0_START(pcie_port), -1);
+	else
+		/* Set Octeon's BAR0 to decode 0-16KB. It overlaps with Bar2 */
+		CVMX_WRITE_CSR(CVMX_PEMX_P2N_BAR0_START(pcie_port), 0);
 
 	/* Set Octeon's BAR2 to decode 0-2^41. Bar0 and Bar1 take precedence
 	 * where they overlap. It also overlaps with the device addresses, so
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index b93dec6..c8cf9ef 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 120751 $<hr>
+ * <hr>$Revision: 121402 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1706,6 +1706,12 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 			else
 				qlm_mode[qlm] = CVMX_QLM_MODE_DISABLED;
 			break;
+		case 0x33:
+			if (mux == 1)
+				qlm_mode[qlm] = CVMX_QLM_MODE_XFI_1X2;
+			else
+				qlm_mode[qlm] = CVMX_QLM_MODE_DISABLED;
+			break;
 		case 0x0035:
 			if (mux == 0)
 				qlm_mode[qlm] = CVMX_QLM_MODE_MIXED;
@@ -1851,14 +1857,22 @@ enum cvmx_qlm_mode cvmx_qlm_get_mode(int qlm)
 	return CVMX_QLM_MODE_DISABLED;
 }
 
-int cvmx_qlm_measure_clock_cn78xx(int node, int qlm)
+int cvmx_qlm_measure_clock_cn7xxx(int node, int qlm)
 {
 	cvmx_gserx_cfg_t cfg;
 	cvmx_gserx_refclk_sel_t refclk_sel;
 	cvmx_gserx_lane_mode_t lane_mode;
 
-	if (qlm >= 8)
-		return -1; /* FIXME for OCI */
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		if (node != 0 || qlm >= 7)
+			return -1;
+	} else if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+		if (qlm >= 8 || node > 1)
+			return -1; /* FIXME for OCI */
+	} else {
+		cvmx_dprintf("%s: Unsupported OCTEON model\n", __func__);
+		return -1;
+	}
 
 	cfg.u64 = cvmx_read_csr_node(node, CVMX_GSERX_CFG(qlm));
 
@@ -1902,12 +1916,28 @@ int cvmx_qlm_measure_clock_cn78xx(int node, int qlm)
 }
 
 /**
+ * Measure the reference clock of a QLM on a multi-node setup
+ *
+ * @param node   node to measure
+ * @param qlm    QLM to measure
+ *
+ * @return Clock rate in Hz
+ */
+int cvmx_qlm_measure_clock_node(int node, int qlm)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_MULTINODE))
+		return cvmx_qlm_measure_clock_cn7xxx(node, qlm);
+	else
+		return cvmx_qlm_measure_clock(qlm);
+}
+
+/**
  * Measure the reference clock of a QLM
  *
  * @param qlm    QLM to measure
  *
  * @return Clock rate in Hz
- *       */
+ */
 int cvmx_qlm_measure_clock(int qlm)
 {
 	cvmx_mio_ptp_clock_cfg_t ptp_clock;
@@ -1927,8 +1957,8 @@ int cvmx_qlm_measure_clock(int qlm)
 	if (OCTEON_IS_MODEL(OCTEON_CN3XXX) || OCTEON_IS_MODEL(OCTEON_CN5XXX))
 		return -1;
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
-		return cvmx_qlm_measure_clock_cn78xx(cvmx_get_node_num(), qlm);
+	if (OCTEON_IS_OCTEON3() && !OCTEON_IS_MODEL(OCTEON_CN70XX))
+		return cvmx_qlm_measure_clock_cn7xxx(cvmx_get_node_num(), qlm);
 
 	/* Force the reference to 156.25Mhz when running in simulation.
 	   This supports the most speeds */
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index 5d46843..07e4628 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -41,7 +41,7 @@
  * @file
  * Header file for simple executive application initialization.  This defines
  * part of the ABI between the bootloader and the application.
- * <hr>$Revision: 119392 $<hr>
+ * <hr>$Revision: 121038 $<hr>
  *
  */
 
@@ -291,6 +291,8 @@ enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_SFF7800 = 73,	/* Embedded Planet board */
 	CVMX_BOARD_TYPE_WAVE2 = 74,
 	CVMX_BOARD_TYPE_NIAGARA830 = 75,
+	CVMX_BOARD_TYPE_EBB7304 = 76,
+	CVMX_BOARD_TYPE_NIC73 = 77,	/* Liquid I/O */
 	CVMX_BOARD_TYPE_MAX,
 	/* NOTE:  256-257 are being used by a customer. */
 
@@ -434,6 +436,8 @@ static inline const char *cvmx_board_type_to_string(enum cvmx_board_types_enum t
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_SFF7800)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_WAVE2)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIAGARA830)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB7304)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC73)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
 
 		/* Customer boards listed here */
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa3.h b/arch/mips/include/asm/octeon/cvmx-fpa3.h
index 483c3ee..adcd43e 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa3.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa3.h
@@ -42,7 +42,7 @@
  *
  * Interface to the CN78XX Free Pool Allocator, a.k.a. FPA3
  *
- * <hr>$Revision: 114431 $<hr>
+ * <hr>$Revision: 121389 $<hr>
  *
  */
 
@@ -671,6 +671,7 @@ extern int cvmx_fpa3_shutdown_aura_and_pool(cvmx_fpa3_gaura_t aura);
 extern int cvmx_fpa3_shutdown_aura(cvmx_fpa3_gaura_t aura);
 extern int cvmx_fpa3_shutdown_pool(cvmx_fpa3_pool_t pool);
 extern const char *cvmx_fpa3_get_pool_name(cvmx_fpa3_pool_t pool);
+extern int cvmx_fpa3_get_pool_buf_size(cvmx_fpa3_pool_t pool);
 extern const char *cvmx_fpa3_get_aura_name(cvmx_fpa3_gaura_t aura);
 
 #ifdef CVMX_BUILD_FOR_UBOOT
diff --git a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
index b0c12cf..d058df9 100644
--- a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
@@ -392,7 +392,9 @@ union cvmx_gpio_bit_cfgx {
                                                          Zero to disable the filter. */
 	uint64_t int_type                     : 1;  /**< Type of interrupt when pin is an input and [INT_EN] set. When set, rising edge interrupt,
                                                          else level interrupt. Only valid for GPIO 0..15, no function for GPIO 16..31. */
-	uint64_t int_en                       : 1;  /**< Enable interrupt generated by this pin. Only valid for GPIO 0..15, no function for GPIO 16..31. */
+	uint64_t int_en                       : 1;  /**< GPIO_BIT_CFG()[INT_EN] enable interrupts going to GPIO_INTR()[INTR] as well as
+                                                         GPIO_MC_INTR(4..7)[INTR]. When GPIO_INTR()[INT_TYPE] is level interrupt,
+                                                         changing  GPIO_INTR()[INT_EN] to zero will cause GPIO_INTR()[INTR] to be cleared. */
 	uint64_t rx_xor                       : 1;  /**< Receive inversion. When set to 1, inverts the received GPIO signal. */
 	uint64_t tx_oe                        : 1;  /**< Transmit output enable. When set to 1, the GPIO pin is driven as an output pin. */
 #else
@@ -779,14 +781,14 @@ union cvmx_gpio_comp {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_11_63               : 53;
 	uint64_t pctl                         : 3;  /**< GPIO bus driver PCTL. Suggested values:
-                                                         0x4 = 75 ohm.
-                                                         0x6 = 50 ohm.
-                                                         0x7 = 40 ohm. */
+                                                         0x4 = 60 ohm.
+                                                         0x6 = 40 ohm.
+                                                         0x7 = 30 ohm. */
 	uint64_t reserved_3_7                 : 5;
 	uint64_t nctl                         : 3;  /**< GPIO bus driver NCTL. Suggested values:
-                                                         0x4 = 75 ohm.
-                                                         0x6 = 50 ohm.
-                                                         0x7 = 40 ohm. */
+                                                         0x4 = 60 ohm.
+                                                         0x6 = 40 ohm.
+                                                         0x7 = 30 ohm. */
 #else
 	uint64_t nctl                         : 3;
 	uint64_t reserved_3_7                 : 5;
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index c7578b8..2147f6c 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -535,10 +535,56 @@ static inline uint64_t CVMX_GSERX_EQ_WAIT_TIME(unsigned long offset)
 #define CVMX_GSERX_EQ_WAIT_TIME(offset) (CVMX_ADD_IO_SEG(0x00011800904E0000ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-static inline uint64_t CVMX_GSERX_GLBL_PLL_CFG_3(unsigned long offset)
+static inline uint64_t CVMX_GSERX_GLBL_MISC_CONFIG_1(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
+		cvmx_warn("CVMX_GSERX_GLBL_MISC_CONFIG_1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090460030ull) + ((offset) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_GLBL_MISC_CONFIG_1(offset) (CVMX_ADD_IO_SEG(0x0001180090460030ull) + ((offset) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_GLBL_PLL_CFG_0(unsigned long offset)
 {
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_GLBL_PLL_CFG_0(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090460000ull) + ((offset) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_GLBL_PLL_CFG_0(offset) (CVMX_ADD_IO_SEG(0x0001180090460000ull) + ((offset) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_GLBL_PLL_CFG_1(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_GLBL_PLL_CFG_1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090460008ull) + ((offset) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_GLBL_PLL_CFG_1(offset) (CVMX_ADD_IO_SEG(0x0001180090460008ull) + ((offset) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_GLBL_PLL_CFG_2(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_GLBL_PLL_CFG_2(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x0001180090460010ull) + ((offset) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_GLBL_PLL_CFG_2(offset) (CVMX_ADD_IO_SEG(0x0001180090460010ull) + ((offset) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_GLBL_PLL_CFG_3(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 8)))))
 		cvmx_warn("CVMX_GSERX_GLBL_PLL_CFG_3(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001180090460018ull) + ((offset) & 15) * 0x1000000ull;
 }
@@ -1921,6 +1967,19 @@ static inline uint64_t CVMX_GSERX_RX_PWR_CTRL_P2(unsigned long offset)
 #define CVMX_GSERX_RX_PWR_CTRL_P2(offset) (CVMX_ADD_IO_SEG(0x00011800904600B8ull) + ((offset) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_RX_TXDIR_CTRL_1(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 6))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 13))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 13)))))
+		cvmx_warn("CVMX_GSERX_RX_TXDIR_CTRL_1(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800904600F0ull) + ((offset) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_RX_TXDIR_CTRL_1(offset) (CVMX_ADD_IO_SEG(0x00011800904600F0ull) + ((offset) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SATA_CFG(unsigned long offset)
 {
 	if (!(
@@ -3551,6 +3610,182 @@ union cvmx_gserx_eq_wait_time {
 typedef union cvmx_gserx_eq_wait_time cvmx_gserx_eq_wait_time_t;
 
 /**
+ * cvmx_gser#_glbl_misc_config_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_glbl_misc_config_1 {
+	uint64_t u64;
+	struct cvmx_gserx_glbl_misc_config_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t pcs_sds_vref_tr              : 4;  /**< Trim the BGR (Band Gap Reference) reference (all external and internal currents
+                                                         are affected).
+                                                         For diagnostic use only. */
+	uint64_t pcs_sds_trim_chp_reg         : 2;  /**< Trim current going to CML-CMOS stage at output of VCO.
+                                                         For diagnostic use only. */
+	uint64_t pcs_sds_vco_reg_tr           : 2;  /**< Trims regulator voltage.
+                                                         For diagnostic use only. */
+	uint64_t pcs_sds_cvbg_en              : 1;  /**< Forces 0.6 V from VDDHV onto VBG node.
+                                                         For diagnostic use only. */
+	uint64_t pcs_sds_extvbg_en            : 1;  /**< Force external VBG through AMON pin in TMA5 mode.
+                                                         For diagnostic use only. */
+#else
+	uint64_t pcs_sds_extvbg_en            : 1;
+	uint64_t pcs_sds_cvbg_en              : 1;
+	uint64_t pcs_sds_vco_reg_tr           : 2;
+	uint64_t pcs_sds_trim_chp_reg         : 2;
+	uint64_t pcs_sds_vref_tr              : 4;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_gserx_glbl_misc_config_1_s cn78xx;
+	struct cvmx_gserx_glbl_misc_config_1_s cn78xxp2;
+	struct cvmx_gserx_glbl_misc_config_1_s cnf75xx;
+};
+typedef union cvmx_gserx_glbl_misc_config_1 cvmx_gserx_glbl_misc_config_1_t;
+
+/**
+ * cvmx_gser#_glbl_pll_cfg_0
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_glbl_pll_cfg_0 {
+	uint64_t u64;
+	struct cvmx_gserx_glbl_pll_cfg_0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t pcs_sds_pll_vco_reset_b      : 1;  /**< VCO reset, active low.
+                                                         For diagnostic use only. */
+	uint64_t pcs_sds_pll_strt_cal_b       : 1;  /**< Start PLL calibration, active low.
+                                                         For diagnostic use only. */
+	uint64_t pcs_sds_pll_cripple          : 1;  /**< Ripple capacitor tuning.
+                                                         For diagnostic use only. */
+	uint64_t reserved_8_10                : 3;
+	uint64_t pcs_sds_pll_fthresh          : 2;  /**< PLL frequency comparison threshold.
+                                                         For diagnostic use only. */
+	uint64_t reserved_0_5                 : 6;
+#else
+	uint64_t reserved_0_5                 : 6;
+	uint64_t pcs_sds_pll_fthresh          : 2;
+	uint64_t reserved_8_10                : 3;
+	uint64_t pcs_sds_pll_cripple          : 1;
+	uint64_t pcs_sds_pll_strt_cal_b       : 1;
+	uint64_t pcs_sds_pll_vco_reset_b      : 1;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_gserx_glbl_pll_cfg_0_s    cn78xx;
+	struct cvmx_gserx_glbl_pll_cfg_0_s    cn78xxp2;
+};
+typedef union cvmx_gserx_glbl_pll_cfg_0 cvmx_gserx_glbl_pll_cfg_0_t;
+
+/**
+ * cvmx_gser#_glbl_pll_cfg_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_glbl_pll_cfg_1 {
+	uint64_t u64;
+	struct cvmx_gserx_glbl_pll_cfg_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t cfg_pll_ctrl_en              : 1;  /**< PLL reset control enable.
+                                                         0 = PLL RESETs/cal start are not active.
+                                                         1 = All PLL RESETs/cal start are enabled.
+                                                         For diagnostic use only. */
+	uint64_t pcs_sds_pll_calmode          : 3;  /**< PLL calibration mode.
+                                                         0 = Force PLL loop into calibration mode.
+                                                         1 = Normal operation.
+                                                         For diagnostic use only. */
+	uint64_t pcs_sds_pll_cal_ovrd_en      : 1;  /**< Manual PLL coarse calibration override enable.
+                                                         For diagnostic use only. */
+	uint64_t pcs_sds_pll_cal_ovrd         : 5;  /**< Manual PLL coarse calibration override value.
+                                                         For diagnostic use only. */
+#else
+	uint64_t pcs_sds_pll_cal_ovrd         : 5;
+	uint64_t pcs_sds_pll_cal_ovrd_en      : 1;
+	uint64_t pcs_sds_pll_calmode          : 3;
+	uint64_t cfg_pll_ctrl_en              : 1;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_gserx_glbl_pll_cfg_1_s    cn78xx;
+	struct cvmx_gserx_glbl_pll_cfg_1_s    cn78xxp2;
+};
+typedef union cvmx_gserx_glbl_pll_cfg_1 cvmx_gserx_glbl_pll_cfg_1_t;
+
+/**
+ * cvmx_gser#_glbl_pll_cfg_2
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_glbl_pll_cfg_2 {
+	uint64_t u64;
+	struct cvmx_gserx_glbl_pll_cfg_2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t pll_div_ovrrd_en             : 1;  /**< Override Global Power state machine and mac_pcs_pll_div control signal.
+                                                         When asserted, pcs_sds_pll_div is specified from
+                                                         GSER()_LANE()_PCS_PLL_CTLIFC_0[PLL_DIV_OVRRD_VAL],
+                                                         global power state machine and mac_pcs_pll_div control signals are ignored.
+                                                         For diagnostic use only. */
+	uint64_t reserved_10_13               : 4;
+	uint64_t pcs_sds_pll_lock_override    : 1;  /**< Not used.
+                                                         For diagnostic use only. */
+	uint64_t pcs_sds_pll_counter_resetn   : 1;  /**< Not used.
+                                                         For diagnostic use only. */
+	uint64_t pll_sdsck_pd_ovrrd_val       : 1;  /**< Clock tree powerdown override value.
+                                                         For diagnostic use only. */
+	uint64_t pll_sdsck_pd_ovrrd_en        : 1;  /**< Clock tree powerdown override enable.
+                                                         For diagnostic use only. */
+	uint64_t pll_pd_ovrrd_val             : 1;  /**< PLL powerdown override value.
+                                                         For diagnostic use only. */
+	uint64_t pll_pd_ovrrd_en              : 1;  /**< When asserted, overrides PLL powerdown from state machine.
+                                                         For diagnostic use only. */
+	uint64_t pcs_sds_pll_div5_byp         : 1;  /**< Not used.
+                                                         For diagnostic use only. */
+	uint64_t pll_band_sel_ovrrd_val       : 1;  /**< State machine override value for VCO band select.
+                                                         0 = Low band VCO0 (RO-VCO).
+                                                         1 = High band VCO1 (LC-VCO).
+                                                         For diagnostic use only. */
+	uint64_t pll_band_sel_ovrrd_en        : 1;  /**< PLL band select override enable.
+                                                         For diagnostic use only. */
+	uint64_t pll_pcs_div_ovrrd_en         : 1;  /**< Override global power state machine and mac_pcs_pll_div control signal.
+                                                         When asserted, pcs_sds_pll_div is specified from
+                                                         GSER()_LANE()_PCS_PLL_CTLIFC_1[PLL_PCS_DIV_OVRRD_VAL],
+                                                         global power state machine and mac_pcs_pll_div control signals are ignored.
+                                                         For diagnostic use only. */
+#else
+	uint64_t pll_pcs_div_ovrrd_en         : 1;
+	uint64_t pll_band_sel_ovrrd_en        : 1;
+	uint64_t pll_band_sel_ovrrd_val       : 1;
+	uint64_t pcs_sds_pll_div5_byp         : 1;
+	uint64_t pll_pd_ovrrd_en              : 1;
+	uint64_t pll_pd_ovrrd_val             : 1;
+	uint64_t pll_sdsck_pd_ovrrd_en        : 1;
+	uint64_t pll_sdsck_pd_ovrrd_val       : 1;
+	uint64_t pcs_sds_pll_counter_resetn   : 1;
+	uint64_t pcs_sds_pll_lock_override    : 1;
+	uint64_t reserved_10_13               : 4;
+	uint64_t pll_div_ovrrd_en             : 1;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_glbl_pll_cfg_2_s    cn78xx;
+	struct cvmx_gserx_glbl_pll_cfg_2_s    cn78xxp2;
+};
+typedef union cvmx_gserx_glbl_pll_cfg_2 cvmx_gserx_glbl_pll_cfg_2_t;
+
+/**
  * cvmx_gser#_glbl_pll_cfg_3
  *
  * These registers are for diagnostic use only.
@@ -3590,6 +3825,7 @@ union cvmx_gserx_glbl_pll_cfg_3 {
 	} s;
 	struct cvmx_gserx_glbl_pll_cfg_3_s    cn78xx;
 	struct cvmx_gserx_glbl_pll_cfg_3_s    cn78xxp2;
+	struct cvmx_gserx_glbl_pll_cfg_3_s    cnf75xx;
 };
 typedef union cvmx_gserx_glbl_pll_cfg_3 cvmx_gserx_glbl_pll_cfg_3_t;
 
@@ -8258,6 +8494,47 @@ union cvmx_gserx_rx_pwr_ctrl_p2 {
 typedef union cvmx_gserx_rx_pwr_ctrl_p2 cvmx_gserx_rx_pwr_ctrl_p2_t;
 
 /**
+ * cvmx_gser#_rx_txdir_ctrl_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_rx_txdir_ctrl_1 {
+	uint64_t u64;
+	struct cvmx_gserx_rx_txdir_ctrl_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t rx_precorr_chg_dir           : 1;  /**< When asserted, the default direction output for the far-end TX Pre is reversed. */
+	uint64_t rx_tap1_chg_dir              : 1;  /**< When asserted, the default direction output for the far-end TX Post is reversed. */
+	uint64_t rx_tap1_hi_thrs              : 5;  /**< The high threshold for the local RX Tap1 count.
+                                                         The far-end TX POST direction output, pcs_mac_rx_txpost_dir,
+                                                         is set to INCREMENT if the local RX tap1 value from the VMA (after RX-EQ)
+                                                         is higher than this value, and the local RX boost value is higher than
+                                                         its high threshold (RX_BOOST_HI_THRS). Note that if RX_TAP1_CHG_DIR is asserted,
+                                                         then the direction is DECREMENT. */
+	uint64_t rx_tap1_lo_thrs              : 5;  /**< The low threshold for the local RX Tap1 count.
+                                                         The far-end TX POST direction output, pcs_mac_rx_txpost_dir,
+                                                         is set to DECREMENT if the local RX tap1 value from the VMA (after RX-EQ)
+                                                         is lower than this value, and the local RX boost value is lower than
+                                                         its low threshold (RX_BOOST_LO_THRS). Note that if RX_TAP1_CHG_DIR is asserted,
+                                                         then the direction is INCREMENT. */
+#else
+	uint64_t rx_tap1_lo_thrs              : 5;
+	uint64_t rx_tap1_hi_thrs              : 5;
+	uint64_t rx_tap1_chg_dir              : 1;
+	uint64_t rx_precorr_chg_dir           : 1;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_gserx_rx_txdir_ctrl_1_s   cn73xx;
+	struct cvmx_gserx_rx_txdir_ctrl_1_s   cn78xx;
+	struct cvmx_gserx_rx_txdir_ctrl_1_s   cn78xxp2;
+	struct cvmx_gserx_rx_txdir_ctrl_1_s   cnf75xx;
+};
+typedef union cvmx_gserx_rx_txdir_ctrl_1 cvmx_gserx_rx_txdir_ctrl_1_t;
+
+/**
  * cvmx_gser#_sata_cfg
  *
  * SATA Config Enable.
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index 9dbbad5..896f06f 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -3389,10 +3389,10 @@ union cvmx_mio_boot_pin_defs {
 	uint64_t dmack_p1                     : 1;  /**< BOOT_DMACK<1> default polarity. */
 	uint64_t dmack_p0                     : 1;  /**< BOOT_DMACK<0> default polarity. */
 	uint64_t term                         : 2;  /**< Selects default boot-bus driver termination.
-                                                         0x0 = full strength.
-                                                         0x1 = 25ohm.
-                                                         0x2 = 50ohm.
-                                                         0x3 = 65ohm. */
+                                                         0x0 = 40 ohm (full strength).
+                                                         0x1 = 30 ohm.
+                                                         0x2 = 60 ohm.
+                                                         0x3 = 60 ohm. */
 	uint64_t user0                        : 9;  /**< BOOT_AD<8:0> latched during power up. */
 #else
 	uint64_t user0                        : 9;
@@ -3443,10 +3443,10 @@ union cvmx_mio_boot_pin_defs {
 	uint64_t dmack_p1                     : 1;  /**< BOOT_DMACK<1> default polarity. */
 	uint64_t dmack_p0                     : 1;  /**< BOOT_DMACK<0> default polarity. */
 	uint64_t term                         : 2;  /**< Selects default boot-bus driver termination.
-                                                         0x0 = full strength.
-                                                         0x1 = 25ohm.
-                                                         0x2 = 50ohm.
-                                                         0x3 = 65ohm. */
+                                                         0x0 = 40 ohm (full strength).
+                                                         0x1 = 30 ohm.
+                                                         0x2 = 60 ohm.
+                                                         0x3 = 60 ohm. */
 	uint64_t user0                        : 9;  /**< BOOT_AD<8:0> latched during power up. */
 #else
 	uint64_t user0                        : 9;
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index 5eef519..8752c4f 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -57,14 +57,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000000ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000000ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000000ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000000ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000000ull + ((offset) & 3) * 0x100000000ull;
@@ -84,17 +87,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG000 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000000ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000000ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG000(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000000ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000000ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000000ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000000ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -115,14 +119,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000004ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000004ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000004ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000004ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000004ull + ((offset) & 3) * 0x100000000ull;
@@ -142,17 +149,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG001 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000004ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000004ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG001(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000004ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000004ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000004ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000004ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -173,14 +181,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000008ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000008ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000008ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000008ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000008ull + ((offset) & 3) * 0x100000000ull;
@@ -200,17 +211,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG002 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000008ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000008ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG002(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000008ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000008ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000008ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000008ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -231,14 +243,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000000Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000000Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000000Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000000Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000000Cull + ((offset) & 3) * 0x100000000ull;
@@ -258,17 +273,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG003 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000000Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000000Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG003(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000000Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000000Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000000Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000000Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -289,14 +305,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000010ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000010ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000010ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000010ull + ((offset) & 3) * 0x100000000ull;
@@ -316,17 +335,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG004 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000010ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000010ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG004(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000010ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -347,14 +367,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030080000010ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030080000010ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030080000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030080000010ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030080000010ull + ((offset) & 3) * 0x100000000ull;
@@ -374,17 +397,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG004_MASK (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030080000010ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030080000010ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG004_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000010ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -405,14 +429,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000014ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000014ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000014ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000014ull + ((offset) & 3) * 0x100000000ull;
@@ -432,17 +459,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG005 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000014ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000014ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG005(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000014ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -463,14 +491,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030080000014ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030080000014ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030080000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030080000014ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030080000014ull + ((offset) & 3) * 0x100000000ull;
@@ -490,17 +521,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG005_MASK (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030080000014ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030080000014ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG005_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000014ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -521,14 +553,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000018ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000018ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000018ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000018ull + ((offset) & 3) * 0x100000000ull;
@@ -548,17 +583,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG006 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000018ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000018ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG006(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000018ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -579,14 +615,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030080000018ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030080000018ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030080000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030080000018ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030080000018ull + ((offset) & 3) * 0x100000000ull;
@@ -606,17 +645,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG006_MASK (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030080000018ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030080000018ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG006_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000018ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -637,14 +677,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000001Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000001Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000001Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000001Cull + ((offset) & 3) * 0x100000000ull;
@@ -664,17 +707,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG007 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000001Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000001Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG007(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000001Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -695,14 +739,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003008000001Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003008000001Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003008000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003008000001Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003008000001Cull + ((offset) & 3) * 0x100000000ull;
@@ -722,17 +769,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG007_MASK (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003008000001Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003008000001Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG007_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003008000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003008000001Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003008000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003008000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -753,14 +801,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000020ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000020ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000020ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000020ull + ((offset) & 3) * 0x100000000ull;
@@ -780,17 +831,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG008 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000020ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000020ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG008(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000020ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -811,14 +863,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030080000020ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030080000020ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030080000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030080000020ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030080000020ull + ((offset) & 3) * 0x100000000ull;
@@ -838,17 +893,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG008_MASK (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030080000020ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030080000020ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG008_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000020ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -869,14 +925,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000024ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000024ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000024ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000024ull + ((offset) & 3) * 0x100000000ull;
@@ -896,17 +955,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG009 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000024ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000024ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG009(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000024ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -927,14 +987,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030080000024ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030080000024ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030080000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030080000024ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030080000024ull + ((offset) & 3) * 0x100000000ull;
@@ -954,17 +1017,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG009_MASK (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030080000024ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030080000024ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG009_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000024ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -985,14 +1049,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000028ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000028ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000028ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000028ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000028ull + ((offset) & 3) * 0x100000000ull;
@@ -1012,17 +1079,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG010 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000028ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000028ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG010(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000028ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000028ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000028ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000028ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1043,14 +1111,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000002Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000002Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000002Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000002Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000002Cull + ((offset) & 3) * 0x100000000ull;
@@ -1070,17 +1141,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG011 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000002Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000002Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG011(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000002Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000002Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000002Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000002Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1101,14 +1173,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000030ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000030ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000030ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000030ull + ((offset) & 3) * 0x100000000ull;
@@ -1128,17 +1203,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG012 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000030ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000030ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG012(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000030ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1159,14 +1235,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030080000030ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030080000030ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030080000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030080000030ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030080000030ull + ((offset) & 3) * 0x100000000ull;
@@ -1186,17 +1265,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG012_MASK (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030080000030ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030080000030ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG012_MASK(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000030ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030080000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030080000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1217,14 +1297,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000034ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000034ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000034ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000034ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000034ull + ((offset) & 3) * 0x100000000ull;
@@ -1244,17 +1327,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG013 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000034ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000034ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG013(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000034ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000034ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000034ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000034ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1275,14 +1359,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000003Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000003Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000003Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000003Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000003Cull + ((offset) & 3) * 0x100000000ull;
@@ -1302,17 +1389,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG015 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000003Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000003Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG015(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000003Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000003Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000003Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000003Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1333,14 +1421,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000040ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000040ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000040ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000040ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000040ull + ((offset) & 3) * 0x100000000ull;
@@ -1360,17 +1451,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG016 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000040ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000040ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG016(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000040ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000040ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000040ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000040ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1391,14 +1483,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000044ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000044ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000044ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000044ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000044ull + ((offset) & 3) * 0x100000000ull;
@@ -1418,17 +1513,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG017 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000044ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000044ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG017(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000044ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000044ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000044ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000044ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1449,14 +1545,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000050ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000050ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000050ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000050ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000050ull + ((offset) & 3) * 0x100000000ull;
@@ -1476,17 +1575,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG020 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000050ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000050ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG020(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000050ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000050ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000050ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000050ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1507,14 +1607,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000054ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000054ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000054ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000054ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000054ull + ((offset) & 3) * 0x100000000ull;
@@ -1534,17 +1637,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG021 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000054ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000054ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG021(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000054ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000054ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000054ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000054ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1565,14 +1669,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000058ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000058ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000058ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000058ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000058ull + ((offset) & 3) * 0x100000000ull;
@@ -1592,17 +1699,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG022 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000058ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000058ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG022(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000058ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000058ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000058ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000058ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1623,14 +1731,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000005Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000005Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000005Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000005Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000005Cull + ((offset) & 3) * 0x100000000ull;
@@ -1650,17 +1761,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG023 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000005Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000005Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG023(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000005Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000005Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000005Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000005Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1683,7 +1795,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG024(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG024(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000060ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -1697,7 +1809,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG025(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG025(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000064ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -1709,14 +1821,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000070ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000070ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000070ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000070ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000070ull + ((offset) & 3) * 0x100000000ull;
@@ -1736,17 +1851,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG028 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000070ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000070ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG028(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000070ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000070ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000070ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000070ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1767,14 +1883,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000074ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000074ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000074ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000074ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000074ull + ((offset) & 3) * 0x100000000ull;
@@ -1794,17 +1913,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG029 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000074ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000074ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG029(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000074ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000074ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000074ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000074ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1825,14 +1945,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000078ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000078ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000078ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000078ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000078ull + ((offset) & 3) * 0x100000000ull;
@@ -1852,17 +1975,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG030 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000078ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000078ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG030(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000078ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000078ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000078ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000078ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1883,14 +2007,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000007Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000007Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000007Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000007Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000007Cull + ((offset) & 3) * 0x100000000ull;
@@ -1910,17 +2037,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG031 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000007Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000007Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG031(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000007Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000007Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000007Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000007Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -1941,14 +2069,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000080ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000080ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000080ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000080ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000080ull + ((offset) & 3) * 0x100000000ull;
@@ -1968,17 +2099,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG032 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000080ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000080ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG032(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000080ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000080ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000080ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000080ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2025,14 +2157,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000094ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000094ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000094ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000094ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000094ull + ((offset) & 3) * 0x100000000ull;
@@ -2052,17 +2187,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG037 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000094ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000094ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG037(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000094ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000094ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000094ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000094ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2083,14 +2219,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000098ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000098ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000098ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000098ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000098ull + ((offset) & 3) * 0x100000000ull;
@@ -2110,17 +2249,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG038 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000098ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000098ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG038(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000098ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000098ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000098ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000098ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2141,14 +2281,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000009Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000009Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000009Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000009Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000009Cull + ((offset) & 3) * 0x100000000ull;
@@ -2168,17 +2311,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG039 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000009Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000009Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG039(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000009Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000009Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000009Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000009Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2199,14 +2343,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x00000300000000A0ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x00000300000000A0ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x00000300000000A0ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x00000300000000A0ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x00000300000000A0ull + ((offset) & 3) * 0x100000000ull;
@@ -2226,17 +2373,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG040 (offset = %lu) not supported on this chip\n", offset);
-	return 0x00000300000000A0ull + ((offset) & 7) * 0x100000000ull;
+	return 0x00000300000000A0ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG040(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x00000300000000A0ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x00000300000000A0ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x00000300000000A0ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x00000300000000A0ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2284,7 +2432,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG044(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG044(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000000B0ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -2297,7 +2445,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG045(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG045(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000000B4ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -2310,7 +2458,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG046(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG046(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000000B8ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -2322,14 +2470,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000100ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000100ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000100ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000100ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000100ull + ((offset) & 3) * 0x100000000ull;
@@ -2349,17 +2500,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG064 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000100ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000100ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG064(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000100ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000100ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000100ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000100ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2380,14 +2532,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000104ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000104ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000104ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000104ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000104ull + ((offset) & 3) * 0x100000000ull;
@@ -2407,17 +2562,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG065 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000104ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000104ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG065(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000104ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000104ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000104ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000104ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2438,14 +2594,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000108ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000108ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000108ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000108ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000108ull + ((offset) & 3) * 0x100000000ull;
@@ -2465,17 +2624,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG066 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000108ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000108ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG066(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000108ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000108ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000108ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000108ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2496,14 +2656,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000010Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000010Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000010Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000010Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000010Cull + ((offset) & 3) * 0x100000000ull;
@@ -2523,17 +2686,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG067 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000010Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000010Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG067(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000010Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000010Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000010Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000010Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2554,14 +2718,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000110ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000110ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000110ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000110ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000110ull + ((offset) & 3) * 0x100000000ull;
@@ -2581,17 +2748,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG068 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000110ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000110ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG068(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000110ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000110ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000110ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000110ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2612,14 +2780,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000114ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000114ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000114ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000114ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000114ull + ((offset) & 3) * 0x100000000ull;
@@ -2639,17 +2810,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG069 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000114ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000114ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG069(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000114ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000114ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000114ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000114ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2670,14 +2842,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000118ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000118ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000118ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000118ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000118ull + ((offset) & 3) * 0x100000000ull;
@@ -2697,17 +2872,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG070 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000118ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000118ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG070(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000118ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000118ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000118ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000118ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2728,14 +2904,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000011Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000011Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000011Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000011Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000011Cull + ((offset) & 3) * 0x100000000ull;
@@ -2755,17 +2934,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG071 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000011Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000011Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG071(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000011Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000011Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000011Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000011Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2786,14 +2966,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000120ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000120ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000120ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000120ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000120ull + ((offset) & 3) * 0x100000000ull;
@@ -2813,17 +2996,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG072 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000120ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000120ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG072(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000120ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000120ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000120ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000120ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2844,14 +3028,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000124ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000124ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000124ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000124ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000124ull + ((offset) & 3) * 0x100000000ull;
@@ -2871,17 +3058,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG073 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000124ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000124ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG073(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000124ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000124ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000124ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000124ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2902,14 +3090,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000128ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000128ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000128ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000128ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000128ull + ((offset) & 3) * 0x100000000ull;
@@ -2929,17 +3120,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG074 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000128ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000128ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG074(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000128ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000128ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000128ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000128ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -2961,7 +3153,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG078(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG078(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000138ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -2975,7 +3167,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG082(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG082(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000148ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -2989,7 +3181,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG083(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG083(%lu) is invalid on this chip\n", offset);
 	return 0x000003000000014Cull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3013,7 +3205,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG086(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG086(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000158ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3026,7 +3218,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG087(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG087(%lu) is invalid on this chip\n", offset);
 	return 0x000003000000015Cull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3039,7 +3231,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG088(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG088(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000160ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3052,7 +3244,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG089(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG089(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000164ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3065,7 +3257,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG090(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG090(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000168ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3078,7 +3270,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG091(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG091(%lu) is invalid on this chip\n", offset);
 	return 0x000003000000016Cull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3091,7 +3283,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG092(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG092(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000170ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3104,7 +3296,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG094(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG094(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000178ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3117,7 +3309,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG095(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG095(%lu) is invalid on this chip\n", offset);
 	return 0x000003000000017Cull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3130,7 +3322,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG096(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG096(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000180ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3143,7 +3335,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG097(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG097(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000184ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3156,7 +3348,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG098(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG098(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000188ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3169,7 +3361,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG099(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG099(%lu) is invalid on this chip\n", offset);
 	return 0x000003000000018Cull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3182,7 +3374,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG100(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG100(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000190ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3195,7 +3387,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG101(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG101(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000194ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3208,7 +3400,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG102(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG102(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000198ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3221,7 +3413,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG103(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG103(%lu) is invalid on this chip\n", offset);
 	return 0x000003000000019Cull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3234,7 +3426,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG104(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG104(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000001A0ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3247,7 +3439,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG105(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG105(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000001A4ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3260,7 +3452,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG106(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG106(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000001A8ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3273,7 +3465,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG107(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG107(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000001ACull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3286,7 +3478,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG108(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG108(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000001B0ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3299,7 +3491,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG109(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG109(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000001B4ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3312,7 +3504,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG110(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG110(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000001B8ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3325,7 +3517,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG111(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG111(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000001BCull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3338,7 +3530,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG112(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG112(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000001C0ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -3350,14 +3542,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000700ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000700ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000700ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000700ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000700ull + ((offset) & 3) * 0x100000000ull;
@@ -3377,17 +3572,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG448 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000700ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000700ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG448(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000700ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000700ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000700ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000700ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3408,14 +3604,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000704ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000704ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000704ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000704ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000704ull + ((offset) & 3) * 0x100000000ull;
@@ -3435,17 +3634,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG449 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000704ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000704ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG449(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000704ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000704ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000704ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000704ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3466,14 +3666,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000708ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000708ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000708ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000708ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000708ull + ((offset) & 3) * 0x100000000ull;
@@ -3493,17 +3696,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG450 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000708ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000708ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG450(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000708ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000708ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000708ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000708ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3524,14 +3728,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000070Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000070Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000070Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000070Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000070Cull + ((offset) & 3) * 0x100000000ull;
@@ -3551,17 +3758,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG451 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000070Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000070Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG451(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000070Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000070Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000070Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000070Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3582,14 +3790,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000710ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000710ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000710ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000710ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000710ull + ((offset) & 3) * 0x100000000ull;
@@ -3609,17 +3820,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG452 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000710ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000710ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG452(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000710ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000710ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000710ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000710ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3640,14 +3852,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000714ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000714ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000714ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000714ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000714ull + ((offset) & 3) * 0x100000000ull;
@@ -3667,17 +3882,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG453 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000714ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000714ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG453(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000714ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000714ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000714ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000714ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3698,14 +3914,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000718ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000718ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000718ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000718ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000718ull + ((offset) & 3) * 0x100000000ull;
@@ -3725,17 +3944,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG454 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000718ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000718ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG454(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000718ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000718ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000718ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000718ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3756,14 +3976,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000071Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000071Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000071Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000071Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000071Cull + ((offset) & 3) * 0x100000000ull;
@@ -3783,17 +4006,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG455 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000071Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000071Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG455(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000071Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000071Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000071Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000071Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3814,14 +4038,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000720ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000720ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000720ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000720ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000720ull + ((offset) & 3) * 0x100000000ull;
@@ -3841,17 +4068,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG456 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000720ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000720ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG456(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000720ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000720ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000720ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000720ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3872,14 +4100,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000728ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000728ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000728ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000728ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000728ull + ((offset) & 3) * 0x100000000ull;
@@ -3899,17 +4130,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG458 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000728ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000728ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG458(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000728ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000728ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000728ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000728ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3930,14 +4162,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000072Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000072Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000072Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000072Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000072Cull + ((offset) & 3) * 0x100000000ull;
@@ -3957,17 +4192,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG459 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000072Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000072Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG459(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000072Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000072Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000072Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000072Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -3988,14 +4224,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000730ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000730ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000730ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000730ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000730ull + ((offset) & 3) * 0x100000000ull;
@@ -4015,17 +4254,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG460 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000730ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000730ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG460(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000730ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000730ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000730ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000730ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4046,14 +4286,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000734ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000734ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000734ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000734ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000734ull + ((offset) & 3) * 0x100000000ull;
@@ -4073,17 +4316,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG461 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000734ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000734ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG461(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000734ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000734ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000734ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000734ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4104,14 +4348,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000738ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000738ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000738ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000738ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000738ull + ((offset) & 3) * 0x100000000ull;
@@ -4131,17 +4378,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG462 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000738ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000738ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG462(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000738ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000738ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000738ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000738ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4162,14 +4410,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000073Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000073Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000073Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000073Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000073Cull + ((offset) & 3) * 0x100000000ull;
@@ -4189,17 +4440,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG463 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000073Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000073Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG463(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000073Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000073Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000073Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000073Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4220,14 +4472,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000740ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000740ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000740ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000740ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000740ull + ((offset) & 3) * 0x100000000ull;
@@ -4247,17 +4502,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG464 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000740ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000740ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG464(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000740ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000740ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000740ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000740ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4278,14 +4534,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000744ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000744ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000744ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000744ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000744ull + ((offset) & 3) * 0x100000000ull;
@@ -4305,17 +4564,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG465 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000744ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000744ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG465(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000744ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000744ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000744ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000744ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4336,14 +4596,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000748ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000748ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000748ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000748ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000748ull + ((offset) & 3) * 0x100000000ull;
@@ -4363,17 +4626,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG466 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000748ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000748ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG466(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000748ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000748ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000748ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000748ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4394,14 +4658,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x000003000000074Cull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000003000000074Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000003000000074Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x000003000000074Cull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x000003000000074Cull + ((offset) & 3) * 0x100000000ull;
@@ -4421,17 +4688,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG467 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000074Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000074Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG467(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000074Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000074Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000074Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000074Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4452,14 +4720,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000750ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000750ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000750ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000750ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000750ull + ((offset) & 3) * 0x100000000ull;
@@ -4479,17 +4750,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG468 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000750ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000750ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG468(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000750ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000750ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000750ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000750ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4646,6 +4918,9 @@ static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long offset)
 				return 0x000003000000080Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000003000000080Cull + ((offset) & 1) * 0x100000000ull;
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 5))
 				return 0x000003000000080Cull + ((offset) & 7) * 0x100000000ull;
@@ -4664,7 +4939,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG515 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000003000000080Cull + ((offset) & 7) * 0x100000000ull;
+	return 0x000003000000080Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long offset)
@@ -4673,6 +4948,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG515(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000080Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return 0x000003000000080Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x000003000000080Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
@@ -4692,14 +4968,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000810ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000810ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000810ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000810ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000810ull + ((offset) & 3) * 0x100000000ull;
@@ -4719,17 +4998,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG516 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000810ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000810ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG516(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000810ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000810ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000810ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000810ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4750,14 +5030,17 @@ static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 5))
-				return 0x0000030000000814ull + ((offset) & 7) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000030000000814ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000030000000814ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 5))
+				return 0x0000030000000814ull + ((offset) & 7) * 0x100000000ull;
+			break;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
 				return 0x0000030000000814ull + ((offset) & 3) * 0x100000000ull;
@@ -4777,17 +5060,18 @@ static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIEEPX_CFG517 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000030000000814ull + ((offset) & 7) * 0x100000000ull;
+	return 0x0000030000000814ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIEEPX_CFG517(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000814ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000814ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000030000000814ull + (offset) * 0x100000000ull;
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000030000000814ull + (offset) * 0x100000000ull;
 		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
@@ -4809,7 +5093,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG548(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG548(%lu) is invalid on this chip\n", offset);
 	return 0x0000030000000890ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -4822,7 +5106,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG554(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG554(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000008A8ull + ((offset) & 7) * 0x100000000ull;
 }
@@ -4835,7 +5119,7 @@ static inline uint64_t CVMX_PCIEEPX_CFG558(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 5))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 5)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIEEPX_CFG558(%lu) is invalid on this chip\n", offset);
 	return 0x00000300000008B8ull + ((offset) & 7) * 0x100000000ull;
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
index ca0da01..6dcc4ed 100644
--- a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
@@ -57,15 +57,18 @@ static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000000ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000000ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000000ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000000ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -78,18 +81,19 @@ static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG000 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000000ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000000ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG000(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000000ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000000ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000000ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -107,15 +111,18 @@ static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000004ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000004ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000004ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000004ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -128,18 +135,19 @@ static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG001 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000004ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000004ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG001(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000004ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000004ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000004ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -157,15 +165,18 @@ static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000008ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000008ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000008ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000008ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -178,18 +189,19 @@ static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG002 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000008ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000008ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG002(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000008ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000008ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000008ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -207,15 +219,18 @@ static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000000Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000000Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000000Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000000Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -228,18 +243,19 @@ static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG003 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000000Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000000Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG003(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000000Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000000Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000000Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -257,15 +273,18 @@ static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000010ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000010ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000010ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000010ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -278,18 +297,19 @@ static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG004 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000010ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000010ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG004(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000010ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000010ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -307,15 +327,18 @@ static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000014ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000014ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000014ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000014ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -328,18 +351,19 @@ static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG005 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000014ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000014ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG005(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000014ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000014ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -357,15 +381,18 @@ static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000018ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000018ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000018ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000018ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -378,18 +405,19 @@ static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG006 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000018ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000018ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG006(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000018ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000018ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -407,15 +435,18 @@ static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000001Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000001Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000001Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000001Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -428,18 +459,19 @@ static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG007 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000001Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000001Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG007(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000001Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000001Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -457,15 +489,18 @@ static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000020ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000020ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000020ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000020ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -478,18 +513,19 @@ static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG008 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000020ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000020ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG008(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000020ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000020ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -507,15 +543,18 @@ static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000024ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000024ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000024ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000024ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -528,18 +567,19 @@ static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG009 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000024ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000024ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG009(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000024ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000024ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -557,15 +597,18 @@ static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000028ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000028ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000028ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000028ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -578,18 +621,19 @@ static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG010 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000028ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000028ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG010(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000028ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000028ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000028ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -607,15 +651,18 @@ static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000002Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000002Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000002Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000002Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -628,18 +675,19 @@ static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG011 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000002Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000002Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG011(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000002Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000002Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000002Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -657,15 +705,18 @@ static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000030ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000030ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000030ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000030ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -678,18 +729,19 @@ static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG012 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000030ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000030ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG012(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000030ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000030ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -707,15 +759,18 @@ static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000034ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000034ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000034ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000034ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -728,18 +783,19 @@ static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG013 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000034ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000034ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG013(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000034ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000034ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000034ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -757,15 +813,18 @@ static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000038ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000038ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000038ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000038ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -778,18 +837,19 @@ static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG014 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000038ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000038ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG014(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000038ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000038ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000038ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -807,15 +867,18 @@ static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000003Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000003Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000003Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000003Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -828,18 +891,19 @@ static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG015 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000003Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000003Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG015(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000003Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000003Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000003Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -857,15 +921,18 @@ static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000040ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000040ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000040ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000040ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -878,18 +945,19 @@ static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG016 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000040ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000040ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG016(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000040ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000040ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000040ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -907,15 +975,18 @@ static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000044ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000044ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000044ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000044ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -928,18 +999,19 @@ static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG017 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000044ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000044ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG017(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000044ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000044ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000044ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -957,15 +1029,18 @@ static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000050ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000050ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000050ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000050ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -978,18 +1053,19 @@ static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG020 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000050ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000050ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG020(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000050ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000050ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000050ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1007,15 +1083,18 @@ static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000054ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000054ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000054ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000054ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1028,18 +1107,19 @@ static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG021 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000054ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000054ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG021(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000054ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000054ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000054ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1057,15 +1137,18 @@ static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000058ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000058ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000058ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000058ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1078,18 +1161,19 @@ static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG022 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000058ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000058ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG022(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000058ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000058ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000058ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1107,15 +1191,18 @@ static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000005Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000005Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000005Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000005Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1128,18 +1215,19 @@ static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG023 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000005Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000005Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG023(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000005Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000005Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000005Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1157,15 +1245,18 @@ static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000070ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000070ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000070ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000070ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1178,18 +1269,19 @@ static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG028 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000070ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000070ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG028(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000070ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000070ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000070ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1207,15 +1299,18 @@ static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000074ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000074ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000074ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000074ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1228,18 +1323,19 @@ static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG029 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000074ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000074ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG029(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000074ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000074ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000074ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1257,15 +1353,18 @@ static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000078ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000078ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000078ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000078ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1278,18 +1377,19 @@ static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG030 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000078ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000078ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG030(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000078ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000078ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000078ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1307,15 +1407,18 @@ static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000007Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000007Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000007Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000007Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1328,18 +1431,19 @@ static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG031 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000007Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000007Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG031(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000007Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000007Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000007Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1357,15 +1461,18 @@ static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000080ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000080ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000080ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000080ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1378,18 +1485,19 @@ static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG032 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000080ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000080ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG032(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000080ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000080ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000080ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1407,15 +1515,18 @@ static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000084ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000084ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000084ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000084ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1428,18 +1539,19 @@ static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG033 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000084ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000084ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG033(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000084ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000084ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000084ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1457,15 +1569,18 @@ static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000088ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000088ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000088ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000088ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1478,18 +1593,19 @@ static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG034 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000088ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000088ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG034(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000088ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000088ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000088ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1507,15 +1623,18 @@ static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000008Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000008Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000008Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000008Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1528,18 +1647,19 @@ static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG035 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000008Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000008Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG035(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000008Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000008Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000008Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1557,15 +1677,18 @@ static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000090ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000090ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000090ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000090ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1578,18 +1701,19 @@ static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG036 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000090ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000090ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG036(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000090ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000090ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000090ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1607,15 +1731,18 @@ static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000094ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000094ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000094ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000094ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1628,18 +1755,19 @@ static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG037 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000094ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000094ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG037(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000094ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000094ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000094ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1657,15 +1785,18 @@ static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000098ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000098ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000098ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000098ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1678,18 +1809,19 @@ static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG038 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000098ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000098ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG038(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000098ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000098ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000098ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1707,15 +1839,18 @@ static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000009Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000009Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000009Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000009Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1728,18 +1863,19 @@ static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG039 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000009Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000009Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG039(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000009Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000009Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000009Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1757,15 +1893,18 @@ static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x00000200000000A0ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x00000200000000A0ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x00000200000000A0ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x00000200000000A0ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1778,18 +1917,19 @@ static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG040 (offset = %lu) not supported on this chip\n", offset);
-	return 0x00000200000000A0ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000200000000A0ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG040(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A0ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A0ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x00000200000000A0ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1807,15 +1947,18 @@ static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x00000200000000A4ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x00000200000000A4ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x00000200000000A4ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x00000200000000A4ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1828,18 +1971,19 @@ static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG041 (offset = %lu) not supported on this chip\n", offset);
-	return 0x00000200000000A4ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000200000000A4ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG041(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A4ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A4ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x00000200000000A4ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1857,15 +2001,18 @@ static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x00000200000000A8ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x00000200000000A8ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x00000200000000A8ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x00000200000000A8ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1878,18 +2025,19 @@ static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG042 (offset = %lu) not supported on this chip\n", offset);
-	return 0x00000200000000A8ull + ((offset) & 3) * 0x100000000ull;
+	return 0x00000200000000A8ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG042(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A8ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x00000200000000A8ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x00000200000000A8ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1908,7 +2056,7 @@ static inline uint64_t CVMX_PCIERCX_CFG044(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG044(%lu) is invalid on this chip\n", offset);
 	return 0x00000200000000B0ull + ((offset) & 3) * 0x100000000ull;
 }
@@ -1921,7 +2069,7 @@ static inline uint64_t CVMX_PCIERCX_CFG045(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG045(%lu) is invalid on this chip\n", offset);
 	return 0x00000200000000B4ull + ((offset) & 3) * 0x100000000ull;
 }
@@ -1934,7 +2082,7 @@ static inline uint64_t CVMX_PCIERCX_CFG046(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG046(%lu) is invalid on this chip\n", offset);
 	return 0x00000200000000B8ull + ((offset) & 3) * 0x100000000ull;
 }
@@ -1946,15 +2094,18 @@ static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000100ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000100ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000100ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000100ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1967,18 +2118,19 @@ static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG064 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000100ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000100ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG064(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000100ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000100ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000100ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -1996,15 +2148,18 @@ static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000104ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000104ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000104ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000104ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2017,18 +2172,19 @@ static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG065 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000104ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000104ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG065(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000104ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000104ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000104ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2046,15 +2202,18 @@ static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000108ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000108ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000108ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000108ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2067,18 +2226,19 @@ static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG066 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000108ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000108ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG066(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000108ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000108ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000108ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2096,15 +2256,18 @@ static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000010Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000010Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000010Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000010Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2117,18 +2280,19 @@ static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG067 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000010Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000010Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG067(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000010Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000010Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000010Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2146,15 +2310,18 @@ static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000110ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000110ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000110ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000110ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2167,18 +2334,19 @@ static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG068 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000110ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000110ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG068(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000110ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000110ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000110ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2196,15 +2364,18 @@ static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000114ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000114ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000114ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000114ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2217,18 +2388,19 @@ static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG069 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000114ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000114ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG069(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000114ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000114ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000114ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2246,15 +2418,18 @@ static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000118ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000118ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000118ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000118ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2267,18 +2442,19 @@ static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG070 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000118ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000118ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG070(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000118ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000118ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000118ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2296,15 +2472,18 @@ static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000011Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000011Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000011Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000011Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2317,18 +2496,19 @@ static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG071 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000011Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000011Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG071(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000011Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000011Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000011Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2346,15 +2526,18 @@ static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000120ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000120ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000120ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000120ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2367,18 +2550,19 @@ static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG072 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000120ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000120ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG072(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000120ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000120ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000120ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2396,15 +2580,18 @@ static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000124ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000124ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000124ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000124ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2417,18 +2604,19 @@ static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG073 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000124ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000124ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG073(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000124ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000124ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000124ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2446,15 +2634,18 @@ static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000128ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000128ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000128ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000128ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2467,18 +2658,19 @@ static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG074 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000128ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000128ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG074(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000128ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000128ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000128ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2496,15 +2688,18 @@ static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000012Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000012Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000012Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000012Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2517,18 +2712,19 @@ static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG075 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000012Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000012Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG075(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000012Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000012Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000012Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2546,15 +2742,18 @@ static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000130ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000130ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000130ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000130ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2567,18 +2766,19 @@ static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG076 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000130ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000130ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG076(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000130ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000130ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000130ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2596,15 +2796,18 @@ static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000134ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000134ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000134ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000134ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2617,18 +2820,19 @@ static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG077 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000134ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000134ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG077(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000134ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000134ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000134ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2647,7 +2851,7 @@ static inline uint64_t CVMX_PCIERCX_CFG086(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG086(%lu) is invalid on this chip\n", offset);
 	return 0x0000020000000158ull + ((offset) & 3) * 0x100000000ull;
 }
@@ -2660,7 +2864,7 @@ static inline uint64_t CVMX_PCIERCX_CFG087(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG087(%lu) is invalid on this chip\n", offset);
 	return 0x000002000000015Cull + ((offset) & 3) * 0x100000000ull;
 }
@@ -2673,7 +2877,7 @@ static inline uint64_t CVMX_PCIERCX_CFG088(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG088(%lu) is invalid on this chip\n", offset);
 	return 0x0000020000000160ull + ((offset) & 3) * 0x100000000ull;
 }
@@ -2686,7 +2890,7 @@ static inline uint64_t CVMX_PCIERCX_CFG089(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG089(%lu) is invalid on this chip\n", offset);
 	return 0x0000020000000164ull + ((offset) & 3) * 0x100000000ull;
 }
@@ -2699,7 +2903,7 @@ static inline uint64_t CVMX_PCIERCX_CFG090(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG090(%lu) is invalid on this chip\n", offset);
 	return 0x0000020000000168ull + ((offset) & 3) * 0x100000000ull;
 }
@@ -2712,7 +2916,7 @@ static inline uint64_t CVMX_PCIERCX_CFG091(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG091(%lu) is invalid on this chip\n", offset);
 	return 0x000002000000016Cull + ((offset) & 3) * 0x100000000ull;
 }
@@ -2725,7 +2929,7 @@ static inline uint64_t CVMX_PCIERCX_CFG092(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG092(%lu) is invalid on this chip\n", offset);
 	return 0x0000020000000170ull + ((offset) & 3) * 0x100000000ull;
 }
@@ -2737,15 +2941,18 @@ static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000700ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000700ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000700ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000700ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2758,18 +2965,19 @@ static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG448 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000700ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000700ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG448(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000700ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000700ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000700ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2787,15 +2995,18 @@ static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000704ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000704ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000704ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000704ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2808,18 +3019,19 @@ static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG449 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000704ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000704ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG449(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000704ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000704ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000704ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2837,15 +3049,18 @@ static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000708ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000708ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000708ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000708ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2858,18 +3073,19 @@ static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG450 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000708ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000708ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG450(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000708ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000708ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000708ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2887,15 +3103,18 @@ static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000070Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000070Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000070Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000070Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2908,18 +3127,19 @@ static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG451 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000070Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000070Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG451(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000070Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000070Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000070Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2937,15 +3157,18 @@ static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000710ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000710ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000710ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000710ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2958,18 +3181,19 @@ static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG452 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000710ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000710ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000710ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000710ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000710ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -2985,17 +3209,20 @@ static inline uint64_t CVMX_PCIERCX_CFG452(unsigned long offset)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long offset)
 {
-	switch(cvmx_get_octeon_family()) {
-		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000714ull + ((offset) & 3) * 0x100000000ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x0000020000000714ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000714ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000714ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3008,18 +3235,19 @@ static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG453 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000714ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000714ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG453(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000714ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000714ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000714ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3037,15 +3265,18 @@ static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000718ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000718ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000718ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000718ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3058,18 +3289,19 @@ static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG454 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000718ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000718ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG454(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000718ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000718ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000718ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3087,15 +3319,18 @@ static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000071Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000071Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000071Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000071Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3108,18 +3343,19 @@ static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG455 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000071Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000071Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG455(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000071Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000071Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000071Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3137,15 +3373,18 @@ static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000720ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000720ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000720ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000720ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3158,18 +3397,19 @@ static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG456 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000720ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000720ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG456(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000720ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000720ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000720ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3187,15 +3427,18 @@ static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000728ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000728ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000728ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000728ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3208,18 +3451,19 @@ static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG458 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000728ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000728ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG458(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000728ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000728ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000728ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3237,15 +3481,18 @@ static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000072Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000072Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000072Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000072Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3258,18 +3505,19 @@ static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG459 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000072Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000072Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG459(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000072Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000072Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000072Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3287,15 +3535,18 @@ static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000730ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000730ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000730ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000730ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3308,18 +3559,19 @@ static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG460 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000730ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000730ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG460(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000730ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000730ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000730ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3337,15 +3589,18 @@ static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000734ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000734ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000734ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000734ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3358,18 +3613,19 @@ static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG461 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000734ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000734ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG461(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000734ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000734ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000734ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3387,15 +3643,18 @@ static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000738ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000738ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000738ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000738ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3408,18 +3667,19 @@ static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG462 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000738ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000738ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG462(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000738ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000738ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000738ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3437,15 +3697,18 @@ static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000073Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000073Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000073Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000073Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3458,18 +3721,19 @@ static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG463 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000073Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000073Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG463(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000073Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000073Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000073Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3487,15 +3751,18 @@ static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000740ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000740ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000740ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000740ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3508,18 +3775,19 @@ static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG464 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000740ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000740ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG464(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000740ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000740ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000740ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3537,15 +3805,18 @@ static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000744ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000744ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000744ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000744ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3558,18 +3829,19 @@ static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG465 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000744ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000744ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG465(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000744ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000744ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000744ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3587,15 +3859,18 @@ static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000748ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000748ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000748ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000748ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3608,18 +3883,19 @@ static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG466 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000748ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000748ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG466(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000748ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000748ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000748ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3637,15 +3913,18 @@ static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x000002000000074Cull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x000002000000074Cull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x000002000000074Cull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x000002000000074Cull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3658,18 +3937,19 @@ static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG467 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000074Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000074Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG467(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000074Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000074Cull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000074Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3687,15 +3967,18 @@ static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000750ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000750ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000750ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000750ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3708,18 +3991,19 @@ static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG468 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000750ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000750ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG468(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000750ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000750ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000750ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3861,6 +4145,9 @@ static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long offset)
 				return 0x000002000000080Cull + ((offset) & 3) * 0x100000000ull;
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return 0x000002000000080Cull + ((offset) & 1) * 0x100000000ull;
+			break;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 3))
@@ -3876,7 +4163,7 @@ static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG515 (offset = %lu) not supported on this chip\n", offset);
-	return 0x000002000000080Cull + ((offset) & 3) * 0x100000000ull;
+	return 0x000002000000080Cull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long offset)
@@ -3885,6 +4172,7 @@ static inline uint64_t CVMX_PCIERCX_CFG515(unsigned long offset)
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000080Cull + (offset) * 0x100000000ull;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+			return 0x000002000000080Cull + (offset) * 0x100000000ull;
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x000002000000080Cull + (offset) * 0x100000000ull;
@@ -3903,15 +4191,18 @@ static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000810ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000810ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000810ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000810ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3924,18 +4215,19 @@ static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG516 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000810ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000810ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG516(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000810ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000810ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000810ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3953,15 +4245,18 @@ static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			if ((offset <= 3))
-				return 0x0000020000000814ull + ((offset) & 3) * 0x100000000ull;
+			if ((offset <= 1))
+				return 0x0000020000000814ull + ((offset) & 1) * 0x100000000ull;
 			break;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			if ((offset <= 2))
 				return 0x0000020000000814ull + ((offset) & 3) * 0x100000000ull;
 			break;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return 0x0000020000000814ull + ((offset) & 3) * 0x100000000ull;
+			break;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -3974,18 +4269,19 @@ static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long offset)
 			break;
 	}
 	cvmx_warn("CVMX_PCIERCX_CFG517 (offset = %lu) not supported on this chip\n", offset);
-	return 0x0000020000000814ull + ((offset) & 3) * 0x100000000ull;
+	return 0x0000020000000814ull + ((offset) & 1) * 0x100000000ull;
 }
 #else
 static inline uint64_t CVMX_PCIERCX_CFG517(unsigned long offset)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000814ull + (offset) * 0x100000000ull;
 		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
 			return 0x0000020000000814ull + (offset) * 0x100000000ull;
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return 0x0000020000000814ull + (offset) * 0x100000000ull;
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN56XX & OCTEON_FAMILY_MASK:
@@ -4004,7 +4300,7 @@ static inline uint64_t CVMX_PCIERCX_CFG548(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG548(%lu) is invalid on this chip\n", offset);
 	return 0x0000020000000890ull + ((offset) & 3) * 0x100000000ull;
 }
@@ -4017,7 +4313,7 @@ static inline uint64_t CVMX_PCIERCX_CFG554(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG554(%lu) is invalid on this chip\n", offset);
 	return 0x00000200000008A8ull + ((offset) & 3) * 0x100000000ull;
 }
@@ -4030,7 +4326,7 @@ static inline uint64_t CVMX_PCIERCX_CFG558(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_PCIERCX_CFG558(%lu) is invalid on this chip\n", offset);
 	return 0x00000200000008B8ull + ((offset) & 3) * 0x100000000ull;
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
index df0e2fd..7639b8a 100644
--- a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
@@ -2968,8 +2968,8 @@ union cvmx_pemx_ecc_ena {
 	uint64_t qhdr_b0_ena                  : 1;  /**< ECC enable for Core's Q HDR Bank0 RAM. */
 	uint64_t rtry_ena                     : 1;  /**< ECC enable for Core's RETRY RA. */
 	uint64_t reserved_11_31               : 21;
-	uint64_t m2s_c_ena                    : 1;  /**< ECC enable for M2S Control FIFO. */
-	uint64_t m2s_d_ena                    : 1;  /**< ECC enable for M2S Data FIFO. */
+	uint64_t m2s_c_ena                    : 1;  /**< Not supported. */
+	uint64_t m2s_d_ena                    : 1;  /**< Not supported. */
 	uint64_t c_c_ena                      : 1;  /**< ECC enable for TLP CPL control FIFO. */
 	uint64_t c_d1_ena                     : 1;  /**< ECC enable for TLP CPL data1 FIFO. */
 	uint64_t c_d0_ena                     : 1;  /**< ECC enable for TLP CPL data0 FIFO. */
@@ -3098,8 +3098,8 @@ union cvmx_pemx_ecc_synd_ctrl {
 	uint64_t qhdr_b0_syn                  : 2;  /**< Syndrome flip bits for Core's Q HDR Bank0 RAM. */
 	uint64_t rtry_syn                     : 2;  /**< Syndrome flip bits for Core's RETRY RAM. */
 	uint64_t reserved_22_31               : 10;
-	uint64_t m2s_c_syn                    : 2;  /**< Syndrome flip bits for M2S Control FIFO. */
-	uint64_t m2s_d_syn                    : 2;  /**< Syndrome flip bits for M2S Data FIFO. */
+	uint64_t m2s_c_syn                    : 2;  /**< Not supported. */
+	uint64_t m2s_d_syn                    : 2;  /**< Not supported. */
 	uint64_t c_c_syn                      : 2;  /**< Syndrome flip bits for TLP CPL control FIFO. */
 	uint64_t c_d1_syn                     : 2;  /**< Syndrome flip bits for TLP CPL data1 FIFO. */
 	uint64_t c_d0_syn                     : 2;  /**< Syndrome flip bits for TLP CPL data0 FIFO. */
@@ -4254,7 +4254,33 @@ union cvmx_pemx_strap {
 #endif
 	} cn78xx;
 	struct cvmx_pemx_strap_cn78xx         cn78xxp2;
-	struct cvmx_pemx_strap_cn73xx         cnf75xx;
+	struct cvmx_pemx_strap_cnf75xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t miopem2dlm5sel               : 1;  /**< The value of the BOOT_AD[13] pin via MIO, which is captured on chip cold reset. It is not
+                                                         affected by any other reset.  Only used for PEM2.  When set, PEM2 is configured to
+                                                         DLM5 and PEM()_QLM[PEMDLMSEL] will be set, the Mac will be confifgured for 2 lanes.
+                                                         When clear, PEM2 is configured to QLM2. */
+	uint64_t pilaneswap                   : 1;  /**< The value of the pi_select_laneswap pin, which is captured on chip cold reset. It is not
+                                                         affected by any other reset.  When set, lane swapping is performed to/from the
+                                                         SerDes. When clear, no lane swapping is performed. */
+	uint64_t pilanes4                     : 1;  /**< The value of the pi_select_4lanes pin, which is captured on chip cold reset. It is not
+                                                         affected by any other reset.  When set, the PEM is configured for a maximum of
+                                                         4-lanes, When clear, the PEM is configured for a maximum of 2-lanes. */
+	uint64_t pimode                       : 2;  /**< The value of the pi_select_mode[1:0] pins, which are captured on chip cold reset. They are
+                                                         not affected by any other reset.
+                                                         0x0 = EP mode, Gen1 speed.
+                                                         0x1 = EP mode, Gen2 speed.
+                                                         0x2 = EP mode, Gen3 speed.
+                                                         0x3 = RC mode, defaults to Gen3 speed. */
+#else
+	uint64_t pimode                       : 2;
+	uint64_t pilanes4                     : 1;
+	uint64_t pilaneswap                   : 1;
+	uint64_t miopem2dlm5sel               : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} cnf75xx;
 };
 typedef union cvmx_pemx_strap cvmx_pemx_strap_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-qlm.h b/arch/mips/include/asm/octeon/cvmx-qlm.h
index ca47b82..86429c9 100644
--- a/arch/mips/include/asm/octeon/cvmx-qlm.h
+++ b/arch/mips/include/asm/octeon/cvmx-qlm.h
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 119797 $<hr>
+ * <hr>$Revision: 121394 $<hr>
  */
 
 #ifndef __CVMX_QLM_H__
@@ -258,6 +258,16 @@ extern void cvmx_qlm_display_registers(int qlm);
 
 extern int cvmx_qlm_measure_clock(int qlm);
 
+/**
+ * Measure the reference clock of a QLM on a multi-node setup
+ *
+ * @param node   node to measure
+ * @param qlm    QLM to measure
+ *
+ * @return Clock rate in Hz
+ */
+extern int cvmx_qlm_measure_clock_node(int node, int qlm);
+
 /*
  * Perform RX equalization on a QLM
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index 37b6e95..db52341 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -313,7 +313,7 @@ union cvmx_rst_boot {
 	uint64_t u64;
 	struct cvmx_rst_boot_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t chipkill                     : 1;  /**< A 0->1 transition of CHIPKILL starts the CHIPKILL timer. When CHIPKILL=1 and the timer
+	uint64_t chipkill                     : 1;  /**< A 0-to-1 transition of CHIPKILL starts the CHIPKILL timer. When CHIPKILL=1 and the timer
                                                          expires, chip reset is asserted internally. The CHIPKILL timer can be stopped only by
                                                          a reset (cold, warm, soft). The length of the CHIPKILL timer is specified by
                                                          RST_CKILL[TIMER].  This bit and timer function as a delayed warm reset. */
@@ -322,9 +322,9 @@ union cvmx_rst_boot {
 	uint64_t ejtagdis                     : 1;  /**< When set, external EJTAG access is disabled. This field resets to 1 in Authentik mode, else 0. */
 	uint64_t romen                        : 1;  /**< When set, Authentik/eMMC boot ROM is visible in the boot bus address space. This field
                                                          resets to 1 in an Authentik part or when booting from eMMC/SD or SPI. Else, resets to 0. */
-	uint64_t ckill_ppdis                  : 1;  /**< Chipkill Core Disable.  When set to 1, cores other than core 0 will immediately be
-                                                         disabled
-                                                         when RST_BOOT[CHIPKILL] is set.  Writes have no effect when RST_BOOT[CHIPKILL]=1. */
+	uint64_t ckill_ppdis                  : 1;  /**< Chipkill core disable. When set to 1, cores other than core 0 will immediately
+                                                         be disabled when RST_BOOT[CHIPKILL] is set. Writes have no effect when
+                                                         RST_BOOT[CHIPKILL]=1. */
 	uint64_t jt_tstmode                   : 1;  /**< JTAG test mode. */
 	uint64_t vrm_err                      : 1;  /**< VRM did not complete operations within 5.25mS of DCOK being asserted. PLLs were released
                                                          automatically. */
-- 
2.6.2

