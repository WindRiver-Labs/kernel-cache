From 4d9f02eafdfe7ce03775cea6d6f0a84a0ebdd784 Mon Sep 17 00:00:00 2001
From: Emil <egoranov@caviumnetworks.com>
Date: Sat, 8 Feb 2014 13:46:59 -0800
Subject: [PATCH 532/974] Fixed Linux octeon-NAND device driver and
 cvmx-BCH-support.

[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-nand.c | 109 +++++++++++++++++++++++++++-------
 1 file changed, 87 insertions(+), 22 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-nand.c b/arch/mips/cavium-octeon/octeon-nand.c
index 6a9766b..b58e16e 100644
--- a/arch/mips/cavium-octeon/octeon-nand.c
+++ b/arch/mips/cavium-octeon/octeon-nand.c
@@ -58,7 +58,9 @@ struct octeon_nand {
 	struct mtd_info mtd;
 	struct nand_chip nand;
 	/* Temporary location to store read data, must be 64 bit aligned */
-	uint8_t data[NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE];
+	uint8_t data[NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE] __attribute__((__aligned__(8)));
+	uint8_t status;
+	int use_status;
 	int data_len;		/* Number of byte in the data buffer */
 	int data_index;		/* Current read index. Equal to data_len when
 					all data has been read */
@@ -109,6 +111,11 @@ static uint8_t octeon_nand_read_byte(struct mtd_info *mtd)
 {
 	struct octeon_nand *priv = container_of(mtd, struct octeon_nand, mtd);
 
+	if (priv->use_status) {
+		DEV_DBG(DEBUG_READ, priv->dev, 
+			"returning status: 0x%x\n", priv->status);
+		return priv->status;
+	}
 	if (priv->data_index < priv->data_len) {
 		DEV_DBG(DEBUG_READ, priv->dev, "read of 0x%02x\n",
 			0xff & priv->data[priv->data_index]);
@@ -128,6 +135,9 @@ static uint16_t octeon_nand_read_word(struct mtd_info *mtd)
 {
 	struct octeon_nand *priv = container_of(mtd, struct octeon_nand, mtd);
 
+	if (priv->use_status)
+		return priv->status | (priv->status << 8);
+
 	if (priv->data_index + 1 < priv->data_len) {
 		uint16_t result = le16_to_cpup((uint16_t *)(priv->data +
 			priv->data_index));
@@ -152,14 +162,14 @@ static void octeon_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
 	struct octeon_nand *priv = container_of(mtd, struct octeon_nand, mtd);
 
 	DEV_DBG(DEBUG_WRITE_BUFFER, priv->dev, "len=%d\n", len);
-
-	memcpy(priv->data + priv->data_index, buf, len);
-	priv->data_index += len;
-	priv->data_len += len;
-	/* Linux sometimes thinks there is less OOB data than the chip really
-		has. Make sure all OOB is set to 0xff */
-	memset(priv->data + priv->data_index, 0xff,
-		sizeof(priv->data) - priv->data_index);
+	if (len <= (sizeof(priv->data) - priv->data_len)) {
+		memcpy(priv->data + priv->data_len, buf, len);
+		priv->data_len += len;
+		memset(priv->data + priv->data_len, 0xff,
+			sizeof(priv->data) - priv->data_len);
+	} else {
+		printk("Not enough data to write %d bytes\n", len);
+	}
 }
 
 /*
@@ -222,9 +232,10 @@ static int octeon_nand_hw_bch_read_page(struct mtd_info *mtd,
 
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
 		int stat;
-
+	
 		DEV_DBG(DEBUG_READ, priv->dev, "Correcting block offset %ld, ecc offset %d\n",
 			p - buf, i);
+
 		stat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);
 		if (stat < 0) {
 			mtd->ecc_stats.failed++;
@@ -234,7 +245,6 @@ static int octeon_nand_hw_bch_read_page(struct mtd_info *mtd,
 			mtd->ecc_stats.corrected += stat;
 		}
 	}
-	priv->data_index += mtd->writesize + mtd->oobsize;
 	return 0;
 }
 
@@ -255,7 +265,11 @@ static int octeon_nand_hw_bch_write_page(struct mtd_info *mtd,
 
 	/* Hardware ECC calculation */
 	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
-		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+		int ret;
+		ret = chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+		if (ret < 0)
+			printk("\n=== chip->ecc.calculate(mtd, p=%p, &ecc_calc[i]) returned %d\n", p, ret);
+		
 		DEV_DBG(DEBUG_WRITE, priv->dev, "block offset %ld, ecc offset %d\n",
 			p - buf, i);
 	}
@@ -282,6 +296,7 @@ static int octeon_nand_write_page_raw(struct mtd_info *mtd,
 				      struct nand_chip *chip,
 				      const uint8_t *buf, int oob_required)
 {
+	// same as in drivers/mtd/nand/nand_base.c
 	chip->write_buf(mtd, buf, mtd->writesize);
 	if (oob_required)
 		chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
@@ -300,6 +315,7 @@ static int octeon_nand_write_oob_std(struct mtd_info *mtd,
 				     struct nand_chip *chip,
 				     int page)
 {
+	// same as in drivers/mtd/nand/nand_base.c
 	int status = 0;
 	const uint8_t *buf = chip->oob_poi;
 	int length = mtd->oobsize;
@@ -328,6 +344,7 @@ static int octeon_nand_read_page_raw(struct mtd_info *mtd,
 				     struct nand_chip *chip,
 				     uint8_t *buf, int oob_required, int page)
 {
+	// same as in drivers/mtd/nand/nand_base.c
 	chip->read_buf(mtd, buf, mtd->writesize);
 	if (oob_required)
 		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
@@ -345,6 +362,7 @@ static int octeon_nand_read_oob_std(struct mtd_info *mtd,
 				    int page)
 
 {
+	// same as in drivers/mtd/nand/nand_base.c
 	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
 	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
 	return 0;
@@ -370,6 +388,7 @@ static void octeon_nand_cmdfunc(struct mtd_info *mtd, unsigned command,
 	int status;
 
 	down(&octeon_bootbus_sem);
+	priv->use_status = 0;
 	switch (command) {
 	case NAND_CMD_READID:
 		DEV_DBG(DEBUG_CONTROL, priv->dev, "READID\n");
@@ -441,10 +460,8 @@ static void octeon_nand_cmdfunc(struct mtd_info *mtd, unsigned command,
 
 	case NAND_CMD_STATUS:
 		DEV_DBG(DEBUG_CONTROL, priv->dev, "STATUS\n");
-		priv->data_index = 0;
-		priv->data_len = 2;
-		priv->data[0] = cvmx_nand_get_status(priv->selected_chip);
-		priv->data[1] = priv->data[0];
+		priv->status = cvmx_nand_get_status(priv->selected_chip);
+		priv->use_status = 1;
 		break;
 
 	case NAND_CMD_SEQIN:
@@ -515,11 +532,10 @@ static int octeon_nand_bch_calculate_ecc_internal(struct octeon_nand *priv,
 	int rc;
 	int i;
 	void *ecc_ptr;
-	uint8_t ecc_buffer[nand_chip->ecc.bytes];
+	uint8_t ecc_buffer[/*45*/nand_chip->ecc.bytes] __attribute__((__aligned__(8)));
 
 	if ((ulong)code % 8) {
 		ecc_ptr = ecc_buffer;
-		memcpy(ecc_buffer, code, nand_chip->ecc.bytes);
 	} else
 		ecc_ptr = code;
 
@@ -910,6 +926,55 @@ static int octeon_nand_scan_onfi(struct octeon_nand *priv)
 			priv->nand.ecc.size = 512;
 		}
 
+		{
+		/*
+		 * nand.ecc.strenght will be used as ecc_level so 
+		 * it should be in {4, 8, 16, 24, 32, 40, 48, 56, 60, 64}
+		 * needed ecc_bytes for m=15 (hardcoded in NAND controller)
+		 */
+		int ecc_lvls[]  = {4, 8, 16, 24, 32, 40, 48, 56, 60, 64};
+		/* for our NAND (4k page, 24bits/1024bytes corrected) and
+		 * NAND controller (hardcoded with m=15) ecc_totalbytes
+		 * per above ecc_lvls {4,8, 16...64} are
+		 */
+		int ecc_bytes[] = {8, 15, 30, 45, 60, 75, 90, 105, 113, 120};
+		int ecc_totalbytes[] = {32, 60, 120, 180, 240, 300, 360, 420, 452, 480};
+		/* first set the desired ecc_level to match ecc_lvls[] */ 
+		int index = /* 0..9 */
+			(priv->nand.ecc.strength >= 64) ? 9/*64*/ :
+			(priv->nand.ecc.strength > 56 && priv->nand.ecc.strength <= 60) ? 8/*60*/ :
+			(priv->nand.ecc.strength > 48 && priv->nand.ecc.strength <= 56) ? 7/*56*/ :
+			(priv->nand.ecc.strength > 40 && priv->nand.ecc.strength <= 48) ? 6/*48*/ :
+			(priv->nand.ecc.strength > 32 && priv->nand.ecc.strength <= 40) ? 5/*40*/ :
+			(priv->nand.ecc.strength > 48 && priv->nand.ecc.strength <= 32) ? 4/*32*/ :
+			(priv->nand.ecc.strength > 16 && priv->nand.ecc.strength <= 24) ? 3/*24*/ :
+			(priv->nand.ecc.strength >  8 && priv->nand.ecc.strength <= 16) ? 2/*16*/ :
+			(priv->nand.ecc.strength >  4 && priv->nand.ecc.strength <=  8) ? 1/*8*/ :
+			(priv->nand.ecc.strength >  1 && priv->nand.ecc.strength <=  4) ? 0/*4*/: 0;
+		/*
+		 * ..then check if there is enough space in OOB to store ECC bytes 
+		 * and eventualy (if not) change ecc.strenght the the best possible value
+		 */
+		if (ecc_totalbytes[index] <= cvmx_nand_get_oob_size(priv->selected_chip) - 2) {
+			priv->nand.ecc.strength = ecc_lvls[index];
+			priv->nand.ecc.bytes = ecc_bytes[index];
+		} else {
+			int i = 9;
+			while (ecc_totalbytes[i] > cvmx_nand_get_oob_size(priv->selected_chip))
+				i--;
+			priv->nand.ecc.strength = ecc_lvls[i];
+			priv->nand.ecc.bytes = ecc_bytes[i];
+		}
+		
+		/*
+		 * strenght=24 needs total of ecc.bytes=180 for 4k page
+		 * strenght=32 needs total of ecc.bytes=240 for 4k page
+		 * Our NAND has only 224 bytes OOB so we should use max
+		 * ecc.strength=24 ,ecc.bytes=45 and ecc_totalbytes=180
+		 */
+/*		if (priv->nand.ecc.strength > 24) priv->nand.ecc.strength = 24;*/
+		}
+		
 		/* The number of ECC bits required is m * t
 		 * where (2^m) - 1 > bits per ecc block and
 		 * t is the number of correctible bits.  So if
@@ -923,9 +988,10 @@ static int octeon_nand_scan_onfi(struct octeon_nand *priv)
 		 * OCTEON requires ((15 * t) + 7) / 8
 		 */
 		priv->nand.ecc.bytes = ((15 * priv->nand.ecc.strength) + 7) / 8;
-		if (!priv->nand.ecc.strength)
-			priv->nand.ecc.strength =
-				(priv->nand.ecc.bytes * 8) / fls(8 * priv->nand.ecc.size);
+		
+		/* priv->nand.ecc.strength =
+			(priv->nand.ecc.bytes * 8) / fls(8 * priv->nand.ecc.size);*/
+
 		priv->nand.ecc.steps = (1 << priv->nand.page_shift) / priv->nand.ecc.size;
 		priv->nand.ecc.calculate = octeon_nand_bch_calculate;
 		priv->nand.ecc.correct = octeon_nand_bch_correct;
@@ -1244,7 +1310,6 @@ static int octeon_nand_probe(struct platform_device *pdev)
 
 		mtd_device_parse_register(&priv->mtd, part_probes,
 					  NULL, NULL, 0);
-
 		octeon_nand_open_mtd[chip] = priv;
 		chip_num++;
 	}
-- 
2.6.2

