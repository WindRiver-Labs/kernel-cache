From d043b1aaf468c359ee81687b046242e2e69253c5 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 21 Feb 2014 13:46:59 -0800
Subject: [PATCH 487/974] netdev: octeon3-ethernet: Fixes to build as module.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/octeon/Kconfig            |  13 +-
 drivers/net/ethernet/octeon/Makefile           |   3 +-
 drivers/net/ethernet/octeon/octeon-bgx-nexus.c | 149 ++++++++++++
 drivers/net/ethernet/octeon/octeon-bgx-port.c  | 229 ++++++++++++++++++
 drivers/net/ethernet/octeon/octeon-bgx.c       | 311 -------------------------
 drivers/net/ethernet/octeon/octeon-bgx.h       |   2 +
 drivers/net/ethernet/octeon/octeon3-ethernet.c |   6 +-
 7 files changed, 395 insertions(+), 318 deletions(-)
 create mode 100644 drivers/net/ethernet/octeon/octeon-bgx-nexus.c
 create mode 100644 drivers/net/ethernet/octeon/octeon-bgx-port.c
 delete mode 100644 drivers/net/ethernet/octeon/octeon-bgx.c

diff --git a/drivers/net/ethernet/octeon/Kconfig b/drivers/net/ethernet/octeon/Kconfig
index 0e8fafe..a2335cc 100644
--- a/drivers/net/ethernet/octeon/Kconfig
+++ b/drivers/net/ethernet/octeon/Kconfig
@@ -2,16 +2,19 @@
 # Cavium network device configuration
 #
 
-config OCTEON_BGX
-	tristate "Cavium Inc. OCTEON III BGX support"
+config OCTEON_BGX_NEXUS
+	tristate
 	depends on CAVIUM_OCTEON_SOC
-	help
-	  Support for 'BGX' Ethernet MAC on cn78XX.
+
+config OCTEON_BGX_PORT
+	tristate
+	depends on CAVIUM_OCTEON_SOC
+	select OCTEON_BGX_NEXUS
 
 config OCTEON3_ETHERNET
 	tristate "Cavium Inc. OCTEON III Ethernet support"
 	depends on CAVIUM_OCTEON_SOC
-	select OCTEON_BGX
+	select OCTEON_BGX_PORT
 	help
 	  Support for 'BGX' Ethernet via PKI/PKO units.
 
diff --git a/drivers/net/ethernet/octeon/Makefile b/drivers/net/ethernet/octeon/Makefile
index 8328928..3fabb8f 100644
--- a/drivers/net/ethernet/octeon/Makefile
+++ b/drivers/net/ethernet/octeon/Makefile
@@ -1,7 +1,8 @@
 #
 # Makefile for the Cavium network device drivers.
 #
-obj-$(CONFIG_OCTEON_BGX)		+= octeon-bgx.o
+obj-$(CONFIG_OCTEON_BGX_PORT)		+= octeon-bgx-port.o
+obj-$(CONFIG_OCTEON_BGX_NEXUS)		+= octeon-bgx-nexus.o
 obj-$(CONFIG_OCTEON3_ETHERNET)		+= octeon3-ethernet.o
 obj-$(CONFIG_OCTEON_MGMT_ETHERNET)	+= octeon_mgmt.o
 obj-$(CONFIG_OCTEON_POW_ONLY_ETHERNET)	+= octeon-pow-ethernet.o
diff --git a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
new file mode 100644
index 0000000..635bd71
--- /dev/null
+++ b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
@@ -0,0 +1,149 @@
+/**********************************************************************
+ * Author: Cavium, Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2014 Cavium, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium, Inc. for more information
+ **********************************************************************/
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-util.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
+#include <asm/octeon/cvmx-bgxx-defs.h>
+
+#include "octeon-bgx.h"
+
+static int bgx_probe(struct platform_device *pdev)
+{
+	struct bgx_platform_data platform_data;
+	const __be32 *reg;
+	u32 port;
+	u64 addr;
+	struct device_node *child;
+	struct platform_device *new_dev;
+	struct platform_device *pki_dev;
+	static int pki_id;
+	int numa_node, interface;
+	int i;
+	int r = 0;
+	char id[64];
+
+	reg = of_get_property(pdev->dev.of_node, "reg", NULL);
+	addr = of_translate_address(pdev->dev.of_node, reg);
+	interface = (addr >> 24) & 0xf;
+	numa_node = (addr >> 36) & 0x7;
+	for_each_available_child_of_node(pdev->dev.of_node, child) {
+		if (!of_device_is_compatible(child, "cavium,octeon-7880-bgx-port"))
+			continue;
+		r = of_property_read_u32(child, "reg", &port);
+		if (r)
+			return -ENODEV;
+		snprintf(id, sizeof(id), "%llx.%u.ethernet-mac", (unsigned long long)addr, port);
+		new_dev = of_platform_device_create(child, id, &pdev->dev);
+		if (!new_dev) {
+			dev_err(&pdev->dev, "Error creating %s\n", id);
+			continue;
+		}
+		platform_data.numa_node = numa_node;
+		platform_data.interface = interface;
+		platform_data.port = port;
+
+		pki_dev = platform_device_register_data(&new_dev->dev, "ethernet-mac-pki", pki_id++,
+							&platform_data, sizeof(platform_data));
+		dev_info(&pdev->dev, "Created PKI %u: %p\n", pki_dev->id, pki_dev);
+#ifdef CONFIG_NUMA
+		new_dev->dev.numa_node = pdev->dev.numa_node;
+		pki_dev->dev.numa_node = pdev->dev.numa_node;
+#endif
+	}
+	__cvmx_helper_packet_hardware_enable(cvmx_helper_node_interface_to_xiface(numa_node, interface));
+	/* Assign 8 CAM entries per LMAC */
+	for (i = 0; i < 32; i++) {
+		union cvmx_bgxx_cmr_rx_adrx_cam adr_cam;
+		adr_cam.u64 = 0;
+		adr_cam.s.id = i >> 3;
+		cvmx_write_csr_node(numa_node, CVMX_BGXX_CMR_RX_ADRX_CAM(i, interface), adr_cam.u64);
+	}
+
+	dev_info(&pdev->dev, "Probed\n");
+	return 0;
+}
+
+static int bgx_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static void bgx_shutdown(struct platform_device *pdev)
+{
+	return;
+}
+
+static struct of_device_id bgx_match[] = {
+	{
+		.compatible = "cavium,octeon-7880-bgx",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, bgx_match);
+
+static struct platform_driver bgx_driver = {
+	.probe		= bgx_probe,
+	.remove		= bgx_remove,
+	.shutdown       = bgx_shutdown,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= KBUILD_MODNAME,
+		.of_match_table = bgx_match,
+	},
+};
+
+/* Allow bgx_port driver to force this driver to load */
+void bgx_nexus_load(void)
+{
+}
+EXPORT_SYMBOL(bgx_nexus_load);
+
+static int __init bgx_driver_init(void)
+{
+	int r;
+	__cvmx_helper_init_port_config_data();
+	r =  platform_driver_register(&bgx_driver);
+	return r;
+}
+module_init(bgx_driver_init);
+
+static void __exit bgx_driver_exit(void)
+{
+	platform_driver_unregister(&bgx_driver);
+}
+module_exit(bgx_driver_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cavium Networks <support@caviumnetworks.com>");
+MODULE_DESCRIPTION("Cavium Networks BGX MAC Nexus driver.");
diff --git a/drivers/net/ethernet/octeon/octeon-bgx-port.c b/drivers/net/ethernet/octeon/octeon-bgx-port.c
new file mode 100644
index 0000000..20652bb
--- /dev/null
+++ b/drivers/net/ethernet/octeon/octeon-bgx-port.c
@@ -0,0 +1,229 @@
+/**********************************************************************
+ * Author: Cavium, Inc.
+ *
+ * Contact: support@cavium.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2014 Cavium, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium, Inc. for more information
+ **********************************************************************/
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_net.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-util.h>
+#include <asm/octeon/cvmx-helper-cfg.h>
+#include <asm/octeon/cvmx-bgxx-defs.h>
+
+#include "octeon-bgx.h"
+
+struct bgx_port_priv {
+	int numa_node;
+	int bgx_interface;
+	int index; /* Port index on BGX block*/
+	const u8 *mac_addr;
+};
+
+const u8 *bgx_port_get_mac(struct device *dev)
+{
+	struct bgx_port_priv *priv = dev_get_drvdata(dev);
+	return priv->mac_addr;
+}
+EXPORT_SYMBOL(bgx_port_get_mac);
+
+static void bgx_port_write_cam(int numa_node, int interface, int index, int cam, const u8 *mac)
+{
+	int i;
+	union cvmx_bgxx_cmr_rx_adrx_cam adr_cam;
+	u64 m = 0;
+	if (mac)
+		for (i = 0; i < 6; i++)
+			m |= ((u64)mac[i]) << (6 * i);
+	adr_cam.u64 = m;
+	adr_cam.s.en = mac ? 1 : 0;
+	adr_cam.s.id = index >> 3;
+	cvmx_write_csr_node(numa_node, CVMX_BGXX_CMR_RX_ADRX_CAM(index * 8 + cam, interface), adr_cam.u64);
+}
+
+/* Set MAC address for the ned_device that is attached. */
+void bgx_port_set_rx_filtering(struct net_device *netdev, struct device *dev)
+{
+	union cvmx_bgxx_cmrx_rx_adr_ctl adr_ctl;
+	struct bgx_port_priv *priv = dev_get_drvdata(dev);
+	int available_cam_entries, current_cam_entry;
+	struct netdev_hw_addr *ha;
+
+	available_cam_entries = 8;
+	adr_ctl.u64 = 0;
+	adr_ctl.s.bcst_accept = 1; /* Accept all Broadcast*/
+
+	if ((netdev->flags & IFF_PROMISC) || netdev->uc.count > 7) {
+		adr_ctl.s.cam_accept = 0; /* Reject CAM match */
+		available_cam_entries = 0;
+	} else {
+		/* One CAM entry for the primary address, leaves seven
+		 * for the secondary addresses.
+		 */
+		adr_ctl.s.cam_accept = 1; /* Accept CAM match */
+		available_cam_entries = 7 - netdev->uc.count;
+	}
+
+	if (netdev->flags & IFF_MULTICAST) {
+		if ((netdev->flags & IFF_ALLMULTI) || netdev_mc_count(netdev) > available_cam_entries)
+			adr_ctl.s.mcst_mode = 1; /* Accept all Multicast */
+		else
+			adr_ctl.s.mcst_mode = 2; /* Accept all Multicast via CAM */
+	}
+	current_cam_entry = 0;
+	if (adr_ctl.s.cam_accept) {
+		bgx_port_write_cam(priv->numa_node, priv->bgx_interface, priv->index,
+				   current_cam_entry, netdev->dev_addr);
+		current_cam_entry++;
+		netdev_for_each_uc_addr(ha, netdev) {
+			bgx_port_write_cam(priv->numa_node, priv->bgx_interface, priv->index,
+					   current_cam_entry, ha->addr);
+			current_cam_entry++;
+		}
+	}
+	if (adr_ctl.s.mcst_mode == 2) {/* Accept all Multicast via CAM */
+		netdev_for_each_mc_addr(ha, netdev) {
+			bgx_port_write_cam(priv->numa_node, priv->bgx_interface, priv->index,
+					   current_cam_entry, ha->addr);
+			current_cam_entry++;
+		}
+	}
+	while (current_cam_entry < 8) {
+		bgx_port_write_cam(priv->numa_node, priv->bgx_interface, priv->index,
+				   current_cam_entry, NULL);
+		current_cam_entry++;
+	}
+	cvmx_write_csr_node(priv->numa_node,
+			    CVMX_BGXX_CMRX_RX_ADR_CTL(priv->index, priv->bgx_interface),
+			    adr_ctl.u64);
+}
+EXPORT_SYMBOL(bgx_port_set_rx_filtering);
+
+int bgx_port_enable(struct device *dev)
+{
+	return 0;
+}
+
+int bgx_port_disable(struct device *dev)
+{
+	return 0;
+}
+
+static int bgx_port_probe(struct platform_device *pdev)
+{
+	u64 addr;
+	const u8 *mac;
+	const __be32 *reg;
+	u32 index;
+	int r;
+	struct bgx_port_priv *priv;
+	int numa_node;
+
+	reg = of_get_property(pdev->dev.parent->of_node, "reg", NULL);
+	addr = of_translate_address(pdev->dev.parent->of_node, reg);
+	mac = of_get_mac_address(pdev->dev.parent->of_node);
+
+	numa_node = (addr >> 36) & 0x7;
+
+	r = of_property_read_u32(pdev->dev.of_node, "reg", &index);
+	if (r)
+		return -ENODEV;
+	priv = kzalloc_node(sizeof(*priv), GFP_KERNEL, numa_node);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->numa_node = numa_node;
+	priv->bgx_interface = (addr >> 24) & 0xf;
+	priv->index = index;
+	if (mac)
+		priv->mac_addr = mac;
+
+	r = dev_set_drvdata(&pdev->dev, priv);
+	if (r)
+		goto err;
+
+	dev_info(&pdev->dev, "Probed\n");
+	return 0;
+err:
+	kfree(priv);
+	return r;
+}
+
+static int bgx_port_remove(struct platform_device *pdev)
+{
+	struct bgx_port_priv *priv = dev_get_drvdata(&pdev->dev);
+	kfree(priv);
+	return 0;
+}
+
+static void bgx_port_shutdown(struct platform_device *pdev)
+{
+	return;
+}
+
+static struct of_device_id bgx_port_match[] = {
+	{
+		.compatible = "cavium,octeon-7880-bgx-port",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, bgx_port_match);
+
+static struct platform_driver bgx_port_driver = {
+	.probe		= bgx_port_probe,
+	.remove		= bgx_port_remove,
+	.shutdown       = bgx_port_shutdown,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= KBUILD_MODNAME,
+		.of_match_table = bgx_port_match,
+	},
+};
+
+static int __init bgx_port_driver_init(void)
+{
+	int r;
+
+	bgx_nexus_load();
+	r =  platform_driver_register(&bgx_port_driver);
+	return r;
+}
+module_init(bgx_port_driver_init);
+
+static void __exit bgx_port_driver_exit(void)
+{
+	platform_driver_unregister(&bgx_port_driver);
+}
+module_exit(bgx_port_driver_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cavium Networks <support@caviumnetworks.com>");
+MODULE_DESCRIPTION("Cavium Networks BGX Ethernet MAC driver.");
diff --git a/drivers/net/ethernet/octeon/octeon-bgx.c b/drivers/net/ethernet/octeon/octeon-bgx.c
deleted file mode 100644
index 7ce27b8..0000000
--- a/drivers/net/ethernet/octeon/octeon-bgx.c
+++ /dev/null
@@ -1,311 +0,0 @@
-/**********************************************************************
- * Author: Cavium, Inc.
- *
- * Contact: support@cavium.com
- * This file is part of the OCTEON SDK
- *
- * Copyright (c) 2014 Cavium, Inc.
- *
- * This file is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License, Version 2, as
- * published by the Free Software Foundation.
- *
- * This file is distributed in the hope that it will be useful, but
- * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
- * NONINFRINGEMENT.  See the GNU General Public License for more
- * details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this file; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
- * or visit http://www.gnu.org/licenses/.
- *
- * This file may also be available under a different license from Cavium.
- * Contact Cavium, Inc. for more information
- **********************************************************************/
-#include <linux/platform_device.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/of_platform.h>
-#include <linux/of_address.h>
-#include <linux/of_net.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/list.h>
-
-#include <asm/octeon/cvmx-helper.h>
-#include <asm/octeon/cvmx-helper-util.h>
-#include <asm/octeon/cvmx-helper-cfg.h>
-#include <asm/octeon/cvmx-bgxx-defs.h>
-
-#include "octeon-bgx.h"
-
-struct bgx_port_priv {
-	int numa_node;
-	int bgx_interface;
-	int index; /* Port index on BGX block*/
-	const u8 *mac_addr;
-};
-
-const u8 *bgx_port_get_mac(struct device *dev)
-{
-	struct bgx_port_priv *priv = dev_get_drvdata(dev);
-	return priv->mac_addr;
-}
-static void bgx_port_write_cam(int numa_node, int interface, int index, int cam, const u8 *mac)
-{
-	int i;
-	union cvmx_bgxx_cmr_rx_adrx_cam adr_cam;
-	u64 m = 0;
-	if (mac)
-		for (i = 0; i < 6; i++)
-			m |= ((u64)mac[i]) << (6 * i);
-	adr_cam.u64 = m;
-	adr_cam.s.en = mac ? 1 : 0;
-	adr_cam.s.id = index >> 3;
-	cvmx_write_csr_node(numa_node, CVMX_BGXX_CMR_RX_ADRX_CAM(index * 8 + cam, interface), adr_cam.u64);
-}
-
-/* Set MAC address for the ned_device that is attached. */
-void bgx_port_set_rx_filtering(struct net_device *netdev, struct device *dev)
-{
-	union cvmx_bgxx_cmrx_rx_adr_ctl adr_ctl;
-	struct bgx_port_priv *priv = dev_get_drvdata(dev);
-	int available_cam_entries, current_cam_entry;
-	struct netdev_hw_addr *ha;
-
-	available_cam_entries = 8;
-	adr_ctl.u64 = 0;
-	adr_ctl.s.bcst_accept = 1; /* Accept all Broadcast*/
-
-	if ((netdev->flags & IFF_PROMISC) || netdev->uc.count > 7) {
-		adr_ctl.s.cam_accept = 0; /* Reject CAM match */
-		available_cam_entries = 0;
-	} else {
-		/* One CAM entry for the primary address, leaves seven
-		 * for the secondary addresses.
-		 */
-		adr_ctl.s.cam_accept = 1; /* Accept CAM match */
-		available_cam_entries = 7 - netdev->uc.count;
-	}
-
-	if (netdev->flags & IFF_MULTICAST) {
-		if ((netdev->flags & IFF_ALLMULTI) || netdev_mc_count(netdev) > available_cam_entries)
-			adr_ctl.s.mcst_mode = 1; /* Accept all Multicast */
-		else
-			adr_ctl.s.mcst_mode = 2; /* Accept all Multicast via CAM */
-	}
-	current_cam_entry = 0;
-	if (adr_ctl.s.cam_accept) {
-		bgx_port_write_cam(priv->numa_node, priv->bgx_interface, priv->index,
-				   current_cam_entry, netdev->dev_addr);
-		current_cam_entry++;
-		netdev_for_each_uc_addr(ha, netdev) {
-			bgx_port_write_cam(priv->numa_node, priv->bgx_interface, priv->index,
-					   current_cam_entry, ha->addr);
-			current_cam_entry++;
-		}
-	}
-	if (adr_ctl.s.mcst_mode == 2) {/* Accept all Multicast via CAM */
-		netdev_for_each_mc_addr(ha, netdev) {
-			bgx_port_write_cam(priv->numa_node, priv->bgx_interface, priv->index,
-					   current_cam_entry, ha->addr);
-			current_cam_entry++;
-		}
-	}
-	while (current_cam_entry < 8) {
-		bgx_port_write_cam(priv->numa_node, priv->bgx_interface, priv->index,
-				   current_cam_entry, NULL);
-		current_cam_entry++;
-	}
-	cvmx_write_csr_node(priv->numa_node,
-			    CVMX_BGXX_CMRX_RX_ADR_CTL(priv->index, priv->bgx_interface),
-			    adr_ctl.u64);
-}
-
-int bgx_port_enable(struct device *dev)
-{
-	return 0;
-}
-
-int bgx_port_disable(struct device *dev)
-{
-	return 0;
-}
-
-static int bgx_port_probe(struct platform_device *pdev)
-{
-	u64 addr;
-	const u8 *mac;
-	const __be32 *reg;
-	u32 index;
-	int r;
-	struct bgx_port_priv *priv;
-	int numa_node;
-
-	reg = of_get_property(pdev->dev.parent->of_node, "reg", NULL);
-	addr = of_translate_address(pdev->dev.parent->of_node, reg);
-	mac = of_get_mac_address(pdev->dev.parent->of_node);
-
-	numa_node = (addr >> 36) & 0x7;
-
-	r = of_property_read_u32(pdev->dev.of_node, "reg", &index);
-	if (r)
-		return -ENODEV;
-	priv = kzalloc_node(sizeof(*priv), GFP_KERNEL, numa_node);
-	if (!priv)
-		return -ENOMEM;
-
-	priv->numa_node = numa_node;
-	priv->bgx_interface = (addr >> 24) & 0xf;
-	priv->index = index;
-	if (mac)
-		priv->mac_addr = mac;
-
-	r = dev_set_drvdata(&pdev->dev, priv);
-	if (r)
-		goto err;
-
-	dev_info(&pdev->dev, "Probed\n");
-	return 0;
-err:
-	kfree(priv);
-	return r;
-}
-
-static int bgx_port_remove(struct platform_device *pdev)
-{
-	struct bgx_port_priv *priv = dev_get_drvdata(&pdev->dev);
-	kfree(priv);
-	return 0;
-}
-
-static void bgx_port_shutdown(struct platform_device *pdev)
-{
-	return;
-}
-
-static struct of_device_id bgx_port_match[] = {
-	{
-		.compatible = "cavium,octeon-7880-bgx-port",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, bgx_port_match);
-
-static struct platform_driver bgx_port_driver = {
-	.probe		= bgx_port_probe,
-	.remove		= bgx_port_remove,
-	.shutdown       = bgx_port_shutdown,
-	.driver		= {
-		.owner	= THIS_MODULE,
-		.name	= KBUILD_MODNAME "_port",
-		.of_match_table = bgx_port_match,
-	},
-};
-module_platform_driver(bgx_port_driver);
-
-static int bgx_probe(struct platform_device *pdev)
-{
-	struct bgx_platform_data platform_data;
-	const __be32 *reg;
-	u32 port;
-	u64 addr;
-	struct device_node *child;
-	struct platform_device *new_dev;
-	struct platform_device *pki_dev;
-	static int pki_id;
-	int numa_node, interface;
-	int i;
-	int r = 0;
-	char id[64];
-
-	reg = of_get_property(pdev->dev.of_node, "reg", NULL);
-	addr = of_translate_address(pdev->dev.of_node, reg);
-	interface = (addr >> 24) & 0xf;
-	numa_node = (addr >> 36) & 0x7;
-	for_each_available_child_of_node(pdev->dev.of_node, child) {
-		if (!of_device_is_compatible(child, "cavium,octeon-7880-bgx-port"))
-			continue;
-		r = of_property_read_u32(child, "reg", &port);
-		if (r)
-			return -ENODEV;
-		snprintf(id, sizeof(id), "%llx.%u.ethernet-mac", (unsigned long long)addr, port);
-		new_dev = of_platform_device_create(child, id, &pdev->dev);
-		if (!new_dev) {
-			dev_err(&pdev->dev, "Error creating %s\n", id);
-			continue;
-		}
-		platform_data.numa_node = numa_node;
-		platform_data.interface = interface;
-		platform_data.port = port;
-
-		pki_dev = platform_device_register_data(&new_dev->dev, "ethernet-mac-pki", pki_id++,
-							&platform_data, sizeof(platform_data));
-		dev_info(&pdev->dev, "Created PKI %u: %p\n", pki_dev->id, pki_dev);
-#ifdef CONFIG_NUMA
-		new_dev->dev.numa_node = pdev->dev.numa_node;
-		pki_dev->dev.numa_node = pdev->dev.numa_node;
-#endif
-	}
-	__cvmx_helper_packet_hardware_enable(cvmx_helper_node_interface_to_xiface(numa_node, interface));
-	/* Assign 8 CAM entries per LMAC */
-	for (i = 0; i < 32; i++) {
-		union cvmx_bgxx_cmr_rx_adrx_cam adr_cam;
-		adr_cam.u64 = 0;
-		adr_cam.s.id = i >> 3;
-		cvmx_write_csr_node(numa_node, CVMX_BGXX_CMR_RX_ADRX_CAM(i, interface), adr_cam.u64);
-	}
-
-	dev_info(&pdev->dev, "Probed\n");
-	return 0;
-}
-
-static int bgx_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static void bgx_shutdown(struct platform_device *pdev)
-{
-	return;
-}
-
-static struct of_device_id bgx_match[] = {
-	{
-		.compatible = "cavium,octeon-7880-bgx",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, bgx_match);
-
-static struct platform_driver bgx_driver = {
-	.probe		= bgx_probe,
-	.remove		= bgx_remove,
-	.shutdown       = bgx_shutdown,
-	.driver		= {
-		.owner	= THIS_MODULE,
-		.name	= KBUILD_MODNAME,
-		.of_match_table = bgx_match,
-	},
-};
-
-static int __init bgx_driver_init(void)
-{
-	int r;
-	__cvmx_helper_init_port_config_data();
-	r =  platform_driver_register(&bgx_driver);
-	return r;
-}
-module_init(bgx_driver_init);
-
-static void __exit bgx_driver_exit(void)
-{
-	platform_driver_unregister(&bgx_driver);
-}
-module_exit(bgx_driver_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Cavium Networks <support@caviumnetworks.com>");
-MODULE_DESCRIPTION("Cavium Networks BGX Ethernet MAC driver.");
diff --git a/drivers/net/ethernet/octeon/octeon-bgx.h b/drivers/net/ethernet/octeon/octeon-bgx.h
index be326a2..51492c8 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx.h
+++ b/drivers/net/ethernet/octeon/octeon-bgx.h
@@ -30,6 +30,8 @@
 struct device;
 struct net_device;
 
+void bgx_nexus_load(void);
+
 int bgx_port_enable(struct device *dev);
 int bgx_port_disable(struct device *dev);
 const u8 *bgx_port_get_mac(struct device *dev);
diff --git a/drivers/net/ethernet/octeon/octeon3-ethernet.c b/drivers/net/ethernet/octeon/octeon3-ethernet.c
index 93bf70f..e67afe7 100644
--- a/drivers/net/ethernet/octeon/octeon3-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon3-ethernet.c
@@ -24,7 +24,7 @@
  * This file may also be available under a different license from Cavium.
  * Contact Cavium, Inc. for more information
  **********************************************************************/
-#include <linux/init.h>
+#include <linux/module.h>
 #include <linux/atomic.h>
 #include <linux/kthread.h>
 #include <linux/interrupt.h>
@@ -818,3 +818,7 @@ static void __exit octeon3_eth_exit(void)
 	platform_driver_unregister(&octeon3_eth_driver);
 }
 module_exit(octeon3_eth_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cavium Networks <support@caviumnetworks.com>");
+MODULE_DESCRIPTION("Cavium Networks PKI/PKO Ethernet driver.");
-- 
2.6.2

