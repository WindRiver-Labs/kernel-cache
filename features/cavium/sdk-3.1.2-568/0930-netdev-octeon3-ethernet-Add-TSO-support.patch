From a0043a11a130a0bd799f8e60da51c8518fdc2ef1 Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Thu, 24 Jul 2014 18:05:50 -0700
Subject: [PATCH 930/974] netdev: octeon3-ethernet: Add TSO support.

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/octeon-feature.c |  1 +
 arch/mips/include/asm/octeon/cvmx-pko3.h           | 20 ++++++++++++++++++++
 arch/mips/include/asm/octeon/octeon-feature.h      |  8 ++++++++
 drivers/net/ethernet/octeon/octeon3-ethernet.c     | 17 +++++++++++++++++
 4 files changed, 46 insertions(+)

diff --git a/arch/mips/cavium-octeon/executive/octeon-feature.c b/arch/mips/cavium-octeon/executive/octeon-feature.c
index 00bf736..7732124 100644
--- a/arch/mips/cavium-octeon/executive/octeon-feature.c
+++ b/arch/mips/cavium-octeon/executive/octeon-feature.c
@@ -144,6 +144,7 @@ void __init octeon_feature_init(void)
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_BGX);
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_BGX_MIX);
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_BGX_XCV);
+	OCTEON_FEATURE_SET(OCTEON_FEATURE_TSO);
 	val = OCTEON_FEATURE_SUCCESS;
 
 feature_check:
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3.h b/arch/mips/include/asm/octeon/cvmx-pko3.h
index 5d8b720..7059519 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3.h
@@ -265,6 +265,7 @@ typedef	enum pko_query_dqstatus pko_query_dqstatus_t;
 #define CVMX_PKO_SENDSUBDC_GATHER	0x1
 #define CVMX_PKO_SENDSUBDC_JUMP		0x2
 /* Sub-command four bit codes (SUBDC4) */
+#define CVMX_PKO_SENDSUBDC_TSO		0x8
 #define CVMX_PKO_SENDSUBDC_FREE		0x9
 #define CVMX_PKO_SENDSUBDC_WORK		0xA
 #define CVMX_PKO_SENDSUBDC_AURA		0xB
@@ -333,6 +334,25 @@ union cvmx_pko_send_aura {
 typedef union cvmx_pko_send_aura cvmx_pko_send_aura_t;
 
 /**
+ * pko_send_tso
+ */
+union cvmx_pko_send_tso {
+	uint64_t u64;
+	struct {
+		CVMX_BITFIELD_FIELD(uint64_t l2len	: 8,
+		CVMX_BITFIELD_FIELD(uint64_t rsvd_48_55	: 8,
+		CVMX_BITFIELD_FIELD(uint64_t subdc4	: 4, /* 0x8 */
+		CVMX_BITFIELD_FIELD(uint64_t rsvd_32_43	: 12,
+		CVMX_BITFIELD_FIELD(uint64_t sb		: 8,
+		CVMX_BITFIELD_FIELD(uint64_t mss	: 16,
+		CVMX_BITFIELD_FIELD(uint64_t eom	: 1,
+		CVMX_BITFIELD_FIELD(uint64_t fn		: 7,
+			))))))));
+	} s;
+};
+typedef union cvmx_pko_send_tso cvmx_pko_send_tso_t;
+
+/**
  * pko_send_free
  */
 union cvmx_pko_send_free {
diff --git a/arch/mips/include/asm/octeon/octeon-feature.h b/arch/mips/include/asm/octeon/octeon-feature.h
index 7c3aa42..c47ba41 100644
--- a/arch/mips/include/asm/octeon/octeon-feature.h
+++ b/arch/mips/include/asm/octeon/octeon-feature.h
@@ -178,6 +178,8 @@ typedef enum {
 				/**<  Octeon has HNA */
 	OCTEON_FEATURE_BGX_XCV,
 				/**< Octeon has BGX XCV RGMII support */
+	OCTEON_FEATURE_TSO,
+				/**< Octeon has tcp segmentation offload */
 	OCTEON_MAX_FEATURE
 } octeon_feature_t;
 
@@ -519,6 +521,12 @@ static inline int octeon_has_feature_OCTEON_FEATURE_BGX_XCV(void)
 {
 	return OCTEON_IS_MODEL(OCTEON_CN73XX);
 }
+
+static inline int octeon_has_feature_OCTEON_FEATURE_TSO(void)
+{
+	return OCTEON_IS_MODEL(OCTEON_CN73XX);
+}
+
 /*
  * bit map for octeon features
  */
diff --git a/drivers/net/ethernet/octeon/octeon3-ethernet.c b/drivers/net/ethernet/octeon/octeon3-ethernet.c
index 428bc04..1e90abb 100644
--- a/drivers/net/ethernet/octeon/octeon3-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon3-ethernet.c
@@ -1483,6 +1483,9 @@ static int octeon3_eth_common_ndo_init(struct net_device	*netdev,
 	if (!OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
 		netdev->features |= NETIF_F_SCTP_CSUM;
 
+	if (octeon_has_feature(OCTEON_FEATURE_TSO))
+		netdev->features |= NETIF_F_TSO | NETIF_F_TSO6;
+
 	priv->rx_buf_count = num_packet_buffers;
 
 	ipd_port = cvmx_helper_get_ipd_port(priv->xiface, priv->port_index);
@@ -1896,6 +1899,7 @@ static int octeon3_eth_ndo_start_xmit(struct sk_buff *skb, struct net_device *ne
 	union cvmx_pko_lmtdma_data lmtdma_data;
 	union cvmx_pko_query_rtn query_rtn;
 	union cvmx_sso_grpx_aq_cnt aq_cnt;
+	union cvmx_pko_send_tso send_tso;
 	struct octeon3_ethernet_node *oen;
 	u8 l4_hdr = 0;
 	unsigned int checksum_alg;
@@ -1908,6 +1912,7 @@ static int octeon3_eth_ndo_start_xmit(struct sk_buff *skb, struct net_device *ne
 	int gaura = 0;
 	void *buffers_needed = NULL;
 	void **buf;
+	unsigned int mss;
 
 	frag_count = 0;
 	if (skb_has_frag_list(skb))
@@ -2036,6 +2041,18 @@ static int octeon3_eth_ndo_start_xmit(struct sk_buff *skb, struct net_device *ne
 	cvmx_scratch_write64(scr_off, send_hdr.u64);
 	scr_off += sizeof(send_hdr);
 
+	/* Add the tso descriptor if needed */
+	mss = skb_shinfo(skb)->gso_size;
+	if (mss) {
+		send_tso.u64 = 0;
+		send_tso.s.l2len = 12;
+		send_tso.s.subdc4 = CVMX_PKO_SENDSUBDC_TSO;
+		send_tso.s.sb = skb_transport_offset(skb) + tcp_hdrlen(skb);
+		send_tso.s.mss = netdev->mtu + ETH_HLEN;
+		cvmx_scratch_write64(scr_off, send_tso.u64);
+		scr_off += sizeof(send_tso);
+	}
+
 	buf_ptr.u64 = 0;
 	buf_ptr.s.subdc3 = CVMX_PKO_SENDSUBDC_GATHER;
 
-- 
2.6.2

