From 7f7fe16a70278e61cd9e96071a80b4c007760edd Mon Sep 17 00:00:00 2001
From: Taras Kondratiuk <takondra@cisco.com>
Date: Tue, 10 Nov 2015 17:25:24 -0800
Subject: [PATCH 964/974] MIPS: traps: call crash_kexec() before panic() when
 dying

In general crash_kexec() can be called from two places:
- from die() in case of exception route
- from panic() when it is invoked explicitly

In a current MIPS code in most cases execution won't reach crash_kexec()
call in die(), because it gets intercepted by panic(). Unfortunately
panic() cannot pass stored registers to crash_kexec(), so backtrace in
the coredump won't start from a crash point. Instead it will be in an
exception context.

There are at least two reasons to fix it:
- it complicates crashdump analysis and further debugging
- it doesn't match with behavior of other architectures

Change-Id: I4924264e6b17925738fba074ba68c58e3830c547
Bug-Id: CSCuu82009
Signed-off-by: Taras Kondratiuk <takondra@cisco.com>
Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/kernel/traps.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index 9da81ea..472eade 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -386,15 +386,15 @@ void __noreturn die(const char *str, struct pt_regs *regs)
 
 	oops_exit();
 
+	if (regs && kexec_should_crash(current))
+		crash_kexec(regs);
+
 	if (in_interrupt())
 		panic("Fatal exception in interrupt");
 
 	if (panic_on_oops)
 		panic("Fatal exception");
 
-	if (regs && kexec_should_crash(current))
-		crash_kexec(regs);
-
 	do_exit(sig);
 }
 
-- 
2.6.2

