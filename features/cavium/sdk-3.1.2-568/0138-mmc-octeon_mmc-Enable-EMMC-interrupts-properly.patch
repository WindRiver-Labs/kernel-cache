From fe8b56ce5fae4d79f8804edd4a883337071c38fe Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Tue, 18 Aug 2015 20:06:22 -0700
Subject: [PATCH 138/184] mmc: octeon_mmc: Enable EMMC interrupts properly

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 2a786202be59e5474fd67170ef8d5739bd48ceab
Description:

Some Octeon models use CIU3 interrupts which are handled differently,
no need to enable by setting MIO_EMM_INT_EN.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mmc/host/octeon_mmc.c | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/drivers/mmc/host/octeon_mmc.c b/drivers/mmc/host/octeon_mmc.c
index 04c970d..1c697be 100644
--- a/drivers/mmc/host/octeon_mmc.c
+++ b/drivers/mmc/host/octeon_mmc.c
@@ -79,6 +79,7 @@ struct octeon_mmc_host {
 	bool big_dma_addr;
 	bool need_irq_handler_lock;
 	spinlock_t irq_handler_lock;
+	bool has_ciu3;
 
 	struct octeon_mmc_slot	*slot[OCTEON_MAX_MMC];
 };
@@ -645,7 +646,8 @@ static void octeon_mmc_dma_request(struct mmc_host *mmc,
 	emm_int.s.dma_err = 1;
 	/* Clear the bit. */
 	cvmx_write_csr(host->base + OCT_MIO_EMM_INT, emm_int.u64);
-	cvmx_write_csr(host->base + OCT_MIO_EMM_INT_EN, emm_int.u64);
+	if (!host->has_ciu3)
+		cvmx_write_csr(host->base + OCT_MIO_EMM_INT_EN, emm_int.u64);
 	host->dma_active = true;
 
 	if ((OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF7XXX)) &&
@@ -747,7 +749,8 @@ static void octeon_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	}
 	/* Clear the bit. */
 	cvmx_write_csr(host->base + OCT_MIO_EMM_INT, emm_int.u64);
-	cvmx_write_csr(host->base + OCT_MIO_EMM_INT_EN, emm_int.u64);
+	if (!host->has_ciu3)
+		cvmx_write_csr(host->base + OCT_MIO_EMM_INT_EN, emm_int.u64);
 	host->dma_active = false;
 
 	emm_cmd.u64 = 0;
@@ -1150,6 +1153,7 @@ static int octeon_mmc_probe(struct platform_device *pdev)
 		host->need_bootbus_lock = false;
 		host->big_dma_addr = true;
 		host->need_irq_handler_lock = true;
+		host->has_ciu3 = true;
 		/*
 		 * First seven are the EMM_INT bits 0..6, then two for
 		 * the EMM_DMA_INT bits
@@ -1163,6 +1167,7 @@ static int octeon_mmc_probe(struct platform_device *pdev)
 		host->need_bootbus_lock = true;
 		host->big_dma_addr = false;
 		host->need_irq_handler_lock = false;
+		host->has_ciu3 = false;
 		/* First one is EMM second NDF_DMA */
 		for (i = 0; i < 2; i++) {
 			mmc_irq[i] = platform_get_irq(pdev, i);
-- 
1.9.1

