From 5e01e84e6d8968661a13539d1ce18928662755fa Mon Sep 17 00:00:00 2001
From: Emil Goranov <egoranov@caviumnetworks.com>
Date: Thu, 15 Oct 2015 13:34:39 -0700
Subject: [PATCH 152/184] oct-app-ctl: get correct value for available
 cores(not limited to 32 cores)

The bootloader was modified (svn 126700) to communicate coremask of
the cores available on the system and the idle cores after cores
have been started, by named_block with name '__common_bootinfo'.
These data, which are addition to cvmx_bootinfo are structured as
cvmx_coremask_t 'hardware_coremask' and 'aval_coremask' and can be
retrieved from all interested started clients (SE or Linux).
This patch gets the idle_coremask which is needed for oct-app-ctl.

Signed-off-by: Emil Goranov <egoranov@caviumnetworks.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/unplug-cpu.c | 58 +++++++++++++++++++++++++++++++-----
 1 file changed, 51 insertions(+), 7 deletions(-)

diff --git a/arch/mips/cavium-octeon/unplug-cpu.c b/arch/mips/cavium-octeon/unplug-cpu.c
index fdaca18..a7eda91 100644
--- a/arch/mips/cavium-octeon/unplug-cpu.c
+++ b/arch/mips/cavium-octeon/unplug-cpu.c
@@ -15,12 +15,14 @@
 #include <asm/octeon/octeon-boot-info.h>
 #include <asm/octeon/cvmx-app-hotplug.h>
 #include <asm/octeon/cvmx-spinlock.h>
+#include <asm/octeon/cvmx-coremask.h>
 
 static struct cvmx_boot_vector_element *octeon_bootvector;
 static void *octeon_replug_ll_raw;
 asmlinkage void octeon_replug_ll(void);
 
 static struct cvmx_app_hotplug_global *hgp;
+static const cvmx_bootmem_named_block_desc_t *ccbi_desc;
 
 DECLARE_PER_CPU(struct cpu, cpu_devices);
 
@@ -136,10 +138,27 @@ static ssize_t unplug_cpu_print(struct device *dev,
 DEVICE_ATTR(octeon_plug, 0644, unplug_cpu_print, plug_cpu_store);
 DEVICE_ATTR(octeon_unplug, 0644, unplug_cpu_print, unplug_cpu_store);
 
+/* the following function will work ONLY with size%8 = 0 */
+static
+int __cvmx_copy_from_bootmem(int64_t bootmem_src_addr, void *dst_ptr, int size)
+{
+	int i;
+	int64_t base_addr = (1ull << 63) | bootmem_src_addr;
+	int64_t *ptr64 = dst_ptr;
+
+	for (i = 0; i < size/8; i++) {
+		ptr64[i] = cvmx_read64_int64(base_addr);
+		base_addr += 8;
+	}
+	return 0;
+}
+
 static void __init octeon_hotplug_global_init(void *arg)
 {
 	struct linux_app_boot_info *labi;
 	cvmx_app_hotplug_global_t *hgp = arg;
+	cvmx_cores_common_bootinfo_t ccbi;
+
 	memset(hgp, 0, CVMX_APP_HOTPLUG_INFO_REGION_SIZE);
 
 	hgp->magic_version = CVMX_HOTPLUG_MAGIC_VERSION;
@@ -149,13 +168,28 @@ static void __init octeon_hotplug_global_init(void *arg)
 	/* Get legacy LABI data structure for initial parameters */
 	labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
 
-	/* Valicate signature */
-	if (labi->labi_signature != LABI_SIGNATURE)
-		return;
-
-	/* Initialize available cores from LABI */
-	cvmx_coremask_set64(&hgp->avail_coremask,
-		(uint64_t) labi->avail_coremask);
+	/* Initialize available cores from LABI is limited to 32 cores
+	 * - try to do not use it - instead do ... */
+	if (ccbi_desc) { /* 'common bootinfo' named block is found - use it*/
+		__cvmx_copy_from_bootmem(ccbi_desc->base_addr, &ccbi,
+					sizeof(cvmx_cores_common_bootinfo_t));
+		/* Validate signature */
+		if (ccbi.magic != CVMX_COMMON_BOOTINFO_MAGIC)
+			return; /* if 'magic' does not match - exit */
+		/* the members from the initial(1) version are always valid */
+		/* only hgp->avail_coremask is need - fill it in */
+		cvmx_coremask_copy(&hgp->avail_coremask, &ccbi.avail_coremask);
+		/* the extra (version) members (if any) are valid when
+		 * (2 <= ccbi.version <= CVMX_COMMON_BOOTINFO_VERSION)
+		 * if (ccbi.version >= 2) { xxx = ccbi.ver2_member; }
+		 */
+	} else { /* the older bootloaders provide only labi->avail_coremask */
+		/* Validate signature */
+		if (labi->labi_signature != LABI_SIGNATURE)
+			return;
+		cvmx_coremask_set64(&hgp->avail_coremask,
+					(uint64_t) labi->avail_coremask);
+	}
 }
 
 static int __init unplug_cpu_init(void)
@@ -170,6 +204,16 @@ static int __init unplug_cpu_init(void)
 	t = __pa_symbol(octeon_replug_ll);
 	octeon_replug_ll_raw = phys_to_virt(t);
 
+	/* the 'common bootinfo' named block should be found/copied before
+	 * creating hotplug named block,
+	 * because avail_coremask is copied from it
+	 */
+	ccbi_desc =
+		cvmx_bootmem_find_named_block(CVMX_APP_COMMON_BOOTINFO_NAME);
+	if (!ccbi_desc)
+		pr_info("Info: cvmx_bootmem_find_named_block(%s) not found.\n",
+						CVMX_APP_COMMON_BOOTINFO_NAME);
+
 	hgp = cvmx_bootmem_alloc_named_range_once(
 		CVMX_APP_HOTPLUG_INFO_REGION_SIZE,
 		0x0, 1ull << 29, 0,
-- 
1.9.1

