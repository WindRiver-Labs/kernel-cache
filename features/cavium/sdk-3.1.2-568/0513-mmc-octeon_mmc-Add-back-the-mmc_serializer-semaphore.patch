From 25db6ef796200e96de22885ff5473697c6e82d9a Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Sun, 2 Mar 2014 13:46:59 -0800
Subject: [PATCH 513/974] mmc octeon_mmc: Add back the mmc_serializer semaphore
 for cn78XX

Even though we no longer need the bootbus semaphore, we still need to
serialize access to the MMC host hardware, so put back the original
mmc_serializer for this case.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/mmc/host/octeon_mmc.c | 33 ++++++++++++++++++---------------
 1 file changed, 18 insertions(+), 15 deletions(-)

diff --git a/drivers/mmc/host/octeon_mmc.c b/drivers/mmc/host/octeon_mmc.c
index bd6e30a..e848693 100644
--- a/drivers/mmc/host/octeon_mmc.c
+++ b/drivers/mmc/host/octeon_mmc.c
@@ -63,6 +63,7 @@ struct octeon_mmc_host {
 	u64	emm_cfg;
 	int	last_slot;
 
+	struct semaphore mmc_serializer;
 	struct mmc_request	*current_req;
 	unsigned int		linear_buf_size;
 	void			*linear_buf;
@@ -74,7 +75,7 @@ struct octeon_mmc_host {
 	int global_pwr_gpio;
 	bool global_pwr_gpio_low;
 	bool dma_err_pending;
-	bool need_bus_lock;
+	bool need_bootbus_lock;
 	bool big_dma_addr;
 
 	struct octeon_mmc_slot	*slot[OCTEON_MAX_MMC];
@@ -115,21 +116,22 @@ static inline octeon_mmc_dbg(const char *s, ...) { }
 
 static void octeon_mmc_acquire_bus(struct octeon_mmc_host *host)
 {
-	if (!host->need_bus_lock)
-		return;
-
-	down(&octeon_bootbus_sem);
-	/* On cn70XX switch the mmc unit onto the bus. */
-	if (OCTEON_IS_MODEL(OCTEON_CN70XX))
-		cvmx_write_csr(CVMX_MIO_BOOT_CTL, 0);
+	if (host->need_bootbus_lock) {
+		down(&octeon_bootbus_sem);
+		/* On cn70XX switch the mmc unit onto the bus. */
+		if (OCTEON_IS_MODEL(OCTEON_CN70XX))
+			cvmx_write_csr(CVMX_MIO_BOOT_CTL, 0);
+	} else {
+		down(&host->mmc_serializer);
+	}
 }
 
 static void octeon_mmc_release_bus(struct octeon_mmc_host *host)
 {
-	if (!host->need_bus_lock)
-		return;
-
-	up(&octeon_bootbus_sem);
+	if (host->need_bootbus_lock)
+		up(&octeon_bootbus_sem);
+	else
+		up(&host->mmc_serializer);
 }
 
 struct octeon_mmc_cr_type {
@@ -1019,9 +1021,11 @@ static int octeon_mmc_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "devm_kzalloc failed\n");
 		return -ENOMEM;
 	}
+	sema_init(&host->mmc_serializer, 1);
+
 	cn78xx_style = of_device_is_compatible(node, "cavium,octeon-7890-mmc");
 	if (cn78xx_style) {
-		host->need_bus_lock = false;
+		host->need_bootbus_lock = false;
 		host->big_dma_addr = true;
 		/*
 		 * First seven are the EMM_INT bits 0..6, then two for
@@ -1033,7 +1037,7 @@ static int octeon_mmc_probe(struct platform_device *pdev)
 				return mmc_irq[i];
 		}
 	} else {
-		host->need_bus_lock = true;
+		host->need_bootbus_lock = true;
 		host->big_dma_addr = false;
 		/* First one is EMM second NDF_DMA */
 		for (i = 0; i < 2; i++) {
@@ -1242,7 +1246,6 @@ static int octeon_mmc_remove(struct platform_device *pdev)
 
 		mmc_free_host(host->mmc);
 	}
-
 	platform_set_drvdata(pdev, NULL);
 	return 0;
 }
-- 
2.6.2

