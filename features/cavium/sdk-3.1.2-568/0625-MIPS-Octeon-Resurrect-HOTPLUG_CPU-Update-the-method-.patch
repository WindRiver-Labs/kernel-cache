From b71004f7cf3524dd168e50bad098df5b18cca78d Mon Sep 17 00:00:00 2001
From: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Date: Tue, 29 Jul 2014 10:24:50 -0700
Subject: [PATCH 625/974] MIPS: Octeon: Resurrect HOTPLUG_CPU Update the method
 for locating boot vector with latest bootloader methods, namely named block
 AND moveable region last 2 words; Fix boot-time SMP coremask handling for >32
 cores;

Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/smp.c | 129 ++++++++++++++++++++++++++++++++++++------
 1 file changed, 113 insertions(+), 16 deletions(-)

diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index fff45b9..6405b24 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -391,10 +391,17 @@ static void octeon_cpus_done(void)
 {
 #ifdef CONFIG_HOTPLUG_CPU
 	struct cvmx_app_hotplug_global *hgp;
+	struct cvmx_sysinfo *sysinfo = cvmx_sysinfo_get();
 	unsigned int cpu;
 
 	hgp = octeon_hotplug_global_ptr;
 
+	/* Boot core_mask is only used during boot-time SMP setup,
+	 * and needs to be cleared for CPU_HOTPLUG to work
+	 * with these and other cores.
+	 */
+	cvmx_coremask_clear_all(&sysinfo->core_mask);
+
 	/* Boot core_mask CPUs are now all on-line,
 	 * make the rest of the CPUs available for HOTPLUG
 	 * regardless if they are presently available
@@ -480,21 +487,121 @@ void play_dead(void)
 	}
 }
 
+/*
+ * Find the location of the system-wide boot vector table
+ * for a given node.
+ */
+static boot_init_vector_t *octeon_get_boot_vector(unsigned node)
+{
+	boot_init_vector_t *boot_vect;
+	cvmx_mio_boot_loc_cfgx_t boot_loc_cfg;
+	uint64_t addr = 0, io_addr, magic, vector;
+
+#ifdef OCTEON_BOOT_VECTOR_LOCATOR_NAME
+	/*
+	 * Try to locate boot vector using its name,
+	 * in case the address has been overwritten
+	 * in BOOT_MIO region.
+	 */
+	const cvmx_bootmem_named_block_desc_t *desc;
+	char name[32], n[2] = "0";
+
+	strcpy(name, OCTEON_BOOT_VECTOR_LOCATOR_NAME);
+	n[0] += node;
+	strcat(name, n);
+
+	pr_debug("%s: block name '%s'\n", __func__, name);
+
+	desc = cvmx_bootmem_find_named_block(name);
+	if (desc != NULL)
+		addr  = desc->base_addr;
+
+	if (addr != 0) {
+		/* Convert to virtual address */
+		boot_vect = cvmx_phys_to_ptr(addr);
+
+		pr_debug("boot_vect location paddr %#llx, vaddr %p\n",
+			(unsigned long long)addr, boot_vect);
+
+		/* Use vector table address located by name */
+		return boot_vect;
+	}
+#endif
+
+	boot_loc_cfg.u64 = cvmx_read_csr_node(node, CVMX_MIO_BOOT_LOC_CFGX(0));
+	if (!boot_loc_cfg.s.en) {
+		pr_warn("ERROR: MIO_BOOT_LOC_CFG not enabled\n");
+		goto _old_bloader;
+	}
+
+	addr = boot_loc_cfg.s.base << 7;
+	io_addr = (addr | (1ULL << 48)  | (1ULL << 63) |
+		(uint64_t)node << CVMX_NODE_IO_SHIFT);
+
+	pr_debug("Moveable address = %#llx\n", (unsigned long long) io_addr);
+
+	/* Read vector location from movable region */
+	magic = cvmx_read64_uint64(io_addr +
+		OCTEON_BOOT_MOVEABLE_MAGIC_OFFSET);
+	vector = cvmx_read64_uint64(io_addr +
+		OCTEON_BOOT_VECTOR_MOVEABLE_OFFSET);
+
+	/* Validate vector location */
+	if (magic != OCTEON_BOOT_MOVEABLE_MAGIC) {
+		pr_warn("ERROR: MOVEABLE_MAGIC invalid %#llx != %#llx\n",
+			(unsigned long long)magic,
+			(unsigned long long)OCTEON_BOOT_MOVEABLE_MAGIC);
+		goto _old_bloader;
+	}
+
+	if (vector == 0) {
+		pr_warn("ERROR: MOVEABLE_OFFSET is zero!\n");
+		goto _old_bloader;
+	}
+
+	/* Make physical address */
+	addr = vector & ~(1ULL << 63);
+
+	/* Convert to virtual address */
+	boot_vect = cvmx_phys_to_ptr(addr);
+
+	pr_debug("new boot_vect location paddr %#llx, vaddr %p\n",
+			(unsigned long long)addr, boot_vect);
+
+	return boot_vect;
+
+_old_bloader:
+	boot_vect = phys_to_virt(BOOTLOADER_BOOT_VECTOR);
+	pr_warn("WARNING: old bootloader assumed\n");
+	pr_debug("boot_vect paddr %#llx, vaddr %p\n",
+			(unsigned long long)BOOTLOADER_BOOT_VECTOR, boot_vect);
+
+	return boot_vect;
+}
+
+
 static int octeon_update_boot_vector(unsigned int cpu)
 {
-#if 0
 	int coreid = cpu_logical_map(cpu);
 	int node;
 	struct cvmx_app_hotplug_global *hgp = octeon_hotplug_global_ptr;
-	struct boot_init_vector *boot_vect =
-		phys_to_virt(BOOTLOADER_BOOT_VECTOR);
-
+	struct boot_init_vector *boot_vect;
+	struct cvmx_sysinfo *sysinfo = cvmx_sysinfo_get();
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+	/*
+	 * A core being brought up must be present either in the boot
+	 * core_mask or in the hotplug available coremask
+	 */
+	if ((cvmx_coremask_is_core_set(&sysinfo->core_mask, coreid))) {
+		/* CPU in boot core mask needs no further handling */
 		return 0;
+	}
+
+	/* Get boot vector address for this node */
+	boot_vect = octeon_get_boot_vector(cvmx_coremask_core_to_node(coreid));
 
 	/* Verify that required entry points are known at this stage */
-	if (!hgp || !octeon_hotplug_entry_addr ||
+	if (!hgp || !octeon_hotplug_entry_addr || !boot_vect ||
 			!octeon_bootloader_entry_addr) {
 		pr_warn("Cavium Hotplug: boot-loader incompatible with Hotplug\n");
 		return -EINVAL;
@@ -507,15 +614,6 @@ static int octeon_update_boot_vector(unsigned int cpu)
 		return -EINVAL;
 	}
 
-	/*
-	 * A core being brought up must be present either in the boot
-	 * core_mask or in the hotplug available coremask
-	 */
-	if (boot_core_mask & (1 << coreid)) {
-		boot_core_mask &= ~(1 << coreid);
-		/* CPU in boot core mask needs no further handling */
-		return 0;
-	}
 	cvmx_spinlock_lock(&hgp->hotplug_global_lock);
 	if (!cvmx_coremask_is_core_set(&hgp->avail_coremask, coreid)) {
 		cvmx_spinlock_unlock(&hgp->hotplug_global_lock);
@@ -538,7 +636,6 @@ static int octeon_update_boot_vector(unsigned int cpu)
 	node = cvmx_coremask_core_to_node(coreid);
 	coreid = cvmx_coremask_core_on_node(coreid);
 	cvmx_write_csr_node(node, CVMX_CIU_NMI, (1 << coreid));
-#endif
 
 	return 0;
 }
-- 
2.6.2

