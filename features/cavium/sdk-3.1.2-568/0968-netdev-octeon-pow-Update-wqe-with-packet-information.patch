From aa71ca45fbcad219260b84a8dcc1ae92c720d22e Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Thu, 12 Nov 2015 17:25:24 -0800
Subject: [PATCH 968/974] netdev: octeon-pow: Update wqe with packet
 information.

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/include/asm/octeon/cvmx-wqe.h           | 1366 ++++++++++-----------
 drivers/net/ethernet/octeon/octeon-pow-ethernet.c |   76 +-
 2 files changed, 703 insertions(+), 739 deletions(-)

diff --git a/arch/mips/include/asm/octeon/cvmx-wqe.h b/arch/mips/include/asm/octeon/cvmx-wqe.h
index 6d46e27..faca8c7 100644
--- a/arch/mips/include/asm/octeon/cvmx-wqe.h
+++ b/arch/mips/include/asm/octeon/cvmx-wqe.h
@@ -49,8 +49,6 @@
  * relate to.
  *
  * This file must not depend on any other header files, except for cvmx.h!!!
- *
- *
  */
 
 #ifndef __CVMX_WQE_H__
@@ -65,117 +63,136 @@ extern "C" {
 /* *INDENT-ON* */
 #endif
 
-#define OCT_TAG_TYPE_STRING(x) (((x) == CVMX_POW_TAG_TYPE_ORDERED) ?  "ORDERED" : \
-                                (((x) == CVMX_POW_TAG_TYPE_ATOMIC) ?  "ATOMIC" : \
-                                (((x) == CVMX_POW_TAG_TYPE_NULL) ?  "NULL" : \
-                                "NULL_NULL")))
+#define OCT_TAG_TYPE_STRING(x) \
+	(((x) == CVMX_POW_TAG_TYPE_ORDERED) ?  "ORDERED" : \
+		(((x) == CVMX_POW_TAG_TYPE_ATOMIC) ?  "ATOMIC" : \
+			(((x) == CVMX_POW_TAG_TYPE_NULL) ?  "NULL" : "NULL_NULL")))
 
 /* Error levels in WQE WORD2 (ERRLEV).*/
-#define PKI_ERRLEV_E__RE_M                                 (0x0)
-#define PKI_ERRLEV_E__LA_M                                 (0x1)
-#define PKI_ERRLEV_E__LB_M                                 (0x2)
-#define PKI_ERRLEV_E__LC_M                                 (0x3)
-#define PKI_ERRLEV_E__LD_M                                 (0x4)
-#define PKI_ERRLEV_E__LE_M                                 (0x5)
-#define PKI_ERRLEV_E__LF_M                                 (0x6)
-#define PKI_ERRLEV_E__LG_M                                 (0x7)
+#define PKI_ERRLEV_E__RE_M  0x0
+#define PKI_ERRLEV_E__LA_M  0x1
+#define PKI_ERRLEV_E__LB_M  0x2
+#define PKI_ERRLEV_E__LC_M  0x3
+#define PKI_ERRLEV_E__LD_M  0x4
+#define PKI_ERRLEV_E__LE_M  0x5
+#define PKI_ERRLEV_E__LF_M  0x6
+#define PKI_ERRLEV_E__LG_M  0x7
 
 enum cvmx_pki_errlevel {
-	CVMX_PKI_ERRLEV_E_RE                         = PKI_ERRLEV_E__RE_M,
-	CVMX_PKI_ERRLEV_E_LA                         = PKI_ERRLEV_E__LA_M,
-	CVMX_PKI_ERRLEV_E_LB                         = PKI_ERRLEV_E__LB_M,
-	CVMX_PKI_ERRLEV_E_LC                         = PKI_ERRLEV_E__LC_M,
-	CVMX_PKI_ERRLEV_E_LD                         = PKI_ERRLEV_E__LD_M,
-	CVMX_PKI_ERRLEV_E_LE                         = PKI_ERRLEV_E__LE_M,
-	CVMX_PKI_ERRLEV_E_LF                         = PKI_ERRLEV_E__LF_M,
-	CVMX_PKI_ERRLEV_E_LG                         = PKI_ERRLEV_E__LG_M
+	CVMX_PKI_ERRLEV_E_RE = PKI_ERRLEV_E__RE_M,
+	CVMX_PKI_ERRLEV_E_LA = PKI_ERRLEV_E__LA_M,
+	CVMX_PKI_ERRLEV_E_LB = PKI_ERRLEV_E__LB_M,
+	CVMX_PKI_ERRLEV_E_LC = PKI_ERRLEV_E__LC_M,
+	CVMX_PKI_ERRLEV_E_LD = PKI_ERRLEV_E__LD_M,
+	CVMX_PKI_ERRLEV_E_LE = PKI_ERRLEV_E__LE_M,
+	CVMX_PKI_ERRLEV_E_LF = PKI_ERRLEV_E__LF_M,
+	CVMX_PKI_ERRLEV_E_LG = PKI_ERRLEV_E__LG_M
 };
+
 #define CVMX_PKI_ERRLEV_MAX  (1 << 3) /* The size of WORD2:ERRLEV field.*/
 
 /* Error code in WQE WORD2 (OPCODE).*/
-#define CVMX_PKI_OPCODE_RE_NONE		0x0
-#define CVMX_PKI_OPCODE_RE_PARTIAL	0x1
-#define CVMX_PKI_OPCODE_RE_JABBER	0x2
-#define CVMX_PKI_OPCODE_RE_FCS		0x7
-#define CVMX_PKI_OPCODE_RE_FCS_RCV	0x8
-#define CVMX_PKI_OPCODE_RE_TERMINATE	0x9
-#define CVMX_PKI_OPCODE_RE_RX_CTL	0xb
-#define CVMX_PKI_OPCODE_RE_SKIP		0xc
-#define CVMX_PKI_OPCODE_RE_DMAPKT	0xf
-#define CVMX_PKI_OPCODE_RE_PKIPAR	0x13
-#define CVMX_PKI_OPCODE_RE_PKIPCAM	0x14
-#define CVMX_PKI_OPCODE_RE_MEMOUT	0x15
+#define CVMX_PKI_OPCODE_RE_NONE        0x0
+#define CVMX_PKI_OPCODE_RE_PARTIAL     0x1
+#define CVMX_PKI_OPCODE_RE_JABBER      0x2
+#define CVMX_PKI_OPCODE_RE_FCS         0x7
+#define CVMX_PKI_OPCODE_RE_FCS_RCV     0x8
+#define CVMX_PKI_OPCODE_RE_TERMINATE   0x9
+#define CVMX_PKI_OPCODE_RE_RX_CTL      0xb
+#define CVMX_PKI_OPCODE_RE_SKIP        0xc
+#define CVMX_PKI_OPCODE_RE_DMAPKT      0xf
+#define CVMX_PKI_OPCODE_RE_PKIPAR      0x13
+#define CVMX_PKI_OPCODE_RE_PKIPCAM     0x14
+#define CVMX_PKI_OPCODE_RE_MEMOUT      0x15
+#define CVMX_PKI_OPCODE_RE_BUFS_OFLOW  0x16
+#define CVMX_PKI_OPCODE_L2_FRAGMENT    0x20
+#define CVMX_PKI_OPCODE_L2_OVERRUN     0x21
+#define CVMX_PKI_OPCODE_L2_PFCS        0x22
+#define CVMX_PKI_OPCODE_L2_PUNY        0x23
+#define CVMX_PKI_OPCODE_L2_MAL         0x24
+#define CVMX_PKI_OPCODE_L2_OVERSIZE    0x25
+#define CVMX_PKI_OPCODE_L2_UNDERSIZE   0x26
+#define CVMX_PKI_OPCODE_L2_LENMISM     0x27
+#define CVMX_PKI_OPCODE_IP_NOT         0x41
+#define CVMX_PKI_OPCODE_IP_CHK         0x42
+#define CVMX_PKI_OPCODE_IP_MAL         0x43
+#define CVMX_PKI_OPCODE_IP_MALD        0x44
+#define CVMX_PKI_OPCODE_IP_HOP         0x45
+#define CVMX_PKI_OPCODE_L4_MAL         0x61
+#define CVMX_PKI_OPCODE_L4_CHK         0x62
+#define CVMX_PKI_OPCODE_L4_LEN         0x63
+#define CVMX_PKI_OPCODE_L4_PORT        0x64
+#define CVMX_PKI_OPCODE_TCP_FLAG       0x65
 
 #define CVMX_PKI_OPCODE_MAX  (1 << 8) /* The size of WORD2:OPCODE field.*/
 
 /* Layer types in pki */
-#define CVMX_PKI_LTYPE_E_NONE_M                                (0x0)
-#define CVMX_PKI_LTYPE_E_ENET_M                                (0x1)
-#define CVMX_PKI_LTYPE_E_VLAN_M                                (0x2)
-#define CVMX_PKI_LTYPE_E_SNAP_PAYLD_M                          (0x5)
-#define CVMX_PKI_LTYPE_E_ARP_M                                 (0x6)
-#define CVMX_PKI_LTYPE_E_RARP_M                                (0x7)
-#define CVMX_PKI_LTYPE_E_IP4_M                                 (0x8)
-#define CVMX_PKI_LTYPE_E_IP4_OPT_M                             (0x9)
-#define CVMX_PKI_LTYPE_E_IP6_M                                 (0xA)
-#define CVMX_PKI_LTYPE_E_IP6_OPT_M                             (0xB)
-#define CVMX_PKI_LTYPE_E_IPSEC_ESP_M                           (0xC)
-#define CVMX_PKI_LTYPE_E_IPFRAG_M                              (0xD)
-#define CVMX_PKI_LTYPE_E_IPCOMP_M                              (0xE)
-#define CVMX_PKI_LTYPE_E_TCP_M                                 (0x10)
-#define CVMX_PKI_LTYPE_E_UDP_M                                 (0x11)
-#define CVMX_PKI_LTYPE_E_SCTP_M                                (0x12)
-#define CVMX_PKI_LTYPE_E_UDP_VXLAN_M                           (0x13)
-#define CVMX_PKI_LTYPE_E_GRE_M                                 (0x14)
-#define CVMX_PKI_LTYPE_E_NVGRE_M                               (0x15)
-#define CVMX_PKI_LTYPE_E_GTP_M                                 (0x16)
-#define CVMX_PKI_LTYPE_E_SW28_M                                (0x1C)
-#define CVMX_PKI_LTYPE_E_SW29_M                                (0x1D)
-#define CVMX_PKI_LTYPE_E_SW30_M                                (0x1E)
-#define CVMX_PKI_LTYPE_E_SW31_M                                (0x1F)
+#define CVMX_PKI_LTYPE_E_NONE_M       0x0
+#define CVMX_PKI_LTYPE_E_ENET_M       0x1
+#define CVMX_PKI_LTYPE_E_VLAN_M       0x2
+#define CVMX_PKI_LTYPE_E_SNAP_PAYLD_M 0x5
+#define CVMX_PKI_LTYPE_E_ARP_M	      0x6
+#define CVMX_PKI_LTYPE_E_RARP_M	      0x7
+#define CVMX_PKI_LTYPE_E_IP4_M	      0x8
+#define CVMX_PKI_LTYPE_E_IP4_OPT_M    0x9
+#define CVMX_PKI_LTYPE_E_IP6_M        0xA
+#define CVMX_PKI_LTYPE_E_IP6_OPT_M    0xB
+#define CVMX_PKI_LTYPE_E_IPSEC_ESP_M  0xC
+#define CVMX_PKI_LTYPE_E_IPFRAG_M     0xD
+#define CVMX_PKI_LTYPE_E_IPCOMP_M     0xE
+#define CVMX_PKI_LTYPE_E_TCP_M        0x10
+#define CVMX_PKI_LTYPE_E_UDP_M        0x11
+#define CVMX_PKI_LTYPE_E_SCTP_M       0x12
+#define CVMX_PKI_LTYPE_E_UDP_VXLAN_M  0x13
+#define CVMX_PKI_LTYPE_E_GRE_M        0x14
+#define CVMX_PKI_LTYPE_E_NVGRE_M      0x15
+#define CVMX_PKI_LTYPE_E_GTP_M        0x16
+#define CVMX_PKI_LTYPE_E_SW28_M       0x1C
+#define CVMX_PKI_LTYPE_E_SW29_M       0x1D
+#define CVMX_PKI_LTYPE_E_SW30_M       0x1E
+#define CVMX_PKI_LTYPE_E_SW31_M       0x1F
 
 enum cvmx_pki_layer_type {
-	CVMX_PKI_LTYPE_E_NONE                        = CVMX_PKI_LTYPE_E_NONE_M,
-	CVMX_PKI_LTYPE_E_ENET                        = CVMX_PKI_LTYPE_E_ENET_M,
-	CVMX_PKI_LTYPE_E_VLAN                        = CVMX_PKI_LTYPE_E_VLAN_M,
-	CVMX_PKI_LTYPE_E_SNAP_PAYLD                  = CVMX_PKI_LTYPE_E_SNAP_PAYLD_M,
-	CVMX_PKI_LTYPE_E_ARP                         = CVMX_PKI_LTYPE_E_ARP_M,
-	CVMX_PKI_LTYPE_E_RARP                        = CVMX_PKI_LTYPE_E_RARP_M,
-	CVMX_PKI_LTYPE_E_IP4                         = CVMX_PKI_LTYPE_E_IP4_M,
-	CVMX_PKI_LTYPE_E_IP4_OPT                     = CVMX_PKI_LTYPE_E_IP4_OPT_M,
-	CVMX_PKI_LTYPE_E_IP6                         = CVMX_PKI_LTYPE_E_IP6_M,
-	CVMX_PKI_LTYPE_E_IP6_OPT                     = CVMX_PKI_LTYPE_E_IP6_OPT_M,
-	CVMX_PKI_LTYPE_E_IPSEC_ESP                   = CVMX_PKI_LTYPE_E_IPSEC_ESP_M,
-	CVMX_PKI_LTYPE_E_IPFRAG                      = CVMX_PKI_LTYPE_E_IPFRAG_M,
-	CVMX_PKI_LTYPE_E_IPCOMP                      = CVMX_PKI_LTYPE_E_IPCOMP_M,
-	CVMX_PKI_LTYPE_E_TCP                         = CVMX_PKI_LTYPE_E_TCP_M,
-	CVMX_PKI_LTYPE_E_UDP                         = CVMX_PKI_LTYPE_E_UDP_M,
-	CVMX_PKI_LTYPE_E_SCTP                        = CVMX_PKI_LTYPE_E_SCTP_M,
-	CVMX_PKI_LTYPE_E_UDP_VXLAN                   = CVMX_PKI_LTYPE_E_UDP_VXLAN_M,
-	CVMX_PKI_LTYPE_E_GRE                         = CVMX_PKI_LTYPE_E_GRE_M,
-	CVMX_PKI_LTYPE_E_NVGRE                       = CVMX_PKI_LTYPE_E_NVGRE_M,
-	CVMX_PKI_LTYPE_E_GTP                         = CVMX_PKI_LTYPE_E_GTP_M,
-	CVMX_PKI_LTYPE_E_SW28                        = CVMX_PKI_LTYPE_E_SW28_M,
-	CVMX_PKI_LTYPE_E_SW29                        = CVMX_PKI_LTYPE_E_SW29_M,
-	CVMX_PKI_LTYPE_E_SW30                        = CVMX_PKI_LTYPE_E_SW30_M,
-	CVMX_PKI_LTYPE_E_SW31                        = CVMX_PKI_LTYPE_E_SW31_M,
-        CVMX_PKI_LTYPE_E_MAX                         = CVMX_PKI_LTYPE_E_SW31
+	CVMX_PKI_LTYPE_E_NONE       = CVMX_PKI_LTYPE_E_NONE_M,
+	CVMX_PKI_LTYPE_E_ENET       = CVMX_PKI_LTYPE_E_ENET_M,
+	CVMX_PKI_LTYPE_E_VLAN       = CVMX_PKI_LTYPE_E_VLAN_M,
+	CVMX_PKI_LTYPE_E_SNAP_PAYLD = CVMX_PKI_LTYPE_E_SNAP_PAYLD_M,
+	CVMX_PKI_LTYPE_E_ARP        = CVMX_PKI_LTYPE_E_ARP_M,
+	CVMX_PKI_LTYPE_E_RARP       = CVMX_PKI_LTYPE_E_RARP_M,
+	CVMX_PKI_LTYPE_E_IP4        = CVMX_PKI_LTYPE_E_IP4_M,
+	CVMX_PKI_LTYPE_E_IP4_OPT    = CVMX_PKI_LTYPE_E_IP4_OPT_M,
+	CVMX_PKI_LTYPE_E_IP6        = CVMX_PKI_LTYPE_E_IP6_M,
+	CVMX_PKI_LTYPE_E_IP6_OPT    = CVMX_PKI_LTYPE_E_IP6_OPT_M,
+	CVMX_PKI_LTYPE_E_IPSEC_ESP  = CVMX_PKI_LTYPE_E_IPSEC_ESP_M,
+	CVMX_PKI_LTYPE_E_IPFRAG     = CVMX_PKI_LTYPE_E_IPFRAG_M,
+	CVMX_PKI_LTYPE_E_IPCOMP     = CVMX_PKI_LTYPE_E_IPCOMP_M,
+	CVMX_PKI_LTYPE_E_TCP        = CVMX_PKI_LTYPE_E_TCP_M,
+	CVMX_PKI_LTYPE_E_UDP        = CVMX_PKI_LTYPE_E_UDP_M,
+	CVMX_PKI_LTYPE_E_SCTP       = CVMX_PKI_LTYPE_E_SCTP_M,
+	CVMX_PKI_LTYPE_E_UDP_VXLAN  = CVMX_PKI_LTYPE_E_UDP_VXLAN_M,
+	CVMX_PKI_LTYPE_E_GRE        = CVMX_PKI_LTYPE_E_GRE_M,
+	CVMX_PKI_LTYPE_E_NVGRE      = CVMX_PKI_LTYPE_E_NVGRE_M,
+	CVMX_PKI_LTYPE_E_GTP        = CVMX_PKI_LTYPE_E_GTP_M,
+	CVMX_PKI_LTYPE_E_SW28       = CVMX_PKI_LTYPE_E_SW28_M,
+	CVMX_PKI_LTYPE_E_SW29       = CVMX_PKI_LTYPE_E_SW29_M,
+	CVMX_PKI_LTYPE_E_SW30       = CVMX_PKI_LTYPE_E_SW30_M,
+	CVMX_PKI_LTYPE_E_SW31       = CVMX_PKI_LTYPE_E_SW31_M,
+	CVMX_PKI_LTYPE_E_MAX        = CVMX_PKI_LTYPE_E_SW31
 };
 
-
 typedef union {
 	uint64_t u64;
 #ifdef __BIG_ENDIAN_BITFIELD
 	struct {
-		uint64_t ptr_vlan:8;              /**< Contains a byte pointer to the first byte of the
-					               VLAN ID field for the first or second VLAN. */
-		uint64_t ptr_layer_g:8;           /**< Contains a byte pointer to the start of layer G */
-		uint64_t ptr_layer_f:8;           /**< Contains a byte pointer to the start of layer F */
-		uint64_t ptr_layer_e:8;           /**< Contains a byte pointer to the start of layer E */
-		uint64_t ptr_layer_d:8;           /**< Contains a byte pointer to the start of layer D */
-		uint64_t ptr_layer_c:8;           /**< Contains a byte pointer to the start of layer C */
-		uint64_t ptr_layer_b:8;           /**< Contains a byte pointer to the start of layer B */
-		uint64_t ptr_layer_a:8;           /**< Contains a byte pointer to the start of layer A */
+		uint64_t ptr_vlan:8; /**< Contains a byte pointer to the first byte
+			of the VLAN ID field for the first or second VLAN. */
+		uint64_t ptr_layer_g:8; /**< Contains a byte pointer to the start of layer G */
+		uint64_t ptr_layer_f:8; /**< Contains a byte pointer to the start of layer F */
+		uint64_t ptr_layer_e:8; /**< Contains a byte pointer to the start of layer E */
+		uint64_t ptr_layer_d:8; /**< Contains a byte pointer to the start of layer D */
+		uint64_t ptr_layer_c:8; /**< Contains a byte pointer to the start of layer C */
+		uint64_t ptr_layer_b:8; /**< Contains a byte pointer to the start of layer B */
+		uint64_t ptr_layer_a:8; /**< Contains a byte pointer to the start of layer A */
 	};
 #else
 	struct {
@@ -187,7 +204,6 @@ typedef union {
 		uint64_t ptr_layer_f:8;
 		uint64_t ptr_layer_g:8;
 		uint64_t ptr_vlan:8;
-
 	};
 #endif
 } cvmx_pki_wqe_word4_t;
@@ -197,346 +213,319 @@ typedef union {
  */
 typedef union {
 	uint64_t u64;
-
 #ifdef __BIG_ENDIAN_BITFIELD
-    /** Use this struct if the hardware determines that the packet is IP */
+	/** Use this struct if the hardware determines that the packet is IP */
 	struct {
-		uint64_t bufs:8;		  /**< HW sets this to the number of buffers used by this packet */
-		uint64_t ip_offset:8;		  /**< HW sets to the number of L2 bytes prior to the IP */
-		uint64_t vlan_valid:1;		  /**< set to 1 if we found DSA/VLAN in the L2 */
-		uint64_t vlan_stacked:1;	  /**< Set to 1 if the DSA/VLAN tag is stacked */
+		uint64_t bufs:8; /**< HW sets this to the number of buffers used by this packet */
+		uint64_t ip_offset:8; /**< HW sets to the number of L2 bytes prior to the IP */
+		uint64_t vlan_valid:1; /**< set to 1 if we found DSA/VLAN in the L2 */
+		uint64_t vlan_stacked:1; /**< Set to 1 if the DSA/VLAN tag is stacked */
 		uint64_t unassigned:1;
-		uint64_t vlan_cfi:1;		  /**< HW sets to the DSA/VLAN CFI flag (valid when vlan_valid) */
-		uint64_t vlan_id:12;		  /**< HW sets to the DSA/VLAN_ID field (valid when vlan_valid) */
-		uint64_t varies:12;
-				/**< 38xx and 68xx have different definitions.  */
-		uint64_t dec_ipcomp:1;		  /**< the packet needs to be decompressed */
-		uint64_t tcp_or_udp:1;		  /**< the packet is either TCP or UDP */
-		uint64_t dec_ipsec:1;		  /**< the packet needs to be decrypted (ESP or AH) */
-		uint64_t is_v6:1;		  /**< the packet is IPv6 */
-
+		uint64_t vlan_cfi:1; /**< HW sets to the DSA/VLAN CFI flag (valid when vlan_valid) */
+		uint64_t vlan_id:12; /**< HW sets to the DSA/VLAN_ID field (valid when vlan_valid) */
+		uint64_t varies:12; /**< 38xx and 68xx have different definitions.  */
+		uint64_t dec_ipcomp:1; /**< the packet needs to be decompressed */
+		uint64_t tcp_or_udp:1; /**< the packet is either TCP or UDP */
+		uint64_t dec_ipsec:1; /**< the packet needs to be decrypted (ESP or AH) */
+		uint64_t is_v6:1; /**< The packet is IPv6 */
 		/* (rcv_error, not_IP, IP_exc, is_frag, L4_error, software, etc.) */
-
-		uint64_t software:1;		  /**< reserved for software use, hardware will clear on packet creation */
-		/* exceptional conditions below */
-		uint64_t L4_error:1;		  /**< the receive interface hardware detected an L4 error (only applies if !is_frag)
-                                                    (only applies if !rcv_error && !not_IP && !IP_exc && !is_frag)
-                                                    failure indicated in err_code below, decode:
-                                                    - 1 = Malformed L4
-                                                    - 2 = L4 Checksum Error: the L4 checksum value is
-                                                    - 3 = UDP Length Error: The UDP length field would make the UDP data longer than what
-                                                        remains in the IP packet (as defined by the IP header length field).
-                                                    - 4 = Bad L4 Port: either the source or destination TCP/UDP port is 0.
-                                                    - 8 = TCP FIN Only: the packet is TCP and only the FIN flag set.
-                                                    - 9 = TCP No Flags: the packet is TCP and no flags are set.
-                                                    - 10 = TCP FIN RST: the packet is TCP and both FIN and RST are set.
-                                                    - 11 = TCP SYN URG: the packet is TCP and both SYN and URG are set.
-                                                    - 12 = TCP SYN RST: the packet is TCP and both SYN and RST are set.
-                                                    - 13 = TCP SYN FIN: the packet is TCP and both SYN and FIN are set. */
-
-		uint64_t is_frag:1;		  /**< set if the packet is a fragment */
-		uint64_t IP_exc:1;		  /**< the receive interface hardware detected an IP error / exception
-                                                    (only applies if !rcv_error && !not_IP) failure indicated in err_code below, decode:
-                                                    - 1 = Not IP: the IP version field is neither 4 nor 6.
-                                                    - 2 = IPv4 Header Checksum Error: the IPv4 header has a checksum violation.
-                                                    - 3 = IP Malformed Header: the packet is not long enough to contain the IP header.
-                                                    - 4 = IP Malformed: the packet is not long enough to contain the bytes indicated by the IP
-                                                        header. Pad is allowed.
-                                                    - 5 = IP TTL Hop: the IPv4 TTL field or the IPv6 Hop Count field are zero.
-                                                    - 6 = IP Options */
-
-		uint64_t is_bcast:1;		  /**< set if the hardware determined that the packet is a broadcast */
-		uint64_t is_mcast:1;		  /**< set if the hardware determined that the packet is a multi-cast */
-		uint64_t not_IP:1;		  /**< set if the packet may not be IP (must be zero in this case) */
-		uint64_t rcv_error:1;		  /**< the receive interface hardware detected a receive error (must be zero in this case) */
-		/* lower err_code = first-level descriptor of the work */
-		/* zero for packet submitted by hardware that isn't on the slow path */
-
-		uint64_t err_code:8;		  /**< type is cvmx_pip_err_t */
+		uint64_t software:1; /**< reserved for software use, hardware will
+			clear on packet creation */
+		/* Exceptional conditions below */
+		uint64_t L4_error:1; /**< The receive interface hardware detected an L4 error
+			(Only applies, if !is_frag)
+			(Only applies, if !rcv_error && !not_IP && !IP_exc && !is_frag)
+			failure indicated in err_code below, decode:
+			- 1 = Malformed L4
+			- 2 = L4 Checksum Error: the L4 checksum value is
+			- 3 = UDP Length Error: The UDP length field would make the UDP data
+				longer than what remains in the IP packet (as defined by
+				the IP header length field).
+			- 4 = Bad L4 Port: either the source or destination TCP/UDP port is 0.
+			- 8 = TCP FIN Only: the packet is TCP and only the FIN flag set.
+			- 9 = TCP No Flags: the packet is TCP and no flags are set.
+			- 10 = TCP FIN RST: the packet is TCP and both FIN and RST are set.
+			- 11 = TCP SYN URG: the packet is TCP and both SYN and URG are set.
+			- 12 = TCP SYN RST: the packet is TCP and both SYN and RST are set.
+			- 13 = TCP SYN FIN: the packet is TCP and both SYN and FIN are set. */
+		uint64_t is_frag:1; /**< Set if the packet is a fragment */
+		uint64_t IP_exc:1; /**< The receive interface hardware detected
+			an IP error / exception.
+			(Only applies if !rcv_error && !not_IP).
+			Failure indicated in err_code below, decode:
+			- 1 = Not IP: the IP version field is neither 4 nor 6.
+			- 2 = IPv4 Header Checksum Error: the IPv4 header has a checksum violation.
+			- 3 = IP Malformed Header: the packet is not long enough to contain the IP header.
+			- 4 = IP Malformed: the packet is not long enough to contain the bytes
+				indicated by the IP header. Pad is allowed.
+			- 5 = IP TTL Hop: the IPv4 TTL field or the IPv6 Hop Count field are zero.
+			- 6 = IP Options */
+		uint64_t is_bcast:1; /**< Set if the hardware determined that the packet is a broadcast */
+		uint64_t is_mcast:1; /**< Set if the hardware determined that the packet is a multi-cast */
+		uint64_t not_IP:1; /**< Set if the packet may not be IP (must be zero in this case) */
+		uint64_t rcv_error:1; /**< the receive interface hardware detected
+			a receive error (must be zero in this case) */
+		/* Lower err_code = first-level descriptor of the work */
+		/* Zero for packet submitted by hardware that isn't on the slow path */
+		uint64_t err_code:8; /**< Type is cvmx_pip_err_t */
 	} s;
 	struct {
-		uint64_t bufs:8;		  /**< HW sets this to the number of buffers used by this packet */
-		uint64_t ip_offset:8;		  /**< HW sets to the number of L2 bytes prior to the IP */
-		uint64_t vlan_valid:1;		  /**< set to 1 if we found DSA/VLAN in the L2 */
-		uint64_t vlan_stacked:1;	  /**< Set to 1 if the DSA/VLAN tag is stacked */
+		uint64_t bufs:8; /**< HW sets this to the number of buffers used by this packet */
+		uint64_t ip_offset:8; /**< HW sets to the number of L2 bytes prior to the IP */
+		uint64_t vlan_valid:1; /**< Set to 1 if we found DSA/VLAN in the L2 */
+		uint64_t vlan_stacked:1; /**< Set to 1 if the DSA/VLAN tag is stacked */
 		uint64_t unassigned:1;
-		uint64_t vlan_cfi:1;		  /**< HW sets to the DSA/VLAN CFI flag (valid when vlan_valid) */
-		uint64_t vlan_id:12;		  /**< HW sets to the DSA/VLAN_ID field (valid when vlan_valid) */
-
-		uint64_t port:12;
-			       /**< MAC/PIP port number.  */
-
-		uint64_t dec_ipcomp:1;		  /**< the packet needs to be decompressed */
-		uint64_t tcp_or_udp:1;		  /**< the packet is either TCP or UDP */
-		uint64_t dec_ipsec:1;		  /**< the packet needs to be decrypted (ESP or AH) */
-		uint64_t is_v6:1;		  /**< the packet is IPv6 */
-
+		uint64_t vlan_cfi:1; /**< HW sets to the DSA/VLAN CFI flag (valid when vlan_valid) */
+		uint64_t vlan_id:12; /**< HW sets to the DSA/VLAN_ID field (valid when vlan_valid) */
+		uint64_t port:12; /**< MAC/PIP port number. */
+		uint64_t dec_ipcomp:1; /**< The packet needs to be decompressed */
+		uint64_t tcp_or_udp:1; /**< The packet is either TCP or UDP */
+		uint64_t dec_ipsec:1; /**< The packet needs to be decrypted (ESP or AH) */
+		uint64_t is_v6:1; /**< The packet is IPv6 */
 		/* (rcv_error, not_IP, IP_exc, is_frag, L4_error, software, etc.) */
-
-		uint64_t software:1;		  /**< reserved for software use, hardware will clear on packet creation */
-		/* exceptional conditions below */
-		uint64_t L4_error:1;		  /**< the receive interface hardware detected an L4 error (only applies if !is_frag)
-                                                    (only applies if !rcv_error && !not_IP && !IP_exc && !is_frag)
-                                                    failure indicated in err_code below, decode:
-                                                    - 1 = Malformed L4
-                                                    - 2 = L4 Checksum Error: the L4 checksum value is
-                                                    - 3 = UDP Length Error: The UDP length field would make the UDP data longer than what
-                                                        remains in the IP packet (as defined by the IP header length field).
-                                                    - 4 = Bad L4 Port: either the source or destination TCP/UDP port is 0.
-                                                    - 8 = TCP FIN Only: the packet is TCP and only the FIN flag set.
-                                                    - 9 = TCP No Flags: the packet is TCP and no flags are set.
-                                                    - 10 = TCP FIN RST: the packet is TCP and both FIN and RST are set.
-                                                    - 11 = TCP SYN URG: the packet is TCP and both SYN and URG are set.
-                                                    - 12 = TCP SYN RST: the packet is TCP and both SYN and RST are set.
-                                                    - 13 = TCP SYN FIN: the packet is TCP and both SYN and FIN are set. */
-
-		uint64_t is_frag:1;		  /**< set if the packet is a fragment */
-		uint64_t IP_exc:1;		  /**< the receive interface hardware detected an IP error / exception
-                                                    (only applies if !rcv_error && !not_IP) failure indicated in err_code below, decode:
-                                                    - 1 = Not IP: the IP version field is neither 4 nor 6.
-                                                    - 2 = IPv4 Header Checksum Error: the IPv4 header has a checksum violation.
-                                                    - 3 = IP Malformed Header: the packet is not long enough to contain the IP header.
-                                                    - 4 = IP Malformed: the packet is not long enough to contain the bytes indicated by the IP
-                                                        header. Pad is allowed.
-                                                    - 5 = IP TTL Hop: the IPv4 TTL field or the IPv6 Hop Count field are zero.
-                                                    - 6 = IP Options */
-
-		uint64_t is_bcast:1;		  /**< set if the hardware determined that the packet is a broadcast */
-		uint64_t is_mcast:1;		  /**< set if the hardware determined that the packet is a multi-cast */
-		uint64_t not_IP:1;		  /**< set if the packet may not be IP (must be zero in this case) */
-		uint64_t rcv_error:1;		  /**< the receive interface hardware detected a receive error (must be zero in this case) */
-		/* lower err_code = first-level descriptor of the work */
-		/* zero for packet submitted by hardware that isn't on the slow path */
-
-		uint64_t err_code:8;		  /**< type is cvmx_pip_err_t */
+		uint64_t software:1; /**< Reserved for software use,
+			hardware will clear on packet creation */
+		/* Exceptional conditions below */
+		uint64_t L4_error:1; /**< The receive interface hardware detected an L4 error.
+			(Only applies if !is_frag)
+			(Only applies if !rcv_error && !not_IP && !IP_exc && !is_frag)
+			Failure indicated in err_code below, decode:
+			- 1 = Malformed L4
+			- 2 = L4 Checksum Error: the L4 checksum value is
+			- 3 = UDP Length Error: The UDP length field would make the UDP data
+				longer than what remains in the IP packet
+				(as defined by the IP header length field).
+			- 4 = Bad L4 Port: either the source or destination TCP/UDP port is 0.
+			- 8 = TCP FIN Only: the packet is TCP and only the FIN flag set.
+			- 9 = TCP No Flags: the packet is TCP and no flags are set.
+			- 10 = TCP FIN RST: the packet is TCP and both FIN and RST are set.
+			- 11 = TCP SYN URG: the packet is TCP and both SYN and URG are set.
+			- 12 = TCP SYN RST: the packet is TCP and both SYN and RST are set.
+			- 13 = TCP SYN FIN: the packet is TCP and both SYN and FIN are set. */
+		uint64_t is_frag:1; /**< Set if the packet is a fragment */
+		uint64_t IP_exc:1; /**< The receive interface hardware detected
+			an IP error / exception.
+			(Only applies if !rcv_error && !not_IP)
+			Failure indicated in err_code below, decode:
+			- 1 = Not IP: the IP version field is neither 4 nor 6.
+			- 2 = IPv4 Header Checksum Error: the IPv4 header has a checksum violation.
+			- 3 = IP Malformed Header: the packet is not long enough to contain the IP header.
+			- 4 = IP Malformed: the packet is not long enough to contain the bytes
+				indicated by the IP header. Pad is allowed.
+			- 5 = IP TTL Hop: the IPv4 TTL field or the IPv6 Hop Count field are zero.
+			- 6 = IP Options */
+		uint64_t is_bcast:1; /**< Set if the hardware determined that the packet is a broadcast */
+		uint64_t is_mcast:1; /**< Set if the hardware determined that the packet is a multi-cast */
+		uint64_t not_IP:1; /**< Set if the packet may not be IP (must be zero in this case) */
+		uint64_t rcv_error:1; /**< The receive interface hardware detected a receive error
+			(must be zero in this case) */
+			/* Lower err_code = first-level descriptor of the work */
+			/* Zero for packet submitted by hardware that isn't on the slow path */
+		uint64_t err_code:8; /**< type is cvmx_pip_err_t */
 	} s_cn68xx;
 	struct {
-		uint64_t bufs:8;		  /**< HW sets this to the number of buffers used by this packet */
-		uint64_t ip_offset:8;		  /**< HW sets to the number of L2 bytes prior to the IP */
-		uint64_t vlan_valid:1;		  /**< set to 1 if we found DSA/VLAN in the L2 */
-		uint64_t vlan_stacked:1;	  /**< Set to 1 if the DSA/VLAN tag is stacked */
+		uint64_t bufs:8; /**< HW sets this to the number of buffers used by this packet */
+		uint64_t ip_offset:8; /**< HW sets to the number of L2 bytes prior to the IP */
+		uint64_t vlan_valid:1; /**< set to 1 if we found DSA/VLAN in the L2 */
+		uint64_t vlan_stacked:1; /**< Set to 1 if the DSA/VLAN tag is stacked */
 		uint64_t unassigned:1;
-		uint64_t vlan_cfi:1;		  /**< HW sets to the DSA/VLAN CFI flag (valid when vlan_valid) */
-		uint64_t vlan_id:12;		  /**< HW sets to the DSA/VLAN_ID field (valid when vlan_valid) */
-		uint64_t pr:4;			  /**< Ring Identifier (if PCIe). Requires PIP_GBL_CTL[RING_EN]=1 */
+		uint64_t vlan_cfi:1; /**< HW sets to the DSA/VLAN CFI flag (valid when vlan_valid) */
+		uint64_t vlan_id:12; /**< HW sets to the DSA/VLAN_ID field (valid when vlan_valid) */
+		uint64_t pr:4; /**< Ring Identifier (if PCIe). Requires PIP_GBL_CTL[RING_EN]=1 */
 		uint64_t unassigned2a:4;
 		uint64_t unassigned2:4;
-
-		uint64_t dec_ipcomp:1;		  /**< the packet needs to be decompressed */
-		uint64_t tcp_or_udp:1;		  /**< the packet is either TCP or UDP */
-		uint64_t dec_ipsec:1;		  /**< the packet needs to be decrypted (ESP or AH) */
-		uint64_t is_v6:1;		  /**< the packet is IPv6 */
-
+		uint64_t dec_ipcomp:1; /**< the packet needs to be decompressed */
+		uint64_t tcp_or_udp:1; /**< the packet is either TCP or UDP */
+		uint64_t dec_ipsec:1; /**< the packet needs to be decrypted (ESP or AH) */
+		uint64_t is_v6:1; /**< the packet is IPv6 */
 		/* (rcv_error, not_IP, IP_exc, is_frag, L4_error, software, etc.) */
-
-		uint64_t software:1;		  /**< reserved for software use, hardware will clear on packet creation */
-		/* exceptional conditions below */
-		uint64_t L4_error:1;		  /**< the receive interface hardware detected an L4 error (only applies if !is_frag)
-                                                    (only applies if !rcv_error && !not_IP && !IP_exc && !is_frag)
-                                                    failure indicated in err_code below, decode:
-                                                    - 1 = Malformed L4
-                                                    - 2 = L4 Checksum Error: the L4 checksum value is
-                                                    - 3 = UDP Length Error: The UDP length field would make the UDP data longer than what
-                                                        remains in the IP packet (as defined by the IP header length field).
-                                                    - 4 = Bad L4 Port: either the source or destination TCP/UDP port is 0.
-                                                    - 8 = TCP FIN Only: the packet is TCP and only the FIN flag set.
-                                                    - 9 = TCP No Flags: the packet is TCP and no flags are set.
-                                                    - 10 = TCP FIN RST: the packet is TCP and both FIN and RST are set.
-                                                    - 11 = TCP SYN URG: the packet is TCP and both SYN and URG are set.
-                                                    - 12 = TCP SYN RST: the packet is TCP and both SYN and RST are set.
-                                                    - 13 = TCP SYN FIN: the packet is TCP and both SYN and FIN are set. */
-
-		uint64_t is_frag:1;		  /**< set if the packet is a fragment */
-		uint64_t IP_exc:1;		  /**< the receive interface hardware detected an IP error / exception
-                                                    (only applies if !rcv_error && !not_IP) failure indicated in err_code below, decode:
-                                                    - 1 = Not IP: the IP version field is neither 4 nor 6.
-                                                    - 2 = IPv4 Header Checksum Error: the IPv4 header has a checksum violation.
-                                                    - 3 = IP Malformed Header: the packet is not long enough to contain the IP header.
-                                                    - 4 = IP Malformed: the packet is not long enough to contain the bytes indicated by the IP
-                                                        header. Pad is allowed.
-                                                    - 5 = IP TTL Hop: the IPv4 TTL field or the IPv6 Hop Count field are zero.
-                                                    - 6 = IP Options */
-
-		uint64_t is_bcast:1;		  /**< set if the hardware determined that the packet is a broadcast */
-		uint64_t is_mcast:1;		  /**< set if the hardware determined that the packet is a multi-cast */
-		uint64_t not_IP:1;		  /**< set if the packet may not be IP (must be zero in this case) */
-		uint64_t rcv_error:1;		  /**< the receive interface hardware detected a receive error (must be zero in this case) */
-		/* lower err_code = first-level descriptor of the work */
-		/* zero for packet submitted by hardware that isn't on the slow path */
-
-		uint64_t err_code:8;		  /**< type is cvmx_pip_err_t */
+		uint64_t software:1; /**< reserved for software use,
+			hardware will clear on packet creation */
+		/* Exceptional conditions below */
+		uint64_t L4_error:1; /**< The receive interface hardware detected an L4 error.
+			(Only applies if !is_frag)
+			(Only applies if !rcv_error && !not_IP && !IP_exc && !is_frag)
+			Failure indicated in err_code below, decode:
+			- 1 = Malformed L4
+			- 2 = L4 Checksum Error: the L4 checksum value is
+			- 3 = UDP Length Error: The UDP length field would make the UDP data
+				longer than what remains in the IP packet
+				(as defined by the IP header length field).
+			- 4 = Bad L4 Port: either the source or destination TCP/UDP port is 0.
+			- 8 = TCP FIN Only: the packet is TCP and only the FIN flag set.
+			- 9 = TCP No Flags: the packet is TCP and no flags are set.
+			- 10 = TCP FIN RST: the packet is TCP and both FIN and RST are set.
+			- 11 = TCP SYN URG: the packet is TCP and both SYN and URG are set.
+			- 12 = TCP SYN RST: the packet is TCP and both SYN and RST are set.
+			- 13 = TCP SYN FIN: the packet is TCP and both SYN and FIN are set. */
+		uint64_t is_frag:1; /**< Set if the packet is a fragment */
+		uint64_t IP_exc:1; /**< The receive interface hardware detected
+			an IP error / exception.
+			(Only applies if !rcv_error && !not_IP)
+			Failure indicated in err_code below, decode:
+			- 1 = Not IP: the IP version field is neither 4 nor 6.
+			- 2 = IPv4 Header Checksum Error: the IPv4 header has a checksum violation.
+			- 3 = IP Malformed Header: the packet is not long enough to contain the IP header.
+			- 4 = IP Malformed: the packet is not long enough to contain the bytes
+				indicated by the IP header. Pad is allowed.
+			- 5 = IP TTL Hop: the IPv4 TTL field or the IPv6 Hop Count field are zero.
+			- 6 = IP Options */
+		uint64_t is_bcast:1; /**< Set if the hardware determined that the packet is a broadcast */
+		uint64_t is_mcast:1; /**< Set if the hardware determined that the packet is a multi-cast */
+		uint64_t not_IP:1; /**< Set if the packet may not be IP (must be zero in this case) */
+		uint64_t rcv_error:1; /**< The receive interface hardware detected
+			a receive error (must be zero in this case) */
+			/* Lower err_code = first-level descriptor of the work */
+			/* Zero for packet submitted by hardware that isn't on the slow path */
+		uint64_t err_code:8; /**< type is cvmx_pip_err_t */
 	} s_cn38xx;
-
-    /**< use this to get at the 16 vlan bits */
+	/**< Use this to get at the 16 vlan bits */
 	struct {
 		uint64_t unused1:16;
 		uint64_t vlan:16;
 		uint64_t unused2:32;
 	} svlan;
-
-    /**< use this struct if the hardware could not determine that the packet is ip */
+	/**< Use this struct if the hardware could not determine that the packet is ip */
 	struct {
-		uint64_t bufs:8;		  /**< HW sets this to the number of buffers used by this packet */
+		uint64_t bufs:8; /**< HW sets this to the number of buffers used by this packet */
 		uint64_t unused:8;
-		uint64_t vlan_valid:1;		  /**< set to 1 if we found DSA/VLAN in the L2 */
-		uint64_t vlan_stacked:1;	  /**< Set to 1 if the DSA/VLAN tag is stacked */
+		uint64_t vlan_valid:1; /**< set to 1 if we found DSA/VLAN in the L2 */
+		uint64_t vlan_stacked:1; /**< Set to 1 if the DSA/VLAN tag is stacked */
 		uint64_t unassigned:1;
-		uint64_t vlan_cfi:1;		  /**< HW sets to the DSA/VLAN CFI flag (valid when vlan_valid) */
-		uint64_t vlan_id:12;		  /**< HW sets to the DSA/VLAN_ID field (valid when vlan_valid) */
-
-		uint64_t varies:12;
-				/**< 38xx and 68xx have different definitions.  */
+		uint64_t vlan_cfi:1; /**< HW sets to the DSA/VLAN CFI flag (valid when vlan_valid) */
+		uint64_t vlan_id:12; /**< HW sets to the DSA/VLAN_ID field (valid when vlan_valid) */
+		uint64_t varies:12; /**< 38xx and 68xx have different definitions.  */
 		uint64_t unassigned2:4;
-
-		uint64_t software:1;		  /**< reserved for software use, hardware will clear on packet creation */
+		uint64_t software:1; /**< Reserved for software use,
+			hardware will clear on packet creation */
 		uint64_t unassigned3:1;
-		uint64_t is_rarp:1;		  /**< set if the hardware determined that the packet is rarp */
-		uint64_t is_arp:1;		  /**< set if the hardware determined that the packet is arp */
-		uint64_t is_bcast:1;		  /**< set if the hardware determined that the packet is a broadcast */
-		uint64_t is_mcast:1;		  /**< set if the hardware determined that the packet is a multi-cast */
-		uint64_t not_IP:1;		  /**< set if the packet may not be IP (must be one in this case) */
-		uint64_t rcv_error:1;		  /**< the receive interface hardware detected a receive error.
-                                                    Failure indicated in err_code below, decode:
-                                                    - 1 = partial error: a packet was partially received, but internal
-                                                        buffering / bandwidth was not adequate to receive the entire packet.
-                                                    - 2 = jabber error: the RGMII packet was too large and is truncated.
-                                                    - 3 = overrun error: the RGMII packet is longer than allowed and had
-                                                        an FCS error.
-                                                    - 4 = oversize error: the RGMII packet is longer than allowed.
-                                                    - 5 = alignment error: the RGMII packet is not an integer number of bytes
-                                                        and had an FCS error (100M and 10M only).
-                                                    - 6 = fragment error: the RGMII packet is shorter than allowed and had an
-                                                        FCS error.
-                                                    - 7 = GMX FCS error: the RGMII packet had an FCS error.
-                                                    - 8 = undersize error: the RGMII packet is shorter than allowed.
-                                                    - 9 = extend error: the RGMII packet had an extend error.
-                                                    - 10 = length mismatch error: the RGMII packet had a length that did not
-                                                        match the length field in the L2 HDR.
-                                                    - 11 = RGMII RX error/SPI4 DIP4 Error: the RGMII packet had one or more
-                                                        data reception errors (RXERR) or the SPI4 packet had one or more DIP4
-                                                        errors.
-                                                    - 12 = RGMII skip error/SPI4 Abort Error: the RGMII packet was not large
-                                                        enough to cover the skipped bytes or the SPI4 packet was terminated
-                                                        with an About EOPS.
-                                                    - 13 = RGMII nibble error/SPI4 Port NXA Error: the RGMII packet had a
-                                                        studder error (data not repeated - 10/100M only) or the SPI4 packet
-                                                        was sent to an NXA.
-                                                    - 16 = FCS error: a SPI4.2 packet had an FCS error.
-                                                    - 17 = Skip error: a packet was not large enough to cover the skipped bytes.
-                                                    - 18 = L2 header malformed: the packet is not long enough to contain the L2 */
-
-		/* lower err_code = first-level descriptor of the work */
-		/* zero for packet submitted by hardware that isn't on the slow path */
-		uint64_t err_code:8;	/* type is cvmx_pip_err_t (union, so can't use directly */
+		uint64_t is_rarp:1; /**< Set if the hardware determined that the packet is rarp */
+		uint64_t is_arp:1; /**< Set if the hardware determined that the packet is arp */
+		uint64_t is_bcast:1; /**< Set if the hardware determined that the packet is a broadcast */
+		uint64_t is_mcast:1; /**< Set if the hardware determined that the packet is a multi-cast */
+		uint64_t not_IP:1; /**< Set if the packet may not be IP (must be one in this case) */
+		uint64_t rcv_error:1; /**< The receive interface hardware detected a receive error.
+			Failure indicated in err_code below, decode:
+			- 1 = partial error: a packet was partially received, but internal
+				buffering / bandwidth was not adequate to receive the entire packet.
+			- 2 = jabber error: the RGMII packet was too large and is truncated.
+			- 3 = overrun error: the RGMII packet is longer than allowed and had an FCS error.
+			- 4 = oversize error: the RGMII packet is longer than allowed.
+			- 5 = alignment error: the RGMII packet is not an integer number of bytes
+				and had an FCS error (100M and 10M only).
+			- 6 = fragment error: the RGMII packet is shorter than allowed and had an FCS error.
+			- 7 = GMX FCS error: the RGMII packet had an FCS error.
+			- 8 = undersize error: the RGMII packet is shorter than allowed.
+			- 9 = extend error: the RGMII packet had an extend error.
+			- 10 = length mismatch error: the RGMII packet had a length that did not
+				match the length field in the L2 HDR.
+			- 11 = RGMII RX error/SPI4 DIP4 Error: the RGMII packet had one or more data
+				reception errors (RXERR) or the SPI4 packet had one or more DIP4 errors.
+			- 12 = RGMII skip error/SPI4 Abort Error: the RGMII packet was not large enough
+				to cover the skipped bytes or the SPI4 packet was terminated with an About EOPS.
+			- 13 = RGMII nibble error/SPI4 Port NXA Error: the RGMII packet had a studder
+				error (data not repeated - 10/100M only) or the SPI4 packet was sent to an NXA.
+			- 16 = FCS error: a SPI4.2 packet had an FCS error.
+			- 17 = Skip error: a packet was not large enough to cover the skipped bytes.
+			- 18 = L2 header malformed: the packet is not long enough to contain the L2 */
+		/* Lower err_code = first-level descriptor of the work */
+		/* Zero for packet submitted by hardware that isn't on the slow path */
+		uint64_t err_code:8; /* type is cvmx_pip_err_t (union, so can't use directly */
 	} snoip;
 	struct {
-		uint64_t bufs:8;		  /**< HW sets this to the number of buffers used by this packet */
+		uint64_t bufs:8; /**< HW sets this to the number of buffers used by this packet */
 		uint64_t unused:8;
-		uint64_t vlan_valid:1;		  /**< set to 1 if we found DSA/VLAN in the L2 */
-		uint64_t vlan_stacked:1;	  /**< Set to 1 if the DSA/VLAN tag is stacked */
+		uint64_t vlan_valid:1; /**< Set to 1 if we found DSA/VLAN in the L2 */
+		uint64_t vlan_stacked:1; /**< Set to 1 if the DSA/VLAN tag is stacked */
 		uint64_t unassigned:1;
-		uint64_t vlan_cfi:1;		  /**< HW sets to the DSA/VLAN CFI flag (valid when vlan_valid) */
-		uint64_t vlan_id:12;		  /**< HW sets to the DSA/VLAN_ID field (valid when vlan_valid) */
-
-		uint64_t port:12;
-			      /**< MAC/PIP port number.  */
+		uint64_t vlan_cfi:1; /**< HW sets to the DSA/VLAN CFI flag (valid when vlan_valid) */
+		uint64_t vlan_id:12; /**< HW sets to the DSA/VLAN_ID field (valid when vlan_valid) */
+		uint64_t port:12; /**< MAC/PIP port number.  */
 		uint64_t unassigned2:4;
-
-		uint64_t software:1;		  /**< reserved for software use, hardware will clear on packet creation */
+		uint64_t software:1; /**< Reserved for software use,
+			hardware will clear on packet creation */
 		uint64_t unassigned3:1;
-		uint64_t is_rarp:1;		  /**< set if the hardware determined that the packet is rarp */
-		uint64_t is_arp:1;		  /**< set if the hardware determined that the packet is arp */
-		uint64_t is_bcast:1;		  /**< set if the hardware determined that the packet is a broadcast */
-		uint64_t is_mcast:1;		  /**< set if the hardware determined that the packet is a multi-cast */
-		uint64_t not_IP:1;		  /**< set if the packet may not be IP (must be one in this case) */
-		uint64_t rcv_error:1;		  /**< the receive interface hardware detected a receive error.
-                                                    Failure indicated in err_code below, decode:
-                                                    - 1 = partial error: a packet was partially received, but internal
-                                                        buffering / bandwidth was not adequate to receive the entire packet.
-                                                    - 2 = jabber error: the RGMII packet was too large and is truncated.
-                                                    - 3 = overrun error: the RGMII packet is longer than allowed and had
-                                                        an FCS error.
-                                                    - 4 = oversize error: the RGMII packet is longer than allowed.
-                                                    - 5 = alignment error: the RGMII packet is not an integer number of bytes
-                                                        and had an FCS error (100M and 10M only).
-                                                    - 6 = fragment error: the RGMII packet is shorter than allowed and had an
-                                                        FCS error.
-                                                    - 7 = GMX FCS error: the RGMII packet had an FCS error.
-                                                    - 8 = undersize error: the RGMII packet is shorter than allowed.
-                                                    - 9 = extend error: the RGMII packet had an extend error.
-                                                    - 10 = length mismatch error: the RGMII packet had a length that did not
-                                                        match the length field in the L2 HDR.
-                                                    - 11 = RGMII RX error/SPI4 DIP4 Error: the RGMII packet had one or more
-                                                        data reception errors (RXERR) or the SPI4 packet had one or more DIP4
-                                                        errors.
-                                                    - 12 = RGMII skip error/SPI4 Abort Error: the RGMII packet was not large
-                                                        enough to cover the skipped bytes or the SPI4 packet was terminated
-                                                        with an About EOPS.
-                                                    - 13 = RGMII nibble error/SPI4 Port NXA Error: the RGMII packet had a
-                                                        studder error (data not repeated - 10/100M only) or the SPI4 packet
-                                                        was sent to an NXA.
-                                                    - 16 = FCS error: a SPI4.2 packet had an FCS error.
-                                                    - 17 = Skip error: a packet was not large enough to cover the skipped bytes.
-                                                    - 18 = L2 header malformed: the packet is not long enough to contain the L2 */
-
-		/* lower err_code = first-level descriptor of the work */
-		/* zero for packet submitted by hardware that isn't on the slow path */
-		uint64_t err_code:8;	/* type is cvmx_pip_err_t (union, so can't use directly */
+		uint64_t is_rarp:1; /**< Set if the hardware determined that the packet is rarp */
+		uint64_t is_arp:1; /**< Set if the hardware determined that the packet is arp */
+		uint64_t is_bcast:1; /**< Set if the hardware determined that the packet is a broadcast */
+		uint64_t is_mcast:1; /**< Set if the hardware determined that the packet is a multi-cast */
+		uint64_t not_IP:1; /**< Set if the packet may not be IP (must be one in this case) */
+		uint64_t rcv_error:1; /**< The receive interface hardware detected a receive error.
+			Failure indicated in err_code below, decode:
+			- 1 = partial error: a packet was partially received, but internal
+				buffering / bandwidth was not adequate to receive the entire packet.
+			- 2 = jabber error: the RGMII packet was too large and is truncated.
+			- 3 = overrun error: the RGMII packet is longer than allowed and had an FCS error.
+			- 4 = oversize error: the RGMII packet is longer than allowed.
+			- 5 = alignment error: the RGMII packet is not an integer number of bytes
+				and had an FCS error (100M and 10M only).
+			- 6 = fragment error: the RGMII packet is shorter than allowed and had an FCS error.
+			- 7 = GMX FCS error: the RGMII packet had an FCS error.
+			- 8 = undersize error: the RGMII packet is shorter than allowed.
+			- 9 = extend error: the RGMII packet had an extend error.
+			- 10 = length mismatch error: the RGMII packet had a length that did not
+				match the length field in the L2 HDR.
+			- 11 = RGMII RX error/SPI4 DIP4 Error: the RGMII packet had one or more
+				data reception errors (RXERR) or the SPI4 packet had one or more DIP4 errors.
+			- 12 = RGMII skip error/SPI4 Abort Error: the RGMII packet was not large enough
+				to cover the skipped bytes or the SPI4 packet was terminated with an About EOPS.
+			- 13 = RGMII nibble error/SPI4 Port NXA Error: the RGMII packet had a studder
+				error (data not repeated - 10/100M only) or the SPI4 packet was sent to an NXA.
+			- 16 = FCS error: a SPI4.2 packet had an FCS error.
+			- 17 = Skip error: a packet was not large enough to cover the skipped bytes.
+			- 18 = L2 header malformed: the packet is not long enough to contain the L2 */
+		/* Lower err_code = first-level descriptor of the work */
+		/* Zero for packet submitted by hardware that isn't on the slow path */
+		uint64_t err_code:8; /* Type is cvmx_pip_err_t (union, so can't use directly */
 	} snoip_cn68xx;
 	struct {
-		uint64_t bufs:8;		  /**< HW sets this to the number of buffers used by this packet */
+		uint64_t bufs:8; /**< HW sets this to the number of buffers used by this packet */
 		uint64_t unused:8;
-		uint64_t vlan_valid:1;		  /**< set to 1 if we found DSA/VLAN in the L2 */
-		uint64_t vlan_stacked:1;	  /**< Set to 1 if the DSA/VLAN tag is stacked */
+		uint64_t vlan_valid:1; /**< Set to 1 if we found DSA/VLAN in the L2 */
+		uint64_t vlan_stacked:1; /**< Set to 1 if the DSA/VLAN tag is stacked */
 		uint64_t unassigned:1;
-		uint64_t vlan_cfi:1;		  /**< HW sets to the DSA/VLAN CFI flag (valid when vlan_valid) */
-		uint64_t vlan_id:12;		  /**< HW sets to the DSA/VLAN_ID field (valid when vlan_valid) */
-		uint64_t pr:4;			  /**< Ring Identifier (if PCIe). Requires PIP_GBL_CTL[RING_EN]=1 */
+		uint64_t vlan_cfi:1; /**< HW sets to the DSA/VLAN CFI flag (valid when vlan_valid) */
+		uint64_t vlan_id:12; /**< HW sets to the DSA/VLAN_ID field (valid when vlan_valid) */
+		uint64_t pr:4; /**< Ring Identifier (if PCIe). Requires PIP_GBL_CTL[RING_EN]=1 */
 		uint64_t unassigned2a:8;
 		uint64_t unassigned2:4;
-
-		uint64_t software:1;		  /**< reserved for software use, hardware will clear on packet creation */
+		uint64_t software:1; /**< Reserved for software use,
+			hardware will clear on packet creation */
 		uint64_t unassigned3:1;
-		uint64_t is_rarp:1;		  /**< set if the hardware determined that the packet is rarp */
-		uint64_t is_arp:1;		  /**< set if the hardware determined that the packet is arp */
-		uint64_t is_bcast:1;		  /**< set if the hardware determined that the packet is a broadcast */
-		uint64_t is_mcast:1;		  /**< set if the hardware determined that the packet is a multi-cast */
-		uint64_t not_IP:1;		  /**< set if the packet may not be IP (must be one in this case) */
-		uint64_t rcv_error:1;		  /**< the receive interface hardware detected a receive error.
-                                                    Failure indicated in err_code below, decode:
-                                                    - 1 = partial error: a packet was partially received, but internal
-                                                        buffering / bandwidth was not adequate to receive the entire packet.
-                                                    - 2 = jabber error: the RGMII packet was too large and is truncated.
-                                                    - 3 = overrun error: the RGMII packet is longer than allowed and had
-                                                        an FCS error.
-                                                    - 4 = oversize error: the RGMII packet is longer than allowed.
-                                                    - 5 = alignment error: the RGMII packet is not an integer number of bytes
-                                                        and had an FCS error (100M and 10M only).
-                                                    - 6 = fragment error: the RGMII packet is shorter than allowed and had an
-                                                        FCS error.
-                                                    - 7 = GMX FCS error: the RGMII packet had an FCS error.
-                                                    - 8 = undersize error: the RGMII packet is shorter than allowed.
-                                                    - 9 = extend error: the RGMII packet had an extend error.
-                                                    - 10 = length mismatch error: the RGMII packet had a length that did not
-                                                        match the length field in the L2 HDR.
-                                                    - 11 = RGMII RX error/SPI4 DIP4 Error: the RGMII packet had one or more
-                                                        data reception errors (RXERR) or the SPI4 packet had one or more DIP4
-                                                        errors.
-                                                    - 12 = RGMII skip error/SPI4 Abort Error: the RGMII packet was not large
-                                                        enough to cover the skipped bytes or the SPI4 packet was terminated
-                                                        with an About EOPS.
-                                                    - 13 = RGMII nibble error/SPI4 Port NXA Error: the RGMII packet had a
-                                                        studder error (data not repeated - 10/100M only) or the SPI4 packet
-                                                        was sent to an NXA.
-                                                    - 16 = FCS error: a SPI4.2 packet had an FCS error.
-                                                    - 17 = Skip error: a packet was not large enough to cover the skipped bytes.
-                                                    - 18 = L2 header malformed: the packet is not long enough to contain the L2 */
-
-		/* lower err_code = first-level descriptor of the work */
-		/* zero for packet submitted by hardware that isn't on the slow path */
-		uint64_t err_code:8;	/* type is cvmx_pip_err_t (union, so can't use directly */
+		uint64_t is_rarp:1; /**< Set if the hardware determined that the packet is rarp */
+		uint64_t is_arp:1; /**< Set if the hardware determined that the packet is arp */
+		uint64_t is_bcast:1; /**< Set if the hardware determined that the packet is a broadcast */
+		uint64_t is_mcast:1; /**< Set if the hardware determined that the packet is a multi-cast */
+		uint64_t not_IP:1; /**< Set if the packet may not be IP (must be one in this case) */
+		uint64_t rcv_error:1; /**< The receive interface hardware detected a receive error.
+			Failure indicated in err_code below, decode:
+			- 1 = partial error: a packet was partially received, but internal
+				buffering / bandwidth was not adequate to receive the entire packet.
+			- 2 = jabber error: the RGMII packet was too large and is truncated.
+			- 3 = overrun error: the RGMII packet is longer than allowed and had an FCS error.
+			- 4 = oversize error: the RGMII packet is longer than allowed.
+			- 5 = alignment error: the RGMII packet is not an integer number of bytes
+				and had an FCS error (100M and 10M only).
+			- 6 = fragment error: the RGMII packet is shorter than allowed and had an FCS error.
+			- 7 = GMX FCS error: the RGMII packet had an FCS error.
+			- 8 = undersize error: the RGMII packet is shorter than allowed.
+			- 9 = extend error: the RGMII packet had an extend error.
+			- 10 = length mismatch error: the RGMII packet had a length that did not
+				match the length field in the L2 HDR.
+			- 11 = RGMII RX error/SPI4 DIP4 Error: the RGMII packet had one or more data
+				reception errors (RXERR) or the SPI4 packet had one or more DIP4 errors.
+			- 12 = RGMII skip error/SPI4 Abort Error: the RGMII packet was not large enough
+				to cover the skipped bytes or the SPI4 packet was terminated with an About EOPS.
+			- 13 = RGMII nibble error/SPI4 Port NXA Error: the RGMII packet had a studder
+				error (data not repeated - 10/100M only) or the SPI4 packet was sent to an NXA.
+			- 16 = FCS error: a SPI4.2 packet had an FCS error.
+			- 17 = Skip error: a packet was not large enough to cover the skipped bytes.
+			- 18 = L2 header malformed: the packet is not long enough to contain the L2 */
+		/* Lower err_code = first-level descriptor of the work */
+		/* Zero for packet submitted by hardware that isn't on the slow path */
+		uint64_t err_code:8; /* Type is cvmx_pip_err_t (union, so can't use directly */
 	} snoip_cn38xx;
-#else				/* __LITTLE_ENDIAN_BITFIELD */
+#else /* __LITTLE_ENDIAN_BITFIELD */
 	struct {
 		uint64_t err_code:8;
 		uint64_t rcv_error:1;
@@ -676,7 +665,7 @@ typedef union {
 		uint64_t unused:8;
 		uint64_t bufs:8;
 	} snoip_cn38xx;
-#endif				/* __LITTLE_ENDIAN_BITFIELD */
+#endif /* __LITTLE_ENDIAN_BITFIELD */
 } cvmx_pip_wqe_word2_t;
 
 
@@ -684,34 +673,35 @@ typedef union {
 	uint64_t u64;
 #ifdef __BIG_ENDIAN_BITFIELD
 	struct {
-		uint64_t software:1;		  /**< reserved for software use, hardware always writes 0 to this bit */
-		uint64_t lg_hdr_type:5;		  /**< Indicates the Layer G header typed parsed,PKI_LTYPE_E */
-		uint64_t lf_hdr_type:5;		  /**< Indicates the Layer F header typed parsed, PKI_LTYPE_E */
-		uint64_t le_hdr_type:5;        	  /**< Indicates the Layer E header typed parsed, PKI_LTYPE_E */
-		uint64_t ld_hdr_type:5;		  /**< Indicates the Layer D header typed parsed, PKI_LTYPE_E */
-		uint64_t lc_hdr_type:5;		  /**< Indicates the Layer C header typed parsed, PKI_LTYPE_E */
-		uint64_t lb_hdr_type:5;		  /**< Indicates the Layer B header typed parsed, PKI_LTYPE_E */
-		uint64_t is_la_ether:1;	          /**< Indicates that Layer A Ethernet was parsed */
+		uint64_t software:1; /**< Reserved for software use,
+			hardware always writes 0 to this bit */
+		uint64_t lg_hdr_type:5; /**< Indicates the Layer G header typed parsed,PKI_LTYPE_E */
+		uint64_t lf_hdr_type:5; /**< Indicates the Layer F header typed parsed, PKI_LTYPE_E */
+		uint64_t le_hdr_type:5; /**< Indicates the Layer E header typed parsed, PKI_LTYPE_E */
+		uint64_t ld_hdr_type:5; /**< Indicates the Layer D header typed parsed, PKI_LTYPE_E */
+		uint64_t lc_hdr_type:5; /**< Indicates the Layer C header typed parsed, PKI_LTYPE_E */
+		uint64_t lb_hdr_type:5; /**< Indicates the Layer B header typed parsed, PKI_LTYPE_E */
+		uint64_t is_la_ether:1; /**< Indicates that Layer A Ethernet was parsed */
 		uint64_t rsvd_0:8;
-		uint64_t vlan_valid:1;		  /**< set to 1 if we found VLAN in the L2 */
-		uint64_t vlan_stacked:1;	  /**< set to 1 if the VLAN tag is stacked */
-		uint64_t stat_inc:1;              /**< stat increment Reserved for Statistics hardware */
-		uint64_t pcam_flag4:1;            /**< indicates if PCAM entry has set the flag */
-		uint64_t pcam_flag3:1;            /**< indicates if PCAM entry has set the flag */
-		uint64_t pcam_flag2:1;            /**< indicates if PCAM entry has set the flag */
-		uint64_t pcam_flag1:1;            /**< indicates if PCAM entry has set the flag */
-		uint64_t is_frag:1;		  /**< set when the outer IP indicates a fragment */
-		uint64_t is_l3_bcast:1;           /**< set when outer ip indicates broadcast */
-		uint64_t is_l3_mcast:1;           /**< set when outer ipv4 indicates multicast */
-		uint64_t is_l2_bcast:1;           /**< set when the packet’s destination MAC address
-							field in the L2 HDR is the broadcast address */
-		uint64_t is_l2_mcast:1; 	  /**< set when the packet’s destination MAC address
-							field in the L2 HDR is a multicast address */
-		uint64_t is_raw:1;                /**< set when PKI_INST_HDR[RAW] was set */
-		uint64_t err_level:3;             /**< contains the lowest protocol layer containing error,
-							when errors are detected, normally 0; PKI_ERROR_LEVEL_E */
-		uint64_t err_code:8;              /**< normally 0, but contains a (non-zero) exception opcode
-							enumerated by PKI_OPCODE_E when WQE[ERRLEV] is non-zero */
+		uint64_t vlan_valid:1; /**< Set to 1 if we found VLAN in the L2 */
+		uint64_t vlan_stacked:1; /**< Set to 1 if the VLAN tag is stacked */
+		uint64_t stat_inc:1; /**< Stat increment Reserved for Statistics hardware */
+		uint64_t pcam_flag4:1; /**< Indicates if PCAM entry has set the flag */
+		uint64_t pcam_flag3:1; /**< Indicates if PCAM entry has set the flag */
+		uint64_t pcam_flag2:1; /**< Indicates if PCAM entry has set the flag */
+		uint64_t pcam_flag1:1; /**< Indicates if PCAM entry has set the flag */
+		uint64_t is_frag:1; /**< Set when the outer IP indicates a fragment */
+		uint64_t is_l3_bcast:1; /**< Set when outer ip indicates broadcast */
+		uint64_t is_l3_mcast:1; /**< Set when outer ipv4 indicates multicast */
+		uint64_t is_l2_bcast:1; /**< Set when the packet’s destination MAC address
+			field in the L2 HDR is the broadcast address */
+		uint64_t is_l2_mcast:1; /**< Set when the packet’s destination MAC address
+			field in the L2 HDR is a multicast address */
+		uint64_t is_raw:1; /**< Set when PKI_INST_HDR[RAW] was set */
+		uint64_t err_level:3; /**< Contains the lowest protocol layer containing error,
+			when errors are detected, normally 0; PKI_ERROR_LEVEL_E */
+		uint64_t err_code:8; /**< Normally 0, but contains a (non-zero) exception opcode
+			enumerated by PKI_OPCODE_E when WQE[ERRLEV] is non-zero */
 	};
 #else
 	struct {
@@ -753,32 +743,21 @@ typedef union {
 	uint64_t u64;
 #ifdef __BIG_ENDIAN_BITFIELD
 	struct {
-		/**
-		 * raw chksum result generated by the HW
-		 */
-		uint16_t hw_chksum;
-		/**
-		 * Field unused by hardware - available for software
-		 */
-		uint8_t unused;
-		/**
-		 * Next pointer used by hardware for list maintenance.
-		 * May be written/read by HW before the work queue
-		 * entry is scheduled to a PP (Only 36 bits used in
-		 * Octeon 1)
-		 */
-		uint64_t next_ptr:40;
-
+		uint16_t hw_chksum; /* Raw chksum result generated by the HW. */
+		uint8_t unused; /* Field unused by hardware - available for software */
+		uint64_t next_ptr:40; /* The pointer used by hardware for list maintenance.
+			May be written/read by HW before the work queue entry is scheduled to
+			a PP (Only 36 bits used in OCTEON 1). */
 	} cn38xx;
 	struct {
-		uint64_t l4ptr:8;	/* 56..63 */
-		uint64_t unused0:8;	/* 48..55 */
-		uint64_t l3ptr:8;	/* 40..47 */
-		uint64_t l2ptr:8;	/* 32..39 */
-		uint64_t unused1:18;	/* 14..31 */
-		uint64_t bpid:6;	/* 8..13 */
-		uint64_t unused2:2;	/* 6..7 */
-		uint64_t pknd:6;	/* 0..5 */
+		uint64_t l4ptr:8; /* 56..63 */
+		uint64_t unused0:8; /* 48..55 */
+		uint64_t l3ptr:8; /* 40..47 */
+		uint64_t l2ptr:8; /* 32..39 */
+		uint64_t unused1:18; /* 14..31 */
+		uint64_t bpid:6; /* 8..13 */
+		uint64_t unused2:2; /* 6..7 */
+		uint64_t pknd:6; /* 0..5 */
 	} cn68xx;
 #else
 	struct {
@@ -838,7 +817,7 @@ typedef union {
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t unused:24;
-		uint64_t next_ptr:40;	/* on cn68xx this is unused as well */
+		uint64_t next_ptr:40; /* On cn68xx this is unused as well */
 #else
 		uint64_t next_ptr:40;
 		uint64_t unused:24;
@@ -852,10 +831,8 @@ typedef union {
 		CVMX_BITFIELD_FIELD(uint64_t len:16,
 		CVMX_BITFIELD_FIELD(uint64_t rsvd_0:2,
 		CVMX_BITFIELD_FIELD(uint64_t rsvd_1:2,
-		/**
-		 * the group that the work queue entry will be scheduled to
-		 */
-		CVMX_BITFIELD_FIELD(uint64_t grp:10,
+		CVMX_BITFIELD_FIELD(uint64_t grp:10, /* The group that the work queue
+			entry will be scheduled to. */
 		CVMX_BITFIELD_FIELD(cvmx_pow_tag_type_t tag_type:2,
 		CVMX_BITFIELD_FIELD(uint64_t tag:32,
 		))))));
@@ -869,10 +846,8 @@ typedef union {
 	struct {
 		CVMX_BITFIELD_FIELD(uint64_t len:16,
 		CVMX_BITFIELD_FIELD(uint64_t varies:14,
-		/**
-		 * the type of the tag (ORDERED, ATOMIC, NULL)
-		 */
-		CVMX_BITFIELD_FIELD(cvmx_pow_tag_type_t tag_type:2,
+		CVMX_BITFIELD_FIELD(cvmx_pow_tag_type_t tag_type:2, /* The type of the tag
+			(ORDERED, ATOMIC, NULL).*/
 		CVMX_BITFIELD_FIELD(uint64_t tag:32,
 		))));
 	};
@@ -880,16 +855,11 @@ typedef union {
 	struct {
 		CVMX_BITFIELD_FIELD(uint64_t len:16,
 		CVMX_BITFIELD_FIELD(uint64_t zero_0:1,
-		/**
-		 * HW sets this to what it thought the priority of the input packet was
-		 */
-		CVMX_BITFIELD_FIELD(uint64_t qos:3,
-
+		CVMX_BITFIELD_FIELD(uint64_t qos:3, /* HW sets this to what it thought
+			the priority of the input packet was.*/
 		CVMX_BITFIELD_FIELD(uint64_t zero_1:1,
-		/**
-		 * the group that the work queue entry will be scheduled to
-		 */
-		CVMX_BITFIELD_FIELD(uint64_t grp:6,
+		CVMX_BITFIELD_FIELD(uint64_t grp:6, /* The group that the work queue entry
+			will be scheduled to.*/
 		CVMX_BITFIELD_FIELD(uint64_t zero_2:3,
 		CVMX_BITFIELD_FIELD(cvmx_pow_tag_type_t tag_type:2,
 		CVMX_BITFIELD_FIELD(uint64_t tag:32,
@@ -897,20 +867,11 @@ typedef union {
 	} cn68xx;
 	struct {
 		CVMX_BITFIELD_FIELD(uint64_t len:16,
-		/**
-		 * HW sets this to input physical port
-		 */
-		CVMX_BITFIELD_FIELD(uint64_t ipprt:6,
-
-		/**
-		 * HW sets this to what it thought the priority of the input packet was
-		 */
-		CVMX_BITFIELD_FIELD(uint64_t qos:3,
-
-		/**
-		 * the group that the work queue entry will be scheduled to
-		 */
-		CVMX_BITFIELD_FIELD(uint64_t grp:4,
+		CVMX_BITFIELD_FIELD(uint64_t ipprt:6, /* HW sets this to input physical port.*/
+		CVMX_BITFIELD_FIELD(uint64_t qos:3, /* HW sets this to what it thought
+			the priority of the input packet was.*/
+		CVMX_BITFIELD_FIELD(uint64_t grp:4, /* The group that the work queue entry
+			will be scheduled to.*/
 		CVMX_BITFIELD_FIELD(uint64_t zero_2:1,
 		CVMX_BITFIELD_FIELD(cvmx_pow_tag_type_t tag_type:2,
 		CVMX_BITFIELD_FIELD(uint64_t tag:32,
@@ -922,20 +883,11 @@ typedef union {
 	uint64_t u64;
 	struct {
 		CVMX_BITFIELD_FIELD(uint64_t rsvd_0:8,
-		/**
-		 * NVMe queue manager hardware error info.
-		 */
-		CVMX_BITFIELD_FIELD(uint64_t hwerr:8,
+		CVMX_BITFIELD_FIELD(uint64_t hwerr:8, /* NVMe queue manager hardware error info.*/
 		CVMX_BITFIELD_FIELD(uint64_t rsvd_1:24,
-		/**
-		 * Submission queue ID number
-		 */
-		CVMX_BITFIELD_FIELD(uint64_t sqid:8,
+		CVMX_BITFIELD_FIELD(uint64_t sqid:8, /* Submission queue ID number.*/
 		CVMX_BITFIELD_FIELD(uint64_t rsvd_2:4,
-		/**
-		 * Virtual function number
-		 */
-		CVMX_BITFIELD_FIELD(uint64_t vfnum:12,
+		CVMX_BITFIELD_FIELD(uint64_t vfnum:12, /* Virtual function number.*/
 		))))));
 	};
 } cvmx_wqe_word3_t;
@@ -944,188 +896,157 @@ typedef union {
 	uint64_t u64;
 	struct {
 		CVMX_BITFIELD_FIELD(uint64_t rsvd_0:21,
-		/**
-		 * SQ flow control counter. For diagnostic use only.
-		 */
-		CVMX_BITFIELD_FIELD(uint64_t sqfc:11,
+		CVMX_BITFIELD_FIELD(uint64_t sqfc:11, /* SQ flow control counter.
+			For diagnostic use only.*/
 		CVMX_BITFIELD_FIELD(uint64_t rsvd_1:5,
-		/**
-		 * SQ tail. For diagnostic use only
-		 */
-		CVMX_BITFIELD_FIELD(uint64_t sqtail:11,
+		CVMX_BITFIELD_FIELD(uint64_t sqtail:11, /* SQ tail. For diagnostic use only.*/
 		CVMX_BITFIELD_FIELD(uint64_t rsvd_2:3,
-		/**
-		 *  SQ head pointer. The SQ entry number that this
-		 *  command was read from. Useful for pairing up
-		 *  fused operations
-		 */
-		CVMX_BITFIELD_FIELD(uint64_t sqhead:13,
+		CVMX_BITFIELD_FIELD(uint64_t sqhead:13, /* SQ head pointer. The SQ entry number
+			that this command was read from. Useful for pairing up fused operations. */
 		))))));
 	};
 } cvmx_wqe_word4_t;
 
 /**
- * Work queue entry format
- *
- * must be 8-byte aligned
+ * Work queue entry format.
+ * Must be 8-byte aligned.
  */
 typedef struct cvmx_wqe_s {
-
-    /*****************************************************************
-     * WORD 0
-     *  HW WRITE: the following 64 bits are filled by HW when a packet arrives
-     */
-
+	/*---------------------------------------------------------------------------*/
+	/* WORD 0                                                                    */
+	/*---------------------------------------------------------------------------*/
+	/* HW WRITE: the following 64 bits are filled by HW when a packet arrives. */
 	cvmx_wqe_word0_t word0;
 
-    /*****************************************************************
-     * WORD 1
-     *  HW WRITE: the following 64 bits are filled by HW when a packet arrives
-     */
-
+	/*---------------------------------------------------------------------------*/
+	/* WORD 1                                                                    */
+	/*---------------------------------------------------------------------------*/
+	/* HW WRITE: the following 64 bits are filled by HW when a packet arrives. */
 	cvmx_wqe_word1_t word1;
-    /**
-     * WORD 2
-     *   HW WRITE: the following 64-bits are filled in by hardware when a packet arrives
-     *   This indicates a variety of status and error conditions.
-     */
+
+	/*---------------------------------------------------------------------------*/
+	/* WORD 2                                                                    */
+	/*---------------------------------------------------------------------------*/
+	/* HW WRITE: the following 64-bits are filled in by hardware when a packet
+	 * arrives. This indicates a variety of status and error conditions.*/
 	cvmx_pip_wqe_word2_t word2;
 
-    /**
-     * Pointer to the first segment of the packet.
-     */
+	/* Pointer to the first segment of the packet. */
 	cvmx_buf_ptr_t packet_ptr;
 
-    /**
-     *   HW WRITE: octeon will fill in a programmable amount from the
-     *             packet, up to (at most, but perhaps less) the amount
-     *             needed to fill the work queue entry to 128 bytes
-     *   If the packet is recognized to be IP, the hardware starts (except that
-     *   the IPv4 header is padded for appropriate alignment) writing here where
-     *   the IP header starts.
-     *   If the packet is not recognized to be IP, the hardware starts writing
-     *   the beginning of the packet here.
-     */
+	/* HW WRITE: OCTEON will fill in a programmable amount from the packet,
+	 * up to (at most, but perhaps less) the amount needed to fill the work queue
+	 * entry to 128 bytes. If the packet is recognized to be IP, the hardware starts
+	 * (except that the IPv4 header is padded for appropriate alignment) writing
+	 * here where the IP header starts. If the packet is not recognized to be IP,
+	 * the hardware starts writing the beginning of the packet here.
+	 */
 	uint8_t packet_data[96];
 
-    /**
-     * If desired, SW can make the work Q entry any length. For the
-     * purposes of discussion here, Assume 128B always, as this is all that
-     * the hardware deals with.
-     *
-     */
-
+	/* If desired, SW can make the work Q entry any length. For the purposes
+	 * of discussion here, Assume 128B always, as this is all that the hardware
+	 * deals with.*/
 } CVMX_CACHE_LINE_ALIGNED cvmx_wqe_t;
 
 /**
  * Work queue entry format for NQM
- *
- * must be 8-byte aligned
+ * Must be 8-byte aligned
  */
 typedef struct cvmx_wqe_nqm_s {
-
-    /*****************************************************************
-     * WORD 0
-     *  HW WRITE: the following 64 bits are filled by HW when a packet arrives
-     */
-
+	/*---------------------------------------------------------------------------*/
+	/* WORD 0                                                                    */
+	/*---------------------------------------------------------------------------*/
+	/* HW WRITE: the following 64 bits are filled by HW when a packet arrives. */
 	cvmx_wqe_word0_t word0;
 
-    /*****************************************************************
-     * WORD 1
-     *  HW WRITE: the following 64 bits are filled by HW when a packet arrives
-     */
-
+	/*---------------------------------------------------------------------------*/
+	/* WORD 1                                                                    */
+	/*---------------------------------------------------------------------------*/
+	/* HW WRITE: the following 64 bits are filled by HW when a packet arrives. */
 	cvmx_wqe_word1_t word1;
-    /**
-     * WORD 2
-     * Reserved
-     */
+
+	/*---------------------------------------------------------------------------*/
+	/* WORD 2                                                                    */
+	/*---------------------------------------------------------------------------*/
+	/* Reserved */
 	uint64_t word2;
 
-    /**
-     * WORD 3
-     * NVMe specific information
-     */
+	/*---------------------------------------------------------------------------*/
+	/* WORD 3                                                                    */
+	/*---------------------------------------------------------------------------*/
+	/* NVMe specific information.*/
 	cvmx_wqe_word3_t word3;
 
-    /**
-     * WORD 4
-     * NVMe specific information
-     */
+	/*---------------------------------------------------------------------------*/
+	/* WORD 4                                                                    */
+	/*---------------------------------------------------------------------------*/
+	/* NVMe specific information.*/
 	cvmx_wqe_word4_t word4;
 
-    /**
-     *   HW WRITE: octeon will fill in a programmable amount from the
-     *             packet, up to (at most, but perhaps less) the amount
-     *             needed to fill the work queue entry to 128 bytes
-     *   If the packet is recognized to be IP, the hardware starts (except that
-     *   the IPv4 header is padded for appropriate alignment) writing here where
-     *   the IP header starts.
-     *   If the packet is not recognized to be IP, the hardware starts writing
-     *   the beginning of the packet here.
-     */
+	/* HW WRITE: OCTEON will fill in a programmable amount from the packet,
+	 * up to (at most, but perhaps less) the amount needed to fill the work queue
+	 * entry to 128 bytes. If the packet is recognized to be IP, the hardware
+	 * starts (except that the IPv4 header is padded for appropriate alignment)
+	 * writing here where the IP header starts. If the packet is not recognized
+	 * to be IP, the hardware starts writing the beginning of the packet here.*/
 	uint8_t packet_data[88];
 
-    /**
-     * If desired, SW can make the work Q entry any length. For the
-     * purposes of discussion here, Assume 128B always, as this is all that
-     * the hardware deals with.
-     *
-     */
-
+	/* If desired, SW can make the work Q entry any length.
+	 * For the purposes of discussion here, assume 128B always, as this is
+	 * all that the hardware deals with.*/
 } CVMX_CACHE_LINE_ALIGNED cvmx_wqe_nqm_t;
 
 /**
- * Work queue entry format for 78XX
- * In 78XX packet data always resides in WQE buffer unless
- * option DIS_WQ_DAT=1 in PKI_STYLE_BUF, which causes packet data to use
- * separate buffer.
+ * Work queue entry format for 78XX.
+ * In 78XX packet data always resides in WQE buffer unless option
+ * DIS_WQ_DAT=1 in PKI_STYLE_BUF, which causes packet data to use separate buffer.
  *
- * must be 8-byte aligned
+ * Must be 8-byte aligned.
  */
 typedef struct {
-	/*****************************************************************
-	 * WORD 0
-	 *  HW WRITE: the following 64 bits are filled by HW when a packet arrives
-	 */
+	/*---------------------------------------------------------------------------*/
+	/* WORD 0                                                                    */
+	/*---------------------------------------------------------------------------*/
+	/* HW WRITE: the following 64 bits are filled by HW when a packet arrives.*/
 	cvmx_pki_wqe_word0_t word0;
 
-	/*****************************************************************
-	 * WORD 1
-	 *  HW WRITE: the following 64 bits are filled by HW when a packet arrives
-	 */
-
+	/*---------------------------------------------------------------------------*/
+	/* WORD 1                                                                    */
+	/*---------------------------------------------------------------------------*/
+	/* HW WRITE: the following 64 bits are filled by HW when a packet arrives.*/
 	cvmx_pki_wqe_word1_t word1;
 
-	/**
-	 * WORD 2
-	 *   HW WRITE: the following 64-bits are filled in by hardware when a packet arrives
-	 *   This indicates a variety of status and error conditions.
-	 */
+	/*---------------------------------------------------------------------------*/
+	/* WORD 2                                                                    */
+	/*---------------------------------------------------------------------------*/
+	/* HW WRITE: the following 64-bits are filled in by hardware when a packet
+	 * arrives. This indicates a variety of status and error conditions.*/
 	cvmx_pki_wqe_word2_t word2;
 
-	/**
-	 * Pointer to the first segment of the packet.
-         * WORD 3
-	 */
+	/*---------------------------------------------------------------------------*/
+	/* WORD 3                                                                    */
+	/*---------------------------------------------------------------------------*/
+	/* Pointer to the first segment of the packet.*/
 	cvmx_buf_ptr_pki_t packet_ptr;
 
-	/**
-         * WORD 4
-         *   HW WRITE: the following 64-bits are filled in by hardware when a packet arrives
-	 *   contains a byte pointer to the start of Layer A/B/C/D/E/F/G relative of start of packet
-	 */
-
+	/*---------------------------------------------------------------------------*/
+	/* WORD 4                                                                    */
+	/*---------------------------------------------------------------------------*/
+	/* HW WRITE: the following 64-bits are filled in by hardware when a packet
+	 * arrives contains a byte pointer to the start of Layer A/B/C/D/E/F/G relative
+	 * of start of packet.*/
 	cvmx_pki_wqe_word4_t word4;
 
-	/**
-         * WORD 5/6/7 may be extended here if WQE_HSZ is set to !0
-	 */
-        uint64_t        wqe_data[11];
+	/*---------------------------------------------------------------------------*/
+	/* WORDs 5/6/7 may be extended there, if WQE_HSZ is set.                     */
+	/*---------------------------------------------------------------------------*/
+	uint64_t wqe_data[11];
 
 } CVMX_CACHE_LINE_ALIGNED cvmx_wqe_78xx_t;
 
+/* Node LS-bit position in the WQE[grp] or PKI_QPG_TBL[grp_ok].*/
+#define CVMX_WQE_GRP_NODE_SHIFT  8
+
 /*
  * This is an accessor function into the WQE that retreives the
  * ingress port number, which can also be used as a destination
@@ -1133,7 +1054,6 @@ typedef struct {
  *
  * @param work - Work Queue Entrey pointer
  * @returns returns the normalized port number, also known as "ipd" port
- *
  */
 static inline int cvmx_wqe_get_port(cvmx_wqe_t *work)
 {
@@ -1157,7 +1077,6 @@ static inline int cvmx_wqe_get_port(cvmx_wqe_t *work)
 	return port;
 }
 
-
 static inline void cvmx_wqe_set_port(cvmx_wqe_t *work, int port)
 {
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))
@@ -1211,7 +1130,7 @@ static inline void cvmx_wqe_set_grp(cvmx_wqe_t *work, int grp)
 {
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		unsigned node = cvmx_get_node_num();
-		/* legacy: GRP[0..2] :=QOS */
+		/* Legacy: GRP[0..2] :=QOS */
 		work->word1.cn78xx.grp = 0xff & (grp << 3);
 		work->word1.cn78xx.grp |= (node << 8);
 	} else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE))
@@ -1225,7 +1144,7 @@ static inline int cvmx_wqe_get_qos(cvmx_wqe_t *work)
 	int qos;
 
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-		/* legacy: GRP[0..2] :=QOS */
+		/* Legacy: GRP[0..2] :=QOS */
 		qos = work->word1.cn78xx.grp & 0x7;
 	} else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE))
 		qos = work->word1.cn68xx.qos;
@@ -1272,13 +1191,13 @@ static inline void cvmx_wqe_set_len(cvmx_wqe_t *work, int len)
 }
 
 /**
- * This function returns if there was L2/L1 errors detected in packet.
+ * This function returns, if there was L2/L1 errors detected in packet.
+ *
  * @param work	pointer to work queue entry
- * @return	0 if packet had no error, non-zero to indicate error code.
  *
- * Please refer to HRM for the specific model for full enumaration of error
- * codes.
+ * @return	0 if packet had no error, non-zero to indicate error code.
  *
+ * Please refer to HRM for the specific model for full enumaration of error codes.
  * With Octeon1/Octeon2 models, the returned code indicates L1/L2 errors.
  * On CN73XX/CN78XX, the return code is the value of PKI_OPCODE_E,
  * if it is non-zero, otherwise the returned code will be derived from
@@ -1290,14 +1209,13 @@ static inline int cvmx_wqe_get_rcv_err(cvmx_wqe_t *work)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t *wqe = (void *)work;
 		if (wqe->word2.err_level == CVMX_PKI_ERRLEV_E_RE ||
-		    wqe->word2.err_code != 0)
+				wqe->word2.err_code != 0)
 		    return wqe->word2.err_code;
 		else
 		    return (wqe->word2.err_level << 4) + 0x10;
-
 	}
 	else if (work->word2.snoip.rcv_error)
-		return (work->word2.snoip.err_code);
+		return work->word2.snoip.err_code;
 	return 0;
 }
 
@@ -1335,11 +1253,10 @@ static inline uint8_t cvmx_wqe_get_unused8(cvmx_wqe_t *work)
 {
 	uint8_t bits;
 
-	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))
-		{
+	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t *wqe = (void *)work;
 		bits = wqe->word2.rsvd_0;
-		}
+	}
 	else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE))
 		bits = work->word0.pip.cn68xx.unused1;
 	else
@@ -1350,11 +1267,10 @@ static inline uint8_t cvmx_wqe_get_unused8(cvmx_wqe_t *work)
 
 static inline void cvmx_wqe_set_unused8(cvmx_wqe_t *work, uint8_t v)
 {
-	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))
-		{
+	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t *wqe = (void *)work;
 		wqe->word2.rsvd_0 = v;
-		}
+	}
 	else if (octeon_has_feature(OCTEON_FEATURE_CN68XX_WQE))
 		work->word0.pip.cn68xx.unused1 = v;
 	else
@@ -1381,7 +1297,6 @@ static inline int cvmx_wqe_get_channel(cvmx_wqe_t *work)
 		return (work->word0.pki.channel);
 	else
 		return cvmx_wqe_get_port(work);
-
 }
 
 static inline void cvmx_wqe_set_channel(cvmx_wqe_t *work, int channel)
@@ -1421,10 +1336,6 @@ static inline void cvmx_wqe_set_style(cvmx_wqe_t *work, int style)
 		work->word0.pki.style = style;
 }
 
-/**
- * Return non-zero if the packet Layer-3 protocol is either IPv4 or IPv6.
- *
- */
 static inline int cvmx_wqe_is_l3_ip(cvmx_wqe_t *work)
 {
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
@@ -1435,9 +1346,9 @@ static inline int cvmx_wqe_is_l3_ip(cvmx_wqe_t *work)
 		if((wqe->word2.le_hdr_type & 0x1c) == CVMX_PKI_LTYPE_E_IP4)
 			return 1;
 		return 0;
-	} else
+	}
+	else
 		return !work->word2.s_cn38xx.not_IP;
-
 }
 
 static inline int cvmx_wqe_is_l3_ipv4(cvmx_wqe_t *work)
@@ -1450,12 +1361,9 @@ static inline int cvmx_wqe_is_l3_ipv4(cvmx_wqe_t *work)
 		if((wqe->word2.le_hdr_type & 0x1e) == CVMX_PKI_LTYPE_E_IP4)
 			return 1;
 		return 0;
-	} else
-		return (
-			!work->word2.s_cn38xx.not_IP &&
-			!work->word2.s_cn38xx.is_v6
-			);
-
+	}
+	else
+		return (!work->word2.s_cn38xx.not_IP && !work->word2.s_cn38xx.is_v6);
 }
 
 static inline int cvmx_wqe_is_l3_ipv6(cvmx_wqe_t *work)
@@ -1468,17 +1376,11 @@ static inline int cvmx_wqe_is_l3_ipv6(cvmx_wqe_t *work)
 		if((wqe->word2.le_hdr_type & 0x1e) == CVMX_PKI_LTYPE_E_IP6)
 			return 1;
 		return 0;
-	} else
-		return (
-			!work->word2.s_cn38xx.not_IP &&
-			work->word2.s_cn38xx.is_v6
-			);
+	}
+	else
+		return (!work->word2.s_cn38xx.not_IP && work->word2.s_cn38xx.is_v6);
 }
 
-/**
- * Return true if an IP packet has a Layer-4 protocol
- * as TCP or UDP. and is not fragmented.
- */
 static inline bool cvmx_wqe_is_l4_udp_or_tcp(cvmx_wqe_t *work)
 {
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
@@ -1488,30 +1390,32 @@ static inline bool cvmx_wqe_is_l4_udp_or_tcp(cvmx_wqe_t *work)
 		if (wqe->word2.lf_hdr_type  == CVMX_PKI_LTYPE_E_UDP)
 			return true;
 		return false;
-	} else {
+	}
+	else {
 		if (work->word2.s_cn38xx.not_IP)
 			return false;
 		return (work->word2.s_cn38xx.tcp_or_udp != 0);
 	}
 }
 
-
 static inline int cvmx_wqe_is_l2_bcast(cvmx_wqe_t *work)
 {
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t* wqe = (void *)work;
-		return (wqe->word2.is_l2_bcast);
-	} else
-		return (work->word2.s_cn38xx.is_bcast);
+		return wqe->word2.is_l2_bcast;
+	}
+	else
+		return work->word2.s_cn38xx.is_bcast;
 }
 
 static inline int cvmx_wqe_is_l2_mcast(cvmx_wqe_t *work)
 {
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t* wqe = (void *)work;
-		return (wqe->word2.is_l2_mcast);
-	} else
-		return (work->word2.s_cn38xx.is_mcast);
+		return wqe->word2.is_l2_mcast;
+	}
+	else
+		return work->word2.s_cn38xx.is_mcast;
 }
 
 static inline void cvmx_wqe_set_l2_bcast(cvmx_wqe_t *work, bool bcast)
@@ -1519,7 +1423,8 @@ static inline void cvmx_wqe_set_l2_bcast(cvmx_wqe_t *work, bool bcast)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t* wqe = (void *)work;
 		wqe->word2.is_l2_bcast = bcast;
-	} else
+	}
+	else
 		work->word2.s_cn38xx.is_bcast = bcast;
 }
 
@@ -1528,7 +1433,8 @@ static inline void cvmx_wqe_set_l2_mcast(cvmx_wqe_t *work, bool mcast)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t* wqe = (void *)work;
 		wqe->word2.is_l2_mcast = mcast;
-	} else
+	}
+	else
 		work->word2.s_cn38xx.is_mcast = mcast;
 }
 
@@ -1536,7 +1442,7 @@ static inline int cvmx_wqe_is_l3_bcast(cvmx_wqe_t *work)
 {
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t* wqe = (void *)work;
-		return (wqe->word2.is_l3_bcast);
+		return wqe->word2.is_l3_bcast;
 	}
 	cvmx_dprintf("%s: ERROR: not supported for model\n",__func__);
 	return 0;
@@ -1546,7 +1452,7 @@ static inline int cvmx_wqe_is_l3_mcast(cvmx_wqe_t *work)
 {
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)){
 		cvmx_wqe_78xx_t* wqe = (void *)work;
-		return (wqe->word2.is_l3_mcast);
+		return wqe->word2.is_l3_mcast;
 	}
 	cvmx_dprintf("%s: ERROR: not supported for model\n",__func__);
 	return 0;
@@ -1559,7 +1465,7 @@ static inline int cvmx_wqe_is_l3_mcast(cvmx_wqe_t *work)
  * ipv6 extension, it will be flag them.
  * @param work	pointer to work queue entry
  * @return	1 -- If IP error was found in packet
- *		0 -- If no IP error was found in packet.
+ *          0 -- If no IP error was found in packet.
  */
 static inline int cvmx_wqe_is_ip_exception(cvmx_wqe_t *work)
 {
@@ -1567,11 +1473,10 @@ static inline int cvmx_wqe_is_ip_exception(cvmx_wqe_t *work)
 		cvmx_wqe_78xx_t* wqe = (void *)work;
 		if (wqe->word2.err_level == CVMX_PKI_ERRLEV_E_LC)
 			return 1;
-		if (wqe->word2.err_level == CVMX_PKI_ERRLEV_E_LE)
-			return 1;
 		else
 			return 0;
-	} else
+	}
+	else
 		return work->word2.s.IP_exc;
 }
 
@@ -1583,16 +1488,29 @@ static inline int cvmx_wqe_is_l4_error(cvmx_wqe_t *work)
 			return 1;
 		else
 			return 0;
-	} else
+	}
+	else
 		return work->word2.s.L4_error;
 }
 
+static inline void cvmx_wqe_set_vlan(cvmx_wqe_t *work, bool set)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
+		cvmx_wqe_78xx_t* wqe = (void *)work;
+			wqe->word2.vlan_valid = set;
+	}
+	else
+		work->word2.s.vlan_valid = set;
+}
+
+
 static inline int cvmx_wqe_is_vlan(cvmx_wqe_t *work)
 {
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t* wqe = (void *)work;
 			return wqe->word2.vlan_valid;
-	} else
+	}
+	else
 		return work->word2.s.vlan_valid;
 }
 
@@ -1601,7 +1519,8 @@ static inline int cvmx_wqe_is_vlan_stacked(cvmx_wqe_t *work)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t* wqe = (void *)work;
 		return wqe->word2.vlan_stacked;
-	} else
+	}
+	else
 		return work->word2.s.vlan_stacked;
 }
 
@@ -1628,13 +1547,11 @@ static inline int cvmx_wqe_get_bufs(cvmx_wqe_t *work)
 	else {
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 		/* Adjust for packet-in-WQE cases */
-		if (cvmx_unlikely(work->word2.s_cn38xx.bufs == 0 &&
-		    !work->word2.s.software))
+		if (cvmx_unlikely(work->word2.s_cn38xx.bufs == 0 && !work->word2.s.software))
 			(void) cvmx_wqe_get_packet_ptr(work);
 #endif
 		bufs = work->word2.s_cn38xx.bufs;
 	}
-
 	return bufs;
 }
 
@@ -1659,7 +1576,8 @@ static inline bool cvmx_wqe_is_soft(cvmx_wqe_t *work)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t* wqe = (void *)work;
 		return wqe->word2.software;
-	} else
+	}
+	else
 		return work->word2.s.software;
 }
 
@@ -1671,11 +1589,10 @@ static inline bool cvmx_wqe_is_soft(cvmx_wqe_t *work)
  */
 extern cvmx_wqe_t * cvmx_wqe_soft_create(void *data_p, unsigned data_sz);
 
-
 /* Errata (PKI-20776) PKI_BUFLINK_S's are endian-swapped
-   CN78XX pass 1.x has a bug where the packet pointer in each segment is
-   written in the opposite endianness of the configured mode. Fix these
-   here */
+ * CN78XX pass 1.x has a bug where the packet pointer in each segment is
+ * written in the opposite endianness of the configured mode. Fix these here.
+ */
 static inline void cvmx_wqe_pki_errata_20776(cvmx_wqe_t *work)
 {
 #ifndef __LITTLE_ENDIAN_BITFIELD
@@ -1703,9 +1620,9 @@ static inline void cvmx_wqe_pki_errata_20776(cvmx_wqe_t *work)
 }
 
 /* Errata (PKO-22235) PKI_BUFLINK_S's are endian-swapped
-   CN78XX pass 1.x has a bug where the packet pointer in each segment is
-   written in the opposite endianness of the configured mode. Fix these
-   here */
+ * CN78XX pass 1.x has a bug where the packet pointer in each segment is
+ * written in the opposite endianness of the configured mode. Fix these here.
+ */
 static inline void cvmx_wqe_pko_errata_22235(cvmx_buf_ptr_pki_t packet_ptr, unsigned len)
 {
 #ifdef __LITTLE_ENDIAN_BITFIELD
@@ -1728,7 +1645,6 @@ static inline void cvmx_wqe_pko_errata_22235(cvmx_buf_ptr_pki_t packet_ptr, unsi
 #endif
 }
 
-
 /**
  * @INTERNAL
  *
@@ -1778,9 +1694,10 @@ static inline unsigned cvmx_wqe_get_l3_offset(cvmx_wqe_t *work)
 		/* Match 4 values: IPv4/v6 w/wo options */
 		if ((wqe->word2.lc_hdr_type & 0x1c) == CVMX_PKI_LTYPE_E_IP4)
 			return wqe->word4.ptr_layer_c;
-	} else {
-		return work->word2.s.ip_offset;
 	}
+	else
+		return work->word2.s.ip_offset;
+
 	return 0;
 }
 
@@ -1801,9 +1718,9 @@ static inline unsigned cvmx_wqe_set_l3_offset(cvmx_wqe_t *work, unsigned ip_off)
 		/* Match 4 values: IPv4/v6 w/wo options */
 		if ((wqe->word2.lc_hdr_type & 0x1c) == CVMX_PKI_LTYPE_E_IP4)
 			wqe->word4.ptr_layer_c = ip_off;
-	} else {
-		work->word2.s.ip_offset = ip_off;
 	}
+	else
+		work->word2.s.ip_offset = ip_off;
 
 	return cvmx_wqe_get_l3_offset(work);
 }
@@ -1824,7 +1741,8 @@ static inline void cvmx_wqe_set_l3_ipv4(cvmx_wqe_t *work, bool set)
 			wqe->word2.lc_hdr_type = CVMX_PKI_LTYPE_E_IP4;
 		else
 			wqe->word2.lc_hdr_type = CVMX_PKI_LTYPE_E_NONE;
-	} else {
+	}
+	else {
 		work->word2.s.not_IP = !set;
 		if (set)
 			work->word2.s_cn38xx.is_v6 = 0;
@@ -1844,12 +1762,12 @@ static inline void cvmx_wqe_set_l3_ipv6(cvmx_wqe_t *work, bool set)
 			wqe->word2.lc_hdr_type = CVMX_PKI_LTYPE_E_IP6;
 		else
 			wqe->word2.lc_hdr_type = CVMX_PKI_LTYPE_E_NONE;
-	} else {
+	}
+	else {
 		work->word2.s_cn38xx.not_IP = !set;
 		if(set)
 			work->word2.s_cn38xx.is_v6 = 1;
 	}
-
 }
 
 /**
@@ -1863,7 +1781,8 @@ static inline void cvmx_wqe_set_l4_udp(cvmx_wqe_t *work, bool set)
 			wqe->word2.lf_hdr_type  = CVMX_PKI_LTYPE_E_UDP;
 		else
 			wqe->word2.lf_hdr_type  = CVMX_PKI_LTYPE_E_NONE;
-	} else {
+	}
+	else {
 		if (!work->word2.s_cn38xx.not_IP)
 			work->word2.s_cn38xx.tcp_or_udp = set;
 	}
@@ -1871,7 +1790,6 @@ static inline void cvmx_wqe_set_l4_udp(cvmx_wqe_t *work, bool set)
 
 /**
  * Set a packet Layer-4 protocol type to TCP.
- *
  */
 static inline void cvmx_wqe_set_l4_tcp(cvmx_wqe_t *work, bool set)
 {
@@ -1881,7 +1799,8 @@ static inline void cvmx_wqe_set_l4_tcp(cvmx_wqe_t *work, bool set)
 			wqe->word2.lf_hdr_type  = CVMX_PKI_LTYPE_E_TCP;
 		else
 			wqe->word2.lf_hdr_type  = CVMX_PKI_LTYPE_E_NONE;
-	} else {
+	}
+	else {
 		if (!work->word2.s_cn38xx.not_IP)
 			work->word2.s_cn38xx.tcp_or_udp = set;
 	}
@@ -1895,9 +1814,9 @@ static inline void cvmx_wqe_set_soft(cvmx_wqe_t *work, bool set)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t* wqe = (void *)work;
 		wqe->word2.software = set;
-	} else {
-		work->word2.s.software = set;
 	}
+	else 
+		work->word2.s.software = set;
 }
 
 /**
@@ -1908,7 +1827,8 @@ static inline bool  cvmx_wqe_is_l3_frag(cvmx_wqe_t *work)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t *wqe = (void *)work;
 		return (wqe->word2.is_frag != 0);
-	} else {
+	}
+	else {
 		if (!work->word2.s_cn38xx.not_IP)
 			return (work->word2.s.is_frag != 0);
 		else
@@ -1924,13 +1844,48 @@ static inline void cvmx_wqe_set_l3_frag(cvmx_wqe_t *work, bool set)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t *wqe = (void *)work;
 		wqe->word2.is_frag = set;
-	} else {
+	}
+	else {
 		if (!work->word2.s_cn38xx.not_IP)
 			work->word2.s.is_frag = set;
 	}
 }
 
 /**
+ * Set the packet Layer-3 protocol to RARP.
+ */
+static inline void cvmx_wqe_set_l3_rarp(cvmx_wqe_t *work, bool set)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
+		cvmx_wqe_78xx_t *wqe = (void *)work;
+		if (set)
+			wqe->word2.lc_hdr_type = CVMX_PKI_LTYPE_E_RARP;
+		else
+			wqe->word2.lc_hdr_type = CVMX_PKI_LTYPE_E_NONE;
+	}
+	else {
+		work->word2.snoip.is_rarp = set;
+	}
+}
+
+/**
+ * Set the packet Layer-3 protocol to ARP.
+ */
+static inline void cvmx_wqe_set_l3_arp(cvmx_wqe_t *work, bool set)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
+		cvmx_wqe_78xx_t *wqe = (void *)work;
+		if (set)
+			wqe->word2.lc_hdr_type = CVMX_PKI_LTYPE_E_ARP;
+		else
+			wqe->word2.lc_hdr_type = CVMX_PKI_LTYPE_E_NONE;
+	}
+	else {
+		work->word2.snoip.is_arp = set;
+	}
+}
+
+/**
  * Return true if the packet Layer-3 protocol is ARP.
  */
 static inline bool cvmx_wqe_is_l3_arp(cvmx_wqe_t *work)
@@ -1938,7 +1893,8 @@ static inline bool cvmx_wqe_is_l3_arp(cvmx_wqe_t *work)
 	if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
 		cvmx_wqe_78xx_t *wqe = (void *)work;
 		return (wqe->word2.lc_hdr_type  == CVMX_PKI_LTYPE_E_ARP);
-	} else {
+	}
+	else {
 		if (work->word2.s_cn38xx.not_IP)
 			return (work->word2.snoip.is_arp != 0);
 		else
@@ -1951,5 +1907,5 @@ static inline bool cvmx_wqe_is_l3_arp(cvmx_wqe_t *work)
 }
 /* *INDENT-ON* */
 #endif
-
 #endif /* __CVMX_WQE_H__ */
+
diff --git a/drivers/net/ethernet/octeon/octeon-pow-ethernet.c b/drivers/net/ethernet/octeon/octeon-pow-ethernet.c
index 1b4a715..49a23c9 100644
--- a/drivers/net/ethernet/octeon/octeon-pow-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon-pow-ethernet.c
@@ -14,8 +14,10 @@
 #include <linux/etherdevice.h>
 #include <linux/in.h>
 #include <linux/ip.h>
+#include <linux/ipv6.h>
 #include <linux/string.h>
 #include <linux/delay.h>
+#include <linux/if_vlan.h>
 
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx.h>
@@ -315,12 +317,13 @@ static cvmx_wqe_t *octeon_skb_to_fpa_buf(struct net_device *dev,
 			*(uint64_t *)prev_packet_ptr = *(uint64_t *)packet_ptr;
 
 		num_segments++;
-		cvmx_wqe_set_bufs(work, num_segments);
 		len -= segment_len;
 		data_ptr += segment_len;
 		prev_packet_ptr = packet_ptr;
 	}
 
+	cvmx_wqe_set_bufs(work, num_segments);
+
 	return work;
 
  error:
@@ -377,52 +380,57 @@ static int octeon_pow_xmit(struct sk_buff *skb, struct net_device *dev)
 		cvmx_wqe_set_grp(work, send_group);
 		cvmx_wqe_set_tt(work, 2);
 		cvmx_wqe_set_tag(work, 0);
-
 		cvmx_wqe_set_aura(work, fpa_packet_pool);
 
+		if (skb->protocol == htons(ETH_P_8021Q)) {
+			struct vlan_hdr *vhdr;
+
+			cvmx_wqe_set_vlan(work, true);
+#if 0
+			work->word2.s.vlan_cfi = 0;	/* FIXME */
+			work->word2.s.vlan_id = 0;	/* FIXME */
+			work->word2.s.dec_ipcomp = 0;	/* FIXME */
+#endif
+			vhdr = (struct vlan_hdr *)(skb->data + ETH_HLEN);
+			vlan_set_encap_proto(skb, vhdr);
+		}
+
 		if (skb->protocol == htons(ETH_P_IP)) {
-			cvmx_wqe_set_l3_offset(work, 14);
-			cvmx_wqe_set_l4_udp(work, ip_hdr(skb)->protocol == IPPROTO_UDP);
-			if (octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE) ||
-				(ip_hdr(skb)->protocol == IPPROTO_TCP))
-				cvmx_wqe_set_l4_tcp(work, ip_hdr(skb)->protocol == IPPROTO_TCP);
+			cvmx_wqe_set_l3_ipv4(work, true);
+			cvmx_wqe_set_l3_offset(work,
+				(uint)(skb_network_header(skb) - skb->data));
+			if (ip_hdr(skb)->protocol == IPPROTO_UDP)
+				cvmx_wqe_set_l4_udp(work, true);
+			else if (ip_hdr(skb)->protocol == IPPROTO_TCP)
+				cvmx_wqe_set_l4_tcp(work, true);
 			cvmx_wqe_set_l3_frag(work, !((ip_hdr(skb)->frag_off == 0)
 						     || (ip_hdr(skb)->frag_off ==
 							 1 << 14)));
 			cvmx_wqe_set_l2_bcast(work, skb->pkt_type == PACKET_BROADCAST);
 			cvmx_wqe_set_l2_mcast(work, skb->pkt_type == PACKET_MULTICAST);
-#if 0
-			work->word2.s.vlan_valid = 0;	/* FIXME */
-			work->word2.s.vlan_cfi = 0;	/* FIXME */
-			work->word2.s.vlan_id = 0;	/* FIXME */
-			work->word2.s.dec_ipcomp = 0;	/* FIXME */
-			if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))
-				work->word2.s.IP_exc = 0; /* Assume Linux is sending
-							     a good packet */
-			work->word2.s.IP_exc = 0; /* Assume Linux is sending
-						     a good packet */
-			work->word2.s.not_IP = 0; /* This is an IP packet */
-			work->word2.s.rcv_error = 0; /* No error, packet is
-							internal */
-			work->word2.s.err_code = 0;  /* No error, packet is
-							internal */
-#endif
 
 			/* When copying the data, include 4 bytes of the
 			   ethernet header to align the same way hardware does */
 			octeon_pow_copy_to(work->packet_data, skb->data + 10,
 			       sizeof(work->packet_data));
-		} else {
-#if 0
-			work->word2.snoip.is_rarp =
-				skb->protocol == htons(ETH_P_RARP);
-			work->word2.snoip.is_arp =
-				skb->protocol == htons(ETH_P_ARP);
-			work->word2.snoip.is_bcast =
-				(skb->pkt_type == PACKET_BROADCAST);
-			work->word2.snoip.is_mcast =
-				(skb->pkt_type == PACKET_MULTICAST);
-#endif
+		} else if (skb->protocol == htons(ETH_P_IPV6)) {
+			cvmx_wqe_set_l3_ipv6(work, 1);
+			cvmx_wqe_set_l3_offset(work,
+				(uint)(skb_network_header(skb) - skb->data));
+			if (ipv6_hdr(skb)->nexthdr == IPPROTO_UDP)
+				cvmx_wqe_set_l4_udp(work, true);
+			else if (ipv6_hdr(skb)->nexthdr == IPPROTO_TCP)
+				cvmx_wqe_set_l4_tcp(work, true);
+		} else if (skb->protocol == htons(ETH_P_ARP))
+			cvmx_wqe_set_l3_arp(work, true);
+		else {
+			if (skb->pkt_type == PACKET_BROADCAST)
+				cvmx_wqe_set_l2_bcast(work, true);
+			if (skb->pkt_type == PACKET_MULTICAST)
+				cvmx_wqe_set_l2_mcast(work, true);
+			if (skb->protocol == htons(ETH_P_RARP))
+				cvmx_wqe_set_l3_rarp(work, work);
+
 			cvmx_wqe_set_l3_ipv4(work, 0);
 			octeon_pow_copy_to(work->packet_data, skb->data,
 			       sizeof(work->packet_data));
-- 
2.6.2

