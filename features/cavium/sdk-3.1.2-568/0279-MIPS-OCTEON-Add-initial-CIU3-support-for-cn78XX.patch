From 13d872062d570678045c7ff9bc7d413afdc92473 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 22 Aug 2013 16:31:06 -0700
Subject: [PATCH 279/974] MIPS: OCTEON: Add initial CIU3 support for cn78XX.

Follow-on patches will improve it and make it more general.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c  | 414 +++++++++++++++++++++++++++++++++-
 arch/mips/include/asm/octeon/octeon.h |   1 +
 2 files changed, 412 insertions(+), 3 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index 8ee7564..3c6ee4c 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2004-2012 Cavium, Inc.
+ * Copyright (C) 2004-2013 Cavium, Inc.
  */
 
 #include <linux/interrupt.h>
@@ -18,11 +18,14 @@
 
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-ciu2-defs.h>
+#include <asm/octeon/cvmx-ciu3-defs.h>
 
 static DEFINE_PER_CPU(unsigned long, octeon_irq_ciu0_en_mirror);
 static DEFINE_PER_CPU(unsigned long, octeon_irq_ciu1_en_mirror);
 static DEFINE_PER_CPU(raw_spinlock_t, octeon_irq_ciu_spinlock);
 
+static struct irq_domain *octeon_irq_ciu3_domain;
+
 static __read_mostly u8 octeon_irq_ciu_to_irq[8][64];
 
 union octeon_ciu_chip_data {
@@ -606,7 +609,7 @@ static void octeon_irq_ciu_gpio_ack(struct irq_data *data)
 	cvmx_write_csr(CVMX_GPIO_INT_CLR, mask);
 }
 
-static void octeon_irq_handle_gpio(unsigned int irq, struct irq_desc *desc)
+static void octeon_irq_handle_trigger(unsigned int irq, struct irq_desc *desc)
 {
 	if (irqd_get_trigger_type(irq_desc_get_irq_data(desc)) & IRQ_TYPE_EDGE_BOTH)
 		handle_edge_irq(irq, desc);
@@ -1063,7 +1066,7 @@ static int octeon_irq_gpio_map(struct irq_domain *d,
 		return -EINVAL;
 
 	octeon_irq_set_ciu_mapping(virq, line, bit, hw,
-				   octeon_irq_gpio_chip, octeon_irq_handle_gpio);
+				   octeon_irq_gpio_chip, octeon_irq_handle_trigger);
 	return 0;
 }
 
@@ -1773,10 +1776,415 @@ static int __init octeon_irq_init_ciu2(struct device_node *ciu_node, struct devi
 	return 0;
 }
 
+static void octeon_irq_ciu3_enable(struct irq_data *data)
+{
+	union cvmx_ciu3_iscx_ctl isc_ctl;
+	union cvmx_ciu3_iscx_w1c isc_w1c;
+	u64 isc_ctl_addr;
+
+	union octeon_ciu_chip_data cd;
+
+	cd.p = irq_data_get_irq_chip_data(data);
+
+	isc_w1c.u64 = 0;
+	isc_w1c.s.en = 1;
+
+	isc_ctl.u64 = 0;
+	isc_ctl.s.en = 1;
+	isc_ctl.s.idt = 1;
+	isc_ctl_addr = CVMX_CIU3_ISCX_CTL(cd.l);
+	cvmx_write_csr(CVMX_CIU3_ISCX_W1C(cd.l), isc_w1c.u64);
+	cvmx_write_csr(isc_ctl_addr, isc_ctl.u64);
+	cvmx_read_csr(isc_ctl_addr);
+}
+
+static void octeon_irq_ciu3_disable(struct irq_data *data)
+{
+	u64 isc_ctl_addr;
+	union cvmx_ciu3_iscx_w1c isc_w1c;
+
+	union octeon_ciu_chip_data cd;
+
+	cd.p = irq_data_get_irq_chip_data(data);
+
+	isc_w1c.u64 = 0;
+	isc_w1c.s.en = 1;
+
+	isc_ctl_addr = CVMX_CIU3_ISCX_CTL(cd.l);
+	cvmx_write_csr(CVMX_CIU3_ISCX_W1C(cd.l), isc_w1c.u64);
+	cvmx_write_csr(isc_ctl_addr, 0);
+	cvmx_read_csr(isc_ctl_addr);
+}
+
+static void octeon_irq_ciu3_ack(struct irq_data *data)
+{
+	u64 isc_w1c_addr;
+	union cvmx_ciu3_iscx_w1c isc_w1c;
+	union octeon_ciu_chip_data cd;
+	u32 trigger_type = irqd_get_trigger_type(data);
+
+	/*
+	 * We use a single irq_chip, so we have to do nothing to ack a
+	 * level interrupt.
+	 */
+	if (trigger_type & IRQ_TYPE_LEVEL_MASK)
+		return;
+
+	cd.p = irq_data_get_irq_chip_data(data);
+
+	isc_w1c.u64 = 0;
+	isc_w1c.s.raw = 1;
+
+	isc_w1c_addr = CVMX_CIU3_ISCX_W1C(cd.l);
+	cvmx_write_csr(isc_w1c_addr, isc_w1c.u64);
+	cvmx_read_csr(isc_w1c_addr);
+}
+
+static void octeon_irq_ciu3_mask(struct irq_data *data)
+{
+	union cvmx_ciu3_iscx_w1c isc_w1c;
+	u64 isc_w1c_addr;
+	union octeon_ciu_chip_data cd;
+
+	cd.p = irq_data_get_irq_chip_data(data);
+
+	isc_w1c.u64 = 0;
+	isc_w1c.s.en = 1;
+
+	isc_w1c_addr = CVMX_CIU3_ISCX_W1C(cd.l);
+	cvmx_write_csr(isc_w1c_addr, isc_w1c.u64);
+	cvmx_read_csr(isc_w1c_addr);
+}
+
+static void octeon_irq_ciu3_mask_ack(struct irq_data *data)
+{
+	union cvmx_ciu3_iscx_w1c isc_w1c;
+	u64 isc_w1c_addr;
+	union octeon_ciu_chip_data cd;
+	u32 trigger_type = irqd_get_trigger_type(data);
+
+	cd.p = irq_data_get_irq_chip_data(data);
+
+	isc_w1c.u64 = 0;
+	isc_w1c.s.en = 1;
+
+	/*
+	 * We use a single irq_chip, so only ack an edge (!level)
+	 * interrupt.
+	 */
+	if (!(trigger_type & IRQ_TYPE_LEVEL_MASK))
+		isc_w1c.s.raw = 1;
+
+	isc_w1c_addr = CVMX_CIU3_ISCX_W1C(cd.l);
+	cvmx_write_csr(isc_w1c_addr, isc_w1c.u64);
+	cvmx_read_csr(isc_w1c_addr);
+}
+
+static void octeon_irq_ciu3_unmask(struct irq_data *data)
+{
+	union cvmx_ciu3_iscx_w1s isc_w1s;
+	u64 isc_w1s_addr;
+	union octeon_ciu_chip_data cd;
+
+	cd.p = irq_data_get_irq_chip_data(data);
+
+	isc_w1s.u64 = 0;
+	isc_w1s.s.en = 1;
+
+	isc_w1s_addr = CVMX_CIU3_ISCX_W1S(cd.l);
+	cvmx_write_csr(isc_w1s_addr, isc_w1s.u64);
+	cvmx_read_csr(isc_w1s_addr);
+}
+
+static struct irq_chip octeon_irq_chip_ciu3 = {
+	.name = "CIU3",
+	.irq_enable = octeon_irq_ciu3_enable,
+	.irq_disable = octeon_irq_ciu3_disable,
+	.irq_ack = octeon_irq_ciu3_ack,
+	.irq_mask = octeon_irq_ciu3_mask,
+	.irq_mask_ack = octeon_irq_ciu3_mask_ack,
+	.irq_unmask = octeon_irq_ciu3_unmask,
+//#ifdef CONFIG_SMP
+//	.irq_set_affinity = octeon_irq_ciu3_set_affinity,
+//	.irq_cpu_offline = octeon_irq_cpu_offline_ciu,
+//#endif
+};
+
+static int octeon_irq_ciu3_xlat(struct irq_domain *d,
+				struct device_node *node,
+				const u32 *intspec,
+				unsigned int intsize,
+				unsigned long *out_hwirq,
+				unsigned int *out_type)
+{
+	unsigned int hwirq, type, intsn_major;
+	union cvmx_ciu3_iscx_ctl isc;
+	hwirq = intspec[0];
+	type = intspec[1];
+
+	if (hwirq >= (1 << 20))
+		return -EINVAL;
+
+	intsn_major = hwirq >> 12;
+	switch (intsn_major) {
+	case 0x04: /* Software handled seperatly. */
+		return -EINVAL;
+	default:
+		break;
+	}
+
+
+	isc.u64 =  cvmx_read_csr(CVMX_CIU3_ISCX_CTL(hwirq));
+	if (!isc.s.imp)
+		return -EINVAL;
+
+	switch (type) {
+	case 0: /* unofficial value, but we might as well let it work. */
+	case 4: /* official value for level triggering. */
+		*out_type = IRQ_TYPE_LEVEL_HIGH;
+		break;
+	case 1: /* official value for edge triggering. */
+		*out_type = IRQ_TYPE_EDGE_RISING;
+		break;
+	default: /* Nothing else is acceptable. */
+		return -EINVAL;
+	}
+
+	*out_hwirq = hwirq;
+
+	return 0;
+}
+
+static int octeon_irq_ciu3_map(struct irq_domain *d,
+			       unsigned int virq, irq_hw_number_t hw)
+{
+	union octeon_ciu_chip_data cd;
+	cd.l = hw;
+
+	irq_set_chip_and_handler(virq, &octeon_irq_chip_ciu3, octeon_irq_handle_trigger);
+	irq_set_chip_data(virq, cd.p);
+
+	return 0;
+}
+
+static struct irq_domain_ops octeon_irq_domain_ciu3_ops = {
+	.map = octeon_irq_ciu3_map,
+	.xlate = octeon_irq_ciu3_xlat,
+};
+
+static void octeon_irq_ciu3_ip2(void)
+{
+	union cvmx_ciu3_destx_pp_int dest_pp_int;
+
+	dest_pp_int.u64 = cvmx_read_csr(CVMX_CIU3_DESTX_PP_INT(3 * cvmx_get_core_num()));
+
+	if (likely(dest_pp_int.s.intr)) {
+		irq_hw_number_t intsn = dest_pp_int.s.intsn;
+		int irq = irq_find_mapping(octeon_irq_ciu3_domain, intsn);
+
+		if (likely(irq)) {
+			do_IRQ(irq);
+		} else {
+			u64 isc_ctl_addr = CVMX_CIU3_ISCX_CTL(intsn);
+			cvmx_write_csr(isc_ctl_addr, 0);
+			cvmx_read_csr(isc_ctl_addr);
+			spurious_interrupt();
+		}
+	} else {
+		spurious_interrupt();
+	}
+}
+
+static void octeon_irq_ciu3_mbox(void)
+{
+	union cvmx_ciu3_destx_pp_int dest_pp_int;
+
+	dest_pp_int.u64 = cvmx_read_csr(CVMX_CIU3_DESTX_PP_INT(1 + (3 * cvmx_get_core_num())));
+
+	if (likely(dest_pp_int.s.intr)) {
+		irq_hw_number_t intsn = dest_pp_int.s.intsn;
+		int irq = (intsn & 7) + OCTEON_IRQ_MBOX0;
+
+		if (likely(irq)) {
+			do_IRQ(irq);
+		} else {
+			u64 isc_ctl_addr = CVMX_CIU3_ISCX_CTL(intsn);
+			cvmx_write_csr(isc_ctl_addr, 0);
+			cvmx_read_csr(isc_ctl_addr);
+			spurious_interrupt();
+		}
+	} else {
+		spurious_interrupt();
+	}
+}
+
+static unsigned int octeon_irq_ciu3_mbox_intsn_for_core(unsigned int core, unsigned int mbox)
+{
+	return (0x04 << 12) | (core << 3) | mbox;
+}
+
+void octeon_ciu3_mbox_send(int cpu, unsigned int mbox)
+{
+	union cvmx_ciu3_iscx_w1s isc_w1s;
+	u64 isc_w1s_addr;
+	unsigned int core = octeon_coreid_for_cpu(cpu);
+
+	if (WARN_ON_ONCE(mbox >= 8))
+		return;
+
+	isc_w1s_addr = CVMX_CIU3_ISCX_W1S(octeon_irq_ciu3_mbox_intsn_for_core(core, mbox));
+
+	isc_w1s.u64 = 0;
+	isc_w1s.s.raw = 1;
+
+	cvmx_write_csr(isc_w1s_addr, isc_w1s.u64);
+	cvmx_read_csr(isc_w1s_addr);
+}
+EXPORT_SYMBOL(octeon_ciu3_mbox_send);
+
+static void octeon_irq_ciu3_mbox_set_enable(struct irq_data *data, unsigned int core, bool en)
+{
+	unsigned int intsn;
+	u64 isc_ctl_addr;
+	unsigned int mbox = data->irq - OCTEON_IRQ_MBOX0;
+
+	intsn = octeon_irq_ciu3_mbox_intsn_for_core(core, mbox);
+	isc_ctl_addr = CVMX_CIU3_ISCX_CTL(intsn);
+
+	cvmx_write_csr(isc_ctl_addr, 0);
+	if (en) {
+		union cvmx_ciu3_iscx_ctl isc_ctl;
+		isc_ctl.u64 = 0;
+		isc_ctl.s.en = 1;
+		isc_ctl.s.idt = 2 + core;
+		cvmx_write_csr(isc_ctl_addr, isc_ctl.u64);
+	}
+	cvmx_read_csr(isc_ctl_addr);
+}
+
+static void octeon_irq_ciu3_mbox_enable(struct irq_data *data)
+{
+	int cpu;
+	unsigned int mbox = data->irq - OCTEON_IRQ_MBOX0;
+
+	WARN_ON(mbox >= 8);
+
+	for_each_online_cpu(cpu) {
+		unsigned int core = octeon_coreid_for_cpu(cpu);
+		octeon_irq_ciu3_mbox_set_enable(data, core, true);
+	}
+}
+
+static void octeon_irq_ciu3_mbox_disable(struct irq_data *data)
+{
+	int cpu;
+	unsigned int mbox = data->irq - OCTEON_IRQ_MBOX0;
+
+	WARN_ON(mbox >= 8);
+
+	for_each_online_cpu(cpu) {
+		unsigned int core = octeon_coreid_for_cpu(cpu);
+		octeon_irq_ciu3_mbox_set_enable(data, core, false);
+	}
+}
+
+static void octeon_irq_ciu3_mbox_ack(struct irq_data *data)
+{
+	unsigned int intsn;
+	u64 isc_w1c_addr;
+	union cvmx_ciu3_iscx_w1c isc_w1c;
+	unsigned int core = cvmx_get_core_num();
+	unsigned int mbox = data->irq - OCTEON_IRQ_MBOX0;
+
+	intsn = octeon_irq_ciu3_mbox_intsn_for_core(core, mbox);
+
+	isc_w1c.u64 = 0;
+	isc_w1c.s.raw = 1;
+
+	isc_w1c_addr = CVMX_CIU3_ISCX_W1C(intsn);
+	cvmx_write_csr(isc_w1c_addr, isc_w1c.u64);
+	cvmx_read_csr(isc_w1c_addr);
+}
+
+static void octeon_irq_ciu3_mbox_cpu_online(struct irq_data *data)
+{
+	unsigned int core = cvmx_get_core_num();
+	octeon_irq_ciu3_mbox_set_enable(data, core, true);
+}
+
+static void octeon_irq_ciu3_mbox_cpu_offline(struct irq_data *data)
+{
+	unsigned int core = cvmx_get_core_num();
+	octeon_irq_ciu3_mbox_set_enable(data, core, false);
+}
+
+static void octeon_irq_setup_secondary_ciu3(void)
+{
+	irq_cpu_online();
+
+	/* Enable the CIU lines */
+	set_c0_status(STATUSF_IP3 | STATUSF_IP2);
+	if (octeon_irq_use_ip4)
+		set_c0_status(STATUSF_IP4);
+	else
+		clear_c0_status(STATUSF_IP4);
+}
+
+static struct irq_chip octeon_irq_chip_ciu3_mbox = {
+	.name = "CIU3-M",
+	.irq_enable = octeon_irq_ciu3_mbox_enable,
+	.irq_disable = octeon_irq_ciu3_mbox_disable,
+	.irq_ack = octeon_irq_ciu3_mbox_ack,
+
+	.irq_cpu_online = octeon_irq_ciu3_mbox_cpu_online,
+	.irq_cpu_offline = octeon_irq_ciu3_mbox_cpu_offline,
+	.flags = IRQCHIP_ONOFFLINE_ENABLED,
+};
+
+static int __init octeon_irq_init_ciu3(struct device_node *ciu_node,
+				       struct device_node *parent)
+{
+	int i;
+
+	octeon_irq_setup_secondary = octeon_irq_setup_secondary_ciu3;
+
+	octeon_irq_ip2 = octeon_irq_ciu3_ip2;
+	octeon_irq_ip3 = octeon_irq_ciu3_mbox;
+	octeon_irq_ip4 = octeon_irq_ip4_mask;
+
+	/* Mips internal */
+	octeon_irq_init_core();
+
+	for (i = 0; i < 8; i++)
+		irq_set_chip_and_handler(i + OCTEON_IRQ_MBOX0, &octeon_irq_chip_ciu3_mbox, handle_percpu_irq);
+
+	octeon_irq_ciu3_domain = irq_domain_add_tree(ciu_node, &octeon_irq_domain_ciu3_ops, NULL);
+	irq_set_default_host(octeon_irq_ciu3_domain);
+
+	/* ip2 interrupts all use IDT[1] targeting core 0 */
+	cvmx_write_csr(CVMX_CIU3_IDTX_CTL(1), 0);
+	cvmx_write_csr(CVMX_CIU3_IDTX_PPX(0, 1), 1);
+	cvmx_write_csr(CVMX_CIU3_IDTX_IO(1), 0);
+
+	for (i = 0; i < 48; i++) {
+		/* idt[2..49] target ip3, one per core */
+		cvmx_write_csr(CVMX_CIU3_IDTX_CTL(2 + i), 1);
+		cvmx_write_csr(CVMX_CIU3_IDTX_PPX(0, 2 + i), 1ull << i);
+		cvmx_write_csr(CVMX_CIU3_IDTX_IO(1), 0);
+	}
+
+	/* Enable the CIU lines */
+	set_c0_status(STATUSF_IP2 | STATUSF_IP3);
+	clear_c0_status(STATUSF_IP4);
+
+	return 0;
+}
+
 static struct of_device_id __initdata ciu_types[] = {
 	{.compatible = "cavium,octeon-3860-ciu", .data = octeon_irq_init_ciu},
 	{.compatible = "cavium,octeon-3860-gpio", .data = octeon_irq_init_gpio},
 	{.compatible = "cavium,octeon-6880-ciu2", .data = octeon_irq_init_ciu2},
+	{.compatible = "cavium,octeon-7880-ciu3", .data = octeon_irq_init_ciu3},
 	{}
 };
 
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index f8ef0ff..96003af 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -399,6 +399,7 @@ typedef void (*octeon_message_fn_t)(void);
 int octeon_request_ipi_handler(octeon_message_fn_t fn);
 void octeon_send_ipi_single(int cpu, unsigned int action);
 void octeon_release_ipi_handler(int action);
+void octeon_ciu3_mbox_send(int cpu, unsigned int mbox);
 
 #define OCTEON_DEBUG_UART 1
 
-- 
2.6.2

