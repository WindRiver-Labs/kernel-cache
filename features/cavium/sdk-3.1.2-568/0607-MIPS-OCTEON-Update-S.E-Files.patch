From 88c8eb41e5d00767e739d0e7edfebcc764491eb7 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 27 Feb 2014 13:46:59 -0800
Subject: [PATCH 607/974] MIPS: OCTEON: Update S.E Files.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bch.c       |  25 ---
 .../cavium-octeon/executive/cvmx-helper-board.c    |  96 ++++++++
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c |  53 ++++-
 .../cavium-octeon/executive/cvmx-helper-pko3.c     | 155 +++++++------
 .../cavium-octeon/executive/cvmx-helper-sgmii.c    |  39 +++-
 .../cavium-octeon/executive/cvmx-helper-util.c     |  10 +-
 .../cavium-octeon/executive/cvmx-helper-xaui.c     |   4 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |  94 +++++++-
 .../mips/cavium-octeon/executive/cvmx-pko3-queue.c | 145 ++++++++----
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      |  13 +-
 arch/mips/cavium-octeon/executive/octeon-model.c   |  41 ++--
 arch/mips/include/asm/octeon/cvmx-ase-defs.h       |  59 ++---
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      |  37 ++--
 arch/mips/include/asm/octeon/cvmx-ciu3-defs.h      |  79 ++-----
 arch/mips/include/asm/octeon/cvmx-dpi-defs.h       | 115 +++++++---
 arch/mips/include/asm/octeon/cvmx-fpa-defs.h       |  75 +++++--
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     | 159 ++++++++++---
 arch/mips/include/asm/octeon/cvmx-helper-board.h   |   5 +-
 arch/mips/include/asm/octeon/cvmx-helper-cfg.h     |  35 ++-
 arch/mips/include/asm/octeon/cvmx-hna-defs.h       | 169 +++++++-------
 arch/mips/include/asm/octeon/cvmx-l2c-defs.h       |  55 ++---
 arch/mips/include/asm/octeon/cvmx-oclax-defs.h     |  52 ++++-
 arch/mips/include/asm/octeon/cvmx-ocx-defs.h       |  53 ++---
 arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h |   3 +-
 arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h   |  26 +--
 arch/mips/include/asm/octeon/cvmx-pciercx-defs.h   |  24 +-
 arch/mips/include/asm/octeon/cvmx-pemx-defs.h      | 129 +++++++----
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |  37 ++--
 arch/mips/include/asm/octeon/cvmx-pko-defs.h       |  98 ++++++---
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |  12 +-
 arch/mips/include/asm/octeon/cvmx-sli-defs.h       | 245 +++++++++++----------
 arch/mips/include/asm/octeon/cvmx-sso-defs.h       |   8 +-
 32 files changed, 1375 insertions(+), 775 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bch.c b/arch/mips/cavium-octeon/executive/cvmx-bch.c
index 89c83a7..fb839e5 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bch.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bch.c
@@ -56,7 +56,6 @@
 # include <asm/octeon/cvmx-cmd-queue.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
-#define USE_BOUNCE_BUFF 1	/* used ONLY for Linux */
 
 #elif defined(CVMX_BUILD_FOR_UBOOT)
 
@@ -251,26 +250,9 @@ int cvmx_bch_encode(const void *block, uint16_t block_size,
 {
 	cvmx_bch_command_t command;
 	cvmx_cmd_queue_result_t result;
-#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-#if USE_BOUNCE_BUFF
-	static uint8_t *bounce_buff;
 
-	if (!bounce_buff)
-		bounce_buff = kmalloc(1024, GFP_KERNEL);
-#endif
-#endif
 	debug("%s(%p, %u, %u, %p, %p) ENTRY\n", __func__, block, block_size,
 	      ecc_level, ecc, response);
-#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-#if USE_BOUNCE_BUFF
-	/* there was a problem when the first argument is used directly
-	 * despite of the fact it was 8-byte aligned, so we copy data
-	 * to dedicated 'bounce_buff' and set
-	 * command.s.iword.prt to cvmx_ptr_to_phys((void *)bounce_buff)
-	 */
-	memcpy(bounce_buff, block, block_size);
-#endif
-#endif
 	memset(&result, 0, sizeof(result));
 	memset(&command, 0, sizeof(command));
 	command.s.cword.ecc_gen = CVMX_BCH_INST_ECC_GENERATION;
@@ -278,13 +260,6 @@ int cvmx_bch_encode(const void *block, uint16_t block_size,
 	command.s.cword.size = block_size;
 
 	command.s.oword.ptr = cvmx_ptr_to_phys(ecc);
-#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-#if USE_BOUNCE_BUFF
-	command.s.iword.ptr = cvmx_ptr_to_phys((void *)bounce_buff);
-#else
-	command.s.iword.ptr = cvmx_ptr_to_phys((void *)block);
-#endif
-#endif
 	command.s.resp.ptr = cvmx_ptr_to_phys((void *)response);
 	debug("Cmd: cword:0x%llx, oword:0x%llx, iword:0x%llx, resp:0x%llx\n",
 	      command.u64[0], command.u64[1], command.u64[2], command.u64[3]);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
index f86fc96..d61eb54e 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
@@ -856,6 +856,11 @@ int __cvmx_helper_board_get_port_from_dt(void *fdt_addr, int ipd_port)
 	else
 		cvmx_helper_set_1000x_mode(xiface, port_index, false);
 
+	if (fdt_getprop(fdt_addr, eth, "cavium,disable-autonegotiation", NULL))
+		cvmx_helper_set_port_autonegotiation(xiface, port_index, false);
+	else
+		cvmx_helper_set_port_autonegotiation(xiface, port_index, true);
+
 	if (mode == CVMX_HELPER_INTERFACE_MODE_AGL) {
 		if (fdt_getprop(fdt_addr, eth, "cavium,rx-clk-delay-bypass", NULL))
 			cvmx_helper_set_agl_rx_clock_delay_bypass(xiface,
@@ -1017,6 +1022,13 @@ int __get_phy_info_from_dt(cvmx_phy_info_t *phy_info, int ipd_port)
 		if (device_tree_dbg)
 			cvmx_dprintf("TI PHY detected for ipd_port %d\n",
 				     ipd_port);
+	} else if (!fdt_node_check_compatible(fdt_addr, phy, "atheros,ar8334") ||
+		   !fdt_node_check_compatible(fdt_addr, phy, "qualcomm,qca8334") ||
+		   !fdt_node_check_compatible(fdt_addr, phy, "atheros,ar8337") ||
+		   !fdt_node_check_compatible(fdt_addr, phy, "qualcomm,qca8337")) {
+		phy_info->phy_type = QUALCOMM_S17;
+		if (device_tree_dbg)
+			cvmx_dprintf("Qualcomm QCA833X switch detected\n");
 	} else if (!fdt_node_check_compatible(fdt_addr, phy,
 					      "ethernet-phy-ieee802.3-c22")) {
 		phy_info->phy_type = GENERIC_8023_C22_PHY;
@@ -1697,6 +1709,57 @@ __cvmx_get_generic_8023_c22_phy_link_state(int phy_addr)
 	}
 	return result;
 }
+
+static cvmx_helper_link_info_t __cvmx_get_qualcomm_s17_phy_link_state(int phy_addr)
+{
+	cvmx_helper_link_info_t result;
+	int phy_status;
+	int auto_status;
+
+	result.u64 = 0;
+
+	phy_status = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, 17);
+	if (device_tree_dbg)
+		cvmx_dprintf("%s(%d): phy status: 0x%x\n",
+			     __func__, phy_addr, phy_status);
+	/* If bit 11 isn't set see if autonegotiation is turned off
+	 * (bit 12, reg 0).  The resolved bit doesn't get set properly when
+	 * autonegotiation is off, so force it.
+	 */
+	if ((phy_status & (1 << 11)) == 0) {
+		auto_status = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, 0);
+		if ((auto_status & (1 << 12)) == 0)
+			phy_status |= 1 << 11;
+
+	}
+	/* Only return a link if the PHY has finished autonegotiation and set
+	 * the resolved bit (bit 11).
+	 */
+	if (phy_status & (1 << 11)) {
+		result.s.link_up = 1;
+		result.s.full_duplex = !!(phy_status & (1 << 13));
+		switch ((phy_status >> 14) & 3) {
+		case 0:		/* 10Mbps */
+			result.s.speed = 10;
+			break;
+		case 1:		/* 100Mbps */
+			result.s.speed = 100;
+			break;
+		case 2:		/* 1Gbps */
+			result.s.speed = 1000;
+			break;
+		default:	/* Illegal */
+			result.u64 = 0;
+			break;
+		}
+	}
+	if (device_tree_dbg)
+		cvmx_dprintf("   link: %s, duplex: %s, speed: %d\n",
+			     result.s.link_up ? "up" : "down",
+			     result.s.full_duplex ? "full" : "half",
+			     result.s.speed);
+	return result;
+}
 #endif
 
 /**
@@ -1868,7 +1931,10 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 {
 	cvmx_helper_link_info_t result;
 	cvmx_phy_info_t phy_info;
+	int xiface, index;
+
 	result.u64 = 0;
+
 	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM) {
 		/* The simulator gives you a simulated 1Gbps full duplex link */
 		result.s.link_up = 1;
@@ -1877,7 +1943,34 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 		return result;
 	}
 
+	xiface = cvmx_helper_get_interface_num(ipd_port);
+	index = cvmx_helper_get_interface_index_num(ipd_port);
+	if (!cvmx_helper_get_port_autonegotiation(xiface, index)) {
+		result.s.link_up = 1;
+		result.s.full_duplex = 1;
+		switch (cvmx_helper_interface_get_mode(xiface)) {
+		case CVMX_HELPER_INTERFACE_MODE_RGMII:
+		case CVMX_HELPER_INTERFACE_MODE_GMII:
+		case CVMX_HELPER_INTERFACE_MODE_SGMII:
+		case CVMX_HELPER_INTERFACE_MODE_QSGMII:
+		case CVMX_HELPER_INTERFACE_MODE_SPI:
+		default:
+			result.s.speed = 1000;
+			break;
+		case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+		case CVMX_HELPER_INTERFACE_MODE_XAUI:
+		case CVMX_HELPER_INTERFACE_MODE_ILK:
+		case CVMX_HELPER_INTERFACE_MODE_10G_KR:
+			result.s.speed = 10000;
+			break;
+		case CVMX_HELPER_INTERFACE_MODE_XFI:
+		case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
+			result.s.speed = 40000;
+			break;
+		}
 
+		return result;
+	}
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
 		if (__cvmx_helper_78xx_parse_phy(&phy_info, ipd_port)) {
 			/*cvmx_dprintf("Error parsing PHY info for 78xx for ipd port %d\n",
@@ -1928,6 +2021,9 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 	case GENERIC_8023_C22_PHY:
 		result = __cvmx_get_generic_8023_c22_phy_link_state(phy_info.phy_addr);
 		break;
+	case QUALCOMM_S17:
+		result = __cvmx_get_qualcomm_s17_phy_link_state(phy_info.phy_addr);
+		break;
 	case INBAND_PHY:
 	default:
 		if (OCTEON_IS_OCTEON1() ||
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index 2a59d0b..7e33198 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -81,15 +81,21 @@ CVMX_SHARED struct cvmx_cfg_port_param cvmx_cfg_port[CVMX_MAX_NODES][CVMX_HELPER
 		{[0 ... CVMX_HELPER_CFG_MAX_PORT_PER_IFACE - 1] =
 			{
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
-				CVMX_HELPER_CFG_INVALID_VALUE,
-				CVMX_HELPER_CFG_INVALID_VALUE,
+				/* port_fdt_node = */ CVMX_HELPER_CFG_INVALID_VALUE,
+				/* phy_fdt_node = */ CVMX_HELPER_CFG_INVALID_VALUE,
 #endif
-				CVMX_HELPER_CFG_INVALID_VALUE,
-				CVMX_HELPER_CFG_INVALID_VALUE,
-				CVMX_HELPER_CFG_INVALID_VALUE,
-				CVMX_HELPER_CFG_INVALID_VALUE,
-				CVMX_HELPER_CFG_INVALID_VALUE,
-				0, 0, 0, 0, false
+				/* ccpp_pknd = */ CVMX_HELPER_CFG_INVALID_VALUE,
+				/* ccpp_bpid =  */ CVMX_HELPER_CFG_INVALID_VALUE,
+				/* ccpp_pko_port_base = */ CVMX_HELPER_CFG_INVALID_VALUE,
+				/* ccpp_pko_num_ports = */ CVMX_HELPER_CFG_INVALID_VALUE,
+				/* agl_rx_clk_skew = */ 0,
+				/* valid = */ true,
+				/* sgmii_phy_mode = */ false,
+				/* sgmii_1000x_mode = */ false,
+				/* agl_rx_clk_delay_bypass = */ false,
+				/* force_link_up = */ false,
+				/* disable_an = */ false,
+				/* link_down_pwr_dn = */ false
 			}
 		}
 	};
@@ -1071,4 +1077,35 @@ int cvmx_helper_get_phy_fdt_node_offset(int xiface, int index)
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	return cvmx_cfg_port[xi.node][xi.interface][index].phy_fdt_node;
 }
+
+/**
+ * @INTERNAL
+ * Override default autonegotiation for a port
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ * @param enable	true to enable autonegotiation, false to force full
+ *			duplex, full speed.
+ */
+void cvmx_helper_set_port_autonegotiation(int xiface, int index, bool enable)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	cvmx_cfg_port[xi.node][xi.interface][index].disable_an = !enable;
+}
 #endif /* !CVMX_BUILD_FOR_LINUX_KERNEL */
+
+/**
+ * INTERNAL
+ * Returns if autonegotiation is enabled or not.
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ *
+ * @return 0 if autonegotiation is disabled, 1 if enabled.
+ */
+bool cvmx_helper_get_port_autonegotiation(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	return !cvmx_cfg_port[xi.node][xi.interface][index].disable_an;
+}
+
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index eb80686..8964341 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -210,29 +210,31 @@ static int __cvmx_pko3_config_memory(unsigned node)
  * The number of channels for each interface is derived from the ILK
  * module configuration.
  */
-static int __cvmx_pko3_config_ilk_interface(int xiface)
+static int __cvmx_pko3_config_ilk_interface(int xiface,
+	unsigned num_dq, bool prioritized)
 {
 	int l1_q_num;
 	int l2_q_num;
 	int res;
+	int res_owner;
 	int pko_mac_num;
-	unsigned num_chans;
+	unsigned num_chans, i;
 	uint16_t ipd_port;
-	int res_owner;
-	unsigned i;
-	const int num_dq = 1;	/* # of DQs per channel */
+	int prio;
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 
-	/* NOTE: changing `num_dq` to 8 will create 8 DQs per channel
-	 * to represent static priorities, but will be ordered by
-	 * system priority, not PCP QoS value. Probably not what we want.
-	 */
+	if (prioritized && num_dq > 1)
+		prio = num_dq;
+	else
+		prio = -1;
 
 	num_chans = __cvmx_helper_ilk_enumerate(xiface);
 
 	if(debug)
-		cvmx_dprintf("%s: configuring iface %u with %u ILK channels\n",
-			     __FUNCTION__, (unsigned int)xiface, num_chans);
+		cvmx_dprintf("%s: configuring ILK xiface %u:%u with "
+				"%u chans %u queues each\n",
+				__FUNCTION__, xi.node, xi.interface,
+				num_chans, num_dq);
 
 	/* ILK channels all go to the same mac */
 	pko_mac_num = __cvmx_pko3_get_mac_num(xiface, 0);
@@ -313,7 +315,8 @@ static int __cvmx_pko3_config_ilk_interface(int xiface)
 			res_owner, -1, num_dq);
 		if(dq < 0) goto _fail;
 
-		res = cvmx_pko3_sq_config_children(xi.node, 5, l5_q, dq, num_dq, num_dq);
+		res = cvmx_pko3_sq_config_children(xi.node, 5, l5_q,
+			dq, num_dq, prio);
 		if(res < 0) goto _fail;
 
 		/* register DQ range with the translation table */
@@ -323,8 +326,8 @@ static int __cvmx_pko3_config_ilk_interface(int xiface)
 
 	return 0;
   _fail:
-	cvmx_dprintf("%s: ERROR:configuring queues for xiface %u chan %u\n",
-		     __FILE__, (unsigned int)xiface, i);
+	cvmx_dprintf("ERROR: %s: configuring queues for xiface %u:%u chan %u\n",
+				__FUNCTION__, xi.node, xi.interface, i);
 	return -1;
 }
 
@@ -393,7 +396,7 @@ static int __cvmx_pko3_config_chan_interface( int xiface, unsigned num_chans,
 
 	/* Configre <num_chans> children for MAC, non-prioritized */
 	res = cvmx_pko3_pq_config_children( xi.node,
-			pko_mac_num, l2_q_num, num_chans, -1);
+			l1_q_num, l2_q_num, num_chans, -1);
 
 	if (res < 0) {
 		cvmx_dprintf("%s: ERROR: Failed channel queues\n",
@@ -441,6 +444,10 @@ static int __cvmx_pko3_config_chan_interface( int xiface, unsigned num_chans,
 			res_owner, -1, num_queues);
 		if(dq < 0) goto _fail;
 
+		if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_0) && (dq & 7))
+			cvmx_dprintf("WARNING: %s: DQ# %u not integral of 8\n",
+				__func__, dq);
+
 		res = cvmx_pko3_sq_config_children(xi.node, 5, l5_q,
 			dq, num_queues, prio);
 		if(res < 0) goto _fail;
@@ -452,8 +459,8 @@ static int __cvmx_pko3_config_chan_interface( int xiface, unsigned num_chans,
 
 	return 0;
   _fail:
-	cvmx_dprintf("%s: ERROR:configuring queues for xiface %u chan %u\n",
-		     __FILE__, (unsigned int)xiface, i);
+	cvmx_dprintf("ERROR: %s: configuring queues for xiface %u:%u chan %u\n",
+				__FUNCTION__, xi.node, xi.interface, i);
 	return -1;
 }
 
@@ -712,14 +719,18 @@ static int __cvmx_pko3_config_null_interface(unsigned int node)
 	int l1_q_num;
 	int l2_q_num;
 	int l3_q, l4_q, l5_q;
-	int res, res_owner;
+	int i, res, res_owner;
 	int xiface;
-
+	int num_dq = 1;	/* # of DQs for NULL */
 	const int dq = 0;	/* Reserve DQ#0 for NULL */
 	const int pko_mac_num = 0x1C; /* MAC# 28 virtual MAC for NULL */
 
+	if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_0))
+		num_dq = 8;
+
 	if(debug)
-		cvmx_dprintf("%s: configuring null interface\n", __FUNCTION__);
+		cvmx_dprintf("%s: null iface dq=%u-%u\n",
+			__FUNCTION__, dq, dq+num_dq-1);
 
 	/* Build an identifiable owner identifier by MAC# for easy release */
 	res_owner = __cvmx_helper_pko3_res_owner(CVMX_PKO3_IPD_PORT_NULL);
@@ -760,7 +771,7 @@ static int __cvmx_pko3_config_null_interface(unsigned int node)
 
 	/* Reserve DQ at 0 by convention */
 	res = cvmx_pko_alloc_queues(node, CVMX_PKO_DESCR_QUEUES, res_owner,
-		dq, 1);
+		dq, num_dq);
 	if (dq != res) {
 		cvmx_dprintf("%s: ERROR: could not reserve DQs\n",
 			__FUNCTION__);
@@ -771,16 +782,17 @@ static int __cvmx_pko3_config_null_interface(unsigned int node)
 	cvmx_pko3_sq_config_children(node, 2, l2_q_num, l3_q, 1, 1);
 	cvmx_pko3_sq_config_children(node, 3, l3_q, l4_q, 1, 1);
 	cvmx_pko3_sq_config_children(node, 4, l4_q, l5_q, 1, 1);
-	cvmx_pko3_sq_config_children(node, 5, l5_q, dq, 1, 1);
+	cvmx_pko3_sq_config_children(node, 5, l5_q, dq, num_dq, num_dq);
 
 	/* NULL interface does not need to map to a CHAN_E */
 
 	/* register DQ/IPD translation */
 	xiface = cvmx_helper_node_interface_to_xiface(node, __CVMX_XIFACE_NULL);
-	__cvmx_pko3_ipd_dq_register(xiface, 0, dq, 1);
+	__cvmx_pko3_ipd_dq_register(xiface, 0, dq, num_dq);
 
-	/* open the null DQ here */
-	res = cvmx_pko_dq_open(node, dq);
+	/* open the null DQs here */
+	for(i = 0; i < num_dq; i++)
+		cvmx_pko_dq_open(node, dq + i);
 
 	return 0;
 }
@@ -834,7 +846,7 @@ int cvmx_helper_pko3_init_interface(int xiface)
 {
 	cvmx_helper_interface_mode_t mode;
 	int subif, num_ports;
-	bool fcs_enable, pad_enable;
+	bool fcs_enable, pad_enable, pad_enable_pko;
 	uint8_t fcs_sof_off = 0;
 	uint8_t num_queues = 1;
 	bool qos = false, pfc = false;
@@ -861,14 +873,20 @@ int cvmx_helper_pko3_init_interface(int xiface)
 			.qos_enable;
 	}
 
+	/* Force 8 DQs per port for pass 1.0 to circumvent limitations */
+	if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_0)) {
+		num_queues = 8;
+		qos = true;
+	}
+
 	/* For ILK there is one IPD port per channel */
 	if ((mode == CVMX_HELPER_INTERFACE_MODE_ILK))
 		num_ports =  __cvmx_helper_ilk_enumerate(xiface);
 
 	/* Skip non-existent interfaces */
 	if(num_ports < 1) {
-		cvmx_dprintf("%s: ERROR invalid interface %d\n",
-			     __FUNCTION__, xiface );
+		cvmx_dprintf("ERROR: %s: invalid iface %u:%u\n",
+			     __FUNCTION__, xi.node, xi.interface);
 		return -1;
 	}
 
@@ -879,6 +897,10 @@ int cvmx_helper_pko3_init_interface(int xiface)
 		qos =
 			__cvmx_pko_queue_static_config.
 				pknd.pko_cfg_loop.qos_enable;
+
+		if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_0))
+			num_queues = 8;
+
 		res = __cvmx_pko3_config_chan_interface(xiface, num_ports,
 				num_queues, qos);
 		if (res < 0) {
@@ -893,6 +915,10 @@ int cvmx_helper_pko3_init_interface(int xiface)
 		qos =
 			__cvmx_pko_queue_static_config.
 				pknd.pko_cfg_npi.qos_enable;
+
+		if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_0))
+			num_queues = 8;
+
 		res = __cvmx_pko3_config_chan_interface(xiface, num_ports,
 				num_queues, qos);
 		if (res < 0) {
@@ -902,8 +928,8 @@ int cvmx_helper_pko3_init_interface(int xiface)
 
 	/* ILK-specific queue configuration */
 	else if (mode == CVMX_HELPER_INTERFACE_MODE_ILK) {
-		num_queues = 1; qos = false; pfc = false;
-		res = __cvmx_pko3_config_ilk_interface(xiface);
+		num_queues = 8; qos = true; pfc = false;
+		res = __cvmx_pko3_config_ilk_interface(xiface, num_queues, qos);
 	}
 
 	/* Setup all ethernet configured for PFC */
@@ -936,20 +962,22 @@ int cvmx_helper_pko3_init_interface(int xiface)
 	fcs_enable = __cvmx_helper_get_has_fcs(xiface);
 	pad_enable = __cvmx_helper_get_pko_padding(xiface);
 
+	if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+		pad_enable_pko = false;
+	else
+		pad_enable_pko = pad_enable;
+
 	if(debug)
 		cvmx_dprintf("%s: FCS=%d pad=%d\n",
 			__func__, fcs_enable, pad_enable);
 
 	/* Setup interface options */
 	for (subif = 0; subif < num_ports; subif++) {
+
 		/* Open interface/port DQs to allow transmission to begin */
-#ifdef	__PKO_MINPAD_FIXED
 		res = __cvmx_pko3_helper_dqs_activate(xiface,
-			subif, pad_enable);
-#else
-		/* PAD=false on all interfaces, it is broken */
-		res = __cvmx_pko3_helper_dqs_activate(xiface, subif, false);
-#endif
+			subif, pad_enable_pko);
+
 		if (res < 0)
 			goto __cfg_error;
 
@@ -964,33 +992,35 @@ int cvmx_helper_pko3_init_interface(int xiface)
 		/* NPI has only one MAC, subif == 'ring' */
 		if (mode == CVMX_HELPER_INTERFACE_MODE_NPI && subif > 0)
 			continue;
-#ifdef	__PKO_MINPAD_FIXED
-		res = cvmx_pko3_interface_options(xiface, subif,
-				  fcs_enable, pad_enable, fcs_sof_off);
-#else
+
 		if (xi.interface > 5) {
-			/* Not BGX, use PKO FCS but not PAD as it is broken */
+			/* Non-BGX interface, use PKO for FCS/PAD */
+			res = cvmx_pko3_interface_options(xiface, subif,
+				fcs_enable, pad_enable_pko, fcs_sof_off);
+		} else if (pad_enable == pad_enable_pko) {
+			/* BGX interface with FCS/PAD done by PKO */
 			res = cvmx_pko3_interface_options(xiface, subif,
-				  fcs_enable,
-				/* pad_enable */false,
-				fcs_sof_off);
+				  fcs_enable, pad_enable, fcs_sof_off);
+			cvmx_helper_bgx_tx_options(xi.node, xi.interface, subif,
+				false, false);
 		} else {
-			/* Use BGX feature because PKO NONPAD i sbroken */
+			/* BGX interface with FCS/PAd done by BGX */
 			res = cvmx_pko3_interface_options(xiface, subif,
 				  false, false, fcs_sof_off);
 			cvmx_helper_bgx_tx_options(xi.node, xi.interface, subif,
 				fcs_enable, pad_enable);
 		}
-#endif
+
 		if(res < 0)
-			cvmx_dprintf("%s: WARNING: failed to set options for interface %d subif %d\n",
-				     __func__, xiface, subif);
+			cvmx_dprintf("WARNING: %s: "
+				"option set failed on iface %u:%u/%u\n",
+				__FUNCTION__, xi.node, xi.interface, subif);
 	}
 	return 0;
 
   __cfg_error:
-	cvmx_dprintf("%s: ERROR configuring interface %u subif %u\n",
-		     __FUNCTION__, xiface, subif);
+	cvmx_dprintf("ERROR: %s: failed on iface %u:%u/%u\n",
+		__FUNCTION__, xi.node, xi.interface, subif);
 	return -1;
 }
 
@@ -1009,7 +1039,7 @@ int __cvmx_helper_pko3_init_global(unsigned int node, uint16_t gaura)
 
 	res = cvmx_pko3_hw_init_global(node, gaura);
 	if(res < 0) {
-		cvmx_dprintf("%s: ERROR: failed block initialization\n",
+		cvmx_dprintf("ERROR: %s:failed block initialization\n",
 			__FUNCTION__);
 		return res;
 	}
@@ -1021,7 +1051,7 @@ int __cvmx_helper_pko3_init_global(unsigned int node, uint16_t gaura)
 	/* add NULL MAC/DQ setup */
 	res = __cvmx_pko3_config_null_interface(node);
 	if (res < 0)
-		cvmx_dprintf("%s: ERROR creating NULL interface\n",
+		cvmx_dprintf("ERROR: %s: creating NULL interface\n",
 			__FUNCTION__);
 
 	return res;
@@ -1086,7 +1116,7 @@ int cvmx_helper_pko3_init_global(unsigned int node)
 	res = __cvmx_pko3_config_memory(node);
 #endif
 	if(res < 0) {
-		cvmx_dprintf("%s: ERROR: PKO3 memory allocation error\n",
+		cvmx_dprintf("ERROR: %s: PKO3 memory allocation error\n",
 			__FUNCTION__);
 		return res;
 	}
@@ -1169,8 +1199,8 @@ int cvmx_helper_pko3_shut_interface(int xiface)
                 dq_count = cvmx_pko3_get_queue_num(ipd_port);
 
                 if( dq_base < 0 || dq_count < 0) {
-                        cvmx_dprintf("%s: ERROR: No descriptor queues for interface %d index %d\n",
-                                __FUNCTION__, xiface, index);
+                        cvmx_dprintf("ERROR: %s: No DQs for iface %u:%d/%u\n",
+                                __FUNCTION__, xi.node, xi.interface, index);
 			continue;
 		}
 
@@ -1178,15 +1208,16 @@ int cvmx_helper_pko3_shut_interface(int xiface)
 		dq_base &= (1 << 10)-1;
 
 		if (debug)
-			cvmx_dprintf("%s: xiface %u:%d port %d dq %u-%u\n",
+			cvmx_dprintf("%s: xiface %u:%d/%d dq %u-%u\n",
 			__func__, xi.node, xi.interface, index,
 			dq_base, dq_base + dq_count -1);
 
 		/* Unregister the DQs for the port, should stop traffic */
 		res = __cvmx_pko3_ipd_dq_unregister(xiface, index);
 		if(res < 0) {
-                        cvmx_dprintf("%s: ERROR: can not unregister queues for interface %d index %d\n",
-                                __FUNCTION__, xiface, index);
+                        cvmx_dprintf("ERROR: %s: "
+				"failed to unregister DQs iface %u/%d/%u\n",
+                                __FUNCTION__, xi.node, xi.interface, index);
 			continue;
 		}
 
@@ -1209,14 +1240,14 @@ int cvmx_helper_pko3_shut_interface(int xiface)
 			} while(res > 0);
 
 			if (res != 0)
-				cvmx_dprintf("%s: ERROR: querying queue %u\n",
+				cvmx_dprintf("ERROR: %s: querying queue %u\n",
 					__FUNCTION__, dq_base + i);
 
 			/* Close the queue, free internal buffers */
 			res = cvmx_pko3_dq_close(xi.node, dq_base + i);
 
 			if (res < 0)
-				cvmx_dprintf("%s: ERROR: closing queue %u\n",
+				cvmx_dprintf("ERROR: %s: closing queue %u\n",
 					__FUNCTION__, dq_base + i);
 
 		}
@@ -1225,7 +1256,7 @@ int cvmx_helper_pko3_shut_interface(int xiface)
 
 		res_owner = __cvmx_helper_pko3_res_owner(ipd_port);
 		if (res_owner < 0) {
-			cvmx_dprintf ("%s: ERROR no resource owner ticket\n",
+			cvmx_dprintf ("ERROR: %s: no resource owner ticket\n",
 				__FUNCTION__);
 			continue;
 		}
@@ -1265,7 +1296,7 @@ int cvmx_helper_pko3_shutdown(unsigned int node)
 	for(dq =0; dq < (1<<10); dq++) {
 		res = cvmx_pko3_dq_close(node, dq);
 		if (res != 0) {
-			cvmx_dprintf("%s: ERROR: PKO3 descriptor queue %u "
+			cvmx_dprintf("ERROR: %s: PKO3 descriptor queue %u "
 				"could not be closed\n",
 				__FUNCTION__, dq);
 			return -1;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
index 74c90e3..f3a0fb4 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
@@ -43,7 +43,7 @@
  * Functions for SGMII initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 99347 $<hr>
+ * <hr>$Revision: 100490 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -181,7 +181,8 @@ static int __cvmx_helper_sgmii_hardware_init_link(int interface, int index)
 	union cvmx_pcsx_mrx_control_reg control_reg;
 	union cvmx_pcsx_miscx_ctl_reg pcsx_miscx_ctl_reg;
 	bool phy_mode;
-	bool mode_1000x;
+	bool an_disable;	/** Disable autonegotiation */
+	bool mode_1000x;	/** 1000Base-X mode */
 
 	if (!cvmx_helper_is_port_valid(interface, index))
 		return 0;
@@ -214,12 +215,16 @@ static int __cvmx_helper_sgmii_hardware_init_link(int interface, int index)
 	 * sgmii negotiation starts.
 	 */
 	phy_mode = cvmx_helper_get_mac_phy_mode(interface, index);
-	control_reg.s.an_en = !phy_mode;
+	an_disable = (phy_mode ||
+		      !cvmx_helper_get_port_autonegotiation(interface, index));
+
+	control_reg.s.an_en = !an_disable;
 
 	/* Force a PCS reset by powering down the PCS interface */
 	control_reg.s.pwr_dn = 1;
 	cvmx_write_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface),
 		       control_reg.u64);
+	cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
 
 	if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM)
 		/* 25ms should be enough, 10ms is too short */
@@ -236,7 +241,7 @@ static int __cvmx_helper_sgmii_hardware_init_link(int interface, int index)
 	pcsx_miscx_ctl_reg.s.mode = mode_1000x;
 	pcsx_miscx_ctl_reg.s.mac_phy = phy_mode;
 	cvmx_write_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface), pcsx_miscx_ctl_reg.u64);
-	if (phy_mode)
+	if (an_disable)
 		/* In PHY mode we can't query the link status so we just
 		 * assume that the link is up.
 		 */
@@ -691,12 +696,17 @@ cvmx_helper_link_info_t __cvmx_helper_sgmii_link_get(int ipd_port)
 int __cvmx_helper_sgmii_link_set(int ipd_port,
 				 cvmx_helper_link_info_t link_info)
 {
+	union cvmx_pcsx_mrx_control_reg control_reg;
 	int interface = cvmx_helper_get_interface_num(ipd_port);
 	int index = cvmx_helper_get_interface_index_num(ipd_port);
 
 	if (!cvmx_helper_is_port_valid(interface, index))
 		return 0;
 
+	/* For some devices, i.e. the Qualcomm QCA8337 switch we need to power
+	 * down the PCS interface when the link goes down and power it back
+	 * up when the link returns.
+	 */
 	if (link_info.s.link_up || !__cvmx_helper_need_g15618()) {
 		__cvmx_helper_sgmii_hardware_init_link(interface, index);
 	} else {
@@ -704,15 +714,22 @@ int __cvmx_helper_sgmii_link_set(int ipd_port,
 
 		pcsx_miscx_ctl_reg.u64 = cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
 
-		/* Disable autonegotiation only when MAC mode is enabled. */
-		if (pcsx_miscx_ctl_reg.s.mac_phy == 0) {
-			union cvmx_pcsx_mrx_control_reg control_reg;
-			control_reg.u64 = cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
+		/* Disable autonegotiation when MAC mode is enabled or
+		 * autonegotiation is disabled.
+		 */
+		control_reg.u64 = cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
+		if (pcsx_miscx_ctl_reg.s.mac_phy == 0 ||
+		    !cvmx_helper_get_port_autonegotiation(interface, index)) {
+
 			control_reg.s.an_en = 0;
-			cvmx_write_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface),
-					control_reg.u64);
-			cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
+			control_reg.s.spdmsb = 1;
+			control_reg.s.spdlsb = 0;
+			control_reg.s.dup = 1;
+
 		}
+		cvmx_write_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface),
+			       control_reg.u64);
+		cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
 		/*
 		 * Use GMXENO to force the link down it will get
 		 * reenabled later...
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
index 36ec03f..9395432 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
@@ -384,13 +384,9 @@ cvmx_buf_ptr_t cvmx_wqe_get_packet_ptr(cvmx_wqe_t *work)
 
 		/* Calculate the "back" offset */
 		if (!nptr.packet_outside_wqe)
-			optr.s.back = (nptr.addr-cvmx_ptr_to_phys(wqe))
-				>> 7;
+			optr.s.back = (nptr.addr-cvmx_ptr_to_phys(wqe)) >> 7;
 		else
-                        optr.s.back = 0; /*((nptr.addr - pki_dflt_style[0].parm_cfg.first_skip) >> 7) << 7*/;
-
- //XXX assume <128, get actual pool sz
-
+                        optr.s.back = (pki_dflt_style[0].parm_cfg.first_skip + 8 + wqe->word0.apad) >> 7;
 		lptr = optr;
 
 		/* Follow pointer and convert all linked pointers */
@@ -410,7 +406,7 @@ cvmx_buf_ptr_t cvmx_wqe_get_packet_ptr(cvmx_wqe_t *work)
 			lptr.s.pool = pool;
 			lptr.s.addr = nptr.addr;
 			lptr.s.size = nptr.size;
-                        lptr.s.back = 0; //((nptr.addr - pki_dflt_style[0].parm_cfg.later_skip) >> 7) << 7;;	//XXX- not guarangeed !!
+                        lptr.s.back = (pki_dflt_style[0].parm_cfg.later_skip + 8) >> 7;	//XXX- not guarangeed !!
 
 			memcpy(vptr-8, &lptr, 8);
 			bufs --;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c b/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
index e399902..8cdd9b5 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
@@ -43,7 +43,7 @@
  * Functions for XAUI initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 99228 $<hr>
+ * <hr>$Revision: 100545 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -391,7 +391,7 @@ int __cvmx_helper_xaui_enable(int xiface)
 	}
 
 	/* 70XX eval boards use Marvel phy, set disparity accordingly. */
-	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_EVB7000) {
+	if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
 		union cvmx_gmxx_rxaui_ctl rxaui_ctl;
 		rxaui_ctl.u64 = cvmx_read_csr(CVMX_GMXX_RXAUI_CTL(interface));
 		rxaui_ctl.s.disparity = 1;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index e1ba3fb..9ae319d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 100137 $<hr>
+ * <hr>$Revision: 100548 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1146,6 +1146,95 @@ static int __cvmx_pcie_rc_initialize_link_gen2(int pcie_port)
 }
 
 /**
+ * @INTERNAL
+ * Return the QLM number for the PCIE port.
+ *
+ * @param  pcie_port  QLM number to return for.
+ *
+ * @return QLM number.
+ */
+static int __cvmx_pcie_get_qlm(int pcie_port)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
+		enum cvmx_qlm_mode mode1 = cvmx_qlm_get_mode(1);
+		enum cvmx_qlm_mode mode2 = cvmx_qlm_get_mode(2);
+		switch (pcie_port) {
+		case 0: /* PCIe0 can be DLM1 with 1, 2 or 4 lanes */
+			if (mode1 == CVMX_QLM_MODE_PCIE || /* Using DLM 1-2 */
+			    mode1 == CVMX_QLM_MODE_PCIE_1X2 || /* Using DLM 1 */
+			    mode1 == CVMX_QLM_MODE_PCIE_2X1 || /* Using DLM 1, lane 0 */
+			    mode1 == CVMX_QLM_MODE_PCIE_1X1) /* Using DLM 1, lane0, lane 1 not used */
+				return 1;
+			else
+				return -1;
+		case 1: /* PCIe1 can be DLM1 1 lane(1), DLM2 1 lane(0) or 2 lanes(0-1) */
+			if (mode1 == CVMX_QLM_MODE_PCIE_2X1)
+				return 1;
+			else if (mode2 == CVMX_QLM_MODE_PCIE_1X2)
+				return 2;
+			else if (mode2 == CVMX_QLM_MODE_PCIE_2X1)
+				return 2;
+			else
+				return -1;
+		case 2: /* PCIe2 can be DLM2 1 lanes(1) */
+			if (mode2 == CVMX_QLM_MODE_PCIE_2X1)
+				return 2;
+			else
+				return -1;
+		default: /* Only three PEM blocks */
+			return -1;
+		}
+	}
+
+	return -1;
+}
+
+/**
+ * @INTERNAL
+ * Set the MPLL Multiplier for PCIe port
+ */
+static void __cvmx_pcie_set_mult(int pcie_port)
+{
+	cvmx_gserx_dlmx_ref_clkdiv2_t ref_clkdiv2;
+	cvmx_gserx_dlmx_mpll_multiplier_t mpll_multiplier;
+	uint64_t meas_refclock, mult;
+	int baud_mhz = 2500;
+	int qlm = __cvmx_pcie_get_qlm(pcie_port);
+	int old_multiplier = 56; /* Value as per Errata 20669 */
+
+	if (!OCTEON_IS_MODEL(OCTEON_CN70XX))
+		return;
+
+	if (qlm == -1)
+		return;
+
+	ref_clkdiv2.u64 = cvmx_read_csr(CVMX_GSERX_DLMX_REF_CLKDIV2(qlm, 0));
+	if (ref_clkdiv2.s.ref_clkdiv2 == 0) {
+		ref_clkdiv2.s.ref_clkdiv2 = 1;
+		cvmx_write_csr(CVMX_GSERX_DLMX_REF_CLKDIV2(qlm, 0),
+				ref_clkdiv2.u64);
+		cvmx_wait(10000);
+	}
+
+	meas_refclock = cvmx_qlm_measure_clock(qlm);
+	if (meas_refclock == 0) {
+		cvmx_warn("DLM%d: Reference clock not running\n", qlm);
+		return;
+	}
+
+	mult = (uint64_t)baud_mhz * 1000000 + (meas_refclock/2);
+	mult /= meas_refclock;
+
+	do {
+		mpll_multiplier.u64 = cvmx_read_csr(CVMX_GSERX_DLMX_MPLL_MULTIPLIER(qlm, 0));
+		mpll_multiplier.s.mpll_multiplier = --old_multiplier;
+		cvmx_write_csr(CVMX_GSERX_DLMX_MPLL_MULTIPLIER(qlm, 0), mpll_multiplier.u64);
+		/* Wait for 1 ms */
+		cvmx_wait_usec(1000);
+	} while (old_multiplier > (int)mult);
+}
+
+/**
  * Initialize a PCIe gen 2 port for use in host(RC) mode. It doesn't enumerate
  * the bus.
  *
@@ -1439,6 +1528,9 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 	/* Wait for PCIe reset to complete */
 	cvmx_wait_usec(1000);
 
+	/* Set MPLL multiplier as per Errata 20669. */
+	__cvmx_pcie_set_mult(pcie_port);
+
 	/* Check and make sure PCIe came out of reset. If it doesn't the board
 	   probably hasn't wired the clocks up and the interface should be
 	   skipped */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
index 7d4c6d0..4a182fa 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
@@ -62,18 +62,20 @@
 /* Smalles Round-Robin quantum to use +1 */
 #define	CVMX_PKO3_RR_QUANTUM_MIN	0x10
 
-static int debug = 0;
+static int debug = 0;	/* 1 for basic, 2 for detailed trace */
+
+/* Minimum MTU assumed for shaping configuration */
+static unsigned __pko3_min_mtu = 9080;
+/* FIXME: The above could be made a per-port config param */
 
 struct cvmx_pko3_dq {
 #ifdef __BIG_ENDIAN_BITFIELD
-	unsigned	
-			dq_count :6,	/* Number of descriptor queues */
-			dq_base :10;	/* Descriptor queue start number */
+	unsigned	dq_count :6;	/* Number of descriptor queues */
+	unsigned	dq_base :10;	/* Descriptor queue start number */
 #define	CVMX_PKO3_SWIZZLE_IPD	0x0
 #else
-	unsigned	
-			dq_base :10,	/* Descriptor queue start number */
-			dq_count :6;	/* Number of descriptor queues */
+	unsigned	dq_base :10;	/* Descriptor queue start number */
+	unsigned	dq_count :6;	/* Number of descriptor queues */
 
 #define	CVMX_PKO3_SWIZZLE_IPD	0x3
 #endif
@@ -478,6 +480,11 @@ static void cvmx_pko_configure_l3_queue(int node, int queue, int parent_queue,
 			CVMX_PKO_L2_SQX_TOPOLOGY(parent_queue),
 			pko_parent_topology.u64);
 
+	if (debug>1) cvmx_dprintf("CVMX_PKO_L2_SQX_TOPOLOGY(%u): "
+		"PRIO_ANCHOR=%u PARENT=%u\n",
+		parent_queue, pko_parent_topology.s.prio_anchor,
+		pko_parent_topology.s.parent);
+
 	/* scheduler configuration for this sq in the parent queue */
 	pko_sq_sched.u64 = 0;
 	pko_sq_sched.s.prio = prio;
@@ -522,6 +529,11 @@ static void cvmx_pko_configure_l4_queue(int node, int queue, int parent_queue,
 			CVMX_PKO_L3_SQX_TOPOLOGY(parent_queue),
 			pko_parent_topology.u64);
 
+	if (debug>1) cvmx_dprintf("CVMX_PKO_L3_SQX_TOPOLOGY(%u): "
+		"PRIO_ANCHOR=%u PARENT=%u\n",
+		parent_queue, pko_parent_topology.s.prio_anchor,
+		pko_parent_topology.s.parent);
+
 	/* scheduler configuration for this sq in the parent queue */
 	pko_sq_sched.u64 = 0;
 	pko_sq_sched.s.prio = prio;
@@ -565,6 +577,11 @@ static void cvmx_pko_configure_l5_queue(int node, int queue, int parent_queue,
 			CVMX_PKO_L4_SQX_TOPOLOGY(parent_queue),
 			pko_parent_topology.u64);
 
+	if (debug>1) cvmx_dprintf("CVMX_PKO_L4_SQX_TOPOLOGY(%u): "
+		"PRIO_ANCHOR=%u PARENT=%u\n",
+		parent_queue, pko_parent_topology.s.prio_anchor,
+		pko_parent_topology.s.parent);
+
 	/* scheduler configuration for this sq in the parent queue */
 	pko_sq_sched.u64 = 0;
 	pko_sq_sched.s.prio = prio;
@@ -600,6 +617,10 @@ static void cvmx_pko_configure_dq(int node, int dq, int parent_queue,
 	cvmx_pko_l5_sqx_topology_t pko_parent_topology;
 	cvmx_pko_dqx_wm_ctl_t pko_dq_wm_ctl;
 
+	if (debug)
+		cvmx_dprintf("%s: dq %u parent %u child_base %u\n",
+			     __func__, dq, parent_queue, child_base);
+
 	/* parent topology configuration */
 	pko_parent_topology.u64 = cvmx_read_csr_node(node,
 			CVMX_PKO_L5_SQX_TOPOLOGY(parent_queue));
@@ -609,6 +630,11 @@ static void cvmx_pko_configure_dq(int node, int dq, int parent_queue,
 			CVMX_PKO_L5_SQX_TOPOLOGY(parent_queue),
 			pko_parent_topology.u64);
 
+	if (debug>1) cvmx_dprintf("CVMX_PKO_L5_SQX_TOPOLOGY(%u): "
+		"PRIO_ANCHOR=%u PARENT=%u\n",
+		parent_queue, pko_parent_topology.s.prio_anchor,
+		pko_parent_topology.s.parent);
+
 	/* scheduler configuration for this dq in the parent queue */
 	pko_dq_sched.u64 = 0;
 	pko_dq_sched.s.prio = prio;
@@ -625,6 +651,17 @@ static void cvmx_pko_configure_dq(int node, int dq, int parent_queue,
 	pko_dq_wm_ctl.s.kind = 1;
 	pko_dq_wm_ctl.s.enable = 0;
 	cvmx_write_csr_node(node, CVMX_PKO_DQX_WM_CTL(dq), pko_dq_wm_ctl.u64);
+
+	if (debug>1) {
+		pko_dq_sched.u64 = cvmx_read_csr_node(node,
+			CVMX_PKO_DQX_SCHEDULE(dq));
+		pko_dq_topology.u64 = cvmx_read_csr_node(node,
+			CVMX_PKO_DQX_TOPOLOGY(dq));
+		cvmx_dprintf("CVMX_PKO_DQX_TOPOLOGY(%u)PARENT=%u "
+			"CVMX_PKO_DQX_SCHEDULE(%u) PRIO=%u Q=%u\n",
+			dq, pko_dq_topology.s.parent,
+			dq, pko_dq_sched.s.prio, pko_dq_sched.s.rr_quantum);
+	}
 }
 
 
@@ -719,7 +756,7 @@ int cvmx_pko3_pq_config_children(unsigned node, unsigned mac_num,
 		rr_quantum = CVMX_PKO3_RR_QUANTUM_MIN;
 
 	if(debug)
-		cvmx_dprintf("%s: L1/PQ%02u MAC%02u child_base %u rr_pri %u\n",
+		cvmx_dprintf("%s: L1/PQ%u MAC%u child_base %u rr_pri %u\n",
 		__FUNCTION__, pq_num, mac_num, child_base, rr_prio);
 
 	cvmx_pko_configure_port_queue(node,
@@ -729,7 +766,7 @@ int cvmx_pko3_pq_config_children(unsigned node, unsigned mac_num,
 	for(child = child_base; child < (child_base + child_count); child ++) {
 		if (debug)
 			cvmx_dprintf("%s: "
-				"L2/SQ%u->PQ%02u prio %u rr_quantum %#x\n",
+				"L2/SQ%u->PQ%u prio %u rr_quantum %#x\n",
 				__FUNCTION__,
 				child, pq_num, prio, rr_quantum);
 
@@ -821,7 +858,7 @@ int cvmx_pko3_sq_config_children(unsigned int node, unsigned parent_level,
 		rr_quantum = CVMX_PKO3_RR_QUANTUM_MIN;
 
 	if(debug)
-		cvmx_dprintf("%s: Parent L%u/SQ%02u child_base %u rr_pri %u\n",
+		cvmx_dprintf("%s: Parent L%u/SQ%u child_base %u rr_pri %u\n",
 		__FUNCTION__, parent_level, parent_queue, child_base, rr_prio);
 
 	/* Parent is configured with child */
@@ -853,23 +890,38 @@ int cvmx_pko3_sq_config_children(unsigned int node, unsigned parent_level,
  * 
  * @INTERNAL
  *
- * FIXME:
- * The calculation is based on partial understanding of 
- * register fields. Must update when more details become
- * available.
+ * Common function to convert bit-rate (ie kilo-bits-per-sec)
+ * and maximum burst (in bytes) values to PKO shaper register
+ * format, that is a short-float type, with divisor.
+ *
+ * @param tclk is the time-wheel clock for the specific shaper
+ * @param reg is a pointer to a register structure
+ * @param rate_kips is the requested bit rate in kilobits/sec
+ * @param burst_bytes is the size of maximum burst in bytes
+ *
+ * @return A negative number means the transfer rate could
+ * not be set within acceptable tolerance, and the actual
+ * error in PPM is the negative of the returned value.
+ * A positive value indicates that the bit rate was set
+ * within acceptable tolerance, but the burst rate had an
+ * error, which is returned in PPM.
+ * A value of 0 means both measures were set within tolerance.
+ *
+ * Note that the bust error could be as a result of this function
+ * enforcing the minimum MTU as the minimum burst size allowed.
+ * 
  */
 static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
 		cvmx_pko_l1_sqx_cir_t *reg,
 		unsigned long rate_kbips, unsigned burst_bytes)
 {
 	const unsigned max_exp = 12;	/* maximum exponent */
-	const unsigned tock_bytes_exp = 3;	/* rate in 8-byte words */
+	const unsigned tock_bytes_exp = 0;	/* tock rate in bytes */
 	long long burst_v, rate_v;
 	unsigned long long rate_tocks, burst_tocks;
 	unsigned long min_burst;
 	unsigned div_exp, mant, exp;
 	unsigned long long tmp, fmax;
-	int debug = 1;	// XXX
 
 	if (debug)
 		cvmx_dprintf("%s: tclk=%lu, rate=%lu kbps, burst=%u bytes\n",
@@ -877,7 +929,8 @@ static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
 
 	/* Convert API args into tocks: PSE native units */
 	tmp = (1 << (3 + tock_bytes_exp))-1;
-	rate_tocks = (1000ULL * rate_kbips + tmp) >> (3 + tock_bytes_exp);
+	tmp += rate_kbips;
+	rate_tocks = (1000ULL * tmp) >> (3 + tock_bytes_exp);
 	tmp = (1 << tock_bytes_exp) - 1;
 	burst_tocks = (burst_bytes+tmp) >> tock_bytes_exp;
 
@@ -888,30 +941,40 @@ static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
 	for (div_exp = 0; div_exp <= max_exp; div_exp++) {
 		tmp = (rate_tocks << div_exp) / tclk;
 		if (tmp > fmax) {
-			div_exp --;
+			if (div_exp > 0)
+				div_exp --;
 			break;
 		}
 	}
 
-	/* Make sure exponent is within valid range */
-	if (div_exp > max_exp)
+	/* Make sure divider, rate are within valid range */
+	if (div_exp > max_exp) {
+		/* Minimum reached */
 		div_exp = max_exp;
+	} else if (div_exp == 0) {
+		/* Maximum reached */
+		if ((rate_tocks / tclk) > fmax)
+			rate_tocks = fmax * tclk;
+	}
 
 	/* Store common divider */
 	reg->s.rate_divider_exponent = div_exp;
 
-	/* XXX-
-	 * Assu,ing the BURST field is the actual satiration value
-	 * for the rate accumulator, while the argument is the 
-	 * delta burst amount to add to the accumulator value
-	 * required to maintain the requested rate.
+	/* Burst register is the maximum accumulated credit count
+	 * in bytes, which must not be less then the MTU, and
+	 * should not be less than RATE/Tclk
 	 */
 
 	/* Find the minimum burst size needed for rate */
 	min_burst = (rate_tocks << div_exp) / tclk;
+	
+	/* Override with minimum MTU (could become per-port cfg) */
+	if (min_burst < __pko3_min_mtu)
+		min_burst = __pko3_min_mtu;
 
 	/* Apply the minimum */
-	burst_tocks += min_burst;
+	if (burst_tocks < min_burst)
+		burst_tocks = min_burst;
 
 	/* Calculate the rate short float */
 	tmp = (rate_tocks << (div_exp + 8)) / tclk;
@@ -945,7 +1008,7 @@ static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
 	burst_v = CVMX_SHOFT_TO_U64(reg->s.burst_mantissa,
 				reg->s.burst_exponent);
 	/* Convert in additional bytes as in argument */
-	burst_v = (burst_v - min_burst) << (tock_bytes_exp);
+	burst_v = burst_v << (tock_bytes_exp);
 	
 	if (debug)
 		cvmx_dprintf("%s: result rate=%'llu kbips burst=%llu bytes\n",
@@ -966,10 +1029,10 @@ static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
 		cvmx_dprintf("%s: error rate=%llu burst=%llu ppm\n",
 			__func__, rate_v, burst_v);
 
-	/* Allow ~ 100 ppm error for CIR, and 5% for BURST */
-	if (rate_v > 100)
+	/* Allow 1% error for CIR/PIR, and 5% for BURST */
+	if (rate_v > 10000)
 		return -rate_v;
-	if (burst_v > 5000)
+	if (burst_v > 50000)
 		return burst_v;
 
 	return 0;
@@ -984,7 +1047,7 @@ static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
  * @param node The OCI node where the target port is located
  * @param pq_num The L1/PQ queue number for this setting
  * @param rate_kbips The desired throughput in kilo-bits-per-second
- * @param burst_size The size of a burst in bytes above 'rate_kbips' allowed
+ * @param burst_size The size of a burst in bytes, at least MTU
  *
  * @return Returns zero if both settings applied within allowed tolerance,
  * otherwise the error is returned in parts-per-million.
@@ -1022,7 +1085,9 @@ int cvmx_pko3_port_cir_set(unsigned node, unsigned pq_num,
 	rc = cvmx_pko3_shaper_rate_compute(tclk, &sqx_cir,
 		rate_kbips, burst_bytes);
 
-	/* FIXME: should refuse to set register if insane rates ? */
+	/* Refuse to set register if insane rates, 25% = 250,000 PPM  */
+	if (rc < 250000)
+		return rc;
 
 	/* Enable shaping */
 	sqx_cir.s.enable = 1;
@@ -1041,11 +1106,11 @@ int cvmx_pko3_port_cir_set(unsigned node, unsigned pq_num,
  * @param node The OCI node where the target port is located
  * @param dq_num The descriptor queue number for this setting
  * @param rate_kbips The desired throughput in kilo-bits-per-second
- * @param burst_size The size of a burst in bytes above 'rate_kbips' allowed
+ * @param burst_size The size of a burst in bytes, at least MTU
  *
  * @return Returns zero if both settings applied within allowed tolerance,
  * otherwise the error is returned in parts-per-million.
- * 'rate_bps" error is e negative number, otherwise 'birst_rate' error
+ * 'rate_bps" error is a negative number, otherwise 'birst_rate' error
  * is returned as a positive integer.
  */
 int cvmx_pko3_dq_cir_set(unsigned node, unsigned dq_num,
@@ -1082,7 +1147,9 @@ int cvmx_pko3_dq_cir_set(unsigned node, unsigned dq_num,
 	rc = cvmx_pko3_shaper_rate_compute(tclk, &sqx_cir,
 		rate_kbips, burst_bytes);
 
-	/* FIXME: should refuse to set register if insane rates ? */
+	/* Refuse to set register if insane rates, 25% = 250,000 PPM  */
+	if (rc < 250000)
+		return rc;
 
 	/* Enable shaping */
 	dqx_cir.s.enable = 1;
@@ -1106,11 +1173,11 @@ int cvmx_pko3_dq_cir_set(unsigned node, unsigned dq_num,
  * @param node The OCI node where the target port is located
  * @param dq_num The descriptor queue number for this setting
  * @param rate_kbips The desired throughput in kilo-bits-per-second
- * @param burst_size The size of a burst in bytes above 'rate_kbips' allowed
+ * @param burst_size The size of a burst in bytes, at least MTU
  *
  * @return Returns zero if both settings applied within allowed tolerance,
  * otherwise the error is returned in parts-per-million.
- * 'rate_bps" error is e negative number, otherwise 'birst_rate' error
+ * 'rate_bps" error is a negative number, otherwise 'birst_rate' error
  * is returned as a positive integer.
  */
 int cvmx_pko3_dq_pir_set(unsigned node, unsigned dq_num,
@@ -1146,7 +1213,9 @@ int cvmx_pko3_dq_pir_set(unsigned node, unsigned dq_num,
 	rc = cvmx_pko3_shaper_rate_compute(tclk, &sqx_cir,
 		rate_kbips, burst_bytes);
 
-	/* FIXME: should refuse to set register if insane rates ? */
+	/* Refuse to set register if insane rates, 25% = 250,000 PPM  */
+	if (rc < 250000)
+		return rc;
 
 	/* Enable shaping */
 	dqx_pir.s.enable = 1;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index 44a941d..f80a196 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -386,18 +386,17 @@ int cvmx_pko3_dq_close(int node, int dq)
 
 	dqstatus = pko_status.s.dqstatus;
 
-#if 0
 	if (dqstatus == PKO_DQSTATUS_NOTCREATED)
 		return 0;
-#endif
+
 	if (dqstatus != PKO_DQSTATUS_PASS) {
-		cvmx_dprintf("%s: WARNING: Failed to close dq :%u: %s\n",	//XXX temp warn
+		cvmx_dprintf("WARNING: %s: Failed to close dq :%u: %s\n",
 				__FUNCTION__, dq,
 				pko_dqstatus_error(dqstatus));
-		cvmx_dprintf("%s: DEBUG: dq %u depth %u\n",
+		cvmx_dprintf("DEBUG: %s: dq %u depth %u\n",
 			__FUNCTION__, dq, (unsigned) pko_status.s.depth);
-//		return -1; XXX- temporarily errors ignored XXX
 	}
+
 	return 0;
 }
 
@@ -1150,8 +1149,8 @@ static int cvmx_pko3_pdesc_subdc_add(cvmx_pko3_pdesc_t *pdesc,
 		return pdesc->num_words;
 	}
 
-        /* SEND_JUMP_S broken on Pass1 */
-        if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_0)) {
+        /* SEND_JUMP_S missing on Pass1 */
+        if(OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
                 cvmx_dprintf("%s: ERROR: too many segments\n",__func__);
                 return -E2BIG;
         }
diff --git a/arch/mips/cavium-octeon/executive/octeon-model.c b/arch/mips/cavium-octeon/executive/octeon-model.c
index 53f6cde..2a644cc 100644
--- a/arch/mips/cavium-octeon/executive/octeon-model.c
+++ b/arch/mips/cavium-octeon/executive/octeon-model.c
@@ -43,7 +43,7 @@
  * File defining functions for working with different Octeon
  * models.
  *
- * <hr>$Revision: 99496 $<hr>
+ * <hr>$Revision: 100627 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/octeon.h>
@@ -247,10 +247,6 @@ const char *octeon_model_get_string_buffer(uint32_t chip_id, char *buffer)
 		break;
 	}
 
-#ifndef CVMX_BUILD_FOR_UBOOT
-	clock_mhz = cvmx_clock_get_rate(CVMX_CLOCK_RCLK) / 1000000;
-#endif
-
 	/* Now figure out the family, the first two digits */
 	switch ((chip_id >> 8) & 0xff) {
 	case 0:		/* CN38XX, CN37XX or CN36XX */
@@ -449,27 +445,16 @@ const char *octeon_model_get_string_buffer(uint32_t chip_id, char *buffer)
 			suffix = "AAP";
 		break;
 	case 0x96:		/* CN70XX */
-		switch(num_cores) {
-		case 1:
-			family = "CN7010";
-			break;
-		case 2:
-			family = "CN7020/CN7120";
-			break;
-		case 3:
-			family = "CN7125";
-			break;
-		case 4:
-		default:
-			family = "CN7130";
-			break;
-		}
-#ifdef CVMX_BUILD_FOR_UBOOT
-		sprintf(buffer, "%s pass %s", family, pass);
-#else
-		sprintf(buffer, "%sp%s%d", family, pass, clock_mhz);
-#endif
-		return buffer;
+		family = "70";
+		if (cvmx_read_csr(CVMX_MIO_FUS_PDF) & (0x1ULL << 32))
+			family = "71";
+		if (fus_dat2.cn70xx.nocrypto)
+			suffix = "CP";
+		else if (fus_dat3.cn70xx.nodfa_dte)
+			suffix = "SCP";
+		else
+			suffix = "AAP";
+		break;
 	default:
 		family = "XX";
 		core_model = "XX";
@@ -478,6 +463,10 @@ const char *octeon_model_get_string_buffer(uint32_t chip_id, char *buffer)
 		break;
 	}
 
+#ifndef CVMX_BUILD_FOR_UBOOT
+	clock_mhz = cvmx_clock_get_rate(CVMX_CLOCK_RCLK) / 1000000;
+#endif
+
 	if (family[0] != '3') {
 		if (OCTEON_IS_OCTEON1PLUS() || OCTEON_IS_OCTEON2()) {
 			int fuse_base = 384 / 8;
diff --git a/arch/mips/include/asm/octeon/cvmx-ase-defs.h b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
index 9468afc..a897234 100644
--- a/arch/mips/include/asm/octeon/cvmx-ase-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
@@ -617,13 +617,15 @@ typedef union cvmx_ase_config cvmx_ase_config_t;
  * cvmx_ase_ecc_ctl
  *
  * This register can be used to disable ECC checks, insert ECC errors.
+ *
  * Fields *ECC_DIS disable SBE detection/correction and DBE detection. If ECC_DIS is 0x1, then no
  * errors are detected.
+ *
  * Fields *ECC_FLIP_SYND flip the syndrome<1:0> bits to generate 1-bit/2-bits error for testing.
- * 0x0 = normal operation
- * 0x1 = SBE on bit<0>
- * 0x2 = SBE on bit<1>
- * 0x3 = DBE on bit<1:0>
+ * _ 0x0 = normal operation.
+ * _ 0x1 = SBE on bit<0>.
+ * _ 0x2 = SBE on bit<1>.
+ * _ 0x3 = DBE on bit<1:0>.
  */
 union cvmx_ase_ecc_ctl {
 	uint64_t u64;
@@ -697,6 +699,7 @@ typedef union cvmx_ase_ecc_ctl cvmx_ase_ecc_ctl_t;
  * LUE_KDT_*, any request that generates an error has its response marked as errored. The
  * LUE_KDT_DBE error is not indicated in the response packet; the only indication of this error
  * is the interrupt mechanism.
+ *
  * For all the LUE* errors below, additional information can be obtained by reading the
  * ASE_LUE_ERROR_LOG. For all the LIP* /LOP* errors below, additional information can be obtained
  * by reading ASE_LUF_ERROR_LOG.
@@ -777,6 +780,7 @@ typedef union cvmx_ase_ecc_int cvmx_ase_ecc_int_t;
  *
  * This register contains the interrupt status for general ASE interrupts. Errors reported in bit
  * positions <39:32>, <7:2>, and <0> are most likely due to software programming errors.
+ *
  * In all LUE* cases below, any request that generates an error has its response marked as
  * errored. These LUE* interrupts are for diagnostic use, not for error handling. For all the
  * LUE* errors below, additional information can be obtained by reading ASE_LUE_ERROR_LOG.
@@ -908,10 +912,10 @@ union cvmx_ase_lop_config {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
 	uint64_t rsp_pri                      : 4;  /**< Response output priority as follows:
-                                                         <7> LUE key response
-                                                         <6> LUF table response
-                                                         <5> LUE table response
-                                                         <4> OSM write/read response
+                                                         <7> = LUE key response.
+                                                         <6> = LUF table response.
+                                                         <5> = LUE table response.
+                                                         <4> = OSM write/read response.
                                                          There are two priority levels per response type: 1 = higher priority;
                                                          0 = lower priority. Round robin is used among the responses with higher priority to send
                                                          back to the LAP or CSR. When there is no response with higher priority left, round robin
@@ -1004,9 +1008,9 @@ typedef union cvmx_ase_lue_config cvmx_ase_lue_config_t;
  * cvmx_ase_lue_dbg_ctl0
  *
  * We are not rewiring the NSP's 16-bit debug bus. Instead we are duplicating that mux 4 times to
- * give OCTEON better observability.
+ * give CNXXXX better observability.
  * LUE DBGCTX is a DOR daisy-chained through the TWE and BWE engines, it can't be moved to a
- * straight OCTEON-style debug bus without rewriting the whole thing.
+ * straight CNXXXX debug bus without rewriting the whole thing.
  * This register selects engines for debug observations for the LUE's four 16-bit debug muxes and
  * selects context for observation.
  */
@@ -1025,9 +1029,9 @@ union cvmx_ase_lue_dbg_ctl0 {
 	uint64_t reserved_20_31               : 12;
 	uint64_t ctx_col_dbg                  : 4;  /**< Context column debug. 32-bit column of context information to display in the ASE_LUE_CTX
                                                          debug field.
-                                                         TWE: Valid column values 0-12.
-                                                         BWE: Valid column values 0-2.
-                                                         RWE: Valid column values 0-8. */
+                                                         _ TWE: Valid column values 0-12.
+                                                         _ BWE: Valid column values 0-2.
+                                                         _ RWE: Valid column values 0-8. */
 	uint64_t reserved_13_15               : 3;
 	uint64_t ctx_eng_dbg                  : 5;  /**< Engine ID from which context information will be made available in the ASE_LUE_CTX debug
                                                          field. Must be 0 to 19. */
@@ -1064,7 +1068,7 @@ typedef union cvmx_ase_lue_dbg_ctl0 cvmx_ase_lue_dbg_ctl0_t;
  *
  * The per-engine filtering from NSP is not really worth moving to DTX-style addressing.
  * We are not rewiring the NSP's 16-bit debug bus. Instead we are duplicating that mux 4 times to
- * give OCTEON better observability.
+ * give CNXXXX better observability.
  * This register selects engines for debug observations for the LUE's four 16-bit debug muxes.
  */
 union cvmx_ase_lue_dbg_ctl1 {
@@ -1131,6 +1135,7 @@ typedef union cvmx_ase_lue_dbg_ctl1 cvmx_ase_lue_dbg_ctl1_t;
  * ASE_*_INT[LUE*]. The contents of this register are retained until all the bits in the
  * ASE_*_INT[LUE*] are cleared, or an error occurs that is of higher-priority than the error for
  * which information is currently logged by this CSR.
+ *
  * The priority of the error is encoded by the enumerated values in ASE_LUE_ERROR_ID_E. The
  * highest priority error is KDT_DBE, the lowest is RFT_SBE. For RFT errors, if multiple errors
  * of equal weight are reported during a clock cycle, the error on the local RFT is reported with
@@ -1150,16 +1155,16 @@ union cvmx_ase_lue_error_log {
 	uint64_t data                         : 48; /**< Error logging information. The information in this field takes on different meanings
                                                          depending on the type of error that is latched in the ASE_*_INT[LUE*] fields. Decode this
                                                          field based on ERROR_ID and HR_ERR_ID:
-                                                         TIC_MISS or TIC_MULTI_HIT, see ASE_LUE_ERROR_LOG_TIC_S.
-                                                         TIC_BAD_WRITE, see ASE_LUE_ERROR_LOG_TIC_BAD_WRITE_S.
-                                                         INVALID_TBL_ACC, see ASE_LUE_ERROR_LOG_INVTBLACC_S.
-                                                         INVALID_REQ, see ASE_LUE_ERROR_LOG_INVREQ_S.
-                                                         RME_FATAL, see ASE_LUE_ERROR_LOG_RME_FATAL_S.
-                                                         KDB_*BE, see ASE_LUE_ERROR_LOG_KDB_ECC_S.
-                                                         TAT_*BE, see ASE_LUE_ERROR_LOG_TAT_ECC_S.
-                                                         RFT_*BE: see ASE_LUE_ERROR_LOG_RFT_ECC_S.
-                                                         RUL_*BE, see ASE_LUE_ERROR_LOG_RUL_ECC_S.
-                                                         KDT_*BE, see ASE_LUE_ERROR_LOG_KDT_ECC_S. */
+                                                         _ TIC_MISS or TIC_MULTI_HIT, see ASE_LUE_ERROR_LOG_TIC_S.
+                                                         _ TIC_BAD_WRITE, see ASE_LUE_ERROR_LOG_TIC_BAD_WRITE_S.
+                                                         _ INVALID_TBL_ACC, see ASE_LUE_ERROR_LOG_INVTBLACC_S.
+                                                         _ INVALID_REQ, see ASE_LUE_ERROR_LOG_INVREQ_S.
+                                                         _ RME_FATAL, see ASE_LUE_ERROR_LOG_RME_FATAL_S.
+                                                         _ KDB_*BE, see ASE_LUE_ERROR_LOG_KDB_ECC_S.
+                                                         _ TAT_*BE, see ASE_LUE_ERROR_LOG_TAT_ECC_S.
+                                                         _ RFT_*BE: see ASE_LUE_ERROR_LOG_RFT_ECC_S.
+                                                         _ RUL_*BE, see ASE_LUE_ERROR_LOG_RUL_ECC_S.
+                                                         _ KDT_*BE, see ASE_LUE_ERROR_LOG_KDT_ECC_S. */
 #else
 	uint64_t data                         : 48;
 	uint64_t hr_err_id                    : 6;
@@ -1298,7 +1303,7 @@ union cvmx_ase_lue_performance_controlx {
 	uint64_t reserved_32_63               : 32;
 	uint64_t frozen                       : 1;  /**< Indicates that the counter is frozen (i.e one shot event occurred) and remains frozen
                                                          until the clear bit written. */
-	uint64_t clear                        : 1;  /**< Writing 1 to this bit generates a hardware pulse that clears the LUE_PERFOMANCE_COUNTER
+	uint64_t clear                        : 1;  /**< Writing 1 to this bit generates a hardware pulse that clears the LUE_PERFORMANCE_COUNTER
                                                          and field FROZEN of this register. */
 	uint64_t enable                       : 1;  /**< Enable the counter. This bit is set to 1 to use the corresponding counter. */
 	uint64_t reserved_27_28               : 2;
@@ -1346,7 +1351,7 @@ union cvmx_ase_lue_performance_control0 {
 	uint64_t reserved_32_63               : 32;
 	uint64_t frozen                       : 1;  /**< Indicates that the counter is frozen (i.e one shot event occurred) and remains frozen
                                                          until the clear bit written. */
-	uint64_t clear                        : 1;  /**< Writing 1 to this bit generates a hardware pulse that clears the LUE_PERFOMANCE_COUNTER
+	uint64_t clear                        : 1;  /**< Writing 1 to this bit generates a hardware pulse that clears the LUE_PERFORMANCE_COUNTER
                                                          and field FROZEN of this register. */
 	uint64_t enable                       : 1;  /**< Enable the counter. This bit is set to 1 to use the corresponding counter. */
 	uint64_t global_stop                  : 1;  /**< Writing a 1 to this bit stops all the counters in the group of eight counters. This bit is
@@ -1397,7 +1402,7 @@ union cvmx_ase_lue_performance_control1 {
 	uint64_t reserved_32_63               : 32;
 	uint64_t frozen                       : 1;  /**< Indicates that the counter is frozen (i.e one shot event occurred) and remains frozen
                                                          until the clear bit written. */
-	uint64_t clear                        : 1;  /**< Writing 1 to this bit generates a hardware pulse that clears the LUE_PERFOMANCE_COUNTER
+	uint64_t clear                        : 1;  /**< Writing 1 to this bit generates a hardware pulse that clears the LUE_PERFORMANCE_COUNTER
                                                          and field FROZEN of this register. */
 	uint64_t enable                       : 1;  /**< Enable the counter. This bit is set to 1 to use the corresponding counter. */
 	uint64_t global_enable                : 1;  /**< Writing a 1 to this bit starts all the counters in the group of eight counters. This bit
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index 81c56ab..2f6377d 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -1953,18 +1953,19 @@ union cvmx_bgxx_cmrx_config {
                                                          When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                          transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                          LMAC are not reset when this bit is clear, allowing software to program them before
-                                                         setting this bit to enable the LMAC. This bit together with the LMAC_TYPE is also used to
+                                                         setting this bit to enable the LMAC. This bit together with LMAC_TYPE is also used to
                                                          enable the clocking to the GMP and/or blocks of the Super path (SMU and SPU). CMR clocking
                                                          is enabled when any of the paths are enabled. */
-	uint64_t data_pkt_rx_en               : 1;  /**< Data packet receive enable. When ENABLE=1 and DATA_PKT_RX_EN=1, the reception of data
-                                                         packets is enabled in the MAC layer. When ENABLE=1 and DATA_PKT_RX_EN=0, the MAC layer
-                                                         drops received data and flow control packets. */
-	uint64_t data_pkt_tx_en               : 1;  /**< Data packet transmit enable. When ENABLE=1 and DATA_PKT_TX_EN=1, the transmission of data
-                                                         packets is enabled in the MAC layer. When ENABLE=1 and DATA_PKT_TX_EN=0, the MAC layer
+	uint64_t data_pkt_rx_en               : 1;  /**< Data packet receive enable. When ENABLE = 1 and DATA_PKT_RX_EN = 1, the reception of data
+                                                         packets is enabled in the MAC layer. When ENABLE = 1 and DATA_PKT_RX_EN = 0, the MAC layer
+                                                         drops received data and flow-control packets. */
+	uint64_t data_pkt_tx_en               : 1;  /**< Data packet transmit enable. When ENABLE = 1 and DATA_PKT_TX_EN = 1, the transmission of
+                                                         data
+                                                         packets is enabled in the MAC layer. When ENABLE = 1 and DATA_PKT_TX_EN = 0, the MAC layer
                                                          suppresses the transmission of new data and packets for the LMAC. */
 	uint64_t int_beat_gen                 : 1;  /**< Internal beat generation. This bit is used for debug/test purposes and should be clear
                                                          during normal operation. When set, the LMAC's PCS layer ignores RXVALID and
-                                                         TXREADY/TXCREDIT from the associated SerDes lane(s), internally generates fake (idle)
+                                                         TXREADY/TXCREDIT from the associated SerDes lanes, internally generates fake (idle)
                                                          RXVALID and TXCREDIT pulses, and suppresses transmission to the SerDes. */
 	uint64_t mix_en                       : 1;  /**< Management enable. This bit is used by LMACs 0 and 1 only, and should be kept clear for
                                                          LMACs 2 and 3. Setting it will pipe the LMAC to and from the MIX interface (LMAC0 to/from
@@ -1989,7 +1990,7 @@ union cvmx_bgxx_cmrx_config {
                                                          each type. Each valid PCS lane is mapped to a physical SerDes lane
                                                          based on the programming of [LANE_TO_SDS].
                                                          This field must be programmed to its final value before [ENABLE] is set, and must not
-                                                         be changed when [ENABLE]=1. */
+                                                         be changed when [ENABLE] = 1. */
 	uint64_t lane_to_sds                  : 8;  /**< PCS lane-to-SerDes Mapping.
                                                          This is an array of 2-bit values that map each logical PCS Lane to a
                                                          physical SerDes lane, as follows:
@@ -2014,7 +2015,7 @@ union cvmx_bgxx_cmrx_config {
                                                          detected RX PCS lane number is recorded in the corresponding
                                                          BGX()_SPU()_BR_LANE_MAP[LNx_MAPPING].
                                                          This field must be programmed to its final value before [ENABLE] is set, and must not
-                                                         be changed when [ENABLE]=1. */
+                                                         be changed when [ENABLE] = 1. */
 #else
 	uint64_t lane_to_sds                  : 8;
 	uint64_t lmac_type                    : 3;
@@ -2783,7 +2784,7 @@ union cvmx_bgxx_cmrx_tx_stat14 {
 	struct cvmx_bgxx_cmrx_tx_stat14_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t bcst                         : 48; /**< Number of packets sent to multicast DMAC. Does not include MCST packets.
+	uint64_t bcst                         : 48; /**< Number of packets sent to broadcast DMAC. Does not include MCST packets.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap.
                                                          Note that BGX determines if the packet is MCST or BCST from the DMAC of the packet. BGX
                                                          assumes that the DMAC lies in the first six bytes of the packet as per the 802.3 frame
@@ -3347,9 +3348,10 @@ union cvmx_bgxx_cmr_rx_adrx_cam {
 	uint64_t en                           : 1;  /**< CAM entry enable for this DMAC address.
                                                          1 = Include this address in the matching algorithm.
                                                          0 = Don't include this address in the matching algorithm. */
-	uint64_t adr                          : 48; /**< DMAC address in the CAM used for matching. The CAM matches against unicast or multicast
-                                                         DMAC addresses. All BGX()_CMR_RX_ADR()_CAM CSRs can be used in any of the
-                                                         LMAC_TYPE combinations such that any BGX MAC can use any of the 32 common DMAC entries. */
+	uint64_t adr                          : 48; /**< DMAC address in the CAM used for matching. Specified in network byte order, i.e.
+                                                         ADR[47:40] is for the first DMAC byte on the wire. The CAM matches against unicast or
+                                                         multicast DMAC addresses. All BGX()_CMR_RX_ADR()_CAM CSRs can be used in any of the LMAC
+                                                         combinations such that any BGX MAC can use any of the 32 common DMAC entries. */
 #else
 	uint64_t adr                          : 48;
 	uint64_t en                           : 1;
@@ -3638,7 +3640,7 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_ctl {
 	uint64_t pre_free                     : 1;  /**< When set, PREAMBLE checking is less strict. GMI will begin the frame at the first SFD.
                                                          PRE_CHK must be set to enable this and all PREAMBLE features. SGMII/1000Base-X only. */
 	uint64_t ctl_smac                     : 1;  /**< Control PAUSE frames can match station SMAC. */
-	uint64_t ctl_mcst                     : 1;  /**< Control PAUSE frames can match globally assign multicast address. */
+	uint64_t ctl_mcst                     : 1;  /**< Control PAUSE frames can match globally assigned multicast address. */
 	uint64_t ctl_bck                      : 1;  /**< Forward PAUSE information to TX block. */
 	uint64_t ctl_drp                      : 1;  /**< Drop control-PAUSE frames. */
 	uint64_t pre_strp                     : 1;  /**< Strip off the preamble (when present).
@@ -5253,7 +5255,7 @@ union cvmx_bgxx_smux_rx_frm_ctl {
                                                          * PKI_TAG_INC()_MASK should be adjusted. */
 	uint64_t reserved_6_11                : 6;
 	uint64_t ctl_smac                     : 1;  /**< Control PAUSE frames can match station SMAC. */
-	uint64_t ctl_mcst                     : 1;  /**< Control PAUSE frames can match globally assign multicast address. */
+	uint64_t ctl_mcst                     : 1;  /**< Control PAUSE frames can match globally assigned multicast address. */
 	uint64_t ctl_bck                      : 1;  /**< Forward PAUSE information to TX block. */
 	uint64_t ctl_drp                      : 1;  /**< Drop control PAUSE frames. */
 	uint64_t pre_strp                     : 1;  /**< Strip off the preamble (when present).
@@ -5784,10 +5786,11 @@ union cvmx_bgxx_smux_tx_thresh {
                                                          interface. This field should be large enough to prevent underflow on the packet interface
                                                          and must never be set to 0x0.
                                                          In 10G/40G mode, CNT = 0x100.
-                                                         In all modes, this register cannot exceed the TX FIFO depth as follows.
+                                                         In all modes, cannot exceed the TX FIFO depth as follows.
                                                          _ BGX()_CMR_TX_PRTS = 0,1:  CNT maximum = 0x7FF.
                                                          _ BGX()_CMR_TX_PRTS = 2:    CNT maximum = 0x3FF.
-                                                         _ BGX()_CMR_TX_PRTS = 3,4:  CNT maximum = 0x1FF. */
+                                                         _ BGX()_CMR_TX_PRTS = 3,4:  CNT maximum = 0x1FF.
+                                                         Additionally, cannot exceed corresponding PKO_MCI1_MAX_CRED(0..27)[MAX_CRED_LIM] - 9. */
 #else
 	uint64_t cnt                          : 11;
 	uint64_t reserved_11_63               : 53;
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
index de896a6c..c9c21eb 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
@@ -196,17 +196,6 @@ static inline uint64_t CVMX_CIU3_INTR_SLOWDOWN_FUNC(void)
 #define CVMX_CIU3_INTR_SLOWDOWN (CVMX_ADD_IO_SEG(0x0001010000000240ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_CIU3_ISCMEM_BASE CVMX_CIU3_ISCMEM_BASE_FUNC()
-static inline uint64_t CVMX_CIU3_ISCMEM_BASE_FUNC(void)
-{
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_CIU3_ISCMEM_BASE not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00010100000002C0ull);
-}
-#else
-#define CVMX_CIU3_ISCMEM_BASE (CVMX_ADD_IO_SEG(0x00010100000002C0ull))
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_CIU3_ISCX_CTL(unsigned long offset)
 {
 	if (!(
@@ -280,12 +269,10 @@ union cvmx_ciu3_bist {
 	uint64_t u64;
 	struct cvmx_ciu3_bist_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_11_63               : 53;
-	uint64_t bist                         : 11; /**< BIST results. Hardware sets a bit for each memory that fails BIST. INTERNAL:
-                                                         <10>= ncbo_crd_fif_mem0.
-                                                         <9> = ciu_nbt_sso_req_ram.
-                                                         <8> = ciu_nbt_rsp_ram.
-                                                         <7> = ciu_sso_output_fifo_mem.
+	uint64_t reserved_9_63                : 55;
+	uint64_t bist                         : 9;  /**< BIST results. Hardware sets a bit for each memory that fails BIST. INTERNAL:
+                                                         <8>= ncbo_crd_fif_mem0.
+                                                         <7> = ciu_nbt_rsp_ram.
                                                          <6> = ciu_isc_ram2.
                                                          <5> = ciu_isc_ram1.
                                                          <4> = ciu_isc_ram0.
@@ -294,8 +281,8 @@ union cvmx_ciu3_bist {
                                                          <1> = csr req_mem.
                                                          <0> = ciu3_wdg_ctl_mem. */
 #else
-	uint64_t bist                         : 11;
-	uint64_t reserved_11_63               : 53;
+	uint64_t bist                         : 9;
+	uint64_t reserved_9_63                : 55;
 #endif
 	} s;
 	struct cvmx_ciu3_bist_s               cn78xx;
@@ -579,14 +566,12 @@ union cvmx_ciu3_intr_ready {
 	uint64_t reserved_46_63               : 18;
 	uint64_t index                        : 14; /**< Scanner index. If [READY] set, the current index, else the index the scanner stopped at.
                                                          For diagnostic use only. */
-	uint64_t sso_cnt                      : 16; /**< Reserved. INTERNAL: Deprecated. Number of SSO events waiting to be sent to SSO. */
-	uint64_t reserved_1_15                : 15;
+	uint64_t reserved_1_31                : 31;
 	uint64_t ready                        : 1;  /**< CIU is idle. If clear, CIU is performing a background scan searching for secondary
                                                          interrupts. Write one to force a new scan. For diagnostic use only. */
 #else
 	uint64_t ready                        : 1;
-	uint64_t reserved_1_15                : 15;
-	uint64_t sso_cnt                      : 16;
+	uint64_t reserved_1_31                : 31;
 	uint64_t index                        : 14;
 	uint64_t reserved_46_63               : 18;
 #endif
@@ -640,21 +625,14 @@ union cvmx_ciu3_iscx_ctl {
                                                          although some indices may have IMP set but not have any INTSN use.
                                                          0 = The IDT and EN fields for this index are RAZ, and do not have any corresponding
                                                          INTSN. */
-	uint64_t sso_pend                     : 1;  /**< Reserved. INTERNAL: Deprecated. Transaction needs to be sent to SSO. CIU internal state
-                                                         for diagnostic use. [SSO_PEND] will be cleared when the entry is transmitted to SSO, or by
-                                                         a software clear of [SSO], [RAW] or [EN]. */
-	uint64_t reserved_3_13                : 11;
-	uint64_t sso                          : 1;  /**< Reserved. This field may be read-only for some indexes.
-                                                         INTERNAL: Deprecated. Use SSO delivery. */
+	uint64_t reserved_2_14                : 13;
 	uint64_t en                           : 1;  /**< Enable interrupt delivery. */
 	uint64_t raw                          : 1;  /**< Interrupt pending before masking. Note read only, must use
                                                          CIU3_ISC()_W1C/CIU3_ISC()_W1S to toggle. */
 #else
 	uint64_t raw                          : 1;
 	uint64_t en                           : 1;
-	uint64_t sso                          : 1;
-	uint64_t reserved_3_13                : 11;
-	uint64_t sso_pend                     : 1;
+	uint64_t reserved_2_14                : 13;
 	uint64_t imp                          : 1;
 	uint64_t idt                          : 8;
 	uint64_t reserved_24_63               : 40;
@@ -671,15 +649,13 @@ union cvmx_ciu3_iscx_w1c {
 	uint64_t u64;
 	struct cvmx_ciu3_iscx_w1c_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_3_63                : 61;
-	uint64_t sso                          : 1;  /**< Reserved. INTERNAL: Deprecated. Use SSO work-queue-entry delivery. */
+	uint64_t reserved_2_63                : 62;
 	uint64_t en                           : 1;  /**< Clear enable interrupt delivery. See CIU3_ISC()_CTL[EN]. */
 	uint64_t raw                          : 1;  /**< Clear interrupt pending. See CIU3_ISC()_CTL[RAW]. */
 #else
 	uint64_t raw                          : 1;
 	uint64_t en                           : 1;
-	uint64_t sso                          : 1;
-	uint64_t reserved_3_63                : 61;
+	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
 	struct cvmx_ciu3_iscx_w1c_s           cn78xx;
@@ -693,15 +669,13 @@ union cvmx_ciu3_iscx_w1s {
 	uint64_t u64;
 	struct cvmx_ciu3_iscx_w1s_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_3_63                : 61;
-	uint64_t sso                          : 1;  /**< Reserved. INTERNAL: Deprecated. Use SSO work-queue-entry delivery. */
+	uint64_t reserved_2_63                : 62;
 	uint64_t en                           : 1;  /**< Set enable interrupt delivery. See CIU3_ISC()_CTL[EN]. */
 	uint64_t raw                          : 1;  /**< Set interrupt pending. See CIU3_ISC()_CTL[RAW]. */
 #else
 	uint64_t raw                          : 1;
 	uint64_t en                           : 1;
-	uint64_t sso                          : 1;
-	uint64_t reserved_3_63                : 61;
+	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
 	struct cvmx_ciu3_iscx_w1s_s           cn78xx;
@@ -709,31 +683,6 @@ union cvmx_ciu3_iscx_w1s {
 typedef union cvmx_ciu3_iscx_w1s cvmx_ciu3_iscx_w1s_t;
 
 /**
- * cvmx_ciu3_iscmem_base
- *
- * Deprecated.
- *
- */
-union cvmx_ciu3_iscmem_base {
-	uint64_t u64;
-	struct cvmx_ciu3_iscmem_base_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_42_63               : 22;
-	uint64_t addr                         : 38; /**< Base address of CIU_INTSN_E table. Note must be 16-byte aligned and is in root-physical
-                                                         address space. Endinaness is selected with CIU3_CTL[ISCMEM_LE]. */
-	uint64_t addrl4                       : 4;  /**< Lowest 4 bits of Base address of CIU_INTSN_E table, always zero as CIU_ISCMEM_S structure
-                                                         is 16-byte aligned. */
-#else
-	uint64_t addrl4                       : 4;
-	uint64_t addr                         : 38;
-	uint64_t reserved_42_63               : 22;
-#endif
-	} s;
-	struct cvmx_ciu3_iscmem_base_s        cn78xx;
-};
-typedef union cvmx_ciu3_iscmem_base cvmx_ciu3_iscmem_base_t;
-
-/**
  * cvmx_ciu3_nmi
  */
 union cvmx_ciu3_nmi {
diff --git a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
index 69c32aa..e03d950 100644
--- a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
@@ -883,8 +883,8 @@ union cvmx_dpi_dmax_ibuff_saddr {
 	uint64_t saddr                        : 35; /**< Starting address. The 128-byte aligned starting or chunk address. SADDR is address bit
                                                          <41:7> of the starting instructions address. When new chunks are fetched by the hardware,
                                                          SADDR is updated to reflect the address of the current chunk. A write to SADDR resets both
-                                                         the queue's doorbell (DPI_DMA(0..7)_COUNTS[DBELL) and its tail pointer
-                                                         (DPI_DMA(0..7)_NADDR[ADDR]). */
+                                                         the queue's doorbell (DPI_DMA()_COUNTS[DBELL) and its tail pointer
+                                                         (DPI_DMA()_NADDR[ADDR]). */
 	uint64_t reserved_0_6                 : 7;
 #else
 	uint64_t reserved_0_6                 : 7;
@@ -1122,7 +1122,8 @@ union cvmx_dpi_dma_control {
                                                          not be disabled while processing instructions.
                                                          When PKT_EN=1,  then DMA_ENB<5>=0.
                                                          When PKT_EN1=1, then DMA_ENB<4>=0. */
-	uint64_t reserved_34_47               : 14;
+	uint64_t reserved_35_47               : 13;
+	uint64_t ncb_tag                      : 1;  /**< Reserved. */
 	uint64_t b0_lend                      : 1;  /**< When set '1' and the DPI is in the mode to write
                                                          0 to L2C memory when a DMA is done, the address
                                                          to be written to will be treated as a Little
@@ -1152,7 +1153,8 @@ union cvmx_dpi_dma_control {
 	uint64_t o_add1                       : 1;
 	uint64_t reserved_20_32               : 13;
 	uint64_t b0_lend                      : 1;
-	uint64_t reserved_34_47               : 14;
+	uint64_t ncb_tag                      : 1;
+	uint64_t reserved_35_47               : 13;
 	uint64_t dma_enb                      : 6;
 	uint64_t reserved_54_55               : 2;
 	uint64_t pkt_en                       : 1;
@@ -1460,9 +1462,9 @@ union cvmx_dpi_dma_control {
                                                          generates the final write for the current instruction.
                                                          When COMMIT_MODE=0, DPI additionally waits for the final write to reach the interface
                                                          coherency point to declare the instructions complete.
-                                                         Please note: when COMMIT_MODE == 1, DPI may not follow the HRM ordering rules. DPI
-                                                         hardware performance may be better with COMMIT_MODE == 1 than with COMMIT_MODE == 0 due to
-                                                         the relaxed ordering rules. If the HRM ordering rules are required, set COMMIT_MODE == 0. */
+                                                         When COMMIT_MODE=1, DPI may not follow the HRM ordering rules. DPI
+                                                         hardware performance may be better with COMMIT_MODE=1 than with COMMIT_MODE=0 due to
+                                                         the relaxed ordering rules. If the HRM ordering rules are required, set COMMIT_MODE=0. */
 	uint64_t reserved_57_57               : 1;
 	uint64_t pkt_en                       : 1;  /**< Enables the packet interface. When the packet interface is enabled, engines 4 and 5 are
                                                          used for packets and are not available for DMA. When PKT_EN=1, then DMA_ENB<5>=0 and
@@ -1471,7 +1473,8 @@ union cvmx_dpi_dma_control {
 	uint64_t dma_enb                      : 6;  /**< DMA engine enable. Enables the operation of the DMA engine. After being enabled an engine
                                                          should not be disabled while processing instructions.
                                                          When PKT_EN=1, then DMA_ENB<5>=0 and DMA_ENB<4>=0. */
-	uint64_t reserved_34_47               : 14;
+	uint64_t reserved_35_47               : 13;
+	uint64_t ncb_tag                      : 1;  /**< Reserved. */
 	uint64_t b0_lend                      : 1;  /**< Little-endian. When set to 1 and the DPI is in the mode to write 0 to L2C when a DMA
                                                          transaction is done, the address to be written is treated as a little-endian address. */
 	uint64_t ldwb                         : 1;  /**< Load don't write back. When set, the hardware is able to issue LDWB commands to the cache.
@@ -1481,15 +1484,15 @@ union cvmx_dpi_dma_control {
 	uint64_t aura_ichk                    : 12; /**< AURA instruction chunk. The AURA that the instruction chunk for DMA operations page will
                                                          be returned to when freed. */
 	uint64_t o_add1                       : 1;  /**< Add one.
-                                                         1 = add 1 to the SLI SLI_DMA*_CNT DMA counters
-                                                         0 = the number of bytes in the DMA transfer is added to SLI_DMA*_CNT. */
+                                                         0 = The number of bytes in the DMA transfer is added to SLI_DMA()_CNT.
+                                                         1 = Add 1 to the SLI_DMA()_CNT DMA counters. */
 	uint64_t o_ro                         : 1;  /**< Relaxed ordering mode for DMA transactions */
 	uint64_t o_ns                         : 1;  /**< No snoop. */
 	uint64_t o_es                         : 2;  /**< Endian swap mode for DMA.
-                                                         0 = pass-through mode (no swap)
-                                                         1 = 64-bit byte-swap mode [ABCD_EFGH] -> [HGFE_DCBA]
-                                                         2 = 32-bit byte-swap mode [ABCD_EFGH] -> [DCBA_HGFE]
-                                                         3 = 32-bit exchange mode [ABCD_EFGH] -> [EFGH_ABCD] */
+                                                         0 = pass-through mode (no swap).
+                                                         1 = 64-bit byte-swap mode [ABCD_EFGH] -> [HGFE_DCBA].
+                                                         2 = 32-bit byte-swap mode [ABCD_EFGH] -> [DCBA_HGFE].
+                                                         3 = 32-bit exchange mode [ABCD_EFGH] -> [EFGH_ABCD]. */
 	uint64_t o_mode                       : 1;  /**< Select PCI_POINTER mode.
                                                          0 = DPTR format 1 is used. Use register values for address; use pointer values for ES, NS,
                                                          RO.
@@ -1506,7 +1509,8 @@ union cvmx_dpi_dma_control {
 	uint64_t aura_ichk                    : 12;
 	uint64_t ldwb                         : 1;
 	uint64_t b0_lend                      : 1;
-	uint64_t reserved_34_47               : 14;
+	uint64_t ncb_tag                      : 1;
+	uint64_t reserved_35_47               : 13;
 	uint64_t dma_enb                      : 6;
 	uint64_t reserved_54_55               : 2;
 	uint64_t pkt_en                       : 1;
@@ -1598,7 +1602,7 @@ union cvmx_dpi_dma_pp_int {
 	struct cvmx_dpi_dma_pp_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t complete                     : 48; /**< DPI DMA per-core instruction completion interrupt. See DPI_DMA_PP(0..47)_CNT. */
+	uint64_t complete                     : 48; /**< DPI DMA per-core instruction completion interrupt. See DPI_DMA_PP()_CNT. */
 #else
 	uint64_t complete                     : 48;
 	uint64_t reserved_48_63               : 16;
@@ -1643,7 +1647,38 @@ typedef union cvmx_dpi_ecc_ctl cvmx_dpi_ecc_ctl_t;
  * cvmx_dpi_ecc_int
  *
  * This register contains ECC error interrupt summary bits.
- *
+ * INTERNAL:
+ * RAM[14] = dpi.pnl.pkt.sli_pkt_msix.msix_vfaddr
+ * RAM[13] = dpi.pnl.pkt.sli_pkt_msix.msix_vfdata
+ * RAM[12] = dpi.pnl.pkt.sli_pkt_csr.pcsr_in_done
+ * RAM[11] = dpi.pnl.pkt.sli_pkt_csr.pcsr_instr_mem
+ * RAM[10] = dpi.pnl.pkt.sli_pkt_csr.pcsr_pout_size
+ * RAM[ 9] = dpi.pnl.pkt.sli_pkt_csr.pcsr_slist
+ * RAM[ 8] = dpi.pnl.pkt.sli_pkt_csr.pout_int
+ * RAM[ 7] = dpi.pnl.pkt.sli_pkt_csr.pout_signal
+ * RAM[ 6] = dpi.pnl.pkt.sli_pkt_pof.sli_pkt_poi.poi_fifo
+ * RAM[ 5] = dpi.pnl.pkt.sli_pkt_pof.sli_pkt_psf.psf_fifo
+ * RAM[ 4] = dpi.pnl.pkt.sli_pkt_pof.sli_pkt_pdf.pdf_fifo
+ * RAM[ 3] = dpi.pnl.pkt.sli_pkt_pop.sli_pkt_pbn.pbn_fifo
+ * RAM[ 2] = dpi.pnl.pkt.sli_pkt_pop.sli_pkt_pfp.pfp_fifo
+ * RAM[ 1] = dpi.pnl.pkt.sli_pkt_pop.pop_fifos.pop_mem1
+ * RAM[ 1] = dpi.pnl.pkt.sli_pkt_pop.pop_fifos.pop_mem0
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk0a
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk0b
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk1a
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk1b
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk3a
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk3b
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk4a
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk4b
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk6a
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk6b
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk7a
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk7b
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk9a
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk9b
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk10a
+ * RAM[ 0] = dpi.dma.rdb.buff.bnk10b
  */
 union cvmx_dpi_ecc_int {
 	uint64_t u64;
@@ -1651,10 +1686,10 @@ union cvmx_dpi_ecc_int {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_47_63               : 17;
 	uint64_t ram_sbe                      : 15; /**< Set when a single-bit error is detected in the corresponding RAM. Throws
-                                                         DPI_INTSN_E::DPI_ERR_RAM_SBE. */
+                                                         DPI_INTSN_E::DPI_ERR_RAM_SBE(). */
 	uint64_t reserved_15_31               : 17;
 	uint64_t ram_dbe                      : 15; /**< Set when a double-bit error is detected in the corresponding RAM. Throws
-                                                         DPI_INTSN_E::DPI_ERR_RAM_DBE. */
+                                                         DPI_INTSN_E::DPI_ERR_RAM_DBE(). */
 #else
 	uint64_t ram_dbe                      : 15;
 	uint64_t reserved_15_31               : 17;
@@ -1677,6 +1712,33 @@ union cvmx_dpi_engx_buf {
 	uint64_t u64;
 	struct cvmx_dpi_engx_buf_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_38_63               : 26;
+	uint64_t compblks                     : 6;  /**< Computed engine block size */
+	uint64_t reserved_10_31               : 22;
+	uint64_t base                         : 6;  /**< The base address in 512B blocks of the engine fifo */
+	uint64_t blks                         : 4;  /**< The size of the engine fifo
+                                                         Legal values are 0-10.
+                                                         0  = Engine is disabled
+                                                         1  = 0.5KB buffer
+                                                         2  = 1.0KB buffer
+                                                         3  = 1.5KB buffer
+                                                         4  = 2.0KB buffer
+                                                         5  = 2.5KB buffer
+                                                         6  = 3.0KB buffer
+                                                         7  = 3.5KB buffer
+                                                         8  = 4.0KB buffer
+                                                         9  = 6.0KB buffer
+                                                         10 = 8.0KB buffer */
+#else
+	uint64_t blks                         : 4;
+	uint64_t base                         : 6;
+	uint64_t reserved_10_31               : 22;
+	uint64_t compblks                     : 6;
+	uint64_t reserved_38_63               : 26;
+#endif
+	} s;
+	struct cvmx_dpi_engx_buf_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_37_63               : 27;
 	uint64_t compblks                     : 5;  /**< Computed engine block size */
 	uint64_t reserved_9_31                : 23;
@@ -1701,8 +1763,7 @@ union cvmx_dpi_engx_buf {
 	uint64_t compblks                     : 5;
 	uint64_t reserved_37_63               : 27;
 #endif
-	} s;
-	struct cvmx_dpi_engx_buf_s            cn61xx;
+	} cn61xx;
 	struct cvmx_dpi_engx_buf_cn63xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
@@ -1725,13 +1786,13 @@ union cvmx_dpi_engx_buf {
 #endif
 	} cn63xx;
 	struct cvmx_dpi_engx_buf_cn63xx       cn63xxp1;
-	struct cvmx_dpi_engx_buf_s            cn66xx;
-	struct cvmx_dpi_engx_buf_s            cn68xx;
-	struct cvmx_dpi_engx_buf_s            cn68xxp1;
-	struct cvmx_dpi_engx_buf_s            cn70xx;
-	struct cvmx_dpi_engx_buf_s            cn70xxp1;
+	struct cvmx_dpi_engx_buf_cn61xx       cn66xx;
+	struct cvmx_dpi_engx_buf_cn61xx       cn68xx;
+	struct cvmx_dpi_engx_buf_cn61xx       cn68xxp1;
+	struct cvmx_dpi_engx_buf_cn61xx       cn70xx;
+	struct cvmx_dpi_engx_buf_cn61xx       cn70xxp1;
 	struct cvmx_dpi_engx_buf_s            cn78xx;
-	struct cvmx_dpi_engx_buf_s            cnf71xx;
+	struct cvmx_dpi_engx_buf_cn61xx       cnf71xx;
 };
 typedef union cvmx_dpi_engx_buf cvmx_dpi_engx_buf_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
index 5011ff4..2f6086f 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
@@ -892,16 +892,30 @@ union cvmx_fpa_aurax_cnt_levels {
 	uint64_t reserved_40_63               : 24;
 	uint64_t bp_ena                       : 1;  /**< Enable backpressure based on [BP] level. If set FPA_GEN_CFG[LVL_DLY] must be nonzero.
                                                          PKI_AURA()_CFG[ENA_BP] must also be set for backpressure to propagate through PKI. */
-	uint64_t red_ena                      : 1;  /**< Enable RED based on [DROP] and [PASS] levels. If set FPA_GEN_CFG[LVL_DLY] must be nonzero.
-                                                         If set, RED is performed on core requests with FPA_ALLOC_LD_S[RED] set, and/or PKI
-                                                         requests if PKI_AURA()_CFG[ENA_RED] is set. */
-	uint64_t shift                        : 6;  /**< Right shift to apply to FPA_AURA()_CNT to result in a 8-bit relative depth to be
-                                                         used for [DROP/PASS/LEVEL]. */
-	uint64_t bp                           : 8;  /**< Backpressure will be applied if the immediate shifted level is equal to or greater than this value. */
-	uint64_t drop                         : 8;  /**< Packet will be dropped if the average shifted level is equal to or greater than this value. */
-	uint64_t pass                         : 8;  /**< Packet will be passed if the average shifted level is less than this value. */
-	uint64_t level                        : 8;  /**< Current shifted level, averaged with FPA_AURA()_CNT.
-                                                         CNT levels track usage; the lower the level the more free resources. */
+	uint64_t red_ena                      : 1;  /**< Enable aura RED based on [DROP] and [PASS] levels. If set FPA_GEN_CFG[LVL_DLY] must be
+                                                         nonzero.
+                                                         If set, aura RED is performed on core requests with
+                                                         FPA_ALLOC_LD_S/FPA_ALLOC_IOBDMA_S[RED] set, and also may be performed on the
+                                                         first PKI allocation request for a packet (depends on PKI style and aura
+                                                         configuration). */
+	uint64_t shift                        : 6;  /**< Right shift to FPA_AURA()_CNT[CNT] to create a narrower depth for aura QOS and
+                                                         backpressure calculations. PKI saturates the shifted FPA_AURA()_CNT[CNT] to
+                                                         8-bits, and compares this 8-bit shifted and saturated depth directly to
+                                                         [DROP/BP]. PKI also creates [LEVEL], which is a moving average of the 8-bit
+                                                         shifted and saturated depth of the aura, for comparison to [DROP/PASS] in RED
+                                                         calculations. */
+	uint64_t bp                           : 8;  /**< Backpressure can assert if the current 8-bit shifted and saturated FPA_AURA()_CNT[CNT] is
+                                                         equal to or greater than this value. */
+	uint64_t drop                         : 8;  /**< If [RED_ENA]==1 and RED processing is requested, the packet will be dropped if
+                                                         [LEVEL] is equal to or greater than this value.
+                                                         If DROP processing is requested, the packet will be dropped if the current 8-bit
+                                                         shifted and saturated FPA_AURA()_CNT[CNT] is equal to or greater than this
+                                                         value. */
+	uint64_t pass                         : 8;  /**< Aura RED processing will not drop an allocation request if [LEVEL] is less than this value. */
+	uint64_t level                        : 8;  /**< Current moving average of the 8-bit shifted and saturated FPA_AURA()_CNT[CNT].
+                                                         The lower [LEVEL] is, the more free resources. The highest [LEVEL]'s indicate buffer
+                                                         exhaustion.
+                                                         See [SHIFT]. */
 #else
 	uint64_t level                        : 8;
 	uint64_t pass                         : 8;
@@ -1007,15 +1021,38 @@ union cvmx_fpa_aurax_pool_levels {
 	struct cvmx_fpa_aurax_pool_levels_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_40_63               : 24;
-	uint64_t bp_ena                       : 1;  /**< Enable backpressure based on [BP] level. If set FPA_GEN_CFG[LVL_DLY] must be nonzero. */
-	uint64_t red_ena                      : 1;  /**< Enable RED based on [DROP] and [PASS] levels. If set FPA_GEN_CFG[LVL_DLY] must be nonzero. */
-	uint64_t shift                        : 6;  /**< Right shift to apply to FPA_POOL()_AVAILABLE to result in a 8-bit relative depth to
-                                                         be used for [DROP/PASS/LEVEL]. */
-	uint64_t bp                           : 8;  /**< Backpressure will be indicated if the immediate shifted level is equal to or less than this value. */
-	uint64_t drop                         : 8;  /**< Packet will be dropped if the average shifted level is equal to or less than this value. */
-	uint64_t pass                         : 8;  /**< Packet will be passed if the average shifted level is larger than this value. */
-	uint64_t level                        : 8;  /**< Current shifted level, averaged with FPA_POOL()_AVAILABLE[AVG_CON].
-                                                         FPA levels track availability; the higher the level the more free resources. */
+	uint64_t bp_ena                       : 1;  /**< Enable aura-unique pool backpressure based on [BP] level. If set FPA_GEN_CFG[LVL_DLY] must
+                                                         be nonzero. */
+	uint64_t red_ena                      : 1;  /**< Enable aura-unique pool RED based on [DROP] and [PASS] levels. If set FPA_GEN_CFG[LVL_DLY]
+                                                         must be nonzero.
+                                                         If set, aura-unique pool RED is performed on core requests with
+                                                         FPA_ALLOC_LD_S/FPA_ALLOC_IOBDMA_S[RED] set, and also may be performed on the first PKI
+                                                         allocation request for a packet (depending on PKI style and aura configuration). */
+	uint64_t shift                        : 6;  /**< Right shift to FPA_POOL()_AVAILABLE[COUNT] used to create a narrower depth for
+                                                         aura-unique pool QOS and backpressure calculations. PKI saturates the shifted
+                                                         FPA_POOL()_AVAILABLE[COUNT] to 8-bits for the aura, and compares this 8-bit
+                                                         shifted and saturated depth directly to [DROP/BP]. PKI also creates [LEVEL],
+                                                         which is a moving average of the 8-bit shifted and saturated depth for the aura,
+                                                         for comparison to [DROP/PASS] in aura-unique pool RED calculations.
+                                                         Though [SHIFT] may differ amongst the auras sharing a given pool, they may most
+                                                         commonly be the same (i.e. the 8-bit shifted and saturated depth and [LEVEL] may
+                                                         typically be the same for all auras sharing a pool), with the [DROP/PASS/BP]
+                                                         configuration providing aura-uniqueness in aura-unique pool RED/DROP/BP
+                                                         processing. */
+	uint64_t bp                           : 8;  /**< Backpressure can assert if the current 8-bit shifted and saturated
+                                                         FPA_POOL()_AVAILABLE[COUNT] for the aura is equal to or less than this value. */
+	uint64_t drop                         : 8;  /**< If [RED_ENA]==1 and RED processing is requested, the packet will be dropped if
+                                                         [LEVEL] is equal to or less than this value.
+                                                         If DROP processing is requested, the packet will be dropped if the current 8-bit
+                                                         shifted and saturated FPA_POOL()_AVAILABLE[COUNT] for the aura is equal to or
+                                                         less than this value. */
+	uint64_t pass                         : 8;  /**< Aura-unique pool RED processing will not drop an allocation request if [LEVEL] is larger
+                                                         than this value. */
+	uint64_t level                        : 8;  /**< Current moving average of the 8-bit shifted and saturated FPA_POOL()_AVAILABLE[COUNT] for
+                                                         the aura.
+                                                         The higher [LEVEL] is, the more free resources. The lowest [LEVEL]'s indicate buffer
+                                                         exhaustion.
+                                                         See [SHIFT]. */
 #else
 	uint64_t level                        : 8;
 	uint64_t pass                         : 8;
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index 7fce9ac..c70f97d 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -493,6 +493,17 @@ static inline uint64_t CVMX_GSERX_DLMX_TX_TERM_OFFSET(unsigned long offset, unsi
 #define CVMX_GSERX_DLMX_TX_TERM_OFFSET(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090003040ull) + (((offset) & 3) + ((block_id) & 0) * 0x0ull) * 524288)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_EQ_WAIT_TIME(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 13)))))
+		cvmx_warn("CVMX_GSERX_EQ_WAIT_TIME(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904E0000ull) + ((block_id) & 15) * 0x1000000ull;
+}
+#else
+#define CVMX_GSERX_EQ_WAIT_TIME(block_id) (CVMX_ADD_IO_SEG(0x00011800904E0000ull) + ((block_id) & 15) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_GLBL_TAD(unsigned long block_id)
 {
 	if (!(
@@ -1703,6 +1714,17 @@ static inline uint64_t CVMX_GSERX_SCRATCH(unsigned long block_id)
 #define CVMX_GSERX_SCRATCH(block_id) (CVMX_ADD_IO_SEG(0x0001180090000020ull) + ((block_id) & 15) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_SLICEX_RX_SDLL_CTRL(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_SLICEX_RX_SDLL_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090460220ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152;
+}
+#else
+#define CVMX_GSERX_SLICEX_RX_SDLL_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090460220ull) + (((offset) & 1) + ((block_id) & 15) * 0x8ull) * 2097152)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_SLICE_CFG(unsigned long block_id)
 {
 	if (!(
@@ -1756,12 +1778,12 @@ union cvmx_gserx_ana_atest {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t ana_dac_b                    : 7;  /**< Used to control the B-side DAC input to the analog test block. Note that the QLM4 register
-                                                         is tied to the analog test block, for non-OCI links. Note that the OCI4 register is tied
-                                                         to the analog test block, for OCI links. The other GSER()_ANA_ATEST registers are
+                                                         is tied to the analog test block, for non-CCPI links. Note that the CCPI4 register is tied
+                                                         to the analog test block, for CCPI links. The other GSER()_ANA_ATEST registers are
                                                          unused. For diagnostic use only. */
 	uint64_t ana_dac_a                    : 5;  /**< Used to control A-side DAC input to the analog test block. Note that the QLM4 register is
-                                                         tied to the analog test block, for non-OCI links. Note that the OCI4 register is tied to
-                                                         the analog test block, for OCI links. The other GSER()_ANA_ATEST registers are unused.
+                                                         tied to the analog test block, for non-CCPI links. Note that the CCPI4 register is tied to
+                                                         the analog test block, for CCPI links. The other GSER()_ANA_ATEST registers are unused.
                                                          For diagnostic use only. */
 #else
 	uint64_t ana_dac_a                    : 5;
@@ -1782,8 +1804,8 @@ union cvmx_gserx_ana_sel {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t ana_sel                      : 9;  /**< Used to control the adr_global input to the analog test block. Note that the QLM0 register
-                                                         is tied to the analog test block, for non-OCI links. Note that the QLM8 register is tied
-                                                         to the analog test block, for OCI links. The other GSER()_ANA_SEL registers are unused.
+                                                         is tied to the analog test block, for non-CCPI links. Note that the QLM8 register is tied
+                                                         to the analog test block, for CCPI links. The other GSER()_ANA_SEL registers are unused.
                                                          For diagnostic use only. */
 #else
 	uint64_t ana_sel                      : 9;
@@ -1924,19 +1946,19 @@ union cvmx_gserx_cfg {
 	struct cvmx_gserx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
-	uint64_t bgx_quad                     : 1;  /**< For non-OCI links, indicates the BGX is in quad aggregation mode when GSER()_CFG[BGX]
-                                                         is also set. A single controller is used for all four lanes. For OCI links, this bit has
+	uint64_t bgx_quad                     : 1;  /**< For non-CCPI links, indicates the BGX is in quad aggregation mode when GSER()_CFG[BGX]
+                                                         is also set. A single controller is used for all four lanes. For CCPI links, this bit has
                                                          no meaning. */
-	uint64_t bgx_dual                     : 1;  /**< For non-OCI links, indicates the BGX is in dual aggregation mode when GSER()_CFG[BGX]
+	uint64_t bgx_dual                     : 1;  /**< For non-CCPI links, indicates the BGX is in dual aggregation mode when GSER()_CFG[BGX]
                                                          is also set. A single controller is used for lanes 0 and 1 and another controller is used
-                                                         for lanes 2 and 3. For OCI links, this bit has no meaning. */
-	uint64_t bgx                          : 1;  /**< For non-OCI links, indicates the GSER is configured for BGX mode. Only one of the BGX,
-                                                         ILA, or PCIE modes can be set at any one time. For OCI links, this bit has no meaning. */
-	uint64_t ila                          : 1;  /**< For non-OCI links, indicates the GSER is configured for ILK/ILA mode. For OCI links this
+                                                         for lanes 2 and 3. For CCPI links, this bit has no meaning. */
+	uint64_t bgx                          : 1;  /**< For non-CCPI links, indicates the GSER is configured for BGX mode. Only one of the BGX,
+                                                         ILA, or PCIE modes can be set at any one time. For CCPI links, this bit has no meaning. */
+	uint64_t ila                          : 1;  /**< For non-CCPI links, indicates the GSER is configured for ILK/ILA mode. For CCPI links this
                                                          bit will be set. Only one of the BGX, ILA, or PCIE modes can be set at any one time. For
-                                                         OCI links, this bit has no meaning. */
-	uint64_t pcie                         : 1;  /**< For non-OCI links, indicates the GSER is configured for PCIE mode. Only one of the BGX,
-                                                         ILA, or PCIE modes can be set at any one time. For OCI links, this bit has no meaning. */
+                                                         CCPI links, this bit has no meaning. */
+	uint64_t pcie                         : 1;  /**< For non-CCPI links, indicates the GSER is configured for PCIE mode. Only one of the BGX,
+                                                         ILA, or PCIE modes can be set at any one time. For CCPI links, this bit has no meaning. */
 #else
 	uint64_t pcie                         : 1;
 	uint64_t ila                          : 1;
@@ -2827,6 +2849,32 @@ union cvmx_gserx_dlmx_tx_term_offset {
 typedef union cvmx_gserx_dlmx_tx_term_offset cvmx_gserx_dlmx_tx_term_offset_t;
 
 /**
+ * cvmx_gser#_eq_wait_time
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_eq_wait_time {
+	uint64_t u64;
+	struct cvmx_gserx_eq_wait_time_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t rxeq_wait_cnt                : 4;  /**< Determines the wait time after VMA RX-EQ completes and before sampling
+                                                         tap1 and starting the precorrelation check. */
+	uint64_t txeq_wait_cnt                : 4;  /**< Determines the wait time from applying the TX-EQ controls (swing/pre/post)
+                                                         to the sampling of the sds_pcs_tx_comp_out. */
+#else
+	uint64_t txeq_wait_cnt                : 4;
+	uint64_t rxeq_wait_cnt                : 4;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} s;
+	struct cvmx_gserx_eq_wait_time_s      cn78xx;
+};
+typedef union cvmx_gserx_eq_wait_time cvmx_gserx_eq_wait_time_t;
+
+/**
  * cvmx_gser#_glbl_tad
  *
  * These registers are for diagnostic use only.
@@ -3769,7 +3817,9 @@ union cvmx_gserx_lanex_rx_misc_ovrrd {
 	uint64_t u64;
 	struct cvmx_gserx_lanex_rx_misc_ovrrd_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_12_63               : 52;
+	uint64_t reserved_14_63               : 50;
+	uint64_t cfg_rx_oob_clk_en_ovrrd_val  : 1;  /**< Not supported. */
+	uint64_t cfg_rx_oob_clk_en_ovrrd_en   : 1;  /**< Not supported. */
 	uint64_t cfg_rx_eie_det_ovrrd_val     : 1;  /**< Override value for RX Electrical-Idle-Exit
                                                          Detect Enable. */
 	uint64_t cfg_rx_eie_det_ovrrd_en      : 1;  /**< Override enable for RX Electrical-Idle-Exit
@@ -3798,7 +3848,9 @@ union cvmx_gserx_lanex_rx_misc_ovrrd {
 	uint64_t cfg_rx_cdr_ctrl_ovvrd_en     : 1;
 	uint64_t cfg_rx_eie_det_ovrrd_en      : 1;
 	uint64_t cfg_rx_eie_det_ovrrd_val     : 1;
-	uint64_t reserved_12_63               : 52;
+	uint64_t cfg_rx_oob_clk_en_ovrrd_en   : 1;
+	uint64_t cfg_rx_oob_clk_en_ovrrd_val  : 1;
+	uint64_t reserved_14_63               : 50;
 #endif
 	} s;
 	struct cvmx_gserx_lanex_rx_misc_ovrrd_s cn78xx;
@@ -4260,7 +4312,7 @@ union cvmx_gserx_lane_lpbken {
 	struct cvmx_gserx_lane_lpbken_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t lpbken                       : 4;  /**< For links that are not in PCIE mode (including all OCI links). When asserted in P0 state,
+	uint64_t lpbken                       : 4;  /**< For links that are not in PCIE mode (including all CCPI links). When asserted in P0 state,
                                                          allows per lane TX-to-RX serial loopback activation.
                                                          <3>: Lane 3.
                                                          <2>: Lane 2.
@@ -4286,7 +4338,7 @@ union cvmx_gserx_lane_mode {
 	struct cvmx_gserx_lane_mode_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t lmode                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), used to index into the PHY
+	uint64_t lmode                        : 4;  /**< For links that are not in PCIE mode (including all CCPI links), used to index into the PHY
                                                          table to select electrical specs and link rate. Note that the PHY table can be modified
                                                          such that any supported link rate can be derived regardless of the configured LMODE.
                                                          0x0: R_25G_REFCLK100.
@@ -4306,8 +4358,9 @@ union cvmx_gserx_lane_mode {
                                                          0xA: R_5G_REFCLK125.
                                                          0xB: R_8G_REFCLK125.
                                                          0xC - 0xF: Reserved.
-                                                         This register is not used for PCIE configurations. For non-OCI links, this register
-                                                         defaults to R_625G_REFCLK15625_RXAUI. For OCI links, the value is mapped at reset from the
+                                                         This register is not used for PCIE configurations. For non-CCPI links, this register
+                                                         defaults to R_625G_REFCLK15625_RXAUI. For CCPI links, the value is mapped at reset from
+                                                         the
                                                          GSER()_SPD and the appropriate table updates are performed so the rate is obtained for the
                                                          particular reference clock.
                                                          It is recommended that the PHY be in reset when reconfiguring the LMODE
@@ -4522,7 +4575,7 @@ union cvmx_gserx_lane_poff {
 	struct cvmx_gserx_lane_poff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t lpoff                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), allows for per lane power
+	uint64_t lpoff                        : 4;  /**< For links that are not in PCIE mode (including all CCPI links), allows for per lane power
                                                          down.
                                                          <3>: Lane 3.
                                                          <2>: Lane 2.
@@ -4548,7 +4601,7 @@ union cvmx_gserx_lane_srst {
 	struct cvmx_gserx_lane_srst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t lsrst                        : 1;  /**< For links that are not in PCIE mode (including all OCI links), resets all 4 lanes
+	uint64_t lsrst                        : 1;  /**< For links that are not in PCIE mode (including all CCPI links), resets all 4 lanes
                                                          (equivalent to the P2 power state) after any pending requests (power state change, rate
                                                          change) are complete. The lanes remain in reset state while this signal is asserted. When
                                                          the signal deasserts, the lanes exit the reset state and the PHY returns to the power
@@ -5872,9 +5925,9 @@ union cvmx_gserx_phy_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t phy_reset                    : 1;  /**< When asserted, the PHY is held in reset. This bit is initialized as follows:
-                                                         0 = (not reset) = Bootable PCIe, or OCI when GSER(8..13)_SPD[SPD] comes up in a bootable
+                                                         0 = (not reset) = Bootable PCIe, or CCPI when GSER(8..13)_SPD[SPD] comes up in a bootable
                                                          mode.
-                                                         1 = (reset) =  Non-bootable PCIe, BGX/ILK, or OCI when GSER(8..13)_SPD[SPD] comes up in
+                                                         1 = (reset) =  Non-bootable PCIe, BGX/ILK, or CCPI when GSER(8..13)_SPD[SPD] comes up in
                                                          SW_MODE. */
 	uint64_t phy_pd                       : 1;  /**< When asserted, the PHY is powered down. */
 #else
@@ -6123,7 +6176,7 @@ union cvmx_gserx_refclk_sel {
                                                          reference clock. It is not used for non-PCIe links. */
 	uint64_t com_clk_sel                  : 1;  /**< When set, the reference clock is sourced from the external clock mux. For bootable PCIe
                                                          links, this bit is loaded with the PCIEn_COM0_CLK_EN pin at cold reset. */
-	uint64_t use_com1                     : 1;  /**< For non-OCI links, this bit controls the external mux select. When set, QLMC_REF_CLK1_N/P
+	uint64_t use_com1                     : 1;  /**< For non-CCPI links, this bit controls the external mux select. When set, QLMC_REF_CLK1_N/P
                                                          are selected as the reference clock. When clear, QLMC_REF_CLK0_N/P are selected as the
                                                          reference clock. */
 #else
@@ -6148,7 +6201,7 @@ union cvmx_gserx_rx_coast {
 	struct cvmx_gserx_rx_coast_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t coast                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), control signals to freeze
+	uint64_t coast                        : 4;  /**< For links that are not in PCIE mode (including all CCPI links), control signals to freeze
                                                          the frequency of the per lane CDR in the PHY. The COAST signals are only valid in P0
                                                          state, come up asserted and are deasserted in hardware after detecting the electrical idle
                                                          exit (GSER()_RX_EIE_DETSTS[EIESTS]). Once the COAST signal deasserts, the CDR is
@@ -6178,7 +6231,7 @@ union cvmx_gserx_rx_eie_deten {
 	struct cvmx_gserx_rx_eie_deten_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t eiede                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), these bits enable per lane
+	uint64_t eiede                        : 4;  /**< For links that are not in PCIE mode (including all CCPI links), these bits enable per lane
                                                          electrical idle exit (EIE) detection. When EIE is detected,
                                                          GSER()_RX_EIE_DETSTS[EIELTCH] is asserted. EIEDE defaults to the enabled state. Once
                                                          EIE has been detected, EIEDE must be disabled, and then enabled again to perform another
@@ -6288,7 +6341,7 @@ union cvmx_gserx_rx_polarity {
 	struct cvmx_gserx_rx_polarity_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t rx_inv                       : 4;  /**< For links that are not in PCIE mode (including all OCI links), control signal to invert
+	uint64_t rx_inv                       : 4;  /**< For links that are not in PCIE mode (including all CCPI links), control signal to invert
                                                          the polarity of received data. When asserted, the polarity of the received data is
                                                          inverted.
                                                          <3>: Lane 3.
@@ -6702,6 +6755,42 @@ union cvmx_gserx_scratch {
 typedef union cvmx_gserx_scratch cvmx_gserx_scratch_t;
 
 /**
+ * cvmx_gser#_slice#_rx_sdll_ctrl
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_slicex_rx_sdll_ctrl {
+	uint64_t u64;
+	struct cvmx_gserx_slicex_rx_sdll_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t pcs_sds_oob_clk_ctrl         : 2;  /**< Not Supported. */
+	uint64_t reserved_7_13                : 7;
+	uint64_t pcs_sds_rx_sdll_tune         : 3;  /**< Tuning bits for the regulator and the loop filter. */
+	uint64_t pcs_sds_rx_sdll_swsel        : 4;  /**< DMON control; selects which signal is passed to the output
+                                                         of DMON.
+                                                         0x1 = dllout[0] (first output clock phase, out of 8 phases,
+                                                         of the Slice DLL).
+                                                         0x2 = dllout[1] (second output clock phase, out of 8 phases,
+                                                         of the Slice DLL).
+                                                         0x4 = piclk (output clock of the PI)
+                                                         0x8 = vdda_int.
+                                                         All other values in this field are reserved. */
+#else
+	uint64_t pcs_sds_rx_sdll_swsel        : 4;
+	uint64_t pcs_sds_rx_sdll_tune         : 3;
+	uint64_t reserved_7_13                : 7;
+	uint64_t pcs_sds_oob_clk_ctrl         : 2;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_slicex_rx_sdll_ctrl_s cn78xx;
+};
+typedef union cvmx_gserx_slicex_rx_sdll_ctrl cvmx_gserx_slicex_rx_sdll_ctrl_t;
+
+/**
  * cvmx_gser#_slice_cfg
  *
  * These registers are for diagnostic use only.
@@ -6740,8 +6829,8 @@ union cvmx_gserx_spd {
 	struct cvmx_gserx_spd_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t spd                          : 4;  /**< For OCI links (i.e. GSER8..13), the hardware loads this CSR field from the OCI_SPD<3:0>
-                                                         pins during chip cold reset. For non-OCI links, this field is not used.
+	uint64_t spd                          : 4;  /**< For CCPI links (i.e. GSER8..13), the hardware loads this CSR field from the OCI_SPD<3:0>
+                                                         pins during chip cold reset. For non-CCPI links, this field is not used.
                                                          For SPD settings that configure a non-default reference clock, hardware updates the PLL
                                                          settings of the specific lane mode (LMODE) table entry to derive the correct link rate.
                                                          <pre>
@@ -6763,9 +6852,9 @@ union cvmx_gserx_spd {
                                                          0xE:  156.25 MHz  10.3125 Gb  R_103125G_REFCLK15625_KR
                                                          0xF:                          SW_MODE
                                                          </pre>
-                                                         Note that a value of 0xF is called SW_MODE. The OCI link does not come up configured in
+                                                         Note that a value of 0xF is called SW_MODE. The CCPI link does not come up configured in
                                                          SW_MODE.
-                                                         (Software must do all the OCI GSER configuration to use OCI in the case of SW_MODE.)
+                                                         (Software must do all the CCPI GSER configuration to use CCPI in the case of SW_MODE.)
                                                          When SPD!=SW_MODE after a chip cold reset, the hardware has initialized the following
                                                          registers (based on the OCI_SPD selection):
                                                           * GSER()_LANE_MODE[LMODE]=Z.
@@ -6819,7 +6908,7 @@ union cvmx_gserx_tx_vboost {
 	struct cvmx_gserx_tx_vboost_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t vboost                       : 4;  /**< For links that are not in PCIE mode (including all OCI links), boosts the TX Vswing from
+	uint64_t vboost                       : 4;  /**< For links that are not in PCIE mode (including all CCPI links), boosts the TX Vswing from
                                                          VDD to 1.0 VPPD.
                                                          <3>: Lane 3.
                                                          <2>: Lane 2.
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-board.h b/arch/mips/include/asm/octeon/cvmx-helper-board.h
index 02b105a..c32bbdf 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-board.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-board.h
@@ -43,7 +43,7 @@
  * Helper functions to abstract board specific data about
  * network ports from the rest of the cvmx-helper files.
  *
- * <hr>$Revision: 97779 $<hr>
+ * <hr>$Revision: 100490 $<hr>
  */
 #ifndef __CVMX_HELPER_BOARD_H__
 #define __CVMX_HELPER_BOARD_H__
@@ -61,13 +61,14 @@ typedef enum {
 	USB_CLOCK_TYPE_CRYSTAL_12,
 } cvmx_helper_board_usb_clock_types_t;
 
-typedef enum {
+typedef enum cvmx_phy_type {
 	BROADCOM_GENERIC_PHY,
 	MARVELL_GENERIC_PHY,
 	CORTINA_PHY,
 	GENERIC_8023_C22_PHY,
 	GENERIC_8023_C45_PHY,
  	INBAND_PHY,
+	QUALCOMM_S17,	/** Qualcomm QCA833X switch */
 } cvmx_phy_type_t;
 
 /** Used to record the host mode used by the Cortina CS4321 PHY */
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
index 62808d5..39db403 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
@@ -131,12 +131,14 @@ struct cvmx_cfg_port_param {
 	int8_t ccpp_bpid;
 	int8_t ccpp_pko_port_base;
 	int8_t ccpp_pko_num_ports;
-	bool valid;			/** 1 = port valid, 0 = invalid */
-	bool sgmii_phy_mode;		/** 1 = port in PHY mode, 0 = MAC mode */
-	bool sgmii_1000x_mode;		/** 1 = 1000Base-X mode, 0 = SGMII mode */
-	bool agl_rx_clk_delay_bypass;	/** 1 = use rx clock delay bypass for AGL mode */
 	uint8_t agl_rx_clk_skew;	/** AGL rx clock skew setting (default 0) */
-	bool force_link_up;		/** Ignore PHY and always report link up */
+	bool valid:1;			/** 1 = port valid, 0 = invalid */
+	bool sgmii_phy_mode:1;		/** 1 = port in PHY mode, 0 = MAC mode */
+	bool sgmii_1000x_mode:1;	/** 1 = 1000Base-X mode, 0 = SGMII mode */
+	bool agl_rx_clk_delay_bypass:1;	/** 1 = use rx clock delay bypass for AGL mode */
+	bool force_link_up:1;		/** Ignore PHY and always report link up */
+	bool disable_an:1;		/** true to disable autonegotiation */
+	bool link_down_pwr_dn:1;	/** Power PCS off when link is down */
 };
 
 /*
@@ -560,6 +562,29 @@ extern void cvmx_helper_set_phy_fdt_node_offset(int xiface, int index,
 extern int cvmx_helper_get_phy_fdt_node_offset(int xiface, int index);
 #endif /* !CVMX_BUILD_FOR_LINUX_KERNEL */
 
+/**
+ * @INTERNAL
+ * Override default autonegotiation for a port
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ * @param enable	true to enable autonegotiation, false to force full
+ *			duplex, full speed.
+ */
+extern void cvmx_helper_set_port_autonegotiation(int xiface, int index,
+						 bool enable);
+
+/**
+ * INTERNAL
+ * Returns if autonegotiation is enabled or not.
+ *
+ * @param xiface	node and interface
+ * @param index		port index
+ *
+ * @return 0 if autonegotiation is disabled, 1 if enabled.
+ */
+extern bool cvmx_helper_get_port_autonegotiation(int xiface, int index);
+
 /*
  * Initializes cvmx with user specified config info.
  */
diff --git a/arch/mips/include/asm/octeon/cvmx-hna-defs.h b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
index d8de7e6..dea65b4 100644
--- a/arch/mips/include/asm/octeon/cvmx-hna-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
@@ -469,14 +469,14 @@ union cvmx_hna_config {
 	uint64_t stk_chksz                    : 3;  /**< Stack chunk size. This encoded value specifies the chunk size for both the RNSTK/SVSTK
                                                          data structures. The RNSTK/SVSTK use a doubly linked list where each chunk's first two
                                                          64-bit entries contain the previous and next chunk pointers.
-                                                         0x0 = 32 entries or 256 bytes
-                                                         0x1 = 64 entries or 512 bytes
-                                                         0x2 = 128 entries or 1K bytes
-                                                         0x3 = 256 entries or 2K bytes -> default power on
-                                                         0x4 = 512 entries or 4K bytes
-                                                         0x5 = 1024 entries or 8K bytes
-                                                         0x6 = 2048 entries or 16K bytes
-                                                         0x7 = 4096 entries or 32K bytes
+                                                         0x0 = 32 entries or 256 bytes.
+                                                         0x1 = 64 entries or 512 bytes.
+                                                         0x2 = 128 entries or 1K bytes.
+                                                         0x3 = 256 entries or 2K bytes.
+                                                         0x4 = 512 entries or 4K bytes.
+                                                         0x5 = 1024 entries or 8K bytes.
+                                                         0x6 = 2048 entries or 16K bytes.
+                                                         0x7 = 4096 entries or 32K bytes.
                                                          NOTE: This field can only be changed at initialization/power on time before the HNA is fed
                                                          instructions. */
 	uint64_t rnstk_lwm                    : 4;  /**< RNSTK low watermark. This field specifies the low watermark for the run stack. Valid
@@ -501,29 +501,29 @@ union cvmx_hna_config {
                                                          Software NOTE: The MIO_FUS___HNA_CLMASK_CRIPPLE[3:0] fuse bits are forced into this
                                                          register at reset. Any fuse bits that contain 1 are disallowed during a write and are
                                                          always read as 1. */
-	uint64_t hpu_clcrip                   : 3;  /**< "HPU cluster cripple. Encoding which represents number of HPUs to cripple for each
+	uint64_t hpu_clcrip                   : 3;  /**< HPU cluster cripple. Encoding which represents number of HPUs to cripple for each
                                                          cluster. Typically HPU_CLCRIP=0x0, which enables all HPUs within each cluster. However,
                                                          when the HNA performance counters are used, software may want to limit the number of HPUs
                                                          per cluster available, as there are only 4 parallel performance counters.
-                                                         HPU_CLCRIP \#HPUs crippled (per cluster)
-                                                         0x0 0 HPU[9:0]:ON, All engines enabled
-                                                         0x1 1 HPU[9]:OFF /HPU[8:0]:ON, (n-1) engines enabled
-                                                         0x2 3 HPU[9:7]:OFF /HPU[6:0]:ON, (n-3) engines enabled
-                                                         0x3 4 HPU[9:6]:OFF /HPU[5:0]:ON, (n-4) engines enabled
-                                                         0x4 5 HPU[9:5]:OFF /HPU[4:0]:ON, (n-5) engines enabled
-                                                         0x5 6 HPU[9:4]:OFF /HPU[3:0]:ON, (n-6) engines enabled
-                                                         0x6 8 HPU[9:2]:OFF /HPU[1:0]:ON, (n-8) engines enabled
-                                                         0x7 9 HPU[9:1]:OFF /HPU[0]:ON, (n-9) 1 engine enabled
+                                                         0x0 = HPU[9:0]:ON, All engines enabled
+                                                         0x1 = HPU[9]:OFF /HPU[8:0]:ON, (n-1) engines enabled.
+                                                         0x2 = HPU[9:8]:OFF /HPU[7:0]:ON, (n-2) engines enabled.
+                                                         0x2 = HPU[9:7]:OFF /HPU[6:0]:ON, (n-3) engines enabled.
+                                                         0x3 = HPU[9:6]:OFF /HPU[5:0]:ON, (n-4) engines enabled.
+                                                         0x4 = HPU[9:5]:OFF /HPU[4:0]:ON, (n-5) engines enabled.
+                                                         0x5 = HPU[9:4]:OFF /HPU[3:0]:ON, (n-6) engines enabled.
+                                                         0x6 = HPU[9:2]:OFF /HPU[1:0]:ON, (n-8) engines enabled.
+                                                         0x7 = HPU[9:1]:OFF /HPU[0]:ON, (n-9) 1 engine enabled.
                                                          NOTE: Higher numbered HPUs are crippled first. For instance, on CN78XX (with 10
-                                                         HPUs/cluster), if HPU_CLCRIP=0x1, then HPU \#s [9] within the cluster are crippled and only
-                                                         HPU#s [8:0] are available.
-                                                         IMPNOTE: The encodings are done in such a way as to later be used with fuses (for future
-                                                         revisions which will disable some number of HPUs). Blowing a fuse has the effect that
-                                                         there will always be fewer HPUs available. [i.e: we never want a customer to blow
-                                                         additional fuses to get more HPUs].
+                                                         HPUs/cluster), if HPU_CLCRIP=0x1, then HPU numbers [9] within the cluster are
+                                                         crippled and only HPU numbers 0-8 are available.
                                                          Software NOTE: The MIO_FUS___HNA_NUMHPU_CRIPPLE[2:0] fuse bits are forced into this
                                                          register at reset. Any fuse bits that contain 1 are disallowed during a write and are
-                                                         always read as 1." */
+                                                         always read as 1.
+                                                         INTERNAL: The encodings are done in such a way as to later be used with fuses (for future
+                                                         revisions which will disable some number of HPUs). Blowing a fuse has the effect that
+                                                         there will always be fewer HPUs available. [i.e: we never want a customer to blow
+                                                         additional fuses to get more HPUs]. */
 	uint64_t hpuclkdis                    : 1;  /**< HNA clock disable source. When set, the HNA clocks for HPU (thread engine) operation are
                                                          disabled (to conserve overall chip clocking power when the HNA function is not used).
                                                          NOTE: When set, software must never issue NCB-direct CSR operations to the HNA (will
@@ -605,6 +605,7 @@ typedef union cvmx_hna_control cvmx_hna_control_t;
  * To write to the HNA_DBELL register, a device issues an IOBST directed at the HNA with
  * addr[34:32] = 0x0 or 0x1. To read the HNA_DBELL register, a device issues an IOBLD64 directed
  * at the HNA with addr[34:32] = 0x0 or 0x1.
+ *
  * If HNA_CONFIG[HPUCLKDIS]=1 (HNA-HPU clocks disabled), reads/writes to the HNA_DBELL register
  * do not take effect. If the HNA-disable fuse is blown, reads/writes to the HNA_DBELL register
  * do not take effect.
@@ -636,6 +637,7 @@ typedef union cvmx_hna_dbell cvmx_hna_dbell_t;
  * To write to the HNA_DIFCTL register, a device issues an IOBST directed at the HNA with
  * addr[34:32]=0x6. To read the HNA_DIFCTL register, a device issues an IOBLD64 directed at the
  * HNA with addr[34:32]=0x6.
+ *
  * This register is intended to only be written once (at power-up). Any future writes could cause
  * the HNA and FPA hardware to become unpredictable. If HNA_CONFIG[HPUCLKDIS]=1 (HNA-HPU clocks
  * disabled), reads/writes to HNA_DIFCTL do not take effect. If the HNA-disable FUSE is blown,
@@ -663,7 +665,7 @@ union cvmx_hna_difctl {
                                                          software at the end of the current HNA instruction chunk (see HNA description of next
                                                          chunk buffer Ptr for format).
                                                          b) determine when a HNA instruction chunk can be returned to the Free Page List maintained
-                                                         by FPA */
+                                                         by FPA. */
 #else
 	uint64_t size                         : 9;
 	uint64_t reserved_9_11                : 3;
@@ -683,6 +685,7 @@ typedef union cvmx_hna_difctl cvmx_hna_difctl_t;
  * To write to the HNA_DIFRDPTR register, a device issues an IOBST directed at the HNA with
  * addr[34:32] = 0x2 or 0x3. To read the HNA_DIFRDPTR register, a device issues an IOBLD64
  * directed at the HNA with addr[34:32] = 0x2 or 0x3.
+ *
  * If HNA_CONFIG[HPUCLKDIS]=1 (HNA-HPU clocks disabled), reads/writes to HNA_DIFRDPTR do not take
  * effect. If the HNA-disable fuse is blown, reads/writes to HNA_DIFRDPTR do not take effect.
  */
@@ -735,9 +738,9 @@ union cvmx_hna_error {
                                                          access to the following 40-bit L2/DRAM address space which maps to a 38-bit physical
                                                          DDR3/4 SDRAM address space (256 GB max).
                                                          DR0: 0x0 0000 0000 0000 to 0x0 0000 0FFF FFFF
-                                                         maps to lower 256MB of physical DDR3/4 SDRAM
+                                                         maps to lower 256MB of physical DDR3/4 SDRAM.
                                                          DR1: 0x0 0000 2000 0000 to 0x0 0020 0FFF FFFF
-                                                         maps to upper 127.75GB of DDR3/4 SDRAM
+                                                         maps to upper 127.75GB of DDR3/4 SDRAM.
                                                          NOTE: the 2nd 256MB hole maps to I/O and is unused (nonexistent) for memory.
                                                          In the event the HNA generates a reference to the L2/DRAM address hole (0x0000.0FFF.FFFF -
                                                          0x0000.1FFF.FFFF), the HNANXM programmable interrupt bit will be set.
@@ -755,7 +758,7 @@ union cvmx_hna_error {
 	uint64_t hnc_ovferr                   : 1;  /**< HNC (RAM1) address overflow error detected.
                                                          This condition is signaled by the HPU when an node access is made to RAM1 outside the size
                                                          of the RAM. */
-	uint64_t hna_inst_err                 : 1;  /**< Instruction field ITYPE is not GWALK or CLOAD. */
+	uint64_t hna_inst_err                 : 1;  /**< Instruction field ITYPE is not GWALK nor OSM Load. */
 	uint64_t reserved_6_10                : 5;
 	uint64_t hpu_pdb_par_err              : 1;  /**< A parity error was detected in a packet data buffer in one of the HNA engines. This is not
                                                          self-correcting, and the HPU behavior is undefined. */
@@ -811,35 +814,37 @@ union cvmx_hna_error_capture_data {
                                                          register is cleared. If multiple error events occur before the VLD bit is cleared, the
                                                          subsequent HPU_STATUS information will be lost. The error capture is triggered by the
                                                          following error conditions:
-                                                         * HPU memory errors (SBE or DBE on svstk/rnstk/rwb, or parity error on PDB)
-                                                         * external memory errors (OSM/DLC)
-                                                         * bad node detected in HPU
-                                                         * bad address in HPU
-                                                         * bad stack entry in HPU
-                                                         * HNC parity error
-                                                         * RAM1 address overflow
+                                                         * HPU memory errors (SBE or DBE on svstk/rnstk/rwb, or parity error on PDB).
+                                                         * external memory errors (OSM/DLC).
+                                                         * bad node detected in HPU.
+                                                         * bad address in HPU.
+                                                         * bad stack entry in HPU.
+                                                         * HNC parity error.
+                                                         * RAM1 address overflow.
                                                          The HPU STATUS format is as follows:
-                                                         [63:60]   4'h0
-                                                         [60:40]   failing address                 Last fetched node
-                                                         [39:36]   4'h0
+                                                         <pre>
+                                                         [63:60]   0x0
+                                                         [60:40]   failing address              Last fetched node
+                                                         [39:36]   0x0
                                                          [35:28]   svstck_synd
-                                                         [27]        svstck_dbe                      Interrupt
-                                                         [26]        svstck_sbe                       Interrupt
+                                                         [27]      svstck_dbe                   Interrupt
+                                                         [26]      svstck_sbe                   Interrupt
                                                          [25:18]   rnstck_synd
-                                                         [17]        rnstck_dbe                      Interrupt
-                                                         [16]        rnstck_sbe                      Interrupt
+                                                         [17]      rnstck_dbe                   Interrupt
+                                                         [16]      rnstck_sbe                   Interrupt
                                                          [15:11]   Current opcode
-                                                         [10]        1'b0
-                                                         [9]          OSM or DLC Response Error       REASON MEMERR
-                                                         [8]          Bad node                        REASON BADNODE
-                                                         [7]          Graph location is in RAM2       REASON BADADR
-                                                         [6]          Bad stack entry                 REASON BAD STACKENTRY
-                                                         [5]          Svstck full                     REASON SVSTACK FULL
-                                                         [4]          Rwb full                        REASON RWB FULL
-                                                         [3]          Rnstck full                     REASON RUN STACK FULL
-                                                         [2]          Packet data parity error               Interrupt
-                                                         [1]          RAM1 or RAM2 parity error       REASON MEMERR
-                                                         [0]          Ram1 overflow error             REASON MEMERR */
+                                                         [10]      1'b0
+                                                         [9]       OSM or DLC Response Error    REASON MEMERR
+                                                         [8]       Bad node                     REASON BADNODE
+                                                         [7]       Graph location is in RAM2    REASON BADADR
+                                                         [6]       Bad stack entry              REASON BAD STACKENTRY
+                                                         [5]       Svstck full                  REASON SVSTACK FULL
+                                                         [4]       Rwb full                     REASON RWB FULL
+                                                         [3]       Rnstck full                  REASON RUN STACK FULL
+                                                         [2]       Packet data parity error     Interrupt
+                                                         [1]       RAM1 or RAM2 parity error    REASON MEMERR
+                                                         [0]       Ram1 overflow error          REASON MEMERR
+                                                         </pre> */
 #else
 	uint64_t hpu_stat                     : 64;
 #endif
@@ -993,10 +998,10 @@ union cvmx_hna_hpu_dbg {
 	struct cvmx_hna_hpu_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t csrnum                       : 2;  /**< HPU CSR number
-                                                         0x0 = HPU_STATUS
-                                                         0x1 = DBG_CURSTK
-                                                         0x2 = DBG_GENERAL */
+	uint64_t csrnum                       : 2;  /**< HPU CSR number:
+                                                         0x0 = HPU_STATUS.
+                                                         0x1 = DBG_CURSTK.
+                                                         0x2 = DBG_GENERAL. */
 	uint64_t clid                         : 2;  /**< Cluster number. Valid range is 0-3. */
 	uint64_t hpuid                        : 4;  /**< HPU engine ID. Valid range 0-11. */
 #else
@@ -1077,10 +1082,10 @@ union cvmx_hna_pfc0_ctl {
 	uint64_t clhpu                        : 4;  /**< "Performance counter 0 cluster HPU selector. When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU),
                                                          this field
                                                          is used to select/monitor the cluster's HPU# for all events
-                                                         associated with performance counter \#0." */
+                                                         associated with performance counter 0." */
 	uint64_t clnum                        : 2;  /**< "Performance counter 0 cluster selector. When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU),
                                                          this field is used to select/monitor the cluster# for all events associated with
-                                                         performance counter \#0." */
+                                                         performance counter 0." */
 #else
 	uint64_t clnum                        : 2;
 	uint64_t clhpu                        : 4;
@@ -1165,14 +1170,14 @@ union cvmx_hna_pfc2_ctl {
 	struct cvmx_hna_pfc2_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
-	uint64_t evsel                        : 6;  /**< Performance counter \#2 event selector (64 total). Enumerated by HNA_PFC_SEL_E. */
+	uint64_t evsel                        : 6;  /**< Performance counter 2 event selector (64 total). Enumerated by HNA_PFC_SEL_E. */
 	uint64_t reserved_6_7                 : 2;
-	uint64_t clhpu                        : 4;  /**< "Performance counter \#2 cluster HPU Selector. When HNA_PFC_GCTL[PMODE]=0 (per-cluster
+	uint64_t clhpu                        : 4;  /**< "Performance counter 2 cluster HPU Selector. When HNA_PFC_GCTL[PMODE]=0 (per-cluster
                                                          HPU), this field is used to select/monitor the cluster's HPU# for all events associated
-                                                         with performance counter \#2." */
-	uint64_t clnum                        : 2;  /**< "Performance counter \#2 cluster selector. When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU),
+                                                         with performance counter 2." */
+	uint64_t clnum                        : 2;  /**< "Performance counter 2 cluster selector. When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU),
                                                          this field is used to select/monitor the cluster# for all events associated with
-                                                         performance counter \#2." */
+                                                         performance counter 2." */
 #else
 	uint64_t clnum                        : 2;
 	uint64_t clhpu                        : 4;
@@ -1215,7 +1220,7 @@ union cvmx_hna_pfc3_ctl {
 	uint64_t reserved_6_7                 : 2;
 	uint64_t clhpu                        : 4;  /**< "Performance counter 3 cluster HPU selector. When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU),
                                                          this field is used to select/monitor the cluster's HPU# for all events associated with
-                                                         performance counter \#3." */
+                                                         performance counter 3." */
 	uint64_t clnum                        : 2;  /**< "Performance counter 3 cluster selector. When HNA_PFC_GCTL[PMODE]=0 (per-cluster HPU),
                                                          this field is used to select/monitor the cluster# for all events associated with
                                                          performance counter 3." */
@@ -1302,6 +1307,8 @@ union cvmx_hna_sbd_dbg0 {
 	struct cvmx_hna_sbd_dbg0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t sbd                          : 64; /**< HNA Scoreboard 0 data.
+                                                         INTERNAL:
+                                                         <pre>
                                                          [63]       (1) Unused
                                                          [62]       (1) llptr_gntd
                                                          [61]       (1) llptr_fetch
@@ -1321,12 +1328,13 @@ union cvmx_hna_sbd_dbg0 {
                                                          [7]        (1) Waiting for PRdReq Issue (to NRQ)
                                                          [6]        (1) Packet data valid
                                                          [5]        (1) WQVLD
-                                                         [4]        (1) WQ done point (either WQWrReq issued (for WQPTR<>0) OR HDR RWrCmtRsp
-                                                         completed)
+                                                         [4]        (1) WQ done point (either WQWrReq issued (for WQPTR<>0)
+                                                                        OR HDR RWrCmtRsp completed)
                                                          [3]        (1) Resultant write STF/P Mode
                                                          [2]        (1) Packet data LDT mode
                                                          [1]        (1) Unused
-                                                         [0]        (1) Valid */
+                                                         [0]        (1) Valid
+                                                         </pre> */
 #else
 	uint64_t sbd                          : 64;
 #endif
@@ -1346,11 +1354,11 @@ union cvmx_hna_sbd_dbg1 {
 	uint64_t u64;
 	struct cvmx_hna_sbd_dbg1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t sbd                          : 64; /**< HNA Scoreboard 1 data.
-                                                         [63:58]    (6) Reserved
-                                                         [57:16]   (42) Packet data pointer
-                                                         [15]       (1) Unused
-                                                         [14:0]    (15) Packet data counter */
+	uint64_t sbd                          : 64; /**< Scoreboard 1 debug data.
+                                                         [63:58] = Reserved.
+                                                         [57:16] = Packet data pointer.
+                                                         [15] = Unused.
+                                                         [14:0] = Packet data counter. */
 #else
 	uint64_t sbd                          : 64;
 #endif
@@ -1371,10 +1379,10 @@ union cvmx_hna_sbd_dbg2 {
 	struct cvmx_hna_sbd_dbg2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t sbd                          : 64; /**< HNA Scoreboard 2 data.
-                                                         [63:48]   (16) Reserved
-                                                         [47:45]    (3) ITYPE
-                                                         [44:6]    (39) Result write pointer
-                                                         [5:0]      (6) Pending result write counter */
+                                                         [63:48] = Reserved.
+                                                         [47:45] = ITYPE.
+                                                         [44:6] = Result write pointer.
+                                                         [5:0] = Pending result write counter. */
 #else
 	uint64_t sbd                          : 64;
 #endif
@@ -1395,6 +1403,8 @@ union cvmx_hna_sbd_dbg3 {
 	struct cvmx_hna_sbd_dbg3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t sbd                          : 64; /**< HNA Scoreboard 3 data.
+                                                         INTERNAL:
+                                                         <pre>
                                                          [63:48]   (16) RESERVED
                                                          [47]       (1) fill_start_1a
                                                          [46]       (1) spill_start_1a
@@ -1405,7 +1415,8 @@ union cvmx_hna_sbd_dbg3 {
                                                          [41:38]    (4) state[3:0]
                                                          [37:29]    (9) hpu_rnstk_lvl[8:0]
                                                          [28:11]   (18) ext_rnstk_lvl[17:0]
-                                                         [10:0]    (11) rnstk_addr[10:0] */
+                                                         [10:0]    (11) rnstk_addr[10:0]
+                                                         </pre> */
 #else
 	uint64_t sbd                          : 64;
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
index 17c175b..3b74904 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
@@ -2383,13 +2383,13 @@ union cvmx_l2c_cbcx_holeerr {
 	uint64_t holerd                       : 1;  /**< Logged information is for a HOLERD error. */
 	uint64_t holewr                       : 1;  /**< Logged information is for a HOLEWR error. */
 	uint64_t reserved_59_61               : 3;
-	uint64_t cmd                          : 8;  /**< Encoding of XMC or OCI command causing error. INTERNAL: If CMD[7]==1, use XMC_CMD_E to
+	uint64_t cmd                          : 8;  /**< Encoding of XMC or CCPI command causing error. INTERNAL: If CMD[7]==1, use XMC_CMD_E to
                                                          decode CMD[6:0]. If CMD[7:5]==0, use OCI_MREQ_CMD_E to decode CMD[4:0]. If CMD[7:5]==1,
                                                          use OCI_MFWD_CMD_E to decode CMD[4:0]. If CMD[7:5]==2, use OCI_MRSP_CMD_E to decode
                                                          CMD[4:0]. */
 	uint64_t source                       : 7;  /**< XMC 'source' of request causing error. If SOURCE<6>==0, then SOURCE<5:0> is PPID, else
                                                          SOURCE<3:0> is BUSID of the IOB which made the request. */
-	uint64_t node                         : 4;  /**< OCI Node of XMC request causing error.For HOLE* errors, is the NODE the request is directed to. */
+	uint64_t node                         : 4;  /**< CCPI node of XMC request causing error. For HOLE* errors, is the NODE the request is directed to. */
 	uint64_t addr                         : 40; /**< XMC address causing the error. This field is the physical address after hole removal and
                                                          index aliasing (if enabled). (The hole is between DR0 and DR1. Remove the hole by
                                                          subtracting 256MB from all L2/DRAM physical addresses >= 512 MB.) */
@@ -3197,7 +3197,8 @@ typedef union cvmx_l2c_cfg cvmx_l2c_cfg_t;
  * 1. RD and SEL are as defined in the description of Core Coprocessor 0 registers.
  *
  * 2. If a COP0 register cannot be accessed by this mechanism the write be silently ignored and
- * the read data will be 0x2bad2bad2bad2bad.
+ * the read data will be 0x2bad2bad2bad2bad. Otherwise, if the COP0 register doesn't exist,
+ * the read data value will be 0x000000000BADDEED.
  *
  * 3. If the PPID is outside the range of 0-47,255 or if the core in question is in reset
  * a write will be ignored and reads will timeout the RSL bus.
@@ -3886,7 +3887,7 @@ union cvmx_l2c_ctl {
 	uint64_t reserved_4_5                 : 2;
 	uint64_t disldwb                      : 1;  /**< Suppresses the DWB functionality of any received LDWB, effectively turning them into LDTs. */
 	uint64_t dissblkdty                   : 1;  /**< Disable bandwidth optimization between L2 and LMC and MOB which only transfers modified
-                                                         sub-blocks when possible. In an OCI system all nodes must use the same setting of
+                                                         sub-blocks when possible. In an CCPI system all nodes must use the same setting of
                                                          DISSBLKDTY or operation is undefined.
                                                          INTERNAL: PASS2: DISSBLKDTY should reset to 0, once verif supports it. */
 	uint64_t disecc                       : 1;  /**< Tag and data ECC disable. */
@@ -6180,13 +6181,13 @@ union cvmx_l2c_oci_ctl {
 	uint64_t shtoioen                     : 1;  /**< When set, any core issues any of an IO load, acking store, IOBDMA, LMTDMA, acking IOBADDR,
                                                          or acking LMTST to a node that doesn't exist (existence defined by the ENAOCI bits), then
                                                          the hardware sets [SHTO]. */
-	uint64_t shtoen                       : 3;  /**< When set, if the corresponding OCI link is down, the hardware sets [SHTO].
+	uint64_t shtoen                       : 3;  /**< When set, if the corresponding CCPI link is down, the hardware sets [SHTO].
                                                          See OCX_COM_LINK(0..2)_CTL for a description of what events can contribute to the
                                                          link_down condition. */
 	uint64_t shto                         : 1;  /**< Use short timeout intervals. When set, core uses SDIDTTO for both DID and commit counter
                                                          timeouts, rather than DIDTTO/DIDTTO2. Similarly, L2C will use short instead of long
                                                          timeout. */
-	uint64_t inv_mode                     : 2;  /**< Describes how aggressive to be when waiting for local invalidates before sending OCI
+	uint64_t inv_mode                     : 2;  /**< Describes how aggressive to be when waiting for local invalidates before sending CCPI
                                                          responses which act like commits at the remote.
                                                          0x0 = Conservative mode, waits until all local invalidates have been sent by their
                                                          respective CBCs to the cores.
@@ -6210,12 +6211,13 @@ union cvmx_l2c_oci_ctl {
 	uint64_t gksegnode                    : 2;  /**< Initialized to the OCX_COM_NODE[ID] value on reset, which will equal the OCI_NODE_ID pins
                                                          on a cold reset, but could be something else on a chip warm or soft reset; writable by
                                                          software. */
-	uint64_t enaoci                       : 4;  /**< Enable OCI processing (one bit per node_id). When set, perform OCI processing. When clear,
-                                                         OCI memory writes are blocked and OCI memory reads return unpredictable data. When clear,
-                                                         OCI I/O requests and MOC references are processed and sent to OCX where they are
+	uint64_t enaoci                       : 4;  /**< Enable CCPI processing (one bit per node_id). When set, perform CCPI
+                                                         processing. When clear, CCPI memory writes are blocked and CCPI memory reads
+                                                         return unpredictable data. When clear,
+                                                         CCPI I/O requests and MOC references are processed and sent to OCX where they are
                                                          ultimately discarded. RDDISOCI/WRDISOCI/IORDDISOCI/IOWRDISOCI interrupts occur if and only
-                                                         if the corresponding ENAOCI[node] bit is clear. References to the local node (configured
-                                                         via OCX_COM_NODE[ID]) ignore the value of ENAOCI[node] because no OCI processing is
+                                                         if the corresponding ENAOCI<node> bit is clear. References to the local node (configured
+                                                         via OCX_COM_NODE[ID]) ignore the value of ENAOCI<node> because no CCPI processing is
                                                          required. Similarly, all I/O references ignore the value of ENAOCI when
                                                          L2C_OCI_CTL[IOFRCL] is set. */
 #else
@@ -7282,14 +7284,14 @@ union cvmx_l2c_tadx_err {
 	uint64_t bigrd                        : 1;  /**< Logged information is for a BIGRD error. */
 	uint64_t bigwr                        : 1;  /**< Logged information is for a BIGWR error. */
 	uint64_t reserved_59_61               : 3;
-	uint64_t cmd                          : 8;  /**< Encoding of XMC or OCI command causing error. INTERNAL: If CMD[7]==1, use XMC_CMD_E to
+	uint64_t cmd                          : 8;  /**< Encoding of XMC or CCPI command causing error. INTERNAL: If CMD[7]==1, use XMC_CMD_E to
                                                          decode CMD[6:0]. If CMD[7:5]==0, use OCI_MREQ_CMD_E to decode CMD[4:0]. If CMD[7:5]==1,
                                                          use OCI_MFWD_CMD_E to decode CMD[4:0]. If CMD[7:5]==2, use OCI_MRSP_CMD_E to decode
                                                          CMD[4:0]. */
 	uint64_t source                       : 7;  /**< XMC source of request causing error. If SOURCE<6>==0, then SOURCE<5:0> is PPID, else
                                                          SOURCE<3:0> is BUSID of the IOB which made the request. If CMD[7]==0, this field is
                                                          unpredictable. */
-	uint64_t node                         : 4;  /**< OCI Node of XMC request causing error. For BIG* errors NODE is always the node that
+	uint64_t node                         : 4;  /**< CCPI node of XMC request causing error. For BIG* errors NODE is always the node that
                                                          generated request causing the error (BIG* errors are logged at the home node). For *DISOCI
                                                          errors, is the NODE the request is directed to (DISOCI request is always the current
                                                          Node). */
@@ -7340,14 +7342,14 @@ union cvmx_l2c_tadx_err {
 	uint64_t rddisoci                     : 1;  /**< Logged information is for a RDDISOCI error. */
 	uint64_t wrdisoci                     : 1;  /**< Logged information is for a WRDISOCI error. */
 	uint64_t reserved_59_59               : 1;
-	uint64_t cmd                          : 8;  /**< Encoding of XMC or OCI command causing error. INTERNAL: If CMD[7]==1, use XMC_CMD_E to
+	uint64_t cmd                          : 8;  /**< Encoding of XMC or CCPI command causing error. INTERNAL: If CMD[7]==1, use XMC_CMD_E to
                                                          decode CMD[6:0]. If CMD[7:5]==0, use OCI_MREQ_CMD_E to decode CMD[4:0]. If CMD[7:5]==1,
                                                          use OCI_MFWD_CMD_E to decode CMD[4:0]. If CMD[7:5]==2, use OCI_MRSP_CMD_E to decode
                                                          CMD[4:0]. */
 	uint64_t source                       : 7;  /**< XMC source of request causing error. If SOURCE<6>==0, then SOURCE<5:0> is PPID, else
                                                          SOURCE<3:0> is BUSID of the IOB which made the request. If CMD[7]==0, this field is
                                                          unpredictable. */
-	uint64_t node                         : 4;  /**< OCI Node of XMC request causing error. For BIG* errors NODE is always the node that
+	uint64_t node                         : 4;  /**< CCPI node of XMC request causing error. For BIG* errors NODE is always the node that
                                                          generated request causing the error (BIG* errors are logged at the home node). For *DISOCI
                                                          errors, is the NODE the request is directed to (DISOCI request is always the current
                                                          Node). */
@@ -7939,7 +7941,7 @@ union cvmx_l2c_tadx_tag {
 	uint64_t businfo                      : 9;  /**< The bus information bits. Ignored/loaded with 0 for RTG accesses. */
 	uint64_t ecc                          : 7;  /**< The tag ECC. This field is undefined if L2C_CTL[DISECC] is not 1 when the LTGL2I reads the tags. */
 	uint64_t tag                          : 22; /**< The tag. TAG<39:20> is the corresponding bits from the L2C+LMC internal L2/DRAM byte
-                                                         address. TAG<41:40> is the OCI node of the address. The RTG must always have the
+                                                         address. TAG<41:40> is the CCPI node of the address. The RTG must always have the
                                                          TAG<41:40> equal to the current node or operation is undefined. */
 	uint64_t reserved_6_19                : 14;
 	uint64_t node                         : 2;  /**< The node ID for the remote node which holds this block. Ignored/loaded with 0 for TAG accesses. */
@@ -7988,7 +7990,7 @@ union cvmx_l2c_tadx_timeout {
                                                          then both could have timed out, but info captured is from the original LFB. */
 	uint64_t reserved_57_61               : 5;
 	uint64_t lfbnum                       : 5;  /**< The LFB number of the entry that timed out, and have its info captures in this register. */
-	uint64_t cmd                          : 8;  /**< Encoding of XMC or OCI command causing error.
+	uint64_t cmd                          : 8;  /**< Encoding of XMC or CCPI command causing error.
                                                          INTERNAL: If CMD[7]==1, use XMC_CMD_E to decode CMD[6:0]. If CMD[7:5]==0, use
                                                          OCI_MREQ_CMD_E to
                                                          decode CMD[4:0]. If CMD[7:5]==1, use OCI_MFWD_CMD_E to decode CMD[4:0]. If CMD[7:5]==2,
@@ -8030,7 +8032,7 @@ union cvmx_l2c_tadx_timetwo {
 	uint64_t reserved_33_63               : 31;
 	uint64_t sid                          : 4;  /**< Source id of the original request, that is 'source' of request. This is only valid if the
                                                          request is a local request (valid if L2C_TAD()_TIMEOUT[CMD] is an XMC request and not
-                                                         relevant if it is an OCI request). */
+                                                         relevant if it is an CCPI request). */
 	uint64_t busid                        : 4;  /**< Busid of the original request, that is 'source' of request. */
 	uint64_t vabst                        : 3;  /**< This is the LFB internal state if INFOLFB is set, else will contain VAB internal state if
                                                          INFOVAB is set. */
@@ -8065,19 +8067,19 @@ union cvmx_l2c_tad_ctl {
 	uint64_t u64;
 	struct cvmx_l2c_tad_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_32_63               : 32;
-	uint64_t disrstp                      : 1;  /**< When set, if the L2 receives an RSTP XMC command, it treats it as a STP.
-                                                         INTERNAL: PASS2: DISRSTP should reset to 0, once verif supports it. */
+	uint64_t reserved_33_63               : 31;
+	uint64_t frcnalc                      : 1;  /**< Reserved. */
+	uint64_t disrstp                      : 1;  /**< When set, if the L2 receives an RSTP XMC command, it treats it as a STP. */
 	uint64_t wtlmcwrdn                    : 1;  /**< Be more conservative with LFB done relative to LMC writes. */
 	uint64_t wtinvdn                      : 1;  /**< Be more conservative with LFB done relative to invalidates. */
 	uint64_t wtfilldn                     : 1;  /**< Be more conservative with LFB done relative to fills. */
 	uint64_t exlrq                        : 4;  /**< Extra LFBs to reserve for locally generated XMC commands. None are reserved for functional
                                                          correctness. Ignored if L2C_OCI_CTL[ENAOCI] is 0. */
-	uint64_t exrrq                        : 4;  /**< Extra LFBs to reserve for Rxxx OCI commands beyond the 1 required for OCI protocol
+	uint64_t exrrq                        : 4;  /**< Extra LFBs to reserve for Rxxx CCPI commands beyond the 1 required for CCPI protocol
                                                          functional correctness. Ignored if L2C_OCI_CTL[ENAOCI] is 0. */
-	uint64_t exfwd                        : 4;  /**< Extra LFBs to reserve for Fxxx/SINV OCI commands beyond the 1 required for OCI protocol
+	uint64_t exfwd                        : 4;  /**< Extra LFBs to reserve for Fxxx/SINV CCPI commands beyond the 1 required for CCPI protocol
                                                          functional correctness. Ignored if L2C_OCI_CTL[ENAOCI] is 0. */
-	uint64_t exvic                        : 4;  /**< Extra LFBs to reserve for VICx OCI commands beyond the 1 required for OCI protocol
+	uint64_t exvic                        : 4;  /**< Extra LFBs to reserve for VICx CCPI commands beyond the 1 required for CCPI protocol
                                                          functional correctness. Ignored if L2C_OCI_CTL[ENAOCI] is 0. */
 	uint64_t vbf_thresh                   : 4;  /**< VBF threshold. When the number of in-use VBFs exceeds this number the L2C TAD increases
                                                          the priority of all its write operations in the LMC. */
@@ -8095,7 +8097,8 @@ union cvmx_l2c_tad_ctl {
 	uint64_t wtinvdn                      : 1;
 	uint64_t wtlmcwrdn                    : 1;
 	uint64_t disrstp                      : 1;
-	uint64_t reserved_32_63               : 32;
+	uint64_t frcnalc                      : 1;
+	uint64_t reserved_33_63               : 31;
 #endif
 	} s;
 	struct cvmx_l2c_tad_ctl_cn70xx {
@@ -8830,7 +8833,7 @@ union cvmx_l2c_xmc_cmd {
                                                          another command. */
 	uint64_t reserved_47_62               : 16;
 	uint64_t qos                          : 3;  /**< QOS level to use for simulated ADD bus request. */
-	uint64_t node                         : 4;  /**< OCI node to use for simulated ADD bus request. */
+	uint64_t node                         : 4;  /**< CCPI node to use for simulated ADD bus request. */
 	uint64_t addr                         : 40; /**< Address to use for simulated XMC request (see Note 6) */
 #else
 	uint64_t addr                         : 40;
diff --git a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
index 0414142..a3ec46f 100644
--- a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
@@ -721,7 +721,10 @@ union cvmx_oclax_fsmx_statex {
 	uint64_t u64;
 	struct cvmx_oclax_fsmx_statex_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_30_63               : 34;
+	uint64_t reserved_31_63               : 33;
+	uint64_t sinfo_set                    : 1;  /**< If a control packet is generated in this state (due to capture starting
+                                                         in the next cycle), set OCLA_CAP_CTL_S[SINFO].
+                                                         Added in pass 2. */
 	uint64_t set_int                      : 1;  /**< In this state set interrupt. */
 	uint64_t cap                          : 1;  /**< In this state request capture this cycle. */
 	uint64_t set_mcd                      : 3;  /**< In this state set MCD. */
@@ -744,12 +747,40 @@ union cvmx_oclax_fsmx_statex {
 	uint64_t set_mcd                      : 3;
 	uint64_t cap                          : 1;
 	uint64_t set_int                      : 1;
-	uint64_t reserved_30_63               : 34;
+	uint64_t sinfo_set                    : 1;
+	uint64_t reserved_31_63               : 33;
 #endif
 	} s;
 	struct cvmx_oclax_fsmx_statex_s       cn70xx;
-	struct cvmx_oclax_fsmx_statex_s       cn70xxp1;
-	struct cvmx_oclax_fsmx_statex_s       cn78xx;
+	struct cvmx_oclax_fsmx_statex_cn70xxp1 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_30_63               : 34;
+	uint64_t set_int                      : 1;  /**< In this state set interrupt. */
+	uint64_t cap                          : 1;  /**< In this state request capture this cycle. */
+	uint64_t set_mcd                      : 3;  /**< In this state set MCD. */
+	uint64_t set_trig                     : 1;  /**< In this state set internal trigger indication. */
+	uint64_t reserved_20_23               : 4;
+	uint64_t set_val                      : 4;  /**< In this state store match value into matcher 0..3. */
+	uint64_t reserved_12_15               : 4;
+	uint64_t clr_cnt                      : 4;  /**< In this state clear match counter. */
+	uint64_t reserved_4_7                 : 4;
+	uint64_t inc_cnt                      : 4;  /**< In this state increment match counter. See State Outputs for more information on this or
+                                                         any of the bits above. */
+#else
+	uint64_t inc_cnt                      : 4;
+	uint64_t reserved_4_7                 : 4;
+	uint64_t clr_cnt                      : 4;
+	uint64_t reserved_12_15               : 4;
+	uint64_t set_val                      : 4;
+	uint64_t reserved_20_23               : 4;
+	uint64_t set_trig                     : 1;
+	uint64_t set_mcd                      : 3;
+	uint64_t cap                          : 1;
+	uint64_t set_int                      : 1;
+	uint64_t reserved_30_63               : 34;
+#endif
+	} cn70xxp1;
+	struct cvmx_oclax_fsmx_statex_cn70xxp1 cn78xx;
 };
 typedef union cvmx_oclax_fsmx_statex cvmx_oclax_fsmx_statex_t;
 
@@ -945,7 +976,7 @@ union cvmx_oclax_stack_base {
 	struct cvmx_oclax_stack_base_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
-	uint64_t ptr                          : 35; /**< Memory address for base of overflow stack. This address must be on the local node in a OCI system. */
+	uint64_t ptr                          : 35; /**< Memory address for base of overflow stack. This address must be on the local node in a CCPI system. */
 	uint64_t reserved_0_6                 : 7;
 #else
 	uint64_t reserved_0_6                 : 7;
@@ -967,8 +998,8 @@ union cvmx_oclax_stack_cur {
 	struct cvmx_oclax_stack_cur_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
-	uint64_t ptr                          : 35; /**< Next address to write for overflow stack. This address must be on the local node in a OCI
-                                                         system. During initialization this must be between OCLA()_STACK_BASE and
+	uint64_t ptr                          : 35; /**< Next address to write for overflow stack. This address must be on the local node in a
+                                                         CCPI system. During initialization this must be between OCLA()_STACK_BASE and
                                                          OCLA()_STACK_TOP. */
 	uint64_t reserved_0_6                 : 7;
 #else
@@ -1011,8 +1042,8 @@ union cvmx_oclax_stack_top {
 	struct cvmx_oclax_stack_top_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
-	uint64_t ptr                          : 35; /**< Memory address for top of overflow stack plus one. This address must be on the local node
-                                                         in a OCI system. */
+	uint64_t ptr                          : 35; /**< Memory address for top of overflow stack plus one. This address must be on the
+                                                         local node in a CCPI system. */
 	uint64_t reserved_0_6                 : 7;
 #else
 	uint64_t reserved_0_6                 : 7;
@@ -1195,7 +1226,8 @@ union cvmx_oclax_time {
 	struct cvmx_oclax_time_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t cycle                        : 32; /**< Current time as free running counter. Loaded into captured control packets. */
+	uint64_t cycle                        : 32; /**< Current time as free running counter. Loaded into captured control packets.
+                                                         Unconditionally clocked, independent of OCLA()_SFT_RST. */
 #else
 	uint64_t cycle                        : 32;
 	uint64_t reserved_32_63               : 32;
diff --git a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
index c503f1b..946bb8b 100644
--- a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
@@ -1093,13 +1093,14 @@ union cvmx_ocx_com_node {
 	uint64_t reserved_4_63                : 60;
 	uint64_t fixed_pin                    : 1;  /**< The current value of the OCI_FIXED_NODE pin. */
 	uint64_t fixed                        : 1;  /**< ID Valid associated with the chip. This register is used by the link initialization
-                                                         software to help assign IDs and is transmitted over OCI. The FIXED field set during a cold
+                                                         software to help assign IDs and is transmitted over CCPI. The FIXED field set during a
+                                                         cold
                                                          reset to the value of the OCI_FIXED_NODE pin. The value is also readable in the
                                                          OCX_LNE(0..23)_STS_MSG[TX_META_DAT<2>] for each lane. The FIXED field of the link partner
                                                          can be examined by locally reading the OCX_LNE(0..23)_STS_MSG[RX_META_DAT<2>] on each
                                                          valid lane or remotely reading the OCX_COM_NODE[FIXED] on the link partner. */
 	uint64_t id                           : 2;  /**< Node ID associated with the chip. This register is used by the rest of the chip to
-                                                         determine what traffic is transmitted over OCI. The value should not match the
+                                                         determine what traffic is transmitted over CCPI. The value should not match the
                                                          OCX_COM_LINK(0..2)_CTL[ID] of any active link. The ID field is set during a cold reset to
                                                          the value of the OCI_NODE_ID pins. The value is also readable in the
                                                          OCX_LNE(0..23)_STS_MSG[TX_META_DAT<1:0>] for each lane. The ID field of the link partner
@@ -1126,26 +1127,9 @@ union cvmx_ocx_dllx_status {
 	uint64_t u64;
 	struct cvmx_ocx_dllx_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_17_63               : 47;
-	uint64_t invert                       : 1;  /**< DLL invert status.
-                                                         0 = Normal clock.
-                                                         1 = Inverted clock. Falling edge of core clock occurs before rising edge of reference
-                                                         clock. */
-	uint64_t lock                         : 1;  /**< DLL lock status. */
-	uint64_t state                        : 3;  /**< DLL state.
-                                                         0x0 = Idle.
-                                                         0x1-0x4 = Intermediate states.
-                                                         0x5 = Locked.
-                                                         0x6-0x7 = Reserved. */
-	uint64_t course                       : 8;  /**< DLL course settings. */
-	uint64_t interp                       : 4;  /**< DLL interpolator settings. */
-#else
-	uint64_t interp                       : 4;
-	uint64_t course                       : 8;
-	uint64_t state                        : 3;
-	uint64_t lock                         : 1;
-	uint64_t invert                       : 1;
-	uint64_t reserved_17_63               : 47;
+	uint64_t reserved_0_63                : 64;
+#else
+	uint64_t reserved_0_63                : 64;
 #endif
 	} s;
 	struct cvmx_ocx_dllx_status_s         cn78xx;
@@ -1929,11 +1913,11 @@ union cvmx_ocx_pp_cmd {
 	uint64_t addr                         : 48; /**< The address used in both the load and store operations:
                                                          <47:40> = NCB_ID.
                                                          <39:38> = 0, Not used.
-                                                         <37:36> = OCI_ID.
+                                                         <37:36> = CCPI_ID.
                                                          <35:0> = Address.
                                                          When <47:43> == SLI & <42:40> == 0 bits <39:0> are:
                                                          <39:38> = 0, Not used.
-                                                         <37:36> = OCI_ID.
+                                                         <37:36> = CCPI_ID.
                                                          <35:32> = 0, Not used.
                                                          <31:24> = RSL_ID.
                                                          <23:0> = RSL register offset.
@@ -2407,7 +2391,7 @@ union cvmx_ocx_tlkx_stat_data_cnt {
 	uint64_t u64;
 	struct cvmx_ocx_tlkx_stat_data_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t count                        : 64; /**< Number of data blocks transferred over the OCI Link while OCX_TLK(0..2)_STAT_CTL[ENABLE]
+	uint64_t count                        : 64; /**< Number of data blocks transferred over the CCPI Link while OCX_TLK(0..2)_STAT_CTL[ENABLE]
                                                          has been set. */
 #else
 	uint64_t count                        : 64;
@@ -2424,7 +2408,7 @@ union cvmx_ocx_tlkx_stat_err_cnt {
 	uint64_t u64;
 	struct cvmx_ocx_tlkx_stat_err_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t count                        : 64; /**< Number of blocks received with an error over the OCI link while
+	uint64_t count                        : 64; /**< Number of blocks received with an error over the CCPI link while
                                                          OCX_TLK(0..2)_STAT_CTL[ENABLE] has been set. */
 #else
 	uint64_t count                        : 64;
@@ -2441,7 +2425,7 @@ union cvmx_ocx_tlkx_stat_idle_cnt {
 	uint64_t u64;
 	struct cvmx_ocx_tlkx_stat_idle_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t count                        : 64; /**< Number of idle blocks transferred over the OCI link while OCX_TLK(0..2)_STAT_CTL[ENABLE]
+	uint64_t count                        : 64; /**< Number of idle blocks transferred over the CCPI link while OCX_TLK(0..2)_STAT_CTL[ENABLE]
                                                          has been set. */
 #else
 	uint64_t count                        : 64;
@@ -2459,7 +2443,7 @@ union cvmx_ocx_tlkx_stat_matx_cnt {
 	struct cvmx_ocx_tlkx_stat_matx_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t count                        : 64; /**< Number of packets that have matched OCX_TLK(a)_STAT_MATCH0 and have been transferred over
-                                                         the OCI Link while OCX_TLK(0..2)_STAT_CTL[ENABLE] has been set. */
+                                                         the CCPI link while OCX_TLK(0..2)_STAT_CTL[ENABLE] has been set. */
 #else
 	uint64_t count                        : 64;
 #endif
@@ -2502,7 +2486,8 @@ union cvmx_ocx_tlkx_stat_retry_cnt {
 	uint64_t u64;
 	struct cvmx_ocx_tlkx_stat_retry_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t count                        : 64; /**< Number of data blocks repeated over the OCI link while OCX_TLK(0..2)_STAT_CTL[ENABLE] has been set. */
+	uint64_t count                        : 64; /**< Number of data blocks repeated over the CCPI link while OCX_TLK(0..2)_STAT_CTL[ENABLE] has
+                                                         been set. */
 #else
 	uint64_t count                        : 64;
 #endif
@@ -2518,7 +2503,7 @@ union cvmx_ocx_tlkx_stat_sync_cnt {
 	uint64_t u64;
 	struct cvmx_ocx_tlkx_stat_sync_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t count                        : 64; /**< Number of sync (control) blocks transferred over the OCI link while
+	uint64_t count                        : 64; /**< Number of sync (control) blocks transferred over the CCPI link while
                                                          OCX_TLK(0..2)_STAT_CTL[ENABLE] has been set. */
 #else
 	uint64_t count                        : 64;
@@ -2535,7 +2520,7 @@ union cvmx_ocx_tlkx_stat_vcx_cmd {
 	uint64_t u64;
 	struct cvmx_ocx_tlkx_stat_vcx_cmd_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t count                        : 64; /**< Number of commands on this VC that have been transfered over the OCI link while
+	uint64_t count                        : 64; /**< Number of commands on this VC that have been transfered over the CCPI link while
                                                          OCX_TLK(0..2)_STAT_CTL[ENABLE] has been set. For VCs 6 through 13 the number of commands
                                                          is equal to the number of packets. */
 #else
@@ -2572,7 +2557,7 @@ union cvmx_ocx_tlkx_stat_vcx_pkt {
 	uint64_t u64;
 	struct cvmx_ocx_tlkx_stat_vcx_pkt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t count                        : 64; /**< Number of packets on this VC that have been transferred over the OCI link while
+	uint64_t count                        : 64; /**< Number of packets on this VC that have been transferred over the CCPI link while
                                                          OCX_TLK(0..2)_STAT_CTL[ENABLE] has been set. */
 #else
 	uint64_t count                        : 64;
@@ -2649,11 +2634,11 @@ union cvmx_ocx_win_cmd {
 	uint64_t addr                         : 48; /**< The address used in both the load and store operations:
                                                          <47:40> = NCB_ID.
                                                          <39:38> = 0, Not used.
-                                                         <37:36> = OCI_ID.
+                                                         <37:36> = CCPI_ID.
                                                          <35:0> = Address.
                                                          When <47:43> == SLI & <42:40> == 0 bits <39:0> are:
                                                          <39:38> = 0, Not used.
-                                                         <37:36> = OCI_ID.
+                                                         <37:36> = CCPI_ID.
                                                          <35:32> = 0, Not used.
                                                          <31:24> = RSL_ID.
                                                          <23:0> = RSL register offset.
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
index 78e6d9d..6552bf6 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
@@ -790,7 +790,8 @@ union cvmx_pcieepvfx_cfg002 {
 	uint32_t bcc                          : 8;  /**< Base class code. */
 	uint32_t sc                           : 8;  /**< Subclass code. */
 	uint32_t pi                           : 8;  /**< Programming interface. */
-	uint32_t rid                          : 8;  /**< Revision ID. */
+	uint32_t rid                          : 8;  /**< Revision ID, writable through PEM()_CFG_WR. However, the application must not change
+                                                         this field. */
 #else
 	uint32_t rid                          : 8;
 	uint32_t pi                           : 8;
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index 8269e7d..c576d9d 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -10919,19 +10919,19 @@ union cvmx_pcieepx_cfg554 {
                                                          phase. Encoding scheme as follows:
                                                          Bit [15:0] = 0x0: No preset is requested and evaluated in the EQ master phase.
                                                          Bit [i] = 1: Preset=i is requested and evaluated in the EQ master phase.
-                                                         _ 0000000000000000: No preset req/evaluated in EQ master phase
-                                                         _ 00000xxxxxxxxxx1: Preset 0 req/evaluated in EQ master phase
-                                                         _ 00000xxxxxxxxx1x: Preset 1 req/evaluated in EQ master phase
-                                                         _ 00000xxxxxxxx1xx: Preset 2 req/evaluated in EQ master phase
-                                                         _ 00000xxxxxxx1xxx: Preset 3 req/evaluated in EQ master phase
-                                                         _ 00000xxxxxx1xxxx: Preset 4 req/evaluated in EQ master phase
-                                                         _ 00000xxxxx1xxxxx: Preset 5 req/evaluated in EQ master phase
-                                                         _ 00000xxxx1xxxxxx: Preset 6 req/evaluated in EQ master phase
-                                                         _ 00000xxx1xxxxxxx: Preset 7 req/evaluated in EQ master phase
-                                                         _ 00000xx1xxxxxxxx: Preset 8 req/evaluated in EQ master phase
-                                                         _ 00000x1xxxxxxxxx: Preset 9 req/evaluated in EQ master phase
-                                                         _ 000001xxxxxxxxxx: Preset 10 req/evaluated in EQ master phase
-                                                         _ All other encodings: Reserved */
+                                                         _ 0b0000000000000000 = No preset req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxxxx1 = Preset 0 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxxx1x = Preset 1 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxx1xx = Preset 2 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxx1xxx = Preset 3 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxx1xxxx = Preset 4 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxx1xxxxx = Preset 5 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxx1xxxxxx = Preset 6 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxx1xxxxxxx = Preset 7 req/evaluated in EQ master phase.
+                                                         _ 0b00000xx1xxxxxxxx = Preset 8 req/evaluated in EQ master phase.
+                                                         _ 0b00000x1xxxxxxxxx = Preset 9 req/evaluated in EQ master phase.
+                                                         _ 0b000001xxxxxxxxxx = Preset 10 req/evaluated in EQ master phase.
+                                                         _ All other encodings = Reserved. */
 	uint32_t reserved_6_7                 : 2;
 	uint32_t p23td                        : 1;  /**< Phase2_3 2 ms timeout disable. Determine behavior in Phase2 for USP (Phase3 if DSP) when
                                                          the PHY does not respond within 2 ms to the assertion of RxEqEval:
diff --git a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
index e56e364..73c458d 100644
--- a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
@@ -9435,18 +9435,18 @@ union cvmx_pciercx_cfg554 {
                                                          phase. Encoding scheme as follows:
                                                          Bit [15:0] = 0x0: No preset is requested and evaluated in the EQ master phase.
                                                          Bit [i] = 1: Preset=i is requested and evaluated in the EQ master phase.
-                                                         _ 0000000000000000: No preset req/evaluated in EQ master phase
-                                                         _ 00000xxxxxxxxxx1: Preset 0 req/evaluated in EQ master phase
-                                                         _ 00000xxxxxxxxx1x: Preset 1 req/evaluated in EQ master phase
-                                                         _ 00000xxxxxxxx1xx: Preset 2 req/evaluated in EQ master phase
-                                                         _ 00000xxxxxxx1xxx: Preset 3 req/evaluated in EQ master phase
-                                                         _ 00000xxxxxx1xxxx: Preset 4 req/evaluated in EQ master phase
-                                                         _ 00000xxxxx1xxxxx: Preset 5 req/evaluated in EQ master phase
-                                                         _ 00000xxxx1xxxxxx: Preset 6 req/evaluated in EQ master phase
-                                                         _ 00000xxx1xxxxxxx: Preset 7 req/evaluated in EQ master phase
-                                                         _ 00000xx1xxxxxxxx: Preset 8 req/evaluated in EQ master phase
-                                                         _ 00000x1xxxxxxxxx: Preset 9 req/evaluated in EQ master phase
-                                                         _ 000001xxxxxxxxxx: Preset 10 req/evaluated in EQ master phase
+                                                         _ 0b0000000000000000: No preset req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxxxx1: Preset 0 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxxx1x: Preset 1 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxx1xx: Preset 2 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxx1xxx: Preset 3 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxx1xxxx: Preset 4 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxx1xxxxx: Preset 5 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxx1xxxxxx: Preset 6 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxx1xxxxxxx: Preset 7 req/evaluated in EQ master phase.
+                                                         _ 0b00000xx1xxxxxxxx: Preset 8 req/evaluated in EQ master phase.
+                                                         _ 0b00000x1xxxxxxxxx: Preset 9 req/evaluated in EQ master phase.
+                                                         _ 0b000001xxxxxxxxxx: Preset 10 req/evaluated in EQ master phase.
                                                          _ All other encodings: Reserved */
 	uint32_t reserved_6_7                 : 2;
 	uint32_t p23td                        : 1;  /**< Phase2_3 2 ms timeout disable. Determine behavior in Phase2 for USP (Phase3 if DSP) when
diff --git a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
index 1cf230d..0e00f8b 100644
--- a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
@@ -1203,11 +1203,11 @@ union cvmx_pemx_cfg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
 	uint64_t laneswap                     : 1;  /**< This field enables overwriting the value for lane swapping. The reset value is captured on
-                                                         cold reset by the pin straps (see PEM(0..3)_STRAP.PILANESWAP). When set, lane swapping is
+                                                         cold reset by the pin straps (see PEM()_STRAP[PILANESWAP]). When set, lane swapping is
                                                          performed to/from the SerDes. When clear, no lane swapping is performed. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t md                           : 2;  /**< This field enables overwriting the value for speed. The reset value is captured on cold
-                                                         reset by the pin straps (see PEM(0..3)_STRAP.PIMODE). For a root complex configuration
+                                                         reset by the pin straps (see PEM()_STRAP[PIMODE]). For a root complex configuration
                                                          that is not running at Gen3 speed, the HOSTMD bit of this register must be set when this
                                                          field is changed.
                                                          0x0 = Gen1 speed.
@@ -1259,21 +1259,22 @@ union cvmx_pemx_cfg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
 	uint64_t laneswap                     : 1;  /**< This field enables overwriting the value for lane swapping. The reset value is captured on
-                                                         cold reset by the pin straps (see PEM(0..3)_STRAP.PILANESWAP). When set, lane swapping is
+                                                         cold reset by the pin straps (see PEM()_STRAP[PILANESWAP]). When set, lane swapping is
                                                          performed to/from the SerDes. When clear, no lane swapping is performed. */
 	uint64_t lanes8                       : 1;  /**< This field enables overwriting the value for the maximum number of lanes. The reset value
-                                                         is captured on cold reset by the pin straps (see PEM(0..3)_STRAP.PILANES8). When set, the
+                                                         is captured on cold reset by the pin straps (see PEM()_STRAP[PILANES8]). When set, the
                                                          PEM is configured for a maximum of 8 lanes. When clear, the PEM is configured for a
                                                          maximum of 4 lanes. This value is used to set the maximum link width field in the core's
                                                          link capabilities register (CFG031) to indicate the maximum number of lanes
                                                          supported. Note that less lanes than the specified maximum can be configured for use via
                                                          the core's link control register (CFG032) negotiated link width field. */
 	uint64_t hostmd                       : 1;  /**< This field enables overwriting the value for host mode. The reset value is captured on
-                                                         cold reset by the pin straps (see PEM(0..3)_STRAP.PIMODE). When set, the PEM is configured
-                                                         to be a root complex.
-                                                         When clear, the PEM is configured to be an end point. */
+                                                         cold reset by the pin straps. (See PEM()_STRAP[PIMODE]. The HOSTMD reset value is the
+                                                         bit-wise AND of the PIMODE straps.  As such, PEMs 0 and 2 are configurable and PEMs 1
+                                                         and 3 default to 0x1.)  When set, the PEM is configured to be a root complex. When clear,
+                                                         the PEM is configured to be an end point. */
 	uint64_t md                           : 2;  /**< This field enables overwriting the value for speed. The reset value is captured on cold
-                                                         reset by the pin straps (see PEM(0..3)_STRAP.PIMODE). For a root complex configuration
+                                                         reset by the pin straps (see PEM()_STRAP[PIMODE]). For a root complex configuration
                                                          that is not running at Gen3 speed, the HOSTMD bit of this register must be set when this
                                                          field is changed.
                                                          0x0 = Gen1 speed.
@@ -2801,10 +2802,10 @@ union cvmx_pemx_int_sum {
 	uint64_t u64;
 	struct cvmx_pemx_int_sum_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t intd                         : 1;  /**< The PCIe controller received an INTD. This is a level sensitive interrupt. */
-	uint64_t intc                         : 1;  /**< The PCIe controller received an INTC. This is a level sensitive interrupt. */
-	uint64_t intb                         : 1;  /**< The PCIe controller received an INTB. This is a level sensitive interrupt. */
-	uint64_t inta                         : 1;  /**< The PCIe controller received an INTA. This is a level sensitive interrupt. */
+	uint64_t intd                         : 1;  /**< The PCIe controller received an INTD. This is a level-sensitive interrupt. */
+	uint64_t intc                         : 1;  /**< The PCIe controller received an INTC. This is a level-sensitive interrupt. */
+	uint64_t intb                         : 1;  /**< The PCIe controller received an INTB. This is a level-sensitive interrupt. */
+	uint64_t inta                         : 1;  /**< The PCIe controller received an INTA. This is a level-sensitive interrupt. */
 	uint64_t reserved_14_59               : 46;
 	uint64_t crs_dr                       : 1;  /**< Had a CRS Timeout when Retries were disabled. */
 	uint64_t crs_er                       : 1;  /**< Had a CRS Timeout when Retries were enabled. */
@@ -2902,10 +2903,10 @@ union cvmx_pemx_int_sum {
 	struct cvmx_pemx_int_sum_cn61xx       cn70xxp1;
 	struct cvmx_pemx_int_sum_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t intd                         : 1;  /**< The PCIe controller received an INTD. This is a level sensitive interrupt. */
-	uint64_t intc                         : 1;  /**< The PCIe controller received an INTC. This is a level sensitive interrupt. */
-	uint64_t intb                         : 1;  /**< The PCIe controller received an INTB. This is a level sensitive interrupt. */
-	uint64_t inta                         : 1;  /**< The PCIe controller received an INTA. This is a level sensitive interrupt. */
+	uint64_t intd                         : 1;  /**< The PCIe controller received an INTD. This is a level-sensitive interrupt. */
+	uint64_t intc                         : 1;  /**< The PCIe controller received an INTC. This is a level-sensitive interrupt. */
+	uint64_t intb                         : 1;  /**< The PCIe controller received an INTB. This is a level-sensitive interrupt. */
+	uint64_t inta                         : 1;  /**< The PCIe controller received an INTA. This is a level-sensitive interrupt. */
 	uint64_t reserved_14_59               : 46;
 	uint64_t crs_dr                       : 1;  /**< Had a CRS timeout when retries were disabled. */
 	uint64_t crs_er                       : 1;  /**< Had a CRS timeout when retries were enabled. */
@@ -2918,10 +2919,10 @@ union cvmx_pemx_int_sum {
 	uint64_t up_b2                        : 1;  /**< Received P-TLP for BAR2 when BAR2 is disabled. */
 	uint64_t up_b1                        : 1;  /**< Received P-TLP for BAR1 when BAR1 index valid is not set. */
 	uint64_t reserved_3_3                 : 1;
-	uint64_t pmei                         : 1;  /**< PME interrupt (cfg_pme_int). This is a level sensitive interrupt. */
+	uint64_t pmei                         : 1;  /**< PME interrupt (cfg_pme_int). This is a level-sensitive interrupt. */
 	uint64_t se                           : 1;  /**< System error, RC mode only.  (cfg_sys_err_rc) */
 	uint64_t aeri                         : 1;  /**< Advanced error reporting interrupt, RC mode only (cfg_aer_rc_err_int).
-                                                         This is a level sensitive interrupt. */
+                                                         This is a level-sensitive interrupt. */
 #else
 	uint64_t aeri                         : 1;
 	uint64_t se                           : 1;
@@ -3367,33 +3368,71 @@ union cvmx_pemx_tlp_credits {
 	uint64_t pem_cpl                      : 8;  /**< TLP 16B credits for completion TLPs in the peer. Legal values are 0x12 to 0x40. */
 	uint64_t pem_np                       : 8;  /**< TLP 16B credits for nonposted TLPs in the peer. Legal values are 0x4 to 0x8. */
 	uint64_t pem_p                        : 8;  /**< TLP 16B credits for posted TLPs in the peer. Legal values are 0x12 to 0x40. */
-	uint64_t sli_cpl                      : 8;  /**< TLP 8B credits for completion TLPs in the SLI. Legal values are 0x24 to 0x80. When
-                                                         multiple PEMs are wire-OR'd together, the sum of all PEMs' SLI_CPL fields must not exceed
-                                                         0x80. The reset value for this register is based on the pi_select_8lanes and the
-                                                         PCIE0/2_MODE<1:0> straps. For EP mode PEMs, the 8-lanes strap determines the credits reset
-                                                         value; 1'b0 = 4 lanes = 64 credits, 1'b1 = 8 lanes = 128 credits. For RC mode PEMs, the
-                                                         credits are reset assuming a 4-lane configuration. Software can bump this value up in the
-                                                         case of 8-lane RC mode PEMS. Software may need to reprogram this register for performance
-                                                         reasons (configured as the only PEM, but as 4-lane -- in this case, this PEM can take all
-                                                         of the credits). */
-	uint64_t sli_np                       : 8;  /**< TLP 8B credits for nonposted TLPs in the SLI. Legal values are 0x8 to 0x10. When multiple
-                                                         PEMS are wire-OR'd together, the sum of all PEMs' SLI_CPL fields must not exceed 0x80. The
-                                                         reset value for this register is based on the pi_select_8lanes and the pi_select_mode
-                                                         straps. For EP mode PEMs, the 8lanes strap determines the credits reset value; 1'b0 = 4
-                                                         lanes = 8 credits, 1'b1 = 8 lanes = 16 credits. For RC mode PEMs, the credits are reset
-                                                         assuming a 4 lane configuration. software can bump this value up in the case of 8 lane RC
-                                                         mode PEMS. software may need to reprogram this register for performance reasons
-                                                         (configured as the only PEM, but as 4-lane - in this case, this PEM can take all of the
-                                                         credits). */
-	uint64_t sli_p                        : 8;  /**< TLP 8B credits for Posted TLPs in the SLI. Legal values are 0x24 to 0x80. When multiple
-                                                         PEMs are wire-OR'd together, the sum of all PEMs' SLI_CPL fields must not exceed 0x80. The
-                                                         reset value for this register is based on the pi_select_8lanes and the PCIE0/2_MODE<1:0>
-                                                         straps. For EP mode PEMs, the 8-lanes strap determines the credits reset value; 1'b0 = 4
-                                                         lanes = 64 credits, 1'b1 = 8 lanes = 128 credits. For RC mode PEMs, the credits are reset
-                                                         assuming a 4-lane configuration. Software can bump this value up in the case of 8-lane RC
-                                                         mode PEMS. Software may need to reprogram this register for performance reasons
-                                                         (configured as the only PEM, but as 4-lane -- in this case, this PEM can take all of the
-                                                         credits). */
+	uint64_t sli_cpl                      : 8;  /**< TLP 8B credits for completion TLPs in the SLI. Legal values are 0x24 to
+                                                         0xFF. Pairs of PEMs share a single SLI interface. PEM(0) and PEM(1) share one
+                                                         SLI interface, while PEM(2) and PEM(3) share the other. When both PEMs of a pair
+                                                         are configured, the sum of both PEMs' SLI_CPL fields must not exceed 0x100. The
+                                                         reset value for this register assumes the minimum (e.g. 4-lane)
+                                                         configuration. This ensures that for configurations where the total number of
+                                                         lanes for a pair of PEMs exceeds 8, the total allocated credits does not
+                                                         oversubscribe the SLI.
+                                                         For configurations other than two 4-lane PEMs connected to a single SLI port,
+                                                         software may safely reprogram this register (i.e. increase the value) to achieve
+                                                         optimal performance.  See the following table of example configurations of PEM
+                                                         pairs for recommended credit values.
+                                                         <pre>
+                                                            Configuration  PEM  Lanes  Typical [SLI_CPL]
+                                                            --------------------------------------------
+                                                            1 8-ln PEM     n    8             0xFF
+                                                            2 4-ln PEMs    n    4             0x80
+                                                                          n+1   4             0x80
+                                                            1 4-ln PEM     n    4             0xFF
+                                                            1 8-ln PEM,    n    8             0xAA
+                                                            1 4-ln PEM    n+1   4             0x55
+                                                         </pre> */
+	uint64_t sli_np                       : 8;  /**< TLP 8B credits for nonposted TLPs in the SLI. Legal values are 0x4 to
+                                                         0x20. Pairs of PEMs share a single SLI interface. PEM(0) and PEM(1) share one
+                                                         SLI interface, while PEM(2) and PEM(3) share the other. When both PEMs of a pair
+                                                         are configured, the sum of both PEMs' SLI_NP fields must not exceed 0x20. The
+                                                         reset value for this register assumes the minimum (e.g. 4-lane)
+                                                         configuration. This ensures that for configurations where the total number of
+                                                         lanes for a pair of PEMs exceeds 8, the total allocated credits does not
+                                                         oversubscribe the SLI.
+                                                         For configurations other than two 4-lane PEMs connected to a single SLI port,
+                                                         software may safely reprogram this register (i.e. increase the value) to achieve
+                                                         optimal performance.  See the following table of example configurations of PEM
+                                                         pairs for recommended credit values.
+                                                         <pre>
+                                                            Configuration  PEM  Lanes  Typical [SLI_CPL]
+                                                            --------------------------------------------
+                                                            1 8-ln PEM     n    8             0x20
+                                                            2 4-ln PEMs    n    4             0x10
+                                                                          n+1   4             0x10
+                                                            1 4-ln PEM     n    4             0x20
+                                                            1 8-ln PEM,    n    8             0x15
+                                                            1 4-ln PEM    n+1   4             0x0B
+                                                         </pre> */
+	uint64_t sli_p                        : 8;  /**< TLP 8B credits for Posted TLPs in the SLI. Legal values are 0x24 to 0xFF. Pairs
+                                                         of PEMs share a single SLI interface. PEM(0) and PEM(1) share one SLI interface,
+                                                         while PEM(2) and PEM(3) share the other. When both PEMs of a pair are
+                                                         configured, the sum of both PEMs' SLI_P fields must not exceed 0x100. The reset
+                                                         value for this register assumes the minimum (e.g. 4-lane) configuration. This
+                                                         ensures that for configurations where the total number of lanes for a pair of
+                                                         PEMs exceeds 8, the total allocated credits does not oversubscribe the SLI.
+                                                         For configurations other than two 4-lane PEMs connected to a single SLI port,
+                                                         software may safely reprogram this register (i.e. increase the value) to achieve
+                                                         optimal performance.  See the following table of example configurations of PEM
+                                                         pairs for recommended credit values.
+                                                         <pre>
+                                                            Configuration  PEM  Lanes  Typical [SLI_CPL]
+                                                            --------------------------------------------
+                                                            1 8-ln PEM     n    8             0xFF
+                                                            2 4-ln PEMs    n    4             0x80
+                                                                          n+1   4             0x80
+                                                            1 4-ln PEM     n    4             0xFF
+                                                            1 8-ln PEM,    n    8             0xAA
+                                                            1 4-ln PEM    n+1   4             0x55
+                                                         </pre> */
 #else
 	uint64_t sli_p                        : 8;
 	uint64_t sli_np                       : 8;
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index b422e6b..5042256 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -1829,9 +1829,9 @@ union cvmx_pki_clx_stylex_alg {
 	uint64_t reserved_32_63               : 32;
 	uint64_t tt                           : 2;  /**< SSO tag type to schedule to, enumerated with SSO_TT_E. */
 	uint64_t apad_nip                     : 3;  /**< Value for WQE[APAD] when packet is not IP. */
-	uint64_t qpg_qos                      : 3;  /**< Algorithm to select QoS field in QPG calculation. Enumerated with PKI_QPGQOS_E. See QPG. */
-	uint64_t qpg_port_sh                  : 3;  /**< Number of bits to shift port number in QPG calculation. See QPG. */
-	uint64_t qpg_port_msb                 : 4;  /**< MSB to take from port number in QPG calculation. See QPG.
+	uint64_t qpg_qos                      : 3;  /**< Algorithm to select QoS field in QPG calculation. Enumerated with PKI_QPGQOS_E. */
+	uint64_t qpg_port_sh                  : 3;  /**< Number of bits to shift port number in QPG calculation. */
+	uint64_t qpg_port_msb                 : 4;  /**< MSB to take from port number in QPG calculation.
                                                          0 = Exclude port number from QPG.
                                                          4 = Include port<3:0>.
                                                          8 = Include port<7:0>.
@@ -2797,6 +2797,7 @@ typedef union cvmx_pki_pkt_err cvmx_pki_pkt_err_t;
  *
  * The QPG table is used to indirectly calculate the Portadd/Aura/Group from the Diffsrv, HiGig
  * or VLAN information as described in QPG.
+ * See also PKI_QPG_TBL2().
  */
 union cvmx_pki_qpg_tblx {
 	uint64_t u64;
@@ -3412,10 +3413,14 @@ union cvmx_pki_stat_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t mode                         : 2;  /**< The PKI_STAT*_X registers can be indexed either by port kind (pkind), or final style.
-                                                         (Does not apply to the PKI_STAT_INB* registers.)
+                                                         (Does not apply to the PKI_STAT_INB* nor PKI_DSTAT_* registers.)
                                                          _ 0x0 = X represents the packet's pkind.
                                                          _ 0x1 = X represents the low 6-bits of packet's final style.
-                                                         _ 0x2-0x3 = Reserved. */
+                                                         _ 0x2 = X represents the packet's PKI_QPG_TBL2()[DSTAT_ID].
+                                                           PKI_STAT()_STAT0..PKI_STAT()_STAT18 and PKI_STAT()_HIST0..PKI_STAT()_HIST6 will only
+                                                           be incremented if the DSTAT_ID is less than 64; i.e. fits in the index of the
+                                                           PKI_STAT()_STAT0 etc. Added in pass 2.
+                                                         _ 0x3 = Reserved. */
 #else
 	uint64_t mode                         : 2;
 	uint64_t reserved_2_63                : 62;
@@ -3438,27 +3443,27 @@ union cvmx_pki_stylex_buf {
 	uint64_t wqe_hsz                      : 2;  /**< Work queue header size:
                                                          0x0 = WORD0..4, standard WQE_S. Note FIRST_SKIP may be set to not include WORD4 in memory.
                                                          0x1 = WORD0..5.
-                                                         0x2 = WORD0..6.
-                                                         0x3 = WORD0..7.
+                                                         0x2 = Reserved
+                                                         0x3 = Reserved
                                                          INTERNAL: Selects which PIX words are transferred to the PKI BE. If a word is not
                                                          transferred and the word will reach memory (FIRST_SKIP is greater than that word number),
                                                          then the final WQE memory word will be zero, not the PIX register contents. */
 	uint64_t wqe_skip                     : 2;  /**< WQE start offset. The number of 128-byte cache lines to skip between the buffer pointer
-                                                         and WORD0 of the work-queue entry. See PKI Hardware Allocating Multiple Buffers.
+                                                         and WORD0 of the work-queue entry.
                                                          If [DIS_WQ_DAT]=1, legal values must satisfy:
-                                                           * MB_SIZE >= (PKI_STYLE()_BUF[WQE_SKIP] * (128/8)) + 18
+                                                           * [MB_SIZE] >= (PKI_STYLE()_BUF[WQE_SKIP] * (128/8)) + 18
                                                          If [DIS_WQ_DAT]=0, legal values must satisfy:
-                                                           * (WQE_SKIP * (128/8)) + 4 <= FIRST_SKIP, to insure the minimum of four work-queue entry
-                                                             words will fit within FIRST_SKIP. */
+                                                           * ([WQE_SKIP] * (128/8)) + 4 <= [FIRST_SKIP], to insure the minimum of four
+                                                             work-queue entry words will fit within [FIRST_SKIP]. */
 	uint64_t first_skip                   : 6;  /**< The number of eight-byte words from the top of the first MBUF that the PKI stores the next
                                                          pointer.
                                                          If [DIS_WQ_DAT]=1, legal values must satisfy:
-                                                           * FIRST_SKIP <= PKI_STYLE()_BUF[MB_SIZE] - 18.
+                                                           * [FIRST_SKIP] <= PKI_STYLE()_BUF[MB_SIZE] - 18.
                                                          If [DIS_WQ_DAT]=0, legal values must satisfy:
-                                                           * FIRST_SKIP <= PKI_STYLE()_BUF[MB_SIZE] - 18.
-                                                           * (WQE_SKIP * (128/8)) + X <= FIRST_SKIP,
-                                                             X must be at least 0x4 to insure the minimum of four work-queue entry,
-                                                             but 0x5 is recommended minimum. X=0x4 will drop WQE WORD4, for use in
+                                                           * [FIRST_SKIP] <= PKI_STYLE()_BUF[MB_SIZE] - 18.
+                                                           * ([WQE_SKIP] * (128/8)) + X <= [FIRST_SKIP].
+                                                           _ X must be at least 0x4 to insure the minimum of four work-queue entry,
+                                                             but 0x5 is recommended minimum. X = 0x4 will drop WQE WORD4, for use in
                                                              backward compatible applications. */
 	uint64_t later_skip                   : 6;  /**< The number of eight-byte words from the top of any MBUF that is not the first MBUF that
                                                          PKI writes the next-pointer to. Legal values are 0 to PKI_STYLE()_BUF[MB_SIZE] - 18. */
diff --git a/arch/mips/include/asm/octeon/cvmx-pko-defs.h b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
index 48be7dcd..ca6233f 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
@@ -3098,7 +3098,7 @@ union cvmx_pko_dpfi_fpa_aura {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t node                         : 2;  /**< Node number of current chip, to ensure that the aura is on the local node. */
-	uint64_t laura                        : 10; /**< Local aura to use for PKO command buffering. Must be on local OCI node.
+	uint64_t laura                        : 10; /**< Local aura to use for PKO command buffering. Must be on local CCPI node.
                                                          The FPA aura selected by LAURA must select an FPA pool whose
                                                          FPA_POOL()_CFG[NAT_ALIGN]=1, and
                                                          (FPA_POOL()_CFG[BUF_SIZE] - FPA_POOL()_CFG[BUF_OFFSET]) >= 4 KB/128. */
@@ -3494,8 +3494,9 @@ union cvmx_pko_dqx_shape {
 	struct cvmx_pko_dqx_shape_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
-	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in shaping calculations such that only
-                                                         the value of PKO_L5_SQ()_SHAPE[ADJUST]. */
+	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
+                                                         and shaping calculations such that only the values of
+                                                         PKO_L5_SQ()_SHAPE[ADJUST] and PKO_SEND_EXT_S[SHAPECHG] are used. */
 	uint64_t reserved_13_23               : 11;
 	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
 	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
@@ -3750,8 +3751,7 @@ union cvmx_pko_formatx_ctl {
 	uint64_t u64;
 	struct cvmx_pko_formatx_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_28_63               : 36;
-	uint64_t ip4_ck                       : 1;  /**< IPv4 header checksum recalculate */
+	uint64_t reserved_27_63               : 37;
 	uint64_t offset                       : 11; /**< Bits to add to PKO_SEND_EXT_S[MARKPTR]*8 to determine where to start marking. */
 	uint64_t y_mask                       : 4;  /**< Yellow mark mask. Corresponding bits in packet's data are cleared when marking packet yellow. */
 	uint64_t y_val                        : 4;  /**< Yellow mark value. Corresponding bits in packet's data are set when marking packet yellow. */
@@ -3763,8 +3763,7 @@ union cvmx_pko_formatx_ctl {
 	uint64_t y_val                        : 4;
 	uint64_t y_mask                       : 4;
 	uint64_t offset                       : 11;
-	uint64_t ip4_ck                       : 1;
-	uint64_t reserved_28_63               : 36;
+	uint64_t reserved_27_63               : 37;
 #endif
 	} s;
 	struct cvmx_pko_formatx_ctl_s         cn78xx;
@@ -4093,13 +4092,19 @@ union cvmx_pko_l1_sqx_shape {
 	uint64_t u64;
 	struct cvmx_pko_l1_sqx_shape_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_18_63               : 46;
+	uint64_t reserved_25_63               : 39;
+	uint64_t length_disable               : 1;  /**< N/A */
+	uint64_t reserved_18_23               : 6;
 	uint64_t link                         : 5;  /**< Link index. Must match PKO_L1_SQ()_TOPOLOGY[LINK]. */
-	uint64_t reserved_0_12                : 13;
+	uint64_t reserved_9_12                : 4;
+	uint64_t adjust                       : 9;  /**< N/A */
 #else
-	uint64_t reserved_0_12                : 13;
+	uint64_t adjust                       : 9;
+	uint64_t reserved_9_12                : 4;
 	uint64_t link                         : 5;
-	uint64_t reserved_18_63               : 46;
+	uint64_t reserved_18_23               : 6;
+	uint64_t length_disable               : 1;
+	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
 	struct cvmx_pko_l1_sqx_shape_s        cn78xx;
@@ -4602,8 +4607,9 @@ union cvmx_pko_l2_sqx_shape {
 	struct cvmx_pko_l2_sqx_shape_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
-	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in shaping calculations such that only
-                                                         the values of PKO_L2_SQ()_SHAPE[ADJUST] and PKO_SEND_EXT_S[SHAPECHG] are used. */
+	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
+                                                         and shaping calculations such that only the values of
+                                                         PKO_L2_SQ()_SHAPE[ADJUST] and PKO_SEND_EXT_S[SHAPECHG] are used. */
 	uint64_t reserved_13_23               : 11;
 	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
 	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
@@ -5113,8 +5119,9 @@ union cvmx_pko_l3_sqx_shape {
 	struct cvmx_pko_l3_sqx_shape_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
-	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in shaping calculations such that only
-                                                         the value of the ADJUST field is used. */
+	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
+                                                         and shaping calculations such that only the values of
+                                                         PKO_L3_SQ()_SHAPE[ADJUST] and PKO_SEND_EXT_S[SHAPECHG] are used. */
 	uint64_t reserved_13_23               : 11;
 	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
 	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
@@ -5579,8 +5586,9 @@ union cvmx_pko_l4_sqx_shape {
 	struct cvmx_pko_l4_sqx_shape_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
-	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in shaping calculations such that only
-                                                         the value of the ADJUST field is used. */
+	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
+                                                         and shaping calculations such that only the values of
+                                                         PKO_L3_SQ()_SHAPE[ADJUST] and PKO_SEND_EXT_S[SHAPECHG] are used. */
 	uint64_t reserved_13_23               : 11;
 	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
 	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
@@ -6048,8 +6056,9 @@ union cvmx_pko_l5_sqx_shape {
 	struct cvmx_pko_l5_sqx_shape_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
-	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in shaping calculations such that only
-                                                         the value of PKO_L5_SQ()_SHAPE[ADJUST]. */
+	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
+                                                         and shaping calculations such that only the values of
+                                                         PKO_L5_SQ()_SHAPE[ADJUST] and PKO_SEND_EXT_S[SHAPECHG] are used. */
 	uint64_t reserved_13_23               : 11;
 	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
 	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
@@ -6387,6 +6396,12 @@ typedef union cvmx_pko_lut_ecc_sbe_sts_cmb0 cvmx_pko_lut_ecc_sbe_sts_cmb0_t;
 
 /**
  * cvmx_pko_mac#_cfg
+ *
+ * These registers create the links between the MACs and the TxFIFO used to store the data, and
+ * hold
+ * the per-MAC configuration bits.  These registers must be disabled (FIFO_NUM set to 0x1f) prior
+ * to
+ * reconfiguration of any of the other bits.
  */
 union cvmx_pko_macx_cfg {
 	uint64_t u64;
@@ -6442,7 +6457,9 @@ union cvmx_pko_mci0_max_credx {
 	struct cvmx_pko_mci0_max_credx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
-	uint64_t max_cred_lim                 : 12; /**< Max credit limit. */
+	uint64_t max_cred_lim                 : 12; /**< Max credit limit.  Should be set to (FIFO_CREDIT - MAC_CREDIT) / 16, where FIFO_CREDIT
+                                                         is the size of the TxFIFO for this MAC (2560, 5120 or 10240), and MAC_CREDIT is the size
+                                                         of the MAC FIFO. */
 #else
 	uint64_t max_cred_lim                 : 12;
 	uint64_t reserved_12_63               : 52;
@@ -6478,7 +6495,8 @@ union cvmx_pko_mci1_max_credx {
 	struct cvmx_pko_mci1_max_credx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
-	uint64_t max_cred_lim                 : 12; /**< Max credit limit. */
+	uint64_t max_cred_lim                 : 12; /**< Max credit limit.  Should be set to (MAC_CREDIT) / 16, where MAC_CREDIT is
+                                                         the size of the MAC FIFO. */
 #else
 	uint64_t max_cred_lim                 : 12;
 	uint64_t reserved_12_63               : 52;
@@ -8730,12 +8748,26 @@ union cvmx_pko_ncb_int {
 	uint64_t u64;
 	struct cvmx_pko_ncb_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_1_63                : 63;
+	uint64_t reserved_2_63                : 62;
+	uint64_t tso_segment_cnt              : 1;  /**< Message segment size is too small to transmit entire packet within the
+                                                         maximum allowed number of segments in TCP segmentation offload. The
+                                                         packet will be transmitted in multiple TSO segments till the maximum
+                                                         number of segments is reached. At this point, the interrupt will be
+                                                         raised, transmission of the packet will cease, and other available
+                                                         packets will be transmitted. This interrupt shares the NCB_TX_ERROR_INFO
+                                                         and NCB_TX_ERROR_WORD registers with the NCB_TX_ERROR interrupt to
+                                                         record information about the erroneous send packet command. Hence,
+                                                         NCB_TX_ERROR_INFO and NCB_TX_ERROR interrupts are onehot; neither
+                                                         will be set till both are cleared. The TSO engine makes no guarantees
+                                                         about the state of memory and pointers allocated for the packet if
+                                                         this interrupt is raised. Throws
+                                                         PKO_INTSN_E::PKO_NCB_TSO_SEGMENT_CNT. */
 	uint64_t ncb_tx_error                 : 1;  /**< NCB transaction error occurred (error/unpredictable/undefined). Throws
                                                          PKO_INTSN_E::PKO_NCB_TX_ERR. */
 #else
 	uint64_t ncb_tx_error                 : 1;
-	uint64_t reserved_1_63                : 63;
+	uint64_t tso_segment_cnt              : 1;
+	uint64_t reserved_2_63                : 62;
 #endif
 	} s;
 	struct cvmx_pko_ncb_int_s             cn78xx;
@@ -10019,9 +10051,9 @@ union cvmx_pko_peb_bist_status {
 	uint64_t send_mem_fifo                : 1;  /**< SEND_MEM_FIFO RAM BIST status. */
 	uint64_t pkt_mrk_ram                  : 1;  /**< PKT_MRK RAM BIST status. */
 	uint64_t peb_st_inf_ram               : 1;  /**< PEB_ST_INF RAM BIST status. */
-	uint64_t reserved_0_0                 : 1;
+	uint64_t peb_sm_jmp_ram               : 1;  /**< PEB_SM_JMP RAM BIST status (Pass 1 only). */
 #else
-	uint64_t reserved_0_0                 : 1;
+	uint64_t peb_sm_jmp_ram               : 1;
 	uint64_t peb_st_inf_ram               : 1;
 	uint64_t pkt_mrk_ram                  : 1;
 	uint64_t send_mem_fifo                : 1;
@@ -10071,7 +10103,8 @@ union cvmx_pko_peb_ecc_ctl0 {
 	uint64_t pdm_resp_buf_ram_cdis        : 1;  /**< PDM_RESP_BUF_RAM ECC correction disable. */
 	uint64_t pdm_pse_buf_ram_flip         : 2;  /**< PDM_PSE_BUF_RAM flip syndrome bits on write. */
 	uint64_t pdm_pse_buf_ram_cdis         : 1;  /**< PDM_PSE_BUF_RAM ECC correction disable. */
-	uint64_t reserved_46_48               : 3;
+	uint64_t peb_sm_jmp_ram_flip          : 2;  /**< PEB_SM_JMP_RAM flip syndrome bits on write. */
+	uint64_t peb_sm_jmp_ram_cdis          : 1;  /**< PEB_SM_JMP_RAM ECC correction disable. */
 	uint64_t peb_st_inf_ram_flip          : 2;  /**< PEB_ST_INF_RAM flip syndrome bits on write. */
 	uint64_t peb_st_inf_ram_cdis          : 1;  /**< PEB_ST_INF_RAM ECC correction disable. */
 	uint64_t pd_bank3_ram_flip            : 2;  /**< PD_BANK3_RAM flip syndrome bits on write. */
@@ -10135,7 +10168,8 @@ union cvmx_pko_peb_ecc_ctl0 {
 	uint64_t pd_bank3_ram_flip            : 2;
 	uint64_t peb_st_inf_ram_cdis          : 1;
 	uint64_t peb_st_inf_ram_flip          : 2;
-	uint64_t reserved_46_48               : 3;
+	uint64_t peb_sm_jmp_ram_cdis          : 1;
+	uint64_t peb_sm_jmp_ram_flip          : 2;
 	uint64_t pdm_pse_buf_ram_cdis         : 1;
 	uint64_t pdm_pse_buf_ram_flip         : 2;
 	uint64_t pdm_resp_buf_ram_cdis        : 1;
@@ -10189,7 +10223,8 @@ union cvmx_pko_peb_ecc_dbe_sts0 {
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
 	uint64_t pdm_pse_buf_ram_dbe          : 1;  /**< Double-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
-	uint64_t reserved_58_58               : 1;
+	uint64_t peb_sm_jmp_ram_dbe           : 1;  /**< Double-bit error for PEB_SM_JMP_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i */
 	uint64_t peb_st_inf_ram_dbe           : 1;  /**< Double-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
 	uint64_t pd_bank3_ram_dbe             : 1;  /**< Double-bit error for PD_BANK3_RAM. INTERNAL: Instances:
@@ -10241,7 +10276,7 @@ union cvmx_pko_peb_ecc_dbe_sts0 {
 	uint64_t pd_bank2_ram_dbe             : 1;
 	uint64_t pd_bank3_ram_dbe             : 1;
 	uint64_t peb_st_inf_ram_dbe           : 1;
-	uint64_t reserved_58_58               : 1;
+	uint64_t peb_sm_jmp_ram_dbe           : 1;
 	uint64_t pdm_pse_buf_ram_dbe          : 1;
 	uint64_t pdm_resp_buf_ram_dbe         : 1;
 	uint64_t iobp1_fifo_ram_dbe           : 1;
@@ -10312,7 +10347,8 @@ union cvmx_pko_peb_ecc_sbe_sts0 {
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pdm_resp_buf_i */
 	uint64_t pdm_pse_buf_ram_sbe          : 1;  /**< Single-bit error for PDM_PSE_BUF_RAM. INTERNAL: Instances:
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_pdm_intf_i.pko_peb_pse_buf_i */
-	uint64_t reserved_58_58               : 1;
+	uint64_t peb_sm_jmp_ram_sbe           : 1;  /**< Single-bit error for PEB_SM_JMP_RAM. INTERNAL: Instances:
+                                                         pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_sm_jmp_uid_mem_i */
 	uint64_t peb_st_inf_ram_sbe           : 1;  /**< Single-bit error for PEB_ST_INF_RAM. INTERNAL: Instances:
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_state_info_mem_i */
 	uint64_t pd_bank3_ram_sbe             : 1;  /**< Single-bit error for PD_BANK3_RAM. INTERNAL: Instances:
@@ -10364,7 +10400,7 @@ union cvmx_pko_peb_ecc_sbe_sts0 {
 	uint64_t pd_bank2_ram_sbe             : 1;
 	uint64_t pd_bank3_ram_sbe             : 1;
 	uint64_t peb_st_inf_ram_sbe           : 1;
-	uint64_t reserved_58_58               : 1;
+	uint64_t peb_sm_jmp_ram_sbe           : 1;
 	uint64_t pdm_pse_buf_ram_sbe          : 1;
 	uint64_t pdm_resp_buf_ram_sbe         : 1;
 	uint64_t iobp1_fifo_ram_sbe           : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index 8398ddb..9db8d35 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -199,14 +199,16 @@ union cvmx_rst_boot {
                                                          automatically. */
 	uint64_t reserved_37_56               : 20;
 	uint64_t c_mul                        : 7;  /**< Core-clock multiplier. C_MUL = (core-clock speed) / (ref-clock speed). 'ref-clock speed'
-                                                         should always be 50MHz. */
+                                                         should always be 50MHz.
+                                                         INTERNAL:  C_MUL is set from the pi_pll_mul pins plus 6. */
 	uint64_t pnr_mul                      : 6;  /**< Coprocessor-clock multiplier. PNR_MUL = (coprocessor-clock speed) /(ref-clock speed).
-                                                         'ref-clock speed' should always be 50MHz. */
+                                                         'ref-clock speed' should always be 50MHz.
+                                                         INTERNAL:  C_MUL is set from the pi_pnr_pll_mul pins plus 6. */
 	uint64_t reserved_21_23               : 3;
 	uint64_t lboot_oci                    : 3;  /**< Last boot cause mask; resets only with DCOK.
-                                                         <20> = Warm reset due to OCI Link 2 going down.
-                                                         <19> = Warm reset due to OCI Link 1 going down.
-                                                         <18> = Warm reset due to OCI Link 0 going down. */
+                                                         <20> = Warm reset due to CCPI link 2 going down.
+                                                         <19> = Warm reset due to CCPI link 1 going down.
+                                                         <18> = Warm reset due to CCPI link 0 going down. */
 	uint64_t lboot_ext                    : 6;  /**< Last boot cause mask; resets only with DCOK.
                                                          <17> = Warm reset due to Cntl3 link-down or hot-reset.
                                                          <16> = Warm reset due to Cntl2 link-down or hot-reset.
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index 4e15a4d..0b852a4 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -1423,11 +1423,11 @@ union cvmx_sli_bist_status {
 	struct cvmx_sli_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t ncb_req                      : 1;  /**< BIST Status for IOI Request FIFO. */
+	uint64_t ncb_req                      : 1;  /**< BIST status for IOI Request FIFO. */
 	uint64_t n2p0_c                       : 1;  /**< BIST Status for N2P Port0 Cmd */
 	uint64_t n2p0_o                       : 1;  /**< BIST Status for N2P Port0 Data */
-	uint64_t n2p1_c                       : 1;  /**< BIST Status for N2P Port1 cmd. */
-	uint64_t n2p1_o                       : 1;  /**< BIST Status for N2P Port1 data. */
+	uint64_t n2p1_c                       : 1;  /**< BIST status for N2P Port1 cmd. */
+	uint64_t n2p1_o                       : 1;  /**< BIST status for N2P Port1 data. */
 	uint64_t cpl_p0                       : 1;  /**< BIST Status for CPL Port 0 */
 	uint64_t cpl_p1                       : 1;  /**< BIST Status for CPL Port 1 */
 	uint64_t reserved_19_24               : 6;
@@ -1649,7 +1649,7 @@ typedef union cvmx_sli_bist_status cvmx_sli_bist_status_t;
 /**
  * cvmx_sli_ctl_port#
  *
- * These registers contains control information for access for Port0 through Port3.
+ * These registers contains control information for access to ports.
  *
  */
 union cvmx_sli_ctl_portx {
@@ -1773,7 +1773,7 @@ union cvmx_sli_ctl_status {
 	uint64_t reserved_32_63               : 32;
 	uint64_t m2s1_ncbi                    : 4;  /**< Contains the IOBI that traffic from M2S1 is placed on. Values 2-15 are reserved. */
 	uint64_t m2s0_ncbi                    : 4;  /**< Contains the IOBI that traffic from M2S0 is placed on. Values 2-15 are reserved. */
-	uint64_t oci_id                       : 4;  /**< The OCI ID. */
+	uint64_t oci_id                       : 4;  /**< The CCPI ID. */
 	uint64_t p1_ntags                     : 6;  /**< Number of tags available for MAC port 1.
                                                          In RC mode, one tag is needed for each outbound TLP that requires a CPL TLP.
                                                          In EP mode, the number of tags required for a TLP request is 1 per 64-bytes of CPL data +
@@ -4078,14 +4078,14 @@ union cvmx_sli_int_sum {
 	uint64_t pidbof                       : 1;  /**< Packet instruction doorbell count overflowed. Which doorbell can be found in
                                                          DPI_PINT_INFO[PIDBOF]. Throws SLI_INTSN_E::SLI_INT_PIDBOF. */
 	uint64_t reserved_38_47               : 10;
-	uint64_t dtime                        : 2;  /**< Whenever SLI_DMA(0..1)_CNT[CNT] is not 0, the SLI_DMA(0..1)_TIM[TIM] timer increments
-                                                         every SLI clock. DTIME<x> is set whenever SLI_DMA(0..1)_TIM[TIM] >
-                                                         SLI_DMA(0..1)_INT_LEVEL[TIME]. DTIME<x> is normally cleared by clearing
-                                                         SLI_DMA(0..1)_CNT[CNT] (which also clears SLI_DMA(0..1)_TIM[TIM]). Throws
-                                                         SLI_INTSN_E::SLI_INT_DTIME. */
-	uint64_t dcnt                         : 2;  /**< DCNT<x> is set whenever SLI_DMAx_CNT[CNT] > SLI_DMA(0..1)_INT_LEVEL[CNT]. DCNT<x> is
-                                                         normally cleared by decreasing SLI_DMA(0..1)_CNT[CNT]. Throws SLI_INTSN_E::SLI_INT_DCNT. */
-	uint64_t dmafi                        : 2;  /**< DMA set forced interrupts. Throws SLI_INTSN_E::SLI_INT_DMAFI. */
+	uint64_t dtime                        : 2;  /**< Whenever SLI_DMA()_CNT[CNT] is not 0, the SLI_DMA()_TIM[TIM] timer increments
+                                                         every SLI clock. DTIME<x> is set whenever SLI_DMA()_TIM[TIM] >
+                                                         SLI_DMA()_INT_LEVEL[TIME]. DTIME<x> is normally cleared by clearing
+                                                         SLI_DMA()_CNT[CNT] (which also clears SLI_DMA()_TIM[TIM]). Throws
+                                                         SLI_INTSN_E::SLI_INT_DTIME0/1. */
+	uint64_t dcnt                         : 2;  /**< DCNT<x> is set whenever SLI_DMAx_CNT[CNT] > SLI_DMA()_INT_LEVEL[CNT]. DCNT<x> is
+                                                         normally cleared by decreasing SLI_DMA()_CNT[CNT]. Throws SLI_INTSN_E::SLI_INT_DCNT0/1. */
+	uint64_t dmafi                        : 2;  /**< DMA set forced interrupts. Throws SLI_INTSN_E::SLI_INT_DMAFI0/1. */
 	uint64_t reserved_29_31               : 3;
 	uint64_t vf_err                       : 1;  /**< Illegal access from VF. Throws SLI_INTSN_E::SLI_INT_VF_ERR. */
 	uint64_t m3_un_wi                     : 1;  /**< Received unsupported N-TLP for window register from MAC 3. This occurs when the window
@@ -4138,11 +4138,11 @@ union cvmx_sli_int_sum {
 	uint64_t pcnt                         : 1;  /**< Packet counter has an interrupt. The specific rings can be found in SLI_PKT_CNT_INT.
                                                          Throws SLI_INTSN_E::SLI_INT_PCNT. */
 	uint64_t reserved_1_3                 : 3;
-	uint64_t rml_to                       : 1;  /**< A read or write transfer to a RSL that did not complete within SLI_WINDOW_CTL[TIME] sclk
-                                                         cycles, or
-                                                         a notification from the OCI that is has sent a previously written command and can take
-                                                         another within
-                                                         SLI_WINDOW_CTL[OCX_TIME]. Throws a SLI_INTSN_E::SLI_INT_RML_TO. */
+	uint64_t rml_to                       : 1;  /**< A read or write transfer to a RSL that did not complete within
+                                                         SLI_WINDOW_CTL[TIME] coprocessor-clock cycles, or a notification from the CCPI
+                                                         that is has sent a previously written command and can take another within
+                                                         SLI_WINDOW_CTL[OCX_TIME].
+                                                         Throws SLI_INTSN_E::SLI_INT_RML_TO. */
 #else
 	uint64_t rml_to                       : 1;
 	uint64_t reserved_1_3                 : 3;
@@ -5292,27 +5292,28 @@ typedef union cvmx_sli_msi_wr_map cvmx_sli_msi_wr_map_t;
 /**
  * cvmx_sli_msix#_table_addr
  *
- * "The MSI-X table must be addressed on a 8-byte aligned boundary and cannot be burst read or
+ * The MSI-X table must be addressed on a 8-byte aligned boundary and cannot be burst read or
  * written.
  *
- * The MSI-X Table is 65 entries deep. Each MAC can see up to 64 VF ring entries and its own
- * PF entry.
- *
- * The first 64 entries contain MSI-X vectors for each of the 64 DPI Packet rings. Entries, or
- * rings, are assigned to PEM0 and/or PEM2 based on the SRN, RPVF, and TNR registers.  Each VF
- * has access to only its own entries and therefore will see the MSI-X Table as smaller than 64
- * entries, unless all 64 rings are assigned to it. A VF must not try to configure more entries
- * than it owns. A VF will always see its first entry as entry 0. The actual MSI-X Table Offset
- * is calculated as follows;   (SRN + ((VF#-1) * RPVF)).
- *
- *           RPVF - Rings VF believes it owns - Max \# VFs
- *             1        0                          64
- *             2        0,1                        32
- *             4        0,1,2,3                    16
- *             8        0,1,2,3,4,5,6,7             8
- *            16        0,1,2,...13,14,15           4
- *            32        0,1,2,...29,30,31           2
- *            64        0,1,2,...61,62,63           1
+ * The MSI-X Table is 65 entries deep. Each MAC can see up to 64 VF ring entries and its own PF
+ * entry. The first 64 entries contain MSI-X vectors for each of the 64 DPI packet rings.
+ * Entries, or rings, are assigned to PEM0 and/or PEM2 based on the SRN, RPVF, and TRS fields of
+ * SLI_PKT_MAC()_RINFO. Each VF has access to only its own entries and therefore sees the MSI-X
+ * table as smaller than 64 entries, unless all 64 rings are assigned to it. A VF must not try to
+ * configure more entries than it owns. A VF always sees its first entry as entry 0. The actual
+ * MSI-X table offset is calculated as follows:   (SRN + ((VF-1) * RPVF)).
+ *
+ * <pre>
+ *    RPVF   Rings VF believes it owns   Max VFs
+ *    ---    -------------------------   -------
+ *      1    0                           64
+ *      2    0,1                         32
+ *      4    0,1,2,3                     16
+ *      8    0,1,2,3,4,5,6,7              8
+ *     16    0,1,2,...13,14,15            4
+ *     32    0,1,2,...29,30,31            2
+ *     64    0,1,2,...61,62,63            1
+ * </pre>
  *
  * A MAC's PF can access the entries for its VF (a total of TNR, regardless of VF Mode).
  *
@@ -5320,8 +5321,8 @@ typedef union cvmx_sli_msi_wr_map cvmx_sli_msi_wr_map_t;
  * PF. There are actually two entries at the 65th location; one for each MAC's PF. The hardware
  * will enable writing to and reading from the appropriate entry based on the pcsr_src vector.
  *
- * In PF Mode there is no virtual function support, but a PF can configure up to 65 entries
- * (up to 64 VF rings + 1 PF ring) for itself."
+ * In PF mode, there is no virtual function support, but a PF can configure up to 65 entries
+ * (up to 64 VF rings + 1 PF ring) for itself.
  */
 union cvmx_sli_msixx_table_addr {
 	uint64_t u64;
@@ -5340,7 +5341,7 @@ typedef union cvmx_sli_msixx_table_addr cvmx_sli_msixx_table_addr_t;
  * cvmx_sli_msix#_table_data
  *
  * The MSI-X table must be addressed on a 8-byte aligned boundary and cannot be burst read or
- * written. F/PF access is the same as described for the SLI_MSIX(0..64)_TABLE_ADDR.
+ * written. F/PF access is the same as described for the SLI_MSIX()_TABLE_ADDR.
  */
 union cvmx_sli_msixx_table_data {
 	uint64_t u64;
@@ -5374,33 +5375,36 @@ typedef union cvmx_sli_msixx_table_data cvmx_sli_msixx_table_data_t;
  * Each VF can read their own pending completion interrupts based on the ring/VF
  * configuration. Therefore, a VF sees the PBA as smaller than what is shown below
  * (unless it owns all 64 entries).  Unassigned bits will return zeros.
- *           RPVF      Interrupts per VF       Pending bits returned
- *           ----      -----------------       ---------------------
- *             1                1               MSG_PND0
- *             2                2               MSG_PND1  - MSG_PND0
- *             4                4               MSG_PND3  - MSG_PND0
- *             8                8               MSG_PND7  - MSG_PND0
- *            16               16               MSG_PND15 - MSG_PND0
- *            32               32               MSG_PND31 - MSG_PND0
- *            64               64               MSG_PND63 - MSG_PND0
+ *
+ * <pre>
+ *    RPVF  Interrupts per VF   Pending bits returned
+ *    ----  -----------------   ---------------------
+ *      1            1          MSG_PND0
+ *      2            2          MSG_PND1  - MSG_PND0
+ *      4            4          MSG_PND3  - MSG_PND0
+ *      8            8          MSG_PND7  - MSG_PND0
+ *     16           16          MSG_PND15 - MSG_PND0
+ *     32           32          MSG_PND31 - MSG_PND0
+ *     64           64          MSG_PND63 - MSG_PND0
+ * </pre>
  *
  * In PF Mode there is no virtual function support, but the PF can configure up to 65
  * entries (up to 64 DPI Packet Rings plus 1 PF ring) for itself.
  *
- * In PF Mode, if SLI_PEM#_TNR=63 (i.e. 64 total DPI Packet Rings configured), a PF will
- * find its pending completion interrupts in bit positions [63:0]. When SLI_PEM#_TNR=63,
+ * In PF Mode, if SLI_PEM()_TNR=63 (i.e. 64 total DPI Packet Rings configured), a PF will
+ * find its pending completion interrupts in bit positions [63:0]. When SLI_PEM()_TNR=63,
  * the PF will find its PCIe error interrupt in SLI_MSIX_PBA1, bit position 0.
  *
- * If SLI_PEM#_TNR<63 (i.e. 1, 2, 4, 8, 16, or 32 rings configured), a PF will find its
+ * If SLI_PEM()_TNR<63 (i.e. 1, 2, 4, 8, 16, or 32 rings configured), a PF will find its
  * ring pending completion interrupts in bit positions [TNR:0]. It will find its PCIe
  * error interrupt in bit position [(TNR+1)]. Bits [63:(TNR+2)] are returned as zero.
- * When SLI_PEM#_TNR<63 in PF Mode, SLI_MSIX_PBA1 is not used and returns zeros."
+ * When SLI_PEM()_TNR<63 in PF Mode, SLI_MSIX_PBA1 is not used and returns zeros."
  */
 union cvmx_sli_msix_pba0 {
 	uint64_t u64;
 	struct cvmx_sli_msix_pba0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t msg_pnd                      : 64; /**< VF message pending[63:0] vector. */
+	uint64_t msg_pnd                      : 64; /**< VF message pending vector. */
 #else
 	uint64_t msg_pnd                      : 64;
 #endif
@@ -5412,14 +5416,16 @@ typedef union cvmx_sli_msix_pba0 cvmx_sli_msix_pba0_t;
 /**
  * cvmx_sli_msix_pba1
  *
- * "The MSI-X pending bit array must be addressed on a 8-byte aligned boundary and cannot be
+ * The MSI-X pending bit array must be addressed on a 8-byte aligned boundary and cannot be
  * burst read.
+ *
  * PF_PND is assigned to PCIe related errors. The error bit is only be found in PBA1 when the MAC
- * is in PF Mode (i.e. no virtualization) and SLI_PEM#_TNR=63 (i.e. 64 total DPI Packet Rings
+ * is in PF Mode (i.e. no virtualization) and SLI_PEM()_TNR=63 (i.e. 64 total DPI Packet Rings
  * configured).
+ *
  * This register is accessible by the PF; a VF read returns zeros. A read by a particular PF only
  * returns its own pending status. That is, both PFs read this register, but the hardware ensures
- * that the PF only sees its own status."
+ * that the PF only sees its own status.
  */
 union cvmx_sli_msix_pba1 {
 	uint64_t u64;
@@ -5713,10 +5719,10 @@ union cvmx_sli_pktx_input_control {
 	uint64_t reserved_27_28               : 2;
 	uint64_t rdsize                       : 2;  /**< Number of instructions to be read in one MAC read request for the 4 ports, 16 rings. Two
                                                          bit value are:
-                                                         0x0: 1 Instruction
-                                                         0x1: 2 Instructions
-                                                         0x2: 3 Instructions
-                                                         0x3: 4 Instructions */
+                                                         0x0 = 1 Instruction.
+                                                         0x1 = 2 Instructions.
+                                                         0x2 = 3 Instructions.
+                                                         0x3 = 4 Instructions. */
 	uint64_t is_64b                       : 1;  /**< When IS_64B=1, instruction input ring i uses 64B. */
 	uint64_t rst                          : 1;  /**< Packet reset. This bit is set for a ring when the ring enters the reset state. This can be
                                                          done by writing a 1 to the field, when a FLR associated with the ring occurs, or when an
@@ -5731,9 +5737,9 @@ union cvmx_sli_pktx_input_control {
 	uint64_t enb                          : 1;  /**< Packet output enable. When ENB<i>=1, packet output ring i is enabled.
                                                          When the ring is in reset, caused by a failing read associated with the ring, the ring
                                                          being put into
-                                                         reset by writing the reset bit assocaited with a ring, a FLR or the MAC the ring is
+                                                         reset by writing the reset bit associated with a ring, a FLR or the MAC the ring is
                                                          associated with
-                                                         being in reset, will cause this bit to clear and be able to be set againg till the reset
+                                                         being in reset, will cause this bit to clear and be able to be set again till the reset
                                                          condition is removed. */
 	uint64_t pbp_dhi                      : 13; /**< PBP_DHI replaces address bits that are used for parse mode and skip-length when
                                                          SLI_PKTi_INSTR_HEADER[PBP] = 1. PBP_DHI becomes either MACADD<63:55> or MACADD<59:51> for
@@ -6056,9 +6062,9 @@ union cvmx_sli_pktx_int_levels {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
 	uint64_t time                         : 22; /**< Output ring counter time interrupt threshold.
-                                                         SLI sets SLI_PKT_TIME_INT[PORT<i>] whenever SLI_PKT(0..63)_CNTS[TIMER] > TIME. */
+                                                         SLI sets SLI_PKT_TIME_INT[PORT<i>] whenever SLI_PKT()_CNTS[TIMER] > TIME. */
 	uint64_t cnt                          : 32; /**< Output ring counter interrupt threshold. SLI sets SLI_PKT_CNT_INT[PORT<i>] whenever
-                                                         SLI_PKT(0..63)_CNTS[CNT] > CNT. */
+                                                         SLI_PKT()_CNTS[CNT] > CNT. */
 #else
 	uint64_t cnt                          : 32;
 	uint64_t time                         : 22;
@@ -6122,37 +6128,38 @@ union cvmx_sli_pktx_output_control {
 	uint64_t iptr                         : 1;  /**< When IPTR=1, packet output ring is in info-pointer mode; otherwise the packet output ring
                                                          is in buffer-pointer-only mode. */
 	uint64_t es                           : 2;  /**< ES or MACADD<63:62> for buffer/info write operations to buffer/info pair MAC memory space
-                                                         addresses fetched from packet output ring. ES<1:0> if SLI_PKTx_OUTPUT_CONTROL[DPTR]=1,
+                                                         addresses fetched from packet output ring. ES<1:0> if SLI_PKT()_OUTPUT_CONTROL[DPTR]=1,
                                                          else MACADD<63:62>. In the latter case, ES<1:0> comes from DPTR<63:62>. ES<1:0> is the
                                                          endian-swap attribute for these MAC memory space writes. */
 	uint64_t nsr                          : 1;  /**< ADDRTYPE<1> or MACADD<61> for buffer/info write operations. NSR    becomes either
                                                          ADDRTYPE<1> or MACADD<61> for writes to buffer/info pair MAC memory space addresses
-                                                         fetched from packet output ring. ADDRTYPE<1> if SLI_PKTx_OUTPUT_CONTROL[DPTR]=1, else
+                                                         fetched from packet output ring. ADDRTYPE<1> if SLI_PKT()_OUTPUT_CONTROL[DPTR]=1, else
                                                          MACADD<61>. In the latter case, ADDRTYPE<1> comes from DPTR<61>. ADDRTYPE<1> is the no-
                                                          snoop attribute for PCIe. */
 	uint64_t ror                          : 1;  /**< ADDRTYPE<0> or MACADD<60> for buffer/info write operations. ROR    becomes either
                                                          ADDRTYPE<0> or MACADD<60> for writes to buffer/info pair MAC memory space addresses
-                                                         fetched from packet output ring. ADDRTYPE<0> if SLI_PKTx_OUTPUT_CONTROL[DPTR]=1, else
+                                                         fetched from packet output ring. ADDRTYPE<0> if SLI_PKT()_OUTPUT_CONTROL[DPTR]=1, else
                                                          MACADD<60>. In the latter case, ADDRTYPE<0> comes from DPTR<60>. ADDRTYPE<0> is the
                                                          relaxed-order attribute for PCIe. */
 	uint64_t dptr                         : 1;  /**< Determines whether buffer/info pointers are DPTR format 0 or DPTR format 1. When DPTR=1,
                                                          the buffer/info pointers fetched from packet output ring are DPTR format 0. When DPTR=0,
                                                          the buffer/info pointers fetched from packet output ring i are DPTR format 1. (Replace
-                                                         SLI_PKT(0..63)_INPUT_CONTROL[D_ESR,D_NSR,D_ROR] in the descriptions of DPTR format 0/1 in
-                                                         DPI Instruction Input Initialization with SLI_PKTx_OUTPUT_CONTROL[ES],
-                                                         SLI_PKTx_OUTPUT_CONTROL[NSR], and SLI_PKTx_OUTPUT_CONTROL[ROR], respectively, though.) */
-	uint64_t bmode                        : 1;  /**< Determines whether SLI_PKTx_CNTS[CNT] is a byte or packet counter. When BMODE=1,
-                                                         SLI_PKTx_CNTS[CNT] is a byte counter, else SLI_PKTx_CNTS[CNT] is a packet counter. */
+                                                         SLI_PKT()_INPUT_CONTROL[D_ESR,D_NSR,D_ROR] in the descriptions of DPTR format 0/1 in
+                                                         DPI Instruction Input Initialization with SLI_PKT()_OUTPUT_CONTROL[ES],
+                                                         SLI_PKT()_OUTPUT_CONTROL[NSR], and SLI_PKT()_OUTPUT_CONTROL[ROR], respectively, though.) */
+	uint64_t bmode                        : 1;  /**< Determines whether SLI_PKT()_CNTS[CNT] is a byte or packet counter. When BMODE=1,
+                                                         SLI_PKT()_CNTS[CNT] is a byte counter, else SLI_PKT()_CNTS[CNT] is a packet counter. */
 	uint64_t es_p                         : 2;  /**< ES<1:0> for the packet output ring reads that fetch buffer/info pointer pairs. ES<1:0> is
                                                          the endian-swap attribute for these MAC memory space reads. */
 	uint64_t nsr_p                        : 1;  /**< ADDRTYPE<1> or MACADD<61> for buffer/info write operations. NSR    becomes either
                                                          ADDRTYPE<1> or MACADD<61> for writes to buffer/info pair MAC memory space addresses
-                                                         fetched from packet output ring. ADDRTYPE<1> if SLI_PKT(0..63)_OUTPUT_CONTROL[DPTR]=1,
+                                                         fetched from packet output ring. ADDRTYPE<1> if SLI_PKT()_OUTPUT_CONTROL[DPTR]=1,
                                                          else MACADD<61>. In the latter case, ADDRTYPE<1> comes from DPTR<61>. ADDRTYPE<1> is the
                                                          no-snoop attribute for PCIe. */
 	uint64_t ror_p                        : 1;  /**< ADDRTYPE<0> for the packet output ring reads that fetch buffer/info pointer pairs. ROR
                                                          becomes ADDRTYPE<0> in DPI/SLI reads that fetch buffer/info pairs from packet output ring
-                                                         (from address SLI_PKTx_SLIST_BADDR+ in MAC memory space.) ADDRTYPE<0> is the relaxed-order
+                                                         (from address SLI_PKT()_SLIST_BADDR+ in MAC memory space.) ADDRTYPE<0> is the relaxed-
+                                                         order
                                                          attribute for PCIe. */
 	uint64_t enb                          : 1;  /**< Packet output enable. When ENB=1, packet output ring is enabled. When the ring is in
                                                          reset,
@@ -6160,8 +6167,7 @@ union cvmx_sli_pktx_output_control {
                                                          writing the reset bit associated with a ring, a FLR or the MAC the ring is associated with
                                                          being in reset, will cause this bit to clear and be able to be set again till the reset
                                                          condition is removed. This is a mirror of SLI_PKT_OUT_ENB (setting a bit here will set a
-                                                         bit
-                                                         in that CSR). */
+                                                         bit in that CSR). */
 #else
 	uint64_t enb                          : 1;
 	uint64_t ror_p                        : 1;
@@ -6338,7 +6344,7 @@ union cvmx_sli_pkt_cnt_int {
 	struct cvmx_sli_pkt_cnt_int_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ring                         : 64; /**< Output ring packet counter interrupt bits SLI sets RING<i> whenever
-                                                         SLI_PKT(0..63)_CNTS[CNT] > SLI_PKT(0..63)_INT_LEVELS[CNT]. SLI_PKT_CNT_INT_ENB[RING<i>] is
+                                                         SLI_PKT()_CNTS[CNT] > SLI_PKT()_INT_LEVELS[CNT]. SLI_PKT_CNT_INT_ENB[RING<i>] is
                                                          the corresponding enable. */
 #else
 	uint64_t ring                         : 64;
@@ -6615,8 +6621,8 @@ union cvmx_sli_pkt_in_donex_cnts {
                                                          field clears the corresponding bit in SLI_PKT_IN_INT[RING[\#]]." */
 	uint64_t reserved_49_61               : 13;
 	uint64_t cint_enb                     : 1;  /**< When set, allows corresponding bit in SLI_PKT_IN_INT[RING[\#]] to be set. */
-	uint64_t wmark                        : 16; /**< "When the value of SLI_PKT_IN_DONE(0..63)_CNTS[CNT[15:0]] is updated to be equal to
-                                                         SLI_PKT_IN_DONE(0..63)_CNTS[WMARK[15:0]] and SLI_PKT_IN_DONE(0..63)_CNTS[CINT_ENB] is also
+	uint64_t wmark                        : 16; /**< "When the value of SLI_PKT_IN_DONE()_CNTS[CNT[15:0]] is updated to be equal to
+                                                         SLI_PKT_IN_DONE()_CNTS[WMARK[15:0]] and SLI_PKT_IN_DONE()_CNTS[CINT_ENB] is also
                                                          set, the corresponding bit in SLI_PKT_IN_INT[RING[\#]] will be set." */
 	uint64_t cnt                          : 32; /**< This field is incrmented by '1' when an instruction
                                                          is completed. This field is incremented as the
@@ -6697,9 +6703,9 @@ union cvmx_sli_pkt_in_int {
 	uint64_t u64;
 	struct cvmx_sli_pkt_in_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ring                         : 64; /**< Set when SLI_PKT_IN_DONE(0..63)_CNTS[CNT[15:0]] is updated to be equal to
-                                                         SLI_PKT_IN_DONE(0..63)_CNTS[WMARK[15:0]] and SLI_PKT_IN_DONE(0..63)_CNTS[CINT_ENB] is set.
-                                                         Cleared when SLI_PKT_IN_DONE(0..63)_CNTS[PI_INT] is cleared. */
+	uint64_t ring                         : 64; /**< Set when SLI_PKT_IN_DONE()_CNTS[CNT[15:0]] is updated to be equal to
+                                                         SLI_PKT_IN_DONE()_CNTS[WMARK[15:0]] and SLI_PKT_IN_DONE()_CNTS[CINT_ENB] is set.
+                                                         Cleared when SLI_PKT_IN_DONE()_CNTS[PI_INT] is cleared. */
 #else
 	uint64_t ring                         : 64;
 #endif
@@ -6936,7 +6942,7 @@ typedef union cvmx_sli_pkt_input_control cvmx_sli_pkt_input_control_t;
  * cvmx_sli_pkt_instr_enb
  *
  * This register enables the instruction fetch for a packet ring. This is the PF version; also
- * see SLI_PKT(0..63)_INPUT_CONTROL[ENB].
+ * see SLI_PKT()_INPUT_CONTROL[ENB].
  */
 union cvmx_sli_pkt_instr_enb {
 	uint64_t u64;
@@ -7243,7 +7249,7 @@ union cvmx_sli_pkt_mem_ctl {
 	uint64_t posi_fs                      : 2;  /**< Used to flip the synd. for pout_signal_csr_flip_synd. */
 	uint64_t posi_ecc                     : 1;  /**< When set pout_signal_csr_cor_dis will have an ECC not generated and checked. */
 	uint64_t pos_fs                       : 2;  /**< Used to flip the synd. for pcsr_pout_size_csr_flip_synd. */
-	uint64_t pos_ecc                      : 1;  /**< When set  will have an ECC not generated and checked. */
+	uint64_t pos_ecc                      : 1;  /**< When set will have an ECC not generated and checked. */
 	uint64_t pinm_fs                      : 2;  /**< Used to flip the synd. for pcsr_instr_mem_csr_flip_synd. */
 	uint64_t pinm_ecc                     : 1;  /**< When set pcsr_instr_mem_csr_cor_dis will have an ECC not generated and checked. */
 	uint64_t pind_fs                      : 2;  /**< Used to flip the synd. for pcsr_in_done_csr_flip_synd. */
@@ -7373,7 +7379,7 @@ typedef union cvmx_sli_pkt_out_bp_en cvmx_sli_pkt_out_bp_en_t;
  * cvmx_sli_pkt_out_enb
  *
  * This register enables the output packet engines. This is the PF version; also see
- * SLI_PKT(0..63)_OUTPUT_CONTROL[ENB].
+ * SLI_PKT()_OUTPUT_CONTROL[ENB].
  */
 union cvmx_sli_pkt_out_enb {
 	uint64_t u64;
@@ -7415,7 +7421,7 @@ typedef union cvmx_sli_pkt_out_enb cvmx_sli_pkt_out_enb_t;
  * cvmx_sli_pkt_output_wmark
  *
  * This register sets the value that determines when backpressure is applied to the PKO. When
- * SLI_PKT(0..63)_SLIST_BAOFF_DBELL[DBELL] is less than [WMARK], backpressure is sent to PKO for
+ * SLI_PKT()_SLIST_BAOFF_DBELL[DBELL] is less than [WMARK], backpressure is sent to PKO for
  * the associated channel.
  */
 union cvmx_sli_pkt_output_wmark {
@@ -7508,7 +7514,7 @@ typedef union cvmx_sli_pkt_port_in_rst cvmx_sli_pkt_port_in_rst_t;
 /**
  * cvmx_sli_pkt_ring_rst
  *
- * This register shows which rings are in reset. See also SLI_PKT(0..63)_INPUT_CONTROL[RST].
+ * This register shows which rings are in reset. See also SLI_PKT()_INPUT_CONTROL[RST].
  *
  */
 union cvmx_sli_pkt_ring_rst {
@@ -7668,7 +7674,7 @@ union cvmx_sli_pkt_time_int {
 	struct cvmx_sli_pkt_time_int_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ring                         : 64; /**< Output ring packet timer interrupt bits SLI sets RING<i> whenever
-                                                         SLI_PKT(0..63)_CNTS[TIMER] > SLI_PKT_INT_LEVELS[TIME]. SLI_PKT_TIME_INT_ENB[RING<i>] is
+                                                         SLI_PKT()_CNTS[TIMER] > SLI_PKT()_INT_LEVELS[TIME]. SLI_PKT_TIME_INT_ENB[RING<i>] is
                                                          the corresponding enable. */
 #else
 	uint64_t ring                         : 64;
@@ -7785,10 +7791,11 @@ union cvmx_sli_s2m_portx_ctl {
 	struct cvmx_sli_s2m_portx_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
-	uint64_t lcl_node                     : 1;  /**< Local OCI node. When set to 1, all window access is treated as local OCI access. Normally,
-                                                         if address bits [37:36] of the window address CSRs are not equal to the chip's OCI value,
-                                                         the window operation is sent to the OCI for remote chip access. This field, when set,
-                                                         disables this and treats all access to be for the local OCI. */
+	uint64_t lcl_node                     : 1;  /**< Local CCPI node. When set to 1, all window access is treated as local CCPI
+                                                         access. Normally, if address bits [37:36] of the window address CSRs are not
+                                                         equal to the chip's CCPI value, the window operation is sent to the CCPI for
+                                                         remote chip access. This field, when set, disables this and treats all access to
+                                                         be for the local CCPI. */
 	uint64_t wind_d                       : 1;  /**< When set '1' disables access to the Window
                                                          Registers from the MAC-Port.
                                                          When Authenticate-Mode is set the reset value of
@@ -7852,15 +7859,16 @@ union cvmx_sli_s2m_portx_ctl {
 	struct cvmx_sli_s2m_portx_ctl_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
-	uint64_t lcl_node                     : 1;  /**< Local OCI node. When set to 1, all window access is treated as local OCI access. Normally,
-                                                         if address bits [37:36] of the window address CSRs are not equal to the chip's OCI value,
-                                                         the window operation is sent to the OCI for remote chip access. This field, when set,
-                                                         disables this and treats all access to be for the local OCI. */
+	uint64_t lcl_node                     : 1;  /**< Local CCPI node. When set to 1, all window access is treated as local CCPI
+                                                         access. Normally, if address bits [37:36] of the window address CSRs are not
+                                                         equal to the chip's CCPI value, the window operation is sent to the CCPI for
+                                                         remote chip access. This field, when set, disables this and treats all access to
+                                                         be for the local CCPI. */
 	uint64_t wind_d                       : 1;  /**< Window disable. When set to 1, disables access to the window registers from the MAC port. */
 	uint64_t bar0_d                       : 1;  /**< BAR0 disable. When set to 1, disables access from the MAC to BAR0 for the following
                                                          address offsets:
-                                                         * 0x0-0x32F
-                                                         * 0x3CD0
+                                                         * 0x0-0x32F.
+                                                         * 0x3CD0.
                                                          * greater than 0x3D70, excluding 0x3E00. */
 	uint64_t ld_cmd                       : 2;  /**< When SLI issues a load command to the L2C that is to be cached, this field selects the
                                                          type of load command to use:
@@ -7885,7 +7893,7 @@ typedef union cvmx_sli_s2m_portx_ctl cvmx_sli_s2m_portx_ctl_t;
 /**
  * cvmx_sli_scratch_1
  *
- * A general purpose 64 bit register for SW use.
+ * This registers is a general purpose 64-bit scratch register for software use.
  *
  */
 union cvmx_sli_scratch_1 {
@@ -7913,7 +7921,7 @@ typedef union cvmx_sli_scratch_1 cvmx_sli_scratch_1_t;
 /**
  * cvmx_sli_scratch_2
  *
- * These registers are general purpose 64-bit scratch registers for software use.
+ * This registers is a general purpose 64-bit scratch register for software use.
  *
  */
 union cvmx_sli_scratch_2 {
@@ -8148,8 +8156,9 @@ typedef union cvmx_sli_tx_pipe cvmx_sli_tx_pipe_t;
  * When the LSB of this CSR is written, the address in this CSR will be read. The data returned
  * from this read will be placed in the WIN_RD_DATA CSR. This CSR should NOT be used to read
  * SLI_* registers.
- * If SLI_S2M_PORT(0..3)_CTL[LCL_NODE] the MAC that it is set for will not be able to write
- * SLI_WIN_RD_ADDR[37:36] which will always be written with the chips OCI-ID.
+ *
+ * If SLI_S2M_PORT()_CTL[LCL_NODE] the MAC that it is set for will not be able to write
+ * SLI_WIN_RD_ADDR[37:36] which will always be written with the chips CCPI-ID.
  */
 union cvmx_sli_win_rd_addr {
 	uint64_t u64;
@@ -8219,17 +8228,21 @@ typedef union cvmx_sli_win_rd_data cvmx_sli_win_rd_data_t;
 /**
  * cvmx_sli_win_wr_addr
  *
- * Add Lock Register (Set on Read, Clear on write), SW uses to control access to BAR0 space.
- * Total Address is 16Kb; 0x0000 - 0x3fff, 0x000 - 0x7fe(Reg, every other 8B)
- * General  5kb; 0x0000 - 0x13ff, 0x000 - 0x27e(Reg-General)
- * PktMem  10Kb; 0x1400 - 0x3bff, 0x280 - 0x77e(Reg-General-Packet)
- * Rsvd     1Kb; 0x3c00 - 0x3fff, 0x780 - 0x7fe(Reg-NCB Only Mode)
- * SLI_WIN_WR_ADDR = SLI Window Write Address Register
- * Contains the address to be writen to when a write operation is started by writing the
- * SLI_WIN_WR_DATA register (see below).
+ * Add Lock Register (set on read, clear on write), software uses to control access to BAR0
+ * space.
+ *
+ * * Total Address is 16Kb; 0x0000 - 0x3fff, 0x000 - 0x7fe(Reg, every other 8B).
+ * * General  5kb; 0x0000 - 0x13ff, 0x000 - 0x27e(Reg-General).
+ * * PktMem  10Kb; 0x1400 - 0x3bff, 0x280 - 0x77e(Reg-General-Packet).
+ * * Rsvd     1Kb; 0x3c00 - 0x3fff, 0x780 - 0x7fe(Reg-NCB Only Mode).
+ *
+ * This register contains the address to be written to when a write operation is started by
+ * writing the SLI_WIN_WR_DATA register. This register should not be used to write SLI_*
+ *
  * This register should NOT be used to write SLI_* registers.
- * If SLI_S2M_PORT(0..3)_CTL[LCL_NODE] the MAC that it is set for will not be able to write
- * WR_ADDR[37:36] which will always be written with the chips OCI-ID.
+ *
+ * If SLI_S2M_PORT()_CTL[LCL_NODE] the MAC that it is set for will not be able to write
+ * SLI_WIN_WR_ADDR[37:36] which will always be written with the chips CCPI-ID.
  */
 union cvmx_sli_win_wr_addr {
 	uint64_t u64;
@@ -8342,9 +8355,9 @@ union cvmx_sli_window_ctl {
 	uint64_t u64;
 	struct cvmx_sli_window_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t ocx_time                     : 32; /**< OCX time. When a command acknowledge or a request to fetch read data is expected from OCI,
-                                                         SLI waits this many SCLKs before determining that the OCI is not going to respond and
-                                                         timeout the request. */
+	uint64_t ocx_time                     : 32; /**< OCX time. When a command acknowledge or a request to fetch read data is expected
+                                                         from CCPI, SLI waits this many SCLKs before determining that the CCPI is not
+                                                         going to respond and timeout the request. */
 	uint64_t time                         : 32; /**< Time to wait in core clocks for a
                                                          BAR0 access to completeon the NCB
                                                          before timing out. A value of 0 will cause no
diff --git a/arch/mips/include/asm/octeon/cvmx-sso-defs.h b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
index 3845262..9a043f9 100644
--- a/arch/mips/include/asm/octeon/cvmx-sso-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
@@ -2560,9 +2560,11 @@ union cvmx_sso_grpx_pri {
 	uint64_t reserved_30_63               : 34;
 	uint64_t wgt_left                     : 6;  /**< Cross-group arbitration credits remaining on this group. */
 	uint64_t reserved_22_23               : 2;
-	uint64_t weight                       : 6;  /**< Cross-group arbitration weight to apply to this group. Must be non-zero. */
+	uint64_t weight                       : 6;  /**< Cross-group arbitration weight to apply to this group. Must be >= 0x2. */
 	uint64_t reserved_12_15               : 4;
-	uint64_t affinity                     : 4;  /**< Processor affinity arbitration weight to apply to this group. If zero, affinity is disabled. */
+	uint64_t affinity                     : 4;  /**< Processor affinity arbitration weight to apply to this group. If zero, affinity
+                                                         is disabled. A change to AFFINITY will not take effect until the old AFFINITY's
+                                                         value loaded into SSO_PP()_ARB[AFF_LEFT] has drained to zero. */
 	uint64_t reserved_3_7                 : 5;
 	uint64_t pri                          : 3;  /**< Priority for this group relative to other groups. To prevent a core from receiving work on
                                                          a group use SSO_PP()_S()_GRPMSK().
@@ -2988,7 +2990,7 @@ union cvmx_sso_ientx_wqpgrp {
 	uint64_t nosched                      : 1;  /**< The nosched bit for the SSO entry. */
 	uint64_t reserved_58_59               : 2;
 	uint64_t grp                          : 10; /**< Group of the SSO entry.
-                                                         The upper bits are not stored in the RAM, but rather indicate the OCI node number. */
+                                                         The upper bits are not stored in the RAM, but rather indicate the CCPI node number. */
 	uint64_t reserved_42_47               : 6;
 	uint64_t wqp                          : 42; /**< Work queue pointer held in the SSO entry. */
 #else
-- 
2.6.2

