From 65005bb17dae12d030bc79eda24a1e98f494857a Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 19 Nov 2012 11:50:11 -0800
Subject: [PATCH 093/974] MIPS: OCTEON: Sync up HOTPLUG_CPU with bootloader
 structures.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/octeon_boot.h              |  95 ---------------
 arch/mips/cavium-octeon/setup.c                    |  17 +++
 arch/mips/cavium-octeon/smp.c                      | 126 +++++++++++---------
 .../asm/mach-cavium-octeon/kernel-entry-init.h     |  12 +-
 arch/mips/include/asm/octeon/octeon-boot-info.h    | 131 +++++++++++++++++++++
 5 files changed, 227 insertions(+), 154 deletions(-)
 delete mode 100644 arch/mips/cavium-octeon/octeon_boot.h
 create mode 100644 arch/mips/include/asm/octeon/octeon-boot-info.h

diff --git a/arch/mips/cavium-octeon/octeon_boot.h b/arch/mips/cavium-octeon/octeon_boot.h
deleted file mode 100644
index a6ce7c4..0000000
--- a/arch/mips/cavium-octeon/octeon_boot.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * (C) Copyright 2004, 2005 Cavium Networks
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __OCTEON_BOOT_H__
-#define __OCTEON_BOOT_H__
-
-#include <linux/types.h>
-
-struct boot_init_vector {
-	/* First stage address - in ram instead of flash */
-	uint64_t code_addr;
-	/* Setup code for application, NOT application entry point */
-	uint32_t app_start_func_addr;
-	/* k0 is used for global data - needs to be passed to other cores */
-	uint32_t k0_val;
-	/* Address of boot info block structure */
-	uint64_t boot_info_addr;
-	uint32_t flags;		/* flags */
-	uint32_t pad;
-};
-
-/* similar to bootloader's linux_app_boot_info but without global data */
-struct linux_app_boot_info {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint32_t labi_signature;
-	uint32_t start_core0_addr;
-	uint32_t avail_coremask;
-	uint32_t pci_console_active;
-	uint32_t icache_prefetch_disable;
-	uint32_t padding;
-	uint64_t InitTLBStart_addr;
-	uint32_t start_app_addr;
-	uint32_t cur_exception_base;
-	uint32_t no_mark_private_data;
-	uint32_t compact_flash_common_base_addr;
-	uint32_t compact_flash_attribute_base_addr;
-	uint32_t led_display_base_addr;
-#else
-	uint32_t start_core0_addr;
-	uint32_t labi_signature;
-
-	uint32_t pci_console_active;
-	uint32_t avail_coremask;
-
-	uint32_t padding;
-	uint32_t icache_prefetch_disable;
-
-	uint64_t InitTLBStart_addr;
-
-	uint32_t cur_exception_base;
-	uint32_t start_app_addr;
-
-	uint32_t compact_flash_common_base_addr;
-	uint32_t no_mark_private_data;
-
-	uint32_t led_display_base_addr;
-	uint32_t compact_flash_attribute_base_addr;
-#endif
-};
-
-/* If not to copy a lot of bootloader's structures
-   here is only offset of requested member */
-#define AVAIL_COREMASK_OFFSET_IN_LINUX_APP_BOOT_BLOCK	 0x765c
-
-/* hardcoded in bootloader */
-#define	 LABI_ADDR_IN_BOOTLOADER			 0x700
-
-#define LINUX_APP_BOOT_BLOCK_NAME "linux-app-boot"
-
-#define LABI_SIGNATURE 0xAABBCC01
-
-/*  from uboot-headers/octeon_mem_map.h */
-#define EXCEPTION_BASE_INCR	(4 * 1024)
-			       /* Increment size for exception base addresses (4k minimum) */
-#define EXCEPTION_BASE_BASE	0
-#define BOOTLOADER_PRIV_DATA_BASE	(EXCEPTION_BASE_BASE + 0x800)
-#define BOOTLOADER_BOOT_VECTOR		(BOOTLOADER_PRIV_DATA_BASE)
-
-#endif /* __OCTEON_BOOT_H__ */
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index acbb505..f311471 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -39,6 +39,7 @@
 #include <asm/time.h>
 
 #include <asm/octeon/octeon.h>
+#include <asm/octeon/octeon-boot-info.h>
 #include <asm/octeon/pci-octeon.h>
 #include <asm/octeon/cvmx-mio-defs.h>
 
@@ -261,6 +262,13 @@ static int octeon_uart;
 extern asmlinkage void handle_int(void);
 extern asmlinkage void plat_irq_dispatch(void);
 
+/*
+ * If set to a non-zero value, the bootloader entry point for
+ * HOTPLUG_CPU and other tricks.
+ */
+u64 octeon_bootloader_entry_addr;
+EXPORT_SYMBOL(octeon_bootloader_entry_addr);
+
 /* If an initrd named block is specified, its name goes here. */
 static char __initdata rd_name[64];
 
@@ -763,6 +771,7 @@ void __init prom_init(void)
 	struct cvmx_sysinfo *sysinfo;
 	const char *arg;
 	char *p;
+	struct linux_app_boot_info *labi;
 	int i;
 	int argc;
 #ifdef CONFIG_CAVIUM_RESERVE32
@@ -1007,6 +1016,14 @@ append_arg:
 
 	octeon_user_io_init();
 	register_smp_ops(&octeon_smp_ops);
+
+	labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
+	if (labi->labi_signature == LABI_SIGNATURE)
+		octeon_bootloader_entry_addr = labi->InitTLBStart_addr;
+
+#ifdef	SDK_VERSION
+	pr_info("Cavium Inc. SDK-" SDK_VERSION "\n");
+#endif
 }
 
 /* Exclude a single page from the regions obtained in plat_mem_setup. */
diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index 489c82d..9d37c62 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2004-2008, 2009, 2010 Cavium Networks
+ * Copyright (C) 2004 - 2012 Cavium, Inc.
  */
 #include <linux/cpu.h>
 #include <linux/init.h>
@@ -19,17 +19,17 @@
 #include <asm/setup.h>
 
 #include <asm/octeon/octeon.h>
-
-#include "octeon_boot.h"
+#include <asm/octeon/octeon-boot-info.h>
 
 volatile unsigned long octeon_processor_boot = 0xff;
 volatile unsigned long octeon_processor_sp;
 volatile unsigned long octeon_processor_gp;
 
 #ifdef CONFIG_HOTPLUG_CPU
-uint64_t octeon_bootloader_entry_addr;
-EXPORT_SYMBOL(octeon_bootloader_entry_addr);
+static uint32_t octeon_hotplug_entry_addr;
+extern void octeon_hotplug_entry(void);
 #endif
+struct cvmx_app_hotplug_global *octeon_hotplug_global_ptr;
 
 static void octeon_icache_flush(void)
 {
@@ -93,12 +93,18 @@ static irqreturn_t mailbox_interrupt(int irq, void *dev_id)
 	u64 action;
 	int i;
 
-	/* Make sure the function array initialization remains correct. */
+	/*
+	 * Make sure the function array initialization remains
+	 * correct.
+	 */
 	BUILD_BUG_ON(SMP_RESCHEDULE_YOURSELF != (1 << 0));
 	BUILD_BUG_ON(SMP_CALL_FUNCTION       != (1 << 1));
 	BUILD_BUG_ON(SMP_ICACHE_FLUSH        != (1 << 2));
 
-	/* Load the mailbox register to figure out what we're supposed to do */
+	/*
+	 * Load the mailbox register to figure out what we're supposed
+	 * to do.
+	 */
 	action = cvmx_read_csr(mbox_clrx);
 
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
@@ -142,22 +148,6 @@ static inline void octeon_send_ipi_mask(const struct cpumask *mask,
 		octeon_send_ipi_single(i, action);
 }
 
-/**
- * Detect available CPUs, populate cpu_possible_mask
- */
-static void octeon_smp_hotplug_setup(void)
-{
-#ifdef CONFIG_HOTPLUG_CPU
-	struct linux_app_boot_info *labi;
-
-	labi = (struct linux_app_boot_info *)PHYS_TO_XKSEG_CACHED(LABI_ADDR_IN_BOOTLOADER);
-	if (labi->labi_signature != LABI_SIGNATURE)
-		panic("The bootloader version on this board is incorrect.");
-
-	octeon_bootloader_entry_addr = labi->InitTLBStart_addr;
-#endif
-}
-
 static void octeon_smp_setup(void)
 {
 	const int coreid = cvmx_get_core_num();
@@ -167,6 +157,7 @@ static void octeon_smp_setup(void)
 #ifdef CONFIG_HOTPLUG_CPU
 	unsigned int num_cores = cvmx_octeon_num_cores();
 #endif
+	struct linux_app_boot_info *labi;
 
 	/* The present CPUs are initially just the boot cpu (CPU 0). */
 	for (id = 0; id < NR_CPUS; id++) {
@@ -190,6 +181,19 @@ static void octeon_smp_setup(void)
 	}
 
 #ifdef CONFIG_HOTPLUG_CPU
+
+	/*
+	 * HOTPLUG_CPU not possible if we don't know the bootloader
+	 * entrypoint.  Stop now before lulling people into thinking
+	 * it might work.
+	 */
+	if (!octeon_bootloader_entry_addr) {
+		if ((octeon_bootinfo->core_mask & 1) == 0)
+			panic("Linux not booted on core 0 with HOTPLUG_CPU");
+		else
+			panic("The bootloader version on this board is not compatible with HOTPLUG_CPU.");
+	}
+
 	/*
 	 * The possible CPUs are all those present on the chip.	 We
 	 * will assign CPU numbers for possible cores as well.	Cores
@@ -204,8 +208,21 @@ static void octeon_smp_setup(void)
 		}
 	}
 #endif
+	octeon_hotplug_global_ptr =
+		(struct cvmx_app_hotplug_global *) cvmx_bootmem_alloc_named_range(
+			CVMX_APP_HOTPLUG_INFO_REGION_SIZE, 0x0, 0x0, 0,
+			CVMX_APP_HOTPLUG_INFO_REGION_NAME);
+	if (!octeon_hotplug_global_ptr) {
+		pr_err("Failed to allocate memory for Hotplug memory block\n");
+		return;
+	}
+	memset(octeon_hotplug_global_ptr, 0, CVMX_APP_HOTPLUG_INFO_REGION_SIZE);
+
+	labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
+	octeon_hotplug_global_ptr->avail_coremask = labi->avail_coremask;
 
-	octeon_smp_hotplug_setup();
+	pr_info("Cavium Hotplug: Available coremask 0x%x\n",
+		octeon_hotplug_global_ptr->avail_coremask);
 }
 
 /**
@@ -260,12 +277,20 @@ void octeon_prepare_cpus(unsigned int max_cpus)
 {
 	u64 mask;
 #ifdef CONFIG_HOTPLUG_CPU
+	unsigned long t;
 	struct linux_app_boot_info *labi;
 
-	labi = (struct linux_app_boot_info *)PHYS_TO_XKSEG_CACHED(LABI_ADDR_IN_BOOTLOADER);
+	labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
 
 	if (labi->labi_signature != LABI_SIGNATURE)
 		panic("The bootloader version on this board is incorrect.");
+
+	t = __pa_symbol(octeon_hotplug_entry);
+
+	if (t >= 0x20000000)
+		panic("The kernel physical load address (%lx) is not compatible with CONFIG_HOTPLUG_CPU.\n", t);
+
+	octeon_hotplug_entry_addr = (uint32_t)CKSEG0ADDR(t);
 #endif
 	/*
 	 * Only the low order mailbox bits are used for IPIs, leave
@@ -336,10 +361,7 @@ static int octeon_cpu_disable(void)
 
 	set_cpu_online(cpu, false);
 	cpu_clear(cpu, cpu_callin_map);
-	local_irq_disable();
 	fixup_irqs();
-	local_irq_enable();
-
 	flush_cache_all();
 	local_flush_tlb_all();
 
@@ -361,27 +383,27 @@ static void octeon_cpu_die(unsigned int cpu)
 	 */
 
 	mask = 1 << coreid;
+	octeon_hotplug_global_ptr->avail_coremask |= mask;
+
 	/* LINUX_APP_BOOT_BLOCK is initialized in bootoct binary */
 	block_desc = cvmx_bootmem_find_named_block(LINUX_APP_BOOT_BLOCK_NAME);
 
 	if (!block_desc) {
 		struct linux_app_boot_info *labi;
 
-		labi = (struct linux_app_boot_info *)PHYS_TO_XKSEG_CACHED(LABI_ADDR_IN_BOOTLOADER);
+		labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
 
 		labi->avail_coremask |= mask;
 		new_mask = labi->avail_coremask;
 	} else {		       /* alternative, already initialized */
-		uint32_t *p = (uint32_t *)PHYS_TO_XKSEG_CACHED(block_desc->base_addr +
-							       AVAIL_COREMASK_OFFSET_IN_LINUX_APP_BOOT_BLOCK);
-		*p |= mask;
-		new_mask = *p;
+		new_mask = octeon_hotplug_global_ptr->avail_coremask;
 	}
 
-	pr_info("Reset core %d. Available Coremask = 0x%x \n", coreid, new_mask);
 	mb();
-	cvmx_write_csr(CVMX_CIU_PP_RST, 1 << coreid);
-	cvmx_write_csr(CVMX_CIU_PP_RST, 0);
+
+	pr_info("Reset core %d. Available Coremask = 0x%x\n",
+		coreid, new_mask);
+	cvmx_write_csr(CVMX_CIU_NMI, 1 << coreid);
 }
 
 void play_dead(void)
@@ -392,50 +414,38 @@ void play_dead(void)
 	octeon_processor_boot = 0xff;
 	per_cpu(cpu_state, cpu) = CPU_DEAD;
 
-	mb();
+	wmb(); /* nudge writeback */
 
 	while (1)	/* core will be reset here */
 		;
 }
 
-extern void kernel_entry(unsigned long arg1, ...);
-
-static void start_after_reset(void)
-{
-	kernel_entry(0, 0, 0);	/* set a2 = 0 for secondary core */
-}
-
 static int octeon_update_boot_vector(unsigned int cpu)
 {
 
 	int coreid = cpu_logical_map(cpu);
-	uint32_t avail_coremask;
+	unsigned int avail_coremask;
 	const struct cvmx_bootmem_named_block_desc *block_desc;
-	struct boot_init_vector *boot_vect =
-		(struct boot_init_vector *)PHYS_TO_XKSEG_CACHED(BOOTLOADER_BOOT_VECTOR);
+	struct boot_init_vector *boot_vect = phys_to_virt(BOOTLOADER_BOOT_VECTOR);
 
 	block_desc = cvmx_bootmem_find_named_block(LINUX_APP_BOOT_BLOCK_NAME);
 
 	if (!block_desc) {
 		struct linux_app_boot_info *labi;
 
-		labi = (struct linux_app_boot_info *)PHYS_TO_XKSEG_CACHED(LABI_ADDR_IN_BOOTLOADER);
+		labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
 
 		avail_coremask = labi->avail_coremask;
 		labi->avail_coremask &= ~(1 << coreid);
 	} else {		       /* alternative, already initialized */
-		avail_coremask = *(uint32_t *)PHYS_TO_XKSEG_CACHED(
-			block_desc->base_addr + AVAIL_COREMASK_OFFSET_IN_LINUX_APP_BOOT_BLOCK);
-	}
-
-	if (!(avail_coremask & (1 << coreid))) {
-		/* core not available, assume, that catched by simple-executive */
-		cvmx_write_csr(CVMX_CIU_PP_RST, 1 << coreid);
-		cvmx_write_csr(CVMX_CIU_PP_RST, 0);
+		avail_coremask = octeon_hotplug_global_ptr->avail_coremask;
+		if (!(avail_coremask & (1<<coreid)))
+			return -1;
 	}
+	/* This core is no longer available */
+	octeon_hotplug_global_ptr->avail_coremask &= ~(1<<coreid);
 
-	boot_vect[coreid].app_start_func_addr =
-		(uint32_t) (unsigned long) start_after_reset;
+	boot_vect[coreid].app_start_func_addr = octeon_hotplug_entry_addr;
 	boot_vect[coreid].code_addr = octeon_bootloader_entry_addr;
 
 	mb();
diff --git a/arch/mips/include/asm/mach-cavium-octeon/kernel-entry-init.h b/arch/mips/include/asm/mach-cavium-octeon/kernel-entry-init.h
index 21732c3..cab0212 100644
--- a/arch/mips/include/asm/mach-cavium-octeon/kernel-entry-init.h
+++ b/arch/mips/include/asm/mach-cavium-octeon/kernel-entry-init.h
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2005-2008 Cavium Networks, Inc
+ * Copyright (C) 2005-2012 Cavium, Inc
  */
 #ifndef __ASM_MACH_CAVIUM_OCTEON_KERNEL_ENTRY_H
 #define __ASM_MACH_CAVIUM_OCTEON_KERNEL_ENTRY_H
@@ -27,6 +27,16 @@
 	# a3 = address of boot descriptor block
 	.set push
 	.set arch=octeon
+#ifdef CONFIG_HOTPLUG_CPU
+	b	7f
+
+FEXPORT(octeon_hotplug_entry)
+	move	a0, zero
+	move	a1, zero
+	move	a2, zero
+	move	a3, zero
+7:
+#endif
 	# Read the cavium mem control register
 	dmfc0	v0, CP0_CVMMEMCTL_REG
 	# Clear the lower 6 bits, the CVMSEG size
diff --git a/arch/mips/include/asm/octeon/octeon-boot-info.h b/arch/mips/include/asm/octeon/octeon-boot-info.h
new file mode 100644
index 0000000..735ae88
--- /dev/null
+++ b/arch/mips/include/asm/octeon/octeon-boot-info.h
@@ -0,0 +1,131 @@
+/*
+ * (C) Copyright 2004, 2012 Cavium, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __OCTEON_BOOT_INFO_H__
+#define __OCTEON_BOOT_INFO_H__
+
+#include <linux/types.h>
+#include <asm/octeon/cvmx-spinlock.h>
+
+struct boot_init_vector {
+	/* First stage address - in ram instead of flash */
+	uint64_t code_addr;
+	/* Setup code for application, NOT application entry point */
+	uint32_t app_start_func_addr;
+	/* k0 is used for global data - needs to be passed to other cores */
+	uint32_t k0_val;
+	/* Address of boot info block structure */
+	uint64_t boot_info_addr;
+	uint32_t flags;		/* flags */
+	uint32_t pad;
+};
+
+/* similar to bootloader's linux_app_boot_info but without global data */
+struct linux_app_boot_info {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t labi_signature;
+	uint32_t start_core0_addr;
+	uint32_t avail_coremask;
+	uint32_t pci_console_active;
+	uint32_t icache_prefetch_disable;
+	uint32_t padding;
+	uint64_t InitTLBStart_addr;
+	uint32_t start_app_addr;
+	uint32_t cur_exception_base;
+	uint32_t no_mark_private_data;
+	uint32_t compact_flash_common_base_addr;
+	uint32_t compact_flash_attribute_base_addr;
+	uint32_t led_display_base_addr;
+#else
+	uint32_t start_core0_addr;
+	uint32_t labi_signature;
+
+	uint32_t pci_console_active;
+	uint32_t avail_coremask;
+
+	uint32_t padding;
+	uint32_t icache_prefetch_disable;
+
+	uint64_t InitTLBStart_addr;
+
+	uint32_t cur_exception_base;
+	uint32_t start_app_addr;
+
+	uint32_t compact_flash_common_base_addr;
+	uint32_t no_mark_private_data;
+
+	uint32_t led_display_base_addr;
+	uint32_t compact_flash_attribute_base_addr;
+#endif
+};
+
+/*
+ * The size of this struct should be a fixed size of 1024 bytes.
+ * Additional members should be added towards the end of the strcuture
+ * by adjusting the size of padding.
+ */
+struct cvmx_app_hotplug_info {
+	char app_name[256];
+	uint32_t coremask;
+	uint32_t volatile hotplug_activated_coremask;
+	int32_t valid;
+	int32_t volatile shutdown_done;
+	uint64_t shutdown_callback;
+	uint64_t unplug_callback;
+	uint64_t cores_added_callback;
+	uint64_t cores_removed_callback;
+	uint64_t hotplug_start;
+	uint64_t data;
+	uint32_t volatile hplugged_cores;
+	uint32_t shutdown_cores;
+	uint32_t app_shutdown;
+	uint32_t unplug_cores;
+	uint32_t padding[172];
+};
+
+struct cvmx_app_hotplug_global {
+	uint32_t avail_coremask;
+	struct cvmx_app_hotplug_info hotplug_info_array[32];
+	uint32_t version;
+	cvmx_spinlock_t hotplug_global_lock;
+	int32_t app_under_boot;
+	int32_t app_under_shutdown;
+};
+#define CVMX_APP_HOTPLUG_INFO_REGION_SIZE  sizeof(struct cvmx_app_hotplug_global)
+#define CVMX_APP_HOTPLUG_INFO_REGION_NAME  "cvmx-app-hotplug-block"
+
+/* If not to copy a lot of bootloader's structures
+   here is only offset of requested member */
+#define AVAIL_COREMASK_OFFSET_IN_LINUX_APP_BOOT_BLOCK	 0x765c
+
+/* hardcoded in bootloader */
+#define	 LABI_ADDR_IN_BOOTLOADER			 0x700
+
+#define LINUX_APP_BOOT_BLOCK_NAME "linux-app-boot"
+
+#define LABI_SIGNATURE 0xAABBCC01
+
+/*  from uboot-headers/octeon_mem_map.h */
+#define EXCEPTION_BASE_INCR	(4 * 1024)
+			       /* Increment size for exception base addresses (4k minimum) */
+#define EXCEPTION_BASE_BASE	0
+#define BOOTLOADER_PRIV_DATA_BASE	(EXCEPTION_BASE_BASE + 0x800)
+#define BOOTLOADER_BOOT_VECTOR		(BOOTLOADER_PRIV_DATA_BASE)
+
+#endif /* __OCTEON_BOOT_INFO_H__ */
-- 
2.6.2

