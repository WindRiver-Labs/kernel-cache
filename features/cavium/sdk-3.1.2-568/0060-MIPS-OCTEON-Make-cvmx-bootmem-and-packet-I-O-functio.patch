From 8ecf9f69ae95f2e5b19211c39bf2d45ffe68cda4 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 27 Sep 2012 14:53:54 -0700
Subject: [PATCH 060/974] MIPS: OCTEON: Make cvmx-bootmem and packet I/O
 functions work Little Endian.

Update the bootmem allocator for Little Endian compatibility.

Add Little Endian structure definitions for packet I/O hardware.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bootmem.c   | 1253 ++++++++++++++------
 arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c |    2 +-
 arch/mips/cavium-octeon/setup.c                    |    2 +-
 arch/mips/include/asm/octeon/cvmx-address.h        |   69 +-
 arch/mips/include/asm/octeon/cvmx-bootmem.h        |  331 ++++--
 arch/mips/include/asm/octeon/cvmx-fau.h            |  139 ++-
 arch/mips/include/asm/octeon/cvmx-packet.h         |    8 +
 arch/mips/include/asm/octeon/octeon-model.h        |    7 +
 8 files changed, 1306 insertions(+), 505 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
index 504ed61..c04e06b 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,37 +22,242 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
+#include <linux/export.h>
 
-/*
- * Simple allocate only memory allocator.  Used to allocate memory at
- * application start time.
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-bootmem.h>
+
+/* #define DEBUG */
+
+#define ULL unsigned long long
+#undef	MAX
+#define MAX(a, b)  (((a) > (b)) ? (a) : (b))
+
+#undef	MIN
+#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
+
+#define ALIGN_ADDR_UP(addr, align)     (((addr) + (~(align))) & (align))
+
+/**
+ * This is the physical location of a cvmx_bootmem_desc_t
+ * structure in Octeon's memory. Note that dues to addressing
+ * limits or runtime environment it might not be possible to
+ * create a C pointer to this structure.
  */
+static uint64_t cvmx_bootmem_desc_addr;
 
-#include <linux/kernel.h>
-#include <linux/module.h>
+/**
+ * This macro returns the size of a member of a structure.
+ * Logically it is the same as "sizeof(s::field)" in C++, but
+ * C lacks the "::" operator.
+ */
+#define SIZEOF_FIELD(s, field) sizeof(((s *)NULL)->field)
+
+/**
+ * This macro returns a member of the cvmx_bootmem_desc_t
+ * structure. These members can't be directly addressed as
+ * they might be in memory not directly reachable. In the case
+ * where bootmem is compiled with LINUX_HOST, the structure
+ * itself might be located on a remote Octeon. The argument
+ * "field" is the member name of the cvmx_bootmem_desc_t to read.
+ * Regardless of the type of the field, the return type is always
+ * a uint64_t.
+ */
+#define CVMX_BOOTMEM_DESC_GET_FIELD(field)				\
+	__cvmx_bootmem_desc_get(cvmx_bootmem_desc_addr,			\
+		offsetof(cvmx_bootmem_desc_t, field),			\
+		SIZEOF_FIELD(cvmx_bootmem_desc_t, field))
+
+/**
+ * This macro writes a member of the cvmx_bootmem_desc_t
+ * structure. These members can't be directly addressed as
+ * they might be in memory not directly reachable. In the case
+ * where bootmem is compiled with LINUX_HOST, the structure
+ * itself might be located on a remote Octeon. The argument
+ * "field" is the member name of the cvmx_bootmem_desc_t to write.
+ */
+#define CVMX_BOOTMEM_DESC_SET_FIELD(field, value)			\
+	__cvmx_bootmem_desc_set(cvmx_bootmem_desc_addr,			\
+		offsetof(cvmx_bootmem_desc_t, field),			\
+		SIZEOF_FIELD(cvmx_bootmem_desc_t, field), value)
+
+/**
+ * This macro returns a member of the
+ * cvmx_bootmem_named_block_desc_t structure. These members can't
+ * be directly addressed as they might be in memory not directly
+ * reachable. In the case where bootmem is compiled with
+ * LINUX_HOST, the structure itself might be located on a remote
+ * Octeon. The argument "field" is the member name of the
+ * cvmx_bootmem_named_block_desc_t to read. Regardless of the type
+ * of the field, the return type is always a uint64_t. The "addr"
+ * parameter is the physical address of the structure.
+ */
+#define CVMX_BOOTMEM_NAMED_GET_FIELD(addr, field)			\
+	__cvmx_bootmem_desc_get(addr,					\
+		offsetof(cvmx_bootmem_named_block_desc_t, field),	\
+		SIZEOF_FIELD(cvmx_bootmem_named_block_desc_t, field))
+
+/**
+ * This macro writes a member of the cvmx_bootmem_named_block_desc_t
+ * structure. These members can't be directly addressed as
+ * they might be in memory not directly reachable. In the case
+ * where bootmem is compiled with LINUX_HOST, the structure
+ * itself might be located on a remote Octeon. The argument
+ * "field" is the member name of the
+ * cvmx_bootmem_named_block_desc_t to write. The "addr" parameter
+ * is the physical address of the structure.
+ */
+#define CVMX_BOOTMEM_NAMED_SET_FIELD(addr, field, value)		\
+	__cvmx_bootmem_desc_set(addr,					\
+		offsetof(cvmx_bootmem_named_block_desc_t, field),	\
+		SIZEOF_FIELD(cvmx_bootmem_named_block_desc_t, field), value)
+
+/**
+ * This function is the implementation of the get macros defined
+ * for individual structure members. The argument are generated
+ * by the macros inorder to read only the needed memory.
+ *
+ * @base:   64bit physical address of the complete structure
+ * @offset: Offset from the beginning of the structure to the member being
+ *               accessed.
+ * @size:   Size of the structure member.
+ *
+ * Returns Value of the structure member promoted into a uint64_t.
+ */
+static inline uint64_t __cvmx_bootmem_desc_get(uint64_t base, int offset,
+					       int size)
+{
+	base = (1ull << 63) | (base + offset);
+	switch (size) {
+	case 4:
+		return cvmx_read64_uint32(base);
+	case 8:
+		return cvmx_read64_uint64(base);
+	default:
+		return 0;
+	}
+}
 
-#include <asm/octeon/cvmx.h>
-#include <asm/octeon/cvmx-spinlock.h>
-#include <asm/octeon/cvmx-bootmem.h>
+/**
+ * This function is the implementation of the set macros defined
+ * for individual structure members. The argument are generated
+ * by the macros in order to write only the needed memory.
+ *
+ * @base:   64bit physical address of the complete structure
+ * @offset: Offset from the beginning of the structure to the member being
+ *               accessed.
+ * @size:   Size of the structure member.
+ * @value:  Value to write into the structure
+ */
+static inline void __cvmx_bootmem_desc_set(uint64_t base, int offset, int size,
+					   uint64_t value)
+{
+	base = (1ull << 63) | (base + offset);
+	switch (size) {
+	case 4:
+		cvmx_write64_uint32(base, value);
+		break;
+	case 8:
+		cvmx_write64_uint64(base, value);
+		break;
+	default:
+		break;
+	}
+}
 
-/*#define DEBUG */
+/**
+ * This function returns the address of the bootmem descriptor lock.
+ *
+ * Returns 64-bit address in KSEG0 of the bootmem descriptor block
+ */
+static inline uint64_t __cvmx_bootmem_get_lock_addr(void)
+{
+	return (1ull << 63) |
+	       (cvmx_bootmem_desc_addr + offsetof(cvmx_bootmem_desc_t, lock));
+}
+/**
+ * This function retrieves the string name of a named block. It is
+ * more complicated than a simple memcpy() since the named block
+ * descriptor may not be directly accessable.
+ *
+ * @addr:   Physical address of the named block descriptor
+ * @str:    String to receive the named block string name
+ * @len:    Length of the string buffer, which must match the length
+ *               stored in the bootmem descriptor.
+ */
+static void CVMX_BOOTMEM_NAMED_GET_NAME(uint64_t addr, char *str, int len)
+{
+	int l = len;
+	char *ptr = str;
+	addr |= (1ull << 63);
+	addr += offsetof(cvmx_bootmem_named_block_desc_t, name);
+	while (l) {
+		/*
+		 * With big-endian in memory byte order, this gives uniform
+		 * results for the CPU in either big or Little endian mode.
+		 */
+		uint64_t blob = cvmx_read64_uint64(addr);
+		int sa = 56;
+		addr += sizeof(uint64_t);
+		while (l && sa >= 0) {
+			*ptr++ = (char)(blob >> sa);
+			l--;
+			sa -= 8;
+		}
+	}
+	str[len] = 0;
+}
 
+/**
+ * This function stores the string name of a named block. It is
+ * more complicated than a simple memcpy() since the named block
+ * descriptor may not be directly accessable.
+ *
+ * @addr:   Physical address of the named block descriptor
+ * @str:    String to store into the named block string name
+ * @len:    Length of the string buffer, which must match the length
+ *               stored in the bootmem descriptor.
+ */
+void CVMX_BOOTMEM_NAMED_SET_NAME(uint64_t addr, const char *str, int len)
+{
+	int l = len;
+	addr |= (1ull << 63);
+	addr += offsetof(cvmx_bootmem_named_block_desc_t, name);
 
-static struct cvmx_bootmem_desc *cvmx_bootmem_desc;
+	while (l) {
+		/*
+		 * With big-endian in memory byte order, this gives uniform
+		 * results for the CPU in either big or Little endian mode.
+		 */
+		uint64_t blob = 0;
+		int sa = 56;
+		while (l && sa >= 0) {
+			uint64_t c = (uint8_t) (*str++);
+			l--;
+			if (l == 0)
+				c = 0;
+			blob |= c << sa;
+			sa -= 8;
+		}
+		cvmx_write64_uint64(addr, blob);
+		addr += sizeof(uint64_t);
+	}
+}
 
 /* See header file for descriptions of functions */
 
 /*
- * Wrapper functions are provided for reading/writing the size and
- * next block values as these may not be directly addressible (in 32
- * bit applications, for instance.)  Offsets of data elements in
- * bootmem list, must match cvmx_bootmem_block_header_t.
+ * Wrapper functions are provided for reading/writing the size and next block
+ * values as these may not be directly addressible (in 32 bit applications, for
+ * instance.)
+ *
+ * Offsets of data elements in bootmem list, must match
+ * cvmx_bootmem_block_header_t
  */
 #define NEXT_OFFSET 0
 #define SIZE_OFFSET 8
-
 static void cvmx_bootmem_phy_set_size(uint64_t addr, uint64_t size)
 {
 	cvmx_write64_uint64((addr + SIZE_OFFSET) | (1ull << 63), size);
@@ -73,18 +278,125 @@ static uint64_t cvmx_bootmem_phy_get_next(uint64_t addr)
 	return cvmx_read64_uint64((addr + NEXT_OFFSET) | (1ull << 63));
 }
 
+/**
+ * Check the version information on the bootmem descriptor
+ *
+ * @exact_match:
+ *               Exact major version to check against. A zero means
+ *               check that the version supports named blocks.
+ *
+ * Returns Zero if the version is correct. Negative if the version is
+ *         incorrect. Failures also cause a message to be displayed.
+ */
+static int __cvmx_bootmem_check_version(int exact_match)
+{
+	int major_version;
+	major_version = CVMX_BOOTMEM_DESC_GET_FIELD(major_version);
+	if ((major_version > 3)
+	    || (exact_match && major_version != exact_match)) {
+		cvmx_dprintf("ERROR: Incompatible bootmem descriptor version: %d.%d at addr: 0x%llx\n",
+			     major_version,
+			     (int)CVMX_BOOTMEM_DESC_GET_FIELD(minor_version),
+			     (ULL)cvmx_bootmem_desc_addr);
+		return -1;
+	} else
+		return 0;
+}
+
+/**
+ * Get the low level bootmem descriptor lock. If no locking
+ * is specified in the flags, then nothing is done.
+ *
+ * @flags:  CVMX_BOOTMEM_FLAG_NO_LOCKING means this functions should do
+ *               nothing. This is used to support nested bootmem calls.
+ */
+static inline void __cvmx_bootmem_lock(uint32_t flags)
+{
+	if (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING)) {
+		/*
+		 * Unfortunately we can't use the normal cvmx-spinlock code as
+		 * the memory for the bootmem descriptor may be not accessable
+		 * by a C pointer. We use a 64bit XKPHYS address to access the
+		 * memory directly
+		 */
+		uint64_t lock_addr = (1ull << 63) |
+			(cvmx_bootmem_desc_addr + offsetof(cvmx_bootmem_desc_t,
+							   lock));
+		unsigned int tmp;
+
+		__asm__ __volatile__(".set noreorder            \n"
+				     "1: ll   %[tmp], 0(%[addr])\n"
+				     "   bnez %[tmp], 1b        \n"
+				     "   li   %[tmp], 1         \n"
+				     "   sc   %[tmp], 0(%[addr])\n"
+				     "   beqz %[tmp], 1b        \n"
+				     "   nop                    \n"
+				     ".set reorder              \n"
+				     : [tmp] "=&r"(tmp)
+				     : [addr] "r"(lock_addr)
+				     : "memory");
+	}
+}
+
+/**
+ * Release the low level bootmem descriptor lock. If no locking
+ * is specified in the flags, then nothing is done.
+ *
+ * @flags:  CVMX_BOOTMEM_FLAG_NO_LOCKING means this functions should do
+ *               nothing. This is used to support nested bootmem calls.
+ */
+static inline void __cvmx_bootmem_unlock(uint32_t flags)
+{
+	if (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING)) {
+		/*
+		 * Unfortunately we can't use the normal cvmx-spinlock code as
+		 * the memory for the bootmem descriptor may be not accessable
+		 * by a C pointer. We use a 64bit XKPHYS address to access the
+		 * memory directly
+		 */
+		uint64_t lock_addr = __cvmx_bootmem_get_lock_addr();
+
+		CVMX_SYNCW;
+		__asm__ __volatile__("sw $0, 0(%[addr])\n"
+				     : : [addr] "r"(lock_addr)
+				     : "memory");
+		CVMX_SYNCW;
+	}
+}
+
+/*
+ * Some of the cvmx-bootmem functions dealing with C pointers are not
+ * supported when we are compiling for CVMX_BUILD_FOR_LINUX_HOST. This
+ * ifndef removes these functions when they aren't needed.
+ *
+ * This functions takes an address range and adjusts it as necessary
+ * to match the ABI that is currently being used.  This is required to
+ * ensure that bootmem_alloc* functions only return valid pointers for
+ * 32 bit ABIs
+ */
+static int __cvmx_validate_mem_range(uint64_t *min_addr_ptr,
+				     uint64_t *max_addr_ptr)
+{
+
+
+	return 0;
+}
+
 void *cvmx_bootmem_alloc_range(uint64_t size, uint64_t alignment,
 			       uint64_t min_addr, uint64_t max_addr)
 {
 	int64_t address;
-	address =
-	    cvmx_bootmem_phy_alloc(size, min_addr, max_addr, alignment, 0);
+
+	__cvmx_validate_mem_range(&min_addr, &max_addr);
+	address = cvmx_bootmem_phy_alloc(size, min_addr, max_addr,
+					 alignment, 0);
 
 	if (address > 0)
 		return cvmx_phys_to_ptr(address);
 	else
 		return NULL;
 }
+EXPORT_SYMBOL(cvmx_bootmem_alloc_range);
 
 void *cvmx_bootmem_alloc_address(uint64_t size, uint64_t address,
 				 uint64_t alignment)
@@ -97,83 +409,129 @@ void *cvmx_bootmem_alloc(uint64_t size, uint64_t alignment)
 {
 	return cvmx_bootmem_alloc_range(size, alignment, 0, 0);
 }
+EXPORT_SYMBOL(cvmx_bootmem_alloc);
 
-void *cvmx_bootmem_alloc_named_range(uint64_t size, uint64_t min_addr,
-				     uint64_t max_addr, uint64_t align,
-				     char *name)
+void *cvmx_bootmem_alloc_named_range_once(uint64_t size, uint64_t min_addr,
+					  uint64_t max_addr, uint64_t align,
+					  const char *name,
+					  void (*init) (void *))
 {
 	int64_t addr;
+	void *ptr;
+	uint64_t named_block_desc_addr;
+
+	__cvmx_bootmem_lock(0);
+
+	__cvmx_validate_mem_range(&min_addr, &max_addr);
+	named_block_desc_addr =
+		cvmx_bootmem_phy_named_block_find(name,
+						  CVMX_BOOTMEM_FLAG_NO_LOCKING);
+
+	if (named_block_desc_addr) {
+		addr = CVMX_BOOTMEM_NAMED_GET_FIELD(named_block_desc_addr,
+						    base_addr);
+		__cvmx_bootmem_unlock(0);
+		return cvmx_phys_to_ptr(addr);
+	}
 
 	addr = cvmx_bootmem_phy_named_block_alloc(size, min_addr, max_addr,
-						  align, name, 0);
+						  align, name,
+						  CVMX_BOOTMEM_FLAG_NO_LOCKING);
+
+	if (addr < 0) {
+		__cvmx_bootmem_unlock(0);
+		return NULL;
+	}
+	ptr = cvmx_phys_to_ptr(addr);
+	if (init)
+		init(ptr);
+	__cvmx_bootmem_unlock(0);
+	return ptr;
+}
+
+void *cvmx_bootmem_alloc_named_range_flags(uint64_t size, uint64_t min_addr,
+					   uint64_t max_addr, uint64_t align,
+					   const char *name, uint32_t flags)
+{
+	int64_t addr;
+
+	__cvmx_validate_mem_range(&min_addr, &max_addr);
+	addr = cvmx_bootmem_phy_named_block_alloc(size, min_addr, max_addr,
+						  align, name, flags);
 	if (addr >= 0)
 		return cvmx_phys_to_ptr(addr);
 	else
 		return NULL;
+
 }
 
-void *cvmx_bootmem_alloc_named_address(uint64_t size, uint64_t address,
-				       char *name)
+void *cvmx_bootmem_alloc_named_range(uint64_t size, uint64_t min_addr,
+				     uint64_t max_addr, uint64_t align,
+				     const char *name)
 {
-    return cvmx_bootmem_alloc_named_range(size, address, address + size,
-					  0, name);
+	return cvmx_bootmem_alloc_named_range_flags(size, min_addr, max_addr,
+						    align, name, 0);
 }
 
-void *cvmx_bootmem_alloc_named(uint64_t size, uint64_t alignment, char *name)
+void *cvmx_bootmem_alloc_named_address(uint64_t size, uint64_t address,
+				       const char *name)
 {
-    return cvmx_bootmem_alloc_named_range(size, 0, 0, alignment, name);
+	return cvmx_bootmem_alloc_named_range(size, address, address + size,
+					      0, name);
 }
-EXPORT_SYMBOL(cvmx_bootmem_alloc_named);
 
-int cvmx_bootmem_free_named(char *name)
+void *cvmx_bootmem_alloc_named(uint64_t size, uint64_t alignment,
+			       const char *name)
 {
-	return cvmx_bootmem_phy_named_block_free(name, 0);
+	return cvmx_bootmem_alloc_named_range(size, 0, 0, alignment, name);
 }
 
-struct cvmx_bootmem_named_block_desc *cvmx_bootmem_find_named_block(char *name)
+void *cvmx_bootmem_alloc_named_flags(uint64_t size, uint64_t alignment,
+				     const char *name, uint32_t flags)
 {
-	return cvmx_bootmem_phy_named_block_find(name, 0);
+	return cvmx_bootmem_alloc_named_range_flags(size, 0, 0, alignment,
+						    name, flags);
 }
-EXPORT_SYMBOL(cvmx_bootmem_find_named_block);
 
-void cvmx_bootmem_lock(void)
+int cvmx_bootmem_free_named(const char *name)
 {
-	cvmx_spinlock_lock((cvmx_spinlock_t *) &(cvmx_bootmem_desc->lock));
+	return cvmx_bootmem_phy_named_block_free(name, 0);
 }
 
-void cvmx_bootmem_unlock(void)
+const cvmx_bootmem_named_block_desc_t *
+cvmx_bootmem_find_named_block(const char *name)
 {
-	cvmx_spinlock_unlock((cvmx_spinlock_t *) &(cvmx_bootmem_desc->lock));
+	/* FIXME: Returning a single static object is probably a bad thing */
+	static cvmx_bootmem_named_block_desc_t desc;
+	uint64_t named_addr = cvmx_bootmem_phy_named_block_find(name, 0);
+	if (named_addr) {
+		desc.base_addr = CVMX_BOOTMEM_NAMED_GET_FIELD(named_addr,
+							      base_addr);
+		desc.size = CVMX_BOOTMEM_NAMED_GET_FIELD(named_addr, size);
+		strncpy(desc.name, name, sizeof(desc.name));
+		desc.name[sizeof(desc.name) - 1] = 0;
+		return &desc;
+	} else
+		return NULL;
 }
 
-int cvmx_bootmem_init(void *mem_desc_ptr)
+void cvmx_bootmem_print_named(void)
 {
-	/* Here we set the global pointer to the bootmem descriptor
-	 * block.  This pointer will be used directly, so we will set
-	 * it up to be directly usable by the application.  It is set
-	 * up as follows for the various runtime/ABI combinations:
-	 *
-	 * Linux 64 bit: Set XKPHYS bit
-	 * Linux 32 bit: use mmap to create mapping, use virtual address
-	 * CVMX 64 bit:	 use physical address directly
-	 * CVMX 32 bit:	 use physical address directly
-	 *
-	 * Note that the CVMX environment assumes the use of 1-1 TLB
-	 * mappings so that the physical addresses can be used
-	 * directly
-	 */
-	if (!cvmx_bootmem_desc) {
-#if   defined(CVMX_ABI_64)
-		/* Set XKPHYS bit */
-		cvmx_bootmem_desc = cvmx_phys_to_ptr(CAST64(mem_desc_ptr));
-#else
-		cvmx_bootmem_desc = (struct cvmx_bootmem_desc *) mem_desc_ptr;
-#endif
-	}
+	cvmx_bootmem_phy_named_block_print();
+}
 
+int cvmx_bootmem_init(uint64_t mem_desc_addr)
+{
+	if (!cvmx_bootmem_desc_addr)
+		cvmx_bootmem_desc_addr = mem_desc_addr;
 	return 0;
 }
 
+uint64_t cvmx_bootmem_available_mem(uint64_t min_block_size)
+{
+	return cvmx_bootmem_phy_available_mem(min_block_size);
+}
+
 /*
  * The cvmx_bootmem_phy* functions below return 64 bit physical
  * addresses, and expose more features that the cvmx_bootmem_functions
@@ -193,31 +551,23 @@ int64_t cvmx_bootmem_phy_alloc(uint64_t req_size, uint64_t address_min,
 	uint64_t prev_addr = 0;
 	uint64_t new_ent_addr = 0;
 	uint64_t desired_min_addr;
+	uint64_t alignment_mask = ~(alignment - 1);
 
 #ifdef DEBUG
-	cvmx_dprintf("cvmx_bootmem_phy_alloc: req_size: 0x%llx, "
-		     "min_addr: 0x%llx, max_addr: 0x%llx, align: 0x%llx\n",
-		     (unsigned long long)req_size,
-		     (unsigned long long)address_min,
-		     (unsigned long long)address_max,
-		     (unsigned long long)alignment);
+	cvmx_dprintf("cvmx_bootmem_phy_alloc: req_size: 0x%llx, min_addr: 0x%llx, max_addr: 0x%llx, align: 0x%llx\n",
+		     (ULL) req_size, (ULL) address_min, (ULL) address_max,
+		     (ULL) alignment);
 #endif
 
-	if (cvmx_bootmem_desc->major_version > 3) {
-		cvmx_dprintf("ERROR: Incompatible bootmem descriptor "
-			     "version: %d.%d at addr: %p\n",
-			     (int)cvmx_bootmem_desc->major_version,
-			     (int)cvmx_bootmem_desc->minor_version,
-			     cvmx_bootmem_desc);
+	if (__cvmx_bootmem_check_version(0))
 		goto error_out;
-	}
 
 	/*
 	 * Do a variety of checks to validate the arguments.  The
-	 * allocator code will later assume that these checks have
+	 * allocator code will later assume * that these checks have
 	 * been made.  We validate that the requested constraints are
-	 * not self-contradictory before we look through the list of
-	 * available memory.
+	 * not * self-contradictory before we look through the list of
+	 * available memory
 	 */
 
 	/* 0 is not a valid req_size for this allocator */
@@ -226,34 +576,34 @@ int64_t cvmx_bootmem_phy_alloc(uint64_t req_size, uint64_t address_min,
 
 	/* Round req_size up to mult of minimum alignment bytes */
 	req_size = (req_size + (CVMX_BOOTMEM_ALIGNMENT_SIZE - 1)) &
-		~(CVMX_BOOTMEM_ALIGNMENT_SIZE - 1);
-
-	/*
-	 * Convert !0 address_min and 0 address_max to special case of
-	 * range that specifies an exact memory block to allocate.  Do
-	 * this before other checks and adjustments so that this
-	 * tranformation will be validated.
-	 */
-	if (address_min && !address_max)
-		address_max = address_min + req_size;
-	else if (!address_min && !address_max)
-		address_max = ~0ull;  /* If no limits given, use max limits */
-
+		   ~(CVMX_BOOTMEM_ALIGNMENT_SIZE - 1);
 
 	/*
 	 * Enforce minimum alignment (this also keeps the minimum free block
-	 * req_size the same as the alignment req_size.
+	 * req_size the same as the alignment req_size
 	 */
 	if (alignment < CVMX_BOOTMEM_ALIGNMENT_SIZE)
 		alignment = CVMX_BOOTMEM_ALIGNMENT_SIZE;
 
+	alignment_mask = ~(alignment - 1);
+
 	/*
 	 * Adjust address minimum based on requested alignment (round
 	 * up to meet alignment).  Do this here so we can reject
 	 * impossible requests up front. (NOP for address_min == 0)
 	 */
 	if (alignment)
-		address_min = ALIGN(address_min, alignment);
+		address_min = (address_min + (alignment - 1)) & ~(alignment - 1);
+	/*
+	 * Convert !0 address_min and 0 address_max to special case of
+	 * range that specifies an exact memory block to allocate.  Do
+	 * this before other checks and adjustments so that this
+	 * tranformation will be validated
+	 */
+	if (address_min && !address_max)
+		address_max = address_min + req_size;
+	else if (!address_min && !address_max)
+		address_max = ~0ull;	/* If no limits given, use max limits */
 
 	/*
 	 * Reject inconsistent args.  We have adjusted these, so this
@@ -265,133 +615,124 @@ int64_t cvmx_bootmem_phy_alloc(uint64_t req_size, uint64_t address_min,
 
 	/* Walk through the list entries - first fit found is returned */
 
-	if (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))
-		cvmx_bootmem_lock();
-	head_addr = cvmx_bootmem_desc->head_addr;
+	__cvmx_bootmem_lock(flags);
+	head_addr = CVMX_BOOTMEM_DESC_GET_FIELD(head_addr);
 	ent_addr = head_addr;
-	for (; ent_addr;
-	     prev_addr = ent_addr,
-	     ent_addr = cvmx_bootmem_phy_get_next(ent_addr)) {
+	while (ent_addr) {
 		uint64_t usable_base, usable_max;
 		uint64_t ent_size = cvmx_bootmem_phy_get_size(ent_addr);
 
 		if (cvmx_bootmem_phy_get_next(ent_addr)
 		    && ent_addr > cvmx_bootmem_phy_get_next(ent_addr)) {
-			cvmx_dprintf("Internal bootmem_alloc() error: ent: "
-				"0x%llx, next: 0x%llx\n",
-				(unsigned long long)ent_addr,
-				(unsigned long long)
-				cvmx_bootmem_phy_get_next(ent_addr));
+			cvmx_dprintf("Internal bootmem_alloc() error: ent: 0x%llx, next: 0x%llx\n",
+				     (ULL)ent_addr,
+				     (ULL)cvmx_bootmem_phy_get_next(ent_addr));
 			goto error_out;
 		}
 
 		/*
 		 * Determine if this is an entry that can satisify the
 		 * request Check to make sure entry is large enough to
-		 * satisfy request.
-		 */
-		usable_base =
-		    ALIGN(max(address_min, ent_addr), alignment);
-		usable_max = min(address_max, ent_addr + ent_size);
-		/*
-		 * We should be able to allocate block at address
-		 * usable_base.
+		 * satisfy request
 		 */
+		usable_base = ALIGN_ADDR_UP(MAX(address_min, ent_addr),
+					    alignment_mask);
+		usable_max = MIN(address_max, ent_addr + ent_size);
+		/* We should be able to allocate block at address usable_base */
 
 		desired_min_addr = usable_base;
+
 		/*
 		 * Determine if request can be satisfied from the
-		 * current entry.
-		 */
-		if (!((ent_addr + ent_size) > usable_base
-				&& ent_addr < address_max
-				&& req_size <= usable_max - usable_base))
-			continue;
-		/*
-		 * We have found an entry that has room to satisfy the
-		 * request, so allocate it from this entry.  If end
-		 * CVMX_BOOTMEM_FLAG_END_ALLOC set, then allocate from
-		 * the end of this block rather than the beginning.
+		 * current entry
 		 */
-		if (flags & CVMX_BOOTMEM_FLAG_END_ALLOC) {
-			desired_min_addr = usable_max - req_size;
+		if (((ent_addr + ent_size) > usable_base
+		     && ent_addr < address_max)
+		    && req_size <= usable_max - usable_base) {
 			/*
-			 * Align desired address down to required
-			 * alignment.
+			 * We have found an entry that has room to satisfy the
+			 * request, so allocate it from this entry
+			 *
+			 * If end CVMX_BOOTMEM_FLAG_END_ALLOC set, then allocate
+			 * from the end of this block rather than the beginning
 			 */
-			desired_min_addr &= ~(alignment - 1);
-		}
-
-		/* Match at start of entry */
-		if (desired_min_addr == ent_addr) {
-			if (req_size < ent_size) {
+			if (flags & CVMX_BOOTMEM_FLAG_END_ALLOC) {
+				desired_min_addr = usable_max - req_size;
 				/*
-				 * big enough to create a new block
-				 * from top portion of block.
+				 * Align desired address down to required
+				 * alignment
 				 */
-				new_ent_addr = ent_addr + req_size;
-				cvmx_bootmem_phy_set_next(new_ent_addr,
-					cvmx_bootmem_phy_get_next(ent_addr));
-				cvmx_bootmem_phy_set_size(new_ent_addr,
-							ent_size -
-							req_size);
+				desired_min_addr &= alignment_mask;
+			}
+
+			/* Match at start of entry */
+			if (desired_min_addr == ent_addr) {
+				if (req_size < ent_size) {
+					/*
+					 * big enough to create a new block from
+					 * top portion of block
+					 */
+					new_ent_addr = ent_addr + req_size;
+					cvmx_bootmem_phy_set_next(new_ent_addr,
+						cvmx_bootmem_phy_get_next(ent_addr));
+					cvmx_bootmem_phy_set_size(new_ent_addr,
+							ent_size - req_size);
+
+					/*
+					 * Adjust next pointer as
+					 * following code uses this.
+					 */
+					cvmx_bootmem_phy_set_next(ent_addr,
+								  new_ent_addr);
+				}
 
 				/*
-				 * Adjust next pointer as following
-				 * code uses this.
+				 * adjust prev ptr or head to remove this entry
+				 * from list
 				 */
-				cvmx_bootmem_phy_set_next(ent_addr,
-							new_ent_addr);
+				if (prev_addr) {
+					cvmx_bootmem_phy_set_next(prev_addr,
+						cvmx_bootmem_phy_get_next(ent_addr));
+				} else {
+					/* head of list being returned, so update head ptr */
+					CVMX_BOOTMEM_DESC_SET_FIELD(head_addr,
+						cvmx_bootmem_phy_get_next(ent_addr));
+				}
+				__cvmx_bootmem_unlock(flags);
+#ifdef DEBUG
+				cvmx_dprintf("cvmx_bootmem_phy_alloc: req_size: 0x%llx, addr: 0x%llx\n",
+					     req_size, desired_min_addr);
+#endif
+				return desired_min_addr;
 			}
 
-			/*
-			 * adjust prev ptr or head to remove this
-			 * entry from list.
+			/* block returned doesn't start at beginning of entry,
+			 * so we know that we will be splitting a block off the
+			 * front of this one.  Create a new block from the
+			 * beginning, add to list, and go to top of loop again.
+			 *
+			 * create a new block from the high portion of the
+			 * block so that the top block starts at the desired
+			 * addr
 			 */
-			if (prev_addr)
-				cvmx_bootmem_phy_set_next(prev_addr,
+			new_ent_addr = desired_min_addr;
+			cvmx_bootmem_phy_set_next(new_ent_addr,
 					cvmx_bootmem_phy_get_next(ent_addr));
-			else
-				/*
-				 * head of list being returned, so
-				 * update head ptr.
-				 */
-				cvmx_bootmem_desc->head_addr =
-					cvmx_bootmem_phy_get_next(ent_addr);
-
-			if (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))
-				cvmx_bootmem_unlock();
-			return desired_min_addr;
+			cvmx_bootmem_phy_set_size(new_ent_addr,
+					cvmx_bootmem_phy_get_size(ent_addr) -
+					 (desired_min_addr - ent_addr));
+			cvmx_bootmem_phy_set_size(ent_addr,
+						  desired_min_addr - ent_addr);
+			cvmx_bootmem_phy_set_next(ent_addr, new_ent_addr);
+			/* Loop again to handle actual alloc from new block */
 		}
-		/*
-		 * block returned doesn't start at beginning of entry,
-		 * so we know that we will be splitting a block off
-		 * the front of this one.  Create a new block from the
-		 * beginning, add to list, and go to top of loop
-		 * again.
-		 *
-		 * create new block from high portion of
-		 * block, so that top block starts at desired
-		 * addr.
-		 */
-		new_ent_addr = desired_min_addr;
-		cvmx_bootmem_phy_set_next(new_ent_addr,
-					cvmx_bootmem_phy_get_next
-					(ent_addr));
-		cvmx_bootmem_phy_set_size(new_ent_addr,
-					cvmx_bootmem_phy_get_size
-					(ent_addr) -
-					(desired_min_addr -
-						ent_addr));
-		cvmx_bootmem_phy_set_size(ent_addr,
-					desired_min_addr - ent_addr);
-		cvmx_bootmem_phy_set_next(ent_addr, new_ent_addr);
-		/* Loop again to handle actual alloc from new block */
+
+		prev_addr = ent_addr;
+		ent_addr = cvmx_bootmem_phy_get_next(ent_addr);
 	}
 error_out:
 	/* We didn't find anything, so return error */
-	if (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))
-		cvmx_bootmem_unlock();
+	__cvmx_bootmem_unlock(flags);
 	return -1;
 }
 
@@ -403,24 +744,17 @@ int __cvmx_bootmem_phy_free(uint64_t phy_addr, uint64_t size, uint32_t flags)
 
 #ifdef DEBUG
 	cvmx_dprintf("__cvmx_bootmem_phy_free addr: 0x%llx, size: 0x%llx\n",
-		     (unsigned long long)phy_addr, (unsigned long long)size);
+		     (ULL) phy_addr, (ULL) size);
 #endif
-	if (cvmx_bootmem_desc->major_version > 3) {
-		cvmx_dprintf("ERROR: Incompatible bootmem descriptor "
-			     "version: %d.%d at addr: %p\n",
-			     (int)cvmx_bootmem_desc->major_version,
-			     (int)cvmx_bootmem_desc->minor_version,
-			     cvmx_bootmem_desc);
+	if (__cvmx_bootmem_check_version(0))
 		return 0;
-	}
 
 	/* 0 is not a valid size for this allocator */
 	if (!size)
 		return 0;
 
-	if (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))
-		cvmx_bootmem_lock();
-	cur_addr = cvmx_bootmem_desc->head_addr;
+	__cvmx_bootmem_lock(flags);
+	cur_addr = CVMX_BOOTMEM_DESC_GET_FIELD(head_addr);
 	if (cur_addr == 0 || phy_addr < cur_addr) {
 		/* add at front of list - special case with changing head ptr */
 		if (cur_addr && phy_addr + size > cur_addr)
@@ -428,18 +762,17 @@ int __cvmx_bootmem_phy_free(uint64_t phy_addr, uint64_t size, uint32_t flags)
 		else if (phy_addr + size == cur_addr) {
 			/* Add to front of existing first block */
 			cvmx_bootmem_phy_set_next(phy_addr,
-						  cvmx_bootmem_phy_get_next
-						  (cur_addr));
+					cvmx_bootmem_phy_get_next(cur_addr));
 			cvmx_bootmem_phy_set_size(phy_addr,
-						  cvmx_bootmem_phy_get_size
-						  (cur_addr) + size);
-			cvmx_bootmem_desc->head_addr = phy_addr;
+					cvmx_bootmem_phy_get_size(cur_addr) + size);
+			CVMX_BOOTMEM_DESC_SET_FIELD(head_addr, phy_addr);
 
 		} else {
-			/* New block before first block.  OK if cur_addr is 0 */
+			/* New block before first block */
+			/* OK if cur_addr is 0 */
 			cvmx_bootmem_phy_set_next(phy_addr, cur_addr);
 			cvmx_bootmem_phy_set_size(phy_addr, size);
-			cvmx_bootmem_desc->head_addr = phy_addr;
+			CVMX_BOOTMEM_DESC_SET_FIELD(head_addr, phy_addr);
 		}
 		retval = 1;
 		goto bootmem_free_done;
@@ -453,15 +786,12 @@ int __cvmx_bootmem_phy_free(uint64_t phy_addr, uint64_t size, uint32_t flags)
 
 	if (!cur_addr) {
 		/*
-		 * We have reached the end of the list, add on to end,
-		 * checking to see if we need to combine with last
-		 * block
+		 * We have reached the end of the list, add on to end, checking
+		 * to see if we need to combine with last block
 		 */
-		if (prev_addr + cvmx_bootmem_phy_get_size(prev_addr) ==
-		    phy_addr) {
+		if (prev_addr + cvmx_bootmem_phy_get_size(prev_addr) == phy_addr) {
 			cvmx_bootmem_phy_set_size(prev_addr,
-						  cvmx_bootmem_phy_get_size
-						  (prev_addr) + size);
+				  cvmx_bootmem_phy_get_size(prev_addr) + size);
 		} else {
 			cvmx_bootmem_phy_set_next(prev_addr, phy_addr);
 			cvmx_bootmem_phy_set_size(phy_addr, size);
@@ -471,15 +801,13 @@ int __cvmx_bootmem_phy_free(uint64_t phy_addr, uint64_t size, uint32_t flags)
 		goto bootmem_free_done;
 	} else {
 		/*
-		 * insert between prev and cur nodes, checking for
-		 * merge with either/both.
+		 * insert between prev and cur nodes, checking for merge with
+		 * either/both
 		 */
-		if (prev_addr + cvmx_bootmem_phy_get_size(prev_addr) ==
-		    phy_addr) {
+		if (prev_addr + cvmx_bootmem_phy_get_size(prev_addr) == phy_addr) {
 			/* Merge with previous */
 			cvmx_bootmem_phy_set_size(prev_addr,
-						  cvmx_bootmem_phy_get_size
-						  (prev_addr) + size);
+				  cvmx_bootmem_phy_get_size(prev_addr) + size);
 			if (phy_addr + size == cur_addr) {
 				/* Also merge with current */
 				cvmx_bootmem_phy_set_size(prev_addr,
@@ -493,11 +821,9 @@ int __cvmx_bootmem_phy_free(uint64_t phy_addr, uint64_t size, uint32_t flags)
 		} else if (phy_addr + size == cur_addr) {
 			/* Merge with current */
 			cvmx_bootmem_phy_set_size(phy_addr,
-						  cvmx_bootmem_phy_get_size
-						  (cur_addr) + size);
+				cvmx_bootmem_phy_get_size(cur_addr) + size);
 			cvmx_bootmem_phy_set_next(phy_addr,
-						  cvmx_bootmem_phy_get_next
-						  (cur_addr));
+				cvmx_bootmem_phy_get_next(cur_addr));
 			cvmx_bootmem_phy_set_next(prev_addr, phy_addr);
 			retval = 1;
 			goto bootmem_free_done;
@@ -512,184 +838,425 @@ int __cvmx_bootmem_phy_free(uint64_t phy_addr, uint64_t size, uint32_t flags)
 	retval = 1;
 
 bootmem_free_done:
-	if (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))
-		cvmx_bootmem_unlock();
+	__cvmx_bootmem_unlock(flags);
 	return retval;
+}
 
+void cvmx_bootmem_phy_list_print(void)
+{
+	uint64_t addr;
+
+	addr = CVMX_BOOTMEM_DESC_GET_FIELD(head_addr);
+	cvmx_dprintf("\n\n\nPrinting bootmem block list, descriptor: 0x%llx,  head is 0x%llx\n",
+		     (ULL) cvmx_bootmem_desc_addr, (ULL) addr);
+	cvmx_dprintf("Descriptor version: %d.%d\n",
+		     (int)CVMX_BOOTMEM_DESC_GET_FIELD(major_version),
+		     (int)CVMX_BOOTMEM_DESC_GET_FIELD(minor_version));
+	if (CVMX_BOOTMEM_DESC_GET_FIELD(major_version) > 3)
+		cvmx_dprintf("Warning: Bootmem descriptor version is newer than expected\n");
+
+	if (!addr)
+		cvmx_dprintf("mem list is empty!\n");
+
+	while (addr) {
+		cvmx_dprintf("Block address: 0x%08llx, size: 0x%08llx, next: 0x%08llx\n",
+			     (ULL) addr, (ULL) cvmx_bootmem_phy_get_size(addr),
+			     (ULL) cvmx_bootmem_phy_get_next(addr));
+		addr = cvmx_bootmem_phy_get_next(addr);
+	}
+	cvmx_dprintf("\n\n");
 }
 
-struct cvmx_bootmem_named_block_desc *
-	cvmx_bootmem_phy_named_block_find(char *name, uint32_t flags)
+uint64_t cvmx_bootmem_phy_available_mem(uint64_t min_block_size)
 {
-	unsigned int i;
-	struct cvmx_bootmem_named_block_desc *named_block_array_ptr;
+	uint64_t addr;
 
-#ifdef DEBUG
-	cvmx_dprintf("cvmx_bootmem_phy_named_block_find: %s\n", name);
-#endif
-	/*
-	 * Lock the structure to make sure that it is not being
-	 * changed while we are examining it.
-	 */
-	if (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))
-		cvmx_bootmem_lock();
+	uint64_t available_mem = 0;
 
-	/* Use XKPHYS for 64 bit linux */
-	named_block_array_ptr = (struct cvmx_bootmem_named_block_desc *)
-	    cvmx_phys_to_ptr(cvmx_bootmem_desc->named_block_array_addr);
+	__cvmx_bootmem_lock(0);
+	addr = CVMX_BOOTMEM_DESC_GET_FIELD(head_addr);
+	while (addr) {
+		if (cvmx_bootmem_phy_get_size(addr) >= min_block_size)
+			available_mem += cvmx_bootmem_phy_get_size(addr);
+		addr = cvmx_bootmem_phy_get_next(addr);
+	}
+	__cvmx_bootmem_unlock(0);
+	return available_mem;
+}
+
+uint64_t cvmx_bootmem_phy_named_block_find(const char *name, uint32_t flags)
+{
+	uint64_t result = 0;
 
 #ifdef DEBUG
-	cvmx_dprintf
-	    ("cvmx_bootmem_phy_named_block_find: named_block_array_ptr: %p\n",
-	     named_block_array_ptr);
+	cvmx_dprintf("cvmx_bootmem_phy_named_block_find: %s\n", name);
 #endif
-	if (cvmx_bootmem_desc->major_version == 3) {
-		for (i = 0;
-		     i < cvmx_bootmem_desc->named_block_num_blocks; i++) {
-			if ((name && named_block_array_ptr[i].size
-			     && !strncmp(name, named_block_array_ptr[i].name,
-					 cvmx_bootmem_desc->named_block_name_len
-					 - 1))
-			    || (!name && !named_block_array_ptr[i].size)) {
-				if (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))
-					cvmx_bootmem_unlock();
-
-				return &(named_block_array_ptr[i]);
+	__cvmx_bootmem_lock(flags);
+	if (!__cvmx_bootmem_check_version(3)) {
+		int i;
+		uint64_t named_block_array_addr =
+			CVMX_BOOTMEM_DESC_GET_FIELD(named_block_array_addr);
+		int num_blocks =
+			CVMX_BOOTMEM_DESC_GET_FIELD(named_block_num_blocks);
+		int name_length =
+			CVMX_BOOTMEM_DESC_GET_FIELD(named_block_name_len);
+		uint64_t named_addr = named_block_array_addr;
+
+		for (i = 0; i < num_blocks; i++) {
+			uint64_t named_size =
+				CVMX_BOOTMEM_NAMED_GET_FIELD(named_addr, size);
+			if (name && named_size) {
+				char name_tmp[name_length];
+				CVMX_BOOTMEM_NAMED_GET_NAME(named_addr,
+							    name_tmp,
+							    name_length);
+				if (!strncmp(name, name_tmp, name_length - 1)) {
+					result = named_addr;
+					break;
+				}
+			} else if (!name && !named_size) {
+				result = named_addr;
+				break;
 			}
+			named_addr += sizeof(cvmx_bootmem_named_block_desc_t);
 		}
-	} else {
-		cvmx_dprintf("ERROR: Incompatible bootmem descriptor "
-			     "version: %d.%d at addr: %p\n",
-			     (int)cvmx_bootmem_desc->major_version,
-			     (int)cvmx_bootmem_desc->minor_version,
-			     cvmx_bootmem_desc);
 	}
-	if (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))
-		cvmx_bootmem_unlock();
-
-	return NULL;
+	__cvmx_bootmem_unlock(flags);
+	return result;
 }
 
-int cvmx_bootmem_phy_named_block_free(char *name, uint32_t flags)
+int cvmx_bootmem_phy_named_block_free(const char *name, uint32_t flags)
 {
-	struct cvmx_bootmem_named_block_desc *named_block_ptr;
+	uint64_t named_block_addr;
 
-	if (cvmx_bootmem_desc->major_version != 3) {
-		cvmx_dprintf("ERROR: Incompatible bootmem descriptor version: "
-			     "%d.%d at addr: %p\n",
-			     (int)cvmx_bootmem_desc->major_version,
-			     (int)cvmx_bootmem_desc->minor_version,
-			     cvmx_bootmem_desc);
+	if (__cvmx_bootmem_check_version(3))
 		return 0;
-	}
 #ifdef DEBUG
 	cvmx_dprintf("cvmx_bootmem_phy_named_block_free: %s\n", name);
 #endif
 
 	/*
-	 * Take lock here, as name lookup/block free/name free need to
-	 * be atomic.
+	 * Take lock here, as name lookup/block free/name free need to be
+	 * atomic
 	 */
-	cvmx_bootmem_lock();
-
-	named_block_ptr =
-	    cvmx_bootmem_phy_named_block_find(name,
-					      CVMX_BOOTMEM_FLAG_NO_LOCKING);
-	if (named_block_ptr) {
+	__cvmx_bootmem_lock(flags);
+
+	named_block_addr = cvmx_bootmem_phy_named_block_find(name,
+						CVMX_BOOTMEM_FLAG_NO_LOCKING);
+	if (named_block_addr) {
+		uint64_t named_addr =
+			CVMX_BOOTMEM_NAMED_GET_FIELD(named_block_addr,
+						     base_addr);
+		uint64_t named_size =
+			CVMX_BOOTMEM_NAMED_GET_FIELD(named_block_addr, size);
 #ifdef DEBUG
-		cvmx_dprintf("cvmx_bootmem_phy_named_block_free: "
-			     "%s, base: 0x%llx, size: 0x%llx\n",
-			     name,
-			     (unsigned long long)named_block_ptr->base_addr,
-			     (unsigned long long)named_block_ptr->size);
+		cvmx_dprintf("cvmx_bootmem_phy_named_block_free: %s, base: 0x%llx, size: 0x%llx\n",
+			     name, (ULL) named_addr, (ULL) named_size);
 #endif
-		__cvmx_bootmem_phy_free(named_block_ptr->base_addr,
-					named_block_ptr->size,
+		__cvmx_bootmem_phy_free(named_addr, named_size,
 					CVMX_BOOTMEM_FLAG_NO_LOCKING);
-		named_block_ptr->size = 0;
 		/* Set size to zero to indicate block not used. */
+		CVMX_BOOTMEM_NAMED_SET_FIELD(named_block_addr, size, 0);
 	}
-
-	cvmx_bootmem_unlock();
-	return named_block_ptr != NULL; /* 0 on failure, 1 on success */
+	__cvmx_bootmem_unlock(flags);
+	return !!named_block_addr;	/* 0 on failure, 1 on success */
 }
 
 int64_t cvmx_bootmem_phy_named_block_alloc(uint64_t size, uint64_t min_addr,
 					   uint64_t max_addr,
-					   uint64_t alignment,
-					   char *name,
+					   uint64_t alignment, const char *name,
 					   uint32_t flags)
 {
 	int64_t addr_allocated;
-	struct cvmx_bootmem_named_block_desc *named_block_desc_ptr;
+	uint64_t named_block_desc_addr;
 
 #ifdef DEBUG
-	cvmx_dprintf("cvmx_bootmem_phy_named_block_alloc: size: 0x%llx, min: "
-		     "0x%llx, max: 0x%llx, align: 0x%llx, name: %s\n",
-		     (unsigned long long)size,
-		     (unsigned long long)min_addr,
-		     (unsigned long long)max_addr,
-		     (unsigned long long)alignment,
-		     name);
+	cvmx_dprintf("cvmx_bootmem_phy_named_block_alloc: size: 0x%llx, min: 0x%llx, max: 0x%llx, align: 0x%llx, name: %s\n",
+		     (ULL) size, (ULL) min_addr, (ULL) max_addr, (ULL) alignment, name);
 #endif
-	if (cvmx_bootmem_desc->major_version != 3) {
-		cvmx_dprintf("ERROR: Incompatible bootmem descriptor version: "
-			     "%d.%d at addr: %p\n",
-			     (int)cvmx_bootmem_desc->major_version,
-			     (int)cvmx_bootmem_desc->minor_version,
-			     cvmx_bootmem_desc);
+
+	if (__cvmx_bootmem_check_version(3))
 		return -1;
-	}
 
 	/*
-	 * Take lock here, as name lookup/block alloc/name add need to
-	 * be atomic.
+	 * Take lock here, as name lookup/block alloc/name add need to be
+	 * atomic
 	 */
-	if (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))
-		cvmx_spinlock_lock((cvmx_spinlock_t *)&(cvmx_bootmem_desc->lock));
-
-	/* Get pointer to first available named block descriptor */
-	named_block_desc_ptr =
-		cvmx_bootmem_phy_named_block_find(NULL,
-						  flags | CVMX_BOOTMEM_FLAG_NO_LOCKING);
+	__cvmx_bootmem_lock(flags);
 
-	/*
-	 * Check to see if name already in use, return error if name
-	 * not available or no more room for blocks.
-	 */
-	if (cvmx_bootmem_phy_named_block_find(name,
-					      flags | CVMX_BOOTMEM_FLAG_NO_LOCKING) || !named_block_desc_ptr) {
-		if (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))
-			cvmx_spinlock_unlock((cvmx_spinlock_t *)&(cvmx_bootmem_desc->lock));
+	named_block_desc_addr = cvmx_bootmem_phy_named_block_find(name,
+					flags | CVMX_BOOTMEM_FLAG_NO_LOCKING);
+	if (named_block_desc_addr) {
+		__cvmx_bootmem_unlock(flags);
 		return -1;
 	}
 
+	/* Get pointer to first available named block descriptor */
+	named_block_desc_addr = cvmx_bootmem_phy_named_block_find(NULL,
+					flags | CVMX_BOOTMEM_FLAG_NO_LOCKING);
+	if (!named_block_desc_addr) {
+		__cvmx_bootmem_unlock(flags);
+		return -1;
+	}
 
 	/*
-	 * Round size up to mult of minimum alignment bytes We need
-	 * the actual size allocated to allow for blocks to be
+	 * Round size up to mult of minimum alignment bytes
+	 * We need the actual size allocated to allow for blocks to be
 	 * coallesced when they are freed.  The alloc routine does the
 	 * same rounding up on all allocations.
 	 */
-	size = ALIGN(size, CVMX_BOOTMEM_ALIGNMENT_SIZE);
+	size = (size + (CVMX_BOOTMEM_ALIGNMENT_SIZE - 1)) &
+	       ~(CVMX_BOOTMEM_ALIGNMENT_SIZE - 1);
 
 	addr_allocated = cvmx_bootmem_phy_alloc(size, min_addr, max_addr,
-						alignment,
-						flags | CVMX_BOOTMEM_FLAG_NO_LOCKING);
+					alignment,
+					flags | CVMX_BOOTMEM_FLAG_NO_LOCKING);
 	if (addr_allocated >= 0) {
-		named_block_desc_ptr->base_addr = addr_allocated;
-		named_block_desc_ptr->size = size;
-		strncpy(named_block_desc_ptr->name, name,
-			cvmx_bootmem_desc->named_block_name_len);
-		named_block_desc_ptr->name[cvmx_bootmem_desc->named_block_name_len - 1] = 0;
+		CVMX_BOOTMEM_NAMED_SET_FIELD(named_block_desc_addr, base_addr,
+					     addr_allocated);
+		CVMX_BOOTMEM_NAMED_SET_FIELD(named_block_desc_addr, size, size);
+		CVMX_BOOTMEM_NAMED_SET_NAME(named_block_desc_addr, name,
+			CVMX_BOOTMEM_DESC_GET_FIELD(named_block_name_len));
 	}
 
-	if (!(flags & CVMX_BOOTMEM_FLAG_NO_LOCKING))
-		cvmx_spinlock_unlock((cvmx_spinlock_t *)&(cvmx_bootmem_desc->lock));
+	__cvmx_bootmem_unlock(flags);
 	return addr_allocated;
 }
 
-struct cvmx_bootmem_desc *cvmx_bootmem_get_desc(void)
+void cvmx_bootmem_phy_named_block_print(void)
+{
+	int i;
+	int printed = 0;
+
+	uint64_t named_block_array_addr =
+		CVMX_BOOTMEM_DESC_GET_FIELD(named_block_array_addr);
+	int num_blocks = CVMX_BOOTMEM_DESC_GET_FIELD(named_block_num_blocks);
+	int name_length = CVMX_BOOTMEM_DESC_GET_FIELD(named_block_name_len);
+	uint64_t named_block_addr = named_block_array_addr;
+
+#ifdef DEBUG
+	cvmx_dprintf("cvmx_bootmem_phy_named_block_print, desc addr: 0x%llx\n",
+		     (ULL) cvmx_bootmem_desc_addr);
+#endif
+	if (__cvmx_bootmem_check_version(3))
+		return;
+	cvmx_dprintf("List of currently allocated named bootmem blocks:\n");
+	for (i = 0; i < num_blocks; i++) {
+		uint64_t named_size =
+			CVMX_BOOTMEM_NAMED_GET_FIELD(named_block_addr, size);
+		if (named_size) {
+			char name_tmp[name_length];
+			uint64_t named_addr =
+				CVMX_BOOTMEM_NAMED_GET_FIELD(named_block_addr,
+							     base_addr);
+			CVMX_BOOTMEM_NAMED_GET_NAME(named_block_addr, name_tmp,
+						    name_length);
+			printed++;
+			cvmx_dprintf("Name: %s, address: 0x%08llx, size: 0x%08llx, index: %d\n",
+				     name_tmp, (ULL) named_addr, (ULL) named_size, i);
+		}
+		named_block_addr += sizeof(cvmx_bootmem_named_block_desc_t);
+	}
+	if (!printed)
+		cvmx_dprintf("No named bootmem blocks exist.\n");
+}
+
+int64_t cvmx_bootmem_phy_mem_list_init(uint64_t mem_size,
+				       uint32_t low_reserved_bytes,
+				       cvmx_bootmem_desc_t *desc_buffer)
+{
+	uint64_t cur_block_addr;
+	int64_t addr;
+	int i;
+
+#ifdef DEBUG
+	cvmx_dprintf("cvmx_bootmem_phy_mem_list_init (arg desc ptr: %p, cvmx_bootmem_desc: 0x%llx)\n",
+		     desc_buffer, (ULL) cvmx_bootmem_desc_addr);
+#endif
+
+	/*
+	 * Descriptor buffer needs to be in 32 bit addressable space to be
+	 * compatible with 32 bit applications
+	 */
+	if (!desc_buffer) {
+		cvmx_dprintf("ERROR: no memory for cvmx_bootmem descriptor provided\n");
+		return 0;
+	}
+
+	if (mem_size > OCTEON_MAX_PHY_MEM_SIZE) {
+		mem_size = OCTEON_MAX_PHY_MEM_SIZE;
+		cvmx_dprintf("ERROR: requested memory size too large, truncating to maximum size\n");
+	}
+
+	if (cvmx_bootmem_desc_addr)
+		return 1;
+
+	/* Initialize cvmx pointer to descriptor */
+	cvmx_bootmem_init(cvmx_ptr_to_phys(desc_buffer));
+
+	/* Fill the bootmem descriptor */
+	CVMX_BOOTMEM_DESC_SET_FIELD(lock, 0);
+	CVMX_BOOTMEM_DESC_SET_FIELD(flags, 0);
+	CVMX_BOOTMEM_DESC_SET_FIELD(head_addr, 0);
+	CVMX_BOOTMEM_DESC_SET_FIELD(major_version, CVMX_BOOTMEM_DESC_MAJ_VER);
+	CVMX_BOOTMEM_DESC_SET_FIELD(minor_version, CVMX_BOOTMEM_DESC_MIN_VER);
+	CVMX_BOOTMEM_DESC_SET_FIELD(app_data_addr, 0);
+	CVMX_BOOTMEM_DESC_SET_FIELD(app_data_size, 0);
+
+	/*
+	 * Set up global pointer to start of list, exclude low 64k for exception
+	 * vectors, space for global descriptor
+	 */
+	cur_block_addr = (OCTEON_DDR0_BASE + low_reserved_bytes);
+
+	if (mem_size <= OCTEON_DDR0_SIZE) {
+		__cvmx_bootmem_phy_free(cur_block_addr,
+					mem_size - low_reserved_bytes, 0);
+		goto frees_done;
+	}
+
+	__cvmx_bootmem_phy_free(cur_block_addr,
+				OCTEON_DDR0_SIZE - low_reserved_bytes, 0);
+
+	mem_size -= OCTEON_DDR0_SIZE;
+
+	/* Add DDR2 block next if present */
+	if (mem_size > OCTEON_DDR1_SIZE) {
+		__cvmx_bootmem_phy_free(OCTEON_DDR1_BASE, OCTEON_DDR1_SIZE, 0);
+		__cvmx_bootmem_phy_free(OCTEON_DDR2_BASE,
+					mem_size - OCTEON_DDR1_SIZE, 0);
+	} else {
+		__cvmx_bootmem_phy_free(OCTEON_DDR1_BASE, mem_size, 0);
+
+	}
+frees_done:
+
+	/* Initialize the named block structure */
+	CVMX_BOOTMEM_DESC_SET_FIELD(named_block_name_len, CVMX_BOOTMEM_NAME_LEN);
+	CVMX_BOOTMEM_DESC_SET_FIELD(named_block_num_blocks,
+				    CVMX_BOOTMEM_NUM_NAMED_BLOCKS);
+	CVMX_BOOTMEM_DESC_SET_FIELD(named_block_array_addr, 0);
+
+	/* Allocate this near the top of the low 256 MBytes of memory */
+	addr = cvmx_bootmem_phy_alloc(CVMX_BOOTMEM_NUM_NAMED_BLOCKS *
+				      sizeof(cvmx_bootmem_named_block_desc_t),
+				      0, 0x10000000, 0,
+				      CVMX_BOOTMEM_FLAG_END_ALLOC);
+	if (addr >= 0)
+		CVMX_BOOTMEM_DESC_SET_FIELD(named_block_array_addr, addr);
+
+#ifdef DEBUG
+	cvmx_dprintf("cvmx_bootmem_phy_mem_list_init: named_block_array_addr: 0x%llx)\n",
+		     (ULL) addr);
+#endif
+	if (!addr) {
+		cvmx_dprintf("FATAL ERROR: unable to allocate memory for bootmem descriptor!\n");
+		return 0;
+	}
+	for (i = 0; i < CVMX_BOOTMEM_NUM_NAMED_BLOCKS; i++) {
+		CVMX_BOOTMEM_NAMED_SET_FIELD(addr, base_addr, 0);
+		CVMX_BOOTMEM_NAMED_SET_FIELD(addr, size, 0);
+		addr += sizeof(cvmx_bootmem_named_block_desc_t);
+	}
+
+	return 1;
+}
+
+int cvmx_bootmem_reserve_memory(uint64_t start_addr, uint64_t size,
+				const char *name, uint32_t flags)
+{
+	uint64_t addr;
+	int rc = 1;
+	static unsigned block_num;
+	char block_name[CVMX_BOOTMEM_NAME_LEN];
+
+#ifdef DEBUG
+	cvmx_dprintf("%s (start_addr: 0x%llx, size: 0x%llx, name: %s, flags: 0x%x)\n",
+		     __func__, start_addr, size, name, flags);
+#endif
+
+	if (__cvmx_bootmem_check_version(3))
+		return 0;
+
+	addr = CVMX_BOOTMEM_DESC_GET_FIELD(head_addr);
+	if (!addr)
+		return 0;
+
+	if (!name)
+		name = "__cvmx_bootmem_reserved";
+
+	while (addr && rc) {
+		uint64_t block_size = cvmx_bootmem_phy_get_size(addr);
+		uint64_t reserve_size = 0;
+
+		if (addr >= start_addr && addr < start_addr + size) {
+			reserve_size = size - (addr - start_addr);
+			if (block_size < reserve_size)
+				reserve_size = block_size;
+		} else if (start_addr > addr &&
+			   start_addr < (addr + block_size)) {
+			reserve_size = block_size - (start_addr - addr);
+		}
+		if (reserve_size) {
+			snprintf(block_name, sizeof(block_name),
+				 "%.100s_%016llx_%u",
+				 name, (unsigned long long)start_addr,
+				 (unsigned int)block_num);
+#ifdef DEBUG
+			cvmx_dprintf("%s: Reserving 0x%llx bytes at address 0x%llx with name %s\n",
+				     __func__, reserve_size, addr, block_name);
+#endif
+			if ((unsigned long long)
+			    cvmx_bootmem_phy_named_block_alloc(reserve_size,
+							       addr, 0, 0,
+							       block_name, 0)
+			    == -1ull) {
+				cvmx_dprintf("%s: Failed to reserve 0x%llx bytes at address 0x%llx\n",
+					     __func__,
+					    (unsigned long long)reserve_size,
+					    (unsigned long long)addr);
+				rc = 0;
+				break;
+			}
+#ifdef DEBUG
+			else
+				cvmx_dprintf("%s: Reserved 0x%llx bytes at address 0x%llx with name %s\n",
+					     __func__, reserve_size, addr, block_name);
+#endif
+		}
+		addr = cvmx_bootmem_phy_get_next(addr);
+		block_num++;
+	}
+	return rc;
+}
+
+void cvmx_bootmem_lock(void)
+{
+	__cvmx_bootmem_lock(0);
+}
+
+void cvmx_bootmem_unlock(void)
+{
+	__cvmx_bootmem_unlock(0);
+}
+
+
+void *__cvmx_phys_addr_to_ptr(uint64_t phys, int size)
+{
+	void *tmp;
+
+	if (sizeof(void *) == 8)
+		tmp = CASTPTR(void, CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS, phys));
+	else {
+		uint32_t phy32 = (uint32_t) (phys & 0x7fffffffULL);
+		tmp = CASTPTR(void, CVMX_ADD_SEG32(CVMX_MIPS32_SPACE_KSEG0, phy32));
+	}
+	/*cvmx_dprintf("%s: ptr=%p phys=%16llx size=%d ra=%p\n", __FUNCTION__, tmp, (unsigned long long) phys,
+		     size, __builtin_return_address(0)); */
+	return tmp;
+}
+
+void *__cvmx_bootmem_internal_get_desc_ptr(void)
 {
-	return cvmx_bootmem_desc;
+	return cvmx_phys_to_ptr(cvmx_bootmem_desc_addr);
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c b/arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c
index 132bccc..c4c449a 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-cmd-queue.c
@@ -81,7 +81,7 @@ static cvmx_cmd_queue_result_t __cvmx_cmd_queue_init_state_ptr(void)
 		memset(__cvmx_cmd_queue_state_ptr, 0,
 		       sizeof(*__cvmx_cmd_queue_state_ptr));
 	else {
-		struct cvmx_bootmem_named_block_desc *block_desc =
+		const struct cvmx_bootmem_named_block_desc *block_desc =
 		    cvmx_bootmem_find_named_block(alloc_name);
 		if (block_desc)
 			__cvmx_cmd_queue_state_ptr =
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 1574f9a..e1439e9 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -779,7 +779,7 @@ void __init prom_init(void)
 	octeon_boot_desc_ptr = (struct octeon_boot_descriptor *)fw_arg3;
 	octeon_bootinfo =
 		cvmx_phys_to_ptr(octeon_boot_desc_ptr->cvmx_desc_vaddr);
-	cvmx_bootmem_init(cvmx_phys_to_ptr(octeon_bootinfo->phy_mem_desc_addr));
+	cvmx_bootmem_init(octeon_bootinfo->phy_mem_desc_addr);
 
 	sysinfo = cvmx_sysinfo_get();
 	memset(sysinfo, 0, sizeof(*sysinfo));
diff --git a/arch/mips/include/asm/octeon/cvmx-address.h b/arch/mips/include/asm/octeon/cvmx-address.h
index e2d874e..76a5348 100644
--- a/arch/mips/include/asm/octeon/cvmx-address.h
+++ b/arch/mips/include/asm/octeon/cvmx-address.h
@@ -104,6 +104,7 @@ typedef enum {
 typedef union {
 
 	uint64_t u64;
+#ifdef __BIG_ENDIAN_BITFIELD
 	/* mapped or unmapped virtual address */
 	struct {
 		uint64_t R:2;
@@ -181,7 +182,7 @@ typedef union {
 	struct {
 		uint64_t ones:49;
 		/* CVMX_ADD_WIN_SCR (0) in this case */
-		cvmx_add_win_dec_t csrdec:2;
+		uint64_t csrdec:2;
 		uint64_t addr:13;
 	} sscr;
 
@@ -203,6 +204,72 @@ typedef union {
 		uint64_t unused:40;
 	} sfilldidspace;
 
+#else
+	struct {
+		uint64_t offset:62;
+		uint64_t R:2;
+	} sva;
+
+	struct {
+		uint64_t offset:31;
+		uint64_t zeroes:33;
+	} suseg;
+
+	struct {
+		uint64_t offset:29;
+		uint64_t sp:2;
+		uint64_t ones:33;
+	} sxkseg;
+
+	struct {
+		uint64_t pa:49;
+		uint64_t mbz:10;
+		uint64_t cca:3;
+		uint64_t R:2;
+	} sxkphys;
+
+	struct {
+		uint64_t offset:36;
+		uint64_t unaddr:4;
+		uint64_t did:8;
+		uint64_t is_io:1;
+		uint64_t mbz:15;
+	} sphys;
+
+	struct {
+		uint64_t offset:36;
+		uint64_t unaddr:4;
+		uint64_t zeroes:24;
+	} smem;
+
+	struct {
+		uint64_t offset:36;
+		uint64_t unaddr:4;
+		uint64_t did:8;
+		uint64_t is_io:1;
+		uint64_t mbz:13;
+		uint64_t mem_region:2;
+	} sio;
+
+	struct {
+		uint64_t addr:13;
+		uint64_t csrdec:2;
+		uint64_t ones:49;
+	} sscr;
+
+	struct {
+		uint64_t addr:7;
+		uint64_t type:3;
+		uint64_t unused2:3;
+		uint64_t csrdec:2;
+		uint64_t ones:49;
+	} sdma;
+
+	struct {
+		uint64_t unused:40;
+		uint64_t didspace:24;
+	} sfilldidspace;
+#endif
 } cvmx_addr_t;
 
 /* These macros for used by 32 bit applications */
diff --git a/arch/mips/include/asm/octeon/cvmx-bootmem.h b/arch/mips/include/asm/octeon/cvmx-bootmem.h
index 352f1dc..540c84f 100644
--- a/arch/mips/include/asm/octeon/cvmx-bootmem.h
+++ b/arch/mips/include/asm/octeon/cvmx-bootmem.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,31 +22,38 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
-/*
- * Simple allocate only memory allocator.  Used to allocate memory at
- * application start time.
+/**
+ * @file
+ * Simple allocate only memory allocator.  Used to allocate memory at application
+ * start time.
+ *
+ *
  */
 
 #ifndef __CVMX_BOOTMEM_H__
 #define __CVMX_BOOTMEM_H__
-/* Must be multiple of 8, changing breaks ABI */
-#define CVMX_BOOTMEM_NAME_LEN 128
 
-/* Can change without breaking ABI */
-#define CVMX_BOOTMEM_NUM_NAMED_BLOCKS 64
 
 /* minimum alignment of bootmem alloced blocks */
 #define CVMX_BOOTMEM_ALIGNMENT_SIZE	(16ull)
+#define CVMX_BOOTMEM_NAME_LEN 128	/* Must be multiple of 8, changing breaks ABI */
+#define CVMX_BOOTMEM_NUM_NAMED_BLOCKS 64	/* Can change without breaking ABI */
 
 /* Flags for cvmx_bootmem_phy_mem* functions */
-/* Allocate from end of block instead of beginning */
-#define CVMX_BOOTMEM_FLAG_END_ALLOC    (1 << 0)
-
-/* Don't do any locking. */
-#define CVMX_BOOTMEM_FLAG_NO_LOCKING   (1 << 1)
+#define CVMX_BOOTMEM_FLAG_END_ALLOC    (1 << 0)	/* Allocate from end of block instead of beginning */
+#define CVMX_BOOTMEM_FLAG_NO_LOCKING   (1 << 1)	/* Don't do any locking. */
+
+/* Real physical addresses of memory regions */
+#define OCTEON_DDR0_BASE    (0x0ULL)
+#define OCTEON_DDR0_SIZE    (0x010000000ULL)
+#define OCTEON_DDR1_BASE    ((OCTEON_IS_OCTEON2()) ? 0x20000000ULL : 0x410000000ULL)
+#define OCTEON_DDR1_SIZE    (0x010000000ULL)
+#define OCTEON_DDR2_BASE    ((OCTEON_IS_OCTEON2()) ? 0x30000000ULL : 0x20000000ULL)
+#define OCTEON_DDR2_SIZE    ((OCTEON_IS_OCTEON2()) ? 0x7d0000000ULL : 0x3e0000000ULL)
+#define OCTEON_MAX_PHY_MEM_SIZE ((OCTEON_IS_MODEL(OCTEON_CN68XX)) ? 128*1024*1024*1024ULL : (OCTEON_IS_OCTEON2()) ? 32*1024*1024*1024ull : 16*1024*1024*1024ULL)
 
 /* First bytes of each free physical block of memory contain this structure,
  * which is used to maintain the free memory list.  Since the bootloader is
@@ -54,82 +61,87 @@
  * application init code converts addresses to 64 bit addresses before the
  * application starts.
  */
-struct cvmx_bootmem_block_header {
-	/*
-	 * Note: these are referenced from assembly routines in the
-	 * bootloader, so this structure should not be changed
-	 * without changing those routines as well.
-	 */
+typedef struct {
+	/* Note: these are referenced from assembly routines in the bootloader, so this structure
+	 ** should not be changed without changing those routines as well. */
 	uint64_t next_block_addr;
 	uint64_t size;
 
-};
+} cvmx_bootmem_block_header_t;
 
 /*
- * Structure for named memory blocks.  Number of descriptors available
- * can be changed without affecting compatibility, but name length
- * changes require a bump in the bootmem descriptor version Note: This
- * structure must be naturally 64 bit aligned, as a single memory
- * image will be used by both 32 and 64 bit programs.
+ * Structure for named memory blocks
+ * Number of descriptors
+ * available can be changed without affecting compatiblity,
+ * but name length changes require a bump in the bootmem
+ * descriptor version
+ * Note: This structure must be naturally 64 bit aligned, as a single
+ * memory image will be used by both 32 and 64 bit programs.
  */
 struct cvmx_bootmem_named_block_desc {
-	/* Base address of named block */
 	uint64_t base_addr;
-	/*
-	 * Size actually allocated for named block (may differ from
-	 * requested).
-	 */
+			    /**< Base address of named block */
 	uint64_t size;
-	/* name of named block */
+			    /**< Size actually allocated for named block (may differ from requested) */
 	char name[CVMX_BOOTMEM_NAME_LEN];
+					/**< name of named block */
 };
 
-/* Current descriptor versions */
-/* CVMX bootmem descriptor major version */
-#define CVMX_BOOTMEM_DESC_MAJ_VER   3
+typedef struct cvmx_bootmem_named_block_desc cvmx_bootmem_named_block_desc_t;
 
-/* CVMX bootmem descriptor minor version */
-#define CVMX_BOOTMEM_DESC_MIN_VER   0
+/* Current descriptor versions */
+#define CVMX_BOOTMEM_DESC_MAJ_VER   3	/* CVMX bootmem descriptor major version */
+#define CVMX_BOOTMEM_DESC_MIN_VER   0	/* CVMX bootmem descriptor minor version */
 
 /* First three members of cvmx_bootmem_desc_t are left in original
- * positions for backwards compatibility.
- */
-struct cvmx_bootmem_desc {
-	/* spinlock to control access to list */
+** positions for backwards compatibility.
+*/
+typedef struct {
+	/* Linux compatible proxy for __BIG_ENDIAN */
+#if defined(__BIG_ENDIAN_BITFIELD)
 	uint32_t lock;
-	/* flags for indicating various conditions */
+			    /**< spinlock to control access to list */
 	uint32_t flags;
+			    /**< flags for indicating various conditions */
 	uint64_t head_addr;
 
-	/* Incremented when incompatible changes made */
 	uint32_t major_version;
-
-	/*
-	 * Incremented changed when compatible changes made, reset to
-	 * zero when major incremented.
-	 */
+				/**< incremented changed when incompatible changes made */
 	uint32_t minor_version;
-
+				/**< incremented changed when compatible changes made, reset to zero when major incremented */
 	uint64_t app_data_addr;
 	uint64_t app_data_size;
 
-	/* number of elements in named blocks array */
 	uint32_t named_block_num_blocks;
-
-	/* length of name array in bootmem blocks */
+					 /**< number of elements in named blocks array */
 	uint32_t named_block_name_len;
-	/* address of named memory block descriptors */
+					 /**< length of name array in bootmem blocks */
 	uint64_t named_block_array_addr;
+					 /**< address of named memory block descriptors */
+#else				/* __LITTLE_ENDIAN */
+	uint32_t flags;
+	uint32_t lock;
+	uint64_t head_addr;
 
-};
+	uint32_t minor_version;
+	uint32_t major_version;
+	uint64_t app_data_addr;
+	uint64_t app_data_size;
+
+	uint32_t named_block_name_len;
+	uint32_t named_block_num_blocks;
+	uint64_t named_block_array_addr;
+#endif
+} cvmx_bootmem_desc_t;
 
 /**
  * Initialize the boot alloc memory structures. This is
  * normally called inside of cvmx_user_app_init()
  *
- * @mem_desc_ptr:	Address of the free memory list
+ * @mem_desc_addr:	Address of the free memory list
+ * Returns
  */
-extern int cvmx_bootmem_init(void *mem_desc_ptr);
+extern int cvmx_bootmem_init(uint64_t mem_desc_addr);
 
 /**
  * Allocate a block of memory from the free list that was passed
@@ -170,20 +182,43 @@ extern void *cvmx_bootmem_alloc_address(uint64_t size, uint64_t address,
  * @min_addr:  defines the minimum address of the range
  * @max_addr:  defines the maximum address of the range
  * @alignment: Alignment required - must be power of 2
+ * @flags:     Flags to control options for the allocation.
+ * Returns pointer to block of memory, NULL on error
+ */
+extern void *cvmx_bootmem_alloc_range_flags(uint64_t size, uint64_t alignment,
+					    uint64_t min_addr,
+					    uint64_t max_addr, uint32_t flags);
+
+/**
+ * Allocate a block of memory from the free list that was
+ * passed to the application by the bootloader within a specified
+ * address range. This is an allocate-only algorithm, so
+ * freeing memory is not possible. Allocation will fail if
+ * memory cannot be allocated in the requested range.
+ *
+ * @size:      Size in bytes of block to allocate
+ * @min_addr:  defines the minimum address of the range
+ * @max_addr:  defines the maximum address of the range
+ * @alignment: Alignment required - must be power of 2
  * Returns pointer to block of memory, NULL on error
  */
 extern void *cvmx_bootmem_alloc_range(uint64_t size, uint64_t alignment,
 				      uint64_t min_addr, uint64_t max_addr);
 
 /**
- * Frees a previously allocated named bootmem block.
+ * Allocate a block of memory from the free list that was passed
+ * to the application by the bootloader, and assign it a name in the
+ * global named block table.  (part of the cvmx_bootmem_descriptor_t structure)
+ * Named blocks can later be freed.
  *
- * @name:   name of block to free
+ * @size:  Size in bytes of block to allocate
+ * @alignment: Alignment required - must be power of 2
+ * @name:  name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes
  *
- * Returns 0 on failure,
- *	   !0 on success
+ * Returns pointer to block of memory, NULL on error
  */
-
+extern void *cvmx_bootmem_alloc_named(uint64_t size, uint64_t alignment,
+				      const char *name);
 
 /**
  * Allocate a block of memory from the free list that was passed
@@ -191,16 +226,15 @@ extern void *cvmx_bootmem_alloc_range(uint64_t size, uint64_t alignment,
  * global named block table.  (part of the cvmx_bootmem_descriptor_t structure)
  * Named blocks can later be freed.
  *
- * @size:      Size in bytes of block to allocate
+ * @size: Size in bytes of block to allocate
  * @alignment: Alignment required - must be power of 2
- * @name:      name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes
+ * @name: name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes
+ * @flags:     Flags to control options for the allocation.
  *
- * Returns a pointer to block of memory, NULL on error
+ * Returns pointer to block of memory, NULL on error
  */
-extern void *cvmx_bootmem_alloc_named(uint64_t size, uint64_t alignment,
-				      char *name);
-
-
+extern void *cvmx_bootmem_alloc_named_flags(uint64_t size, uint64_t alignment,
+					    const char *name, uint32_t flags);
 
 /**
  * Allocate a block of memory from the free list that was passed
@@ -214,12 +248,10 @@ extern void *cvmx_bootmem_alloc_named(uint64_t size, uint64_t alignment,
  * @name:     name of block - must be less than CVMX_BOOTMEM_NAME_LEN
  *	      bytes
  *
- * Returns a pointer to block of memory, NULL on error
+ * Returns pointer to block of memory, NULL on error
  */
 extern void *cvmx_bootmem_alloc_named_address(uint64_t size, uint64_t address,
-					      char *name);
-
-
+					      const char *name);
 
 /**
  * Allocate a block of memory from a specific range of the free list
@@ -232,16 +264,65 @@ extern void *cvmx_bootmem_alloc_named_address(uint64_t size, uint64_t address,
  * @size:      Size in bytes of block to allocate
  * @min_addr:  minimum address of range
  * @max_addr:  maximum address of range
- * @align:     Alignment of memory to be allocated. (must be a power of 2)
- * @name:      name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes
+ * @align:  Alignment of memory to be allocated. (must be a power of 2)
+ * @name:   name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes
  *
- * Returns a pointer to block of memory, NULL on error
+ * Returns pointer to block of memory, NULL on error
  */
 extern void *cvmx_bootmem_alloc_named_range(uint64_t size, uint64_t min_addr,
 					    uint64_t max_addr, uint64_t align,
-					    char *name);
+					    const char *name);
 
-extern int cvmx_bootmem_free_named(char *name);
+/**
+ * Allocate if needed a block of memory from a specific range of the
+ * free list that was passed to the application by the bootloader, and
+ * assign it a name in the global named block table.  (part of the
+ * cvmx_bootmem_descriptor_t structure) Named blocks can later be
+ * freed.  If the requested name block is already allocated, return
+ * the pointer to block of memory.  If request cannot be satisfied
+ * within the address range specified, NULL is returned
+ *
+ * @size:   Size in bytes of block to allocate
+ * @min_addr:  minimum address of range
+ * @max_addr:  maximum address of range
+ * @align:  Alignment of memory to be allocated. (must be a power of 2)
+ * @name:   name of block - must be less than CVMX_BOOTMEM_NAME_LEN bytes
+ * @init:   Initialization function
+ *
+ * Returns pointer to block of memory, NULL on error
+ */
+void *cvmx_bootmem_alloc_named_range_once(uint64_t size,
+					  uint64_t min_addr,
+					  uint64_t max_addr,
+					  uint64_t align,
+					  const char *name,
+					  void (*init) (void *));
+
+/**
+ * Allocate all free memory starting at the start address.  This is used to
+ * prevent any free blocks from later being allocated within the reserved space.
+ * Note that any memory allocated with this function cannot be later freed.
+ *
+ * @start_addr:  Starting address to reserve
+ * @size:        Size in bytes to reserve starting at start_addr
+ * @name:        Name to assign to reserved blocks
+ * @flags:       Flags to use when reserving memory
+ *
+ * Returns 0 on failure,
+ *         !0 on success
+ */
+extern int cvmx_bootmem_reserve_memory(uint64_t start_addr, uint64_t size,
+				       const char *name, uint32_t flags);
+
+/**
+ * Frees a previously allocated named bootmem block.
+ *
+ * @name:   name of block to free
+ *
+ * Returns 0 on failure,
+ *         !0 on success
+ */
+extern int cvmx_bootmem_free_named(const char *name);
 
 /**
  * Finds a named bootmem block by name.
@@ -251,7 +332,27 @@ extern int cvmx_bootmem_free_named(char *name);
  * Returns pointer to named block descriptor on success
  *	   0 on failure
  */
-struct cvmx_bootmem_named_block_desc *cvmx_bootmem_find_named_block(char *name);
+const cvmx_bootmem_named_block_desc_t *cvmx_bootmem_find_named_block(const char *name);
+
+/**
+ * Returns the size of available memory in bytes, only
+ * counting blocks that are at least as big as the minimum block
+ * size.
+ *
+ * @min_block_size:
+ *               Minimum block size to count in total.
+ *
+ * Returns Number of bytes available for allocation that meet the
+ * block size requirement
+ */
+uint64_t cvmx_bootmem_available_mem(uint64_t min_block_size);
+
+/**
+ * Prints out the list of named blocks that have been allocated
+ * along with their addresses and sizes.
+ * This is primarily used for debugging purposes
+ */
+void cvmx_bootmem_print_named(void);
 
 /**
  * Allocates a block of physical memory from the free list, at
@@ -301,12 +402,12 @@ int64_t cvmx_bootmem_phy_alloc(uint64_t req_size, uint64_t address_min,
  * @param name	    name to assign to named block
  * @param flags	    Flags to control options for the allocation.
  *
- * @return physical address of block allocated, or -1 on failure
+ * Returns physical address of block allocated, or -1 on failure
  */
 int64_t cvmx_bootmem_phy_named_block_alloc(uint64_t size, uint64_t min_addr,
 					   uint64_t max_addr,
 					   uint64_t alignment,
-					   char *name, uint32_t flags);
+					   const char *name, uint32_t flags);
 
 /**
  * Finds a named memory block by name.
@@ -315,14 +416,26 @@ int64_t cvmx_bootmem_phy_named_block_alloc(uint64_t size, uint64_t min_addr,
  * @name: Name of memory block to find.	 If NULL pointer given, then
  *	  finds unused descriptor, if available.
  *
- * @flags: Flags to control options for the allocation.
+ * @flags:  Flags to control options for the allocation.
  *
  * Returns Pointer to memory block descriptor, NULL if not found.
  *	   If NULL returned when name parameter is NULL, then no memory
  *	   block descriptors are available.
  */
-struct cvmx_bootmem_named_block_desc *
-cvmx_bootmem_phy_named_block_find(char *name, uint32_t flags);
+uint64_t cvmx_bootmem_phy_named_block_find(const char *name, uint32_t flags);
+
+/**
+ * Returns the size of available memory in bytes, only
+ * counting blocks that are at least as big as the minimum block
+ * size.
+ *
+ * @min_block_size:
+ *               Minimum block size to count in total.
+ *
+ * Returns Number of bytes available for allocation that meet the
+ * block size requirement
+ */
+uint64_t cvmx_bootmem_phy_available_mem(uint64_t min_block_size);
 
 /**
  * Frees a named block.
@@ -333,7 +446,7 @@ cvmx_bootmem_phy_named_block_find(char *name, uint32_t flags);
  * Returns 0 on failure
  *	   1 on success
  */
-int cvmx_bootmem_phy_named_block_free(char *name, uint32_t flags);
+int cvmx_bootmem_phy_named_block_free(const char *name, uint32_t flags);
 
 /**
  * Frees a block to the bootmem allocator list.	 This must
@@ -355,7 +468,38 @@ int cvmx_bootmem_phy_named_block_free(char *name, uint32_t flags);
 int __cvmx_bootmem_phy_free(uint64_t phy_addr, uint64_t size, uint32_t flags);
 
 /**
- * Locks the bootmem allocator.	 This is useful in certain situations
+ * Prints the list of currently allocated named blocks
+ *
+ */
+void cvmx_bootmem_phy_named_block_print(void);
+
+/**
+ * Prints the list of available memory.
+ *
+ */
+void cvmx_bootmem_phy_list_print(void);
+
+/**
+ * This function initializes the free memory list used by cvmx_bootmem.
+ * This must be called before any allocations can be done.
+ *
+ * @mem_size: Total memory available, in bytes
+ *
+ * @low_reserved_bytes: Number of bytes to reserve (leave out of
+ * free list) at address 0x0.
+ *
+ * @desc_buffer: Buffer for the bootmem descriptor.  This must be
+ *                 a 32 bit addressable address.
+ *
+ * Returns 1 on success
+ *         0 on failure
+ */
+int64_t cvmx_bootmem_phy_mem_list_init(uint64_t mem_size,
+				       uint32_t low_reserved_bytes,
+				       cvmx_bootmem_desc_t * desc_buffer);
+
+/**
+ * Locks the bootmem allocator.  This is useful in certain situations
  * where multiple allocations must be made without being interrupted.
  * This should be used with the CVMX_BOOTMEM_FLAG_NO_LOCKING flag.
  *
@@ -370,6 +514,17 @@ void cvmx_bootmem_lock(void);
  */
 void cvmx_bootmem_unlock(void);
 
-extern struct cvmx_bootmem_desc *cvmx_bootmem_get_desc(void);
+/**
+ * Internal use function to get the current descriptor pointer */
+void *__cvmx_bootmem_internal_get_desc_ptr(void);
+
+/**
+ * Internal use.  This is userd to get a pointer to a physical
+ * address.  For linux n32 the physical address in mmaped to a virtual
+ * address and the virtual address is returned.  For n64 the address
+ * is converted to an xkphys address and the xkhpys address is
+ * returned.
+ */
+void *__cvmx_phys_addr_to_ptr(uint64_t phys, int size);
 
 #endif /*   __CVMX_BOOTMEM_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-fau.h b/arch/mips/include/asm/octeon/cvmx-fau.h
index ef98f7f..6a62d29 100644
--- a/arch/mips/include/asm/octeon/cvmx-fau.h
+++ b/arch/mips/include/asm/octeon/cvmx-fau.h
@@ -1,10 +1,10 @@
 /***********************license start***************
- * Author: Cavium Networks
+ * Author: Cavium Inc.
  *
- * Contact: support@caviumnetworks.com
+ * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2003-2008 Cavium Networks
+ * Copyright (c) 2003-2010 Cavium Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -22,13 +22,9 @@
  * or visit http://www.gnu.org/licenses/.
  *
  * This file may also be available under a different license from Cavium.
- * Contact Cavium Networks for more information
+ * Contact Cavium Inc. for more information
  ***********************license end**************************************/
 
-/*
- * Interface to the hardware Fetch and Add Unit.
- */
-
 #ifndef __CVMX_FAU_H__
 #define __CVMX_FAU_H__
 
@@ -105,6 +101,16 @@ typedef union {
 	} s;
 } cvmx_fau_async_tagwait_result_t;
 
+#ifdef __LITTLE_ENDIAN_BITFIELD
+#define SWIZZLE_8  0x7
+#define SWIZZLE_16 0x6
+#define SWIZZLE_32 0x4
+#else
+#define SWIZZLE_8  0
+#define SWIZZLE_16 0
+#define SWIZZLE_32 0
+#endif
+
 /**
  * Builds a store I/O address for writing to the FAU
  *
@@ -116,7 +122,7 @@ typedef union {
  *		 - Step by 8 for 64 bit access.
  * Returns Address to store for atomic update
  */
-static inline uint64_t __cvmx_fau_store_address(uint64_t noadd, uint64_t reg)
+static inline uint64_t __cvmx_fau_store_address(uint64_t noadd, int reg)
 {
 	return CVMX_ADD_IO_SEG(CVMX_FAU_LOAD_IO_ADDRESS) |
 	       cvmx_build_bits(CVMX_FAU_BITS_NOADD, noadd) |
@@ -139,7 +145,7 @@ static inline uint64_t __cvmx_fau_store_address(uint64_t noadd, uint64_t reg)
  *		  22 bits are available.
  * Returns Address to read from for atomic update
  */
-static inline uint64_t __cvmx_fau_atomic_address(uint64_t tagwait, uint64_t reg,
+static inline uint64_t __cvmx_fau_atomic_address(uint64_t tagwait, int reg,
 						 int64_t value)
 {
 	return CVMX_ADD_IO_SEG(CVMX_FAU_LOAD_IO_ADDRESS) |
@@ -157,8 +163,7 @@ static inline uint64_t __cvmx_fau_atomic_address(uint64_t tagwait, uint64_t reg,
  *		  Note: Only the low 22 bits are available.
  * Returns Value of the register before the update
  */
-static inline int64_t cvmx_fau_fetch_and_add64(cvmx_fau_reg_64_t reg,
-					       int64_t value)
+static inline int64_t cvmx_fau_fetch_and_add64(int reg, int64_t value)
 {
 	return cvmx_read64_int64(__cvmx_fau_atomic_address(0, reg, value));
 }
@@ -172,9 +177,9 @@ static inline int64_t cvmx_fau_fetch_and_add64(cvmx_fau_reg_64_t reg,
  *		  Note: Only the low 22 bits are available.
  * Returns Value of the register before the update
  */
-static inline int32_t cvmx_fau_fetch_and_add32(cvmx_fau_reg_32_t reg,
-					       int32_t value)
+static inline int32_t cvmx_fau_fetch_and_add32(int reg, int32_t value)
 {
+	reg ^= SWIZZLE_32;
 	return cvmx_read64_int32(__cvmx_fau_atomic_address(0, reg, value));
 }
 
@@ -186,9 +191,9 @@ static inline int32_t cvmx_fau_fetch_and_add32(cvmx_fau_reg_32_t reg,
  * @value:   Signed value to add.
  * Returns Value of the register before the update
  */
-static inline int16_t cvmx_fau_fetch_and_add16(cvmx_fau_reg_16_t reg,
-					       int16_t value)
+static inline int16_t cvmx_fau_fetch_and_add16(int reg, int16_t value)
 {
+	reg ^= SWIZZLE_16;
 	return cvmx_read64_int16(__cvmx_fau_atomic_address(0, reg, value));
 }
 
@@ -199,8 +204,9 @@ static inline int16_t cvmx_fau_fetch_and_add16(cvmx_fau_reg_16_t reg,
  * @value:   Signed value to add.
  * Returns Value of the register before the update
  */
-static inline int8_t cvmx_fau_fetch_and_add8(cvmx_fau_reg_8_t reg, int8_t value)
+static inline int8_t cvmx_fau_fetch_and_add8(int reg, int8_t value)
 {
+	reg ^= SWIZZLE_8;
 	return cvmx_read64_int8(__cvmx_fau_atomic_address(0, reg, value));
 }
 
@@ -216,15 +222,14 @@ static inline int8_t cvmx_fau_fetch_and_add8(cvmx_fau_reg_8_t reg, int8_t value)
  *	   the value of the register before the update will be
  *	   returned
  */
-static inline cvmx_fau_tagwait64_t
-cvmx_fau_tagwait_fetch_and_add64(cvmx_fau_reg_64_t reg, int64_t value)
+static inline cvmx_fau_tagwait64_t cvmx_fau_tagwait_fetch_and_add64(int reg,
+								    int64_t value)
 {
 	union {
 		uint64_t i64;
 		cvmx_fau_tagwait64_t t;
 	} result;
-	result.i64 =
-	    cvmx_read64_int64(__cvmx_fau_atomic_address(1, reg, value));
+	result.i64 = cvmx_read64_int64(__cvmx_fau_atomic_address(1, reg, value));
 	return result.t;
 }
 
@@ -240,15 +245,15 @@ cvmx_fau_tagwait_fetch_and_add64(cvmx_fau_reg_64_t reg, int64_t value)
  *	   the value of the register before the update will be
  *	   returned
  */
-static inline cvmx_fau_tagwait32_t
-cvmx_fau_tagwait_fetch_and_add32(cvmx_fau_reg_32_t reg, int32_t value)
+static inline cvmx_fau_tagwait32_t cvmx_fau_tagwait_fetch_and_add32(int reg,
+								    int32_t value)
 {
 	union {
 		uint64_t i32;
 		cvmx_fau_tagwait32_t t;
 	} result;
-	result.i32 =
-	    cvmx_read64_int32(__cvmx_fau_atomic_address(1, reg, value));
+	reg ^= SWIZZLE_32;
+	result.i32 = cvmx_read64_int32(__cvmx_fau_atomic_address(1, reg, value));
 	return result.t;
 }
 
@@ -263,15 +268,15 @@ cvmx_fau_tagwait_fetch_and_add32(cvmx_fau_reg_32_t reg, int32_t value)
  *	   the value of the register before the update will be
  *	   returned
  */
-static inline cvmx_fau_tagwait16_t
-cvmx_fau_tagwait_fetch_and_add16(cvmx_fau_reg_16_t reg, int16_t value)
+static inline cvmx_fau_tagwait16_t cvmx_fau_tagwait_fetch_and_add16(int reg,
+								    int16_t value)
 {
 	union {
 		uint64_t i16;
 		cvmx_fau_tagwait16_t t;
 	} result;
-	result.i16 =
-	    cvmx_read64_int16(__cvmx_fau_atomic_address(1, reg, value));
+	reg ^= SWIZZLE_16;
+	result.i16 = cvmx_read64_int16(__cvmx_fau_atomic_address(1, reg, value));
 	return result.t;
 }
 
@@ -285,13 +290,14 @@ cvmx_fau_tagwait_fetch_and_add16(cvmx_fau_reg_16_t reg, int16_t value)
  *	   the value of the register before the update will be
  *	   returned
  */
-static inline cvmx_fau_tagwait8_t
-cvmx_fau_tagwait_fetch_and_add8(cvmx_fau_reg_8_t reg, int8_t value)
+static inline cvmx_fau_tagwait8_t cvmx_fau_tagwait_fetch_and_add8(int reg,
+								  int8_t value)
 {
 	union {
 		uint64_t i8;
 		cvmx_fau_tagwait8_t t;
 	} result;
+	reg ^= SWIZZLE_8;
 	result.i8 = cvmx_read64_int8(__cvmx_fau_atomic_address(1, reg, value));
 	return result.t;
 }
@@ -299,7 +305,7 @@ cvmx_fau_tagwait_fetch_and_add8(cvmx_fau_reg_8_t reg, int8_t value)
 /**
  * Builds I/O data for async operations
  *
- * @scraddr: Scratch pad byte address to write to.  Must be 8 byte aligned
+ * @scraddr: Scratch pad byte addres to write to.  Must be 8 byte aligned
  * @value:   Signed value to add.
  *		  Note: When performing 32 and 64 bit access, only the low
  *		  22 bits are available.
@@ -344,12 +350,10 @@ static inline uint64_t __cvmx_fau_iobdma_data(uint64_t scraddr, int64_t value,
  *		  Note: Only the low 22 bits are available.
  * Returns Placed in the scratch pad register
  */
-static inline void cvmx_fau_async_fetch_and_add64(uint64_t scraddr,
-						  cvmx_fau_reg_64_t reg,
+static inline void cvmx_fau_async_fetch_and_add64(uint64_t scraddr, int reg,
 						  int64_t value)
 {
-	cvmx_send_single(__cvmx_fau_iobdma_data
-			 (scraddr, value, 0, CVMX_FAU_OP_SIZE_64, reg));
+	cvmx_send_single(__cvmx_fau_iobdma_data(scraddr, value, 0, CVMX_FAU_OP_SIZE_64, reg));
 }
 
 /**
@@ -364,12 +368,10 @@ static inline void cvmx_fau_async_fetch_and_add64(uint64_t scraddr,
  *		  Note: Only the low 22 bits are available.
  * Returns Placed in the scratch pad register
  */
-static inline void cvmx_fau_async_fetch_and_add32(uint64_t scraddr,
-						  cvmx_fau_reg_32_t reg,
+static inline void cvmx_fau_async_fetch_and_add32(uint64_t scraddr, int reg,
 						  int32_t value)
 {
-	cvmx_send_single(__cvmx_fau_iobdma_data
-			 (scraddr, value, 0, CVMX_FAU_OP_SIZE_32, reg));
+	cvmx_send_single(__cvmx_fau_iobdma_data(scraddr, value, 0, CVMX_FAU_OP_SIZE_32, reg));
 }
 
 /**
@@ -383,12 +385,10 @@ static inline void cvmx_fau_async_fetch_and_add32(uint64_t scraddr,
  * @value:   Signed value to add.
  * Returns Placed in the scratch pad register
  */
-static inline void cvmx_fau_async_fetch_and_add16(uint64_t scraddr,
-						  cvmx_fau_reg_16_t reg,
+static inline void cvmx_fau_async_fetch_and_add16(uint64_t scraddr, int reg,
 						  int16_t value)
 {
-	cvmx_send_single(__cvmx_fau_iobdma_data
-			 (scraddr, value, 0, CVMX_FAU_OP_SIZE_16, reg));
+	cvmx_send_single(__cvmx_fau_iobdma_data(scraddr, value, 0, CVMX_FAU_OP_SIZE_16, reg));
 }
 
 /**
@@ -401,12 +401,10 @@ static inline void cvmx_fau_async_fetch_and_add16(uint64_t scraddr,
  * @value:   Signed value to add.
  * Returns Placed in the scratch pad register
  */
-static inline void cvmx_fau_async_fetch_and_add8(uint64_t scraddr,
-						 cvmx_fau_reg_8_t reg,
+static inline void cvmx_fau_async_fetch_and_add8(uint64_t scraddr, int reg,
 						 int8_t value)
 {
-	cvmx_send_single(__cvmx_fau_iobdma_data
-			 (scraddr, value, 0, CVMX_FAU_OP_SIZE_8, reg));
+	cvmx_send_single(__cvmx_fau_iobdma_data(scraddr, value, 0, CVMX_FAU_OP_SIZE_8, reg));
 }
 
 /**
@@ -425,11 +423,10 @@ static inline void cvmx_fau_async_fetch_and_add8(uint64_t scraddr,
  * Returns Placed in the scratch pad register
  */
 static inline void cvmx_fau_async_tagwait_fetch_and_add64(uint64_t scraddr,
-							  cvmx_fau_reg_64_t reg,
+							  int reg,
 							  int64_t value)
 {
-	cvmx_send_single(__cvmx_fau_iobdma_data
-			 (scraddr, value, 1, CVMX_FAU_OP_SIZE_64, reg));
+	cvmx_send_single(__cvmx_fau_iobdma_data(scraddr, value, 1, CVMX_FAU_OP_SIZE_64, reg));
 }
 
 /**
@@ -448,11 +445,10 @@ static inline void cvmx_fau_async_tagwait_fetch_and_add64(uint64_t scraddr,
  * Returns Placed in the scratch pad register
  */
 static inline void cvmx_fau_async_tagwait_fetch_and_add32(uint64_t scraddr,
-							  cvmx_fau_reg_32_t reg,
+							  int reg,
 							  int32_t value)
 {
-	cvmx_send_single(__cvmx_fau_iobdma_data
-			 (scraddr, value, 1, CVMX_FAU_OP_SIZE_32, reg));
+	cvmx_send_single(__cvmx_fau_iobdma_data(scraddr, value, 1, CVMX_FAU_OP_SIZE_32, reg));
 }
 
 /**
@@ -467,15 +463,13 @@ static inline void cvmx_fau_async_tagwait_fetch_and_add32(uint64_t scraddr,
  * @reg:     FAU atomic register to access. 0 <= reg < 2048.
  *		  - Step by 2 for 16 bit access.
  * @value:   Signed value to add.
- *
  * Returns Placed in the scratch pad register
  */
 static inline void cvmx_fau_async_tagwait_fetch_and_add16(uint64_t scraddr,
-							  cvmx_fau_reg_16_t reg,
+							  int reg,
 							  int16_t value)
 {
-	cvmx_send_single(__cvmx_fau_iobdma_data
-			 (scraddr, value, 1, CVMX_FAU_OP_SIZE_16, reg));
+	cvmx_send_single(__cvmx_fau_iobdma_data(scraddr, value, 1, CVMX_FAU_OP_SIZE_16, reg));
 }
 
 /**
@@ -489,15 +483,12 @@ static inline void cvmx_fau_async_tagwait_fetch_and_add16(uint64_t scraddr,
  *
  * @reg:     FAU atomic register to access. 0 <= reg < 2048.
  * @value:   Signed value to add.
- *
  * Returns Placed in the scratch pad register
  */
 static inline void cvmx_fau_async_tagwait_fetch_and_add8(uint64_t scraddr,
-							 cvmx_fau_reg_8_t reg,
-							 int8_t value)
+							 int reg, int8_t value)
 {
-	cvmx_send_single(__cvmx_fau_iobdma_data
-			 (scraddr, value, 1, CVMX_FAU_OP_SIZE_8, reg));
+	cvmx_send_single(__cvmx_fau_iobdma_data(scraddr, value, 1, CVMX_FAU_OP_SIZE_8, reg));
 }
 
 /**
@@ -507,7 +498,7 @@ static inline void cvmx_fau_async_tagwait_fetch_and_add8(uint64_t scraddr,
  *		  - Step by 8 for 64 bit access.
  * @value:   Signed value to add.
  */
-static inline void cvmx_fau_atomic_add64(cvmx_fau_reg_64_t reg, int64_t value)
+static inline void cvmx_fau_atomic_add64(int reg, int64_t value)
 {
 	cvmx_write64_int64(__cvmx_fau_store_address(0, reg), value);
 }
@@ -519,8 +510,9 @@ static inline void cvmx_fau_atomic_add64(cvmx_fau_reg_64_t reg, int64_t value)
  *		  - Step by 4 for 32 bit access.
  * @value:   Signed value to add.
  */
-static inline void cvmx_fau_atomic_add32(cvmx_fau_reg_32_t reg, int32_t value)
+static inline void cvmx_fau_atomic_add32(int reg, int32_t value)
 {
+	reg ^= SWIZZLE_32;
 	cvmx_write64_int32(__cvmx_fau_store_address(0, reg), value);
 }
 
@@ -531,8 +523,9 @@ static inline void cvmx_fau_atomic_add32(cvmx_fau_reg_32_t reg, int32_t value)
  *		  - Step by 2 for 16 bit access.
  * @value:   Signed value to add.
  */
-static inline void cvmx_fau_atomic_add16(cvmx_fau_reg_16_t reg, int16_t value)
+static inline void cvmx_fau_atomic_add16(int reg, int16_t value)
 {
+	reg ^= SWIZZLE_16;
 	cvmx_write64_int16(__cvmx_fau_store_address(0, reg), value);
 }
 
@@ -542,8 +535,9 @@ static inline void cvmx_fau_atomic_add16(cvmx_fau_reg_16_t reg, int16_t value)
  * @reg:     FAU atomic register to access. 0 <= reg < 2048.
  * @value:   Signed value to add.
  */
-static inline void cvmx_fau_atomic_add8(cvmx_fau_reg_8_t reg, int8_t value)
+static inline void cvmx_fau_atomic_add8(int reg, int8_t value)
 {
+	reg ^= SWIZZLE_8;
 	cvmx_write64_int8(__cvmx_fau_store_address(0, reg), value);
 }
 
@@ -554,7 +548,7 @@ static inline void cvmx_fau_atomic_add8(cvmx_fau_reg_8_t reg, int8_t value)
  *		  - Step by 8 for 64 bit access.
  * @value:   Signed value to write.
  */
-static inline void cvmx_fau_atomic_write64(cvmx_fau_reg_64_t reg, int64_t value)
+static inline void cvmx_fau_atomic_write64(int reg, int64_t value)
 {
 	cvmx_write64_int64(__cvmx_fau_store_address(1, reg), value);
 }
@@ -566,8 +560,9 @@ static inline void cvmx_fau_atomic_write64(cvmx_fau_reg_64_t reg, int64_t value)
  *		  - Step by 4 for 32 bit access.
  * @value:   Signed value to write.
  */
-static inline void cvmx_fau_atomic_write32(cvmx_fau_reg_32_t reg, int32_t value)
+static inline void cvmx_fau_atomic_write32(int reg, int32_t value)
 {
+	reg ^= SWIZZLE_32;
 	cvmx_write64_int32(__cvmx_fau_store_address(1, reg), value);
 }
 
@@ -578,8 +573,9 @@ static inline void cvmx_fau_atomic_write32(cvmx_fau_reg_32_t reg, int32_t value)
  *		  - Step by 2 for 16 bit access.
  * @value:   Signed value to write.
  */
-static inline void cvmx_fau_atomic_write16(cvmx_fau_reg_16_t reg, int16_t value)
+static inline void cvmx_fau_atomic_write16(int reg, int16_t value)
 {
+	reg ^= SWIZZLE_16;
 	cvmx_write64_int16(__cvmx_fau_store_address(1, reg), value);
 }
 
@@ -589,8 +585,9 @@ static inline void cvmx_fau_atomic_write16(cvmx_fau_reg_16_t reg, int16_t value)
  * @reg:     FAU atomic register to access. 0 <= reg < 2048.
  * @value:   Signed value to write.
  */
-static inline void cvmx_fau_atomic_write8(cvmx_fau_reg_8_t reg, int8_t value)
+static inline void cvmx_fau_atomic_write8(int reg, int8_t value)
 {
+	reg ^= SWIZZLE_8;
 	cvmx_write64_int8(__cvmx_fau_store_address(1, reg), value);
 }
 
diff --git a/arch/mips/include/asm/octeon/cvmx-packet.h b/arch/mips/include/asm/octeon/cvmx-packet.h
index 38aefa1..d472d6a 100644
--- a/arch/mips/include/asm/octeon/cvmx-packet.h
+++ b/arch/mips/include/asm/octeon/cvmx-packet.h
@@ -39,6 +39,7 @@ union cvmx_buf_ptr {
 	void *ptr;
 	uint64_t u64;
 	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
 		/* if set, invert the "free" pick of the overall
 		 * packet. HW always sets this bit to 0 on inbound
 		 * packet */
@@ -55,6 +56,13 @@ union cvmx_buf_ptr {
 		uint64_t size:16;
 		/* Pointer to the first byte of the data, NOT buffer */
 		uint64_t addr:40;
+#else
+		uint64_t addr:40;
+		uint64_t size:16;
+		uint64_t pool:3;
+		uint64_t back:4;
+		uint64_t i:1;
+#endif
 	} s;
 };
 
diff --git a/arch/mips/include/asm/octeon/octeon-model.h b/arch/mips/include/asm/octeon/octeon-model.h
index ff906c2..a11d4e6 100644
--- a/arch/mips/include/asm/octeon/octeon-model.h
+++ b/arch/mips/include/asm/octeon/octeon-model.h
@@ -328,6 +328,13 @@ static inline int __octeon_is_model_runtime__(uint32_t model)
 #define OCTEON_IS_COMMON_BINARY() 1
 #undef OCTEON_MODEL
 
+#define OCTEON_IS_OCTEON1()	OCTEON_IS_MODEL(OCTEON_CN3XXX)
+#define OCTEON_IS_OCTEONPLUS()	OCTEON_IS_MODEL(OCTEON_CN5XXX)
+#define OCTEON_IS_OCTEON2()	\
+	(OCTEON_IS_MODEL(OCTEON_CN6XXX) || OCTEON_IS_MODEL(OCTEON_CNF71XX))
+
+#define OCTEON_IS_OCTEON1PLUS()	(OCTEON_IS_OCTEON1() || OCTEON_IS_OCTEONPLUS())
+
 const char *octeon_model_get_string(uint32_t chip_id);
 const char *octeon_model_get_string_buffer(uint32_t chip_id, char *buffer);
 
-- 
2.6.2

