From 5047ae2d3c46f4e764fb2f87925582445ae210e3 Mon Sep 17 00:00:00 2001
From: Emil Goranov <egoranov@caviumnetworks.com>
Date: Tue, 15 Jul 2014 18:05:50 -0700
Subject: [PATCH 949/974] oct-app-ctl: get correct value for available
 cores(not limited to 32 cores)

The bootloader was modified (svn 126700) to communicate coremask of
the cores available on the system and the idle cores after cores
have been started, by named_block with name '__common_bootinfo'.
These data, which are addition to cvmx_bootinfo are structured as
cvmx_coremask_t 'hardware_coremask' and 'aval_coremask' and can be
retrieved from all interested started clients (SE or Linux).
This patch gets the idle_coremask which is needed for oct-app-ctl.

Signed-off-by: Emil Goranov <egoranov@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/unplug-cpu.c         | 58 ++++++++++++++++++++++++----
 arch/mips/include/asm/octeon/cvmx-app-init.h | 26 ++++++++++++-
 2 files changed, 76 insertions(+), 8 deletions(-)

diff --git a/arch/mips/cavium-octeon/unplug-cpu.c b/arch/mips/cavium-octeon/unplug-cpu.c
index fdaca18..a7eda91 100644
--- a/arch/mips/cavium-octeon/unplug-cpu.c
+++ b/arch/mips/cavium-octeon/unplug-cpu.c
@@ -15,12 +15,14 @@
 #include <asm/octeon/octeon-boot-info.h>
 #include <asm/octeon/cvmx-app-hotplug.h>
 #include <asm/octeon/cvmx-spinlock.h>
+#include <asm/octeon/cvmx-coremask.h>
 
 static struct cvmx_boot_vector_element *octeon_bootvector;
 static void *octeon_replug_ll_raw;
 asmlinkage void octeon_replug_ll(void);
 
 static struct cvmx_app_hotplug_global *hgp;
+static const cvmx_bootmem_named_block_desc_t *ccbi_desc;
 
 DECLARE_PER_CPU(struct cpu, cpu_devices);
 
@@ -136,10 +138,27 @@ static ssize_t unplug_cpu_print(struct device *dev,
 DEVICE_ATTR(octeon_plug, 0644, unplug_cpu_print, plug_cpu_store);
 DEVICE_ATTR(octeon_unplug, 0644, unplug_cpu_print, unplug_cpu_store);
 
+/* the following function will work ONLY with size%8 = 0 */
+static
+int __cvmx_copy_from_bootmem(int64_t bootmem_src_addr, void *dst_ptr, int size)
+{
+	int i;
+	int64_t base_addr = (1ull << 63) | bootmem_src_addr;
+	int64_t *ptr64 = dst_ptr;
+
+	for (i = 0; i < size/8; i++) {
+		ptr64[i] = cvmx_read64_int64(base_addr);
+		base_addr += 8;
+	}
+	return 0;
+}
+
 static void __init octeon_hotplug_global_init(void *arg)
 {
 	struct linux_app_boot_info *labi;
 	cvmx_app_hotplug_global_t *hgp = arg;
+	cvmx_cores_common_bootinfo_t ccbi;
+
 	memset(hgp, 0, CVMX_APP_HOTPLUG_INFO_REGION_SIZE);
 
 	hgp->magic_version = CVMX_HOTPLUG_MAGIC_VERSION;
@@ -149,13 +168,28 @@ static void __init octeon_hotplug_global_init(void *arg)
 	/* Get legacy LABI data structure for initial parameters */
 	labi = phys_to_virt(LABI_ADDR_IN_BOOTLOADER);
 
-	/* Valicate signature */
-	if (labi->labi_signature != LABI_SIGNATURE)
-		return;
-
-	/* Initialize available cores from LABI */
-	cvmx_coremask_set64(&hgp->avail_coremask,
-		(uint64_t) labi->avail_coremask);
+	/* Initialize available cores from LABI is limited to 32 cores
+	 * - try to do not use it - instead do ... */
+	if (ccbi_desc) { /* 'common bootinfo' named block is found - use it*/
+		__cvmx_copy_from_bootmem(ccbi_desc->base_addr, &ccbi,
+					sizeof(cvmx_cores_common_bootinfo_t));
+		/* Validate signature */
+		if (ccbi.magic != CVMX_COMMON_BOOTINFO_MAGIC)
+			return; /* if 'magic' does not match - exit */
+		/* the members from the initial(1) version are always valid */
+		/* only hgp->avail_coremask is need - fill it in */
+		cvmx_coremask_copy(&hgp->avail_coremask, &ccbi.avail_coremask);
+		/* the extra (version) members (if any) are valid when
+		 * (2 <= ccbi.version <= CVMX_COMMON_BOOTINFO_VERSION)
+		 * if (ccbi.version >= 2) { xxx = ccbi.ver2_member; }
+		 */
+	} else { /* the older bootloaders provide only labi->avail_coremask */
+		/* Validate signature */
+		if (labi->labi_signature != LABI_SIGNATURE)
+			return;
+		cvmx_coremask_set64(&hgp->avail_coremask,
+					(uint64_t) labi->avail_coremask);
+	}
 }
 
 static int __init unplug_cpu_init(void)
@@ -170,6 +204,16 @@ static int __init unplug_cpu_init(void)
 	t = __pa_symbol(octeon_replug_ll);
 	octeon_replug_ll_raw = phys_to_virt(t);
 
+	/* the 'common bootinfo' named block should be found/copied before
+	 * creating hotplug named block,
+	 * because avail_coremask is copied from it
+	 */
+	ccbi_desc =
+		cvmx_bootmem_find_named_block(CVMX_APP_COMMON_BOOTINFO_NAME);
+	if (!ccbi_desc)
+		pr_info("Info: cvmx_bootmem_find_named_block(%s) not found.\n",
+						CVMX_APP_COMMON_BOOTINFO_NAME);
+
 	hgp = cvmx_bootmem_alloc_named_range_once(
 		CVMX_APP_HOTPLUG_INFO_REGION_SIZE,
 		0x0, 1ull << 29, 0,
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index 4a965ee..2ca2ea5 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -41,7 +41,7 @@
  * @file
  * Header file for simple executive application initialization.  This defines
  * part of the ABI between the bootloader and the application.
- * <hr>$Revision: 123622 $<hr>
+ * <hr>$Revision: 126111 $<hr>
  *
  */
 
@@ -214,6 +214,30 @@ typedef struct cvmx_bootinfo cvmx_bootinfo_t;
 
 #endif /*   (CVMX_BOOTINFO_MAJ_VER == 1) */
 
+
+
+/* the following structure extend bootinfo with common for all cores data
+ * It will be put in named block. No need of locking - it will be written just
+ * once from the bootloader and will be only read from others
+ */
+#define CVMX_COMMON_BOOTINFO_MAGIC	0x1234567887654321
+	/* NOTE: this constant is endian agnostic (same for LE and BE) */
+#define CVMX_COMMON_BOOTINFO_VERSION	1	/* 1 based */
+#define CVMX_APP_COMMON_BOOTINFO_NAME	"__common_bootinfo"
+#define CVMX_APP_COMMON_BOOTINFO_SIZE	sizeof(cvmx_cores_common_bootinfo_t)
+
+struct cvmx_cores_common_bootinfo {
+	uint64_t	magic;
+	uint64_t	version; /*keep simple - we do not plan other versions*/
+	cvmx_coremask_t hardware_coremask;
+	cvmx_coremask_t avail_coremask;
+#if (CVMX_COMMON_BOOTINFO_VERSION >= 2)
+	/* declare ver2_members here*/;
+#endif
+};
+
+typedef struct cvmx_cores_common_bootinfo cvmx_cores_common_bootinfo_t;
+
 /* Type defines for board and chip types */
 enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_NULL = 0,
-- 
2.6.2

