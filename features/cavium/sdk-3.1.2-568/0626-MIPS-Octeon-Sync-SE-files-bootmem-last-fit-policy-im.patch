From 8cf80ee5c4a12c7ec17be0e595ebb67b12bab841 Mon Sep 17 00:00:00 2001
From: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Date: Tue, 29 Jul 2014 18:05:50 -0700
Subject: [PATCH 626/974] MIPS: Octeon: Sync SE files, bootmem "last-fit"
 policy implemented The "Last fit" policy will allocate memory from the
 highest physical address that fits the range spec, so that low memory is only
 used when necesary, or when it is the only remaining free memory. The memory
 population in setup.c has been already changed to guarantee a fixed amount of
 32-bit memory for the kernel in a previous commit.

Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bootmem.c | 327 +++++++++++++----------
 arch/mips/include/asm/octeon/octeon-boot-info.h  |   2 +
 2 files changed, 184 insertions(+), 145 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
index f79a1c65..8e8f854 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
@@ -43,7 +43,7 @@
  * Simple allocate only memory allocator.  Used to allocate memory at
  * application start time.
  *
- * <hr>$Revision: 96308 $<hr>
+ * <hr>$Revision: 102155 $<hr>
  *
  */
 
@@ -443,7 +443,16 @@ static int __cvmx_validate_mem_range(uint64_t *min_addr_ptr,
 				     uint64_t *max_addr_ptr)
 {
 
-#if defined(__linux__) && defined(CVMX_ABI_N32)
+#ifdef CVMX_BUILD_FOR_UBOOT
+	{
+		uint64_t max_phys = (1ull << 29) - 0x10;	/* KSEG0 */
+		*min_addr_ptr = MIN(MAX(*min_addr_ptr, 0x0), max_phys);
+		if (!*max_addr_ptr)
+			*max_addr_ptr = max_phys;
+		else
+			*max_addr_ptr = MAX(MIN(*max_addr_ptr, max_phys), 0x0);
+	}
+#elif defined(__linux__) && defined(CVMX_ABI_N32)
 	{
 		extern uint64_t linux_mem32_min;
 		extern uint64_t linux_mem32_max;
@@ -467,7 +476,7 @@ static int __cvmx_validate_mem_range(uint64_t *min_addr_ptr,
 #elif defined(CVMX_ABI_N32)
 	{
 		/* Max physical address when 1-1 mappings not used */
-		uint32_t max_phys = 0x7FFFFFFF;
+		uint32_t max_phys = 0x1FFFFFFF; /* 512 MB */
 
 		/* We are are running standalone simple executive, so we need
 		 * to limit the range that we allocate from
@@ -694,56 +703,59 @@ int64_t cvmx_bootmem_phy_alloc(uint64_t req_size, uint64_t address_min,
 			       uint32_t flags)
 {
 
-	uint64_t head_addr;
-	uint64_t ent_addr;
-	/* points to previous list entry, NULL current entry is head of list */
-	uint64_t prev_addr = 0;
-	uint64_t new_ent_addr = 0;
-	uint64_t desired_min_addr;
-	uint64_t alignment_mask = ~(alignment - 1);
+	uint64_t head_addr, ent_addr, ent_size;
+	uint64_t target_ent_addr = 0, target_prev_addr = 0;
+	uint64_t target_size = ~0ull;
+	uint64_t free_start, free_end;
+	uint64_t next_addr, prev_addr = 0;
+	uint64_t new_ent_addr = 0, new_ent_size;
+	uint64_t desired_min_addr, usable_max;
+	uint64_t align, align_mask;
 
 #ifdef DEBUG
-	cvmx_dprintf("cvmx_bootmem_phy_alloc: req_size: 0x%llx, min_addr: "
+	cvmx_dprintf("%s: req_size: 0x%llx, min_addr: "
 		     "0x%llx, max_addr: 0x%llx, align: 0x%llx\n",
+		     __func__,
 		     CAST_ULL(req_size), CAST_ULL(address_min),
 		     CAST_ULL(address_max), CAST_ULL(alignment));
 #endif
 
 	if (__cvmx_bootmem_check_version(0))
-		goto error_out;
+		return -1;
 
 	/*
 	 * Do a variety of checks to validate the arguments.  The
-	 * allocator code will later assume * that these checks have
+	 * allocator code will later assume that these checks have
 	 * been made.  We validate that the requested constraints are
-	 * not * self-contradictory before we look through the list of
+	 * not self-contradictory before we look through the list of
 	 * available memory
 	 */
 
 	/* 0 is not a valid req_size for this allocator */
 	if (!req_size)
-		goto error_out;
+		return -1;
 
-	/* Round req_size up to mult of minimum alignment bytes */
+	/* Round req_size up to multiple of minimum alignment bytes */
 	req_size = (req_size + (CVMX_BOOTMEM_ALIGNMENT_SIZE - 1)) &
 		   ~(CVMX_BOOTMEM_ALIGNMENT_SIZE - 1);
 
-	/*
-	 * Enforce minimum alignment (this also keeps the minimum free block
-	 * req_size the same as the alignment req_size
-	 */
-	if (alignment < CVMX_BOOTMEM_ALIGNMENT_SIZE)
-		alignment = CVMX_BOOTMEM_ALIGNMENT_SIZE;
+	/* Make sure alignment is power of 2, and at least the minimum */
+	for (align = CVMX_BOOTMEM_ALIGNMENT_SIZE;
+	    align < (1ull<<48);
+	    align <<= 1) {
+		if (align >= alignment)
+			break;
+	}
 
-	alignment_mask = ~(alignment - 1);
+	align_mask = ~(align - 1);
 
 	/*
 	 * Adjust address minimum based on requested alignment (round
 	 * up to meet alignment).  Do this here so we can reject
 	 * impossible requests up front. (NOP for address_min == 0)
 	 */
-	if (alignment)
-		address_min = (address_min + (alignment - 1)) & ~(alignment - 1);
+	address_min = (address_min + (align - 1)) & align_mask;
+
 	/*
 	 * Convert !0 address_min and 0 address_max to special case of
 	 * range that specifies an exact memory block to allocate.  Do
@@ -753,7 +765,7 @@ int64_t cvmx_bootmem_phy_alloc(uint64_t req_size, uint64_t address_min,
 	if (address_min && !address_max)
 		address_max = address_min + req_size;
 	else if (!address_min && !address_max)
-		address_max = ~0ull;	/* If no limits given, use max limits */
+		address_max = ~0ull;	/* If no limits given, use max */
 
 	/*
 	 * Reject inconsistent args.  We have adjusted these, so this
@@ -761,130 +773,154 @@ int64_t cvmx_bootmem_phy_alloc(uint64_t req_size, uint64_t address_min,
 	 * would pass for the values the user supplied.
 	 */
 	if (req_size > address_max - address_min)
-		goto error_out;
-
-	/* Walk through the list entries - first fit found is returned */
+		return -1;
 
 	__cvmx_bootmem_lock(flags);
+
+	/* Walk through the list entries to find the right fit */
 	head_addr = CVMX_BOOTMEM_DESC_GET_FIELD(head_addr);
-	ent_addr = head_addr;
-	while (ent_addr) {
-		uint64_t usable_base, usable_max;
-		uint64_t ent_size = cvmx_bootmem_phy_get_size(ent_addr);
-
-		if (cvmx_bootmem_phy_get_next(ent_addr)
-		    && ent_addr > cvmx_bootmem_phy_get_next(ent_addr)) {
-			cvmx_dprintf("Internal bootmem_alloc() error: ent: "
-				     "0x%llx, next: 0x%llx\n",
-				     CAST_ULL(ent_addr),
-				     CAST_ULL(cvmx_bootmem_phy_get_next(ent_addr)));
+
+	for (ent_addr = head_addr;
+		ent_addr != 0ULL && ent_addr < address_max;
+		prev_addr = ent_addr,
+		ent_addr = cvmx_bootmem_phy_get_next(ent_addr)) {
+
+		/* Raw free block size */
+		ent_size = cvmx_bootmem_phy_get_size(ent_addr);
+		next_addr = cvmx_bootmem_phy_get_next(ent_addr);
+
+		/* Validate the free list ascending order */
+		if (ent_size < CVMX_BOOTMEM_ALIGNMENT_SIZE ||
+		    (next_addr && ent_addr > next_addr)) {
+			cvmx_dprintf("ERROR: %s: bad free list ent: %#llx, next: %#llx\n",
+				__func__, CAST_ULL(ent_addr),
+				CAST_ULL(next_addr));
 			goto error_out;
 		}
 
-		/*
-		 * Determine if this is an entry that can satisify the
-		 * request Check to make sure entry is large enough to
-		 * satisfy request
-		 */
-		usable_base = ALIGN_ADDR_UP(MAX(address_min, ent_addr),
-					    alignment_mask);
-		usable_max = MIN(address_max, ent_addr + ent_size);
-		/* We should be able to allocate block at address usable_base */
+		/* adjust free block edges for alignment */
+		free_start = (ent_addr + align - 1) & align_mask;
+		free_end = (ent_addr + ent_size) &  align_mask;
 
-		desired_min_addr = usable_base;
+		/* check that free block is large enough */
+		if ((free_start + req_size) > free_end)
+			continue;
 
-		/*
-		 * Determine if request can be satisfied from the
-		 * current entry
-		 */
-		if (((ent_addr + ent_size) > usable_base
-		     && ent_addr < address_max)
-		    && req_size <= usable_max - usable_base) {
-			/*
-			 * We have found an entry that has room to satisfy the
-			 * request, so allocate it from this entry
-			 *
-			 * If end CVMX_BOOTMEM_FLAG_END_ALLOC set, then allocate
-			 * from the end of this block rather than the beginning
-			 */
-			if (flags & CVMX_BOOTMEM_FLAG_END_ALLOC) {
-				desired_min_addr = usable_max - req_size;
-				/*
-				 * Align desired address down to required
-				 * alignment
-				 */
-				desired_min_addr &= alignment_mask;
-			}
+		/* check that desired start is within the free block */
+		if (free_end < address_min || free_start > address_max)
+			continue;
+		if ((free_end - address_min) < req_size)
+			continue;
+		if ((address_max - free_start) < req_size)
+			continue;
 
-			/* Match at start of entry */
-			if (desired_min_addr == ent_addr) {
-				if (req_size < ent_size) {
-					/*
-					 * big enough to create a new block from
-					 * top portion of block
-					 */
-					new_ent_addr = ent_addr + req_size;
-					cvmx_bootmem_phy_set_next(new_ent_addr,
-						cvmx_bootmem_phy_get_next(ent_addr));
-					cvmx_bootmem_phy_set_size(new_ent_addr,
-							ent_size - req_size);
-
-					/*
-					 * Adjust next pointer as
-					 * following code uses this.
-					 */
-					cvmx_bootmem_phy_set_next(ent_addr,
-								  new_ent_addr);
-				}
+		/* Found usebale free block */
+		target_ent_addr = ent_addr;
+		target_prev_addr = prev_addr;
+		target_size = ent_size;
 
-				/*
-				 * adjust prev ptr or head to remove this entry
-				 * from list
-				 */
-				if (prev_addr) {
-					cvmx_bootmem_phy_set_next(prev_addr,
-						cvmx_bootmem_phy_get_next(ent_addr));
-				} else {
-					/* head of list being returned, so update head ptr */
-					CVMX_BOOTMEM_DESC_SET_FIELD(head_addr,
-						cvmx_bootmem_phy_get_next(ent_addr));
-				}
-				__cvmx_bootmem_unlock(flags);
+		/* Continue looking for highest/best block that fits */
+	}
+
+	/* Bail if the search has resulted in no eligible free blocks */
+	if (target_ent_addr == 0) {
 #ifdef DEBUG
-				cvmx_dprintf("cvmx_bootmem_phy_alloc: req_size:"
-					     " 0x%llx, addr: 0x%llx\n",
-					     CAST_ULL(req_size),
-					     CAST_ULL(desired_min_addr));
+		cvmx_dprintf("%s: eligible free block not found\n", __func__);
 #endif
-				return desired_min_addr;
-			}
+		goto error_out;
+	}
 
-			/* block returned doesn't start at beginning of entry,
-			 * so we know that we will be splitting a block off the
-			 * front of this one.  Create a new block from the
-			 * beginning, add to list, and go to top of loop again.
-			 *
-			 * create a new block from the high portion of the
-			 * block so that the top block starts at the desired
-			 * addr
-			 */
-			new_ent_addr = desired_min_addr;
-			cvmx_bootmem_phy_set_next(new_ent_addr,
-					cvmx_bootmem_phy_get_next(ent_addr));
-			cvmx_bootmem_phy_set_size(new_ent_addr,
-					cvmx_bootmem_phy_get_size(ent_addr) -
-					 (desired_min_addr - ent_addr));
-			cvmx_bootmem_phy_set_size(ent_addr,
-						  desired_min_addr - ent_addr);
-			cvmx_bootmem_phy_set_next(ent_addr, new_ent_addr);
-			/* Loop again to handle actual alloc from new block */
-		}
+	/* Found the free block to allocate from */
+	ent_addr = target_ent_addr;
+	prev_addr = target_prev_addr;
+	ent_size = target_size;
+
+#ifdef DEBUG
+	cvmx_dprintf("%s: using free block at %#010llx size %#llx\n",
+		__func__, CAST_ULL(ent_addr), CAST_ULL(ent_size));
+#endif
+
+	/* Always allocate from the end of a free block */
+	usable_max = MIN(address_max, ent_addr + ent_size);
+	desired_min_addr = usable_max - req_size;
+	desired_min_addr &= align_mask;
+
+	/* Split current free block into up to 3 free blocks */
 
+	/* Check for head room */
+	if (desired_min_addr > ent_addr) {
+		/* Create a new free block at the allocation address */
+		new_ent_addr = desired_min_addr;
+		new_ent_size = ent_size - (desired_min_addr - ent_addr);
+
+		cvmx_bootmem_phy_set_next(new_ent_addr,
+				cvmx_bootmem_phy_get_next(ent_addr));
+		cvmx_bootmem_phy_set_size(new_ent_addr, new_ent_size);
+
+		/* Split out head room into a new free block */
+		ent_size -= new_ent_size;
+		cvmx_bootmem_phy_set_next(ent_addr, new_ent_addr);
+		cvmx_bootmem_phy_set_size(ent_addr, ent_size);
+
+#ifdef DEBUG
+		cvmx_dprintf("%s: splitting head, addr %#llx size %#llx\n",
+		__func__, CAST_ULL(ent_addr), CAST_ULL(ent_size));
+#endif
+		/* Make the allocation target the current free block */
 		prev_addr = ent_addr;
-		ent_addr = cvmx_bootmem_phy_get_next(ent_addr);
+		ent_addr = new_ent_addr;
+		ent_size = new_ent_size;
 	}
+
+	/* Check for tail room */
+	if ((desired_min_addr + req_size) < (ent_addr + ent_size)) {
+		new_ent_addr = ent_addr + req_size;
+		new_ent_size = ent_size - req_size;
+
+		/* Create a new free block from tail room */
+		cvmx_bootmem_phy_set_next(new_ent_addr,
+				cvmx_bootmem_phy_get_next(ent_addr));
+		cvmx_bootmem_phy_set_size(new_ent_addr, new_ent_size);
+
+#ifdef DEBUG
+		cvmx_dprintf("%s: splitting tail, addr %#llx size %#llx\n",
+		__func__, CAST_ULL(new_ent_addr), CAST_ULL(new_ent_size));
+#endif
+
+		/* Adjust the current block to exclude tail room */
+		ent_size = ent_size - new_ent_size;
+		cvmx_bootmem_phy_set_next(ent_addr, new_ent_addr);
+		cvmx_bootmem_phy_set_size(ent_addr, ent_size);
+	}
+
+	/* The current free block IS the allocation target */
+	if (desired_min_addr != ent_addr || ent_size != req_size)
+		cvmx_dprintf("ERROR: %s: internal error - addr %#llx %#llx size %#llx %#llx\n",
+		__func__,
+		CAST_ULL(desired_min_addr),  CAST_ULL(ent_addr),
+		CAST_ULL(ent_size), CAST_ULL(req_size));
+
+	/* Remove the current free block from list */
+	if (prev_addr) {
+		cvmx_bootmem_phy_set_next(prev_addr,
+				cvmx_bootmem_phy_get_next(ent_addr));
+	} else {
+		/* head of list being returned, so update head ptr */
+		CVMX_BOOTMEM_DESC_SET_FIELD(head_addr,
+				cvmx_bootmem_phy_get_next(ent_addr));
+	}
+
+	__cvmx_bootmem_unlock(flags);
+#ifdef DEBUG
+	cvmx_dprintf("%s: allocated size: %#llx, at addr: %#010llx\n",
+			__func__,
+			CAST_ULL(req_size),
+			CAST_ULL(desired_min_addr));
+#endif
+	return desired_min_addr;
+
 error_out:
-	/* We didn't find anything, so return error */
+	/* Requested memory not found or argument error */
 	__cvmx_bootmem_unlock(flags);
 	return -1;
 }
@@ -896,16 +932,20 @@ int __cvmx_bootmem_phy_free(uint64_t phy_addr, uint64_t size, uint32_t flags)
 	int retval = 0;
 
 #ifdef DEBUG
-	cvmx_dprintf("__cvmx_bootmem_phy_free addr: 0x%llx, size: 0x%llx\n",
+	cvmx_dprintf("%s addr: %#llx, size: %#llx\n", __func__,
 		     CAST_ULL(phy_addr), CAST_ULL(size));
 #endif
 	if (__cvmx_bootmem_check_version(0))
 		return 0;
 
 	/* 0 is not a valid size for this allocator */
-	if (!size)
+	if (!size || !phy_addr)
 		return 0;
 
+	/* Round size up to mult of minimum alignment bytes */
+	size = (size + (CVMX_BOOTMEM_ALIGNMENT_SIZE - 1)) &
+		   ~(CVMX_BOOTMEM_ALIGNMENT_SIZE - 1);
+
 	__cvmx_bootmem_lock(flags);
 	cur_addr = CVMX_BOOTMEM_DESC_GET_FIELD(head_addr);
 	if (cur_addr == 0 || phy_addr < cur_addr) {
@@ -1476,11 +1516,9 @@ int cvmx_bootmem_reserve_memory(uint64_t start_addr, uint64_t size,
 	char block_name[CVMX_BOOTMEM_NAME_LEN];
 
 #ifdef DEBUG
-	cvmx_dprintf("%s (start_addr: 0x%llx, size: 0x%llx, name: %s, flags:"
-		     "0x%x)\n", __func__, CAST_ULL(start_addr), CAST_ULL(size),
-		     name, flags);
-#else
-  (void)flags;
+	cvmx_dprintf("%s: start %#llx, size: %#llx, name: %s, flags:%#x)\n",
+		__func__, CAST_ULL(start_addr), CAST_ULL(size),
+		name, (unsigned) flags);
 #endif
 
 	if (__cvmx_bootmem_check_version(3))
@@ -1507,7 +1545,7 @@ int cvmx_bootmem_reserve_memory(uint64_t start_addr, uint64_t size,
 		}
 		if (reserve_size) {
 			snprintf(block_name, sizeof(block_name),
-				 "%.100s_%016llx_%u",
+				 "%.32s_%012llx_%u",
 				 name, (unsigned long long)start_addr,
 				 (unsigned int)block_num);
 #ifdef DEBUG
@@ -1516,10 +1554,9 @@ int cvmx_bootmem_reserve_memory(uint64_t start_addr, uint64_t size,
 				     __func__, CAST_ULL(reserve_size),
 				     CAST_ULL(addr), block_name);
 #endif
-			if (CAST_ULL(cvmx_bootmem_phy_named_block_alloc(reserve_size,
-									addr, 0, 0,
-									block_name, 0))
-			    == -1ull) {
+			if (cvmx_bootmem_phy_named_block_alloc(
+				reserve_size, addr, 0, 0, block_name, flags
+				) == -1) {
 				cvmx_dprintf("%s: Failed to reserve 0x%llx "
 					     "bytes at address 0x%llx\n",
 					     __func__, CAST_ULL(reserve_size),
diff --git a/arch/mips/include/asm/octeon/octeon-boot-info.h b/arch/mips/include/asm/octeon/octeon-boot-info.h
index a4135cb..0c1d8d9 100644
--- a/arch/mips/include/asm/octeon/octeon-boot-info.h
+++ b/arch/mips/include/asm/octeon/octeon-boot-info.h
@@ -65,6 +65,8 @@
 /** Offset within the boot bus moveable region for the boot vector table */
 #define OCTEON_BOOT_VECTOR_MOVEABLE_OFFSET	0x78
 
+/** Each per-node boot vector table also has a name */
+#define	OCTEON_BOOT_VECTOR_LOCATOR_NAME	"__cvmx_boot_vector_"
 
 #ifndef __ASSEMBLY__
 
-- 
2.6.2

