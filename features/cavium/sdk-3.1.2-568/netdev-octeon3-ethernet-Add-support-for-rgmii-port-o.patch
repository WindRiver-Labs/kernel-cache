From ed7d25319a271fcfd92387fa3d1679cda1b4a6a9 Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Mon, 18 Jan 2016 16:46:40 -0800
Subject: [PATCH 12/13] netdev: octeon3-ethernet: Add support for rgmii port
 on ebb7304 board.

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
[Original patch taken from patch set for OCTEON SDK 3.1.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/octeon/octeon-bgx-nexus.c    |   23 +++++++++++++++++++-
 drivers/net/ethernet/octeon/octeon-bgx-port.c     |    7 ++++-
 drivers/net/ethernet/octeon/octeon-common-nexus.h |    6 +++++
 drivers/net/ethernet/octeon/octeon3-ethernet.c    |    3 ++
 4 files changed, 35 insertions(+), 4 deletions(-)

diff --git a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
index 28a67ee..adf417b 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
@@ -125,6 +125,19 @@ static bool is_lmac_to_pki(int node, int bgx, int lmac)
 	return pki_ports[node][bgx][lmac];
 }
 
+/* is_lmac_to_xcv:		Check if this lmac is connected to the xcv
+ *				block (rgmii).
+ *
+ *  of_node:			Device node to check.
+ *
+ *  returns:			true if the lmac is connected to the xcv, false
+ *				otherwise.
+ */
+static bool is_lmac_to_xcv(struct device_node *of_node)
+{
+	return of_device_is_compatible(of_node, "cavium,octeon-7360-xcv");
+}
+
 static int bgx_probe(struct platform_device *pdev)
 {
 	struct mac_platform_data platform_data;
@@ -140,7 +153,6 @@ static int bgx_probe(struct platform_device *pdev)
 	int r = 0;
 	char id[64];
 
-
 	reg = of_get_property(pdev->dev.of_node, "reg", NULL);
 	addr = of_translate_address(pdev->dev.of_node, reg);
 	interface = (addr >> 24) & 0xf;
@@ -162,11 +174,13 @@ static int bgx_probe(struct platform_device *pdev)
 	for_each_available_child_of_node(pdev->dev.of_node, child) {
 		bool is_mix = false;
 		bool is_pki = false;
+		bool is_xcv = false;
 		union cvmx_bgxx_cmrx_config cmr_config;
 		cvmx_bgxx_cmr_global_config_t global_config;
 		struct pdev_list_item *pdev_item;
 
-		if (!of_device_is_compatible(child, "cavium,octeon-7890-bgx-port"))
+		if (!of_device_is_compatible(child, "cavium,octeon-7890-bgx-port") &&
+		    !of_device_is_compatible(child, "cavium,octeon-7360-xcv"))
 			continue;
 		r = of_property_read_u32(child, "reg", &port);
 		if (r)
@@ -174,6 +188,7 @@ static int bgx_probe(struct platform_device *pdev)
 
 		is_mix = is_lmac_to_mix(numa_node, interface, port);
 		is_pki = is_lmac_to_pki(numa_node, interface, port);
+		is_xcv = is_lmac_to_xcv(child);
 
 		/* Check if this port should be configured */
 		if (is_mix == false && is_pki == false)
@@ -209,6 +224,10 @@ static int bgx_probe(struct platform_device *pdev)
 		platform_data.numa_node = numa_node;
 		platform_data.interface = interface;
 		platform_data.port = port;
+		if (is_xcv)
+			platform_data.src_type = XCV;
+		else
+			platform_data.src_type = QLM;
 
 		/* Add device to the list of created devices so we can remove it
 		 * on exit.
diff --git a/drivers/net/ethernet/octeon/octeon-bgx-port.c b/drivers/net/ethernet/octeon/octeon-bgx-port.c
index 4b89d23..6701ca2 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-port.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-port.c
@@ -305,7 +305,7 @@ int bgx_port_enable(struct net_device *netdev)
 	cvmx_helper_set_mac_phy_mode(priv->xiface, priv->index, false);
 
 	cfg.u64 = cvmx_read_csr_node(priv->numa_node, CVMX_BGXX_CMRX_CONFIG(priv->index, priv->bgx_interface));
-	if (cfg.s.lmac_type == 0) {
+	if (cfg.s.lmac_type == 0 || cfg.s.lmac_type == 5) {
 		/* 1G */
 		union cvmx_bgxx_gmp_gmi_txx_append tx_append;
 		union cvmx_bgxx_gmp_gmi_txx_min_pkt min_pkt;
@@ -443,7 +443,7 @@ int bgx_port_change_mtu(struct net_device *netdev, int new_mtu)
 	max_frame = round_up(new_mtu + ETH_HLEN + ETH_FCS_LEN, 8);
 
 	cfg.u64 = cvmx_read_csr_node(priv->numa_node, CVMX_BGXX_CMRX_CONFIG(priv->index, priv->bgx_interface));
-	if (cfg.s.lmac_type == 0)
+	if (cfg.s.lmac_type == 0 || cfg.s.lmac_type == 5)
 		cvmx_write_csr_node(priv->numa_node,		/* 1G */
 				    CVMX_BGXX_GMP_GMI_RXX_JABBER(priv->index, priv->bgx_interface),
 				    max_frame);
@@ -573,6 +573,9 @@ static struct of_device_id bgx_port_match[] = {
 	{
 		.compatible = "cavium,octeon-7890-bgx-port",
 	},
+	{
+		.compatible = "cavium,octeon-7360-xcv",
+	},
 	{},
 };
 MODULE_DEVICE_TABLE(of, bgx_port_match);
diff --git a/drivers/net/ethernet/octeon/octeon-common-nexus.h b/drivers/net/ethernet/octeon/octeon-common-nexus.h
index 3c83bc6..886e922 100644
--- a/drivers/net/ethernet/octeon/octeon-common-nexus.h
+++ b/drivers/net/ethernet/octeon/octeon-common-nexus.h
@@ -32,11 +32,17 @@ enum octeon3_mac_type {
 	SRIO_MAC
 };
 
+enum octeon3_src_type {
+	QLM,
+	XCV
+};
+
 struct mac_platform_data {
 	enum octeon3_mac_type	mac_type;
 	int			numa_node;
 	int			interface;
 	int			port;
+	enum octeon3_src_type	src_type;
 };
 
 extern int octeon3_init_port_cfg_data(int node);
diff --git a/drivers/net/ethernet/octeon/octeon3-ethernet.c b/drivers/net/ethernet/octeon/octeon3-ethernet.c
index d5ee45f..466234a 100644
--- a/drivers/net/ethernet/octeon/octeon3-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon3-ethernet.c
@@ -2503,6 +2503,9 @@ static int octeon3_eth_probe(struct platform_device *pdev)
 	priv->port_index = pd->port;
 	spin_lock_init(&priv->stat_lock);
 
+	if (pd->src_type == XCV)
+		snprintf(netdev->name, IFNAMSIZ, "rgmii%d", pd->port);
+
 	if (priv->mac_type == BGX_MAC)
 		netdev->netdev_ops = &octeon3_eth_netdev_ops;
 #if IS_ENABLED(CONFIG_OCTEON3_ETHERNET_SRIO)
-- 
1.7.5.4

