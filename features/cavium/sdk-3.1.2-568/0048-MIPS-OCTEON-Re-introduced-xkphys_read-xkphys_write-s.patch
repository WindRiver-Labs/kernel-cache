From ad5042ca83952e93018fb61ed2b602b9f46c9907 Mon Sep 17 00:00:00 2001
From: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Date: Wed, 5 Jun 2013 15:31:04 -0700
Subject: [PATCH 048/974] MIPS: OCTEON: Re-introduced xkphys_read, xkphys_write
 sysmips(2) calls

[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/setup.c      | 149 +++++++++++++++++++++++++++++++++++
 arch/mips/include/asm/thread_info.h  |   4 +
 arch/mips/include/uapi/asm/sysmips.h |   2 +
 arch/mips/kernel/syscall.c           |  13 +++
 4 files changed, 168 insertions(+)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 304f144..d4dc7a0 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -606,6 +606,155 @@ void octeon_user_io_init(void)
 	write_c0_derraddr1(0);
 }
 
+/*
+ * Octeon-specific system calls
+ */
+
+/* the caller must hold RCU read lock */
+static int is_task_and_current_same(struct task_struct *t)
+{
+	const struct cred *cred = current_cred(), *tcred;
+
+	tcred = __task_cred(t);
+	if ((cred->euid ^ tcred->suid) &&
+	    (cred->euid ^ tcred->uid) &&
+	    (cred->uid  ^ tcred->suid) &&
+	    (cred->uid  ^ tcred->uid)) {
+		return 0;
+	}
+	return 1;
+}
+
+
+static void octeon_prepare_arch_switch(struct task_struct *next)
+{
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || \
+	defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+	struct task_struct *group_leader = next->group_leader;
+	union octeon_cvmemctl cvmmemctl;
+	cvmmemctl.u64 = read_c0_cvmmemctl();
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS)
+	cvmmemctl.s.xkmemenau = test_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN) ? 1 : 0;
+#endif
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+	cvmmemctl.s.xkioenau = test_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN) ? 1 : 0;
+#endif
+	write_c0_cvmmemctl(cvmmemctl.u64);
+#endif
+}
+
+static struct task_struct *xkphys_get_task(pid_t pid)
+{
+	struct task_struct *task, *group_leader;
+
+	rcu_read_lock();
+	task = find_task_by_vpid(pid);
+	if (!task) {
+		read_unlock(&tasklist_lock);
+		return NULL;
+	}
+	group_leader = task->group_leader;
+	get_task_struct(group_leader);
+
+	rcu_read_unlock();
+	return group_leader;
+}
+
+
+int xkphys_usermem_read(long pid)
+{
+	struct task_struct *task;
+	int io, mem;
+
+	task = xkphys_get_task(pid);
+	if (!task)
+		return -ESRCH;
+#if defined(CONFIG_CAVIUM_OCTEON_USER_IO)
+	io = 1;
+#elif defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+	io = test_tsk_thread_flag(task, TIF_XKPHYS_IO_EN);
+#else
+	io = 0;
+#endif
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM)
+	mem = 1;
+#elif defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS)
+	mem = test_tsk_thread_flag(task, TIF_XKPHYS_MEM_EN);
+#else
+	mem = 0;
+#endif
+	put_task_struct(task);
+	return (io ? 2 : 0) | (mem ? 1 : 0);
+}
+
+int xkphys_usermem_write(long pid, int value)
+{
+	struct task_struct *task, *group_leader;
+	int permission_ok = 0;
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_IO)
+	if ((value & 2) == 0)
+		return -EINVAL;
+#elif !defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+	if (value & 2)
+		return -EINVAL;
+#endif
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM)
+	if ((value & 1) == 0)
+		return -EINVAL;
+#elif !defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS)
+	if (value & 1)
+		return -EINVAL;
+#endif
+
+	task = xkphys_get_task(pid);
+	group_leader = task->group_leader;
+
+	if (!task)
+		return -ESRCH;
+
+	rcu_read_lock();
+	/* Allow XKPHYS disable of other tasks from the current user*/
+	if (value == 0 && is_task_and_current_same(task))
+		permission_ok = 1;
+	rcu_read_unlock();
+
+	if (capable(CAP_SYS_RAWIO))
+		permission_ok = 1;
+
+	if (!permission_ok) {
+		put_task_struct(task);
+		return -EPERM;
+	}
+
+	if (value & 1)
+		set_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN);
+	else
+		clear_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN);
+
+	if (value & 2)
+		set_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN);
+	else
+		clear_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN);
+
+	preempt_disable();
+
+	/*
+	 * If we are adjusting ourselves, make the change effective
+	 * immediatly.
+	 */
+	if (group_leader == current->group_leader)
+		octeon_prepare_arch_switch(current);
+
+	preempt_enable();
+
+	put_task_struct(task);
+	return 0;
+}
+
 /**
  * Early entry point for arch setup
  */
diff --git a/arch/mips/include/asm/thread_info.h b/arch/mips/include/asm/thread_info.h
index e6e5d91..d03e906 100644
--- a/arch/mips/include/asm/thread_info.h
+++ b/arch/mips/include/asm/thread_info.h
@@ -115,6 +115,8 @@ static inline struct thread_info *current_thread_info(void)
 #define TIF_32BIT_ADDR		23	/* 32-bit address space (o32/n32) */
 #define TIF_FPUBOUND		24	/* thread bound to FPU-full CPU set */
 #define TIF_LOAD_WATCH		25	/* If set, load watch registers */
+#define TIF_XKPHYS_MEM_EN	26
+#define TIF_XKPHYS_IO_EN	27
 #define TIF_SYSCALL_TRACE	31	/* syscall trace active */
 
 #define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
@@ -130,6 +132,8 @@ static inline struct thread_info *current_thread_info(void)
 #define _TIF_32BIT_ADDR		(1<<TIF_32BIT_ADDR)
 #define _TIF_FPUBOUND		(1<<TIF_FPUBOUND)
 #define _TIF_LOAD_WATCH		(1<<TIF_LOAD_WATCH)
+#define _TIF_XKPHYS_MEM_EN	(1<<TIF_XKPHYS_MEM_EN)
+#define _TIF_XKPHYS_IO_EN	(1<<TIF_XKPHYS_IO_EN)
 
 #define _TIF_WORK_SYSCALL_ENTRY	(_TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT | _TIF_SECCOMP)
 
diff --git a/arch/mips/include/uapi/asm/sysmips.h b/arch/mips/include/uapi/asm/sysmips.h
index ae637e9..c008d14 100644
--- a/arch/mips/include/uapi/asm/sysmips.h
+++ b/arch/mips/include/uapi/asm/sysmips.h
@@ -21,5 +21,7 @@
 #define MIPS_FIXADE		   7	/* control address error fixing	 */
 #define MIPS_RDNVRAM		  10	/* read NVRAM */
 #define MIPS_ATOMIC_SET		2001	/* atomically set variable	 */
+#define MIPS_CAVIUM_XKPHYS_READ  2010	/* XKPHYS */
+#define MIPS_CAVIUM_XKPHYS_WRITE 2011	/* XKPHYS */
 
 #endif /* _ASM_SYSMIPS_H */
diff --git a/arch/mips/kernel/syscall.c b/arch/mips/kernel/syscall.c
index 1e43377..0410202 100644
--- a/arch/mips/kernel/syscall.c
+++ b/arch/mips/kernel/syscall.c
@@ -39,6 +39,11 @@
 #include <asm/uaccess.h>
 #include <asm/switch_to.h>
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+extern int xkphys_usermem_read(long);
+extern int xkphys_usermem_write(long, int);
+#endif
+
 /*
  * For historic reasons the pipe(2) syscall on MIPS has an unusual calling
  * convention.	It returns results in registers $v0 / $v1 which means there
@@ -224,6 +229,14 @@ SYSCALL_DEFINE3(sysmips, long, cmd, long, arg1, long, arg2)
 	case FLUSH_CACHE:
 		__flush_cache_all();
 		return 0;
+
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	case MIPS_CAVIUM_XKPHYS_READ:
+		return xkphys_usermem_read(arg1);
+
+	case MIPS_CAVIUM_XKPHYS_WRITE:
+		return xkphys_usermem_write(arg1, arg2);
+#endif
 	}
 
 	return -EINVAL;
-- 
2.6.2

