From 182ff0ac93ae6e6bb31d1f11b68b15b0c36bbf9e Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Tue, 13 Jan 2015 11:17:49 -0800
Subject: [PATCH 055/184] MIPS: OCTEON: Inhibit CP0_Compare interrupts when not
 needed.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 4c37601ad19c897262d231b661c5565a8b3b4c49
Description:

This prevents unwanted interrupts when the CP0_Count wraps around, and
allows for tickless mode to truly not generate timer interrupts.

Signed-off-by: David Daney <david.daney@cavium.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c | 25 ++++++++++++++++++++++++-
 arch/mips/kernel/cevt-r4k.c          | 11 +++++++++++
 2 files changed, 35 insertions(+), 1 deletion(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index 86ad4d1..1cb2a3a 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -146,6 +146,9 @@ int octeon_cpu_for_coreid(int coreid)
 #endif
 }
 
+static DEFINE_PER_CPU(bool, octeon_irq_core_ack_masked[8]);
+static DEFINE_PER_CPU(bool, octeon_irq_core_inhibited[8]);
+
 static void octeon_irq_core_ack(struct irq_data *data)
 {
 	struct octeon_core_chip_data *cd = irq_data_get_irq_chip_data(data);
@@ -157,6 +160,7 @@ static void octeon_irq_core_ack(struct irq_data *data)
 	 * interrupt code.
 	 */
 	clear_c0_status(0x100 << bit);
+	__this_cpu_write(octeon_irq_core_ack_masked[bit], true);
 	/* The two user interrupts must be cleared manually. */
 	if (bit < 2)
 		clear_c0_cause(0x100 << bit);
@@ -165,13 +169,32 @@ static void octeon_irq_core_ack(struct irq_data *data)
 static void octeon_irq_core_eoi(struct irq_data *data)
 {
 	struct octeon_core_chip_data *cd = irq_data_get_irq_chip_data(data);
+	unsigned int bit = cd->bit;
+	bool inhibited = __this_cpu_read(octeon_irq_core_inhibited[bit]);
 
 	/*
 	 * We don't need to disable IRQs to make these atomic since
 	 * they are already disabled earlier in the low level
 	 * interrupt code.
 	 */
-	set_c0_status(0x100 << cd->bit);
+	if (!inhibited)
+		set_c0_status(0x100 << bit);
+	__this_cpu_write(octeon_irq_core_ack_masked[bit], false);
+}
+
+void octeon_irq_core_inhibit_bit(unsigned int bit, bool v)
+{
+	unsigned long flags;
+	bool masked;
+
+	raw_local_irq_save(flags);
+
+	masked = __this_cpu_read(octeon_irq_core_ack_masked[bit]);
+	__this_cpu_write(octeon_irq_core_inhibited[bit], v);
+
+	if (!masked && !v)
+		set_c0_status(0x100 << bit);
+	raw_local_irq_restore(flags);
 }
 
 static void octeon_irq_core_set_enable_local(void *arg)
diff --git a/arch/mips/kernel/cevt-r4k.c b/arch/mips/kernel/cevt-r4k.c
index d70c4d8..058e591 100644
--- a/arch/mips/kernel/cevt-r4k.c
+++ b/arch/mips/kernel/cevt-r4k.c
@@ -15,6 +15,15 @@
 #include <asm/time.h>
 #include <asm/cevt-r4k.h>
 
+#ifdef CONFIG_CAVIUM_OCTEON_SOC
+void octeon_irq_core_inhibit_bit(unsigned int bit, bool v);
+#else
+static void octeon_irq_core_inhibit_bit(unsigned int bit, bool v)
+{
+	return;
+}
+#endif
+
 static int mips_next_event(unsigned long delta,
 			   struct clock_event_device *evt)
 {
@@ -25,6 +34,7 @@ static int mips_next_event(unsigned long delta,
 	cnt += delta;
 	write_c0_compare(cnt);
 	res = ((int)(read_c0_count() - cnt) >= 0) ? -ETIME : 0;
+	octeon_irq_core_inhibit_bit(cp0_compare_irq, false);
 	return res;
 }
 
@@ -78,6 +88,7 @@ irqreturn_t c0_compare_interrupt(int irq, void *dev_id)
 	if (!r2 || (read_c0_cause() & CAUSEF_TI)) {
 		/* Clear Count/Compare Interrupt */
 		write_c0_compare(read_c0_compare());
+		octeon_irq_core_inhibit_bit(cp0_compare_irq, true);
 		cd = &per_cpu(mips_clockevent_device, cpu);
 		cd->event_handler(cd);
 
-- 
1.9.1

