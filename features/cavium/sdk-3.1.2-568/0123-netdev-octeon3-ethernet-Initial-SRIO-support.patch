From 2e2efa81449e3a18957bd65ba1b4d30745ac612c Mon Sep 17 00:00:00 2001
From: Carlos Munoz <cmunoz@caviumnetworks.com>
Date: Wed, 10 Jun 2015 16:59:25 -0700
Subject: [PATCH 123/184] netdev: octeon3-ethernet: Initial SRIO support.

Source: Cavium Networks, Inc.
MR: 00000
Type: Integration
Disposition: Merged from Octeon Tree
ChangeID: 7162307f319fe4b811b10dfc43573ee43a7274a4
Description:

Signed-off-by: Carlos Munoz <cmunoz@caviumnetworks.com>
Signed-off-by: Corey Minyard <cminyard@mvista.com>
[Original patch taken from octeon-linux-kernel-patches-SDK-3.1.2-release]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/octeon/Kconfig               |  20 +-
 drivers/net/ethernet/octeon/Makefile              |   8 +-
 drivers/net/ethernet/octeon/octeon-bgx-nexus.c    |  23 +-
 drivers/net/ethernet/octeon/octeon-bgx.h          |   6 -
 drivers/net/ethernet/octeon/octeon-common-nexus.c |  76 +++++
 drivers/net/ethernet/octeon/octeon-common-nexus.h |  47 +++
 drivers/net/ethernet/octeon/octeon-srio-nexus.c   | 200 ++++++++++++
 drivers/net/ethernet/octeon/octeon3-ethernet.c    | 376 +++++++++++++++++++---
 drivers/net/ethernet/octeon/octeon_mgmt.c         |   3 +-
 9 files changed, 693 insertions(+), 66 deletions(-)
 create mode 100644 drivers/net/ethernet/octeon/octeon-common-nexus.c
 create mode 100644 drivers/net/ethernet/octeon/octeon-common-nexus.h
 create mode 100644 drivers/net/ethernet/octeon/octeon-srio-nexus.c

diff --git a/drivers/net/ethernet/octeon/Kconfig b/drivers/net/ethernet/octeon/Kconfig
index 6b9e510..8bb8fd0 100644
--- a/drivers/net/ethernet/octeon/Kconfig
+++ b/drivers/net/ethernet/octeon/Kconfig
@@ -6,10 +6,17 @@ config OCTEON_BGX_NEXUS
 	tristate
 	depends on CAVIUM_OCTEON_SOC
 
+config OCTEON_SRIO_NEXUS
+	tristate
+
+config OCTEON_COMMON_NEXUS
+	tristate
+
 config OCTEON_BGX_PORT
 	tristate
 	depends on CAVIUM_OCTEON_SOC
 	select OCTEON_BGX_NEXUS
+	select OCTEON_COMMON_NEXUS
 
 config OCTEON3_ETHERNET
 	tristate "Cavium Inc. OCTEON III PKI/PKO Ethernet support (not cn70xx)"
@@ -18,7 +25,18 @@ config OCTEON3_ETHERNET
 	select OCTEON_FPA3
 	help
 	  Support for 'BGX' Ethernet via PKI/PKO units.  No support
-	  for cn70xx chips (use OCTEON_ETHERNET for cn70xx)
+	  for cn70xx chips (use OCTEON_ETHERNET for cn70xx).
+
+config OCTEON3_ETHERNET_SRIO
+	bool "Cavium Inc. SRIO support for OCTEON III Ethernet driver"
+	depends on (OCTEON3_ETHERNET && CAVIUM_OCTEON_RAPIDIO)
+	select OCTEON_SRIO_NEXUS
+	default y
+	help
+	  This driver adds 'SRIO' support to the Ethernet driver via PKI/PKO
+	  units. It supports Caviums CNF75XX SOC. To compile this driver as a
+	  module, choose M here. The module will be called
+	  octeon3-ethernet-srio.
 
 config OCTEON_ETHERNET
 	tristate "Cavium Inc. OCTEON Ethernet support"
diff --git a/drivers/net/ethernet/octeon/Makefile b/drivers/net/ethernet/octeon/Makefile
index 215c0d9..162d751 100644
--- a/drivers/net/ethernet/octeon/Makefile
+++ b/drivers/net/ethernet/octeon/Makefile
@@ -3,12 +3,14 @@
 #
 obj-$(CONFIG_OCTEON_BGX_PORT)		+= octeon-bgx-port.o
 obj-$(CONFIG_OCTEON_BGX_NEXUS)		+= octeon-bgx-nexus.o
+obj-$(CONFIG_OCTEON_COMMON_NEXUS)	+= octeon-common-nexus.o
+obj-$(CONFIG_OCTEON_SRIO_NEXUS)		+= octeon-srio-nexus.o
 obj-$(CONFIG_OCTEON3_ETHERNET)		+= octeon3-ethernet.o
 obj-$(CONFIG_OCTEON_MGMT_ETHERNET)	+= octeon_mgmt.o
 obj-$(CONFIG_OCTEON_POW_ONLY_ETHERNET)	+= octeon-pow-ethernet.o
-obj-$(CONFIG_OCTEON_ETHERNET) +=  octeon-ethernet.o
-obj-$(CONFIG_OCTEON_ETHERNET_MEM) += ethernet-mem.o
-obj-$(CONFIG_OCTEON_ETHERNET_COMMON) += octeon_common.o
+obj-$(CONFIG_OCTEON_ETHERNET)		+= octeon-ethernet.o
+obj-$(CONFIG_OCTEON_ETHERNET_MEM)	+= ethernet-mem.o
+obj-$(CONFIG_OCTEON_ETHERNET_COMMON)	+= octeon_common.o
 
 octeon-ethernet-objs := ethernet.o
 octeon-ethernet-objs += ethernet-mdio.o
diff --git a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
index ec106f7..9dd378d 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
+++ b/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
@@ -39,9 +39,8 @@
 #include <asm/octeon/cvmx-bgxx-defs.h>
 
 #include "octeon-bgx.h"
+#include "octeon-common-nexus.h"
 
-static atomic_t bgx_nexus_once;
-static atomic_t request_ethernet3_once;
 static atomic_t request_mgmt_once;
 
 static char *mix_port;
@@ -52,7 +51,6 @@ static char *pki_port;
 module_param(pki_port, charp, S_IRUGO);
 MODULE_PARM_DESC(pki_port, "Specifies which ports connect to the PKI.");
 
-#define MAX_NODES		2
 #define MAX_MIX_PER_NODE	2
 #define MAX_BGX_PER_NODE	6
 #define MAX_LMAC_PER_NODE	4
@@ -129,22 +127,21 @@ static bool is_lmac_to_pki(int node, int bgx, int lmac)
 
 static int bgx_probe(struct platform_device *pdev)
 {
-	struct bgx_platform_data platform_data;
+	struct mac_platform_data platform_data;
 	const __be32 *reg;
 	u32 port;
 	u64 addr;
 	struct device_node *child;
 	struct platform_device *new_dev;
 	struct platform_device *pki_dev;
-	static int pki_id;
+	int pki_id;
 	int numa_node, interface;
 	int i;
 	int r = 0;
 	char id[64];
 
-	/* One time initialization */
-	if (atomic_cmpxchg(&bgx_nexus_once, 0, 1) == 0)
-		__cvmx_helper_init_port_config_data();
+	/* Initialize the node's ports' configuration data */
+	octeon3_init_port_cfg_data(numa_node);
 
 	reg = of_get_property(pdev->dev.of_node, "reg", NULL);
 	addr = of_translate_address(pdev->dev.of_node, reg);
@@ -207,6 +204,7 @@ static int bgx_probe(struct platform_device *pdev)
 			dev_err(&pdev->dev, "Error creating %s\n", id);
 			continue;
 		}
+		platform_data.mac_type = BGX_MAC;
 		platform_data.numa_node = numa_node;
 		platform_data.interface = interface;
 		platform_data.port = port;
@@ -220,9 +218,10 @@ static int bgx_probe(struct platform_device *pdev)
 		list_add(&pdev_item->list, &pdev_list);
 		mutex_unlock(&pdev_list_lock);
 
+		pki_id = octeon3_get_eth_id();
 		pki_dev = platform_device_register_data(&new_dev->dev,
 							is_mix ? "octeon_mgmt" : "ethernet-mac-pki",
-							pki_id++,
+							pki_id,
 							&platform_data, sizeof(platform_data));
 		dev_info(&pdev->dev, "Created %s %u: %p\n", is_mix ? "MIX" : "PKI", pki_dev->id, pki_dev);
 
@@ -244,10 +243,8 @@ static int bgx_probe(struct platform_device *pdev)
 			if (atomic_cmpxchg(&request_mgmt_once, 0, 1) == 0)
 				request_module_nowait("octeon_mgmt");
 		}
-		if (is_pki) {
-			if (atomic_cmpxchg(&request_ethernet3_once, 0, 1) == 0)
-				request_module_nowait("octeon3-ethernet");
-		}
+		if (is_pki)
+			octeon3_load_eth_driver();
 	}
 
 	dev_info(&pdev->dev, "Probed\n");
diff --git a/drivers/net/ethernet/octeon/octeon-bgx.h b/drivers/net/ethernet/octeon/octeon-bgx.h
index 55325ed..bc93e1d 100644
--- a/drivers/net/ethernet/octeon/octeon-bgx.h
+++ b/drivers/net/ethernet/octeon/octeon-bgx.h
@@ -54,10 +54,4 @@ int bgx_port_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
 
 void bgx_port_mix_assert_reset(struct net_device *netdev, int mix, bool v);
 
-struct bgx_platform_data {
-	int numa_node;
-	int interface;
-	int port;
-};
-
 #endif /* _OCTEON_BGX_H_ */
diff --git a/drivers/net/ethernet/octeon/octeon-common-nexus.c b/drivers/net/ethernet/octeon/octeon-common-nexus.c
new file mode 100644
index 0000000..db780da
--- /dev/null
+++ b/drivers/net/ethernet/octeon/octeon-common-nexus.c
@@ -0,0 +1,76 @@
+/**********************************************************************
+ * Copyright (c) 2015 Cavium, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium, Inc. for more information
+ **********************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/atomic.h>
+
+#include <asm/octeon/cvmx-helper-cfg.h>
+
+
+static atomic_t init_port_cfg_data_once[4];
+static atomic_t octeon3_eth_driver_once;
+
+
+int octeon3_init_port_cfg_data(int node)
+{
+	int	rc = 0;
+
+	if (atomic_cmpxchg(init_port_cfg_data_once + node, 0, 1) == 0)
+		rc = __cvmx_helper_init_port_config_data(node);
+
+	return rc;
+}
+EXPORT_SYMBOL(octeon3_init_port_cfg_data);
+
+int octeon3_load_eth_driver(void)
+{
+	if (atomic_cmpxchg(&octeon3_eth_driver_once, 0, 1) == 0)
+		request_module_nowait("octeon3-ethernet");
+
+	return 0;
+}
+EXPORT_SYMBOL(octeon3_load_eth_driver);
+
+int octeon3_get_eth_id(void)
+{
+	static int pki_id;
+
+	return pki_id++;
+}
+EXPORT_SYMBOL(octeon3_get_eth_id);
+
+static int __init common_nexus_init(void)
+{
+	return 0;
+}
+
+static void __exit common_nexus_exit(void)
+{
+}
+
+module_init(common_nexus_init);
+module_exit(common_nexus_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Carlos Munoz <cmunoz@caviumnetworks.com>");
+MODULE_DESCRIPTION("Cavium Networks common ethernet nexus driver.");
diff --git a/drivers/net/ethernet/octeon/octeon-common-nexus.h b/drivers/net/ethernet/octeon/octeon-common-nexus.h
new file mode 100644
index 0000000..3c83bc6
--- /dev/null
+++ b/drivers/net/ethernet/octeon/octeon-common-nexus.h
@@ -0,0 +1,47 @@
+/**********************************************************************
+ * Copyright (c) 2015 Cavium, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium, Inc. for more information
+ **********************************************************************/
+
+#ifndef __OCTEON3_COMMON_NEXUS_H__
+#define __OCTEON3_COMMON_NEXUS_H__
+
+#define MAX_NODES		2
+#define SRIO_INTERFACE_OFFSET	1
+
+
+enum octeon3_mac_type {
+	BGX_MAC,
+	SRIO_MAC
+};
+
+struct mac_platform_data {
+	enum octeon3_mac_type	mac_type;
+	int			numa_node;
+	int			interface;
+	int			port;
+};
+
+extern int octeon3_init_port_cfg_data(int node);
+extern int octeon3_load_eth_driver(void);
+extern int octeon3_get_eth_id(void);
+extern void srio_nexus_load(void);
+
+#endif /* __OCTEON3_COMMON_NEXUS_H__ */
diff --git a/drivers/net/ethernet/octeon/octeon-srio-nexus.c b/drivers/net/ethernet/octeon/octeon-srio-nexus.c
new file mode 100644
index 0000000..ee07af8
--- /dev/null
+++ b/drivers/net/ethernet/octeon/octeon-srio-nexus.c
@@ -0,0 +1,200 @@
+/**********************************************************************
+ * Copyright (c) 2015 Cavium, Inc.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium, Inc. for more information
+ **********************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+
+#include "octeon-bgx.h"
+#include "octeon-common-nexus.h"
+
+
+/* Created platform devices get added to this list */
+static struct list_head pdev_list;
+static struct mutex pdev_list_lock;
+
+/* Created platform device use this structure to add themselves to the list */
+struct pdev_list_item {
+	struct list_head	list;
+	struct platform_device	*pdev;
+};
+
+
+static int srio_probe(struct platform_device *pdev)
+{
+	struct mac_platform_data	platform_data;
+	struct device_node		*child;
+	const __be32			*reg;
+	u64				addr;
+	int				numa_node;
+	int				interface;
+	int				r = 0;
+
+	reg = of_get_property(pdev->dev.of_node, "reg", NULL);
+	addr = of_translate_address(pdev->dev.of_node, reg);
+	interface = ((addr >> 24) & 0x1) + SRIO_INTERFACE_OFFSET;
+	numa_node = (addr >> 36) & 0x7;
+
+	/* Initialize the node's ports' configuration data */
+	octeon3_init_port_cfg_data(numa_node);
+
+	for_each_available_child_of_node(pdev->dev.of_node, child) {
+		u32			port;
+		struct pdev_list_item	*pdev_item;
+		struct platform_device	*new_dev;
+		struct platform_device	*pki_dev;
+		int			pki_id;
+		char			id[64];
+
+		if (!of_device_is_compatible(child,
+					     "cavium,octeon-7890-srio-port"))
+			continue;
+
+		r = of_property_read_u32(child, "reg", &port);
+		if (r)
+			return -ENODEV;
+
+		/* Create a platform device for this child node */
+		snprintf(id, sizeof(id), "%llx.%u.ethernet-mac",
+			 (unsigned long long)addr, port);
+		new_dev = of_platform_device_create(child, id, &pdev->dev);
+		if (!new_dev) {
+			dev_err(&pdev->dev, "Error creating %s\n", id);
+			continue;
+		}
+		platform_data.mac_type = SRIO_MAC;
+		platform_data.numa_node = numa_node;
+		platform_data.interface = interface;
+		platform_data.port = port;
+
+		/* Add device to the list of created devices so we can remove it
+		 * on exit.
+		 */
+		pdev_item = kmalloc(sizeof(*pdev_item), GFP_KERNEL);
+		pdev_item->pdev = new_dev;
+		mutex_lock(&pdev_list_lock);
+		list_add(&pdev_item->list, &pdev_list);
+		mutex_unlock(&pdev_list_lock);
+
+		pki_id = octeon3_get_eth_id();
+		pki_dev = platform_device_register_data(&new_dev->dev,
+							"ethernet-mac-pki",
+							pki_id,
+							&platform_data,
+							sizeof(platform_data));
+		dev_info(&pdev->dev, "Created %s %u: %p\n", "SRIO-PKI",
+			 pki_dev->id, pki_dev);
+
+		/* Add device to the list of created devices so we can remove it
+		 * on exit.
+		 */
+		pdev_item = kmalloc(sizeof(*pdev_item), GFP_KERNEL);
+		pdev_item->pdev = pki_dev;
+		mutex_lock(&pdev_list_lock);
+		list_add(&pdev_item->list, &pdev_list);
+		mutex_unlock(&pdev_list_lock);
+
+#ifdef CONFIG_NUMA
+		new_dev->dev.numa_node = pdev->dev.numa_node;
+		pki_dev->dev.numa_node = pdev->dev.numa_node;
+#endif
+
+		/* Load the ethernet driver */
+		octeon3_load_eth_driver();
+	}
+
+	dev_info(&pdev->dev, "Probed\n");
+	return 0;
+}
+
+static int srio_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static void srio_shutdown(struct platform_device *pdev)
+{
+	return;
+}
+
+static struct of_device_id srio_match[] = {
+	{
+		.compatible = "cavium,octeon-7890-srio",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, srio_match);
+
+static struct platform_driver srio_driver = {
+	.probe		= srio_probe,
+	.remove		= srio_remove,
+	.shutdown       = srio_shutdown,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= KBUILD_MODNAME,
+		.of_match_table = srio_match,
+	},
+};
+
+void srio_nexus_load(void)
+{
+}
+EXPORT_SYMBOL(srio_nexus_load);
+
+static int __init srio_driver_init(void)
+{
+	int rc;
+
+	INIT_LIST_HEAD(&pdev_list);
+	mutex_init(&pdev_list_lock);
+
+	rc = platform_driver_register(&srio_driver);
+
+	return rc;
+}
+
+static void __exit srio_driver_exit(void)
+{
+	struct pdev_list_item *pdev_item;
+
+	mutex_lock(&pdev_list_lock);
+	while (!list_empty(&pdev_list)) {
+		pdev_item = list_first_entry(&pdev_list, struct pdev_list_item,
+					     list);
+		list_del(&pdev_item->list);
+		platform_device_unregister(pdev_item->pdev);
+		kfree(pdev_item);
+	}
+	mutex_unlock(&pdev_list_lock);
+
+	platform_driver_unregister(&srio_driver);
+}
+
+module_init(srio_driver_init);
+module_exit(srio_driver_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Carlos Munoz <cmunoz@caviumnetworks.com>");
+MODULE_DESCRIPTION("Cavium Networks SRIO MAC Nexus driver.");
diff --git a/drivers/net/ethernet/octeon/octeon3-ethernet.c b/drivers/net/ethernet/octeon/octeon3-ethernet.c
index 098e53f..d8a0a53 100644
--- a/drivers/net/ethernet/octeon/octeon3-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon3-ethernet.c
@@ -4,7 +4,7 @@
  * Contact: support@cavium.com
  * This file is part of the OCTEON SDK
  *
- * Copyright (c) 2014 Cavium, Inc.
+ * Copyright (c) 2014-2015 Cavium, Inc.
  *
  * This file is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License, Version 2, as
@@ -36,6 +36,8 @@
 #include <linux/ip.h>
 #include <linux/ipv6.h>
 #include <linux/if_vlan.h>
+#include <linux/rio_drv.h>
+#include <linux/rio_ids.h>
 
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-helper-cfg.h>
@@ -44,13 +46,17 @@
 #include <asm/octeon/cvmx-pow.h>
 #include <asm/octeon/cvmx-pko3.h>
 #include <asm/octeon/cvmx-fpa3.h>
+#include <asm/octeon/cvmx-srio.h>
 #include <asm/octeon/cvmx-app-config.h>
 
 #include <asm/octeon/cvmx-fpa-defs.h>
 #include <asm/octeon/cvmx-sso-defs.h>
+#include <asm/octeon/cvmx-sriox-defs.h>
+#include <asm/octeon/cvmx-sriomaintx-defs.h>
 #include <asm/octeon/octeon-ethernet-user.h>
 
 #include "octeon-bgx.h"
+#include "octeon-common-nexus.h"
 
 
 /*
@@ -133,7 +139,6 @@
 
 #define MAX_TX_QUEUE_DEPTH 512
 #define SSO_INTSN_EXE 0x61
-#define OCTEON3_ETH_MAX_NUMA_NODES 2
 #define MAX_RX_CONTEXTS 32
 
 #define SKB_PTR_OFFSET		0
@@ -143,6 +148,9 @@
 #define USE_ASYNC_IOBDMA	1
 #define CVMX_SCR_SCRATCH	0
 
+#define SRIO_PAD                8
+
+
 /*  octeon3_napi_wrapper:	Structure containing the napi structure. This
  *				structure is added to receive contexts to
  *				increase the number of threads (napis) receiving
@@ -168,7 +176,7 @@ struct octeon3_napi_wrapper {
 #define MAX_NAPIS_PER_NODE	(CVMX_MAX_CORES * MAX_NAPI_PER_CPU)
 
 static struct octeon3_napi_wrapper
-napi_wrapper[OCTEON3_ETH_MAX_NUMA_NODES][MAX_NAPIS_PER_NODE]
+napi_wrapper[MAX_NODES][MAX_NAPIS_PER_NODE]
 __cacheline_aligned_in_smp;
 
 struct octeon3_ethernet;
@@ -186,7 +194,9 @@ struct octeon3_rx {
 struct octeon3_ethernet {
 	struct bgx_port_netdev_priv bgx_priv; /* Must be first element. */
 	struct list_head list;
+	struct list_head srio_bcast;
 	struct net_device *netdev;
+	enum octeon3_mac_type mac_type;
 	struct octeon3_rx rx_cxt[MAX_RX_CONTEXTS];
 	int num_rx_cxt;
 	int pki_laura;
@@ -199,6 +209,7 @@ struct octeon3_ethernet {
 	int tx_complete_grp;
 	spinlock_t stat_lock;
 	cvm_oct_callback_t intercept_cb;
+	u64 srio_tx_header;
 	u64 last_packets;
 	u64 last_octets;
 	u64 last_dropped;
@@ -258,6 +269,11 @@ struct octeon3_ethernet_node {
 	spinlock_t napi_alloc_lock;
 };
 
+struct octeon3_srio_bcast_target {
+	struct list_head	list;
+	u16			destid;
+};
+
 /* This array keeps track of the number of napis running on each cpu */
 static u8 octeon3_cpu_napi_cnt[NR_CPUS] __cacheline_aligned_in_smp;
 
@@ -285,7 +301,7 @@ static int rx_contexts = 1;
 module_param(rx_contexts, int, S_IRUGO);
 MODULE_PARM_DESC(rx_contexts, "Number of RX threads per port.");
 
-static struct octeon3_ethernet_node octeon3_eth_node[OCTEON3_ETH_MAX_NUMA_NODES];
+static struct octeon3_ethernet_node octeon3_eth_node[MAX_NODES];
 static struct kmem_cache *octeon3_eth_sso_pko_cache;
 
 
@@ -311,7 +327,7 @@ struct net_device *octeon3_register_callback(const char		*device_name,
 	int			node;
 
 	rcu_read_lock();
-	for (node = 0; node < OCTEON3_ETH_MAX_NUMA_NODES; node++) {
+	for (node = 0; node < MAX_NODES; node++) {
 		list_for_each_entry_rcu(priv,
 					&octeon3_eth_node[node].device_list,
 					list) {
@@ -374,7 +390,7 @@ static void octeon3_eth_sso_pass1_limit(int node, int	grp)
  * Map auras to the field priv->buffers_needed. Used to speed up packet
  * transmission.
  */
-static void *aura2bufs_needed[OCTEON3_ETH_MAX_NUMA_NODES][CVMX_FPA3_NUM_AURAS];
+static void *aura2bufs_needed[MAX_NODES][CVMX_FPA3_NUM_AURAS];
 
 static int octeon3_eth_lgrp_to_ggrp(int node, int grp)
 {
@@ -1190,6 +1206,13 @@ static int octeon3_eth_rx_one(struct octeon3_rx *rx, bool is_async,
 					skb->ip_summed = CHECKSUM_UNNECESSARY;
 		}
 
+#if IS_ENABLED(CONFIG_OCTEON3_ETHERNET_SRIO)
+		if (priv->mac_type == SRIO_MAC) {
+			__skb_pull(skb,
+				   sizeof(struct cvmx_srio_rx_message_header));
+		}
+#endif
+
 		if (unlikely(priv->intercept_cb)) {
 			enum cvm_oct_callback_result cb_result;
 
@@ -1423,7 +1446,8 @@ static int octeon3_eth_ndo_change_mtu(struct net_device *netdev, int new_mtu)
 	return bgx_port_change_mtu(netdev, new_mtu);
 }
 
-static int octeon3_eth_ndo_init(struct net_device *netdev)
+static int octeon3_eth_common_ndo_init(struct net_device	*netdev,
+				       int			extra_skip)
 {
 	struct octeon3_ethernet *priv = netdev_priv(netdev);
 	struct octeon3_ethernet_node *oen = octeon3_eth_node + priv->numa_node;
@@ -1436,7 +1460,6 @@ static int octeon3_eth_ndo_init(struct net_device *netdev)
 	int first_skip, later_skip;
 	struct cvmx_xport xdq;
 	int r, i;
-	const u8 *mac;
 	cvmx_fpa3_gaura_t aura;
 
 	netif_carrier_off(netdev);
@@ -1468,11 +1491,6 @@ static int octeon3_eth_ndo_init(struct net_device *netdev)
 	if (r < 0)
 		return -ENODEV;
 
-	/* Padding and FCS are done in BGX */
-	r = cvmx_pko3_interface_options(priv->xiface, priv->port_index, false, false, 0);
-	if (r)
-		return -ENODEV;
-
 	node_dq = cvmx_pko3_get_queue_base(ipd_port);
 	xdq = cvmx_helper_ipd_port_to_xport(node_dq);
 
@@ -1532,7 +1550,7 @@ static int octeon3_eth_ndo_init(struct net_device *netdev)
 	pki_prt_cfg.style_cfg.parm_cfg.ip6_udp_opt = false;
 	pki_prt_cfg.style_cfg.parm_cfg.ip6_udp_opt = false;
 	pki_prt_cfg.style_cfg.parm_cfg.wqe_skip = 1 * 128;
-	first_skip = 8 * 21;
+	first_skip = 8 * 21 + extra_skip;
 	later_skip = 8 * 16;
 	pki_prt_cfg.style_cfg.parm_cfg.first_skip = first_skip;
 	pki_prt_cfg.style_cfg.parm_cfg.later_skip = later_skip;
@@ -1608,6 +1626,34 @@ static int octeon3_eth_ndo_init(struct net_device *netdev)
 	cvmx_write_csr_node(priv->numa_node, CVMX_PKI_STATX_STAT3(priv->pki_pkind), 0);
 	priv->last_dropped = 0;
 
+	octeon3_napi_init_node(priv->numa_node, netdev);
+
+	/* Register ethtool methods */
+	SET_ETHTOOL_OPS(netdev, &octeon3_ethtool_ops);
+
+	return 0;
+err:
+	kfree(prt_schd);
+	return r;
+}
+
+static int octeon3_eth_bgx_ndo_init(struct net_device *netdev)
+{
+	struct octeon3_ethernet	*priv = netdev_priv(netdev);
+	const u8		*mac;
+	int			r;
+
+	octeon3_eth_common_ndo_init(netdev, 0);
+
+	/* Padding and FCS are done in BGX */
+	r = cvmx_pko3_interface_options(priv->xiface, priv->port_index, false,
+					false, 0);
+	if (r) {
+		dev_err(netdev->dev.parent,
+			"cvmx_pko3_interface_options: %d\n", r);
+		return -ENODEV;
+	}
+
 	mac = bgx_port_get_mac(netdev);
 	if (mac && is_valid_ether_addr(mac)) {
 		memcpy(netdev->dev_addr, mac, ETH_ALEN);
@@ -1618,15 +1664,7 @@ static int octeon3_eth_ndo_init(struct net_device *netdev)
 	bgx_port_set_rx_filtering(netdev);
 	octeon3_eth_ndo_change_mtu(netdev, netdev->mtu);
 
-	octeon3_napi_init_node(priv->numa_node, netdev);
-
-	/* Register ethtool methods */
-	netdev->ethtool_ops = &octeon3_ethtool_ops;
-
 	return 0;
-err:
-	kfree(prt_schd);
-	return r;
 }
 
 static void octeon3_eth_ndo_uninit(struct net_device *netdev)
@@ -1662,7 +1700,7 @@ static irqreturn_t octeon3_eth_rx_handler(int irq, void *info)
 	return IRQ_HANDLED;
 }
 
-static int octeon3_eth_ndo_open(struct net_device *netdev)
+static int octeon3_eth_common_ndo_open(struct net_device *netdev)
 {
 	struct octeon3_ethernet *priv = netdev_priv(netdev);
 	struct irq_domain *d = octeon_irq_get_block_domain(priv->numa_node, SSO_INTSN_EXE);
@@ -1724,9 +1762,7 @@ static int octeon3_eth_ndo_open(struct net_device *netdev)
 	}
 	octeon3_eth_replenish_rx(priv, priv->rx_buf_count);
 
-	r = bgx_port_enable(netdev);
-
-	return r;
+	return 0;
 
  err4:
 	bitmap_clear(priv->rx_cxt[i].napi_idx_bitmap, idx, 1);
@@ -1748,18 +1784,24 @@ static int octeon3_eth_ndo_open(struct net_device *netdev)
 	return r;
 }
 
-static int octeon3_eth_ndo_stop(struct net_device *netdev)
+static int octeon3_eth_bgx_ndo_open(struct net_device *netdev)
+{
+	int	rc;
+
+	rc = octeon3_eth_common_ndo_open(netdev);
+	if (rc == 0)
+		rc = bgx_port_enable(netdev);
+
+	return rc;
+}
+
+static int octeon3_eth_common_ndo_stop(struct net_device *netdev)
 {
 	struct octeon3_ethernet *priv = netdev_priv(netdev);
 	void **w;
 	struct sk_buff *skb;
 	struct octeon3_rx *rx;
 	int i;
-	int r;
-
-	r = bgx_port_disable(netdev);
-	if (r)
-		goto err;
 
 	/* Allow enough time for ingress in transit packets to be drained */
 	msleep(20);
@@ -1794,8 +1836,18 @@ static int octeon3_eth_ndo_stop(struct net_device *netdev)
 		dev_kfree_skb(skb);
 	}
 
-err:
-	return r;
+	return 0;
+}
+
+static int octeon3_eth_bgx_ndo_stop(struct net_device *netdev)
+{
+	int r;
+
+	r = bgx_port_disable(netdev);
+	if (r)
+		return r;
+
+	return octeon3_eth_common_ndo_stop(netdev);
 }
 
 /* octeon3_prepare_skb_to_recycle:	Reset all the skb fields to default
@@ -2140,10 +2192,10 @@ static int octeon3_eth_set_mac_address(struct net_device *netdev, void *addr)
 }
 
 static const struct net_device_ops octeon3_eth_netdev_ops = {
-	.ndo_init		= octeon3_eth_ndo_init,
+	.ndo_init		= octeon3_eth_bgx_ndo_init,
 	.ndo_uninit		= octeon3_eth_ndo_uninit,
-	.ndo_open		= octeon3_eth_ndo_open,
-	.ndo_stop		= octeon3_eth_ndo_stop,
+	.ndo_open		= octeon3_eth_bgx_ndo_open,
+	.ndo_stop		= octeon3_eth_bgx_ndo_stop,
 	.ndo_start_xmit		= octeon3_eth_ndo_start_xmit,
 	.ndo_get_stats64	= octeon3_eth_ndo_get_stats64,
 	.ndo_set_rx_mode	= bgx_port_set_rx_filtering,
@@ -2152,13 +2204,232 @@ static const struct net_device_ops octeon3_eth_netdev_ops = {
 	.ndo_do_ioctl		= bgx_port_do_ioctl,
 };
 
+#if IS_ENABLED(CONFIG_OCTEON3_ETHERNET_SRIO)
+
+static int octeon3_eth_srio_set_mac_address(struct net_device	*netdev,
+					    void		*addr)
+{
+	memcpy(netdev->dev_addr, addr + 2, 6);
+	return 0;
+}
+
+static int octeon3_eth_srio_ndo_init(struct net_device *netdev)
+{
+	struct octeon3_ethernet		*priv = netdev_priv(netdev);
+	cvmx_xiface_t			xiface;
+	union cvmx_sriox_status_reg	status_reg;
+	int				srio_port;
+	int				extra_skip;
+	int				rc;
+
+	extra_skip = sizeof(struct cvmx_srio_rx_message_header);
+	octeon3_eth_common_ndo_init(netdev, extra_skip);
+
+	xiface = cvmx_helper_xiface_to_node_interface(priv->xiface);
+	srio_port = xiface.interface - SRIO_INTERFACE_OFFSET;
+
+	rc = cvmx_pko3_interface_options(priv->xiface, priv->port_index, true,
+					true, 0);
+	if (rc) {
+		dev_err(netdev->dev.parent, "cvmx_pko3_interface_options: %d\n",
+			rc);
+		return -ENODEV;
+	}
+
+	status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(srio_port));
+	if (!status_reg.s.access)
+		return 0;
+
+	return 0;
+}
+
+static int octeon3_eth_srio_ndo_open(struct net_device *netdev)
+{
+
+	struct octeon3_ethernet	*priv = netdev_priv(netdev);
+	cvmx_xiface_t		xiface;
+	int			srio_port;
+	struct			rio_dev *rdev;
+	struct sockaddr		sa;
+	u32			devid;
+	int			rc;
+
+	xiface = cvmx_helper_xiface_to_node_interface(priv->xiface);
+	srio_port = xiface.interface - SRIO_INTERFACE_OFFSET;
+
+	cvmx_srio_config_read32(srio_port, 0, -1, 1, 0,
+				CVMX_SRIOMAINTX_PRI_DEV_ID(srio_port), &devid);
+	sa.sa_data[0] = 0;
+	sa.sa_data[1] = 0;
+	sa.sa_data[2] = 0;
+	sa.sa_data[3] = 0;
+	if (devid >> 16) {
+		sa.sa_data[4] = 0;
+		sa.sa_data[5] = (devid >> 16) & 0xff;
+	} else {
+		sa.sa_data[4] = (devid >> 8) & 0xff;
+		sa.sa_data[5] = devid & 0xff;
+	}
+
+	netdev->netdev_ops->ndo_set_mac_address(netdev, &sa);
+
+	rdev = NULL;
+	for (;;) {
+		struct octeon3_srio_bcast_target *target;
+		rdev = rio_get_device(RIO_ANY_ID, RIO_ANY_ID, rdev);
+		if (!rdev)
+			break;
+		if (rdev->net->hport->id != srio_port)
+			continue;
+		if (rdev->destid == 0xffff)
+			continue;
+		target = kmalloc(sizeof(*target), GFP_KERNEL);
+		if (!target) {
+			WARN(1, "No memory");
+			return -ENOMEM;
+		}
+		target->destid = rdev->destid;
+		list_add(&target->list, &priv->srio_bcast);
+	}
+
+	rc = octeon3_eth_common_ndo_open(netdev);
+	if (rc == 0)
+		netif_carrier_on(netdev);
+
+	netdev->netdev_ops->ndo_change_mtu(netdev, netdev->mtu);
+
+	return rc;
+}
+
+static int octeon3_eth_srio_ndo_start_xmit(struct sk_buff	*skb,
+					   struct net_device	*netdev)
+{
+	struct octeon3_ethernet	*priv = netdev_priv(netdev);
+	union cvmx_srio_tx_message_header tx_header;
+	u64 dest_mac;
+
+	if (unlikely(skb->len > 4096)) {
+		dev_kfree_skb(skb);
+		netdev_dbg(netdev, "TX packet > 4096 bytes. Dropped.\n");
+		return 0;
+	}
+
+	if (unlikely(skb->len < 64)) {
+		if (likely(skb_tailroom(skb) >= 64 - skb->len))
+			skb_put(skb, 64 - skb->len);
+	}
+
+	if (skb->len & (SRIO_PAD - 1)) {
+		if (likely(skb_tailroom(skb) > SRIO_PAD - 1))
+			skb_put(skb, SRIO_PAD - (skb->len & (SRIO_PAD - 1)));
+	}
+
+	tx_header.u64 = priv->srio_tx_header;
+	if (skb->sk) {
+		if (skb->sk->sk_priority < 0)
+			tx_header.s.prio = 0;
+		else if (skb->sk->sk_priority > 3)
+			tx_header.s.prio = 3;
+		else
+			tx_header.s.prio = skb->sk->sk_priority;
+	}
+
+	dest_mac = cpu_to_be64(*(u64 *)skb->data >> 16);
+
+	if (dest_mac >> 40) {
+		struct list_head *pos;
+		struct sk_buff *new_skb;
+
+		list_for_each(pos, &priv->srio_bcast) {
+			struct octeon3_srio_bcast_target *t;
+
+			t = container_of(pos, struct octeon3_srio_bcast_target,
+					 list);
+			if (skb_headroom(skb) < 8) {
+				new_skb = skb_realloc_headroom(skb,
+					8 - skb_headroom(skb));
+			} else
+				new_skb = skb_copy(skb, GFP_ATOMIC);
+
+			if (new_skb) {
+				tx_header.s.did = t->destid;
+				*(u64 *)__skb_push(new_skb, 8) =
+					cpu_to_be64(tx_header.u64);
+				octeon3_eth_ndo_start_xmit(new_skb, netdev);
+			} else {
+				netdev_dbg(netdev, "SKB allocation failed\n");
+				break;
+			}
+		}
+
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	} else {
+		tx_header.s.did = *(u8 *)(skb->data + 5);
+		if (unlikely(skb_headroom(skb) < 8)) {
+			int	nhead = 8 - skb_headroom(skb);
+
+			if (pskb_expand_head(skb, nhead, 0, GFP_ATOMIC)) {
+				netdev_dbg(netdev,
+					   "SKB didn't have room for SRIO "
+					   "header and allocation failed\n");
+				return NETDEV_TX_OK;
+			}
+		}
+
+		*(u64 *)__skb_push(skb, 8) = cpu_to_be64(tx_header.u64);
+		return octeon3_eth_ndo_start_xmit(skb, netdev);
+	}
+}
+
+static int octeon3_eth_srio_ndo_stop(struct net_device *netdev)
+{
+	return octeon3_eth_common_ndo_stop(netdev);
+}
+
+static int octeon3_eth_srio_ndo_change_mtu(struct net_device	*netdev,
+					   int			new_mtu)
+{
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	int vlan_bytes = VLAN_HLEN;
+#else
+	int vlan_bytes = 0;
+#endif
+	unsigned int max_mtu;
+	int srio_hdr_len = sizeof(union cvmx_srio_tx_message_header);
+
+	max_mtu = RIO_MAX_MSG_SIZE - srio_hdr_len - ETH_HLEN - vlan_bytes -
+		SRIO_PAD - ETH_FCS_LEN;
+	if ((new_mtu < 68) || (new_mtu > max_mtu)) {
+		netdev_warn(netdev, "MTU must be between %d and %d.\n",
+			    68, max_mtu);
+		return -EINVAL;
+	}
+	netdev->mtu = new_mtu;
+
+	return 0;
+}
+
+const struct net_device_ops octeon3_eth_srio_netdev_ops = {
+	.ndo_init		= octeon3_eth_srio_ndo_init,
+	.ndo_uninit		= octeon3_eth_ndo_uninit,
+	.ndo_open		= octeon3_eth_srio_ndo_open,
+	.ndo_stop		= octeon3_eth_srio_ndo_stop,
+	.ndo_start_xmit		= octeon3_eth_srio_ndo_start_xmit,
+	.ndo_get_stats64	= octeon3_eth_ndo_get_stats64,
+	.ndo_set_mac_address	= octeon3_eth_srio_set_mac_address,
+	.ndo_change_mtu		= octeon3_eth_srio_ndo_change_mtu,
+};
+
+#endif /* CONFIG_OCTEON3_ETHERNET_SRIO */
+
 static int octeon3_eth_probe(struct platform_device *pdev)
 {
 	struct octeon3_ethernet *priv;
 	struct net_device *netdev;
 	int r;
 
-	struct bgx_platform_data *pd = dev_get_platdata(&pdev->dev);
+	struct mac_platform_data *pd = dev_get_platdata(&pdev->dev);
 #if defined(CONFIG_KEXEC) || defined(CONFIG_CRASH_DUMP)
 	static bool cvmx_res_clear = false;
 	if (cvmx_res_clear == false) {
@@ -2187,10 +2458,13 @@ static int octeon3_eth_probe(struct platform_device *pdev)
 	SET_NETDEV_DEV(netdev, &pdev->dev);
 	dev_set_drvdata(&pdev->dev, netdev);
 
-	bgx_port_set_netdev(pdev->dev.parent, netdev);
+	if (pd->mac_type == BGX_MAC)
+		bgx_port_set_netdev(pdev->dev.parent, netdev);
 	priv = netdev_priv(netdev);
 	priv->netdev = netdev;
+	priv->mac_type = pd->mac_type;
 	INIT_LIST_HEAD(&priv->list);
+	INIT_LIST_HEAD(&priv->srio_bcast);
 	priv->numa_node = pd->numa_node;
 
 	mutex_lock(&octeon3_eth_node[priv->numa_node].device_list_lock);
@@ -2201,7 +2475,26 @@ static int octeon3_eth_probe(struct platform_device *pdev)
 	priv->port_index = pd->port;
 	spin_lock_init(&priv->stat_lock);
 	spin_lock_init(&priv->xmit_lock);
-	netdev->netdev_ops = &octeon3_eth_netdev_ops;
+
+	if (priv->mac_type == BGX_MAC)
+		netdev->netdev_ops = &octeon3_eth_netdev_ops;
+#if IS_ENABLED(CONFIG_OCTEON3_ETHERNET_SRIO)
+	else if (priv->mac_type == SRIO_MAC) {
+		union cvmx_srio_tx_message_header tx_header;
+
+		srio_nexus_load();
+
+		tx_header.u64 = 0;
+		tx_header.s.tt = 0;
+		tx_header.s.ssize = 0xe;
+		tx_header.s.mbox = pd->port;
+		tx_header.s.lns = 1;
+		tx_header.s.intr = 1;
+		priv->srio_tx_header = tx_header.u64;
+
+		netdev->netdev_ops = &octeon3_eth_srio_netdev_ops;
+	}
+#endif
 
 	if (register_netdev(netdev) < 0) {
 		dev_err(&pdev->dev, "Failed to register ethernet device\n");
@@ -2327,10 +2620,9 @@ static struct platform_driver octeon3_eth_driver = {
 };
 
 
-
 static int __init octeon3_eth_init(void)
 {
-	if (!OCTEON_IS_MODEL(OCTEON_CN78XX))
+	if (!octeon_has_feature(OCTEON_FEATURE_BGX))
 		return 0;
 
 	if (rx_contexts <= 0)
diff --git a/drivers/net/ethernet/octeon/octeon_mgmt.c b/drivers/net/ethernet/octeon/octeon_mgmt.c
index 52863ee..62a1119 100644
--- a/drivers/net/ethernet/octeon/octeon_mgmt.c
+++ b/drivers/net/ethernet/octeon/octeon_mgmt.c
@@ -29,6 +29,7 @@
 
 #include "octeon-bgx.h"
 #include "octeon_common.h"
+#include "octeon-common-nexus.h"
 
 #define DRV_NAME "octeon_mgmt"
 #define DRV_VERSION "2.0"
@@ -1610,7 +1611,7 @@ static int octeon_mgmt_o3_probe(struct platform_device *pdev)
 {
 	struct net_device *netdev;
 	struct octeon_mgmt *p;
-	struct bgx_platform_data *pd = dev_get_platdata(&pdev->dev);
+	struct mac_platform_data *pd = dev_get_platdata(&pdev->dev);
 	int result = -EINVAL;
 
 	dev_notice(&pdev->dev, "Probed %d:%d:%d\n", pd->numa_node, pd->interface, pd->port);
-- 
1.9.1

