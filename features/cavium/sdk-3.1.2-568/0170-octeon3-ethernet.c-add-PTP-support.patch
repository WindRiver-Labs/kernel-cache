From f2ea1b585738f5008b72bf920d0e65aafdaa5029 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Mon, 7 Aug 2017 14:02:47 +0800
Subject: [PATCH 170/184] octeon3-ethernet.c: add PTP support

These functions don't exist in Cavium's SDK formatted patches, but SDK's
final image(OCTEON-SDK-3.1.2-568 .i386.rpm + sdk_3.1.2_update_p10 .tgz)
has them, port them from SDK's final image.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/octeon/ethernet-napi.c    |   2 -
 drivers/net/ethernet/octeon/ethernet-rx.c      |  30 --
 drivers/net/ethernet/octeon/octeon3-ethernet.c | 368 ++++++++++++++++++++++++-
 3 files changed, 367 insertions(+), 33 deletions(-)

diff --git a/drivers/net/ethernet/octeon/ethernet-napi.c b/drivers/net/ethernet/octeon/ethernet-napi.c
index d0d5c83..64620e1 100644
--- a/drivers/net/ethernet/octeon/ethernet-napi.c
+++ b/drivers/net/ethernet/octeon/ethernet-napi.c
@@ -164,7 +164,6 @@ static int CVM_OCT_NAPI_POLL(struct napi_struct *napi, int budget)
 				     priv->tx_timestamp_hw)) {
 					u64 ns = *(u64 *)work->packet_data;
 					struct skb_shared_hwtstamps ts;
-					ts.syststamp = cvm_oct_ptp_to_ktime(ns);
 					ts.hwtstamp = ns_to_ktime(ns);
 					skb_tstamp_tx(skb, &ts);
 			}
@@ -361,7 +360,6 @@ static int CVM_OCT_NAPI_POLL(struct napi_struct *napi, int budget)
 					struct skb_shared_hwtstamps *ts;
 					ts = skb_hwtstamps(skb);
 					ts->hwtstamp = ns_to_ktime(ns);
-					ts->syststamp = cvm_oct_ptp_to_ktime(ns);
 					__skb_pull(skb, 8);
 				}
 				skb->protocol = eth_type_trans(skb, priv->netdev);
diff --git a/drivers/net/ethernet/octeon/ethernet-rx.c b/drivers/net/ethernet/octeon/ethernet-rx.c
index 45eeab0..3c7c6f0 100644
--- a/drivers/net/ethernet/octeon/ethernet-rx.c
+++ b/drivers/net/ethernet/octeon/ethernet-rx.c
@@ -293,36 +293,6 @@ static int cvm_oct_check_rcv_error(cvmx_wqe_t *work)
 	return 0;
 }
 
-/**
- * cvm_oct_ptp_to_ktime - Convert a hardware PTP timestamp into a
- * kernel timestamp.
- *
- * @ptptime: 64 bit PTP timestamp, normally in nanoseconds
- *
- * Return ktime_t
- */
-static ktime_t cvm_oct_ptp_to_ktime(u64 ptptime)
-{
-	ktime_t ktimebase;
-	u64 ptpbase;
-	unsigned long flags;
-
-	local_irq_save(flags);
-	/* Fill the icache with the code */
-	ktime_get_real();
-	/* Flush all pending operations */
-	mb();
-	/* Read the time and PTP clock as close together as
-	 * possible. It is important that this sequence take the same
-	 * amount of time to reduce jitter
-	 */
-	ktimebase = ktime_get_real();
-	ptpbase = octeon_read_ptp_csr(CVMX_MIO_PTP_CLOCK_HI);
-	local_irq_restore(flags);
-
-	return ktime_sub_ns(ktimebase, ptpbase - ptptime);
-}
-
 #undef CVM_OCT_NAPI_68
 #include "ethernet-napi.c"
 
diff --git a/drivers/net/ethernet/octeon/octeon3-ethernet.c b/drivers/net/ethernet/octeon/octeon3-ethernet.c
index 8335853..91e8354 100644
--- a/drivers/net/ethernet/octeon/octeon3-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon3-ethernet.c
@@ -38,8 +38,14 @@
 #include <linux/if_vlan.h>
 #include <linux/rio_drv.h>
 #include <linux/rio_ids.h>
+#include <linux/net_tstamp.h>
+#include <linux/clocksource.h>
+#include <linux/ptp_clock_kernel.h>
+#include <linux/timecounter.h>
 
 #include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-helper-bgx.h>
 #include <asm/octeon/cvmx-helper-cfg.h>
 #include <asm/octeon/cvmx-helper-pko3.h>
 #include <asm/octeon/cvmx-helper-pki.h>
@@ -48,6 +54,7 @@
 #include <asm/octeon/cvmx-fpa3.h>
 #include <asm/octeon/cvmx-srio.h>
 #include <asm/octeon/cvmx-app-config.h>
+#include <asm/octeon/cvmx-bgxx-defs.h>
 
 #include <asm/octeon/cvmx-fpa-defs.h>
 #include <asm/octeon/cvmx-sso-defs.h>
@@ -198,6 +205,11 @@ struct octeon3_ethernet {
 	struct net_device *netdev;
 	enum octeon3_mac_type mac_type;
 	struct octeon3_rx rx_cxt[MAX_RX_CONTEXTS];
+	struct ptp_clock_info ptp_info;
+	struct ptp_clock *ptp_clock;
+	struct cyclecounter cc;
+	struct timecounter tc;
+	spinlock_t ptp_lock;
 	int num_rx_cxt;
 	int pki_laura;
 	int pki_pkind;
@@ -207,6 +219,8 @@ struct octeon3_ethernet {
 	int port_index;
 	int rx_buf_count;
 	int tx_complete_grp;
+	int rx_timestamp_hw:1;
+	int tx_timestamp_hw:1;
 	spinlock_t stat_lock;
 	cvm_oct_callback_t intercept_cb;
 	u64 srio_tx_header;
@@ -666,6 +680,22 @@ static int octeon3_eth_replenish_all(struct octeon3_ethernet_node *oen)
 	return pending;
 }
 
+static int octeon3_eth_tx_complete_hwtstamp(struct octeon3_ethernet *priv,
+					    struct sk_buff *skb)
+{
+	struct skb_shared_hwtstamps	shts;
+	u64				hwts;
+	u64				ns;
+
+	hwts = *((u64 *)(skb->cb) + 1);
+	ns = timecounter_cyc2time(&priv->tc, hwts);
+	memset(&shts, 0, sizeof(shts));
+	shts.hwtstamp = ns_to_ktime(ns);
+	skb_tstamp_tx(skb, &shts);
+
+	return 0;
+}
+
 static int octeon3_eth_tx_complete_worker(void *data)
 {
 	union cvmx_sso_grpx_aq_cnt aq_cnt;
@@ -704,6 +734,9 @@ static int octeon3_eth_tx_complete_worker(void *data)
 				    atomic64_read(&tx_priv->tx_backlog) < MAX_TX_QUEUE_DEPTH)
 					netif_wake_queue(tx_netdev);
 				skb = container_of((void *)work, struct sk_buff, cb);
+				if (unlikely(tx_priv->tx_timestamp_hw) &&
+				    unlikely(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS))
+					octeon3_eth_tx_complete_hwtstamp(tx_priv, skb);
 				dev_kfree_skb(skb);
 			}
 
@@ -1202,6 +1235,18 @@ static int octeon3_eth_rx_one(struct octeon3_rx *rx, bool is_async,
 
 	if (likely(priv->netdev->flags & IFF_UP)) {
 		skb_checksum_none_assert(skb);
+		if (unlikely(priv->rx_timestamp_hw)) {
+			/* The first 8 bytes are the timestamp */
+			u64 hwts = *(u64 *)skb->data;
+			u64 ns;
+			struct skb_shared_hwtstamps *shts;
+
+			ns = timecounter_cyc2time(&priv->tc, hwts);
+			shts = skb_hwtstamps(skb);
+			memset(shts, 0, sizeof(*shts));
+			shts->hwtstamp = ns_to_ktime(ns);
+			__skb_pull(skb, 8);
+		}
 		skb->protocol = eth_type_trans(skb, priv->netdev);
 		skb->dev = priv->netdev;
 		if (priv->netdev->features & NETIF_F_RXCSUM) {
@@ -1400,12 +1445,38 @@ static void ethtool_get_drvinfo(struct net_device *netdev,
 	strcpy(info->bus_info, "Builtin");
 }
 
+static int ethtool_get_ts_info(struct net_device *ndev,
+				      struct ethtool_ts_info *info)
+{
+	struct octeon3_ethernet *priv = netdev_priv(ndev);
+
+	if (!octeon_has_feature(OCTEON_FEATURE_PTP))
+		return 0;
+
+	info->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |
+		SOF_TIMESTAMPING_RX_HARDWARE |
+		SOF_TIMESTAMPING_RAW_HARDWARE;
+
+	if (priv->ptp_clock)
+		info->phc_index = ptp_clock_index(priv->ptp_clock);
+	else
+		info->phc_index = -1;
+
+	info->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);
+
+	info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |
+		(1 << HWTSTAMP_FILTER_ALL);
+
+	return 0;
+}
+
 static const struct ethtool_ops octeon3_ethtool_ops = {
 	.get_drvinfo = ethtool_get_drvinfo,
 	.get_settings = bgx_port_ethtool_get_settings,
 	.set_settings = bgx_port_ethtool_set_settings,
 	.nway_reset = bgx_port_ethtool_nway_reset,
 	.get_link = ethtool_op_get_link,
+	.get_ts_info = ethtool_get_ts_info,
 };
 
 static int octeon3_eth_ndo_change_mtu(struct net_device *netdev, int new_mtu)
@@ -1896,6 +1967,7 @@ static int octeon3_eth_ndo_start_xmit(struct sk_buff *skb, struct net_device *ne
 	unsigned int scr_off = CVMX_PKO_LMTLINE * CVMX_CACHE_LINE_SIZE;
 	unsigned int ret_off = scr_off;
 	union cvmx_pko_send_hdr send_hdr;
+	union cvmx_pko_send_ext send_ext;
 	union cvmx_pko_buf_ptr buf_ptr;
 	union cvmx_pko_send_work send_work;
 	union cvmx_pko_send_mem send_mem;
@@ -2048,6 +2120,19 @@ static int octeon3_eth_ndo_start_xmit(struct sk_buff *skb, struct net_device *ne
 	cvmx_scratch_write64(scr_off, send_hdr.u64);
 	scr_off += sizeof(send_hdr);
 
+	/* Request packet to be ptp timestamped */
+	if ((unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) &&
+	    unlikely(priv->tx_timestamp_hw) && likely(!can_recycle_skb)) {
+		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+		send_ext.u64 = 0;
+		send_ext.s.subdc4 = CVMX_PKO_SENDSUBDC_EXT;
+		send_ext.s.ra = 1;
+		send_ext.s.tstmp = 1;
+		send_ext.s.markptr = ETH_HLEN;
+		cvmx_scratch_write64(scr_off, send_ext.u64);
+		scr_off += sizeof(send_ext);
+	}
+
 	/* Add the tso descriptor if needed */
 	mss = skb_shinfo(skb)->gso_size;
 	if (mss) {
@@ -2095,6 +2180,19 @@ static int octeon3_eth_ndo_start_xmit(struct sk_buff *skb, struct net_device *ne
 	cvmx_scratch_write64(scr_off, send_mem.u64);
 	scr_off += sizeof(buf_ptr);
 
+	/* Write the ptp timestamp in the skb itself */
+	if ((unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) &&
+	    unlikely(priv->tx_timestamp_hw) && likely(!can_recycle_skb)) {
+		send_mem.u64 = 0;
+		send_mem.s.wmem = 1;
+		send_mem.s.subdc4 = CVMX_PKO_SENDSUBDC_MEM;
+		send_mem.s.dsz = MEMDSZ_B64;
+		send_mem.s.alg = MEMALG_SETTSTMP;
+		send_mem.s.addr = virt_to_phys(&work[1]);
+		cvmx_scratch_write64(scr_off, send_mem.u64);
+		scr_off += sizeof(send_mem);
+	}
+
 	if (likely(can_recycle_skb)) {
 		cvmx_pko_send_free_t	send_free;
 
@@ -2221,6 +2319,257 @@ static int octeon3_eth_set_mac_address(struct net_device *netdev, void *addr)
 	return 0;
 }
 
+static cycle_t octeon3_cyclecounter_read(const struct cyclecounter *cc)
+{
+	struct octeon3_ethernet	*priv;
+	cycle_t			count;
+
+	priv = container_of(cc, struct octeon3_ethernet, cc);
+	count = cvmx_read_csr_node(priv->numa_node, CVMX_MIO_PTP_CLOCK_HI);
+	return count;
+}
+
+static int octeon3_bgx_hwtstamp(struct net_device *netdev, int en)
+{
+	struct octeon3_ethernet		*priv = netdev_priv(netdev);
+	cvmx_xiface_t			xiface;
+	cvmx_bgxx_gmp_gmi_rxx_frm_ctl_t	frmctl;
+	cvmx_bgxx_smux_rx_frm_ctl_t	xfrmctl;
+
+	xiface = cvmx_helper_xiface_to_node_interface(priv->xiface);
+	switch (cvmx_helper_bgx_get_mode(priv->xiface, priv->port_index)) {
+	case CVMX_HELPER_INTERFACE_MODE_GMII:
+	case CVMX_HELPER_INTERFACE_MODE_RGMII:
+	case CVMX_HELPER_INTERFACE_MODE_SGMII:
+		frmctl.u64 = cvmx_read_csr_node(priv->numa_node,
+			CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(priv->port_index,
+			xiface.interface));
+		frmctl.s.ptp_mode = en;
+		cvmx_write_csr_node(priv->numa_node,
+			CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(priv->port_index,
+			xiface.interface), frmctl.u64);
+		break;
+
+	case CVMX_HELPER_INTERFACE_MODE_XAUI:
+	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+	case CVMX_HELPER_INTERFACE_MODE_10G_KR:
+	case CVMX_HELPER_INTERFACE_MODE_XLAUI:
+	case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
+	case CVMX_HELPER_INTERFACE_MODE_XFI:
+		xfrmctl.u64 = cvmx_read_csr_node(priv->numa_node,
+			CVMX_BGXX_SMUX_RX_FRM_CTL(priv->port_index,
+			xiface.interface));
+		xfrmctl.s.ptp_mode = en;
+		cvmx_write_csr_node(priv->numa_node,
+			CVMX_BGXX_SMUX_RX_FRM_CTL(priv->port_index,
+			xiface.interface), xfrmctl.u64);
+		break;
+
+	default:
+		/* No timestamp support*/
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int octeon3_pki_hwtstamp(struct net_device *netdev, int en)
+{
+	struct octeon3_ethernet		*priv = netdev_priv(netdev);
+	struct cvmx_pki_port_config	pki_prt_cfg;
+	int				val = en ? 8 : 0;
+	int				ipd_port;
+
+	ipd_port = cvmx_helper_get_ipd_port(priv->xiface, priv->port_index);
+
+	cvmx_pki_get_port_config(ipd_port, &pki_prt_cfg);
+	pki_prt_cfg.pkind_cfg.fcs_skip = val;
+	pki_prt_cfg.pkind_cfg.inst_skip = val;
+	pki_prt_cfg.pkind_cfg.l2_scan_offset = val;
+	cvmx_pki_set_port_config(ipd_port, &pki_prt_cfg);
+
+	return 0;
+}
+
+static int octeon3_ioctl_hwtstamp(struct net_device *netdev,
+				  struct ifreq *rq, int cmd)
+{
+	struct octeon3_ethernet		*priv = netdev_priv(netdev);
+	union cvmx_mio_ptp_clock_cfg	ptp;
+	struct hwtstamp_config		config;
+	int				en;
+
+	if (!octeon_has_feature(OCTEON_FEATURE_PTP)) {
+		netdev_err(netdev, "Error: PTP clock not supported\n");
+		return -EOPNOTSUPP;
+	}
+
+	/* The PTP block should be enabled */
+	ptp.u64 = cvmx_read_csr_node(priv->numa_node, CVMX_MIO_PTP_CLOCK_CFG);
+	if (!ptp.s.ptp_en) {
+		netdev_err(netdev, "Error: PTP clock not enabled\n");
+		return -EOPNOTSUPP;
+	}
+
+	if (copy_from_user(&config, rq->ifr_data, sizeof(config)))
+		return -EFAULT;
+
+	if (config.flags) /* reserved for future extensions */
+		return -EINVAL;
+
+	switch (config.tx_type) {
+	case HWTSTAMP_TX_OFF:
+		priv->tx_timestamp_hw = 0;
+		break;
+	case HWTSTAMP_TX_ON:
+		priv->tx_timestamp_hw = 1;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	switch (config.rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		priv->rx_timestamp_hw = 0;
+		en = 0;
+		break;
+	case HWTSTAMP_FILTER_ALL:
+	case HWTSTAMP_FILTER_SOME:
+	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+		priv->rx_timestamp_hw = 1;
+		en = 1;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	octeon3_bgx_hwtstamp(netdev, en);
+	octeon3_pki_hwtstamp(netdev, en);
+
+	priv->cc.read = octeon3_cyclecounter_read;
+	priv->cc.mask = CLOCKSOURCE_MASK(64);
+	/* Ptp counter is always in nsec */
+	priv->cc.mult = 1;
+	priv->cc.shift = 0;
+	timecounter_init(&priv->tc, &priv->cc, ktime_to_ns(ktime_get_real()));
+
+	return 0;
+}
+
+static int octeon3_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
+{
+	struct octeon3_ethernet	*priv;
+	u64			comp;
+	u64			diff;
+	int			neg_ppb = 0;
+
+	priv = container_of(ptp, struct octeon3_ethernet, ptp_info);
+
+	if (ppb < 0) {
+		ppb = -ppb;
+		neg_ppb = 1;
+	}
+
+	/* The part per billion (ppb) is a delta from the base frequency */
+	comp = (NSEC_PER_SEC << 32) / octeon_get_io_clock_rate();
+
+	diff = comp;
+	diff *= ppb;
+	diff = div_u64(diff, 1000000000ULL);
+
+	comp = neg_ppb ? comp - diff : comp + diff;
+
+	cvmx_write_csr_node(priv->numa_node, CVMX_MIO_PTP_CLOCK_COMP, comp);
+
+	return 0;
+}
+
+static int octeon3_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+	struct octeon3_ethernet	*priv;
+	s64			now;
+	unsigned long		flags;
+
+	priv = container_of(ptp, struct octeon3_ethernet, ptp_info);
+
+	spin_lock_irqsave(&priv->ptp_lock, flags);
+	now = timecounter_read(&priv->tc);
+	now += delta;
+	timecounter_init(&priv->tc, &priv->cc, now);
+	spin_unlock_irqrestore(&priv->ptp_lock, flags);
+
+	return 0;
+}
+
+static int octeon3_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts)
+{
+	struct octeon3_ethernet	*priv;
+	u64			ns;
+	u32			remainder;
+	unsigned long		flags;
+
+	priv = container_of(ptp, struct octeon3_ethernet, ptp_info);
+
+	spin_lock_irqsave(&priv->ptp_lock, flags);
+	ns = timecounter_read(&priv->tc);
+	spin_unlock_irqrestore(&priv->ptp_lock, flags);
+	ts->tv_sec = div_u64_rem(ns, 1000000000ULL, &remainder);
+	ts->tv_nsec = remainder;
+
+	return 0;
+}
+
+static int octeon3_settime64(struct ptp_clock_info *ptp,
+			   const struct timespec64 *ts)
+{
+	struct octeon3_ethernet	*priv;
+	u64			ns;
+	unsigned long		flags;
+
+	priv = container_of(ptp, struct octeon3_ethernet, ptp_info);
+	ns = timespec_to_ns(ts);
+
+	spin_lock_irqsave(&priv->ptp_lock, flags);
+	timecounter_init(&priv->tc, &priv->cc, ns);
+	spin_unlock_irqrestore(&priv->ptp_lock, flags);
+
+	return 0;
+}
+
+static int octeon3_enable(struct ptp_clock_info *ptp,
+			  struct ptp_clock_request *rq, int on)
+{
+	return -EOPNOTSUPP;
+}
+
+static int octeon3_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+	int rc;
+
+	switch (cmd) {
+	case SIOCSHWTSTAMP:
+		rc = octeon3_ioctl_hwtstamp(netdev, ifr, cmd);
+		break;
+
+	default:
+		rc = bgx_port_do_ioctl(netdev, ifr, cmd);
+		break;
+	}
+
+	return rc;
+}
+
 static const struct net_device_ops octeon3_eth_netdev_ops = {
 	.ndo_init		= octeon3_eth_bgx_ndo_init,
 	.ndo_uninit		= octeon3_eth_ndo_uninit,
@@ -2231,7 +2580,7 @@ static const struct net_device_ops octeon3_eth_netdev_ops = {
 	.ndo_set_rx_mode	= bgx_port_set_rx_filtering,
 	.ndo_set_mac_address	= octeon3_eth_set_mac_address,
 	.ndo_change_mtu		= octeon3_eth_ndo_change_mtu,
-	.ndo_do_ioctl		= bgx_port_do_ioctl,
+	.ndo_do_ioctl		= octeon3_ioctl,
 };
 
 #if IS_ENABLED(CONFIG_OCTEON3_ETHERNET_SRIO)
@@ -2531,6 +2880,22 @@ static int octeon3_eth_probe(struct platform_device *pdev)
 		list_del(&priv->list);
 		free_netdev(netdev);
 	}
+
+	spin_lock_init(&priv->ptp_lock);
+	priv->ptp_info.owner = THIS_MODULE;
+	snprintf(priv->ptp_info.name, 16, "octeon3 ptp");
+	priv->ptp_info.max_adj = 250000000;
+	priv->ptp_info.n_alarm = 0;
+	priv->ptp_info.n_ext_ts = 0;
+	priv->ptp_info.n_per_out = 0;
+	priv->ptp_info.pps = 0;
+	priv->ptp_info.adjfreq = octeon3_adjfreq;
+	priv->ptp_info.adjtime = octeon3_adjtime;
+	priv->ptp_info.gettime64 = octeon3_gettime64;
+	priv->ptp_info.settime64 = octeon3_settime64;
+	priv->ptp_info.enable = octeon3_enable;
+	priv->ptp_clock = ptp_clock_register(&priv->ptp_info, &pdev->dev);
+
 	netdev_info(netdev, "Registered\n");
 	return 0;
 }
@@ -2603,6 +2968,7 @@ static int octeon3_eth_remove(struct platform_device *pdev)
 	int				node = priv->numa_node;
 	struct octeon3_ethernet_node	*oen = octeon3_eth_node + node;
 
+	ptp_clock_unregister(priv->ptp_clock);
 	unregister_netdev(netdev);
 	bgx_port_set_netdev(pdev->dev.parent, NULL);
 	dev_set_drvdata(&pdev->dev, NULL);
-- 
1.9.1

