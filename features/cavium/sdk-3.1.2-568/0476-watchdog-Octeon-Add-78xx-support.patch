From 4144444641baa55fc5ef21c07e3f6e071553a092 Mon Sep 17 00:00:00 2001
From: Carlos Munoz <carlos.munoz@caviumnetworks.com>
Date: Thu, 13 Feb 2014 13:46:59 -0800
Subject: [PATCH 476/974] watchdog: Octeon: Add 78xx support.

Signed-off-by: Carlos Munoz <carlos.munoz@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c         |  3 +
 arch/mips/include/asm/octeon/cvmx-ciu-defs.h | 12 ++++
 drivers/watchdog/octeon-wdt-main.c           | 87 ++++++++++++++++++++++------
 3 files changed, 85 insertions(+), 17 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index e2b1046..ce8cc3f 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -2862,6 +2862,7 @@ void *octeon_irq_get_ciu3_info(int node)
 {
 	return octeon_ciu3_info_per_node[node & CVMX_NODE_MASK];
 }
+EXPORT_SYMBOL(octeon_irq_get_ciu3_info);
 
 void octeon_irq_add_block_domain(int node, uint8_t block,
 				 struct irq_domain *domain)
@@ -2871,6 +2872,7 @@ void octeon_irq_add_block_domain(int node, uint8_t block,
 	ciu3_info = octeon_ciu3_info_per_node[node & CVMX_NODE_MASK];
 	ciu3_info->domain[block] = domain;
 }
+EXPORT_SYMBOL(octeon_irq_add_block_domain);
 
 struct irq_domain *octeon_irq_get_block_domain(int node, uint8_t block)
 {
@@ -2879,3 +2881,4 @@ struct irq_domain *octeon_irq_get_block_domain(int node, uint8_t block)
 	ciu3_info = octeon_ciu3_info_per_node[node & CVMX_NODE_MASK];
 	return ciu3_info->domain[block];
 }
+EXPORT_SYMBOL(octeon_irq_get_block_domain);
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
index d4a1e12..631e44d 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
@@ -881,6 +881,10 @@ static inline uint64_t CVMX_CIU_PP_POKEX(unsigned long offset)
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x0001070100100200ull) + ((offset) & 31) * 8;
 			break;
+
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 47))
+				return CVMX_ADD_IO_SEG(0x0001010000030000ull) + ((offset) & 63) * 8;
 	}
 	cvmx_warn("CVMX_CIU_PP_POKEX (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000000580ull) + ((offset) & 3) * 8;
@@ -910,6 +914,8 @@ static inline uint64_t CVMX_CIU_PP_POKEX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001070000000580ull) + (offset) * 8;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070100100200ull) + (offset) * 8;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001010000030000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000580ull) + (offset) * 8;
 }
@@ -1258,6 +1264,10 @@ static inline uint64_t CVMX_CIU_WDOGX(unsigned long offset)
 			if ((offset <= 31))
 				return CVMX_ADD_IO_SEG(0x0001070100100000ull) + ((offset) & 31) * 8;
 			break;
+
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 47))
+				return CVMX_ADD_IO_SEG(0x0001010000020000ull) + ((offset) & 63) * 8;
 	}
 	cvmx_warn("CVMX_CIU_WDOGX (offset = %lu) not supported on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x0001070000000500ull) + ((offset) & 3) * 8;
@@ -1287,6 +1297,8 @@ static inline uint64_t CVMX_CIU_WDOGX(unsigned long offset)
 			return CVMX_ADD_IO_SEG(0x0001070000000500ull) + (offset) * 8;
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
 			return CVMX_ADD_IO_SEG(0x0001070100100000ull) + (offset) * 8;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0001010000020000ull) + (offset) * 8;
 	}
 	return CVMX_ADD_IO_SEG(0x0001070000000500ull) + (offset) * 8;
 }
diff --git a/drivers/watchdog/octeon-wdt-main.c b/drivers/watchdog/octeon-wdt-main.c
index dd48772..1a7df46 100644
--- a/drivers/watchdog/octeon-wdt-main.c
+++ b/drivers/watchdog/octeon-wdt-main.c
@@ -74,6 +74,9 @@
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-ciu2-defs.h>
 
+/* Watchdog interrupt major block number (8 MSBs of intsn) */
+#define WD_BLOCK_NUMBER		0x01
+
 /* The count needed to achieve timeout_sec. */
 static unsigned int timeout_cnt;
 
@@ -260,11 +263,12 @@ static irqreturn_t octeon_wdt_poke_irq(int cpl, void *dev_id)
 {
 	unsigned int core = cvmx_get_core_num();
 	int cpu = core2cpu(core);
+	int node = cvmx_get_node_num();
 
 	if (do_coundown) {
 		if (per_cpu_countdown[cpu] > 0) {
 			/* We're alive, poke the watchdog */
-			cvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);
+			cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(core), 1);
 			per_cpu_countdown[cpu]--;
 		} else {
 			/* Bad news, you are about to reboot. */
@@ -273,7 +277,7 @@ static irqreturn_t octeon_wdt_poke_irq(int cpl, void *dev_id)
 		}
 	} else {
 		/* Not open, just ping away... */
-		cvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);
+		cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(core), 1);
 	}
 	return IRQ_HANDLED;
 }
@@ -374,7 +378,7 @@ void octeon_wdt_nmi_stage3(u64 reg[32])
 	octeon_wdt_write_hex(cp0_cause, 16);
 	octeon_wdt_write_string("\r\n");
 
-	/* The CIU register are different in cn68xx compared to other models. */
+	/* The CIU register are different on the different octeon models */
 	if (is_ciu2) {
 		octeon_wdt_write_string("\tsrc_wd\t0x");
 		octeon_wdt_write_hex(cvmx_read_csr(CVMX_CIU2_SRC_PPX_IP2_WDOG(coreid)), 16);
@@ -389,7 +393,7 @@ void octeon_wdt_nmi_stage3(u64 reg[32])
 		octeon_wdt_write_string("\tsum\t0x");
 		octeon_wdt_write_hex(cvmx_read_csr(CVMX_CIU2_SUM_PPX_IP2(coreid)), 16);
 		octeon_wdt_write_string("\r\n");
-	} else {
+	} else if (!octeon_has_feature(OCTEON_FEATURE_CIU3)) {
 		octeon_wdt_write_string("\tsum0\t0x");
 		octeon_wdt_write_hex(cvmx_read_csr(CVMX_CIU_INTX_SUM0(coreid * 2)), 16);
 		octeon_wdt_write_string("\ten0\t0x");
@@ -404,18 +408,20 @@ static void octeon_wdt_disable_interrupt(int cpu)
 {
 	unsigned int core;
 	unsigned int irq;
+	int node;
 	union cvmx_ciu_wdogx ciu_wdog;
 
 	core = cpu2core(cpu);
+	node = cpu_to_node(cpu);
 
 	irq = OCTEON_IRQ_WDOG0 + core;
 
 	/* Poke the watchdog to clear out its state */
-	cvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);
+	cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(core), 1);
 
 	/* Disable the hardware. */
 	ciu_wdog.u64 = 0;
-	cvmx_write_csr(CVMX_CIU_WDOGX(core), ciu_wdog.u64);
+	cvmx_write_csr_node(node, CVMX_CIU_WDOGX(core), ciu_wdog.u64);
 
 	free_irq(irq, octeon_wdt_poke_irq);
 }
@@ -425,31 +431,52 @@ static void octeon_wdt_setup_interrupt(int cpu)
 	unsigned int core;
 	unsigned int irq;
 	union cvmx_ciu_wdogx ciu_wdog;
+	int node;
+	struct irq_domain *domain;
+	int hwirq;
 
 	core = cpu2core(cpu);
+	node = cpu_to_node(cpu);
 
 	/* Disable it before doing anything with the interrupts. */
 	ciu_wdog.u64 = 0;
-	cvmx_write_csr(CVMX_CIU_WDOGX(core), ciu_wdog.u64);
+	cvmx_write_csr_node(node, CVMX_CIU_WDOGX(core), ciu_wdog.u64);
 
 	per_cpu_countdown[cpu] = countdown_reset;
 
-	irq = OCTEON_IRQ_WDOG0 + core;
+	if (octeon_has_feature(OCTEON_FEATURE_CIU3)) {
+		/* Must get the domain for the watchdog block */
+		domain = octeon_irq_get_block_domain(node, WD_BLOCK_NUMBER);
+
+		/* Get a irq for the wd intsn (hardware interrupt) */
+		hwirq = WD_BLOCK_NUMBER << 12 | 0x200 | core;
+		irq = irq_create_mapping(domain, hwirq);
+	} else
+		irq = OCTEON_IRQ_WDOG0 + core;
 
 	if (request_irq(irq, octeon_wdt_poke_irq,
 			IRQF_NO_THREAD, "octeon_wdt", octeon_wdt_poke_irq))
 		panic("octeon_wdt: Couldn't obtain irq %d", irq);
 
+	/* Must set the irq affinity here */
+	if (octeon_has_feature(OCTEON_FEATURE_CIU3)) {
+		cpumask_t mask;
+
+		cpumask_clear(&mask);
+		cpumask_set_cpu(cpu, &mask);
+		irq_set_affinity(irq, &mask);
+	}
+
 	cpumask_set_cpu(cpu, &irq_enabled_cpus);
 
 	/* Poke the watchdog to clear out its state */
-	cvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);
+	cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(core), 1);
 
 	/* Finally enable the watchdog now that all handlers are installed */
 	ciu_wdog.u64 = 0;
 	ciu_wdog.s.len = timeout_cnt;
 	ciu_wdog.s.mode = 3;	/* 3 = Interrupt + NMI + Soft-Reset */
-	cvmx_write_csr(CVMX_CIU_WDOGX(core), ciu_wdog.u64);
+	cvmx_write_csr_node(node, CVMX_CIU_WDOGX(core), ciu_wdog.u64);
 }
 
 static int octeon_wdt_cpu_callback(struct notifier_block *nfb,
@@ -475,18 +502,29 @@ static void octeon_wdt_ping(void)
 {
 	int cpu;
 	int coreid;
+	int node;
+	int irq;
+	struct irq_domain *domain;
+	int hwirq;
 
 	if (disable)
 		return;
 
 	for_each_online_cpu(cpu) {
 		coreid = cpu2core(cpu);
-		cvmx_write_csr(CVMX_CIU_PP_POKEX(coreid), 1);
+		node = cpu_to_node(cpu);
+		cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(coreid), 1);
 		per_cpu_countdown[cpu] = countdown_reset;
 		if ((countdown_reset || !do_coundown) &&
 		    !cpumask_test_cpu(cpu, &irq_enabled_cpus)) {
 			/* We have to enable the irq */
-			int irq = OCTEON_IRQ_WDOG0 + coreid;
+			if (octeon_has_feature(OCTEON_FEATURE_CIU3)) {
+				domain = octeon_irq_get_block_domain(node,
+						               WD_BLOCK_NUMBER);
+				hwirq = WD_BLOCK_NUMBER << 12 | 0x200 | coreid;
+				irq = irq_find_mapping(domain, hwirq);
+			} else
+				irq = OCTEON_IRQ_WDOG0 + coreid;
 			enable_irq(irq);
 			cpumask_set_cpu(cpu, &irq_enabled_cpus);
 		}
@@ -527,6 +565,7 @@ static int octeon_wdt_set_heartbeat(int t)
 	int cpu;
 	int coreid;
 	union cvmx_ciu_wdogx ciu_wdog;
+	int node;
 
 	if (t <= 0)
 		return -1;
@@ -538,12 +577,13 @@ static int octeon_wdt_set_heartbeat(int t)
 
 	for_each_online_cpu(cpu) {
 		coreid = cpu2core(cpu);
-		cvmx_write_csr(CVMX_CIU_PP_POKEX(coreid), 1);
+		node = cpu_to_node(cpu);
+		cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(coreid), 1);
 		ciu_wdog.u64 = 0;
 		ciu_wdog.s.len = timeout_cnt;
 		ciu_wdog.s.mode = 3;	/* 3 = Interrupt + NMI + Soft-Reset */
-		cvmx_write_csr(CVMX_CIU_WDOGX(coreid), ciu_wdog.u64);
-		cvmx_write_csr(CVMX_CIU_PP_POKEX(coreid), 1);
+		cvmx_write_csr_node(node, CVMX_CIU_WDOGX(coreid), ciu_wdog.u64);
+		cvmx_write_csr_node(node, CVMX_CIU_PP_POKEX(coreid), 1);
 	}
 	octeon_wdt_ping(); /* Get the irqs back on. */
 	return 0;
@@ -769,6 +809,10 @@ out:
 static void __exit octeon_wdt_cleanup(void)
 {
 	int cpu;
+	int node;
+	unsigned int irq;
+	struct irq_domain *domain;
+	int hwirq;
 
 	misc_deregister(&octeon_wdt_miscdev);
 
@@ -779,10 +823,19 @@ static void __exit octeon_wdt_cleanup(void)
 
 	for_each_online_cpu(cpu) {
 		int core = cpu2core(cpu);
+		node = cpu_to_node(cpu);
 		/* Disable the watchdog */
-		cvmx_write_csr(CVMX_CIU_WDOGX(core), 0);
+		cvmx_write_csr_node(node, CVMX_CIU_WDOGX(core), 0);
+
 		/* Free the interrupt handler */
-		free_irq(OCTEON_IRQ_WDOG0 + core, octeon_wdt_poke_irq);
+		if (octeon_has_feature(OCTEON_FEATURE_CIU3)) {
+			domain = octeon_irq_get_block_domain(node,
+							     WD_BLOCK_NUMBER);
+			hwirq = WD_BLOCK_NUMBER << 12 | 0x200 | core;
+			irq = irq_find_mapping(domain, hwirq);
+		} else
+			irq = OCTEON_IRQ_WDOG0 + core;
+		free_irq(irq, octeon_wdt_poke_irq);
 	}
 	/*
 	 * Disable the boot-bus memory, the code it points to is soon
-- 
2.6.2

