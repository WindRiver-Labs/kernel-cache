From a0cb08b7a212584776629bdb021748feeb80d58b Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Fri, 4 Dec 2015 08:16:14 -0800
Subject: [PATCH 01/13] MIPS:OCTEON: Sync-up SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>

Conflicts:

	arch/mips/include/asm/octeon/cvmx-app-init.h

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from patch set for OCTEON SDK 3.1.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |    3 +
 .../cavium-octeon/executive/cvmx-helper-board.c    |    3 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |   25 ++++++++-
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |   21 +++++++-
 arch/mips/include/asm/octeon/cvmx-app-init.h       |    4 +-
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      |    4 +-
 arch/mips/include/asm/octeon/cvmx-bootmem.h        |   15 ------
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     |   25 ++++-----
 arch/mips/include/asm/octeon/cvmx-mixx-defs.h      |    2 +-
 arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h |    4 +-
 arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h   |   17 +++++-
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |   53 +++++++++++++-------
 arch/mips/include/asm/octeon/cvmx-pki.h            |   10 ++--
 arch/mips/include/asm/octeon/cvmx-pow.h            |   21 ++++++--
 arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h   |    2 +-
 arch/mips/include/asm/octeon/octeon-feature.h      |    4 +-
 16 files changed, 139 insertions(+), 74 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 92f0a50..163e6be 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -1552,6 +1552,9 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 				    && index >= 2
 				    && xi.interface == 2) {
 					lane = index - 2;
+				} else if (OCTEON_IS_MODEL(OCTEON_CNF75XX)
+					   && index >= 2) {
+					lane = index - 2;
 				}
 				__cvmx_qlm_rx_equalization(node, qlm, lane);
 			}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
index b8b02fd..ac7b708 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
@@ -479,7 +479,8 @@ static void __cvmx_mdio_addr_to_node_bus(uint64_t addr, int *node, int *bus)
 				    __func__, (unsigned long long) addr);
 			break;
 		}
-	} else if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+	} else if (OCTEON_IS_MODEL(OCTEON_CN73XX)
+		   || OCTEON_IS_MODEL(OCTEON_CNF75XX)) {
 		switch (addr) {
 		case 0x0001180000003800:
 			*bus = 0;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index 7a69082..ff2d64c 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 127467 $<hr>
+ * <hr>$Revision: 129050 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -328,8 +328,25 @@ static int __cvmx_pcie_get_qlm(int node, int pcie_port)
 		default: /* Only three PEM blocks */
 			return -1;
 		}
+	} else if (OCTEON_IS_MODEL(OCTEON_CNF75XX)) {
+		cvmx_gserx_cfg_t gserx_cfg;
+		switch (pcie_port) {
+		case 0:  /* PEM0 */
+			gserx_cfg.u64 = CVMX_READ_CSR(CVMX_GSERX_CFG(0));
+			if (gserx_cfg.s.pcie)
+				return 0; /* PEM0 is on QLM0 and possibly QLM1 */
+			else
+				return -1; /* PEM0 is disabled */
+		case 1: /* PEM1 */
+			gserx_cfg.u64 = CVMX_READ_CSR(CVMX_GSERX_CFG(1));
+			if (gserx_cfg.s.pcie)
+				return 1;  /* PEM1 is on DLM1 */
+			else
+				return -1;  /* PEM1 is disabled */
+		default:
+			return -1;
+		}
 	}
-
 	return -1;
 }
 
@@ -535,7 +552,9 @@ static void __cvmx_pcie_rc_initialize_config_space(int node, int pcie_port)
 				     pciercx_cfg034.u32);
 	}
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX)
+	    || OCTEON_IS_MODEL(OCTEON_CN73XX)
+	    || OCTEON_IS_MODEL(OCTEON_CNF75XX)) {
 		int qlm = __cvmx_pcie_get_qlm(node, pcie_port);
 		int speed = cvmx_qlm_get_gbaud_mhz(qlm);
 		cvmx_pemx_cfg_t pem_cfg;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index 186f01e..36c40b2 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 122709 $<hr>
+ * <hr>$Revision: 129042 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -152,6 +152,8 @@ int cvmx_qlm_get_num(void)
 		return 8;
 	else if (OCTEON_IS_MODEL(OCTEON_CN73XX))
 		return 7;
+	else if (OCTEON_IS_MODEL(OCTEON_CNF75XX))
+		return 9;
 	/* cvmx_dprintf("Warning: cvmx_qlm_get_num: This chip does not have QLMs\n"); */
 	return 0;
 }
@@ -347,12 +349,25 @@ int cvmx_qlm_mux_interface(int bgx)
 {
 	int mux = 0;
 	cvmx_gserx_cfg_t gser1, gser2;
+	int qlm1, qlm2;
 
 	if (OCTEON_IS_MODEL(OCTEON_CN73XX) && bgx != 2)
 		return -1;
+	else if (OCTEON_IS_MODEL(OCTEON_CNF75XX) && bgx != 0)
+		return -1;
+	else
+		return -1;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+		qlm1 = 5;
+		qlm2 = 6;
+	} else if (OCTEON_IS_MODEL(OCTEON_CNF75XX)) {
+		qlm1 = 4;
+		qlm2 = 5;
+	}
 
-	gser1.u64 = cvmx_read_csr(CVMX_GSERX_CFG(5));
-	gser2.u64 = cvmx_read_csr(CVMX_GSERX_CFG(6));
+	gser1.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm1));
+	gser2.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm2));
 
 	if (gser1.s.bgx && gser2.s.bgx) {
 		mux = 0;
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index c01dbab..ad6c5c1 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -41,7 +41,7 @@
  * @file
  * Header file for simple executive application initialization.  This defines
  * part of the ABI between the bootloader and the application.
- * <hr>$Revision: 127966 $<hr>
+ * <hr>$Revision: 128584 $<hr>
  *
  */
 
@@ -319,6 +319,7 @@ enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_NIC73 = 77,	/* Liquid I/O */
 	CVMX_BOARD_TYPE_NIC25E = 79,
 	CVMX_BOARD_TYPE_NIC225E = 80,
+	CVMX_BOARD_TYPE_EBB7504 = 81,
 	CVMX_BOARD_TYPE_MAX,
 	/* NOTE:  256-257 are being used by a customer. */
 
@@ -466,6 +467,7 @@ static inline const char *cvmx_board_type_to_string(enum cvmx_board_types_enum t
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC73)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC25E)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC225E)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB7504)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
 
 		/* Customer boards listed here */
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index 826767e..e97964c 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -4645,7 +4645,7 @@ union cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval {
 	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t interval                     : 16; /**< Arbitrate for a 802.3 PAUSE packet or CBFC PAUSE packet every (INTERVAL * 512) bit-times.
+	uint64_t interval                     : 16; /**< Arbitrate for a 802.3 PAUSE packet every (INTERVAL * 512) bit-times.
                                                          Normally, 0 < INTERVAL < BGX()_GMP_GMI_TX()_PAUSE_PKT_TIME[PTIME].
                                                          INTERVAL = 0 only sends a single PAUSE packet for each backpressure event.
                                                          BGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND] must be 1 when INTERVAL = 0. */
@@ -4669,7 +4669,7 @@ union cvmx_bgxx_gmp_gmi_txx_pause_pkt_time {
 	struct cvmx_bgxx_gmp_gmi_txx_pause_pkt_time_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t ptime                        : 16; /**< Provides the pause_time field placed in outbound 802.3 PAUSE packets or CBFC PAUSE packets
+	uint64_t ptime                        : 16; /**< Provides the pause_time field placed in outbound 802.3 PAUSE packets
                                                          in 512 bit-times. Normally, P_TIME >
                                                          BGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL[INTERVAL]. For programming information see
                                                          BGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL. */
diff --git a/arch/mips/include/asm/octeon/cvmx-bootmem.h b/arch/mips/include/asm/octeon/cvmx-bootmem.h
index 927ee0a..7a748e0 100644
--- a/arch/mips/include/asm/octeon/cvmx-bootmem.h
+++ b/arch/mips/include/asm/octeon/cvmx-bootmem.h
@@ -126,7 +126,6 @@ typedef struct cvmx_bootmem_named_block_desc cvmx_bootmem_named_block_desc_t;
 */
 typedef struct {
 	/* Linux compatible proxy for __BIG_ENDIAN */
-#if defined(__BIG_ENDIAN_BITFIELD) || defined(CVMX_BUILD_FOR_LINUX_HOST)
 	uint32_t lock;
 			    /**< spinlock to control access to list */
 	uint32_t flags;
@@ -146,20 +145,6 @@ typedef struct {
 					 /**< length of name array in bootmem blocks */
 	uint64_t named_block_array_addr;
 					 /**< address of named memory block descriptors */
-#else				/* __LITTLE_ENDIAN */
-	uint32_t flags;
-	uint32_t lock;
-	uint64_t head_addr;
-
-	uint32_t minor_version;
-	uint32_t major_version;
-	uint64_t app_data_addr;
-	uint64_t app_data_size;
-
-	uint32_t named_block_name_len;
-	uint32_t named_block_num_blocks;
-	uint64_t named_block_array_addr;
-#endif
 } cvmx_bootmem_desc_t;
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index a028651..32a21be 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -2814,7 +2814,7 @@ union cvmx_gserx_cfg {
 	uint64_t srio                         : 1;  /**< When set, indicates the GSER is configured for SRIO mode. [SRIO] must not be set
                                                          when any of [BGX,PCIE,RMAC] are set. [SRIO] must only be set for QLM2 and QLM3
                                                          (i.e. GSER2 and GSER3). */
-	uint64_t sata                         : 1;  /**< Reserved. */
+	uint64_t sata                         : 1;  /**< Unused. */
 	uint64_t bgx_quad                     : 1;  /**< Reserved. */
 	uint64_t bgx_dual                     : 1;  /**< Reserved. */
 	uint64_t bgx                          : 1;  /**< When set, indicates the GSER is configured for BGX mode. [BGX] must not be set
@@ -4385,8 +4385,7 @@ union cvmx_gserx_lanex_misc_cfg_0 {
                                                          PHY EIE status assertions to determine EIE and assert Raw
                                                          PCS output pcs_mac_rx_eie_det_sts. */
 	uint64_t eie_det_stl_on_time          : 3;  /**< EIE detec state machine "on" delay prior to sampling
-                                                         PHY EIE status.  Software needs to set this field to 0x4 if
-                                                         in SATA mode (GSER()_CFG[SATA] is set). */
+                                                         PHY EIE status. */
 	uint64_t eie_det_stl_off_time         : 3;  /**< EIE detec state machine "off" delay prior to sampling
                                                          PHY EIE status. */
 	uint64_t tx_bit_order                 : 1;  /**< 0x1: Reverse bit order of parallel data to SerDes TX.
@@ -6687,7 +6686,7 @@ union cvmx_gserx_lane_lpbken {
 	struct cvmx_gserx_lane_lpbken_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t lpbken                       : 4;  /**< For links that are not in PCIE nor SATA mode. When asserted in P0 state,
+	uint64_t lpbken                       : 4;  /**< For links that are not in PCIE mode. When asserted in P0 state,
                                                          allows per lane TX-to-RX serial loopback activation.
                                                          <3>: Lane 3.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
                                                          <2>: Lane 2.  Not supported in GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, or GSER8.
@@ -6716,7 +6715,7 @@ union cvmx_gserx_lane_mode {
 	struct cvmx_gserx_lane_mode_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t lmode                        : 4;  /**< For links that are not in PCIE nor SATA mode, used to index into the PHY
+	uint64_t lmode                        : 4;  /**< For links that are not in PCIE mode, used to index into the PHY
                                                          table to select electrical specs and link rate. Note that the PHY table can be modified
                                                          such that any supported link rate can be derived regardless of the configured LMODE.
                                                          0x0: R_25G_REFCLK100.
@@ -6732,7 +6731,7 @@ union cvmx_gserx_lane_mode {
                                                          0xA: R_5G_REFCLK125.
                                                          0xB: R_8G_REFCLK125.
                                                          0xC - 0xF: Reserved.
-                                                         This register is not used for PCIE nor SATA configurations. This register
+                                                         This register is not used for PCIE configurations. This register
                                                          defaults to R_625G_REFCLK15625_RXAUI.
                                                          It is recommended that the PHY be in reset when reconfiguring the LMODE
                                                          (GSER()_PHY_CTL[PHY_RESET] is set).
@@ -6999,7 +6998,7 @@ union cvmx_gserx_lane_srst {
 	struct cvmx_gserx_lane_srst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t lsrst                        : 1;  /**< For links that are not in PCIE nor SATA mode, resets all 4 lanes
+	uint64_t lsrst                        : 1;  /**< For links that are not in PCIE, resets all 4 lanes
                                                          (equivalent to the P2 power state) after any pending requests (power state change, rate
                                                          change) are complete. The lanes remain in reset state while this signal is asserted. When
                                                          the signal deasserts, the lanes exit the reset state and the PHY returns to the power
@@ -8344,8 +8343,8 @@ union cvmx_gserx_phy_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t phy_reset                    : 1;  /**< When asserted, the PHY is held in reset. This bit is initialized as follows:
-                                                         0 = (not reset) = Bootable PCIe.
-                                                         1 = (reset) = Non-bootable PCIe, BGX, or SATA. */
+                                                         0 = (not reset) = Bootable PCIe, and  SRIO.
+                                                         1 = (reset) = Non-bootable PCIe, BGX, and SRIO with SPD pins strapped for 0xF. */
 	uint64_t phy_pd                       : 1;  /**< When asserted, the PHY is powered down. */
 #else
 	uint64_t phy_pd                       : 1;
@@ -8704,7 +8703,7 @@ union cvmx_gserx_rx_coast {
 	struct cvmx_gserx_rx_coast_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t coast                        : 4;  /**< For links that are not in PCIE nor SATA mode, control signals to freeze
+	uint64_t coast                        : 4;  /**< For links that are not in PCIE mode, control signals to freeze
                                                          the frequency of the per lane CDR in the PHY. The COAST signals are only valid in P0
                                                          state, come up asserted and are deasserted in hardware after detecting the electrical idle
                                                          exit (GSER()_RX_EIE_DETSTS[EIESTS]). Once the COAST signal deasserts, the CDR is
@@ -8737,7 +8736,7 @@ union cvmx_gserx_rx_eie_deten {
 	struct cvmx_gserx_rx_eie_deten_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t eiede                        : 4;  /**< For links that are not in PCIE nor SATA mode, these bits enable per lane
+	uint64_t eiede                        : 4;  /**< For links that are not in PCIE mode, these bits enable per lane
                                                          electrical idle exit (EIE) detection. When EIE is detected,
                                                          GSER()_RX_EIE_DETSTS[EIELTCH] is asserted. EIEDE defaults to the enabled state. Once
                                                          EIE has been detected, EIEDE must be disabled, and then enabled again to perform another
@@ -8952,9 +8951,7 @@ union cvmx_gserx_rx_pwr_ctrl_p2 {
                                                          <3> = Reserved.
                                                          <2> = Lane DLL.
                                                          <1> = DFE/Samplers.
-                                                         <0> = Termination.
-                                                         Software needs to clear the Terminatin bit in SATA mode
-                                                         (GSER()_CFG[SATA] is set). */
+                                                         <0> = Termination. */
 	uint64_t p2_rx_chpd                   : 1;  /**< RX lane power down. */
 #else
 	uint64_t p2_rx_chpd                   : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
index e962e98..0255cd7 100644
--- a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
@@ -1592,7 +1592,7 @@ union cvmx_mixx_tstamp {
 	struct cvmx_mixx_tstamp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t tstamp                       : 64; /**< MIX timestamp value. When software sets up an O-Ring entry with
-                                                         [47] = 1 (TSTAMP), the packet is tagged with a special 'SOP with TSTAMP' flag as it is
+                                                         [49] = 1 (TSTAMP), the packet is tagged with a special 'SOP with TSTAMP' flag as it is
                                                          sent to the BGX. Later the BGX sends sample strobe(s) to capture a global 64-bit timestamp
                                                          value, followed by a 'commit' strobe which writes the last sampled value into the outbound
                                                          timestamp FIFO (max depth = 4) and increments
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
index 6b42e15..d95ebc6 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
@@ -983,7 +983,9 @@ union cvmx_pcieepvfx_cfg030 {
                                                          receive any of the errors in PCIEEPVF()_CFG068, for example a replay-timer timeout.
                                                          Also, it can be set if we get any of the errors in PCIEEPVF()_CFG066 that has a severity
                                                          set to Nonfatal and meets the Advisory Nonfatal criteria, which most ECRC errors should. */
-	uint32_t i_flr                        : 1;  /**< Initiate function level reset. */
+	uint32_t i_flr                        : 1;  /**< Initiate function level reset when written to one.
+                                                         [I_FLR] must not be written to one via the indirect PEM()_CFG_WR. It should only ever
+                                                         be written to one via a direct PCIe access. */
 	uint32_t mrrs                         : 3;  /**< Read-only copy of the associated PF's PCIEP()_CFG030[MRRS]. */
 	uint32_t ns_en                        : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG030[NS_EN]. */
 	uint32_t ap_en                        : 1;  /**< Read-only copy of the associated PF's PCIEP()_CFG030[AP_EN]. */
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index 07656ce..78dad6c 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -7460,7 +7460,9 @@ union cvmx_pcieepx_cfg030 {
                                                          receive any of the errors in PCIEEP()_CFG068, for example a replay-timer timeout.
                                                          Also, it can be set if we get any of the errors in PCIEEP()_CFG066 that has a severity
                                                          set to Nonfatal and meets the Advisory Nonfatal criteria, which most ECRC errors should. */
-	uint32_t i_flr                        : 1;  /**< Initiate function level reset. */
+	uint32_t i_flr                        : 1;  /**< Initiate function level reset.
+                                                         [I_FLR] must not be written to one via the indirect PEM()_CFG_WR. It should only ever
+                                                         be written to one via a direct PCIe access. */
 	uint32_t mrrs                         : 3;  /**< Max read request size.
                                                          0x0 =128 bytes.
                                                          0x1 = 256 bytes.
@@ -8306,8 +8308,17 @@ union cvmx_pcieepx_cfg038 {
 	uint32_t atom_op                      : 1;  /**< AtomicOp requester enable. */
 	uint32_t ari                          : 1;  /**< Alternate routing ID forwarding supported. */
 	uint32_t ctd                          : 1;  /**< Completion timeout disable. */
-	uint32_t ctv                          : 4;  /**< Completion timeout value. Completion timeout programming is not supported. Completion
-                                                         timeout is the range of 16 ms to 55 ms. */
+	uint32_t ctv                          : 4;  /**< Completion timeout value.
+                                                         0x0 = Default range: 16 ms to 55 ms.
+                                                         0x1 = 50 us to 100 us.
+                                                         0x2 = 1 ms to 10 ms.
+                                                         0x3 = 16 ms to 55 ms.
+                                                         0x6 = 65 ms to 210 ms.
+                                                         0x9 = 260 ms to 900 ms.
+                                                         0xA = 1 s to 3.5 s.
+                                                         0xD = 4 s to 13 s.
+                                                         0xE = 17 s to 64 s.
+                                                         Values not defined are reserved. */
 #else
 	uint32_t ctv                          : 4;
 	uint32_t ctd                          : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index e421316..7c4141c 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -1952,8 +1952,7 @@ union cvmx_pki_clx_pkindx_cfg {
                                                          0x2 = Enable custom LG header extraction after layer D.
                                                          0x3 = Enable custom LG header extraction after layer E.
                                                          0x4 = Enable custom LG header extraction after layer F.
-                                                         0x5-0x7 = Reserved.
-                                                         If non-zero PKI_GBL_PEN[CLG_PEN] must be set. */
+                                                         0x5-0x7 = Reserved. */
 	uint64_t fcs_pres                     : 1;  /**< FCS present.
                                                          0 = FCS not present. FCS may not be checked nor stripped.
                                                          1 = FCS present; the last four bytes of the packet are part of the FCS and may not be
@@ -1962,25 +1961,26 @@ union cvmx_pki_clx_pkindx_cfg {
                                                          corresponding [FCS_PRES] must be set. */
 	uint64_t mpls_en                      : 1;  /**< Enable MPLS parsing.
                                                          0 = Any MPLS labels are ignored, but may be handled by custom Ethertype PCAM matchers.
-                                                         1 = MPLS label stacks are parsed and skipped over. PKI_GBL_PEN[MPLS_PEN] must be set. */
+                                                         1 = MPLS label stacks are parsed and skipped over. */
 	uint64_t inst_hdr                     : 1;  /**< INST header. When set, a PKI_INST_HDR_S is present PKI_CL()_PKIND()_SKIP[INST_SKIP]
                                                          bytes into the packet received by PKI. */
 	uint64_t lg_custom                    : 1;  /**< Reserved. */
 	uint64_t fulc_en                      : 1;  /**< Enable Fulcrum tag parsing.
                                                          0 = Any Fulcrum header is ignored.
-                                                         1 = Fulcrum header is parsed. PKI_GBL_PEN[FULC_PEN] must be set.
-                                                         At most one of FULC_EN, DSA_EN or HG_EN may be set. */
-	uint64_t dsa_en                       : 1;  /**< Enable DSA parsing. This field should not be set for DPI ports.
+                                                         1 = Fulcrum header is parsed.
+                                                         [FULC_EN] must be clear when any of [HG_EN,HG2_EN,DSA_EN] are set. */
+	uint64_t dsa_en                       : 1;  /**< Enable DSA parsing.
                                                          0 = Any DSA header is ignored.
-                                                         1 = DSA is parsed. PKI_GBL_PEN[DSA_PEN] must be set.
-                                                         At most one of FULC_EN, DSA_EN or HG_EN may be set. */
-	uint64_t hg2_en                       : 1;  /**< Enable HiGig 2 parsing. This field should not be set for DPI ports.
+                                                         1 = DSA is parsed.
+                                                         [DSA_EN] must be clear when any of [HG_EN,HG2_EN,FULC_EN] are set. */
+	uint64_t hg2_en                       : 1;  /**< Enable HiGig 2 parsing.
                                                          0 = Any HiGig2 header is ignored.
-                                                         1 = HiGig2 is parsed. PKI_GBL_PEN[HG_PEN] must be set. */
-	uint64_t hg_en                        : 1;  /**< Enable HiGig parsing. This field should not be set for DPI ports.
+                                                         1 = HiGig2 is parsed.
+                                                         [HG2_EN] must be clear when any of [HG_EN,FULC_EN,DSA_EN] is set. */
+	uint64_t hg_en                        : 1;  /**< Enable HiGig parsing.
                                                          0 = Any HiGig header is ignored.
-                                                         1 = HiGig is parsed. PKI_GBL_PEN[HG_PEN] must be set.
-                                                         At most one of FULC_EN, DSA_EN or HG_EN may be set. */
+                                                         1 = HiGig is parsed.
+                                                         [HG_EN] must be clear when any of [HG2_EN,FULC_EN,DSA_EN] is set. */
 #else
 	uint64_t hg_en                        : 1;
 	uint64_t hg2_en                       : 1;
@@ -2271,7 +2271,10 @@ union cvmx_pki_clx_stylex_alg {
                                                          else Reserved. */
 	uint64_t reserved_11_16               : 6;
 	uint64_t tag_vni                      : 1;  /**< When NVGRE/VXLAN/GENEVE is found, include VNI in tag generation. When NVGRE is found, include TNI. */
-	uint64_t tag_gtp                      : 1;  /**< When GTP is parsed, include GTP's TEID in tag generation. */
+	uint64_t tag_gtp                      : 1;  /**< When GTP is parsed, include GTP's TEID in tag generation.
+                                                         The GTP PKI_PCAM_TERM_E::L4_PORT PCAM entry must have
+                                                         PKI_CL()_PCAM()_ACTION()[SETTY,ADVANCE]
+                                                         be PKI_LTYPE_E::GTP,8 (ADVANCE needs to skip over the UDP header). */
 	uint64_t tag_spi                      : 1;  /**< Include AH/ESP/GRE in tag generation.
                                                          0 = Exclude AH/ESP/GRE in tag generation.
                                                          1 = If IP SEC is parsed, include AH/ESP SPI field in tag generation, or if GRE
@@ -3106,11 +3109,13 @@ union cvmx_pki_gbl_pen {
 	uint64_t virt_pen                     : 1;  /**< Virtualization parsing enable.
                                                          0 = VXLAN/NVGRE/GENEVE is never used in any style. This enables internal power
                                                          and latency reductions.
-                                                         1 = VXLAN/NVGRE/GENEVE parsing may be used. */
+                                                         1 = VXLAN/NVGRE/GENEVE parsing may be used.
+                                                         See [L3_PEN] for supported [L3_PEN,VIRT_PEN,IL3_PEN,L4_PEN,CLG_PEN] combinations. */
 	uint64_t clg_pen                      : 1;  /**< Custom LG parsing enable.
                                                          0 = Custom LG is never used in any style; i.e. PKI_CL()_PKIND()_CFG[LG_CUSTOM_LAYER]
                                                          is zero for all indices. This enables internal power and latency reductions.
-                                                         1 = Custom LG parsing may be used. */
+                                                         1 = Custom LG parsing may be used.
+                                                         See [L3_PEN] for supported [L3_PEN,VIRT_PEN,IL3_PEN,L4_PEN,CLG_PEN] combinations. */
 	uint64_t cl2_pen                      : 1;  /**< Custom L2 parsing enable.
                                                          0 = Custom L2 is never used in any style; i.e. PKI_CL()_PKIND()_L2_CUSTOM[VALID]
                                                          is zero for all indices. This enables internal power and latency reductions.
@@ -3118,15 +3123,25 @@ union cvmx_pki_gbl_pen {
 	uint64_t l4_pen                       : 1;  /**< L4 parsing enable.
                                                          0 = L4 parsing is never used in any style. This enables internal power and latency
                                                          reductions.
-                                                         1 = L4 parsing may be used. */
+                                                         1 = L4 parsing may be used.
+                                                         See [L3_PEN] for supported [L3_PEN,VIRT_PEN,IL3_PEN,L4_PEN,CLG_PEN] combinations. */
 	uint64_t il3_pen                      : 1;  /**< L3 inner parsing enable. Must be zero if L3_PEN is zero.
                                                          0 = L3 inner parsing is never used in any style. This enables internal power and latency
                                                          reductions.
-                                                         1 = L3 inner (IP-in-IP) parsing may be used. */
+                                                         1 = L3 inner (IP-in-IP) parsing may be used.
+                                                         See [L3_PEN] for supported [L3_PEN,VIRT_PEN,IL3_PEN,L4_PEN,CLG_PEN] combinations. */
 	uint64_t l3_pen                       : 1;  /**< L3 parsing enable.
                                                          0 = L3 parsing is never used in any style. This enables internal power and latency
                                                          reductions.
-                                                         1 = L3 parsing may be used. */
+                                                         1 = L3 parsing may be used.
+                                                         The supported [L3_PEN,VIRT_PEN,IL3_PEN,L4_PEN,CLG_PEN] combinations are:
+                                                         <pre>
+                                                         L3_PEN VIRT_PEN IL3_PEN L4_PEN CLG_PEN
+                                                         --------------------------------------
+                                                           1       1        1      1       1
+                                                           0       0        0      0       1
+                                                           0       0        0      0       0
+                                                         </pre> */
 	uint64_t mpls_pen                     : 1;  /**< MPLS parsing enable.
                                                          0 = MPLS parsing is never used in any style; i.e. PKI_CL()_PKIND()_CFG[MPLS_EN]
                                                          is zero for all indices. This enables internal power and latency reductions.
diff --git a/arch/mips/include/asm/octeon/cvmx-pki.h b/arch/mips/include/asm/octeon/cvmx-pki.h
index effa997..ac4add4 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki.h
@@ -369,12 +369,12 @@ struct cvmx_pki_style_parm {
 		0x2 = WORD0..6
 		0x3 = WORD0..7
 		else = Reserved */
-	uint8_t wqe_skip; /**< in bytes, WQE start offset.
-		The number of 128-byte cache lines to skip between the buffer
+	uint16_t wqe_skip; /**< in bytes, WQE start offset.
+		The number of bytes to skip between the buffer
 		Pointer and WORD0 of the work-queue entry.*/
-	uint8_t first_skip; /**< The number of eight-byte words from the top
+	uint16_t first_skip; /**< in bytes, The number of bytes from the top
 		of the first MBUF, that the PKI stores the next pointer.*/
-	uint8_t later_skip; /**< The number of eight-byte words from the top
+	uint16_t later_skip; /**< in bytes, The number of bytes from the top
 		of any MBUF, that is not the first MBUF that PKI writes
 		next-pointer to.*/
 	enum cvmx_pki_cache_mode cache_mode; /**< Select the style of write to the L2C.
@@ -391,7 +391,7 @@ struct cvmx_pki_style_parm {
 		by packet data, in the same buffer as the work queue entry.
 		1 = The packet link pointer will be at word [FIRST_SKIP] in a new buffer
 		separate from the work queue entry.*/
-	uint64_t mbuff_size; /**< The number of eight-byte words to store into a buffer.
+	uint64_t mbuff_size; /**< in bytes, The number of bytes to store into a buffer.
 		This must be even, in the range of 32 to 4096 and this must be
 		less than or equal to the maximum size of every free page in every FPA pool
 		this style may use. */
diff --git a/arch/mips/include/asm/octeon/cvmx-pow.h b/arch/mips/include/asm/octeon/cvmx-pow.h
index bc443bd..76ca9d9 100644
--- a/arch/mips/include/asm/octeon/cvmx-pow.h
+++ b/arch/mips/include/asm/octeon/cvmx-pow.h
@@ -3076,6 +3076,12 @@ static inline void *cvmx_sso_work_request_grp_sync(unsigned int lgrp,
  * or to accept work in accordance to just one of the two mask sets.
  * The 'core_num' argument represents a processor core on any node
  * in a coherent multi-chip system.
+ *
+ * If the 'mask_set' argument is 3, both mask sets are configured
+ * with the same value (which is not typically the intention),
+ * so keep in mind the function needs to be called twice
+ * to set a different value into each of the mask sets,
+ * once with 'mask_set=1' and second time with 'mask_set=2'.
  */
 static inline void cvmx_pow_set_xgrp_mask( uint64_t core_num,
 		uint8_t mask_set, const uint64_t xgrp_mask[])
@@ -3089,21 +3095,28 @@ static inline void cvmx_pow_set_xgrp_mask( uint64_t core_num,
 			__FUNCTION__);
 		return;
 	}
+
+	if (CVMX_ENABLE_POW_CHECKS) {
+		cvmx_warn_if(mask_set < 1 || mask_set > 3, "Invalid mask set");
+	}
+
 	node = cvmx_coremask_core_to_node(core_num);
 	core = cvmx_coremask_core_on_node(core_num);
 
 	for (grp = 0; grp < (cvmx_sso_num_xgrp() >> 6); grp++) {
 		reg_addr = CVMX_SSO_PPX_SX_GRPMSKX(core, 0, grp),
 		grp_msk.u64 = 0;
-		if (mask_set & 1)
+		if (mask_set & 1) {
 			grp_msk.s.grp_msk = xgrp_mask[grp];
-		cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
+			cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
+		}
 
 		reg_addr = CVMX_SSO_PPX_SX_GRPMSKX(core, 1, grp),
 		grp_msk.u64 = 0;
-		if (mask_set & 2)
+		if (mask_set & 2) {
 			grp_msk.s.grp_msk = xgrp_mask[grp];
-		cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
+			cvmx_write_csr_node(node, reg_addr, grp_msk.u64);
+		}
 	}
 }
 
diff --git a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
index 5fcbf28..9df8bdb 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
@@ -5890,7 +5890,7 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          the largest RAM. */
 	uint64_t ref_clk_sel                  : 2;  /**< Reference clock select. Choose reference-clock source for the SuperSpeed and high-speed
                                                          PLL blocks.
-                                                         0x0 = Reference clock source for both PLLs come from the USB pads.
+                                                         0x0 = Reference clock sources for both PLLs come from the USB pads.
                                                          0x1 = Reserved.
                                                          0x2 = Reserved.
                                                          0x3 = Reserved.
diff --git a/arch/mips/include/asm/octeon/octeon-feature.h b/arch/mips/include/asm/octeon/octeon-feature.h
index 794ee3e..e887822 100644
--- a/arch/mips/include/asm/octeon/octeon-feature.h
+++ b/arch/mips/include/asm/octeon/octeon-feature.h
@@ -526,7 +526,9 @@ static inline int octeon_has_feature_OCTEON_FEATURE_BGX_XCV(void)
 
 static inline int octeon_has_feature_OCTEON_FEATURE_TSO(void)
 {
-	return OCTEON_IS_MODEL(OCTEON_CN73XX);
+	return (OCTEON_IS_MODEL(OCTEON_CN73XX)
+		|| OCTEON_IS_MODEL(OCTEON_CNF75XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN78XX_PASS2_X));
 }
 
 static inline int octeon_has_feature_OCTEON_FEATURE_TDM(void)
-- 
1.7.5.4

