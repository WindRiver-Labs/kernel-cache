From b96e79e4a57cb736e4c1d2a04520c5e5236fc5aa Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Thu, 12 Sep 2013 10:29:21 -0700
Subject: [PATCH 300/974] MIPS: OCTEON: Sync up SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../cavium-octeon/executive/cvmx-debug-handler.S   |  25 ++-
 arch/mips/cavium-octeon/executive/cvmx-debug.c     | 114 ++++++------
 .../mips/cavium-octeon/executive/cvmx-helper-npi.c |   3 +-
 .../cavium-octeon/executive/cvmx-helper-util.c     |  49 ++---
 .../cavium-octeon/executive/cvmx-helper-xaui.c     |   4 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |  66 +++++--
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |  63 ++++++-
 arch/mips/include/asm/octeon/cvmx-agl-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-app-init.h       |   4 +-
 arch/mips/include/asm/octeon/cvmx-ase-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-asxx-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-bch-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      |  21 +--
 arch/mips/include/asm/octeon/cvmx-ciu-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-ciu2-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-ciu3-defs.h      |  42 ++++-
 arch/mips/include/asm/octeon/cvmx-coremask.h       |  26 ++-
 arch/mips/include/asm/octeon/cvmx-dbg-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-debug.h          |   9 +-
 arch/mips/include/asm/octeon/cvmx-dpi-defs.h       |  31 +++-
 arch/mips/include/asm/octeon/cvmx-fpa-defs.h       |   6 +-
 arch/mips/include/asm/octeon/cvmx-gmxx-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-gpio-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     |   2 +-
 arch/mips/include/asm/octeon/cvmx-hna-defs.h       | 198 +++++++--------------
 arch/mips/include/asm/octeon/cvmx-ila-defs.h       |   4 +-
 arch/mips/include/asm/octeon/cvmx-ilk-defs.h       |  11 +-
 arch/mips/include/asm/octeon/cvmx-iob-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-iobn-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-iobp-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-ipd-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-l2c-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-l2d-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-l2t-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-lapx-defs.h      |  10 +-
 arch/mips/include/asm/octeon/cvmx-lbk-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-led-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h      | 112 ++++++++----
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       |  43 +++--
 arch/mips/include/asm/octeon/cvmx-mixx-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-mpi-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-ndf-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-npei-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-npi-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-oclax-defs.h     |   2 +-
 arch/mips/include/asm/octeon/cvmx-ocx-defs.h       |  55 ++++--
 arch/mips/include/asm/octeon/cvmx-osm-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-pci-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-pcie.h           |  13 +-
 arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h |   2 +-
 arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h   |   2 +-
 arch/mips/include/asm/octeon/cvmx-pciercx-defs.h   |   2 +-
 arch/mips/include/asm/octeon/cvmx-pcsx-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h     |   2 +-
 arch/mips/include/asm/octeon/cvmx-pemx-defs.h      | 172 ++++++------------
 arch/mips/include/asm/octeon/cvmx-pescx-defs.h     |   2 +-
 arch/mips/include/asm/octeon/cvmx-pexp-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-pip-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-pko-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-pow-defs.h       | 117 +++++-------
 arch/mips/include/asm/octeon/cvmx-qlm.h            |  25 ++-
 arch/mips/include/asm/octeon/cvmx-rnm-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |   7 +-
 arch/mips/include/asm/octeon/cvmx-sli-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-smix-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-spxx-defs.h      |   2 +-
 .../mips/include/asm/octeon/cvmx-sriomaintx-defs.h |   2 +-
 arch/mips/include/asm/octeon/cvmx-sriox-defs.h     |   2 +-
 arch/mips/include/asm/octeon/cvmx-srxx-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-sso-defs.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-stxx-defs.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-uctlx-defs.h     |   2 +-
 arch/mips/include/asm/octeon/cvmx-usbcx-defs.h     |   2 +-
 arch/mips/include/asm/octeon/cvmx-usbnx-defs.h     |   2 +-
 arch/mips/include/asm/octeon/octeon-model.h        |   3 +-
 76 files changed, 723 insertions(+), 608 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-debug-handler.S b/arch/mips/cavium-octeon/executive/cvmx-debug-handler.S
index e67164d..c6bf91d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-debug-handler.S
+++ b/arch/mips/cavium-octeon/executive/cvmx-debug-handler.S
@@ -144,7 +144,7 @@ __cvmx_debug_handler_stage2:
 	// Use reserved space in kseg0 to save off some temp regs
         mfc0    k0, $15, 1  // read exception base reg.
         andi    k0, 0xff    // mask off core ID
-        sll     k0, 12      // multiply by 4096 (512 dwords) DEBUG_NUMREGS
+        sll     k0, 4      // multiply by 16 (2 dwords) DEBUG_NUMREGS
 
         addiu   k0,  REG_SAVE_BASE_DIV_8
         addiu   k0,  REG_SAVE_BASE_DIV_8
@@ -162,8 +162,8 @@ __cvmx_debug_handler_stage2:
 
 	// save off k1 and at ($1) off to the bootloader reg save area
 	// at is used by dla
-	sd      $1, 8(k0)	// save at for temp usage
-	sd      k1, 216(k0)	// save k1 for temp usage
+	sd      $1, 0(k0)	// save at for temp usage
+	sd      k1, 8(k0)	// save k1 for temp usage
 
 
 	// Detect debug-mode exception.
@@ -204,8 +204,8 @@ __cvmx_debug_handler_stage2:
 	nop
 
 	// Restore k1 and at from the bootloader reg save area
-	ld      $1, 8(k0)	// save at for temp usage
-	ld      k1, 216(k0)	// save k1 for temp usage
+	ld      $1, 0(k0)	// save at for temp usage
+	ld      k1, 8(k0)	// save k1 for temp usage
 
 	dmfc0	k0, COP0_DEPC
 	// Skip the faulting instruction.
@@ -218,7 +218,7 @@ noexc:
 	loadaddr (k1, __cvmx_debug_save_regs_area, 8)
 
 	// Restore at
-	ld      $1, 8(k0)	// restore at for temp usage
+	ld      $1, 0(k0)	// restore at for temp usage
 
 	.irp	n, REGS0
 	sd	$\n, 0(k1)
@@ -226,7 +226,7 @@ noexc:
 	.endr
 
 	move	$25, k1
-	ld      k1, 216(k0)	// restore k1 for temp usage
+	ld      k1, 8(k0)	// restore k1 for temp usage
 	move	k0, $25
 
 	// Store out k0, we can use $25 here because we just saved it
@@ -239,6 +239,11 @@ noexc:
 	addiu	k0, 8
 	.endr
 	
+	dla k1, __cvmx_debug_has_wide_mult
+	lw k1, 0(k1)
+	blez k1, cvmx_mpy_save_finish
+	nop
+
 	dla k1, __cvmx_debug_is_octeon3
 	lw k1, 0(k1)
 	blez k1, not_oct3_save
@@ -291,6 +296,7 @@ not_oct3_save:
 	sd $2, 32(k1)
 	sd $3, 40(k1)
 cvmx_mpy_save_finish:
+
 	//Save fp registers in OCTEON3
 	dmfc0 k0, COP0_CONFIG1
 	bbit0 k0,0, fpu_nonexist
@@ -368,6 +374,11 @@ fpu_nonexist:
 	.set pop
 fpu_nonexist_restore:
 
+	dla k1, __cvmx_debug_has_wide_mult
+	lw k1, 0(k1)
+	blez k1, cvmx_mpy_restore_finish
+	nop
+
 	dla k1, __cvmx_debug_is_octeon3
 	lw k1, 0(k1)
 	blez k1, not_oct3_restore
diff --git a/arch/mips/cavium-octeon/executive/cvmx-debug.c b/arch/mips/cavium-octeon/executive/cvmx-debug.c
index c17d025..8b8b1f8 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-debug.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-debug.c
@@ -143,8 +143,10 @@ char *__cvmx_debug_stack_top_all[CVMX_MAX_CORES];
 #define cvmx_interrupt_in_isr 0
 
 #endif
-/* This variable is used in assembly to determine if the target is Octeon3 or not */
+/* This variable is used in the assembly to determine if the target is Octeon3 or not. */
 uint32_t __cvmx_debug_is_octeon3;
+/* This variable is used in the assembly to determine if the core has wide multiply or not. */
+uint32_t __cvmx_debug_has_wide_mult;
 
 static size_t cvmx_debug_strlen(const char *str)
 {
@@ -319,13 +321,20 @@ void cvmx_debug_init(void)
 	if (!cvmx_debug_enabled())
 		return;
 
-	/*Set this flag so that it can be checked in assembly while saving wide multiply registers*/
-	__cvmx_debug_is_octeon3=OCTEON_IS_OCTEON3();
+	/* Set this flag so that it can be checked in assembly while saving wide multiply registers. */
+	__cvmx_debug_is_octeon3 = OCTEON_IS_OCTEON3();
+	{
+		uint64_t t;
+		CVMX_MF_CVM_CTL(t);
+		/* Wide mult is enabled when CvmCtl[NOMUL] is cleared. */
+		__cvmx_debug_has_wide_mult = !(t & (1ull << 27));
+	}
 
 	cvmx_debug_init_globals();
 
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
-	// Put a barrier until all cores have got to this point.
+	/* Put a barrier until all cores have got to this point.
+	   Except the linux kernel as it is only called once.  */
 	cvmx_coremask_barrier_sync(pcm);
 #endif
 	cvmx_debug_globals_check_version();
@@ -335,7 +344,7 @@ void cvmx_debug_init(void)
 
 	core = cvmx_get_core_num();
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	/*  Install the debugger handler on the cores. */
+	/*  Install the debugger handler on all of the cores. */
 	{
 		int core1 = 0;
 		cvmx_coremask_for_each_core(core1, pcm) {
@@ -353,21 +362,23 @@ void cvmx_debug_init(void)
 		cvmx_spinlock_lock(lock);
 		state = cvmx_debug_get_state();
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+		/* The Linux kernel only calls this once for the init core,
+		   setup the known cores to be all of the cores that Linux knows about. */
 		{
-		uint64_t coremask = cvmx_coremask_get64(pcm);
-		state.known_cores |= coremask;
-		state.core_finished &= ~coremask;
+			uint64_t coremask = cvmx_coremask_get64(pcm);
+			state.known_cores |= coremask;
+			state.core_finished &= ~coremask;
 		}
 #else
-		state.known_cores |= (1u << core);
-		state.core_finished &= ~(1u << core);
+		state.known_cores |= (1ull << core);
+		state.core_finished &= ~(1ull << core);
 #endif
 		cvmx_debug_update_state(state);
 		cvmx_spinlock_unlock(lock);
 	}
 
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
-	// Put a barrier until all cores have got to this point.
+	/* Put a barrier until all cores have got to this point. */
 	cvmx_coremask_barrier_sync(pcm);
 
 	if (cvmx_is_init_core())
@@ -384,8 +395,8 @@ void cvmx_debug_init(void)
 		cvmx_debug_printf("Known cores at init: 0x%llx\n", (long long)state.known_cores);
 		cvmx_debug_update_state(state);
 
-		/* Initialize __cvmx_debug_stack_top_all. */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+		/* Initialize __cvmx_debug_stack_top_all for Linux kernel, all cores share the same address space. */
 		{
 			int i;
 			for (i = 0; i < CVMX_MAX_CORES; i++)
@@ -487,7 +498,7 @@ static int cvmx_debug_putpacket_hexint(char *buf, uint64_t value)
 
 static int cvmx_debug_active_core(cvmx_debug_state_t state, unsigned core)
 {
-	return state.active_cores & (1u << core);
+	return state.active_cores & (1ull << core);
 }
 
 static volatile cvmx_debug_core_context_t *cvmx_debug_core_context(void)
@@ -500,7 +511,7 @@ static volatile uint64_t *cvmx_debug_regnum_to_context_ref(int regnum, volatile
 	/* Must be kept in sync with mips_octeon_reg_names in gdb/mips-tdep.c. */
 	if (regnum < 32)
 		return &context->regs[regnum];
-/* Return fp registers in OCTEON3 */
+	/* Return fp registers for Octeon 3*/
 	if(37 < regnum && regnum < 70)
 		return &context->fp_regs[regnum-38];
 
@@ -531,23 +542,21 @@ static int cvmx_debug_probe_load(unsigned char *ptr, unsigned char *result)
 	volatile unsigned char *p = ptr;
 	int ok;
 	unsigned char tem;
+	__cvmx_debug_mode_exception_ignore = 1;
+	__cvmx_debug_mode_exception_occured = 0;
+	/* Force a byte load so that it will not be in a delay slot */
+	asm volatile (".set push	\n\t"
+		      ".set noreorder	\n\t"
+		      "nop		\n\t"
+		      "lbu %0, %1	\n\t"
+		      "nop		\n\t"
+		      ".set pop"
+		      : "=r" (tem) : "m"(*p));
+	ok = __cvmx_debug_mode_exception_occured == 0;
+	__cvmx_debug_mode_exception_ignore = 0;
+	__cvmx_debug_mode_exception_occured = 0;
+	*result = tem;
 
-	{
-		__cvmx_debug_mode_exception_ignore = 1;
-		__cvmx_debug_mode_exception_occured = 0;
-		/* We don't handle debug-mode exceptions in delay slots.  Avoid them.  */
-		asm volatile (".set push	\n\t"
-			      ".set noreorder	\n\t"
-			      "nop		\n\t"
-			      "lbu %0, %1	\n\t"
-			      "nop		\n\t"
-			      ".set pop"
-			      : "=r" (tem) : "m"(*p));
-		ok = __cvmx_debug_mode_exception_occured == 0;
-		__cvmx_debug_mode_exception_ignore = 0;
-		__cvmx_debug_mode_exception_occured = 0;
-		*result = tem;
-	}
 	return ok;
 }
 
@@ -558,7 +567,7 @@ static int cvmx_debug_probe_store(unsigned char *ptr)
 
 	__cvmx_debug_mode_exception_ignore = 1;
 	__cvmx_debug_mode_exception_occured = 0;
-	/* We don't handle debug-mode exceptions in delay slots.  Avoid them.  */
+	/* Force a byte store so that it will not be in a delay slot */
 	asm volatile (".set push	\n\t"
 		      ".set noreorder	\n\t"
 		      "nop		\n\t"
@@ -663,7 +672,7 @@ static cvmx_debug_command_t cvmx_debug_process_packet(const char *packet)
 			/* Only cores in the exception handler may become the focus.
 			   If a core not in the exception handler got focus the
 			   debugger would hang since nobody would talk to it.  */
-			else if (state.handler_cores & (1u << core)) {
+			else if (state.handler_cores & (1ull << core)) {
 				/* Focus change reply must be sent before the focus
 				   changes. Otherwise the new focus core will eat our ACK
 				   from the debugger.  */
@@ -709,9 +718,9 @@ static cvmx_debug_command_t cvmx_debug_process_packet(const char *packet)
 				state.active_cores = state.known_cores;
 
 			/* The focus core must be in the active_cores mask */
-			if ((state.active_cores & (1u << state.focus_core)) == 0) {
+			if ((state.active_cores & (1ull << state.focus_core)) == 0) {
 				cvmx_debug_putpacket_noformat("!Focus core was added to the masked.");
-				state.active_cores |= 1u << state.focus_core;
+				state.active_cores |= 1ull << state.focus_core;
 			}
 
 			cvmx_debug_update_state(state);
@@ -1063,7 +1072,7 @@ static int cvmx_debug_stop_core(cvmx_debug_state_t state, unsigned core, cvmx_de
 		cvmx_debug_printf("Core #%d not in active cores, continuing.\n", core);
 		return 0;
 	}
-	if ((state.core_finished & (1u << core)) && proxy)
+	if ((state.core_finished & (1ull << core)) && proxy)
 		return 0;
 	return 1;
 }
@@ -1088,7 +1097,7 @@ static void cvmx_debug_set_focus_core(cvmx_debug_state_t * state, int core)
 static void cvmx_debug_may_elect_as_focus_core(cvmx_debug_state_t * state, int core, cvmx_debug_register_t * debug_reg)
 {
 	/* If another core has already elected itself as the focus core, we're late.  */
-	if (state->handler_cores & (1u << state->focus_core))
+	if (state->handler_cores & (1ull << state->focus_core))
 		return;
 
 	/* If we hit a breakpoint, elect ourselves.  */
@@ -1098,7 +1107,7 @@ static void cvmx_debug_may_elect_as_focus_core(cvmx_debug_state_t * state, int c
 	/* It is possible the focus core has completed processing and exited the
 	   program. When this happens the focus core will not be in
 	   known_cores. If this is the case we need to elect a new focus. */
-	if ((state->known_cores & (1u << state->focus_core)) == 0)
+	if ((state->known_cores & (1ull << state->focus_core)) == 0)
 		cvmx_debug_set_focus_core(state, core);
 }
 
@@ -1234,10 +1243,10 @@ static int cvmx_debug_event_loop(cvmx_debug_register_t * debug_reg, volatile cvm
 		cvmx_spinlock_lock(&cvmx_debug_globals->lock);
 		state = cvmx_debug_get_state();
 
-		state.handler_cores |= (1u << core);
+		state.handler_cores |= (1ull << core);
 		cvmx_debug_may_elect_as_focus_core(&state, core, debug_reg);
 
-/* Push all updates before exiting the critical section */
+		/* Push all updates before exiting the critical section */
 		state.focus_switch = 1;
 		cvmx_debug_update_state(state);
 		cvmx_spinlock_unlock(&cvmx_debug_globals->lock);
@@ -1256,7 +1265,7 @@ static int cvmx_debug_event_loop(cvmx_debug_register_t * debug_reg, volatile cvm
 
 			/* If the focus has changed and the old focus has exited, then send a signal
 			   that we should stop if step_all is off.  */
-			if (oldfocus != state.focus_core && ((1u << oldfocus) & state.core_finished)
+			if (oldfocus != state.focus_core && ((1ull << oldfocus) & state.core_finished)
 			    && !state.step_all)
 				cvmx_debug_send_stop_reason(debug_reg, context);
 
@@ -1274,7 +1283,7 @@ static int cvmx_debug_event_loop(cvmx_debug_register_t * debug_reg, volatile cvm
 			}
 		} else {
 			volatile int i;
-			/* Do a small sleep just so there is some time to process a focus change. */
+			/* Do a small sleep (around 2000 cycles) just so there is some time to process a focus change. */
 			for (i = 0; i < 240; i++)
 				asm volatile (".set push	\n\t"
 					      ".set noreorder	\n\t"
@@ -1292,7 +1301,7 @@ static int cvmx_debug_event_loop(cvmx_debug_register_t * debug_reg, volatile cvm
 		   we are changing the communications. */
 		if (command == COMMAND_NOP && cvmx_debug_globals->comm_changed) {
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
-			cvmx_coremask_t cm;
+			cvmx_coremask_t cm = CVMX_COREMASK_EMPTY;
 
 			/* FIXME: Debugger is limited at 64 cores */
 			cvmx_coremask_set64(&cm, state.handler_cores);
@@ -1310,7 +1319,7 @@ static int cvmx_debug_event_loop(cvmx_debug_register_t * debug_reg, volatile cvm
 	{
 		cvmx_spinlock_lock(&cvmx_debug_globals->lock);
 		state = cvmx_debug_get_state();
-		state.handler_cores ^= (1u << core);
+		state.handler_cores ^= (1ull << core);
 		cvmx_debug_update_state(state);
 		cvmx_spinlock_unlock(&cvmx_debug_globals->lock);
 	}
@@ -1553,7 +1562,7 @@ void __cvmx_debug_handler_stage3(uint64_t lo, uint64_t hi)
 void cvmx_debug_trigger_exception(void)
 {
 	/* Set CVMX_CIU_DINT to enter debug exception handler.  */
-	cvmx_write_csr(CVMX_CIU_DINT, 1u << cvmx_get_core_num());
+	cvmx_write_csr(CVMX_CIU_DINT, 1ull << cvmx_get_core_num());
 	/* Perform an immediate read after every write to an RSL register to force
 	   the write to complete. It doesn't matter what RSL read we do, so we
 	   choose CVMX_MIO_BOOT_BIST_STAT because it is fast and harmless */
@@ -1570,6 +1579,8 @@ void cvmx_debug_finish(void)
 	unsigned coreid = cvmx_get_core_num();
 	cvmx_debug_state_t state;
 
+	cvmx_coremask_t cm = CVMX_COREMASK_EMPTY;
+
 	if (!cvmx_debug_globals)
 		return;
 	cvmx_debug_printf("Debug _exit reached!, core %d, cvmx_debug_globals = %p\n", coreid, cvmx_debug_globals);
@@ -1581,18 +1592,19 @@ void cvmx_debug_finish(void)
 
 	cvmx_spinlock_lock(&cvmx_debug_globals->lock);
 	state = cvmx_debug_get_state();
-	state.known_cores ^= (1u << coreid);
-	state.core_finished |= (1u << coreid);
+	state.known_cores ^= (1ull << coreid);
+	state.core_finished |= (1ull << coreid);
 	cvmx_debug_update_state(state);
 
 	/* Tell the user the core has finished. */
 	if (state.ever_been_in_debug)
 		cvmx_debug_putcorepacket("finished.", coreid);
 
+	/* FIXME: Debugger is limited at 64 cores */
+	cvmx_coremask_set64(&cm, state.core_finished);
+
 	/* Notify the debugger if all cores have completed the program */
-#if 0
-	/* FIXME: coremask is not done correctly for core_finished. */
-	if (cvmx_coremask_is_subset(cvmx_debug_core_mask(), (&state)->core_finished)) {
+	if (cvmx_coremask_cmp(cvmx_debug_core_mask(), &cm) == 0) {
 		cvmx_debug_printf("All cores done!\n");
 		if (state.ever_been_in_debug)
 			cvmx_debug_putpacket_noformat("D0");
@@ -1603,8 +1615,7 @@ void cvmx_debug_finish(void)
 		   should always find a core */
 		unsigned newcore;
 		for (newcore = 0; newcore < CVMX_MAX_CORES; newcore++) {
-			if (cvmx_coremask_is_core_set(&state.known_cores,
-						      newcore)) {
+			if (state.known_cores & (1ull << newcore)) {
 				cvmx_debug_printf("Routing uart interrupts to Core #%u.\n", newcore);
 				cvmx_debug_set_focus_core(&state, newcore);
 				cvmx_debug_update_state(state);
@@ -1612,7 +1623,6 @@ void cvmx_debug_finish(void)
 			}
 		}
 	}
-#endif
 	cvmx_spinlock_unlock(&cvmx_debug_globals->lock);
 
 	/* If we ever been in the debug, report to it that we have exited the core. */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c b/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
index b5ae333..d26f3d6 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
@@ -43,7 +43,7 @@
  * Functions for NPI initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 87074 $<hr>
+ * <hr>$Revision: 88039 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -81,7 +81,6 @@ int __cvmx_helper_npi_probe(int interface)
 		   OCTEON_IS_MODEL(OCTEON_CN50XX) ||
 		   OCTEON_IS_MODEL(OCTEON_CN30XX))) {
 		/* The packet engines didn't exist before cn56xx pass 2 */
-		if (__cvmx_pko_queue_static_config.non_pknd.pko_queues_per_port_pci > 0)
 			return 4;
 	}
 	return 0;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
index 04957d4..911fe20 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
@@ -109,11 +109,16 @@ typedef enum {
  *	First IPD port number assigned to this interface.
  * @param last_ipd_port
  *	Last IPD port number assigned to this interface.
+ * @param ipd_port_adj
+ *	Different octeon chips require different ipd ports for the 
+ *	same interface port/mode configuration. This value is used
+ *	to account for that difference.
  */
 struct ipd_port_map {
 	port_map_if_type_t	type;
 	int			first_ipd_port;
 	int			last_ipd_port;
+	int			ipd_port_adj;
 };
 
 /**
@@ -121,15 +126,15 @@ struct ipd_port_map {
  * Interface number to ipd port map for the octeon 68xx.
  */
 static const struct ipd_port_map ipd_port_map_68xx[CVMX_HELPER_MAX_IFACE] = {
-	{GMII,	0x800,	0x8ff},		/* Interface 0 */
-	{GMII,	0x900,	0x9ff},		/* Interface 1 */
-	{GMII,	0xa00,	0xaff},		/* Interface 2 */
-	{GMII,	0xb00,	0xbff},		/* Interface 3 */
-	{GMII,	0xc00,	0xcff},		/* Interface 4 */
-	{ILK,	0x400,	0x4ff},		/* Interface 5 */
-	{ILK,	0x500,	0x5ff},		/* Interface 6 */
-	{NPI,	0x100,	0x120},		/* Interface 7 */
-	{LB,	0x000,	0x008},		/* Interface 8 */
+	{GMII,	0x800,	0x8ff,	0x40},		/* Interface 0 */
+	{GMII,	0x900,	0x9ff,	0x40},		/* Interface 1 */
+	{GMII,	0xa00,	0xaff,	0x40},		/* Interface 2 */
+	{GMII,	0xb00,	0xbff,	0x40},		/* Interface 3 */
+	{GMII,	0xc00,	0xcff,	0x40},		/* Interface 4 */
+	{ILK,	0x400,	0x4ff,	0x00},		/* Interface 5 */
+	{ILK,	0x500,	0x5ff,	0x00},		/* Interface 6 */
+	{NPI,	0x100,	0x120,	0x00},		/* Interface 7 */
+	{LB,	0x000,	0x008,	0x00},		/* Interface 8 */
 };
 
 /**
@@ -137,16 +142,16 @@ static const struct ipd_port_map ipd_port_map_68xx[CVMX_HELPER_MAX_IFACE] = {
  * Interface number to ipd port map for the octeon 78xx.
  */
 static const struct ipd_port_map ipd_port_map_78xx[CVMX_HELPER_MAX_IFACE] = {
-	{GMII,	0x800,	0x8ff},		/* Interface 0 */
-	{GMII,	0x900,	0x9ff},		/* Interface 1 */
-	{GMII,	0xa00,	0xaff},		/* Interface 2 */
-	{GMII,	0xb00,	0xbff},		/* Interface 3 */
-	{GMII,	0xc00,	0xcff},		/* Interface 4 */
-	{GMII,	0xd00,	0xdff},		/* Interface 5 */
-	{ILK,	0x400,	0x4ff},		/* Interface 6 */
-	{ILK,	0x500,	0x5ff},		/* Interface 7 */
-	{NPI,	0x100,	0x120},		/* Interface 8 */
-	{LB,	0x000,	0x008},		/* Interface 9 */
+	{GMII,	0x800,	0x8ff,	0x00},		/* Interface 0 */
+	{GMII,	0x900,	0x9ff,	0x00},		/* Interface 1 */
+	{GMII,	0xa00,	0xaff,	0x00},		/* Interface 2 */
+	{GMII,	0xb00,	0xbff,	0x00},		/* Interface 3 */
+	{GMII,	0xc00,	0xcff,	0x00},		/* Interface 4 */
+	{GMII,	0xd00,	0xdff,	0x00},		/* Interface 5 */
+	{ILK,	0x400,	0x4ff,	0x00},		/* Interface 6 */
+	{ILK,	0x500,	0x5ff,	0x00},		/* Interface 7 */
+	{NPI,	0x100,	0x120,	0x00},		/* Interface 8 */
+	{LB,	0x000,	0x008,	0x00},		/* Interface 9 */
 };
 
 struct cvmx_iface {
@@ -698,8 +703,10 @@ int cvmx_helper_get_ipd_port(int interface, int port)
 			cvmx_helper_interface_mode_t mode =
 				cvmx_helper_interface_get_mode(interface);
 			if (mode == CVMX_HELPER_INTERFACE_MODE_XAUI ||
-			    mode == CVMX_HELPER_INTERFACE_MODE_RXAUI)
-				return ipd_port + 0x40;
+			    mode == CVMX_HELPER_INTERFACE_MODE_RXAUI) {
+				ipd_port += port_map[interface].ipd_port_adj;
+				return ipd_port;
+			}
 			else
 				return ipd_port + (port * 16);
 		} else if (port_map[interface].type == ILK)
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c b/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
index cf92f1a..a355e03 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-xaui.c
@@ -43,7 +43,7 @@
  * Functions for XAUI initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 87025 $<hr>
+ * <hr>$Revision: 88172 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -547,7 +547,7 @@ int __cvmx_helper_bgx_xaui_probe(int interface)
 	if (cvmx_qlm_get_mode(qlm) != CVMX_QLM_MODE_XAUI)
 		return 0;
 
-	return __cvmx_helper_sgmii_enumerate(interface);
+	return __cvmx_helper_xaui_enumerate(interface);
 }
 
 /**
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index 0b97e40..b451cf9 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2011  Cavium, Inc. <support@cavium.com>.  All rights
+ * Copyright (c) 2003-2013  Cavium, Inc. <support@cavium.com>.  All rights
  * reserved.
  *
  *
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 87128 $<hr>
+ * <hr>$Revision: 88224 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -58,6 +58,7 @@
 #include <asm/octeon/cvmx-pemx-defs.h>
 #include <asm/octeon/cvmx-pexp-defs.h>
 #include <asm/octeon/cvmx-pescx-defs.h>
+#include <asm/octeon/cvmx-rst-defs.h>
 #include <asm/octeon/cvmx-sli-defs.h>
 #include <asm/octeon/cvmx-sriox-defs.h>
 #include <asm/octeon/cvmx-helper-jtag.h>
@@ -85,6 +86,7 @@
 #include "cvmx-helper-errata.h"
 #include "cvmx-qlm.h"
 #include "cvmx-bootmem.h"
+#include "cvmx-rst-defs.h"
 #include "octeon_mem_map.h"
 #ifdef __U_BOOT__
 # include <libfdt.h>
@@ -473,6 +475,11 @@ static int __cvmx_pcie_rc_initialize_gen1(int pcie_port)
 	cvmx_pciercx_cfg032_t pciercx_cfg032;
 	cvmx_npei_bar1_indexx_t bar1_index;
 
+	if (pcie_port >= CVMX_PCIE_PORTS) {
+		//cvmx_dprintf("Invalid PCIe%d port\n", pcie_port);
+		return -1;
+	}
+
 retry:
 	/* Make sure we aren't trying to setup a target mode interface in host mode */
 	npei_ctl_status.u64 = cvmx_read_csr(CVMX_PEXP_NPEI_CTL_STATUS);
@@ -856,16 +863,21 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 	cvmx_sli_mem_access_ctl_t sli_mem_access_ctl;
 	cvmx_sli_mem_access_subidx_t mem_access_subid;
 	cvmx_pemx_bar1_indexx_t bar1_index;
-	uint64_t ciu_soft_prst_reg;
+	uint64_t ciu_soft_prst_reg, rst_ctl_reg;
 	int ep_mode;
 	int qlm = pcie_port;
 	int connected_pcie_reset = -1;
+	enum cvmx_qlm_mode mode = CVMX_QLM_MODE_DISABLED;
+
+	if (pcie_port >= CVMX_PCIE_PORTS) {
+		//cvmx_dprintf("Invalid PCIe%d port\n", pcie_port);
+		return -1;
+	}
 
 	/* Make sure this interface is PCIe */
 	if (octeon_has_feature(OCTEON_FEATURE_PCIE)) {
 		/* Requires reading the MIO_QLMX_CFG register to figure
 		   out the port type. */
-		enum cvmx_qlm_mode mode;
 		if (OCTEON_IS_MODEL(OCTEON_CN68XX))
 			qlm = 3 - (pcie_port * 2);
 		else if (OCTEON_IS_MODEL(OCTEON_CN61XX)) {
@@ -878,6 +890,8 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		   2 PCIe ports in x1 */
 		else if (OCTEON_IS_MODEL(OCTEON_CNF71XX))
 			qlm = 1;
+		else if (OCTEON_IS_MODEL(OCTEON_CN70XX))
+			qlm = (pcie_port == 0) ? 1 : 2;
 		mode = cvmx_qlm_get_mode(qlm);
 		if (mode == CVMX_QLM_MODE_SRIO_1X4 ||
 		    mode == CVMX_QLM_MODE_SRIO_2X2 ||
@@ -896,7 +910,8 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 			return -1;
 		} else if (mode != CVMX_QLM_MODE_PCIE &&
 			   mode != CVMX_QLM_MODE_PCIE_1X2 &&
-			   mode != CVMX_QLM_MODE_PCIE_2X1) {
+			   mode != CVMX_QLM_MODE_PCIE_2X1 &&
+			   mode != CVMX_QLM_MODE_PCIE_1X1) {
 			cvmx_dprintf("PCIe: Port %d is unknown, skipping.\n", pcie_port);
 			return -1;
 		}
@@ -921,7 +936,16 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 #endif
 
 	/* Make sure we aren't trying to setup a target mode interface in host mode */
-	mio_rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CTLX(pcie_port));
+	if (OCTEON_IS_OCTEON3()) {
+		ciu_soft_prst_reg = CVMX_RST_SOFT_PRSTX(pcie_port);
+		rst_ctl_reg = CVMX_RST_CTLX(pcie_port);
+	} else {
+		ciu_soft_prst_reg = (pcie_port) ?
+				 CVMX_CIU_SOFT_PRST1 : CVMX_CIU_SOFT_PRST;
+		rst_ctl_reg = CVMX_MIO_RST_CTLX(pcie_port);
+	}
+
+	mio_rst_ctl.u64 = cvmx_read_csr(rst_ctl_reg);
 	ep_mode = ((OCTEON_IS_MODEL(OCTEON_CN61XX) ||
 		    OCTEON_IS_MODEL(OCTEON_CNF71XX)) ?
 		(mio_rst_ctl.s.prtmode != 1) : (!mio_rst_ctl.s.host_mode));
@@ -964,9 +988,6 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		}
 	}
 
-	ciu_soft_prst_reg = (pcie_port) ?
-				 CVMX_CIU_SOFT_PRST1 : CVMX_CIU_SOFT_PRST;
-
 	/* On some boards, notably the SFF6100 board, the PCIe reset lines
 	 * are miswired in PCIe 2x1 mode.  In 2x1 mode, the PRST line of
 	 * QLM0 should go to PCIe PEM 0 and the PRST line of QLM1 should
@@ -978,10 +999,10 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 	static void *fdt_addr = 0;
 
-	if (fdt_addr == 0)
+	if (fdt_addr == 0 && mode == CVMX_QLM_MODE_PCIE_2X1)
 		fdt_addr = __cvmx_phys_addr_to_ptr(cvmx_sysinfo_get()->fdt_addr,
 						   OCTEON_FDT_MAX_SIZE);
-	if (fdt_addr) {
+	if (fdt_addr && mode == CVMX_QLM_MODE_PCIE_2X1) {
 		uint32_t *prop;
 		int offset;
 
@@ -995,7 +1016,7 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		}
 	}
 #else
-	{
+	if (mode == CVMX_QLM_MODE_PCIE_2X1) {
 		struct device_node *node = of_find_node_by_path("/soc@0");
 		if (node) {
 			if (of_property_read_u32(node,
@@ -1059,6 +1080,17 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		break;
 	case -1:
 	default:
+		if (OCTEON_IS_OCTEON3()) {
+			union cvmx_pemx_on pemx_on;
+			pemx_on.u64 = cvmx_read_csr(CVMX_PEMX_ON(pcie_port));
+			if (pemx_on.s.pemoor == 0) {
+				/* Reset PCIe PIPE out of reset */
+				pemx_on.s.pemon = 1;
+				cvmx_write_csr(CVMX_PEMX_ON(pcie_port), pemx_on.u64);
+				/* Wait until pcie resets the pipe */
+				cvmx_wait_usec(2000);
+			}
+		}
 		/* Bring the PCIe out of reset */
 		ciu_soft_prst.u64 = cvmx_read_csr(ciu_soft_prst_reg);
 		/* After a chip reset the PCIe will also be in reset. If it
@@ -1083,7 +1115,7 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 	/* Check and make sure PCIe came out of reset. If it doesn't the board
 	   probably hasn't wired the clocks up and the interface should be
 	   skipped */
-	if (CVMX_WAIT_FOR_FIELD64(CVMX_MIO_RST_CTLX(pcie_port), cvmx_mio_rst_ctlx_t, rst_done, ==, 1, 10000)) {
+	if (CVMX_WAIT_FOR_FIELD64(rst_ctl_reg, cvmx_mio_rst_ctlx_t, rst_done, ==, 1, 10000)) {
 		cvmx_dprintf("PCIe: Port %d stuck in reset, skipping.\n", pcie_port);
 		return -1;
 	}
@@ -1486,7 +1518,13 @@ int cvmx_pcie_ep_initialize(int pcie_port)
 	} else {
 		cvmx_mio_rst_ctlx_t mio_rst_ctl;
 		int ep_mode;
-		mio_rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CTLX(pcie_port));
+		uint64_t mio_rst_reg;
+
+		if (OCTEON_IS_OCTEON3())
+			mio_rst_reg = CVMX_RST_CTLX(pcie_port);
+		else
+			mio_rst_reg = CVMX_MIO_RST_CTLX(pcie_port);
+		mio_rst_ctl.u64 = cvmx_read_csr(mio_rst_reg);
 		ep_mode = (OCTEON_IS_MODEL(OCTEON_CN61XX) ? (mio_rst_ctl.s.prtmode != 0) : mio_rst_ctl.s.host_mode);
 		if (ep_mode)
 			return -1;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index 73dfc94..38f9bc6 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 87438 $<hr>
+ * <hr>$Revision: 88225 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -55,6 +55,7 @@
 #include <asm/octeon/cvmx-sriox-defs.h>
 #include <asm/octeon/cvmx-sriomaintx-defs.h>
 #include <asm/octeon/cvmx-pciercx-defs.h>
+#include <asm/octeon/cvmx-pemx-defs.h>
 #else
 #include "cvmx.h"
 #include "cvmx-bootmem.h"
@@ -772,6 +773,64 @@ static enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn70xx(int qlm)
 				return CVMX_QLM_MODE_DISABLED;
 			}
 		}
+	case 1:  /* Sata / pem0 */
+		{
+			union cvmx_gserx_sata_cfg sata_cfg;
+			union cvmx_pemx_cfg pem0_cfg;
+
+			sata_cfg.u64 = cvmx_read_csr(CVMX_GSERX_SATA_CFG(0));
+			pem0_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(0));
+
+			switch(pem0_cfg.cn70xx.md) {
+			case CVMX_PEM_MD_GEN2_2LANE:
+			case CVMX_PEM_MD_GEN1_2LANE:
+				return CVMX_QLM_MODE_PCIE_1X2;
+			case CVMX_PEM_MD_GEN2_1LANE:
+			case CVMX_PEM_MD_GEN1_1LANE:
+				if (sata_cfg.s.sata_en)
+					/* Both PEM0 and PEM1 */
+					return CVMX_QLM_MODE_PCIE_2X1;
+				else
+					/* Only PEM0 */
+					return CVMX_QLM_MODE_PCIE_1X1;
+			case CVMX_PEM_MD_GEN2_4LANE:
+			case CVMX_PEM_MD_GEN1_4LANE:
+				return CVMX_QLM_MODE_PCIE;
+			default:
+				return CVMX_QLM_MODE_DISABLED;
+			}
+		}
+	case 2:
+		{
+			union cvmx_gserx_sata_cfg sata_cfg;
+			union cvmx_pemx_cfg pem0_cfg, pem1_cfg, pem2_cfg;
+
+			sata_cfg.u64 = cvmx_read_csr(CVMX_GSERX_SATA_CFG(0));
+			pem0_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(0));
+			pem1_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(1));
+			pem2_cfg.u64 = cvmx_read_csr(CVMX_PEMX_CFG(2));
+
+			if (sata_cfg.s.sata_en)
+				return CVMX_QLM_MODE_SATA_2X1;
+			if (pem0_cfg.cn70xx.md == CVMX_PEM_MD_GEN2_4LANE
+			    || pem0_cfg.cn70xx.md == CVMX_PEM_MD_GEN1_4LANE)
+				return CVMX_QLM_MODE_PCIE;
+			if (pem1_cfg.cn70xx.md == CVMX_PEM_MD_GEN2_2LANE
+			    || pem1_cfg.cn70xx.md == CVMX_PEM_MD_GEN1_2LANE)
+				return CVMX_QLM_MODE_PCIE_1X2;
+			if (pem1_cfg.cn70xx.md == CVMX_PEM_MD_GEN2_1LANE
+			    || pem1_cfg.cn70xx.md == CVMX_PEM_MD_GEN1_1LANE) {
+				if (pem2_cfg.cn70xx.md == CVMX_PEM_MD_GEN2_1LANE
+				    || pem2_cfg.cn70xx.md == CVMX_PEM_MD_GEN1_1LANE)
+					return CVMX_QLM_MODE_PCIE_2X1;
+				else
+					return CVMX_QLM_MODE_PCIE_1X1;
+			}
+			if (pem2_cfg.cn70xx.md == CVMX_PEM_MD_GEN2_1LANE
+			    || pem2_cfg.cn70xx.md == CVMX_PEM_MD_GEN1_1LANE)
+				return CVMX_QLM_MODE_PCIE_2X1;
+			return CVMX_QLM_MODE_DISABLED;
+		}
 	default:
 		return CVMX_QLM_MODE_DISABLED;
 	}
@@ -813,7 +872,7 @@ enum cvmx_qlm_mode cvmx_qlm_get_dlm_mode(int qlm, int interface)
 			return CVMX_QLM_MODE_DISABLED;
 		}
 	default:
-		return CVMX_QLM_MODE_DISABLED;
+		return qlm_mode;
 	}
 }
 
diff --git a/arch/mips/include/asm/octeon/cvmx-agl-defs.h b/arch/mips/include/asm/octeon/cvmx-agl-defs.h
index 134fdf7..800d4ab 100644
--- a/arch/mips/include/asm/octeon/cvmx-agl-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-agl-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index 20a7435..8ce64d9 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -41,7 +41,7 @@
  * @file
  * Header file for simple executive application initialization.  This defines
  * part of the ABI between the bootloader and the application.
- * <hr>$Revision: 86527 $<hr>
+ * <hr>$Revision: 88074 $<hr>
  *
  */
 
@@ -272,6 +272,7 @@ enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_CNF71XX_REF = 53,
 	CVMX_BOARD_TYPE_MOONSHOT = 54,
 	CVMX_BOARD_TYPE_EVB7000_SFF = 55,
+	CVMX_BOARD_TYPE_EVB7000 = 56,
 	CVMX_BOARD_TYPE_MAX,
 	/* NOTE:  256-257 are being used by a customer. */
 
@@ -395,6 +396,7 @@ static inline const char *cvmx_board_type_to_string(enum cvmx_board_types_enum t
 		    ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CNF71XX_REF)
 		    ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MOONSHOT)
 		    ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EVB7000_SFF)
+		    ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EVB7000)
 		    ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
 
 		    /* Customer boards listed here */
diff --git a/arch/mips/include/asm/octeon/cvmx-ase-defs.h b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
index 3faa665..9d078ae 100644
--- a/arch/mips/include/asm/octeon/cvmx-ase-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-asxx-defs.h b/arch/mips/include/asm/octeon/cvmx-asxx-defs.h
index 29c0de3..56fb582 100644
--- a/arch/mips/include/asm/octeon/cvmx-asxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-asxx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-bch-defs.h b/arch/mips/include/asm/octeon/cvmx-bch-defs.h
index 02ec72a..858a066 100644
--- a/arch/mips/include/asm/octeon/cvmx-bch-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bch-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index c4f17e6..7f8fc30 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -1981,7 +1981,7 @@ union cvmx_bgxx_cmrx_config {
                                                          NUM_PCS_LANES specifies the number of of PCS lanes that are valid for
                                                          each type. Each valid PCS lane is mapped to a physical serdes lane
                                                          based on the programming of [LANE_TO_SDS]. */
-	uint64_t lane_to_sds                  : 8;  /**< "PCS Lane to Serdes Mapping
+	uint64_t lane_to_sds                  : 8;  /**< PCS Lane to Serdes Mapping.
                                                          This is an array of 2-bit values that map each logical PCS Lane to a
                                                          physical serdes lane, as follows:
                                                            ----------+----------------------------------------------------------
@@ -2007,9 +2007,7 @@ union cvmx_bgxx_cmrx_config {
                                                          alignment marker lock on the receive side (i.e. the associated
                                                          MARKER_LOCK bit is set in BR_ALGN_STATUS), then the actual detected
                                                          RX PCS lane number is recorded in the corresponding LNx_MAPPING
-                                                         field in BR_LANE_MAP.
-                                                         For SGMII, the lane serdes assignments are hardcoded. LMAC 0 will
-                                                         always use lane 0 and is connected to sds 0. Same for LMAC 1, 2, 3." */
+                                                         field in BR_LANE_MAP. */
 #else
 	uint64_t lane_to_sds                  : 8;
 	uint64_t lmac_type                    : 3;
@@ -2111,7 +2109,7 @@ union cvmx_bgxx_cmrx_rx_bp_drop {
 	struct cvmx_bgxx_cmrx_rx_bp_drop_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
-	uint64_t mark                         : 7;  /**< Number of eight-byte cycles to reserve in the RX FIFO. When When the number of free
+	uint64_t mark                         : 7;  /**< Number of eight-byte cycles to reserve in the RX FIFO. When the number of free
                                                          entries in the RX FIFO is less than or equal to MARK, incoming packet data is
                                                          dropped. Mark additionally indicates the number of entries to reserve in the RX FIFO for
                                                          closing partially received packets. MARK should typically be programmed to its reset
@@ -2133,7 +2131,8 @@ union cvmx_bgxx_cmrx_rx_bp_off {
 	struct cvmx_bgxx_cmrx_rx_bp_off_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
-	uint64_t mark                         : 7;  /**< Low watermark (number of eight-byte cycles to deassert backpressure). */
+	uint64_t mark                         : 7;  /**< Low watermark (number of eight-byte cycles to deassert backpressure). Level is also used
+                                                         to exit the overflow dropping state. */
 #else
 	uint64_t mark                         : 7;
 	uint64_t reserved_7_63                : 57;
@@ -5013,9 +5012,11 @@ union cvmx_bgxx_smux_hg2_control {
 	uint64_t hg2tx_en                     : 1;  /**< Enable transmission of HG2 physical and logical messages. When set, also disables hardware
                                                          autogenerated (802.3 and PFC/CBFC) PAUSE frames. (CN78XX cannot generate proper 802.3 or
                                                          PFC/CBFC PAUSE frames in HiGig2 mode.) */
-	uint64_t hg2rx_en                     : 1;  /**< Enable extraction and processing of HG2 message packet from RX flow. Physical logical
+	uint64_t hg2rx_en                     : 1;  /**< Enable extraction and processing of HG2 message packet from RX flow. Physical and logical
                                                          PAUSE information is used to PAUSE physical-link, backpressure PKO. This field must be set
-                                                         when HiGig2 messages are present in the receive stream. */
+                                                         when HiGig2 messages are present in the receive stream. This bit is also forwarded to CMR
+                                                         so it can generate the required deferring signals to SMU TX and backpressure signals to
+                                                         PKO. */
 	uint64_t phys_en                      : 1;  /**< 1 bit physical link pause enable for recevied
                                                          HiGig2 physical pause message. This bit enables the SMU TX
                                                          to CMR HG2 deferring counter to be set every time SMU RX
@@ -5023,7 +5024,7 @@ union cvmx_bgxx_smux_hg2_control {
 	uint64_t logl_en                      : 16; /**< 16 bit xof enables for recevied HiGig2 messages
                                                          or PFC/CBFC packets. This field is NOT used by SMU at all.
                                                          It is forwarded to CMR without alteration. It appears here
-                                                         for backward compatibility tieh O68. */
+                                                         for backward compatibility with O68. */
 #else
 	uint64_t logl_en                      : 16;
 	uint64_t phys_en                      : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
index adf01d3..73f35f3 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu2-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu2-defs.h
index d9eb776..eca97c0 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu2-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu2-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
index 6013fea..9fa5b4b 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -317,6 +317,17 @@ static inline uint64_t CVMX_CIU3_PP_RST_FUNC(void)
 #define CVMX_CIU3_PP_RST (CVMX_ADD_IO_SEG(0x0001010000000100ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_CIU3_PP_RST_PENDING CVMX_CIU3_PP_RST_PENDING_FUNC()
+static inline uint64_t CVMX_CIU3_PP_RST_PENDING_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_CIU3_PP_RST_PENDING not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001010000000108ull);
+}
+#else
+#define CVMX_CIU3_PP_RST_PENDING (CVMX_ADD_IO_SEG(0x0001010000000108ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_CIU3_SISCX(unsigned long offset)
 {
 	if (!(
@@ -923,8 +934,9 @@ typedef union cvmx_ciu3_pp_pokex cvmx_ciu3_pp_pokex_t;
  * cvmx_ciu3_pp_rst
  *
  * This register contains the reset control for each core. A 1 holds a core in reset, 0 release
- * from reset. It resets to all ones when REMOTE_BOOT is enabled, all ones excluding bit 0 clear
- * otherwise.
+ * from reset. It resets to all ones when REMOTE_BOOT is enabled or all ones excluding bit 0 when
+ * REMOTE_BOOT is disabled. Writes to this register should occur only if the CIU3_PP_RST_PENDING
+ * register is cleared.
  */
 union cvmx_ciu3_pp_rst {
 	uint64_t u64;
@@ -945,6 +957,30 @@ union cvmx_ciu3_pp_rst {
 typedef union cvmx_ciu3_pp_rst cvmx_ciu3_pp_rst_t;
 
 /**
+ * cvmx_ciu3_pp_rst_pending
+ *
+ * This register contains the reset status for each core.
+ *
+ */
+union cvmx_ciu3_pp_rst_pending {
+	uint64_t u64;
+	struct cvmx_ciu3_pp_rst_pending_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t pend                         : 48; /**< Set if corresponding core is waiting to change its reset state. Normally a reset change
+                                                         occurs immediately but if RST_PP_POWER[GATE] bit is set and the core is released from
+                                                         reset a delay of 64K core clocks between each core reset will apply to satisfy power
+                                                         management. */
+#else
+	uint64_t pend                         : 48;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_ciu3_pp_rst_pending_s     cn78xx;
+};
+typedef union cvmx_ciu3_pp_rst_pending cvmx_ciu3_pp_rst_pending_t;
+
+/**
  * cvmx_ciu3_sisc#
  */
 union cvmx_ciu3_siscx {
diff --git a/arch/mips/include/asm/octeon/cvmx-coremask.h b/arch/mips/include/asm/octeon/cvmx-coremask.h
index ec6c093..64cc999 100644
--- a/arch/mips/include/asm/octeon/cvmx-coremask.h
+++ b/arch/mips/include/asm/octeon/cvmx-coremask.h
@@ -60,7 +60,7 @@
  * provide future compatibility if more cores are added to future processors
  * or more nodes are supported.
  *
- * <hr>$Revision: 87283 $<hr>
+ * <hr>$Revision: 87873 $<hr>
  *
  */
 
@@ -615,22 +615,16 @@ cvmx_coremask_is_core_first_core(const cvmx_coremask_t *pcm,
 	return (__builtin_ffs(pcm->coremask_bitmap[n]) == core + 1);
 }
 
-#if	0	//Removed in favor of cvmx_is_init_core()
-/**
- * Test to see if current core is first core in coremask.
- *
- * @param[in]  pcm  pointer to the coremask to test against
- *
- * @return  1 if current core is first core in the coremask, 0 otherwise
- *
+/*
+ * NOTE:
+ * cvmx_coremask_is_first_core() was retired due to improper usage.
+ * For inquiring about the current core being the initializing
+ * core for an application, use cvmx_is_init_core().
+ * For simply inquring if the current core is numerically
+ * lowest in a given mask, use :
+ * 	cvmx_coremask_is_core_first_core( pcm, dvmx_get_core_num())
  */
-static inline int
-cvmx_coremask_is_first_core(const cvmx_coremask_t *pcm)
-{
-	return cvmx_coremask_is_core_first_core(pcm,
-						cvmx_get_core_num());
-}
-#endif
+
 /**
  * Returns the number of 1 bits set in a coremask
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-dbg-defs.h b/arch/mips/include/asm/octeon/cvmx-dbg-defs.h
index 022c714..2edabc2 100644
--- a/arch/mips/include/asm/octeon/cvmx-dbg-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dbg-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-debug.h b/arch/mips/include/asm/octeon/cvmx-debug.h
index acd1aa8..cb59b16 100644
--- a/arch/mips/include/asm/octeon/cvmx-debug.h
+++ b/arch/mips/include/asm/octeon/cvmx-debug.h
@@ -42,7 +42,6 @@
  *
  * Interface to debug exception handler
  *
- * <hr>$Revision:  $<hr>
  */
 
 #ifndef __CVMX_DEBUG_H__
@@ -55,7 +54,7 @@
 #define CVMX_DEBUG_MAX_RESPONSE_SIZE 1024 + 5
 
 #define CVMX_DEBUG_GLOBALS_BLOCK_NAME "cvmx-debug-globals"
-#define CVMX_DEBUG_GLOBALS_VERSION 5
+#define CVMX_DEBUG_GLOBALS_VERSION 6
 
 #ifdef	__cplusplus
 /* *INDENT-OFF* */
@@ -252,7 +251,7 @@ typedef enum {
 			/**< The focus core changed */
 } cvmx_debug_command_t;
 
-/* Every field in this struct has to be uint32_t. */
+/* Every field in this struct has to be uint64_t. */
 typedef struct {
 	uint64_t known_cores;
 	uint64_t step_isr;
@@ -282,8 +281,8 @@ typedef struct cvmx_debug_globals_s {
 	uint64_t comm_type;	/* cvmx_debug_comm_type_t */
 	volatile uint64_t comm_changed;	/* cvmx_debug_comm_type_t+1 when someone wants to change it. */
 	volatile uint64_t init_complete;
-	uint32_t tlb_entries;
-	uint32_t state[sizeof(cvmx_debug_state_t) / sizeof(uint32_t)];
+	uint64_t tlb_entries;
+	uint64_t state[sizeof(cvmx_debug_state_t) / sizeof(uint64_t)];
 	cvmx_spinlock_t lock;
 
 	volatile cvmx_debug_core_context_t contextes[CVMX_MAX_CORES];
diff --git a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
index 71320c1..cc9957f9 100644
--- a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -286,6 +286,17 @@ static inline uint64_t CVMX_DPI_DMA_PPX_CNT(unsigned long offset)
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DPI_DMA_PP_INT CVMX_DPI_DMA_PP_INT_FUNC()
+static inline uint64_t CVMX_DPI_DMA_PP_INT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DPI_DMA_PP_INT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001DF0000000038ull);
+}
+#else
+#define CVMX_DPI_DMA_PP_INT (CVMX_ADD_IO_SEG(0x0001DF0000000038ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_DPI_ECC_CTL CVMX_DPI_ECC_CTL_FUNC()
 static inline uint64_t CVMX_DPI_ECC_CTL_FUNC(void)
 {
@@ -1558,6 +1569,24 @@ union cvmx_dpi_dma_ppx_cnt {
 typedef union cvmx_dpi_dma_ppx_cnt cvmx_dpi_dma_ppx_cnt_t;
 
 /**
+ * cvmx_dpi_dma_pp_int
+ */
+union cvmx_dpi_dma_pp_int {
+	uint64_t u64;
+	struct cvmx_dpi_dma_pp_int_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t complete                     : 48; /**< DPI DMA per-core instruction completion interrupt.  See DPI_DMA_PP(0..47)_CNT. */
+#else
+	uint64_t complete                     : 48;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_dpi_dma_pp_int_s          cn78xx;
+};
+typedef union cvmx_dpi_dma_pp_int cvmx_dpi_dma_pp_int_t;
+
+/**
  * cvmx_dpi_ecc_ctl
  *
  * This register allows inserting ECC errors for testing.
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
index 3d7725e..a989e68 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -1573,8 +1573,8 @@ union cvmx_fpa_gen_cfg {
                                                          0x1 = 32 pools, 640 FPF entries per pool.
                                                          0x2 = 16 pools, 1280 FPF entries per pool.
                                                          0x3 = Reserved */
-	uint64_t avg_en                       : 1;  /**< QoS Averaging enable. When set, compute average buffer levels. When clear, do not compute
-                                                         averages and save a few mW of power. */
+	uint64_t avg_en                       : 1;  /**< QoS averaging enable. When set, compute average buffer levels, and [LVL_DLY] must be non-
+                                                         zero. When clear, do not compute averages and save a few mW of power. */
 	uint64_t reserved_0_0                 : 1;
 #else
 	uint64_t reserved_0_0                 : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h b/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h
index 13b410d..db98f90 100644
--- a/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gmxx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
index e3e29e6..29639a0 100644
--- a/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gpio-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index 82a1427..498f4f5 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-hna-defs.h b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
index c13a98b..74cb6c3 100644
--- a/arch/mips/include/asm/octeon/cvmx-hna-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -195,17 +195,6 @@ static inline uint64_t CVMX_HNA_ERROR_FUNC(void)
 #else
 #define CVMX_HNA_ERROR (CVMX_ADD_IO_SEG(0x0001180047000028ull))
 #endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_HNA_MEMHIDAT CVMX_HNA_MEMHIDAT_FUNC()
-static inline uint64_t CVMX_HNA_MEMHIDAT_FUNC(void)
-{
-	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
-		cvmx_warn("CVMX_HNA_MEMHIDAT not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x0001470700000000ull);
-}
-#else
-#define CVMX_HNA_MEMHIDAT (CVMX_ADD_IO_SEG(0x0001470700000000ull))
-#endif
 
 /**
  * cvmx_hna_bist0
@@ -383,67 +372,55 @@ union cvmx_hna_config {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t repl_ena                     : 1;  /**< Replication Mode Enable
-                                                         *** o63-P2 NEW ***
-                                                         When set, enables replication mode performance enhancement
-                                                         feature. This enables the HNA to communicate address
-                                                         replication information during memory references to the
-                                                         memory controller.
-                                                         For o63-P2:        This is used by the memory controller
-                                                         to support graph data in multiple banks (or bank sets), so that
-                                                         the least full bank can be selected to minimize the effects of
-                                                         DDR3 bank conflicts (ie: tRC=row cycle time).
-                                                         For o68: This is used by the memory controller to support graph
+                                                         This is used by the memory controller to support graph
                                                          data in multiple ports (or port sets), so that the least full
                                                          port can be selected to minimize latency effects.
                                                          SWNOTE: Using this mode requires the HNA SW compiler and HNA
                                                          driver to be aware of the address replication changes.
-                                                         This involves changes to the MLOAD/GWALK HNA instruction format
-                                                         (see: IWORD2.SREPL), as well as changes to node arc and metadata
+                                                         This involves changes to the LOAD/GWALK HNA instruction format
+                                                         (see: IWORD0.REPL), as well as changes to node arc and metadata
                                                          definitions which now support an additional REPL field.
                                                          When clear, replication mode is disabled, and HNA will interpret
                                                          HNA instructions and node-arc formats which DO NOT have
                                                          address replication information. */
 	uint64_t clmskcrip                    : 4;  /**< Cluster Cripple Mask
-                                                         A one in each bit of the mask represents which DTE cluster to
-                                                         cripple.
-                                                         NOTE: o63 has only a single Cluster (therefore CLMSKCRIP[0]
-                                                         is the only bit used.
-                                                         o2 has 4 clusters, where all CLMSKCRIP mask bits are used.
+                                                         A one in each bit of the mask represents which HPC cluster to
+                                                         cripple. o78 HNA has 4 clusters, where all CLMSKCRIP mask bits are used.
                                                          SWNOTE: The MIO_FUS___HNA_CLMASK_CRIPPLE[3:0] fuse bits will
                                                          be forced into this register at reset. Any fuse bits that
                                                          contain '1' will be disallowed during a write and will always
                                                          be read as '1'. */
-	uint64_t cldtecrip                    : 3;  /**< "Encoding which represents \#of DTEs to cripple for each
-                                                         cluster. Typically DTE_CLCRIP=0 which enables all DTEs
+	uint64_t hpu_clcrip                   : 3;  /**< "Encoding which represents \#of HPUs to cripple for each
+                                                         cluster. Typically HPU_CLCRIP=0 which enables all HPUs
                                                          within each cluster. However, when the HNA performance
-                                                         counters are used, SW may want to limit the \#of DTEs
+                                                         counters are used, SW may want to limit the \#of HPUs
                                                          per cluster available, as there are only 4 parallel
                                                          performance counters.
-                                                         DTE_CLCRIP | \#DTEs crippled(per cluster)
-                                                         ------------+-----------------------------
-                                                         0    |  0      DTE[15:0]:ON
-                                                         1    |  1/2    DTE[15:8]:OFF  /DTE[7:0]:ON
-                                                         2    |  1/4    DTE[15:12]:OFF /DTE[11:0]:ON
-                                                         3    |  3/4    DTE[15:4]:OFF  /DTE[3:0]:ON
-                                                         4    |  1/8    DTE[15:14]:OFF /DTE[13:0]:ON
-                                                         5    |  5/8    DTE[15:6]:OFF  /DTE[5:0]:ON
-                                                         6    |  3/8    DTE[15:10]:OFF /DTE[9:0]:ON
-                                                         7    |  7/8    DTE[15:2]:OFF  /DTE[1:0]:ON
-                                                         NOTE: Higher numbered DTEs are crippled first. For instance,
-                                                         on o63 (with 16 DTEs/cluster), if DTE_CLCRIP=1(1/2), then
-                                                         DTE#s [15:8] within the cluster are crippled and only
-                                                         DTE#s [7:0] are available.
+                                                         HPU_CLCRIP | \#HPUs crippled(per cluster)
+                                                         -----------+-----------------------------
+                                                         0          |  0      HPU[11:0]:ON
+                                                         1          |  6      HPU[11:6]:OFF  /HPU[5:0]:ON
+                                                         2          |  3      HPU[11:9]:OFF  /HPU[8:0]:ON
+                                                         3          |  9      HPU[11:3]:OFF  /HPU[2:0]:ON
+                                                         4          |  1      HPU[11]:OFF    /HPU[10:0]:ON
+                                                         5          |  8      HPU[11:4]:OFF  /HPU[3:0]:ON
+                                                         6          |  4      HPU[11:8]:OFF  /HPU[7:0]:ON
+                                                         7          |  11     HPU[11:1]:OFF  /HPU[0]:ON
+                                                         NOTE: Higher numbered HPUs are crippled first. For instance,
+                                                         on o78 (with 12 HPUs/cluster), if HPU_CLCRIP=1(1/2), then
+                                                         HPU#s [15:8] within the cluster are crippled and only
+                                                         HPU#s [7:0] are available.
                                                          IMPNOTE: The encodings are done in such a way as to later
-                                                         be used with fuses (for future o2 revisions which will disable
-                                                         some \#of DTEs). Blowing a fuse has the effect that there will
-                                                         always be fewer DTEs available. [ie: we never want a customer
-                                                         to blow additional fuses to get more DTEs].
-                                                         SWNOTE: The MIO_FUS___HNA_NUMDTE_CRIPPLE[2:0] fuse bits will
+                                                         be used with fuses (for future revisions which will disable
+                                                         some \#of HPUs). Blowing a fuse has the effect that there will
+                                                         always be fewer HPUs available. [ie: we never want a customer
+                                                         to blow additional fuses to get more HPUs].
+                                                         SWNOTE: The MIO_FUS___HNA_NUMHPU_CRIPPLE[2:0] fuse bits will
                                                          be forced into this register at reset. Any fuse bits that
                                                          contain '1' will be disallowed during a write and will always
                                                          be read as '1'." */
-	uint64_t dteclkdis                    : 1;  /**< HNA Clock Disable Source
-                                                         When SET, the HNA clocks for DTE(thread engine)
+	uint64_t hpuclkdis                    : 1;  /**< HNA Clock Disable Source
+                                                         When SET, the HNA clocks for HPU(thread engine)
                                                          operation are disabled (to conserve overall chip clocking
                                                          power when the HNA function is not used).
                                                          NOTE: When SET, SW MUST NEVER issue NCB-Direct CSR
@@ -451,13 +428,13 @@ union cvmx_hna_config {
                                                          errors).
                                                          NOTE: This should only be written to a different value
                                                          during power-on SW initialization.
-                                                         SWNOTE: The MIO_FUS___HNA_DTE_DISABLE fuse bit will
+                                                         SWNOTE: The MIO_FUS___HNA_HPU_DISABLE fuse bit will
                                                          be forced into this register at reset. If the fuse bit
-                                                         contains '1', writes to DTECLKDIS are disallowed and
+                                                         contains '1', writes to HPUCLKDIS are disallowed and
                                                          will always be read as '1'. */
 #else
-	uint64_t dteclkdis                    : 1;
-	uint64_t cldtecrip                    : 3;
+	uint64_t hpuclkdis                    : 1;
+	uint64_t hpu_clcrip                   : 3;
 	uint64_t clmskcrip                    : 4;
 	uint64_t repl_ena                     : 1;
 	uint64_t reserved_9_63                : 55;
@@ -523,9 +500,9 @@ typedef union cvmx_hna_control cvmx_hna_control_t;
  * with addr[34:33]=2'b00.
  * To read the HNA_DBELL register, a device would issue an IOBLD64 directed at the HNA with
  * addr[34:33]=2'b00.
- * NOTE: If HNA_CONFIG[DTECLKDIS]=1 (HNA-DTE clocks disabled), reads/writes to the HNA_DBELL
+ * NOTE: If HNA_CONFIG[HPUCLKDIS]=1 (HNA-HPU clocks disabled), reads/writes to the HNA_DBELL
  * register do not take effect.
- * NOTE: If FUSE[TBD]="HNA DTE disable" is blown, reads/writes to the HNA_DBELL register do not
+ * NOTE: If FUSE[TBD]="HNA HPU disable" is blown, reads/writes to the HNA_DBELL register do not
  * take effect.
  */
 union cvmx_hna_dbell {
@@ -564,7 +541,7 @@ typedef union cvmx_hna_dbell cvmx_hna_dbell_t;
  * CSR read.
  * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
  * model)
- * on the reads unless the DTE Engine specified by HNA_CONTROL[SBDNUM] has previously been
+ * on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
  * assigned an
  * instruction."
  */
@@ -614,7 +591,7 @@ typedef union cvmx_hna_debug0 cvmx_hna_debug0_t;
  * CSR read.
  * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
  * model)
- * on the reads unless the DTE Engine specified by HNA_CONTROL[SBDNUM] has previously been
+ * on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
  * assigned an
  * instruction."
  */
@@ -645,7 +622,7 @@ typedef union cvmx_hna_debug1 cvmx_hna_debug1_t;
  * CSR read.
  * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
  * model)
- * on the reads unless the DTE Engine specified by HNA_CONTROL[SBDNUM] has previously been
+ * on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
  * assigned an
  * instruction.
  */
@@ -676,7 +653,7 @@ typedef union cvmx_hna_debug2 cvmx_hna_debug2_t;
  * CSR read.
  * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
  * model)
- * on the reads unless the DTE Engine specified by HNA_CONTROL[SBDNUM] has previously been
+ * on the reads unless the HPU Engine specified by HNA_CONTROL[SBDNUM] has previously been
  * assigned an
  * instruction.
  */
@@ -705,9 +682,9 @@ typedef union cvmx_hna_debug3 cvmx_hna_debug3_t;
  * addr[34:32]=3'b110.
  * NOTE: This register is intended to ONLY be written once (at power-up). Any future writes could
  * cause the HNA and FPA HW to become unpredictable.
- * NOTE: If HNA_CONFIG[DTECLKDIS]=1 (HNA-DTE clocks disabled), reads/writes to the HNA_DIFCTL
+ * NOTE: If HNA_CONFIG[HPUCLKDIS]=1 (HNA-HPU clocks disabled), reads/writes to the HNA_DIFCTL
  * register do not take effect.
- * NOTE: If FUSE[TBD]="HNA DTE disable" is blown, reads/writes to the HNA_DIFCTL register do not
+ * NOTE: If FUSE[TBD]="HNA HPU disable" is blown, reads/writes to the HNA_DIFCTL register do not
  * take effect.
  */
 union cvmx_hna_difctl {
@@ -786,9 +763,9 @@ typedef union cvmx_hna_difctl cvmx_hna_difctl_t;
  * with addr[34:33]=2'b01.
  * To read the HNA_DIFRDPTR register, a device would issue an IOBLD64 directed at the HNA with
  * addr[34:33]=2'b01.
- * NOTE: If HNA_CONFIG[DTECLKDIS]=1 (HNA-DTE clocks disabled), reads/writes to the HNA_DIFRDPTR
+ * NOTE: If HNA_CONFIG[HPUCLKDIS]=1 (HNA-HPU clocks disabled), reads/writes to the HNA_DIFRDPTR
  * register do not take effect.
- * NOTE: If FUSE[TBD]="HNA DTE disable" is blown, reads/writes to the HNA_DIFRDPTR register do
+ * NOTE: If FUSE[TBD]="HNA HPU disable" is blown, reads/writes to the HNA_DIFRDPTR register do
  * not take effect.
  */
 union cvmx_hna_difrdptr {
@@ -881,7 +858,7 @@ union cvmx_hna_error {
 	uint64_t reserved_20_63               : 44;
 	uint64_t osmerr                       : 1;  /**< OSM reported an Error with the response data. */
 	uint64_t replerr                      : 1;  /**< HNA Illegal Replication Factor Error
-                                                         For o68: HNA only supports 1x, 2x, and 4x port replication.
+                                                         HNA only supports 1x, 2x, and 4x port replication.
                                                          Legal configurations for memory are to support 2 port or
                                                          4 port configurations.
                                                          The REPLERR interrupt will be set in the following illegal
@@ -894,32 +871,33 @@ union cvmx_hna_error {
                                                          If REPLERR is set during a NCB-Direct CSR read access to HNA
                                                          Memory REGION, then the CSR read response data is UNPREDICTABLE. */
 	uint64_t hnanxm                       : 1;  /**< HNA Non-existent Memory Access
-                                                         For o68: DTEs (and backdoor CSR HNA Memory REGION reads)
-                                                         have access to the following 38bit L2/DRAM address space
-                                                         which maps to a 37bit physical DDR3 SDRAM address space.
+                                                         HPUs (and backdoor CSR HNA Memory REGION reads)
+                                                         have access to the following 40bit L2/DRAM address space
+                                                         which maps to a 38bit physical DDR3 SDRAM address space [256GB(max)].
                                                          see:
                                                          DR0: 0x0 0000 0000 0000 to 0x0 0000 0FFF FFFF
                                                          maps to lower 256MB of physical DDR3 SDRAM
                                                          DR1: 0x0 0000 2000 0000 to 0x0 0020 0FFF FFFF
                                                          maps to upper 127.75GB of DDR3 SDRAM
+                                                         NOTE: the 2nd 256MB HOLE maps to IO and is unused(nonexistent) for memory.
                                                          L2/DRAM address space                     Physical DDR3 SDRAM Address space
-                                                         (38bit address)                           (37bit address)
-                                                         +-----------+ 0x0020.0FFF.FFFF
-                                                         ===   DR1   ===                          +-----------+ 0x001F.FFFF.FFFF
-                                                         (128GB-256MB)
-                                                         |           |                     =>    |           |  (128GB-256MB)
-                                                         +-----------+ 0x0000.1FFF.FFFF          |   DR1
-                                                         256MB   |   HOLE    |   (DO NOT USE)
-                                                         +-----------+ 0x0000.0FFF.FFFF          +-----------+ 0x0000.0FFF.FFFF
-                                                         256MB   |    DR0    |                           |   DR0     |   (256MB)
-                                                         +-----------+ 0x0000.0000.0000          +-----------+ 0x0000.0000.0000
+                                                         (40bit address)                           (38bit address)
+                                                         +-----------+ 0x0040.0FFF.FFFF
+
+                                                         |   DR1     |                            +-----------+ 0x003F.FFFF.FFFF
+                                                         |           | (256GB-256MB)
+                                                         |           |                     =>     |   DR1
+                                                         +-----------+ 0x0000.1FFF.FFFF           |           | (256GB-256MB)
+                                                         |   HOLE    | 256MB (DO NOT USE)
+                                                         +-----------+ 0x0000.0FFF.FFFF           +-----------+ 0x0000.0FFF.FFFF
+                                                         |    DR0    | 256MB                      |   DR0     | (256MB)
+                                                         +-----------+ 0x0000.0000.0000           +-----------+ 0x0000.0000.0000
                                                          In the event the HNA generates a reference to the L2/DRAM
-                                                         address hole (0x0000.0FFF.FFFF - 0x0000.1FFF.FFFF) or to
-                                                         an address above 0x0020.0FFF.FFFF, the HNANXM programmable
-                                                         interrupt bit will be set.
+                                                         address hole (0x0000.0FFF.FFFF - 0x0000.1FFF.FFFF) the HNANXM
+                                                         programmable interrupt bit will be set.
                                                          SWNOTE: Both the 1) SW HNA Graph compiler and the 2) SW NCB-Direct CSR
                                                          accesses to HNA Memory REGION MUST avoid making references
-                                                         to these non-existent memory regions.
+                                                         to this 2nd 256MB HOLE which is non-existent memory region.
                                                          NOTE: If HNANXM is set during a HNA Graph Walk operation,
                                                          then the walk will prematurely terminate with RWORD0[REA]=ERR.
                                                          If HNANXM is set during a NCB-Direct CSR read access to HNA
@@ -987,54 +965,4 @@ union cvmx_hna_error {
 };
 typedef union cvmx_hna_error cvmx_hna_error_t;
 
-/**
- * cvmx_hna_memhidat
- *
- * HNA supports NCB-Direct CSR acccesses to DFM Memory space for debug purposes. Unfortunately,
- * NCB-Direct accesses
- * are limited to QW-size(64bits), whereas the minimum access granularity for DFM Memory space is
- * OW(128bits). To
- * support writes to DFM Memory space, the Hi-QW of data is sourced from the HNA_MEMHIDAT
- * register. Recall, the
- * OW(128b) in DDR3 memory space is fixed format:
- * OWDATA[127:118]: OWECC[9:0] 10bits of in-band OWECC SEC/DED codeword
- * This can be precomputed/written by SW OR
- * if DFM_FNTCTL[ECC_WENA]=1, DFM hardware will auto-compute the 10b OWECC and place in the
- * OWDATA[127:118] before being written to memory.
- * OWDATA[117:0]:   Memory Data (contains fixed MNODE/MONODE arc formats for use by DTEs(thread
- * engines).
- * Or, a user may choose to treat DFM Memory Space as 'scratch pad' in which case the
- * OWDATA[117:0] may contain user-specified information accessible via NCB-Direct CSR mode
- * accesses to HNA Memory Space.
- * NOTE: To write to the HNA_MEMHIDAT register, a device would issue an IOBST directed at the HNA
- * with addr[34:32]=3'b111.
- * To read the HNA_MEMHIDAT register, a device would issue an IOBLD64 directed at the HNA with
- * addr[34:32]=3'b111.
- * NOTE: If HNA_CONFIG[DTECLKDIS]=1 (HNA-DTE clocks disabled), reads/writes to the HNA_MEMHIDAT
- * register do not take effect.
- * NOTE: If FUSE[TBD]="HNA DTE disable" is blown, reads/writes to the HNA_MEMHIDAT register do
- * not take effect.
- * NOTE: PLEASE REMOVE DEFINITION FROM o68 HRM
- */
-union cvmx_hna_memhidat {
-	uint64_t u64;
-	struct cvmx_hna_memhidat_s {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t hidat                        : 64; /**< HNA Hi-QW of Write data during NCB-Direct DFM DDR3
-                                                         Memory accesses.
-                                                         All DFM DDR3 memory accesses are OW(128b) references,
-                                                         and since NCB-Direct Mode writes only support QW(64b),
-                                                         the Hi QW of data must be sourced from a CSR register.
-                                                         NOTE: This single register is 'shared' for ALL DFM
-                                                         DDR3 Memory writes.
-                                                         For o68: This register is UNUSED. Treat as spare bits.
-                                                         NOTE: PLEASE REMOVE DEFINITION FROM o68 HRM */
-#else
-	uint64_t hidat                        : 64;
-#endif
-	} s;
-	struct cvmx_hna_memhidat_s            cn78xx;
-};
-typedef union cvmx_hna_memhidat cvmx_hna_memhidat_t;
-
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-ila-defs.h b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
index c6030c4..a60919f 100644
--- a/arch/mips/include/asm/octeon/cvmx-ila-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -1700,7 +1700,7 @@ union cvmx_ila_txx_rmatch {
 	struct cvmx_ila_txx_rmatch_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
-	uint64_t grnlrty                      : 2;  /**< Granularity of a token, where 1 token equal (1<<GRNLRTY) bytes. */
+	uint64_t grnlrty                      : 2;  /**< Reserved. */
 	uint64_t brst_limit                   : 16; /**< Size of token bucket, also the maximum quantity of data that can be burst across the
                                                          interface before invoking rate-limiting logic. */
 	uint64_t time_limit                   : 16; /**< Number of cycles per time interval. Must be >= 4. */
diff --git a/arch/mips/include/asm/octeon/cvmx-ilk-defs.h b/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
index 0f83922..b20a7c2 100644
--- a/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -4902,11 +4902,10 @@ union cvmx_ilk_txx_rmatch {
 	struct cvmx_ilk_txx_rmatch_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_50_63               : 14;
-	uint64_t grnlrty                      : 2;  /**< Granularity of a token, where 1 token equal (1<<GRNLRTY) bytes. */
-	uint64_t brst_limit                   : 16; /**< Size of token bucket, also the maximum quantity of data that can be burst across the
-                                                         interface before invoking rate-limiting logic. */
-	uint64_t time_limit                   : 16; /**< Number of cycles per time interval. Must be >= 4. */
-	uint64_t rate_limit                   : 16; /**< Number of tokens added to the bucket when the interval timer expires. */
+	uint64_t grnlrty                      : 2;  /**< Reserved. */
+	uint64_t brst_limit                   : 16; /**< Reserved. */
+	uint64_t time_limit                   : 16; /**< Reserved. */
+	uint64_t rate_limit                   : 16; /**< Reserved. */
 #else
 	uint64_t rate_limit                   : 16;
 	uint64_t time_limit                   : 16;
diff --git a/arch/mips/include/asm/octeon/cvmx-iob-defs.h b/arch/mips/include/asm/octeon/cvmx-iob-defs.h
index 15e3be7..40fc1ba 100644
--- a/arch/mips/include/asm/octeon/cvmx-iob-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iob-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
index 7dc85be..30b0e39 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobn-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-iobp-defs.h b/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
index b9bc325..bddc995 100644
--- a/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-iobp-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-ipd-defs.h b/arch/mips/include/asm/octeon/cvmx-ipd-defs.h
index 9a19b75..26fce64 100644
--- a/arch/mips/include/asm/octeon/cvmx-ipd-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ipd-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
index 7c4e84a..ee35010 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-l2d-defs.h b/arch/mips/include/asm/octeon/cvmx-l2d-defs.h
index 37a377e..73d4f1c 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2d-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2d-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-l2t-defs.h b/arch/mips/include/asm/octeon/cvmx-l2t-defs.h
index b16becf..21dea30 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2t-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2t-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
index 7c066bdd..7a81981 100644
--- a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -535,7 +535,10 @@ union cvmx_lapx_gen_int {
 	uint64_t u64;
 	struct cvmx_lapx_gen_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_18_63               : 46;
+	uint64_t reserved_19_63               : 45;
+	uint64_t xid_bad                      : 1;  /**< A response packet's transaction ID was targeted to an LAB not in PROCESSING state. Not
+                                                         reported if packet also has CRC or MISMATCH errors. Typically indicates TCAM or
+                                                         configuration error. Throws LAP_INTSN_E::LAP(0..1)_GEN_XID_BAD. */
 	uint64_t nbr_dbe                      : 1;  /**< An ECC uncorrectable error has occurred in the NBR RAM. Throws
                                                          LAP_INTSN_E::LAP(0..1)_GEN_NBR_DBE. */
 	uint64_t nbr_sbe                      : 1;  /**< An ECC correctable error has occurred in the NBR RAM. Throws
@@ -587,7 +590,8 @@ union cvmx_lapx_gen_int {
 	uint64_t edat_dbe                     : 1;
 	uint64_t nbr_sbe                      : 1;
 	uint64_t nbr_dbe                      : 1;
-	uint64_t reserved_18_63               : 46;
+	uint64_t xid_bad                      : 1;
+	uint64_t reserved_19_63               : 45;
 #endif
 	} s;
 	struct cvmx_lapx_gen_int_s            cn78xx;
diff --git a/arch/mips/include/asm/octeon/cvmx-lbk-defs.h b/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
index 13adc60..7f82745 100644
--- a/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lbk-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-led-defs.h b/arch/mips/include/asm/octeon/cvmx-led-defs.h
index 63b3b7c..f9b8a17 100644
--- a/arch/mips/include/asm/octeon/cvmx-led-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-led-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index 4d0fd65..2d99b4b 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -3514,33 +3514,13 @@ union cvmx_lmcx_config {
 	uint64_t mode32b                      : 1;  /**< Always reads as 1 for 70xx devices, only 32b mode is supported. */
 	uint64_t scrz                         : 1;  /**< Hide LMC(0..0)_SCRAMBLE_CFG0 and LMC(0..0)_SCRAMBLE_CFG1 when set. */
 	uint64_t early_unload_d1_r1           : 1;  /**< When set, unload the PHY silo one cycle early for Rank 3 reads.
-                                                         The recommended EARLY_UNLOAD_D1_R1 value can be calculated after the final
-                                                         LMC*_RLEVEL_RANK3[BYTE*] values are selected (as part of read-leveling initialization).
-                                                         Then, determine the largest read-leveling setting for rank 3 (i.e. calculate
-                                                         maxset=MAX(LMC*_RLEVEL_RANK3[BYTEi]) across all i), then set EARLY_UNLOAD_D1_R1 when the
-                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D1_R1 = (maxset<1:0>
-                                                         !=3)). */
+                                                         The recommended EARLY_UNLOAD_D1_R1 value is 0. */
 	uint64_t early_unload_d1_r0           : 1;  /**< When set, unload the PHY silo one cycle early for Rank 2 reads.
-                                                         The recommended EARLY_UNLOAD_D1_RO value can be calculated after the final
-                                                         LMC*_RLEVEL_RANK2[BYTE*] values are selected (as part of read-leveling initialization).
-                                                         Then, determine the largest read-leveling setting for rank 2 (i.e. calculate
-                                                         maxset=MAX(LMC*_RLEVEL_RANK2[BYTEi]) across all i), then set EARLY_UNLOAD_D1_RO when the
-                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D1_RO = (maxset<1:0>
-                                                         !=3)). */
+                                                         The recommended EARLY_UNLOAD_D1_RO value is 0. */
 	uint64_t early_unload_d0_r1           : 1;  /**< When set, unload the PHY silo one cycle early for Rank 1 reads.
-                                                         The recommended EARLY_UNLOAD_D0_R1 value can be calculated after the final
-                                                         LMC*_RLEVEL_RANK1[BYTE*] values are selected (as part of read-leveling initialization).
-                                                         Then, determine the largest read-leveling setting for rank 1 (i.e. calculate
-                                                         maxset=MAX(LMC*_RLEVEL_RANK1[BYTEi]) across all i), then set EARLY_UNLOAD_D0_R1 when the
-                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D0_R1 = (maxset<1:0>
-                                                         !=3)). */
+                                                         The recommended EARLY_UNLOAD_D0_R1 value is 0. */
 	uint64_t early_unload_d0_r0           : 1;  /**< When set, unload the PHY silo one cycle early for Rank 0 reads.
-                                                         The recommended EARLY_UNLOAD_D0_R0 value can be calculated after the final
-                                                         LMC*_RLEVEL_RANK0[BYTE*] values are selected (as part of read-leveling initialization).
-                                                         Then, determine the largest read-leveling setting for rank 0 (i.e. calculate
-                                                         maxset=MAX(LMC*_RLEVEL_RANK0[BYTEi]) across all i), then set EARLY_UNLOAD_D0_R0 when the
-                                                         low two bits of this largest setting is not 3 (i.e. EARLY_UNLOAD_D0_R0 = (maxset<1:0>
-                                                         !=3)). */
+                                                         The recommended EARLY_UNLOAD_D0_R0 value is 0. */
 	uint64_t init_status                  : 4;  /**< Indicates status of initialization. INIT_STATUS[n] = 1 implies rank n has been
                                                          initialized.
                                                          Software must set necessary RANKMASK bits before executing the initialization sequence
@@ -3556,6 +3536,9 @@ union cvmx_lmcx_config {
                                                          DDR#_A<8> is swapped with DDR#_A<7>;
                                                          DDR#_A<6> is swapped with DDR#_A<5>;
                                                          DDR#_A<4> is swapped with DDR#_A<3>.
+                                                         For 70xx, MIRRMASK<3:2> MBZ.
+                                                         When RANK_ENA = 0, MIRRMASK<1> MBZ."
+                                                         INTERNAL:
                                                          In DDR4, a mirrored read/write operation has the following differences:
                                                          DDR#_BG<1> is swapped with DDR#_BG<0>;
                                                          DDR#_BA<1> is swapped with DDR#_BA<0>;
@@ -3567,11 +3550,11 @@ union cvmx_lmcx_config {
                                                          When RANK_ENA = 0, MIRRMASK<1> MBZ." */
 	uint64_t rankmask                     : 4;  /**< Mask to select rank to be leveled/initialized. To write-level/read-level/initialize rank
                                                          i, set RANKMASK< i>
-                                                         RANK_ENA = 1 RANK_ENA = 0
-                                                         RANKMASK<0> = DIMM0_CS0 DIMM0_CS0
-                                                         RANKMASK<1> = DIMM0_CS1 MBZ
-                                                         RANKMASK<2> = DIMM1_CS0 DIMM1_CS0
-                                                         RANKMASK<3> = DIMM1_CS1 MBZ
+                                                                       RANK_ENA = 1 RANK_ENA = 0
+                                                         RANKMASK<0> = DIMM0_CS0    DIMM0_CS0
+                                                         RANKMASK<1> = DIMM0_CS1    MBZ
+                                                         RANKMASK<2> = MBZ          MBZ
+                                                         RANKMASK<3> = MBZ          MBZ
                                                          For read/write leveling, each rank has to be leveled separately, so RANKMASK should only
                                                          have one bit set. RANKMASK is not used during self-refresh entry/exit and precharge power-
                                                          down entry/exit instruction sequences. For 70xx, RANKMASK<3:2> MBZ.  When RANK_ENA = 0,
@@ -3638,24 +3621,24 @@ union cvmx_lmcx_config {
                                                          Encoding used to determine which memory address bit position represents the low order DDR
                                                          ROW address. The processor's memory address<34:7> needs to be translated to DRAM addresses
                                                          (bnk,row,col,rank and DIMM) and that is a function of the following:
-                                                         Datapath width (64)
+                                                         Datapath width (32)
                                                          \# banks (8)
                                                          \# column bits of the memory part--specified indirectly by this register.
                                                          \# row bits of the memory part--specified indirectly by PBANK_LSB
                                                          \# ranks in a DIMM--specified by RANK_ENA
                                                          \# DIMMs in the system by the register below (PBANK_LSB).
-                                                         Col Address starts from mem_addr[3] for 64b (8Bytes) DQ width. ROW_LSB is mem_adr[15] for
-                                                         64b mode. Therefore, the ROW_LSB parameter should be set to 001 (64b).
+                                                         Col Address starts from mem_addr[2] for 32b (4Bytes) DQ width. ROW_LSB is mem_adr[14] for
+                                                         32b mode. Therefore, the ROW_LSB parameter should be set to 000 (32b).
                                                          Decoding for row_lsb:
                                                          Mem address  Mem address
-                                                         Value bit that is LSB Value bit that is LSB
+                                                         Value and corresponding bit that is LSB:
                                                          000 <14>. 100 <18>.
                                                          001 <15>. 101 <19>.
                                                          010 <16>. 110 <20>.
                                                          011 <17>. 111 Reserved.
                                                          For example, for a DIMM made of Samsung's K4B1G0846C-F7 1GB (16M * 8 bit * 8 bank) DDR3
-                                                         parts, the column address width = 10, so with 10b of col, 3b of bus, 3b of bank, ROW_LSB =
-                                                         16. So, row = mem_adr<29:16>.
+                                                         parts, the column address width = 10, so with 10b of col, 2b of bus, 3b of bank, ROW_LSB =
+                                                         15. So, row = mem_adr<28:15>, and ROW_LSB parameter should be set to 001.
                                                          Refer to Cache-block Read Transaction Example." */
 	uint64_t ecc_ena                      : 1;  /**< ECC enable. When set, enables the 8b ECC check/correct logic. Should be 1 when used with
                                                          DIMMs with ECC; 0, otherwise.
@@ -6301,7 +6284,15 @@ union cvmx_lmcx_ext_config {
 	uint64_t u64;
 	struct cvmx_lmcx_ext_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_21_63               : 43;
+	uint64_t reserved_29_63               : 35;
+	uint64_t cal_ena                      : 1;  /**< Set to cause LMC to operate in CAL mode.  DRAM mode registers must first be
+                                                         programmed into CAL mode, then set CAL_ENABLE. */
+	uint64_t reserved_27_27               : 1;
+	uint64_t par_include_a17              : 1;  /**< If set, include A17 in parity calculations in DDR4 mode. */
+	uint64_t par_include_bg1              : 1;  /**< If set, include BG1 in parity calculations in DDR4 mode. */
+	uint64_t gen_par                      : 1;  /**< Enable parity generation in the DRAM commands, must be set prior to enabling
+                                                         parity in register or DRAM devices */
+	uint64_t reserved_21_23               : 3;
 	uint64_t vrefint_seq_deskew           : 1;  /**< Personality bit to change the operation of what is normally the internal
                                                          vref training sequence into the deskew training sequence. */
 	uint64_t read_ena_bprch               : 1;  /**< Enable pad receiver one cycle longer than normal during read operations. */
@@ -6334,10 +6325,53 @@ union cvmx_lmcx_ext_config {
 	uint64_t read_ena_fprch               : 1;
 	uint64_t read_ena_bprch               : 1;
 	uint64_t vrefint_seq_deskew           : 1;
-	uint64_t reserved_21_63               : 43;
+	uint64_t reserved_21_23               : 3;
+	uint64_t gen_par                      : 1;
+	uint64_t par_include_bg1              : 1;
+	uint64_t par_include_a17              : 1;
+	uint64_t reserved_27_27               : 1;
+	uint64_t cal_ena                      : 1;
+	uint64_t reserved_29_63               : 35;
 #endif
 	} s;
-	struct cvmx_lmcx_ext_config_s         cn70xx;
+	struct cvmx_lmcx_ext_config_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_21_63               : 43;
+	uint64_t vrefint_seq_deskew           : 1;  /**< Personality bit to change the operation of what is normally the internal
+                                                         vref training sequence into the deskew training sequence. */
+	uint64_t read_ena_bprch               : 1;  /**< Enable pad receiver one cycle longer than normal during read operations. */
+	uint64_t read_ena_fprch               : 1;  /**< Enable pad receiver starting one cycle earlier than normal during read operations. */
+	uint64_t slot_ctl_reset_force         : 1;  /**< Write 1 to reset the slot-control override for all slot-control registers. After writing a
+                                                         1 to this bit, slot-control registers will update with changes made to other timing-
+                                                         control registers. This is a one-shot operation; it automatically returns to 0 after a
+                                                         write to 1. */
+	uint64_t ref_int_lsbs                 : 9;  /**< These are the 9 LSBs for the refresh interval value, default to 0, but can be set to
+                                                         a non-zero value to get a more precise refresh interval. */
+	uint64_t drive_ena_bprch              : 1;  /**< Drive DQx for one cycle longer than normal during write operations. */
+	uint64_t drive_ena_fprch              : 1;  /**< Drive DQX starting one cycle earlier than normal during write operations. */
+	uint64_t dlcram_flip_synd             : 2;  /**< Reserved. INTERNAL: DLC RAM flip syndrome control bits. */
+	uint64_t dlcram_cor_dis               : 1;  /**< Reserved. INTERNAL: DLC RAM correction disable control. */
+	uint64_t dlc_nxm_rd                   : 1;  /**< When set, enable NXM events for DLC reads.  Default is disabled, but
+                                                         could be useful for debug of DLC/DFA accesses. */
+	uint64_t l2c_nxm_rd                   : 1;  /**< When set, enable NXM events for L2C read operations. INTERNAL: Default is disabled as L2C
+                                                         NXM read operations are possible and expected during normal operation. */
+	uint64_t l2c_nxm_wr                   : 1;  /**< When set, enable NXM events for L2C write operations. */
+#else
+	uint64_t l2c_nxm_wr                   : 1;
+	uint64_t l2c_nxm_rd                   : 1;
+	uint64_t dlc_nxm_rd                   : 1;
+	uint64_t dlcram_cor_dis               : 1;
+	uint64_t dlcram_flip_synd             : 2;
+	uint64_t drive_ena_fprch              : 1;
+	uint64_t drive_ena_bprch              : 1;
+	uint64_t ref_int_lsbs                 : 9;
+	uint64_t slot_ctl_reset_force         : 1;
+	uint64_t read_ena_fprch               : 1;
+	uint64_t read_ena_bprch               : 1;
+	uint64_t vrefint_seq_deskew           : 1;
+	uint64_t reserved_21_63               : 43;
+#endif
+	} cn70xx;
 	struct cvmx_lmcx_ext_config_s         cn78xx;
 };
 typedef union cvmx_lmcx_ext_config cvmx_lmcx_ext_config_t;
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index 7d56627..415e06f 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -6098,8 +6098,8 @@ typedef union cvmx_mio_pll_setting cvmx_mio_pll_setting_t;
 /**
  * cvmx_mio_ptp_ckout_hi_incr
  *
- * This register contains the high bytes of the PTP clock out increment. MIO_PTP Registers for
- * address.
+ * This register contains the high bytes of the PTP clock out increment.
+ *
  */
 union cvmx_mio_ptp_ckout_hi_incr {
 	uint64_t u64;
@@ -6124,7 +6124,7 @@ typedef union cvmx_mio_ptp_ckout_hi_incr cvmx_mio_ptp_ckout_hi_incr_t;
 /**
  * cvmx_mio_ptp_ckout_lo_incr
  *
- * This register contains the low bytes of the PTP clock out increment. MIO_PTP Registers for address.
+ * This register contains the low bytes of the PTP clock out increment.
  *
  */
 union cvmx_mio_ptp_ckout_lo_incr {
@@ -6152,7 +6152,7 @@ typedef union cvmx_mio_ptp_ckout_lo_incr cvmx_mio_ptp_ckout_lo_incr_t;
  *
  * This register contains the high bytes of the PTP clock out. Writes to MIO_PTP_CKOUT_THRESH_HI
  * also clear MIO_PTP_CKOUT_THRESH_LO; to update all 96 bits, write MIO_PTP_CKOUT_THRESH_HI
- * followed by MIO_PTP_CKOUT_THRESH_LO. MIO_PTP Registers for address.
+ * followed by MIO_PTP_CKOUT_THRESH_LO.
  */
 union cvmx_mio_ptp_ckout_thresh_hi {
 	uint64_t u64;
@@ -6175,7 +6175,7 @@ typedef union cvmx_mio_ptp_ckout_thresh_hi cvmx_mio_ptp_ckout_thresh_hi_t;
 /**
  * cvmx_mio_ptp_ckout_thresh_lo
  *
- * This register contains the low bytes of the PTP clock out. MIO_PTP Registers for address.
+ * This register contains the low bytes of the PTP clock out.
  *
  */
 union cvmx_mio_ptp_ckout_thresh_lo {
@@ -6201,7 +6201,7 @@ typedef union cvmx_mio_ptp_ckout_thresh_lo cvmx_mio_ptp_ckout_thresh_lo_t;
 /**
  * cvmx_mio_ptp_clock_cfg
  *
- * This register configures the timestamp architecture. MIO_PTP Registers for address
+ * This register configures the timestamp architecture. See MIO_PTP Registers for address
  *
  */
 union cvmx_mio_ptp_clock_cfg {
@@ -6539,7 +6539,7 @@ typedef union cvmx_mio_ptp_clock_cfg cvmx_mio_ptp_clock_cfg_t;
 /**
  * cvmx_mio_ptp_clock_comp
  *
- * This register provides the compensation value the PTP clock. MIO_PTP Registers for address.
+ * This register provides the compensation value the PTP clock.
  *
  */
 union cvmx_mio_ptp_clock_comp {
@@ -6569,8 +6569,7 @@ typedef union cvmx_mio_ptp_clock_comp cvmx_mio_ptp_clock_comp_t;
  * cvmx_mio_ptp_clock_hi
  *
  * This register provides bits<95:32> of the PTP clock. Writes to MIO_PTP_CLOCK_HI also clear
- * MIO_PTP_CLOCK_LO. To update all 96 bits, write MIO_PTP_CLOCK_HI followed by
- * MIO_PTP_CLOCK_LOMIO_PTP Registers for address.
+ * MIO_PTP_CLOCK_LO. To update all 96 bits, write MIO_PTP_CLOCK_HI followed by MIO_PTP_CLOCK_LO.
  */
 union cvmx_mio_ptp_clock_hi {
 	uint64_t u64;
@@ -6596,7 +6595,7 @@ typedef union cvmx_mio_ptp_clock_hi cvmx_mio_ptp_clock_hi_t;
 /**
  * cvmx_mio_ptp_clock_lo
  *
- * This register provides bits<31:0> of the PTP clock. MIO_PTP Registers for address.
+ * This register provides bits<31:0> of the PTP clock.
  *
  */
 union cvmx_mio_ptp_clock_lo {
@@ -6625,7 +6624,7 @@ typedef union cvmx_mio_ptp_clock_lo cvmx_mio_ptp_clock_lo_t;
 /**
  * cvmx_mio_ptp_dpll_err_int
  *
- * This register contains the Digital PLL error event interrupt. MIO_PTP Registers for address.
+ * This register contains the Digital PLL error event interrupt.
  *
  */
 union cvmx_mio_ptp_dpll_err_int {
@@ -6648,7 +6647,7 @@ typedef union cvmx_mio_ptp_dpll_err_int cvmx_mio_ptp_dpll_err_int_t;
 /**
  * cvmx_mio_ptp_dpll_err_thresh
  *
- * This register configures the Digital PLL error interrupt. MIO_PTP Registers for address.
+ * This register configures the Digital PLL error interrupt.
  *
  */
 union cvmx_mio_ptp_dpll_err_thresh {
@@ -6669,8 +6668,8 @@ typedef union cvmx_mio_ptp_dpll_err_thresh cvmx_mio_ptp_dpll_err_thresh_t;
 /**
  * cvmx_mio_ptp_dpll_incr
  *
- * This register contains the Digital PLL increment. Zero disables the digital PLL. MIO_PTP
- * Registers for address.
+ * This register contains the Digital PLL increment. Zero disables the digital PLL.
+ *
  */
 union cvmx_mio_ptp_dpll_incr {
 	uint64_t u64;
@@ -6690,7 +6689,7 @@ typedef union cvmx_mio_ptp_dpll_incr cvmx_mio_ptp_dpll_incr_t;
 /**
  * cvmx_mio_ptp_evt_cnt
  *
- * This register contains the PTP event counter. MIO_PTP Registers for address.
+ * This register contains the PTP event counter.
  *
  */
 union cvmx_mio_ptp_evt_cnt {
@@ -6717,7 +6716,7 @@ typedef union cvmx_mio_ptp_evt_cnt cvmx_mio_ptp_evt_cnt_t;
 /**
  * cvmx_mio_ptp_evt_int
  *
- * This register contains the PTP event interrupt. MIO_PTP Registers for address.
+ * This register contains the PTP event interrupt.
  *
  */
 union cvmx_mio_ptp_evt_int {
@@ -6765,7 +6764,7 @@ typedef union cvmx_mio_ptp_phy_1pps_in cvmx_mio_ptp_phy_1pps_in_t;
 /**
  * cvmx_mio_ptp_pps_hi_incr
  *
- * This register contains the high bytes of the PTP PPS increment. MIO_PTP Registers for address.
+ * This register contains the high bytes of the PTP PPS increment.
  *
  */
 union cvmx_mio_ptp_pps_hi_incr {
@@ -6791,7 +6790,7 @@ typedef union cvmx_mio_ptp_pps_hi_incr cvmx_mio_ptp_pps_hi_incr_t;
 /**
  * cvmx_mio_ptp_pps_lo_incr
  *
- * This register contains the low bytes of the PTP PPS increment. MIO_PTP Registers for address.
+ * This register contains the low bytes of the PTP PPS increment.
  *
  */
 union cvmx_mio_ptp_pps_lo_incr {
@@ -6819,7 +6818,7 @@ typedef union cvmx_mio_ptp_pps_lo_incr cvmx_mio_ptp_pps_lo_incr_t;
  *
  * This register contains the high bytes of the PTP PPS. Writes to MIO_PTP_PPS_THRESH_HI also
  * clear MIO_PTP_PPS_THRESH_LO; to update all 96 bits write MIO_PTP_PPS_THRESH_HI followed by
- * MIO_PTP_PPS_THRESH_LO. MIO_PTP Registers for address.
+ * MIO_PTP_PPS_THRESH_LO.
  */
 union cvmx_mio_ptp_pps_thresh_hi {
 	uint64_t u64;
@@ -6842,7 +6841,7 @@ typedef union cvmx_mio_ptp_pps_thresh_hi cvmx_mio_ptp_pps_thresh_hi_t;
 /**
  * cvmx_mio_ptp_pps_thresh_lo
  *
- * This register contains the low bytes of the PTP PPS. MIO_PTP Registers for address.
+ * This register contains the low bytes of the PTP PPS.
  *
  */
 union cvmx_mio_ptp_pps_thresh_lo {
@@ -6869,7 +6868,7 @@ typedef union cvmx_mio_ptp_pps_thresh_lo cvmx_mio_ptp_pps_thresh_lo_t;
  * cvmx_mio_ptp_timestamp
  *
  * This register contains the timestamp latched on MIO_PTP_CLOCK_CFG[TSTMP_EDGE] edge of
- * MIO_PTP_CLOCK_CFG[TSTMP_IN]. MIO_PTP Registers for address.
+ * MIO_PTP_CLOCK_CFG[TSTMP_IN].
  */
 union cvmx_mio_ptp_timestamp {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
index 57edfeb..9ab137d 100644
--- a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
index 94cd776..996f9fd 100644
--- a/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mpi-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-ndf-defs.h b/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
index 4453139..b160bfc 100644
--- a/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ndf-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-npei-defs.h b/arch/mips/include/asm/octeon/cvmx-npei-defs.h
index 0714258..f8fed4b 100644
--- a/arch/mips/include/asm/octeon/cvmx-npei-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-npei-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-npi-defs.h b/arch/mips/include/asm/octeon/cvmx-npi-defs.h
index 4049973..eda66ff 100644
--- a/arch/mips/include/asm/octeon/cvmx-npi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-npi-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
index a970072..e087985 100644
--- a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
index 65a36ea..814fd74 100644
--- a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -474,7 +474,7 @@ static inline uint64_t CVMX_OCX_RLKX_ENABLES(unsigned long offset)
 static inline uint64_t CVMX_OCX_RLKX_FIFOX_CNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 13)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_RLKX_FIFOX_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011018100ull) + (((offset) & 15) + ((block_id) & 3) * 0x400ull) * 8;
 }
@@ -518,7 +518,7 @@ static inline uint64_t CVMX_OCX_TLKX_ECC_CTL(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_FIFOX_CNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 13)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_TLKX_FIFOX_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011010100ull) + (((offset) & 15) + ((block_id) & 3) * 0x400ull) * 8;
 }
@@ -540,7 +540,7 @@ static inline uint64_t CVMX_OCX_TLKX_LNK_DATA(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_LNK_VCX_CNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 13)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_TLKX_LNK_VCX_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011010200ull) + (((offset) & 15) + ((block_id) & 3) * 0x400ull) * 8;
 }
@@ -562,7 +562,7 @@ static inline uint64_t CVMX_OCX_TLKX_MCD_CTL(unsigned long offset)
 static inline uint64_t CVMX_OCX_TLKX_RTN_VCX_CNT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 13)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_TLKX_RTN_VCX_CNT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011010300ull) + (((offset) & 15) + ((block_id) & 3) * 0x400ull) * 8;
 }
@@ -683,7 +683,7 @@ static inline uint64_t CVMX_OCX_TLKX_STAT_VCX_CMD(unsigned long offset, unsigned
 static inline uint64_t CVMX_OCX_TLKX_STAT_VCX_CON(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 13)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_TLKX_STAT_VCX_CON(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011010580ull) + (((offset) & 15) + ((block_id) & 3) * 0x400ull) * 8;
 }
@@ -694,7 +694,7 @@ static inline uint64_t CVMX_OCX_TLKX_STAT_VCX_CON(unsigned long offset, unsigned
 static inline uint64_t CVMX_OCX_TLKX_STAT_VCX_PKT(unsigned long offset, unsigned long block_id)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 12)) && ((block_id <= 2))))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 13)) && ((block_id <= 2))))))
 		cvmx_warn("CVMX_OCX_TLKX_STAT_VCX_PKT(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x0001180011010500ull) + (((offset) & 15) + ((block_id) & 3) * 0x400ull) * 8;
 }
@@ -825,7 +825,7 @@ union cvmx_ocx_com_linkx_ctl {
                                                          software wishes to manage deassertion of DROP. */
 	uint64_t drop                         : 1;  /**< Drop all requests on given link. Typically set by hardware when link has failed or been
                                                          reinitialized. Cleared by software once pending link traffic is removed. (See
-                                                         OCX_TLK[0..2]_FIFO[0..12]_CNT.) */
+                                                         OCX_TLK[0..2]_FIFO[0..13]_CNT.) */
 	uint64_t up                           : 1;  /**< Link is operating normally. */
 	uint64_t valid                        : 1;  /**< Link has valid lanes and is exchanging information. */
 	uint64_t id                           : 2;  /**< This ID is used to sort traffic by link. If more than one link has the same value, the
@@ -926,14 +926,21 @@ union cvmx_ocx_com_node {
 	uint64_t fixed_pin                    : 1;  /**< The current value of the OCI_FIXED_ID pin. */
 	uint64_t fixed                        : 1;  /**< ID Valid associated with the chip. This register is used by the link initialization
                                                          software to help assign IDs and is transmitted over OCI. The FIXED field set during a cold
-                                                         reset to the value of the OCI_FIXED_ID pin. The value should also be readable in the
-                                                         OCX_LNE(0..23)_CFG[RX_META_DAT] on the corresponding link of the partner. */
+                                                         reset to the value of the OCI_FIXED_ID pin. The value is also be readable in the
+                                                         OCX_LNE(0..23)_STS_MSG[TX_META_DAT[2]] for each lane.  The FIXED pin of the link partner
+                                                         can
+                                                         be examined by locally reading the OCX_LNE(0..23)_STS_MSG[RX_META_DAT[2]] on each valid
+                                                         lane
+                                                         or remotely reading the OCX_COM_NODE[FIXED] on the link partner. */
 	uint64_t id                           : 2;  /**< Node ID associated with the chip. This register is used by the rest of the chip to
                                                          determine what traffic is transmitted over OCI. The value should not match the
                                                          OCX_COM_LINK(0..2)_CTL[ID] of any active link. The ID field is set during a cold reset to
-                                                         the value of the OCI_NODE_ID pins. The value should be readable in the
-                                                         OCX_LNE(0..23)_CFG[RX_META_DAT] on the corresponding link of the partner. It can be
-                                                         changed as long as no traffic is being transferred. */
+                                                         the value of the OCI_NODE_ID pins. The value is also be readable in the
+                                                         OCX_LNE(0..23)_STS_MSG[TX_META_DAT[1:0]] for each lane.  The FIXED pin of the link partner
+                                                         can
+                                                         be examined by locally reading the OCX_LNE(0..23)_STS_MSG[RX_META_DAT[1:0]] on each valid
+                                                         lane
+                                                         or remotely reading the OCX_COM_NODE[ID] on the link partner. */
 #else
 	uint64_t id                           : 2;
 	uint64_t fixed                        : 1;
@@ -1827,7 +1834,8 @@ union cvmx_ocx_rlkx_fifox_cnt {
 	struct cvmx_ocx_rlkx_fifox_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t count                        : 16; /**< RX FIFO count of 64-bit words to send to core. */
+	uint64_t count                        : 16; /**< RX FIFO count of 64-bit words to send to core.  VC13 traffic is used immediately so
+                                                         the FIFO count is always 0. (see OCX_RLK(0..2)_LNK_DATA) */
 #else
 	uint64_t count                        : 16;
 	uint64_t reserved_16_63               : 48;
@@ -1953,7 +1961,7 @@ union cvmx_ocx_tlkx_lnk_vcx_cnt {
 	struct cvmx_ocx_tlkx_lnk_vcx_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t count                        : 16; /**< Link VC credits available for use. */
+	uint64_t count                        : 16; /**< Link VC credits available for use.  VC13 always reads 1 since credits are not required. */
 #else
 	uint64_t count                        : 16;
 	uint64_t reserved_16_63               : 48;
@@ -1965,6 +1973,13 @@ typedef union cvmx_ocx_tlkx_lnk_vcx_cnt cvmx_ocx_tlkx_lnk_vcx_cnt_t;
 
 /**
  * cvmx_ocx_tlk#_mcd_ctl
+ *
+ * This register controls which MCD bits are transported via the link. For proper operation
+ * only one link must be enabled in both directions between each pair of link partners.
+ * Internal:  If N chips are connected over OCX, N-1 links should have MCD enabled.
+ * A single "central" chip should connect all MCD buses and have a single MCD enabled link
+ * to each of the other chips.  No MCD enabled links should connect between chips that don't
+ * include the "central" chip.
  */
 union cvmx_ocx_tlkx_mcd_ctl {
 	uint64_t u64;
@@ -1989,7 +2004,7 @@ union cvmx_ocx_tlkx_rtn_vcx_cnt {
 	struct cvmx_ocx_tlkx_rtn_vcx_cnt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t count                        : 16; /**< Link VC credits to return. */
+	uint64_t count                        : 16; /**< Link VC credits to return.  VC13 always reads 0 since credits are never returned. */
 #else
 	uint64_t count                        : 16;
 	uint64_t reserved_16_63               : 48;
@@ -2152,8 +2167,9 @@ union cvmx_ocx_tlkx_stat_vcx_cmd {
 	uint64_t u64;
 	struct cvmx_ocx_tlkx_stat_vcx_cmd_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t count                        : 64; /**< Number of blocks received with an error over the OCI link while
-                                                         OCX_TLK(a)_STAT_CTL[ENABLE] has been set. */
+	uint64_t count                        : 64; /**< Number of commands on this VC that have been transfered over the OCI link while
+                                                         OCX_TLK(a)_STAT_CTL[ENABLE] has been set.  For VCs 6 thru 13 the number of commands is
+                                                         equal to the number of packets. */
 #else
 	uint64_t count                        : 64;
 #endif
@@ -2170,7 +2186,8 @@ union cvmx_ocx_tlkx_stat_vcx_con {
 	struct cvmx_ocx_tlkx_stat_vcx_con_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t count                        : 64; /**< Number of conflicts on this VC while OCX_TLK(a)_STAT_CTL[ENABLE] has been set. A conflict
-                                                         is indicated when a VC has one or more packets to send and no link credits are available. */
+                                                         is indicated when a VC has one or more packets to send and no link credits are available.
+                                                         VC13 does not require credits so no conflicts are ever indicated (ie. reads 0). */
 #else
 	uint64_t count                        : 64;
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-osm-defs.h b/arch/mips/include/asm/octeon/cvmx-osm-defs.h
index 0ae576b..9191ff0 100644
--- a/arch/mips/include/asm/octeon/cvmx-osm-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-osm-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pci-defs.h b/arch/mips/include/asm/octeon/cvmx-pci-defs.h
index 28be954..d75607e 100644
--- a/arch/mips/include/asm/octeon/cvmx-pci-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pci-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pcie.h b/arch/mips/include/asm/octeon/cvmx-pcie.h
index 4c891dd..daa4222 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcie.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcie.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 73845 $<hr>
+ * <hr>$Revision: 88161 $<hr>
  */
 
 #ifndef __CVMX_PCIE_H__
@@ -54,6 +54,15 @@ extern "C" {
 /* *INDENT-ON* */
 #endif
 
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+#include <asm/octeon/cvmx.h>
+#else
+#include <cvmx.h>
+#endif
+
+#define CVMX_PCIE_MAX_PORTS	3
+#define CVMX_PCIE_PORTS		(OCTEON_IS_OCTEON3() ? CVMX_PCIE_MAX_PORTS : 2)
+
 /*
  * The physical memory base mapped by BAR1.  256MB at the end of the
  * first 4GB.
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
index 3e44b0d..a76d87b 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index 8fa3706..677028c 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
index dade8b0..603d1be 100644
--- a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h
index 856b077..d504dbe 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcsx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
index a4ca741..1ff32eb 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcsxx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
index 7e34306..cece806 100644
--- a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -347,6 +347,17 @@ static inline uint64_t CVMX_PEMX_CTL_STATUS(unsigned long block_id)
 #define CVMX_PEMX_CTL_STATUS(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000000ull) + ((block_id) & 3) * 0x1000000ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_PEMX_CTL_STATUS2(unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((block_id <= 3)))))
+		cvmx_warn("CVMX_PEMX_CTL_STATUS2(%lu) is invalid on this chip\n", block_id);
+	return CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((block_id) & 3) * 0x1000000ull;
+}
+#else
+#define CVMX_PEMX_CTL_STATUS2(block_id) (CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((block_id) & 3) * 0x1000000ull)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEMX_DBG_INFO(unsigned long block_id)
 {
 	switch(cvmx_get_octeon_family()) {
@@ -1415,33 +1426,16 @@ union cvmx_pemx_ctl_status {
 	uint64_t u64;
 	struct cvmx_pemx_ctl_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_7_63                : 57;
-	uint64_t nf_ecrc                      : 1;  /**< Do not forward peer-to-peer ECRC TLPs. */
-	uint64_t dly_one                      : 1;  /**< When set the output client state machines will
-                                                         wait one cycle before starting a new TLP out. */
-	uint64_t lnk_enb                      : 1;  /**< When set '1' the link is enabled when '0' the
-                                                         link is disabled. This bit only is active when in
-                                                         RC mode. */
-	uint64_t ro_ctlp                      : 1;  /**< When set '1' C-TLPs that have the RO bit set will
-                                                         not wait for P-TLPs that normaly would be sent
-                                                         first. */
-	uint64_t fast_lm                      : 1;  /**< When '1' forces fast link mode. */
-	uint64_t inv_ecrc                     : 1;  /**< When '1' causes the LSB of the ECRC to be inverted. */
-	uint64_t inv_lcrc                     : 1;  /**< When '1' causes the LSB of the LCRC to be inverted. */
-#else
-	uint64_t inv_lcrc                     : 1;
-	uint64_t inv_ecrc                     : 1;
-	uint64_t fast_lm                      : 1;
-	uint64_t ro_ctlp                      : 1;
-	uint64_t lnk_enb                      : 1;
-	uint64_t dly_one                      : 1;
-	uint64_t nf_ecrc                      : 1;
-	uint64_t reserved_7_63                : 57;
-#endif
-	} s;
-	struct cvmx_pemx_ctl_status_cn61xx {
-#ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_48_63               : 16;
+	uint64_t reserved_51_63               : 13;
+	uint64_t inv_dpar                     : 1;  /**< Invert the generated parity to be written into the
+                                                         the most significant Data Queue Buffer ram block
+                                                         to force a parity error when it is later read. */
+	uint64_t inv_hpar                     : 1;  /**< Invert the generated parity to be written into the
+                                                         most significant Header Queue Buffer ram block
+                                                         to force a parity error when it is later read. */
+	uint64_t inv_rpar                     : 1;  /**< Invert the generated parity to be written into the
+                                                         most significant Retry Buffer ram block to force
+                                                         a parity error when it is later read. */
 	uint64_t auto_sd                      : 1;  /**< Link Hardware Autonomous Speed Disable. */
 	uint64_t dnum                         : 5;  /**< Primary bus device number. */
 	uint64_t pbus                         : 8;  /**< Primary bus number. */
@@ -1492,26 +1486,15 @@ union cvmx_pemx_ctl_status {
 	uint64_t pbus                         : 8;
 	uint64_t dnum                         : 5;
 	uint64_t auto_sd                      : 1;
-	uint64_t reserved_48_63               : 16;
+	uint64_t inv_rpar                     : 1;
+	uint64_t inv_hpar                     : 1;
+	uint64_t inv_dpar                     : 1;
+	uint64_t reserved_51_63               : 13;
 #endif
-	} cn61xx;
-	struct cvmx_pemx_ctl_status_cn61xx    cn63xx;
-	struct cvmx_pemx_ctl_status_cn61xx    cn63xxp1;
-	struct cvmx_pemx_ctl_status_cn61xx    cn66xx;
-	struct cvmx_pemx_ctl_status_cn61xx    cn68xx;
-	struct cvmx_pemx_ctl_status_cn61xx    cn68xxp1;
-	struct cvmx_pemx_ctl_status_cn70xx {
+	} s;
+	struct cvmx_pemx_ctl_status_cn61xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_51_63               : 13;
-	uint64_t inv_dpar                     : 1;  /**< Invert the generated parity to be written into the
-                                                         the most significant Data Queue Buffer ram block
-                                                         to force a parity error when it is later read. */
-	uint64_t inv_hpar                     : 1;  /**< Invert the generated parity to be written into the
-                                                         most significant Header Queue Buffer ram block
-                                                         to force a parity error when it is later read. */
-	uint64_t inv_rpar                     : 1;  /**< Invert the generated parity to be written into the
-                                                         tmost significant Retry Buffer ram block to force
-                                                         a parity error when it is later read. */
+	uint64_t reserved_48_63               : 16;
 	uint64_t auto_sd                      : 1;  /**< Link Hardware Autonomous Speed Disable. */
 	uint64_t dnum                         : 5;  /**< Primary bus device number. */
 	uint64_t pbus                         : 8;  /**< Primary bus number. */
@@ -1562,26 +1545,31 @@ union cvmx_pemx_ctl_status {
 	uint64_t pbus                         : 8;
 	uint64_t dnum                         : 5;
 	uint64_t auto_sd                      : 1;
-	uint64_t inv_rpar                     : 1;
-	uint64_t inv_hpar                     : 1;
-	uint64_t inv_dpar                     : 1;
-	uint64_t reserved_51_63               : 13;
+	uint64_t reserved_48_63               : 16;
 #endif
-	} cn70xx;
-	struct cvmx_pemx_ctl_status_cn78xx {
+	} cn61xx;
+	struct cvmx_pemx_ctl_status_cn61xx    cn63xx;
+	struct cvmx_pemx_ctl_status_cn61xx    cn63xxp1;
+	struct cvmx_pemx_ctl_status_cn61xx    cn66xx;
+	struct cvmx_pemx_ctl_status_cn61xx    cn68xx;
+	struct cvmx_pemx_ctl_status_cn61xx    cn68xxp1;
+	struct cvmx_pemx_ctl_status_s         cn70xx;
+	struct cvmx_pemx_ctl_status_s         cn78xx;
+	struct cvmx_pemx_ctl_status_cn61xx    cnf71xx;
+};
+typedef union cvmx_pemx_ctl_status cvmx_pemx_ctl_status_t;
+
+/**
+ * cvmx_pem#_ctl_status2
+ *
+ * Additional general control and status of the PEM.
+ *
+ */
+union cvmx_pemx_ctl_status2 {
+	uint64_t u64;
+	struct cvmx_pemx_ctl_status2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t inv_dpar                     : 1;  /**< Invert the generated parity to be written into the
-                                                         the most significant Data Queue Buffer ram block
-                                                         to force a parity error when it is later read. */
-	uint64_t inv_hpar                     : 1;  /**< Invert the generated parity to be written into the
-                                                         most significant Header Queue Buffer ram block
-                                                         to force a parity error when it is later read. */
-	uint64_t inv_rpar                     : 1;  /**< Invert the generated parity to be written into the
-                                                         most significant Retry Buffer ram block to force
-                                                         a parity error when it is later read. */
-	uint64_t auto_sd                      : 1;  /**< Link Hardware Autonomous Speed Disable. */
-	uint64_t dnum                         : 5;  /**< Primary bus device number. */
-	uint64_t pbus                         : 8;  /**< Primary bus number. */
+	uint64_t reserved_16_63               : 48;
 	uint64_t no_fwd_prg                   : 16; /**< The time x 0x10000 in core clocks to wait for the
                                                          TLP FIFOs to be able to unload an entry. If there is
                                                          no forward progress, such that the timeout occurs,
@@ -1589,61 +1577,17 @@ union cvmx_pemx_ctl_status {
                                                          (if enabled) will be asserted. Any more TLPs received
                                                          will be dropped on the floor and the credits
                                                          associated with those TLPs will be returned, as well.
+                                                         Note that 0xFFFF is a reserved value that will put
+                                                         the PEM in the 'forward progress stopped' state immediately.
                                                          This state will hold until a mac reset is received. */
-	uint64_t cfg_rtry                     : 16; /**< The time x 0x10000 in core clocks to wait for a
-                                                         CPL to a CFG RD that does not carry a Retry Status.
-                                                         Until such time that the timeout occurs and Retry
-                                                         Status is received for a CFG RD, the Read CFG Read
-                                                         will be resent. A value of 0 disables retries and
-                                                         treats a CPL Retry as a CPL UR.
-                                                         When enabled only one CFG RD may be issued until
-                                                         either successful completion or CPL UR. */
-	uint64_t reserved_11_14               : 4;
-	uint64_t pm_xtoff                     : 1;  /**< When WRITTEN with a '1' a single cycle pulse is
-                                                         to the PCIe core pm_xmt_turnoff port. RC mode. */
-	uint64_t pm_xpme                      : 1;  /**< When WRITTEN with a '1' a single cycle pulse is
-                                                         to the PCIe core pm_xmt_pme port. EP mode. */
-	uint64_t ob_p_cmd                     : 1;  /**< When WRITTEN with a '1' a single cycle pulse is
-                                                         to the PCIe core outband_pwrup_cmd port. EP mode. */
-	uint64_t reserved_7_7                 : 1;
-	uint64_t nf_ecrc                      : 1;  /**< Do not forward peer-to-peer ECRC TLPs. */
-	uint64_t dly_one                      : 1;  /**< When set the output client state machines will
-                                                         wait one cycle before starting a new TLP out. */
-	uint64_t lnk_enb                      : 1;  /**< When set '1' the link is enabled when '0' the
-                                                         link is disabled. This bit only is active when in
-                                                         RC mode. */
-	uint64_t ro_ctlp                      : 1;  /**< When set '1' C-TLPs that have the RO bit set will
-                                                         not wait for P-TLPs that normaly would be sent
-                                                         first. */
-	uint64_t fast_lm                      : 1;  /**< When '1' forces fast link mode. */
-	uint64_t inv_ecrc                     : 1;  /**< When '1' causes the LSB of the ECRC to be inverted. */
-	uint64_t inv_lcrc                     : 1;  /**< When '1' causes the LSB of the LCRC to be inverted. */
 #else
-	uint64_t inv_lcrc                     : 1;
-	uint64_t inv_ecrc                     : 1;
-	uint64_t fast_lm                      : 1;
-	uint64_t ro_ctlp                      : 1;
-	uint64_t lnk_enb                      : 1;
-	uint64_t dly_one                      : 1;
-	uint64_t nf_ecrc                      : 1;
-	uint64_t reserved_7_7                 : 1;
-	uint64_t ob_p_cmd                     : 1;
-	uint64_t pm_xpme                      : 1;
-	uint64_t pm_xtoff                     : 1;
-	uint64_t reserved_11_14               : 4;
-	uint64_t cfg_rtry                     : 16;
 	uint64_t no_fwd_prg                   : 16;
-	uint64_t pbus                         : 8;
-	uint64_t dnum                         : 5;
-	uint64_t auto_sd                      : 1;
-	uint64_t inv_rpar                     : 1;
-	uint64_t inv_hpar                     : 1;
-	uint64_t inv_dpar                     : 1;
+	uint64_t reserved_16_63               : 48;
 #endif
-	} cn78xx;
-	struct cvmx_pemx_ctl_status_cn61xx    cnf71xx;
+	} s;
+	struct cvmx_pemx_ctl_status2_s        cn78xx;
 };
-typedef union cvmx_pemx_ctl_status cvmx_pemx_ctl_status_t;
+typedef union cvmx_pemx_ctl_status2 cvmx_pemx_ctl_status2_t;
 
 /**
  * cvmx_pem#_dbg_info
diff --git a/arch/mips/include/asm/octeon/cvmx-pescx-defs.h b/arch/mips/include/asm/octeon/cvmx-pescx-defs.h
index 354e0d4..58f27d4 100644
--- a/arch/mips/include/asm/octeon/cvmx-pescx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pescx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pexp-defs.h b/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
index ffcadf9..f9eede7 100644
--- a/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pip-defs.h b/arch/mips/include/asm/octeon/cvmx-pip-defs.h
index 614ed1d..e50242c 100644
--- a/arch/mips/include/asm/octeon/cvmx-pip-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pip-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index 516d5f3..77eba7e 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pko-defs.h b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
index 59a4425..c95ae00 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-pow-defs.h b/arch/mips/include/asm/octeon/cvmx-pow-defs.h
index 68b54d1..664c9c6 100644
--- a/arch/mips/include/asm/octeon/cvmx-pow-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pow-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -710,30 +710,23 @@ typedef union cvmx_pow_ds_pc cvmx_pow_ds_pc_t;
  *
  * Contains the single and double error bits and the corresponding interrupt enables for the ECC-
  * protected POW index memory.  Also contains the syndrome value in the event of an ECC error.
- * Also contains the remote pointer error bit and interrupt enable.  RPE is set when the POW
- * detected
- * corruption on one or more of the input queue lists in L2/DRAM (POW's local copy of the tail
- * pointer
+ * Also contains the remote pointer error bit and interrupt enable.  RPE is set when the POW detected
+ * corruption on one or more of the input queue lists in L2/DRAM (POW's local copy of the tail pointer
  * for the L2/DRAM input queue did not match the last entry on the the list).   This is caused by
- * L2/DRAM corruption, and is generally a fatal error because it likely caused POW to load bad
- * work
+ * L2/DRAM corruption, and is generally a fatal error because it likely caused POW to load bad work
  * queue entries.
  * This register also contains the illegal operation error bits and the corresponding interrupt
  * enables as follows:
- * <0> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP from PP in NULL_NULL state
- * <1> Received SWTAG/SWTAG_DESCH/DESCH/UPD_WQP from PP in NULL state
- * <2> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/GET_WORK from PP with pending tag switch to ORDERED
- * or ATOMIC
- * <3> Received SWTAG/SWTAG_FULL/SWTAG_DESCH from PP with tag specified as NULL_NULL
- * <4> Received SWTAG_FULL/SWTAG_DESCH from PP with tag specified as NULL
- * <5> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with GET_WORK
- * pending
- * <6> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with NULL_RD
- * pending
- * <7> Received CLR_NSCHED from PP with SWTAG_DESCH/DESCH/CLR_NSCHED pending
- * <8> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with
- * CLR_NSCHED pending
- * <9> Received illegal opcode
+ *  <0> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP from PP in NULL_NULL state
+ *  <1> Received SWTAG/SWTAG_DESCH/DESCH/UPD_WQP from PP in NULL state
+ *  <2> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/GET_WORK from PP with pending tag switch to ORDERED or ATOMIC
+ *  <3> Received SWTAG/SWTAG_FULL/SWTAG_DESCH from PP with tag specified as NULL_NULL
+ *  <4> Received SWTAG_FULL/SWTAG_DESCH from PP with tag specified as NULL
+ *  <5> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with GET_WORK pending
+ *  <6> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with NULL_RD pending
+ *  <7> Received CLR_NSCHED from PP with SWTAG_DESCH/DESCH/CLR_NSCHED pending
+ *  <8> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with CLR_NSCHED pending
+ *  <9> Received illegal opcode
  * <10> Received ADD_WORK with tag specified as NULL_NULL
  * <11> Received DBG load from PP with DBG load pending
  * <12> Received CSR load from PP with CSR load pending
@@ -890,8 +883,7 @@ typedef union cvmx_pow_iq_com_cnt cvmx_pow_iq_com_cnt_t;
 /**
  * cvmx_pow_iq_int
  *
- * "Contains the bits (1 per QOS level) that can trigger the input queue interrupt.  An IQ_INT
- * bit
+ * "Contains the bits (1 per QOS level) that can trigger the input queue interrupt.  An IQ_INT bit
  * will be set if POW_IQ_CNT#QOS# changes and the resulting value is equal to POW_IQ_THR#QOS#."
  */
 union cvmx_pow_iq_int {
@@ -1051,33 +1043,26 @@ typedef union cvmx_pow_nos_cnt cvmx_pow_nos_cnt_t;
  * cvmx_pow_nw_tim
  *
  * Sets the minimum period for a new work request timeout.  Period is specified in n-1 notation
- * where the increment value is 1024 clock cycles.  Thus, a value of 0x0 in this register
- * translates
- * to 1024 cycles, 0x1 translates to 2048 cycles, 0x2 translates to 3072 cycles, etc...  Note:
- * the
- * maximum period for a new work request timeout is 2 times the minimum period.  Note: the new
- * work
+ * where the increment value is 1024 clock cycles.  Thus, a value of 0x0 in this register translates
+ * to 1024 cycles, 0x1 translates to 2048 cycles, 0x2 translates to 3072 cycles, etc...  Note: the
+ * maximum period for a new work request timeout is 2 times the minimum period.  Note: the new work
  * request timeout counter is reset when this register is written.
  * There are two new work request timeout cases:
  * - WAIT bit clear.  The new work request can timeout if the timer expires before the pre-fetch
- * engine has reached the end of all work queues.  This can occur if the executable work queue
- * entry is deep in the queue and the pre-fetch engine is subject to many resets (i.e. high
- * switch,
- * de-schedule, or new work load from other PP's).  Thus, it is possible for a PP to receive a
- * work
- * response with the NO_WORK bit set even though there was at least one executable entry in the
- * work queues.  The other (and typical) scenario for receiving a NO_WORK response with the WAIT
- * bit clear is that the pre-fetch engine has reached the end of all work queues without finding
- * executable work.
+ *   engine has reached the end of all work queues.  This can occur if the executable work queue
+ *   entry is deep in the queue and the pre-fetch engine is subject to many resets (i.e. high switch,
+ *   de-schedule, or new work load from other PP's).  Thus, it is possible for a PP to receive a work
+ *   response with the NO_WORK bit set even though there was at least one executable entry in the
+ *   work queues.  The other (and typical) scenario for receiving a NO_WORK response with the WAIT
+ *   bit clear is that the pre-fetch engine has reached the end of all work queues without finding
+ *   executable work.
  * - WAIT bit set.  The new work request can timeout if the timer expires before the pre-fetch
- * engine has found executable work.  In this case, the only scenario where the PP will receive a
- * work response with the NO_WORK bit set is if the timer expires.  Note: it is still possible
- * for
- * a PP to receive a NO_WORK response even though there was at least one executable entry in the
- * work queues.
+ *   engine has found executable work.  In this case, the only scenario where the PP will receive a
+ *   work response with the NO_WORK bit set is if the timer expires.  Note: it is still possible for
+ *   a PP to receive a NO_WORK response even though there was at least one executable entry in the
+ *   work queues.
  * In either case, it's important to note that switches and de-schedules are higher priority
- * operations that can cause the pre-fetch engine to reset.  Thus in a system with many switches
- * or
+ * operations that can cause the pre-fetch engine to reset.  Thus in a system with many switches or
  * de-schedules occuring, it's possible for the new work timer to expire (resulting in NO_WORK
  * responses) before the pre-fetch engine is able to get very deep into the work queues.
  */
@@ -1151,14 +1136,11 @@ typedef union cvmx_pow_pf_rst_msk cvmx_pow_pf_rst_msk_t;
  *
  * Selects which group(s) a PP belongs to.  A '1' in any bit position sets the PP's membership in
  * the corresponding group.  A value of 0x0 will prevent the PP from receiving new work.  Note:
- * disabled or non-existent PP's should have this field set to 0xffff (the reset value) in order
- * to
+ * disabled or non-existent PP's should have this field set to 0xffff (the reset value) in order to
  * maximize POW performance.
- * Also contains the QOS level priorities for each PP.  0x0 is highest priority, and 0x7 the
- * lowest.
+ * Also contains the QOS level priorities for each PP.  0x0 is highest priority, and 0x7 the lowest.
  * Setting the priority to 0xf will prevent that PP from receiving work from that QOS level.
- * Priority values 0x8 through 0xe are reserved and should not be used.  For a given PP,
- * priorities
+ * Priority values 0x8 through 0xe are reserved and should not be used.  For a given PP, priorities
  * should begin at 0x0 and remain contiguous throughout the range.
  */
 union cvmx_pow_pp_grp_mskx {
@@ -1219,17 +1201,12 @@ typedef union cvmx_pow_pp_grp_mskx cvmx_pow_pp_grp_mskx_t;
 /**
  * cvmx_pow_qos_rnd#
  *
- * Contains the round definitions for issuing new work.  Each round consists of 8 bits with each
- * bit
+ * Contains the round definitions for issuing new work.  Each round consists of 8 bits with each bit
  * corresponding to a QOS level.  There are 4 rounds contained in each register for a total of 32
- * rounds.  The issue logic traverses through the rounds sequentially (lowest round to highest
- * round)
- * in an attempt to find new work for each PP.  Within each round, the issue logic traverses
- * through
- * the QOS levels sequentially (highest QOS to lowest QOS) skipping over each QOS level with a
- * clear
- * bit in the round mask.  Note: setting a QOS level to all zeroes in all issue round registers
- * will
+ * rounds.  The issue logic traverses through the rounds sequentially (lowest round to highest round)
+ * in an attempt to find new work for each PP.  Within each round, the issue logic traverses through
+ * the QOS levels sequentially (highest QOS to lowest QOS) skipping over each QOS level with a clear
+ * bit in the round mask.  Note: setting a QOS level to all zeroes in all issue round registers will
  * prevent work from being issued from that QOS level.
  */
 union cvmx_pow_qos_rndx {
@@ -1272,13 +1249,10 @@ typedef union cvmx_pow_qos_rndx cvmx_pow_qos_rndx_t;
 /**
  * cvmx_pow_qos_thr#
  *
- * Contains the thresholds for allocating POW internal storage buffers.  If the number of
- * remaining
- * free buffers drops below the minimum threshold (MIN_THR) or the number of allocated buffers
- * for
+ * Contains the thresholds for allocating POW internal storage buffers.  If the number of remaining
+ * free buffers drops below the minimum threshold (MIN_THR) or the number of allocated buffers for
  * this QOS level rises above the maximum threshold (MAX_THR), future incoming work queue entries
- * will be buffered externally rather than internally.  This register also contains a read-only
- * count
+ * will be buffered externally rather than internally.  This register also contains a read-only count
  * of the current number of free buffers (FREE_CNT), the number of internal buffers currently
  * allocated to this QOS level (BUF_CNT), and the total number of buffers on the de-schedule list
  * (DES_CNT) (which is not the same as the total number of de-scheduled buffers).
@@ -1537,8 +1511,7 @@ typedef union cvmx_pow_wa_pcx cvmx_pow_wa_pcx_t;
  * cvmx_pow_wq_int
  *
  * Contains the bits (1 per group) that set work queue interrupts and are used to clear these
- * interrupts.  Also contains the input queue interrupt temporary disable bits (1 per group).
- * For
+ * interrupts.  Also contains the input queue interrupt temporary disable bits (1 per group). For
  * more information regarding this register, see the interrupt section.
  */
 union cvmx_pow_wq_int {
@@ -1768,8 +1741,7 @@ typedef union cvmx_pow_wq_int_cntx cvmx_pow_wq_int_cntx_t;
 /**
  * cvmx_pow_wq_int_pc
  *
- * Contains the threshold value for the work queue interrupt periodic counter and also a read-
- * only
+ * Contains the threshold value for the work queue interrupt periodic counter and also a read-only
  * copy of the periodic counter.  For more information regarding this register, see the interrupt
  * section.
  */
@@ -1816,8 +1788,7 @@ typedef union cvmx_pow_wq_int_pc cvmx_pow_wq_int_pc_t;
  * Contains the thresholds for enabling and setting work queue interrupts.  For more information
  * regarding this register, see the interrupt section.
  * Note: Up to 4 of the POW's internal storage buffers can be allocated for hardware use and are
- * therefore not available for incoming work queue entries.  Additionally, any PP that is not in
- * the
+ * therefore not available for incoming work queue entries.  Additionally, any PP that is not in the
  * NULL_NULL state consumes a buffer.  Thus in a 4 PP system, it is not advisable to set either
  * IQ_THR or DS_THR to greater than 512 - 4 - 4 = 504.  Doing so may prevent the interrupt from
  * ever triggering.
diff --git a/arch/mips/include/asm/octeon/cvmx-qlm.h b/arch/mips/include/asm/octeon/cvmx-qlm.h
index 7ea006d..460027b 100644
--- a/arch/mips/include/asm/octeon/cvmx-qlm.h
+++ b/arch/mips/include/asm/octeon/cvmx-qlm.h
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 87408 $<hr>
+ * <hr>$Revision: 87866 $<hr>
  */
 
 #ifndef __CVMX_QLM_H__
@@ -169,6 +169,7 @@ enum cvmx_qlm_mode {
 	CVMX_QLM_MODE_PCIE,	/* gen2 / gen1 */
 	CVMX_QLM_MODE_PCIE_1X2,	/* 1x2 gen2 / gen1 */
 	CVMX_QLM_MODE_PCIE_2X1,	/* 2x1 gen2 / gen1 */
+	CVMX_QLM_MODE_PCIE_1X1,	/* 1x1 gen2 / gen1 */
 	CVMX_QLM_MODE_SRIO_1X4,	/* 1x4 short / long */
 	CVMX_QLM_MODE_SRIO_2X2,	/* 2x2 short / long */
 	CVMX_QLM_MODE_SRIO_4X1,	/* 4x1 short / long */
@@ -183,6 +184,7 @@ enum cvmx_qlm_mode {
 	CVMX_QLM_MODE_DISABLED_QSGMII,
 	CVMX_QLM_MODE_QSGMII_SGMII,
 	CVMX_QLM_MODE_RXAUI_1X2,
+	CVMX_QLM_MODE_SATA_2X1,
 };
 
 enum cvmx_gmx_inf_mode {
@@ -192,6 +194,27 @@ enum cvmx_gmx_inf_mode {
 	CVMX_GMX_INF_MODE_RXAUI = 3,     /* Only interface 0, interface 1 must be DISABLED */
 };
 
+/**
+ * These apply to DLM1 and DLM2 if its not in SATA mode
+ * Manual refers to lanes as follows:
+ *  DML 0 lane 0 == GSER0 lane 0
+ *  DML 0 lane 1 == GSER0 lane 1
+ *  DML 1 lane 2 == GSER1 lane 0
+ *  DML 1 lane 3 == GSER1 lane 1
+ *  DML 2 lane 4 == GSER2 lane 0
+ *  DML 2 lane 5 == GSER2 lane 1
+ */
+enum cvmx_pemx_cfg_mode {
+	CVMX_PEM_MD_GEN2_2LANE = 0,	/* Valid for PEM0(DLM1), PEM1(DLM2) */
+	CVMX_PEM_MD_GEN2_1LANE = 1,	/* Valid for PEM0(DLM1.0), PEM1(DLM1.1,DLM2.0), PEM2(DLM2.1) */
+	CVMX_PEM_MD_GEN2_4LANE = 2,	/* Valid for PEM0(DLM1-2) */
+	/* Reserved */
+	CVMX_PEM_MD_GEN1_2LANE = 4,	/* Valid for PEM0(DLM1), PEM1(DLM2) */
+	CVMX_PEM_MD_GEN1_1LANE = 5,	/* Valid for PEM0(DLM1.0), PEM1(DLM1.1,DLM2.0), PEM2(DLM2.1) */
+	CVMX_PEM_MD_GEN1_4LANE = 6,	/* Valid for PEM0(DLM1-2) */
+	/* Reserved */
+};
+
 /*
  * Read QLM and return mode.
  */
diff --git a/arch/mips/include/asm/octeon/cvmx-rnm-defs.h b/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
index b8df0c5..855c175 100644
--- a/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rnm-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index 198c884..86aa674 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
@@ -486,7 +486,10 @@ union cvmx_rst_pp_power {
 	struct cvmx_rst_pp_power_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t gate                         : 48; /**< When set, corresponding core has voltage removed to save power. */
+	uint64_t gate                         : 48; /**< Powerdown Enable.  When both a bit and the corresponding CIU3_PP_RST bit are set, the core
+                                                         has voltage removed to save power.
+                                                         In typical operation these bits are setup during initialization and PP resets are
+                                                         controlled through CIU3_PP_RST. */
 #else
 	uint64_t gate                         : 48;
 	uint64_t reserved_48_63               : 16;
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index 8e7dcc0..7a614e1 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-smix-defs.h b/arch/mips/include/asm/octeon/cvmx-smix-defs.h
index eae1bb21..9405d86 100644
--- a/arch/mips/include/asm/octeon/cvmx-smix-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-smix-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-spxx-defs.h b/arch/mips/include/asm/octeon/cvmx-spxx-defs.h
index d9e326d..0f246a7 100644
--- a/arch/mips/include/asm/octeon/cvmx-spxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-spxx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h b/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
index 0d11df11..4355cfb 100644
--- a/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sriomaintx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-sriox-defs.h b/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
index 4f46c7b..6fff67c 100644
--- a/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sriox-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-srxx-defs.h b/arch/mips/include/asm/octeon/cvmx-srxx-defs.h
index 48adf21..af7a998 100644
--- a/arch/mips/include/asm/octeon/cvmx-srxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-srxx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-sso-defs.h b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
index a6db03f..c1a61ce 100644
--- a/arch/mips/include/asm/octeon/cvmx-sso-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-stxx-defs.h b/arch/mips/include/asm/octeon/cvmx-stxx-defs.h
index 4e1f5ce..9499bdb 100644
--- a/arch/mips/include/asm/octeon/cvmx-stxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-stxx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h b/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
index a5c5c42..82342a7 100644
--- a/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-uctlx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h
index db7f03e..c7e8a4a 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbcx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h
index 6a952f8..bd5b4f2 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbnx-defs.h
@@ -1,5 +1,5 @@
 /***********************license start***************
- * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
  * reserved.
  *
  *
diff --git a/arch/mips/include/asm/octeon/octeon-model.h b/arch/mips/include/asm/octeon/octeon-model.h
index e12eaa6..8a51e8e 100644
--- a/arch/mips/include/asm/octeon/octeon-model.h
+++ b/arch/mips/include/asm/octeon/octeon-model.h
@@ -43,7 +43,7 @@
  * File defining different Octeon model IDs and macros to
  * compare them.
  *
- * <hr>$Revision: 84894 $<hr>
+ * <hr>$Revision: 88111 $<hr>
  */
 
 #ifndef __OCTEON_MODEL_H__
@@ -126,7 +126,6 @@ extern "C" {
  */
 #define OCTEON_CN68XX_PASS1_0   0x000d9100
 #define OCTEON_CN68XX_PASS1_1   0x000d9101
-#define OCTEON_CN68XX_PASS1_2   0x000d9102
 #define OCTEON_CN68XX_PASS2_0   0x000d9108
 #define OCTEON_CN68XX_PASS2_1   0x000d9109
 #define OCTEON_CN68XX_PASS2_2   0x000d910a
-- 
2.6.2

