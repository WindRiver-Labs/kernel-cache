From a31d6c2114aa551f02cf4e5f52cfdeb79c745f1e Mon Sep 17 00:00:00 2001
From: Peter Swain <peter.swain@cavium.com>
Date: Fri, 1 Nov 2013 19:42:56 -0700
Subject: [PATCH 373/974] MIPS: octeon-hw-status: fix refcounting

Increment parent.users on creation, not child.users!
Mark parent with .has_child when child created, avoiding "Mismatch" warning.
Added param octeon_hw_status.count_debug for noisy add/remove.
Unified printk()/WARN() style to use common prefix.
Bug#8548
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-hw-status.c | 82 ++++++++++++++++++++++++------
 1 file changed, 66 insertions(+), 16 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-hw-status.c b/arch/mips/cavium-octeon/octeon-hw-status.c
index 23db696..1632e9d 100644
--- a/arch/mips/cavium-octeon/octeon-hw-status.c
+++ b/arch/mips/cavium-octeon/octeon-hw-status.c
@@ -11,10 +11,13 @@
 #include <linux/notifier.h>
 #include <linux/export.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 
 #include <asm/octeon/octeon-hw-status.h>
 #include <asm/octeon/octeon.h>
 
+#define DRV_NAME "octeon-hw-status"
+
 static RAW_NOTIFIER_HEAD(octeon_hw_status_notifiers);
 
 int octeon_hw_status_notifier_register(struct notifier_block *nb)
@@ -29,6 +32,10 @@ int octeon_hw_status_notifier_unregister(struct notifier_block *nb)
 }
 EXPORT_SYMBOL(octeon_hw_status_notifier_unregister);
 
+enum { ref_max_users = 0xff, };
+static bool count_debug;
+module_param(count_debug, bool, 0644);
+
 struct octeon_hw_status_node {
 	struct octeon_hw_status_node *next; /* Child list */
 	struct octeon_hw_status_node *child;
@@ -216,14 +223,15 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 {
 	struct octeon_hw_status_data ohsd;
 	struct octeon_hw_status_node *root;
-	struct octeon_hw_status_node *n;
 	struct octeon_hw_status_node *w;
 	struct octeon_hw_status_node *new_root;
 	struct octeon_hw_status_node *new_child;
 	struct find_node_cb_data match = { .warn = false, };
+	bool oflow = false;
 	bool root_created = false;
+	bool created = false;
+	int siblings = 0;
 	int rv = 0;
-	int oflow;
 
 	if (!chain->reg_is_hwint)
 		return -EINVAL;
@@ -256,6 +264,7 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 
 	w = root;
 	while (chain->has_child) {
+		struct octeon_hw_status_node *n;
 		chain++;
 		n = find_child(w, chain, &match);
 		if (!n) {
@@ -265,8 +274,10 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 			}
 			n = new_child;
 			new_child = NULL;
+			match.r = n;
 			n->is_hwint = chain->reg_is_hwint;
 			n->ack_w1c = chain->ack_w1c;
+			n->users = 1;
 			if (n->is_hwint) {
 				n->hwint = chain->reg;
 			} else {
@@ -274,20 +285,38 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 				n->mask_reg = chain->mask_reg;
 				n->bit = chain->bit;
 			}
+
+			/* attach to parent */
+			n->parent = w;
 			n->next = w->child;
 			w->child = n;
-			n->parent = w;
+			chain->has_child = 1;
+
+			/* parent ref-count */
+			oflow = (w->users == ref_max_users);
+			if (!oflow)
+				w->users++;
+			siblings = w->users;
+			created = true;
+			break;
 		}
 		w = n;
 	}
-	w->users++;
-	oflow = !w->users;
 
 	write_unlock(&octeon_hw_status_lock);
 
-	WARN(oflow, "Reference count overflowed!");
-	WARN(match.warn, "Mismatched properties %p, %d, %d, %d",
-	     match.r->child, match.sr->has_child, match.r->ack_w1c, match.sr->ack_w1c);
+	if (count_debug) {
+		if (root_created)
+			printk(DRV_NAME " %llx/%llx:%d created root\n",
+				chain->reg, chain->mask_reg, chain->bit);
+		printk(DRV_NAME " %llx/%llx:%d refcount %s%d\n",
+			match.r->reg, match.r->mask_reg, match.r->bit,
+			created ? "++" : "", siblings);
+	}
+	WARN(oflow, DRV_NAME " Reference count overflowed!\n");
+	WARN(match.warn, DRV_NAME " Mismatched properties %p, %d, %d, %d\n",
+		 match.r->child, match.sr->has_child,
+		 match.r->ack_w1c, match.sr->ack_w1c);
 
 	if (root_created) {
 		/* register an interrupt handler */
@@ -298,8 +327,8 @@ int octeon_hw_status_add_source(struct octeon_hw_status_reg *chain)
 		}
 
 		rv = request_threaded_irq(root->irq, NULL, octeon_hw_status_irq,
-					  IRQF_ONESHOT, "octeon-hw-status", root);
-		WARN(rv, "request_threaded_irq failed: %d", rv);
+				          IRQF_ONESHOT, DRV_NAME, root);
+		WARN(rv, DRV_NAME " request_threaded_irq failed: %d\n", rv);
 	}
 
 	ohsd.reg = w->reg;
@@ -312,6 +341,9 @@ bye:
 		kfree(new_root);
 	if (new_child)
 		kfree(new_child);
+	if (rv && count_debug)
+		printk(DRV_NAME " %llx/%llx:%d err %d\n",
+			chain->reg, chain->mask_reg, chain->bit, rv);
 	return rv;
 unlock:
 	write_unlock(&octeon_hw_status_lock);
@@ -368,6 +400,8 @@ int octeon_hw_status_remove_source(struct octeon_hw_status_reg *leaf)
 	bool already_unlocked = false;
 	struct octeon_hw_status_node *n;
 	struct find_node_cb_data d = { .warn  = false, };
+	bool oflow = false;
+	bool gone = false;
 
 	write_lock(&octeon_hw_status_lock);
 
@@ -377,16 +411,30 @@ int octeon_hw_status_remove_source(struct octeon_hw_status_reg *leaf)
 		goto out;
 	}
 
-	n->users--;
-	if (n->users == 0)
-		already_unlocked = dispose_of_node(n);
+	/* Can't Happen: count overflowed, so decrement unsafe */
+	oflow = (n->users == ref_max_users);
+	if (!oflow) {
+		n->users--;
+		if (n->users == 0) {
+			gone = true;
+			/* should clear parent->has_child if was last, free parent */
+			already_unlocked = dispose_of_node(n);
+		}
+	}
 out:
 	if (!already_unlocked)
 		write_unlock(&octeon_hw_status_lock);
 
-	WARN(d.warn, "Mismatched properties %p, %d, %d, %d",
+	WARN(d.warn, DRV_NAME " Mismatched properties %p, %d, %d, %d\n",
 	     d.r->child, d.sr->has_child, d.r->ack_w1c, d.sr->ack_w1c);
 
+	if (count_debug && gone)
+		printk(DRV_NAME " %llx:%d gone\n",
+			d.r->reg, d.r->bit);
+	else if (count_debug)
+		printk(DRV_NAME " %llx:%d refcount --%d@%p\n",
+			d.r->reg, d.r->bit, n->users, n);
+
 	return rv;
 }
 EXPORT_SYMBOL(octeon_hw_status_remove_source);
@@ -433,7 +481,8 @@ int octeon_hw_status_enable(u64 reg, u64 bit_mask)
 
 	read_unlock(&octeon_hw_status_lock);
 
-	WARN(cbd.warn_mask, "mask reg mismatch %llu %llu", cbd.reg, cbd.warn_mask);
+	WARN(cbd.warn_mask, DRV_NAME " mask reg mismatch %llu %llu\n",
+		cbd.reg, cbd.warn_mask);
 
 	return 0;
 }
@@ -459,7 +508,8 @@ int octeon_hw_status_disable(u64 reg, u64 bit_mask)
 
 	read_unlock(&octeon_hw_status_lock);
 
-	WARN(cbd.warn_mask, "mask reg mismatch %llu %llu", cbd.reg, cbd.warn_mask);
+	WARN(cbd.warn_mask, DRV_NAME " mask reg mismatch %llu %llu\n",
+		cbd.reg, cbd.warn_mask);
 
 	return 0;
 }
-- 
2.6.2

