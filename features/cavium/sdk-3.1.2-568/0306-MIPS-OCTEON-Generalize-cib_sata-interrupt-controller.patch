From af8091ab5fe8c67b6b56582dd8281b02b876c8e6 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 25 Sep 2013 10:29:21 -0700
Subject: [PATCH 306/974] MIPS: OCTEON: Generalize cib_sata interrupt
 controller support for all cib.

Configured from the device tree, this should now handle:

L2C, LMC, RST, SATA, USBDRD and OCLA blocks.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c | 144 +++++++++++++++++++++++------------
 1 file changed, 94 insertions(+), 50 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index c8b3300..7b0d12a 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -2391,47 +2391,55 @@ static int __init octeon_irq_init_ciu3(struct device_node *ciu_node,
 	return 0;
 }
 
-struct octeon_irq_cibsata_data {
-	int bit;
+struct octeon_irq_cib_host_data {
+	raw_spinlock_t lock;
+	u64 raw_reg;
+	u64 en_reg;
+	int max_bits;
 };
 
-static DEFINE_RAW_SPINLOCK(octeon_irq_cibsata_lock);
+struct octeon_irq_cib_chip_data {
+	struct octeon_irq_cib_host_data *host_data;
+	int bit;
+};
 
-static void octeon_irq_cibsata_enable(struct irq_data *data)
+static void octeon_irq_cib_enable(struct irq_data *data)
 {
 	unsigned long flags;
 	u64 en;
-	struct octeon_irq_cibsata_data *cd = irq_data_get_irq_chip_data(data);
+	struct octeon_irq_cib_chip_data *cd = irq_data_get_irq_chip_data(data);
+	struct octeon_irq_cib_host_data *host_data = cd->host_data;
 
-	raw_spin_lock_irqsave(&octeon_irq_cibsata_lock, flags);
-	en = cvmx_read_csr(CVMX_CIU_CIB_SATA_ENX(0));
+	raw_spin_lock_irqsave(&host_data->lock, flags);
+	en = cvmx_read_csr(host_data->en_reg);
 	en |= 1ull < cd->bit;
-	cvmx_write_csr(CVMX_CIU_CIB_SATA_ENX(0), en);
-	raw_spin_unlock_irqrestore(&octeon_irq_cibsata_lock, flags);
+	cvmx_write_csr(host_data->en_reg, en);
+	raw_spin_unlock_irqrestore(&host_data->lock, flags);
 }
 
-static void octeon_irq_cibsata_disable(struct irq_data *data)
+static void octeon_irq_cib_disable(struct irq_data *data)
 {
 	unsigned long flags;
 	u64 en;
-	struct octeon_irq_cibsata_data *cd = irq_data_get_irq_chip_data(data);
+	struct octeon_irq_cib_chip_data *cd = irq_data_get_irq_chip_data(data);
+	struct octeon_irq_cib_host_data *host_data = cd->host_data;
 
-	raw_spin_lock_irqsave(&octeon_irq_cibsata_lock, flags);
-	en = cvmx_read_csr(CVMX_CIU_CIB_SATA_ENX(0));
+	raw_spin_lock_irqsave(&host_data->lock, flags);
+	en = cvmx_read_csr(host_data->en_reg);
 	en &= ~(1ull < cd->bit);
-	cvmx_write_csr(CVMX_CIU_CIB_SATA_ENX(0), en);
-	raw_spin_unlock_irqrestore(&octeon_irq_cibsata_lock, flags);
+	cvmx_write_csr(host_data->en_reg, en);
+	raw_spin_unlock_irqrestore(&host_data->lock, flags);
 }
 
-static struct irq_chip octeon_irq_chip_cibsata = {
+static struct irq_chip octeon_irq_chip_cib = {
 	.name = "CIU3",
-	.irq_enable = octeon_irq_cibsata_enable,
-	.irq_disable = octeon_irq_cibsata_disable,
-	.irq_mask = octeon_irq_cibsata_disable,
-	.irq_unmask = octeon_irq_cibsata_enable,
+	.irq_enable = octeon_irq_cib_enable,
+	.irq_disable = octeon_irq_cib_disable,
+	.irq_mask = octeon_irq_cib_disable,
+	.irq_unmask = octeon_irq_cib_enable,
 };
 
-static int octeon_irq_cibsata_xlat(struct irq_domain *d,
+static int octeon_irq_cib_xlat(struct irq_domain *d,
 				   struct device_node *node,
 				   const u32 *intspec,
 				   unsigned int intsize,
@@ -2443,50 +2451,59 @@ static int octeon_irq_cibsata_xlat(struct irq_domain *d,
 	return 0;
 }
 
-static int octeon_irq_cibsata_map(struct irq_domain *d,
+static int octeon_irq_cib_map(struct irq_domain *d,
 				  unsigned int virq, irq_hw_number_t hw)
 {
-	struct octeon_irq_cibsata_data *cd;
+	struct octeon_irq_cib_host_data *host_data = d->host_data;
+	struct octeon_irq_cib_chip_data *cd;
+
+	if (hw >= host_data->max_bits) {
+		pr_err("ERROR: %s mapping %u is to big!\n",
+		       d->of_node->name, (unsigned)hw);
+		return -EINVAL;
+	}
 
-	cd = kmalloc(sizeof(*cd), GFP_KERNEL);
+	cd = kzalloc(sizeof(*cd), GFP_KERNEL);
+	cd->host_data = host_data;
 	cd->bit = hw;
 
-	irq_set_chip_and_handler(virq, &octeon_irq_chip_cibsata,
+	irq_set_chip_and_handler(virq, &octeon_irq_chip_cib,
 				 handle_simple_irq);
 	irq_set_chip_data(virq, cd);
 	return 0;
 }
 
-static struct irq_domain_ops octeon_irq_domain_cibsata_ops = {
-	.map = octeon_irq_cibsata_map,
+static struct irq_domain_ops octeon_irq_domain_cib_ops = {
+	.map = octeon_irq_cib_map,
 	.unmap = octeon_irq_free_cd,
-	.xlate = octeon_irq_cibsata_xlat,
+	.xlate = octeon_irq_cib_xlat,
 };
 
 /* Chain to real handler. */
-static irqreturn_t octeon_irq_cibsata_handler(int my_irq, void *data)
+static irqreturn_t octeon_irq_cib_handler(int my_irq, void *data)
 {
 	u64 en;
 	u64 raw;
 	u64 bits;
 	int i;
 	int irq;
-	struct irq_domain *cibsata_domain = data;
+	struct irq_domain *cib_domain = data;
+	struct octeon_irq_cib_host_data *host_data = cib_domain->host_data;
 
-	en = cvmx_read_csr(CVMX_CIU_CIB_SATA_ENX(0));
-	raw = cvmx_read_csr(CVMX_CIU_CIB_SATA_RAWX(0));
+	en = cvmx_read_csr(host_data->en_reg);
+	raw = cvmx_read_csr(host_data->raw_reg);
 
 	bits = en & raw;
 
 	/* Acknologe the bits we will be sending. */
-	cvmx_write_csr(CVMX_CIU_CIB_SATA_RAWX(0), bits);
+	cvmx_write_csr(host_data->raw_reg, bits);
 
-	for (i = 0; i < 4; i++) {
+	for (i = 0; i < host_data->max_bits; i++) {
 		if ((bits & 1ull << i) == 0)
 			continue;
-		irq = irq_find_mapping(cibsata_domain, i);
+		irq = irq_find_mapping(cib_domain, i);
 		if (!irq)
-			pr_err("ERROR: No mapping for cibsata %d\n", i);
+			pr_err("ERROR: No mapping for cib %d\n", i);
 		else
 			generic_handle_irq(irq);
 	}
@@ -2494,34 +2511,62 @@ static irqreturn_t octeon_irq_cibsata_handler(int my_irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static int __init octeon_irq_init_cibsata(struct device_node *ciu_node,
-					  struct device_node *parent)
+static int __init octeon_irq_init_cib(struct device_node *ciu_node,
+				      struct device_node *parent)
 {
+	const __be32 *addr;
+	u32 val;
+	struct octeon_irq_cib_host_data *host_data;
 	int parent_irq;
 	int r;
-	struct irq_domain *cibsata_domain;
+	struct irq_domain *cib_domain;
 
 	parent_irq = irq_of_parse_and_map(ciu_node, 0);
 	if (!parent_irq) {
-		pr_err("ERROR: Couldn't acquire parent_irq\n.");
+		pr_err("ERROR: Couldn't acquire parent_irq for %s\n.", ciu_node->name);
 		return -EINVAL;
 	}
 
-	cibsata_domain = irq_domain_add_linear(ciu_node, 4,
-					       &octeon_irq_domain_cibsata_ops,
-					       NULL);
-	if (!cibsata_domain) {
+	host_data = kzalloc(sizeof(*host_data), GFP_KERNEL);
+	raw_spin_lock_init(&host_data->lock);
+
+	addr = of_get_address(ciu_node, 0, NULL, NULL);
+	if (!addr) {
+		pr_err("ERROR: Couldn't acquire reg(0) %s\n.", ciu_node->name);
+		return -EINVAL;
+	}
+	host_data->raw_reg = of_translate_address(ciu_node, addr);
+
+	addr = of_get_address(ciu_node, 1, NULL, NULL);
+	if (!addr) {
+		pr_err("ERROR: Couldn't acquire reg(1) %s\n.", ciu_node->name);
+		return -EINVAL;
+	}
+	host_data->en_reg = of_translate_address(ciu_node, addr);
+
+	r = of_property_read_u32(ciu_node, "cavium,max_bits", &val);
+	if (r) {
+		pr_err("ERROR: Couldn't read cavium,max_bits from %s\n.", ciu_node->name);
+		return r;
+	}
+	host_data->max_bits = val;
+
+	cib_domain = irq_domain_add_linear(ciu_node, host_data->max_bits,
+					   &octeon_irq_domain_cib_ops,
+					   host_data);
+	if (!cib_domain) {
 		pr_err("ERROR: Couldn't irq_domain_add_linear()\n.");
 		return -ENOMEM;
 	}
 
-	r = request_irq(parent_irq, octeon_irq_cibsata_handler, IRQF_NO_THREAD,
-			"cibsata", cibsata_domain);
+	r = request_irq(parent_irq, octeon_irq_cib_handler, 0,
+			"cib", cib_domain);
 	if (r) {
-		pr_err("request_irq cibsata failed %d\n", r);
+		pr_err("request_irq cib failed %d\n", r);
 		return r;
 	}
-	pr_info("interrupt controller probed: %s\n", ciu_node->name);
+	pr_info("interrupt controller probed: %s: %llx %llx %d\n",
+		ciu_node->name, host_data->raw_reg, host_data->en_reg, host_data->max_bits);
 	return 0;
 }
 
@@ -2530,8 +2575,7 @@ static struct of_device_id __initdata ciu_types[] = {
 	{.compatible = "cavium,octeon-3860-gpio", .data = octeon_irq_init_gpio},
 	{.compatible = "cavium,octeon-6880-ciu2", .data = octeon_irq_init_ciu2},
 	{.compatible = "cavium,octeon-7880-ciu3", .data = octeon_irq_init_ciu3},
-	{.compatible = "cavium,octeon-7130-cibsata", .data = octeon_irq_init_cibsata},
-	//{.compatible = "cavium,octeon-7130-cibusb", .data = octeon_irq_init_cibusb},
+	{.compatible = "cavium,octeon-7130-cib", .data = octeon_irq_init_cib},
 	{}
 };
 
-- 
2.6.2

