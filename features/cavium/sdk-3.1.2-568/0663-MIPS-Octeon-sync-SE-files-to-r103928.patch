From 115ca5c9a4c6747edb4f697d7c9b4932e2158472 Mon Sep 17 00:00:00 2001
From: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Date: Fri, 4 Jul 2014 18:05:50 -0700
Subject: [PATCH 663/974] MIPS: Octeon: sync SE files to r103928

[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../executive/cvmx-global-resources.c              |  15 +-
 .../cavium-octeon/executive/cvmx-helper-board.c    | 489 ++++++++---
 .../cavium-octeon/executive/cvmx-helper-pko3.c     |  15 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |  10 +-
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |  14 +-
 arch/mips/include/asm/octeon/cvmx-ase-defs.h       |  33 +-
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      | 147 ++--
 arch/mips/include/asm/octeon/cvmx-dpi-defs.h       | 215 ++++-
 arch/mips/include/asm/octeon/cvmx-fpa-defs.h       |  12 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     | 186 ++--
 arch/mips/include/asm/octeon/cvmx-helper-board.h   |  17 +-
 arch/mips/include/asm/octeon/cvmx-helper-cfg.h     |  13 -
 arch/mips/include/asm/octeon/cvmx-hna-defs.h       |   6 +-
 arch/mips/include/asm/octeon/cvmx-l2c-defs.h       |   8 +-
 arch/mips/include/asm/octeon/cvmx-lapx-defs.h      |  11 +-
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h      | 117 ++-
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       |  79 +-
 arch/mips/include/asm/octeon/cvmx-oclax-defs.h     |  26 +-
 arch/mips/include/asm/octeon/cvmx-ocx-defs.h       |   8 +-
 arch/mips/include/asm/octeon/cvmx-pciercx-defs.h   |  26 +-
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |   5 +-
 arch/mips/include/asm/octeon/cvmx-pko-defs.h       | 939 ++++++++++++++-------
 arch/mips/include/asm/octeon/cvmx-sli-defs.h       |  76 +-
 arch/mips/include/asm/octeon/cvmx-sso-defs.h       |   8 +-
 arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h   |   4 +-
 arch/mips/include/asm/octeon/octeon-model.h        |   3 +-
 26 files changed, 1745 insertions(+), 737 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-global-resources.c b/arch/mips/cavium-octeon/executive/cvmx-global-resources.c
index 4ff3232..153730f 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-global-resources.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-global-resources.c
@@ -112,7 +112,8 @@ typedef struct cvmx_global_resources
 CVMX_SHARED int cvmx_enable_helper_flag;
 CVMX_SHARED uint64_t cvmx_app_id;
 
-static int dbg = 0;
+static const int dbg = 0;
+
 extern int __cvmx_bootmem_phy_free(uint64_t phy_addr, uint64_t size, uint32_t flags);
 
 /*
@@ -569,15 +570,17 @@ void cvmx_global_resources_show(void)
 	entry_cnt = CVMX_GLOBAL_RESOURCES_GET_FIELD(entry_cnt);
 	memset (tagname, 0, MAX_RESOURCE_TAG_LEN + 1);
 
-	cvmx_dprintf("%s: cvmx-global-resources: \n",__FUNCTION__);
+	if (dbg)
+		cvmx_dprintf("%s: cvmx-global-resources: \n",__FUNCTION__);
 	for (count = 0; count < entry_cnt; count++) {
 		p = CVMX_GET_RESOURCE_ENTRY(count);
 		phys_addr = CVMX_RESOURCE_ENTRY_GET_FIELD(p, phys_addr);
 		rtag.lo = CVMX_RESOURCE_TAG_GET_FIELD(p, lo);
 		rtag.hi = CVMX_RESOURCE_TAG_GET_FIELD(p, hi);
 		__cvmx_get_tagname(&rtag, tagname);
-		cvmx_dprintf("Global Resource tag name: %s Resource Address: %llx\n",
-			     tagname, CAST_ULL(phys_addr));
+		if (dbg)
+			cvmx_dprintf("Global Resource tag name: %s Resource Address: %llx\n",
+				     tagname, CAST_ULL(phys_addr));
 	}
 
 	__cvmx_global_resource_unlock();
@@ -602,7 +605,9 @@ uint64_t cvmx_allocate_app_id(void)
 
 	cvmx_app_id = __atomic_add_fetch(vptr, 1, __ATOMIC_SEQ_CST);
 
-	cvmx_dprintf("CVMX_APP_ID = %lx.\n", (unsigned long)cvmx_app_id);
+	if (dbg)
+		cvmx_dprintf("CVMX_APP_ID = %lx.\n",
+			     (unsigned long)cvmx_app_id);
 	return cvmx_app_id;
 }
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
index d61eb54e..a607c4a 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
@@ -87,11 +87,61 @@
  * this pointer to a function before calling any cvmx-helper
  * operations.
  */
-CVMX_SHARED cvmx_helper_link_info_t(*cvmx_override_board_link_get) (int ipd_port) = NULL;
+CVMX_SHARED cvmx_helper_link_info_t(*cvmx_override_board_link_get)(int ipd_port) = NULL;
 
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 
 static const int device_tree_dbg = 0;
+#endif
+
+/**
+ * @INTERNAL
+ * Get link state of Cortina PHY
+ *
+ * @param phy_info PHY information
+ *
+ * @return link state information from PHY
+ */
+static cvmx_helper_link_info_t
+__cvmx_get_cortina_phy_link_state(cvmx_phy_info_t *phy_info);
+
+/**
+ * @INTERNAL
+ * Get link state of generic C45 compliant PHYs
+ */
+static cvmx_helper_link_info_t
+__get_generic_8023_c45_phy_link_state(cvmx_phy_info_t *phy_info);
+
+/**
+ * @INTERNAL
+ * Get link state of marvell PHY
+ */
+static cvmx_helper_link_info_t
+__get_marvell_phy_link_state(cvmx_phy_info_t *phy_info);
+
+/**
+ * @INTERNAL
+ * Get link state of broadcom PHY
+ *
+ * @param phy_info	PHY information
+ */
+static cvmx_helper_link_info_t
+__get_broadcom_phy_link_state(cvmx_phy_info_t *phy_info);
+
+#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
+/**
+ * @INTERNAL
+ * Get link state of generic gigabit PHY
+ *
+ * @param phy_info - information about the PHY
+ *
+ * @returns link status of the PHY
+ */
+static cvmx_helper_link_info_t
+__cvmx_get_generic_8023_c22_phy_link_state(cvmx_phy_info_t *phy_info);
+
+static cvmx_helper_link_info_t
+__cvmx_get_qualcomm_s17_phy_link_state(cvmx_phy_info_t *phy_info);
 
 static void cvmx_retry_i2c_write(int twsi_id, uint8_t dev_addr,
 				 uint16_t internal_addr, int num_bytes,
@@ -123,7 +173,7 @@ int __pip_eth_node(const void *fdt_addr, int aliases, int ipd_port)
 	int interface_index = cvmx_helper_get_interface_index_num(ipd_port);
 	cvmx_helper_interface_mode_t interface_mode =
 			 cvmx_helper_interface_get_mode(interface_num);
-	int dbg = device_tree_dbg;
+	const int dbg = device_tree_dbg;
 
 	/* The following are not found in the device tree */
 	switch (interface_mode) {
@@ -199,12 +249,12 @@ int __mix_eth_node(const void *fdt_addr, int aliases, int interface_index)
  * @INTERNAL
  * Switch MDIO mux to the specified port.
  */
-static int __switch_mdio_mux(int ipd_port, const cvmx_phy_info_t *phy_info);
+static int __switch_mdio_mux(const cvmx_phy_info_t *phy_info);
 
 static int __mdiobus_addr_to_unit(uint32_t addr)
 {
 	int unit = (addr >> 7) & 3;
-	if (!OCTEON_IS_MODEL(OCTEON_CN68XX) || !OCTEON_IS_MODEL(OCTEON_CN78XX))
+	if (!OCTEON_IS_MODEL(OCTEON_CN68XX) && !OCTEON_IS_MODEL(OCTEON_CN78XX))
 		unit >>= 1;
 	return unit;
 }
@@ -550,6 +600,9 @@ int __cvmx_helper_78xx_parse_phy(struct cvmx_phy_info *phy_info, int ipd_port)
 
 	phy = cvmx_helper_get_phy_fdt_node_offset(xiface, index);
 	if (phy < 0) {
+		/* If this is the first time through we need to first parse the
+		 * device tree to get the node offsets.
+		 */
 		if (device_tree_dbg)
 			cvmx_dprintf("No config present, calling __cvmx_helper_parse_78xx_bgx_dt\n");
 		if (__cvmx_helper_parse_78xx_bgx_dt(fdt_addr)) {
@@ -558,15 +611,16 @@ int __cvmx_helper_78xx_parse_phy(struct cvmx_phy_info *phy_info, int ipd_port)
 		}
 		phy = cvmx_helper_get_phy_fdt_node_offset(xiface, index);
 		if (phy < 0) {
-			//cvmx_dprintf("%s: Cannot find PHY node in device tree\n", __func__);
+			if (device_tree_dbg)
+				cvmx_dprintf("%s: Could not get PHY node offset for IPD port 0x%x\n",
+					     __func__, ipd_port);
 			return -1;
 		}
 	}
 
-	phy_info->direct_connect = 1;
 	compat = (const char *)fdt_getprop(fdt_addr, phy, "compatible", NULL);
 	if (!compat) {
-		cvmx_printf("ERROR: no compatible prop in phy\n");
+		cvmx_printf("ERROR: %d:%d:no compatible prop in phy\n", xiface, index);
 		return -1;
 	}
 
@@ -575,22 +629,45 @@ int __cvmx_helper_78xx_parse_phy(struct cvmx_phy_info *phy_info, int ipd_port)
 
 	phy_addr = cvmx_fdt_get_int(fdt_addr, phy, "reg", -1);
 	if (phy_addr == -1) {
-		cvmx_printf("Error: could not get PHY address\n");
+		cvmx_printf("Error: %d:%d:could not get PHY address\n",
+			    xiface, index);
 		return -1;
 	}
 	if (device_tree_dbg)
-		cvmx_dprintf("  PHY address: %d\n", phy_addr);
+		cvmx_dprintf("  PHY address: %d, compat: %s\n", phy_addr, compat);
 
-	if (!memcmp("marvell", compat, strlen("marvell")))
+	if (!memcmp("marvell", compat, strlen("marvell"))) {
 		phy_info->phy_type = MARVELL_GENERIC_PHY;
-	else if (!memcmp("broadcom", compat, strlen("broadcom")))
+		phy_info->link_function = __get_marvell_phy_link_state;
+	} else if (!memcmp("broadcom", compat, strlen("broadcom"))) {
 		phy_info->phy_type = BROADCOM_GENERIC_PHY;
+		phy_info->link_function = __get_broadcom_phy_link_state;
+	} else if (!memcmp("cortina", compat, strlen("cortina"))) {
+		phy_info->phy_type = CORTINA_PHY;
+		phy_info->link_function = __cvmx_get_cortina_phy_link_state;
+	}
+
+	phy_info->ipd_port = ipd_port;
+	phy_info->phy_sub_addr = 0;
+	phy_info->direct_connect = 1;
 
 	parent = fdt_parent_offset(fdt_addr, phy);
 	if (!fdt_node_check_compatible(fdt_addr, parent, "ethernet-phy-nexus")) {
-		parent = fdt_parent_offset(fdt_addr, parent);
 		if (device_tree_dbg)
 			cvmx_dprintf("  nexus PHY found\n");
+		if (phy_info->phy_type == CORTINA_PHY) {
+			/* The Cortina CS422X uses the same PHY device for
+			 * multiple ports for XFI.  In this case we use a
+			 * nexus and each PHY address is the slice or
+			 * sub-address and the actual PHY address is the
+			 * nexus address.
+			 */
+			phy_info->phy_sub_addr = phy_addr;
+			phy_addr = cvmx_fdt_get_int(fdt_addr, parent, "reg", -1);
+			if (device_tree_dbg)
+				cvmx_dprintf("  Cortina PHY real address: 0x%x\n", phy_addr);
+		}
+		parent = fdt_parent_offset(fdt_addr, parent);
 	}
 
 	if (device_tree_dbg) {
@@ -906,6 +983,9 @@ int __get_phy_info_from_dt(cvmx_phy_info_t *phy_info, int ipd_port)
 	int dbg = device_tree_dbg;
 	int interface;
 
+	if (device_tree_dbg)
+		cvmx_dprintf("%s(%p, %d)\n", __func__, phy_info, ipd_port);
+
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
 		return __cvmx_helper_78xx_parse_phy(phy_info, ipd_port);
 
@@ -916,6 +996,8 @@ int __get_phy_info_from_dt(cvmx_phy_info_t *phy_info, int ipd_port)
 	if (device_tree_dbg)
 		cvmx_dprintf("%s(%p, %d)\n", __func__, phy_info, ipd_port);
 	phy_info->phy_addr = -1;
+	phy_info->phy_sub_addr = 0;
+	phy_info->ipd_port = ipd_port;
 	phy_info->direct_connect = -1;
 	phy_info->phy_type = (cvmx_phy_type_t) -1;
 	for (i = 0; i < CVMX_PHY_MUX_MAX_GPIO; i++)
@@ -924,7 +1006,7 @@ int __get_phy_info_from_dt(cvmx_phy_info_t *phy_info, int ipd_port)
 	phy_info->gpio_value = -1;
 	phy_info->gpio_parent_mux_twsi = -1;
 	phy_info->gpio_parent_mux_select = -1;
-
+	phy_info->link_function = NULL;
 	if (!fdt_addr) {
 		cvmx_dprintf("No device tree found.\n");
 		return -1;
@@ -989,8 +1071,10 @@ int __get_phy_info_from_dt(cvmx_phy_info_t *phy_info, int ipd_port)
 			cvmx_dprintf("Marvell PHY detected for ipd_port %d\n",
 				     ipd_port);
 		phy_info->phy_type = MARVELL_GENERIC_PHY;
+		phy_info->link_function = __get_marvell_phy_link_state;
 	} else if (!memcmp("broadcom", phy_compatible_str, strlen("broadcom"))) {
 		phy_info->phy_type = BROADCOM_GENERIC_PHY;
+		phy_info->link_function = __get_broadcom_phy_link_state;
 		if (device_tree_dbg)
 			cvmx_dprintf("Broadcom PHY detected for ipd_port %d\n",
 				     ipd_port);
@@ -1001,15 +1085,20 @@ int __get_phy_info_from_dt(cvmx_phy_info_t *phy_info, int ipd_port)
 		if (!fdt_node_check_compatible(fdt_addr, phy,
 					       "ethernet-phy-ieee802.3-c22")) {
 			phy_info->phy_type = GENERIC_8023_C22_PHY;
+			phy_info->link_function =
+					__get_generic_8023_c45_phy_link_state;
 			if (device_tree_dbg)
 				cvmx_dprintf("Vitesse 802.3 c22 detected\n");
 		} else {
 			phy_info->phy_type = GENERIC_8023_C45_PHY;
+			phy_info->link_function =
+				__cvmx_get_generic_8023_c22_phy_link_state;
 			if (device_tree_dbg)
 				cvmx_dprintf("Vitesse 802.3 c45 detected\n");
 		}
 	} else if (!memcmp("cortina", phy_compatible_str, strlen("cortina"))) {
 		phy_info->phy_type = CORTINA_PHY;
+		phy_info->link_function = __cvmx_get_cortina_phy_link_state;
 		host_mode_str = (const char *)fdt_getprop(fdt_addr, phy,
 							  "cortina,host-mode",
 							  NULL);
@@ -1018,7 +1107,7 @@ int __get_phy_info_from_dt(cvmx_phy_info_t *phy_info, int ipd_port)
 				     ipd_port);
 	} else if (!memcmp("ti", phy_compatible_str, strlen("ti"))) {
 		phy_info->phy_type = GENERIC_8023_C45_PHY;
-
+		phy_info->link_function = __get_generic_8023_c45_phy_link_state;
 		if (device_tree_dbg)
 			cvmx_dprintf("TI PHY detected for ipd_port %d\n",
 				     ipd_port);
@@ -1027,21 +1116,26 @@ int __get_phy_info_from_dt(cvmx_phy_info_t *phy_info, int ipd_port)
 		   !fdt_node_check_compatible(fdt_addr, phy, "atheros,ar8337") ||
 		   !fdt_node_check_compatible(fdt_addr, phy, "qualcomm,qca8337")) {
 		phy_info->phy_type = QUALCOMM_S17;
+		phy_info->link_function = __cvmx_get_qualcomm_s17_phy_link_state;
 		if (device_tree_dbg)
 			cvmx_dprintf("Qualcomm QCA833X switch detected\n");
 	} else if (!fdt_node_check_compatible(fdt_addr, phy,
 					      "ethernet-phy-ieee802.3-c22")) {
 		phy_info->phy_type = GENERIC_8023_C22_PHY;
+		phy_info->link_function =
+				__cvmx_get_generic_8023_c22_phy_link_state;
 		if (device_tree_dbg)
 			cvmx_dprintf("Generic 802.3 c22 PHY detected\n");
 	} else if (!fdt_node_check_compatible(fdt_addr, phy,
 					      "ethernet-phy-ieee802.3-c45")) {
 		phy_info->phy_type = GENERIC_8023_C45_PHY;
+		phy_info->link_function = __get_generic_8023_c45_phy_link_state;
 		if (device_tree_dbg)
 			cvmx_dprintf("Generic 802.3 c45 PHY detected\n");
 	} else {
 		cvmx_dprintf("Unknown PHY compatibility\n");
 		phy_info->phy_type = -1;
+		phy_info->link_function = NULL;
 	}
 
 	phy_info->host_mode = CVMX_PHY_HOST_MODE_UNKNOWN;
@@ -1106,7 +1200,8 @@ int __get_phy_info_from_dt(cvmx_phy_info_t *phy_info, int ipd_port)
 		}
 		/* Find the GPIO MUX controller */
 	}
-	ret = fdt_node_check_compatible(fdt_addr, phy_parent, "cavium,octeon-3860-mdio");
+	ret = fdt_node_check_compatible(fdt_addr, phy_parent,
+					"cavium,octeon-3860-mdio");
 	if (ret == 0) {
 		uint32_t *mdio_reg_base = (uint32_t *) fdt_getprop(fdt_addr, phy_parent, "reg", 0);
 		phy_info->direct_connect = 1;
@@ -1234,7 +1329,7 @@ cvmx_phy_host_mode_t cvmx_helper_board_get_phy_host_mode(int ipd_port)
 int cvmx_helper_board_get_mii_address(int ipd_port)
 {
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
-	int dbg = device_tree_dbg;
+	const int dbg = device_tree_dbg;
 #endif
 	if (cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM)
 		return -1;
@@ -1242,24 +1337,40 @@ int cvmx_helper_board_get_mii_address(int ipd_port)
 
 	if (cvmx_sysinfo_get()->fdt_addr) {
 		cvmx_phy_info_t phy_info;
-		int retcode = __get_phy_info_from_dt(&phy_info, ipd_port);
+		int retcode;
+
+		if (dbg)
+			cvmx_dprintf("%s(0x%x) getting phy info from device tree\n",
+				     __func__, ipd_port);
+		memset(&phy_info, 0, sizeof(phy_info));
+		retcode = __get_phy_info_from_dt(&phy_info, ipd_port);
 
 		if (retcode == -2) {
+			if (device_tree_dbg)
+				cvmx_dprintf("%s(0x%x): phy info missing in device tree\n",
+					     __func__, ipd_port);
 			return retcode;
 		} else if (retcode < 0) {
-			if (dbg)
+			if (device_tree_dbg)
 				cvmx_dprintf("%s: could not get phy info for port %d\n",
 					     __func__, ipd_port);
 			return retcode;
 		}
+		if (device_tree_dbg)
+			cvmx_dprintf("%s: phy address: 0x%x\n",
+				     __func__, phy_info.phy_addr);
 		if (phy_info.phy_addr >= 0) {
 			if (phy_info.direct_connect == 0) {
 				if (device_tree_dbg)
 					cvmx_dprintf("%s: Phy at address %d not directly connected, configuring mux\n",
 						     __func__,
 						     phy_info.phy_addr);
-				__switch_mdio_mux(ipd_port, &phy_info);
+				__switch_mdio_mux(&phy_info);
 			}
+			if (device_tree_dbg)
+				cvmx_dprintf("%s(0x%x): PHY address: 0x%x\n",
+					     __func__, ipd_port,
+					     phy_info.phy_addr);
 			return phy_info.phy_addr;
 		}
 	}
@@ -1474,36 +1585,71 @@ EXPORT_SYMBOL(cvmx_helper_board_get_mii_address);
  * @INTERNAL
  * Get link state of Cortina PHY
  *
- * @param phy_addr MDIO address of PHY
+ * @param phy_info PHY information
  *
  * @return link state information from PHY
  */
-cvmx_helper_link_info_t __cvmx_get_cortina_phy_link_state(int phy_addr)
+static cvmx_helper_link_info_t
+__cvmx_get_cortina_phy_link_state(cvmx_phy_info_t *phy_info)
 {
 	cvmx_helper_link_info_t result;
+	uint32_t phy_addr = phy_info->phy_addr;
+	uint32_t bus = phy_addr >> 8;
 	int value;
+	uint32_t id;
+	bool is_cs4223 = false;
+#define CS4XXX_GLOBAL_CHIPID_LSB			0x0000
+#define CS4XXX_GLOBAL_CHIPID_MSB			0x0001
 #define CS4321_GIGEPCS_LINE_STATUS			0xC01
 #define CS4321_GPIO_GPIO_INTS				0x16D
 #define CS4321_GLOBAL_GT_10KHZ_REF_CLK_CNT0		0x2E
+#define CS4223_PP_LINE_SDS_DSP_MSEQ_STATUS		0x1237
+#define CS4223_PP_LINE_SDS_DSP_MSEQ_EDC_CONVERGED	(1 << 5)
+#define CS4223_PP_HOST_SDS_DSP_MSEQ_STATUS		0x1A37
+#define CS4223_PP_HOST_SDS_DSP_MSEQ_EDC_CONVERGED	(1 << 5)
 
 	result.u64 = 0;
 	result.s.full_duplex = 1;
 
+	phy_addr &= 0xff;
+
+	value = cvmx_mdio_45_read(bus, phy_addr, 0, CS4XXX_GLOBAL_CHIPID_LSB);
+	id = value;
+
+	value = cvmx_mdio_45_read(bus, phy_addr, 0, CS4XXX_GLOBAL_CHIPID_MSB);
+	id |= value << 16;
+
+	is_cs4223 = ((id & 0x0FFFFFFF) == 0x000303e5);
+
+	if (is_cs4223) {
+		int slice_off = phy_info->phy_sub_addr * 0x1000;
+		/* For now we only support 40Gbps for this device. */
+		value = cvmx_mdio_45_read(bus, phy_addr, 0,
+					  CS4223_PP_LINE_SDS_DSP_MSEQ_STATUS + slice_off);
+		result.s.link_up =
+			!!(value & CS4223_PP_LINE_SDS_DSP_MSEQ_EDC_CONVERGED);
+		value = cvmx_mdio_45_read(bus, phy_addr, 0,
+					  CS4223_PP_HOST_SDS_DSP_MSEQ_STATUS + slice_off);
+		if (!(value & CS4223_PP_HOST_SDS_DSP_MSEQ_EDC_CONVERGED))
+			result.s.link_up = 0;
+		return result;
+	}
+
 	/* Right now to determine the speed we look at the reference clock.
 	 * There's probably a better way but this should work.  For SGMII
 	 * we use a 100MHz reference clock, for XAUI/RXAUI we use a 156.25MHz
 	 * reference clock.
 	 */
-	value = cvmx_mdio_45_read(phy_addr >> 8, phy_addr & 0xff,
-				  0, CS4321_GLOBAL_GT_10KHZ_REF_CLK_CNT0);
+	value = cvmx_mdio_45_read(bus, phy_addr, 0,
+				  CS4321_GLOBAL_GT_10KHZ_REF_CLK_CNT0);
 	result.s.speed = (value == 10000) ? 1000 : 10000;
 
 	if (result.s.speed == 1000) {
-		value = cvmx_mdio_45_read(phy_addr >> 8, phy_addr & 0xff, 0,
+		value = cvmx_mdio_45_read(bus, phy_addr, 0,
 					  CS4321_GIGEPCS_LINE_STATUS);
 		result.s.link_up = (value >= 0) && !!(value & 4);
 	} else {
-		value = cvmx_mdio_45_read(phy_addr >> 8, phy_addr & 0xff, 0,
+		value = cvmx_mdio_45_read(bus, phy_addr, 0,
 					  CS4321_GPIO_GPIO_INTS);
 		result.s.link_up = (value >= 0) && !(value & 3);
 	}
@@ -1516,11 +1662,12 @@ cvmx_helper_link_info_t __cvmx_get_cortina_phy_link_state(int phy_addr)
  * Get link state of generic C45 compliant PHYs
  */
 static cvmx_helper_link_info_t
-__get_generic_8023_c45_phy_link_state(int phy_addr)
+__get_generic_8023_c45_phy_link_state(cvmx_phy_info_t *phy_info)
 {
 	cvmx_helper_link_info_t result;
 	int phy_status;
 	int pma_ctrl1;
+	uint32_t phy_addr = phy_info->phy_addr;
 
 	result.u64 = 0;
 	pma_ctrl1 = cvmx_mdio_45_read(phy_addr >> 8, phy_addr & 0xff, 1, 0);
@@ -1547,10 +1694,12 @@ __get_generic_8023_c45_phy_link_state(int phy_addr)
  * @INTERNAL
  * Get link state of marvell PHY
  */
-static cvmx_helper_link_info_t __get_marvell_phy_link_state(int phy_addr)
+static cvmx_helper_link_info_t
+__get_marvell_phy_link_state(cvmx_phy_info_t *phy_info)
 {
 	cvmx_helper_link_info_t result;
 	int phy_status;
+	uint32_t phy_addr = phy_info->phy_addr;
 
 	result.u64 = 0;
 	/* Set to page 0 */
@@ -1593,10 +1742,14 @@ static cvmx_helper_link_info_t __get_marvell_phy_link_state(int phy_addr)
 /**
  * @INTERNAL
  * Get link state of broadcom PHY
+ *
+ * @param phy_info	PHY information
  */
-static cvmx_helper_link_info_t __get_broadcom_phy_link_state(int phy_addr)
+static cvmx_helper_link_info_t
+__get_broadcom_phy_link_state(cvmx_phy_info_t *phy_info)
 {
 	cvmx_helper_link_info_t result;
+	uint32_t phy_addr = phy_info->phy_addr;
 	int phy_status;
 
 	result.u64 = 0;
@@ -1651,14 +1804,15 @@ static cvmx_helper_link_info_t __get_broadcom_phy_link_state(int phy_addr)
  * @INTERNAL
  * Get link state of generic gigabit PHY
  *
- * @param phy_addr - address of PHY
+ * @param phy_info - information about the PHY
  *
  * @returns link status of the PHY
  */
 static cvmx_helper_link_info_t
-__cvmx_get_generic_8023_c22_phy_link_state(int phy_addr)
+__cvmx_get_generic_8023_c22_phy_link_state(cvmx_phy_info_t *phy_info)
 {
 	cvmx_helper_link_info_t result;
+	uint32_t phy_addr = phy_info->phy_addr;
 	int phy_basic_control;	/* Register 0x0 */
 	int phy_basic_status;	/* Register 0x1 */
 	int phy_anog_adv;	/* Register 0x4 */
@@ -1710,18 +1864,18 @@ __cvmx_get_generic_8023_c22_phy_link_state(int phy_addr)
 	return result;
 }
 
-static cvmx_helper_link_info_t __cvmx_get_qualcomm_s17_phy_link_state(int phy_addr)
+static cvmx_helper_link_info_t
+__cvmx_get_qualcomm_s17_phy_link_state(cvmx_phy_info_t *phy_info)
 {
 	cvmx_helper_link_info_t result;
+	uint32_t phy_addr = phy_info->phy_addr;
 	int phy_status;
 	int auto_status;
 
 	result.u64 = 0;
 
 	phy_status = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, 17);
-	if (device_tree_dbg)
-		cvmx_dprintf("%s(%d): phy status: 0x%x\n",
-			     __func__, phy_addr, phy_status);
+
 	/* If bit 11 isn't set see if autonegotiation is turned off
 	 * (bit 12, reg 0).  The resolved bit doesn't get set properly when
 	 * autonegotiation is off, so force it.
@@ -1766,7 +1920,8 @@ static cvmx_helper_link_info_t __cvmx_get_qualcomm_s17_phy_link_state(int phy_ad
  * @INTERNAL
  * Get link state using inband status
  */
-static cvmx_helper_link_info_t __get_inband_link_state(int ipd_port)
+static cvmx_helper_link_info_t
+__get_inband_link_state(int ipd_port)
 {
 	cvmx_helper_link_info_t result;
 	union cvmx_gmxx_rxx_rx_inbnd inband_status;
@@ -1862,7 +2017,7 @@ static void __set_gpio(const int gpio_pin[], int num_bits,
  * @INTERNAL
  * Switch MDIO mux to the specified port.
  */
-static int __switch_mdio_mux(int ipd_port, const cvmx_phy_info_t *phy_info)
+static int __switch_mdio_mux(const cvmx_phy_info_t *phy_info)
 {
 	int i;
 	int num_bits = 0;
@@ -1930,8 +2085,10 @@ static int __switch_mdio_mux(int ipd_port, const cvmx_phy_info_t *phy_info)
 cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 {
 	cvmx_helper_link_info_t result;
-	cvmx_phy_info_t phy_info;
+	cvmx_phy_info_t *phy_info = NULL;
+	cvmx_phy_info_t local_phy_info;
 	int xiface, index;
+	bool use_inband = false;
 
 	result.u64 = 0;
 
@@ -1943,43 +2100,78 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 		return result;
 	}
 
-	xiface = cvmx_helper_get_interface_num(ipd_port);
-	index = cvmx_helper_get_interface_index_num(ipd_port);
-	if (!cvmx_helper_get_port_autonegotiation(xiface, index)) {
-		result.s.link_up = 1;
-		result.s.full_duplex = 1;
-		switch (cvmx_helper_interface_get_mode(xiface)) {
-		case CVMX_HELPER_INTERFACE_MODE_RGMII:
-		case CVMX_HELPER_INTERFACE_MODE_GMII:
-		case CVMX_HELPER_INTERFACE_MODE_SGMII:
-		case CVMX_HELPER_INTERFACE_MODE_QSGMII:
-		case CVMX_HELPER_INTERFACE_MODE_SPI:
-		default:
-			result.s.speed = 1000;
-			break;
-		case CVMX_HELPER_INTERFACE_MODE_RXAUI:
-		case CVMX_HELPER_INTERFACE_MODE_XAUI:
-		case CVMX_HELPER_INTERFACE_MODE_ILK:
-		case CVMX_HELPER_INTERFACE_MODE_10G_KR:
-			result.s.speed = 10000;
-			break;
-		case CVMX_HELPER_INTERFACE_MODE_XFI:
-		case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
-			result.s.speed = 40000;
-			break;
-		}
+	if (ipd_port >= 0) {
+		xiface = cvmx_helper_get_interface_num(ipd_port);
+		index = cvmx_helper_get_interface_index_num(ipd_port);
+		if (!cvmx_helper_get_port_autonegotiation(xiface, index)) {
+			result.s.link_up = 1;
+			result.s.full_duplex = 1;
+			switch (cvmx_helper_interface_get_mode(xiface)) {
+			case CVMX_HELPER_INTERFACE_MODE_RGMII:
+			case CVMX_HELPER_INTERFACE_MODE_GMII:
+			case CVMX_HELPER_INTERFACE_MODE_SGMII:
+			case CVMX_HELPER_INTERFACE_MODE_QSGMII:
+			case CVMX_HELPER_INTERFACE_MODE_SPI:
+				result.s.speed = 1000;
+				break;
+			case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+			case CVMX_HELPER_INTERFACE_MODE_XAUI:
+			case CVMX_HELPER_INTERFACE_MODE_10G_KR:
+				result.s.speed = 10000;
+				break;
+			case CVMX_HELPER_INTERFACE_MODE_XFI:
+			case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
+				result.s.speed = 40000;
+				break;
+			default:
+				break;
+			}
 
-		return result;
-	}
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
-		if (__cvmx_helper_78xx_parse_phy(&phy_info, ipd_port)) {
-			/*cvmx_dprintf("Error parsing PHY info for 78xx for ipd port %d\n",
-				    ipd_port); */
+			return result;
 		}
-	} else if (__get_phy_info_from_dt(&phy_info, ipd_port) < 0) {
-		/* If we can't get the PHY info from the device tree then try
-		 * the inband state.
+		phy_info = cvmx_helper_get_port_phy_info(xiface, index);
+		if (!phy_info) {
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+			phy_info = (cvmx_phy_info_t *)kmalloc(sizeof(*phy_info),
+							      GFP_KERNEL);
+#else
+			phy_info = cvmx_bootmem_alloc(sizeof(*phy_info), 0);
+#endif
+			memset(phy_info, 0, sizeof(*phy_info));
+			phy_info->phy_addr = -1;
+		}
+		if (!phy_info) {
+			cvmx_printf("%s: Out of memory\n", __func__);
+			return result;
+		}
+		cvmx_helper_set_port_phy_info(xiface, index, phy_info);
+	} else {
+		/* For management ports we don't store the PHY information
+		 * so we use a local copy instead.
 		 */
+		phy_info = &local_phy_info;
+		memset(phy_info, 0, sizeof(*phy_info));
+		phy_info->phy_addr = -1;
+	}
+
+	if (phy_info->phy_addr == -1) {
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
+			if (__cvmx_helper_78xx_parse_phy(phy_info, ipd_port)) {
+				/*cvmx_dprintf("Error parsing PHY info for 78xx for ipd port %d\n",
+					       ipd_port); */
+				phy_info->phy_addr = -1;
+				use_inband = true;
+			}
+		} else if (__get_phy_info_from_dt(phy_info, ipd_port) < 0) {
+			phy_info->phy_addr = -1;
+			use_inband = true;
+		}
+	}
+
+	/* If we can't get the PHY info from the device tree then try
+	 * the inband state.
+	 */
+	if (use_inband) {
 		if (OCTEON_IS_OCTEON1() || OCTEON_IS_MODEL(OCTEON_CN58XX) ||
 		    OCTEON_IS_MODEL(OCTEON_CN50XX)) {
 			result = __get_inband_link_state(ipd_port);
@@ -1991,55 +2183,27 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 		return result;
 	}
 
-	if (phy_info.phy_addr < 0) {
-		/*cvmx_dprintf("%s: phy address invalid for port %d\n",
-			     __func__, ipd_port); */
+	if (phy_info->phy_addr < 0)
 		return result;
-	}
 
+	if (phy_info->direct_connect == 0)
+		__switch_mdio_mux(phy_info);
 
-	if (phy_info.direct_connect == 0) {
-		if (device_tree_dbg)
-			cvmx_dprintf("%s: Phy at address %d not directly connected\n",
-				     __func__, phy_info.phy_addr);
-		__switch_mdio_mux(ipd_port, &phy_info);
-	}
+	if (phy_info->link_function)
+		result = phy_info->link_function(phy_info);
+	else if (OCTEON_IS_OCTEON1() ||
+		 OCTEON_IS_MODEL(OCTEON_CN58XX) ||
+		 OCTEON_IS_MODEL(OCTEON_CN50XX))
+		/* We don't have a PHY address, so attempt to use
+		 * in-band status. It is really important that boards
+		 * not supporting in-band status never get
+		 * here. Reading broken in-band status tends to do bad
+		 * things.
+		 */
+		result = __get_inband_link_state(ipd_port);
+	else
+		result = cvmx_helper_link_get(ipd_port);
 
-	switch (phy_info.phy_type) {
-	case GENERIC_8023_C45_PHY:
-		result = __get_generic_8023_c45_phy_link_state(phy_info.phy_addr);
-		break;
-	case BROADCOM_GENERIC_PHY:
-		result = __get_broadcom_phy_link_state(phy_info.phy_addr);
-		break;
-	case MARVELL_GENERIC_PHY:
-		result = __get_marvell_phy_link_state(phy_info.phy_addr);
-		break;
-	case CORTINA_PHY:
-		result = __cvmx_get_cortina_phy_link_state(phy_info.phy_addr);
-		break;
-	case GENERIC_8023_C22_PHY:
-		result = __cvmx_get_generic_8023_c22_phy_link_state(phy_info.phy_addr);
-		break;
-	case QUALCOMM_S17:
-		result = __cvmx_get_qualcomm_s17_phy_link_state(phy_info.phy_addr);
-		break;
-	case INBAND_PHY:
-	default:
-		if (OCTEON_IS_OCTEON1() ||
-		    OCTEON_IS_MODEL(OCTEON_CN58XX) ||
-		    OCTEON_IS_MODEL(OCTEON_CN50XX))
-			/*
-			 * We don't have a PHY address, so attempt to use
-			 * in-band status. It is really important that boards
-			 * not supporting in-band status never get
-			 * here. Reading broken in-band status tends to do bad
-			 * things.
-			 */
-			result = __get_inband_link_state(ipd_port);
-		else
-			return cvmx_helper_link_get(ipd_port);
-	}
 	return result;
 
 }
@@ -2069,6 +2233,7 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 cvmx_helper_link_info_t __cvmx_helper_board_link_get(int ipd_port)
 {
 	cvmx_helper_link_info_t result;
+	struct cvmx_phy_info phy_info;
 	int phy_addr;
 	int is_broadcom_phy = 0;
 	int is_vitesse_phy = 0;
@@ -2120,8 +2285,9 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get(int ipd_port)
 	case CVMX_BOARD_TYPE_EBH5601:
 	case CVMX_BOARD_TYPE_EBH5610:
 		/* Board has 1 management ports */
-		if (ipd_port == CVMX_HELPER_BOARD_MGMT_IPD_PORT)
+		if (ipd_port == CVMX_HELPER_BOARD_MGMT_IPD_PORT) {
 			is_broadcom_phy = 1;
+		}
 		break;
 	case CVMX_BOARD_TYPE_EBH5200:
 	case CVMX_BOARD_TYPE_EBH5201:
@@ -2186,17 +2352,33 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get(int ipd_port)
 		break;
 	}
 
+	memset(&phy_info, 0, sizeof(phy_info));
+	phy_info.phy_addr = -1;
+	phy_info.ipd_port = ipd_port;
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 	phy_addr = cvmx_helper_board_get_mii_address(ipd_port);
+	phy_info.phy_addr = phy_addr;
+#else
+	if (device_tree_dbg)
+		cvmx_dprintf("%s: Getting PHY info from device tree for IPD port %d\n",
+			     __func__, ipd_port);
+	if (__get_phy_info_from_dt(&phy_info, ipd_port) != 0) {
+		if (device_tree_dbg)
+			cvmx_dprintf("DT failed, getting addr from board\n");
+		phy_info.phy_addr = cvmx_helper_board_get_mii_address(ipd_port);
+	}
+	phy_addr = phy_info.phy_addr;
+#endif
 	if (phy_addr >= 0) {
 		if (is_cortina_phy) {
-			result = __cvmx_get_cortina_phy_link_state(phy_addr);
+			result = __cvmx_get_cortina_phy_link_state(&phy_info);
 		} else if (is_broadcom_phy) {
-			result = __get_broadcom_phy_link_state(phy_addr);
+			result = __get_broadcom_phy_link_state(&phy_info);
 		} else if (is_vitesse_phy || is_ti_phy) {
-			result = __get_generic_8023_c45_phy_link_state(phy_addr);
+			result = __get_generic_8023_c45_phy_link_state(&phy_info);
 		} else {
 			/* This code assumes we are using a Marvell Gigabit PHY. */
-			result = __get_marvell_phy_link_state(phy_addr);
+			result = __get_marvell_phy_link_state(&phy_info);
 		}
 	} else if (OCTEON_IS_MODEL(OCTEON_CN3XXX) ||
 		   OCTEON_IS_MODEL(OCTEON_CN58XX) ||
@@ -2241,7 +2423,9 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get(int ipd_port)
  *
  * @return Zero on success, negative on failure
  */
-int cvmx_helper_board_link_set_phy(int phy_addr, cvmx_helper_board_set_phy_link_flags_types_t link_flags, cvmx_helper_link_info_t link_info)
+int cvmx_helper_board_link_set_phy(int phy_addr,
+				   cvmx_helper_board_set_phy_link_flags_types_t link_flags,
+				   cvmx_helper_link_info_t link_info)
 {
 
 	/* Set the flow control settings based on link_flags */
@@ -2261,41 +2445,60 @@ int cvmx_helper_board_link_set_phy(int phy_addr, cvmx_helper_board_set_phy_link_
 		cvmx_mdio_phy_reg_extended_status_t reg_extended_status;
 		cvmx_mdio_phy_reg_control_1000_t reg_control_1000;
 
-		reg_status.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_STATUS);
-		reg_autoneg_adver.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_AUTONEG_ADVER);
+		reg_status.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+						CVMX_MDIO_PHY_REG_STATUS);
+		reg_autoneg_adver.u16 = cvmx_mdio_read(phy_addr >> 8,
+						       phy_addr & 0xff,
+							CVMX_MDIO_PHY_REG_AUTONEG_ADVER);
 		reg_autoneg_adver.s.advert_100base_t4 = reg_status.s.capable_100base_t4;
 		reg_autoneg_adver.s.advert_10base_tx_full = reg_status.s.capable_10_full;
 		reg_autoneg_adver.s.advert_10base_tx_half = reg_status.s.capable_10_half;
 		reg_autoneg_adver.s.advert_100base_tx_full = reg_status.s.capable_100base_x_full;
 		reg_autoneg_adver.s.advert_100base_tx_half = reg_status.s.capable_100base_x_half;
-		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_AUTONEG_ADVER, reg_autoneg_adver.u16);
+		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
+				CVMX_MDIO_PHY_REG_AUTONEG_ADVER,
+				reg_autoneg_adver.u16);
 		if (reg_status.s.capable_extended_status) {
-			reg_extended_status.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_EXTENDED_STATUS);
-			reg_control_1000.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_CONTROL_1000);
+			reg_extended_status.u16 = cvmx_mdio_read(phy_addr >> 8,
+								 phy_addr & 0xff,
+								 CVMX_MDIO_PHY_REG_EXTENDED_STATUS);
+			reg_control_1000.u16 = cvmx_mdio_read(phy_addr >> 8,
+							      phy_addr & 0xff,
+							      CVMX_MDIO_PHY_REG_CONTROL_1000);
 			reg_control_1000.s.advert_1000base_t_full = reg_extended_status.s.capable_1000base_t_full;
 			reg_control_1000.s.advert_1000base_t_half = reg_extended_status.s.capable_1000base_t_half;
-			cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_CONTROL_1000, reg_control_1000.u16);
+			cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
+					CVMX_MDIO_PHY_REG_CONTROL_1000,
+					reg_control_1000.u16);
 		}
-		reg_control.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_CONTROL);
+		reg_control.u16 = cvmx_mdio_read(phy_addr >> 8,
+						 phy_addr & 0xff,
+						 CVMX_MDIO_PHY_REG_CONTROL);
 		reg_control.s.reset = 1;
 		reg_control.s.autoneg_enable = 1;
 		reg_control.s.restart_autoneg = 1;
-		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
+		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
+				CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
 	} else if ((link_flags & set_phy_link_flags_autoneg)) {
 		cvmx_mdio_phy_reg_control_t reg_control;
 		cvmx_mdio_phy_reg_status_t reg_status;
 		cvmx_mdio_phy_reg_autoneg_adver_t reg_autoneg_adver;
 		cvmx_mdio_phy_reg_control_1000_t reg_control_1000;
 
-		reg_status.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_STATUS);
-		reg_autoneg_adver.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_AUTONEG_ADVER);
+		reg_status.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+						CVMX_MDIO_PHY_REG_STATUS);
+		reg_autoneg_adver.u16 = cvmx_mdio_read(phy_addr >> 8,
+						       phy_addr & 0xff,
+						       CVMX_MDIO_PHY_REG_AUTONEG_ADVER);
 		reg_autoneg_adver.s.advert_100base_t4 = 0;
 		reg_autoneg_adver.s.advert_10base_tx_full = 0;
 		reg_autoneg_adver.s.advert_10base_tx_half = 0;
 		reg_autoneg_adver.s.advert_100base_tx_full = 0;
 		reg_autoneg_adver.s.advert_100base_tx_half = 0;
 		if (reg_status.s.capable_extended_status) {
-			reg_control_1000.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_CONTROL_1000);
+			reg_control_1000.u16 = cvmx_mdio_read(phy_addr >> 8,
+							      phy_addr & 0xff,
+							      CVMX_MDIO_PHY_REG_CONTROL_1000);
 			reg_control_1000.s.advert_1000base_t_full = 0;
 			reg_control_1000.s.advert_1000base_t_half = 0;
 		}
@@ -2313,17 +2516,24 @@ int cvmx_helper_board_link_set_phy(int phy_addr, cvmx_helper_board_set_phy_link_
 			reg_control_1000.s.advert_1000base_t_half = !link_info.s.full_duplex;
 			break;
 		}
-		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_AUTONEG_ADVER, reg_autoneg_adver.u16);
+		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
+				CVMX_MDIO_PHY_REG_AUTONEG_ADVER,
+				reg_autoneg_adver.u16);
 		if (reg_status.s.capable_extended_status)
-			cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_CONTROL_1000, reg_control_1000.u16);
-		reg_control.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_CONTROL);
+			cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
+					CVMX_MDIO_PHY_REG_CONTROL_1000,
+					reg_control_1000.u16);
+		reg_control.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+						 CVMX_MDIO_PHY_REG_CONTROL);
 		reg_control.s.reset = 1;
 		reg_control.s.autoneg_enable = 1;
 		reg_control.s.restart_autoneg = 1;
-		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
+		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
+				CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
 	} else {
 		cvmx_mdio_phy_reg_control_t reg_control;
-		reg_control.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_CONTROL);
+		reg_control.u16 = cvmx_mdio_read(phy_addr >> 8, phy_addr & 0xff,
+						 CVMX_MDIO_PHY_REG_CONTROL);
 		reg_control.s.reset = 1;
 		reg_control.s.autoneg_enable = 0;
 		reg_control.s.reset = 1;
@@ -2339,7 +2549,8 @@ int cvmx_helper_board_link_set_phy(int phy_addr, cvmx_helper_board_set_phy_link_
 			reg_control.s.speed_msb = 0;
 			reg_control.s.speed_lsb = 0;
 		}
-		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff, CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
+		cvmx_mdio_write(phy_addr >> 8, phy_addr & 0xff,
+				CVMX_MDIO_PHY_REG_CONTROL, reg_control.u16);
 	}
 	return 0;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index 54a5266..28ec36e 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -70,6 +70,11 @@
 #include "cvmx-helper-cfg.h"
 #endif
 
+/* bootloader has limited memory, not much traffic */
+#if defined(__U_BOOT__)
+#define CVMX_PKO3_POOL_BUFFERS (1024*4+1024)
+#endif
+
 /*
  * PKO3 requires 4 buffers for each active Descriptor Queue,
  * and because it is not known how many DQs will in fact be used
@@ -80,13 +85,21 @@
  * be rarely used.
  */
 #ifndef CVMX_PKO3_POOL_BUFFERS
+/* Calculate buffer count based on maximum queue depth if defined */
 #ifdef CVMX_PKO3_DQ_MAX_DEPTH
+/* Number of command words per buffer */
+#define _NUMW	(4*1024/8)
+/* Assume 8 concurrently active, fully loaded queues */
+#define _NUMQ	8
 /* Assume worst case of 16 words per command per DQ */
-#define CVMX_PKO3_POOL_BUFFERS (CVMX_PKO3_DQ_MAX_DEPTH*16/511*1024);
+#define _DQ_SZ	16
+/* Combine the above guesstimates into the total buffer count */
+#define CVMX_PKO3_POOL_BUFFERS (CVMX_PKO3_DQ_MAX_DEPTH*_DQ_SZ/_NUMW*_NUMQ+1024)
 #else
 #define CVMX_PKO3_POOL_BUFFERS (1024*4+1024)
 #endif
 #endif
+
 /* Simulator has limited memory, use fewer buffers */
 #ifndef	CVMX_PKO3_POOL_BUFS_SIM
 #define CVMX_PKO3_POOL_BUFS_SIM (1024*4+1024)
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index f8e2fdc..b369cc5 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 103672 $<hr>
+ * <hr>$Revision: 103829 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -439,7 +439,6 @@ static void __cvmx_pcie_rc_initialize_config_space(int pcie_port)
 		cvmx_pciercx_cfg091_t cfg091;
 		cvmx_pciercx_cfg092_t cfg092;
 		cvmx_pciercx_cfg548_t cfg548;
-		cvmx_pciercx_cfg554_t cfg554;
 		/* Errata (GSER-21178) PCIe gen3 doesn't work */
 		/* The starting equalization hints are incorrect on CN78XX pass 1.x. Fix
 		them for the 8 possible lanes. It doesn't hurt to program them even for
@@ -472,10 +471,15 @@ static void __cvmx_pcie_rc_initialize_config_space(int pcie_port)
 		cfg548.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG548(pcie_port));
 		cfg548.s.ep2p3d = 1;
 		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG548(pcie_port), cfg548.u32);
+	}
+
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+		cvmx_pciercx_cfg554_t cfg554;
 		/* Errata (GSER-21331) GEN3 Equalization may fail */
 		/* Disable preset #10 and disable the 2ms timeout */
 		cfg554.u32 = cvmx_pcie_cfgx_read(pcie_port, CVMX_PCIERCX_CFG554(pcie_port));
-		cfg554.s.p23td = 1;
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+			cfg554.s.p23td = 1;
 		cfg554.s.prv = 0x3ff;
 		cvmx_pcie_cfgx_write(pcie_port, CVMX_PCIERCX_CFG554(pcie_port), cfg554.u32);
 	}
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index 5074562..80c2858 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 102508 $<hr>
+ * <hr>$Revision: 103883 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -616,7 +616,7 @@ void __cvmx_qlm_pcie_idle_dac_tweak(void)
 		num_qlms = 5;
 	else if (OCTEON_IS_MODEL(OCTEON_CN66XX_PASS1_X))
 		num_qlms = 3;
-	else if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X) || OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_X))
+	else if (OCTEON_IS_MODEL(OCTEON_CN63XX))
 		num_qlms = 3;
 	else
 		return;
@@ -1381,7 +1381,7 @@ enum cvmx_qlm_mode cvmx_qlm_get_mode(int qlm)
 	return CVMX_QLM_MODE_DISABLED;
 }
 
-int cvmx_qlm_measure_clock_cn78xx(int qlm)
+int cvmx_qlm_measure_clock_cn78xx(int node, int qlm)
 {
 	cvmx_gserx_cfg_t cfg;
 	cvmx_gserx_refclk_sel_t refclk_sel;
@@ -1390,17 +1390,17 @@ int cvmx_qlm_measure_clock_cn78xx(int qlm)
 	if (qlm >= 8)
 		return -1; /* FIXME for OCI */
 
-	cfg.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm));
+	cfg.u64 = cvmx_read_csr_node(node, CVMX_GSERX_CFG(qlm));
 
 	if (cfg.s.pcie) {
-		refclk_sel.u64 = cvmx_read_csr(CVMX_GSERX_REFCLK_SEL(qlm));
+		refclk_sel.u64 = cvmx_read_csr_node(node, CVMX_GSERX_REFCLK_SEL(qlm));
 		if (refclk_sel.s.pcie_refclk125)
 			return REF_125MHZ; /* Ref 125 Mhz */
 		else
 			return REF_100MHZ; /* Ref 100Mhz */
 	}
 
-	lane_mode.u64 = cvmx_read_csr(CVMX_GSERX_LANE_MODE(qlm));
+	lane_mode.u64 = cvmx_read_csr_node(node, CVMX_GSERX_LANE_MODE(qlm));
 	switch(lane_mode.s.lmode) {
 	case R_25G_REFCLK100:
 		return REF_100MHZ;
@@ -1457,7 +1457,7 @@ int cvmx_qlm_measure_clock(int qlm)
 		return -1;
 
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
-		return cvmx_qlm_measure_clock_cn78xx(qlm);
+		return cvmx_qlm_measure_clock_cn78xx(cvmx_get_node_num(), qlm);
 
 	/* Force the reference to 156.25Mhz when running in simulation.
 	   This supports the most speeds */
diff --git a/arch/mips/include/asm/octeon/cvmx-ase-defs.h b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
index a897234..23ceb72 100644
--- a/arch/mips/include/asm/octeon/cvmx-ase-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ase-defs.h
@@ -729,8 +729,8 @@ union cvmx_ase_ecc_int {
 	uint64_t lue_kdb_dbe                  : 1;  /**< Detected double-bit error on LUE KRQ key data buffer. */
 	uint64_t lue_kdb_sbe                  : 1;  /**< Detected and corrected single-bit error on LUE KRQ key data buffer. */
 	uint64_t reserved_18_31               : 14;
-	uint64_t lop_txb_dbe                  : 1;  /**< Detected double-bit error on LOP's TXBUFF RAM read. */
-	uint64_t lop_txb_sbe                  : 1;  /**< Detected and corrected single-bit error on LOP's TXBUFF RAM read. */
+	uint64_t lop_txb_dbe                  : 1;  /**< Detected double-bit error on LOP's TXBUFF RAM read operation. */
+	uint64_t lop_txb_sbe                  : 1;  /**< Detected and corrected single-bit error on LOP's TXBUFF RAM read operation. */
 	uint64_t reserved_8_15                : 8;
 	uint64_t lip_newq_dbe                 : 1;  /**< Detected double-bit error on LIP's new queue. */
 	uint64_t lip_newq_sbe                 : 1;  /**< Detected and corrected single-bit error on LIP's new queue. */
@@ -810,10 +810,10 @@ union cvmx_ase_gen_int {
 	uint64_t lip_tbf_missing_eop          : 1;  /**< The incoming TBL command did not indicate EOP on the correct beat, or the incoming lookup
                                                          command did not indicate EOP before the 12th beat. The request will be marked FATAL. */
 	uint64_t lip_tbf_early_eop            : 1;  /**< The incoming TBL write command did not have enough write data beats to match the command.
-                                                         The write is marked FATAL. */
+                                                         The write operation is marked FATAL. */
 	uint64_t lip_obf_missing_eop          : 1;  /**< The incoming OSM command did not indicate EOP on the correct beat. The request is marked FATAL. */
 	uint64_t lip_obf_early_eop            : 1;  /**< The incoming OSM Write command did not have enough write data beats to match the command.
-                                                         The write is marked FATAL. */
+                                                         The write operation is marked FATAL. */
 	uint64_t lip_obf_drop_unkn_cmd        : 1;  /**< The incoming control word at LIP OSM bypass splitter does not decode to a valid command.
                                                          The packet is dropped since we can't trust the command to figure out what kind of response
                                                          to send to LAP. We depend on LAP timeouts to inform software. */
@@ -822,7 +822,7 @@ union cvmx_ase_gen_int {
 	uint64_t lip_obf_drop_cmd_dbe         : 1;  /**< LIP OSM bypass splitter sees the incoming control word is marked as having a double-bit
                                                          error. The packet is dropped since we can't trust the LID to send even an error response
                                                          to LAP. We depend on LAP timeouts to inform software. */
-	uint64_t lip_isf_drop_full            : 1;  /**< LIP Input Skid FIFO dropped a beat because it was full. This only happens if LAP issues
+	uint64_t lip_isf_drop_full            : 1;  /**< LIP input skid FIFO dropped a beat because it was full. This only happens if LAP issues
                                                          request beats but has no ase__lap1_credit<0>s to do so; this indicates LAP credits are
                                                          misprogrammed. If this interrupt fires, the software has to reset LAP1 and ASE to recover,
                                                          as the credits are out of sync. */
@@ -973,8 +973,8 @@ union cvmx_ase_lue_config {
                                                          When set, each bucket walk engine is allowed to have a maximum of 16 outstanding rule read
                                                          requests in progress at a time, split into two groups of 8 (Phases A and B). After the
                                                          initial 8 bucket entries, the next set of [up to] 8 bucket entries are speculatively read
-                                                         and submitted to the rule walk engine. Subsequent speculative reads are performed once all
-                                                         outstanding requests for a phase have completed. */
+                                                         and submitted to the rule walk engine. Subsequent speculative read operations are
+                                                         performed once all outstanding requests for a phase have completed. */
 	uint64_t reserved_20_31               : 12;
 	uint64_t twc_strspsta_rr              : 1;  /**< Within the TWC block, configures the arbiter which selects between pending TWE or BWE
                                                          STRSPs. When clear, fixed priority arbitration is selected, which gives BWEs higher
@@ -1253,7 +1253,7 @@ union cvmx_ase_lue_perf_filt {
 	uint64_t hst_rft_kftidx               : 6;  /**< Lookups to the RFT in the HST module will trigger a performance event if the lookup is for
                                                          the KFTIDX value indicated in this field. */
 	uint64_t reserved_26_31               : 6;
-	uint64_t sel_all_perf                 : 1;  /**< Disable Filtering. When set, overrides the setting of SEL_ID_PERF for some performance
+	uint64_t sel_all_perf                 : 1;  /**< Disable filtering. When set, overrides the setting of SEL_ID_PERF for some performance
                                                          counter events. This field is used by the TWC, BWC, and STR modules. */
 	uint64_t sel_id_perf                  : 1;  /**< Selects how the value in the ENG_KID_ID_PERF field is interpreted. This field is used by
                                                          the TWC, BWC, and STR modules. */
@@ -1293,8 +1293,8 @@ typedef union cvmx_ase_lue_perf_filt cvmx_ase_lue_perf_filt_t;
 /**
  * cvmx_ase_lue_performance_control#
  *
- * A write to LUE_PERFORMANCE_CONTROL*, which sets the ENABLE field to 0x1 must not change the
- * values of any other fields in the CSR.
+ * A write operation to LUE_PERFORMANCE_CONTROL*, which sets the ENABLE field to 0x1
+ * must not change the values of any other fields in the CSR.
  */
 union cvmx_ase_lue_performance_controlx {
 	uint64_t u64;
@@ -1341,8 +1341,8 @@ typedef union cvmx_ase_lue_performance_controlx cvmx_ase_lue_performance_control
 /**
  * cvmx_ase_lue_performance_control0
  *
- * A write to LUE_PERFORMANCE_CONTROL*, which sets the ENABLE field to 0x1 must not change the
- * values of any other fields in the CSR.
+ * A write operation to LUE_PERFORMANCE_CONTROL*, which sets the ENABLE field to 0x1
+ * must not change the values of any other fields in the CSR.
  */
 union cvmx_ase_lue_performance_control0 {
 	uint64_t u64;
@@ -1362,8 +1362,8 @@ union cvmx_ase_lue_performance_control0 {
                                                          1 = Event counted SEL0.
                                                          0 = Event counted SEL0 & SEL1 & SEL2.
                                                          Bits<26:25>:
-                                                         0x0 = Pos Edge.
-                                                         0x1 = Neg Edge.
+                                                         0x0 = Pos edge.
+                                                         0x1 = Neg edge.
                                                          0x2 = Level.
                                                          0x3 = One shot. */
 	uint64_t sel2                         : 8;  /**< Performance counter event select, third mux.
@@ -1392,8 +1392,9 @@ typedef union cvmx_ase_lue_performance_control0 cvmx_ase_lue_performance_control
 /**
  * cvmx_ase_lue_performance_control1
  *
- * A write to LUE_PERFORMANCE_CONTROL*, which sets the ENABLE or GLOBAL_ENABLE fields to 0x1 must
- * not change the values of any other fields in the CSR.
+ * A write operation to LUE_PERFORMANCE_CONTROL*, which sets the ENABLE or
+ * GLOBAL_ENABLE fields to 0x1 must not change the values of any other fields in the
+ * CSR.
  */
 union cvmx_ase_lue_performance_control1 {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index 2f6377d..9c727b4 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -3928,8 +3928,7 @@ union cvmx_bgxx_gmp_gmi_txx_append {
 	struct cvmx_bgxx_gmp_gmi_txx_append_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t force_fcs                    : 1;  /**< Append the Ethernet FCS on each PAUSE packet. PAUSE packets are normally padded to 60
-                                                         bytes. If BGX()_GMP_GMI_TX()_MIN_PKT[MIN_SIZE] exceeds 59, then FCS_C is not used. */
+	uint64_t force_fcs                    : 1;  /**< Append the Ethernet FCS on each PAUSE packet. */
 	uint64_t fcs                          : 1;  /**< Append the Ethernet FCS on each packet. */
 	uint64_t pad                          : 1;  /**< Append PAD bytes such that minimum-sized packet is transmitted. */
 	uint64_t preamble                     : 1;  /**< Prepend the Ethernet preamble on each transfer. */
@@ -4373,10 +4372,10 @@ union cvmx_bgxx_gmp_pcs_anx_adv {
                                                          0x0 = Link OK, XMIT = DATA.
                                                          0x1 = Link failure (loss of sync, XMIT !=DATA).
                                                          0x2 = Local device offline.
-                                                         0x3 = Auto-Negotiation error; failure to complete Auto-Negotiation. AN error is set if
+                                                         0x3 = Autonegotiation error; failure to complete autonegotiation. AN error is set if
                                                          resolution function precludes operation with link partner. */
 	uint64_t reserved_9_11                : 3;
-	uint64_t pause                        : 2;  /**< PAUSE frame flow capability across link, exchanged during Auto-Negotiation as follows:
+	uint64_t pause                        : 2;  /**< PAUSE frame flow capability across link, exchanged during autonegotiation as follows:
                                                          0x0 = No PAUSE.
                                                          0x1 = Symmetric PAUSE.
                                                          0x2 = Asymmetric PAUSE.
@@ -4429,7 +4428,7 @@ typedef union cvmx_bgxx_gmp_pcs_anx_ext_st cvmx_bgxx_gmp_pcs_anx_ext_st_t;
 /**
  * cvmx_bgx#_gmp_pcs_an#_lp_abil
  *
- * This is the Auto-Negotiation Link partner ability register 5 as per IEEE 802.3, Clause 37.
+ * This is the autonegotiation link partner ability register 5 as per IEEE 802.3, Clause 37.
  *
  */
 union cvmx_bgxx_gmp_pcs_anx_lp_abil {
@@ -4444,7 +4443,7 @@ union cvmx_bgxx_gmp_pcs_anx_lp_abil {
                                                          0x0 = Link OK.
                                                          0x1 = Offline.
                                                          0x2 = Link failure.
-                                                         0x3 = Auto-Negotiation error. */
+                                                         0x3 = Autonegotiation error. */
 	uint64_t reserved_9_11                : 3;
 	uint64_t pause                        : 2;  /**< Link partner PAUSE setting as follows:
                                                          0x0 = No PAUSE.
@@ -4492,9 +4491,9 @@ union cvmx_bgxx_gmp_pcs_anx_results {
                                                          0x1 = 100 Mb/s.
                                                          0x2 = 1000 Mb/s.
                                                          0x3 = Reserved. */
-	uint64_t an_cpt                       : 1;  /**< Auto-Negotiation completed.
-                                                         1 = Auto-Negotiation completed.
-                                                         0 = Auto-Negotiation not completed or failed. */
+	uint64_t an_cpt                       : 1;  /**< Autonegotiation completed.
+                                                         1 = Autonegotiation completed.
+                                                         0 = Autonegotiation not completed or failed. */
 	uint64_t dup                          : 1;  /**< Duplex mode. 1 = full duplex, 0 = half duplex. */
 	uint64_t link_ok                      : 1;  /**< Link status: 1 = link up (OK), 1 = link down. */
 #else
@@ -4526,7 +4525,7 @@ union cvmx_bgxx_gmp_pcs_intx {
 	uint64_t dup                          : 1;  /**< Set whenever duplex mode changes on the link. */
 	uint64_t sync_bad                     : 1;  /**< Set by hardware whenever RX sync state machine reaches a bad state. Should never be set
                                                          during normal operation. */
-	uint64_t an_bad                       : 1;  /**< Set by hardware whenever Auto-Negotiation state machine reaches a bad state. Should never
+	uint64_t an_bad                       : 1;  /**< Set by hardware whenever autonegotiation state machine reaches a bad state. Should never
                                                          be set during normal operation. */
 	uint64_t rxlock                       : 1;  /**< Set by hardware whenever code group sync or bit lock failure occurs. Cannot fire in loopback1 mode. */
 	uint64_t rxbad                        : 1;  /**< Set by hardware whenever RX state machine reaches a bad state. Should never be set during
@@ -4537,7 +4536,7 @@ union cvmx_bgxx_gmp_pcs_intx {
                                                          normal operation. */
 	uint64_t txfifo                       : 1;  /**< Set whenever hardware detects a TX FIFO overflow condition. */
 	uint64_t txfifu                       : 1;  /**< Set whenever hardware detects a TX FIFO underflow condition. */
-	uint64_t an_err                       : 1;  /**< Auto-Negotiation error; AN resolution function failed. */
+	uint64_t an_err                       : 1;  /**< Autonegotiation error; AN resolution function failed. */
 	uint64_t xmit                         : 1;  /**< Set whenever hardware detects a change in the XMIT variable. XMIT variable states are
                                                          IDLE, CONFIG and DATA. */
 	uint64_t lnkspd                       : 1;  /**< Set by hardware whenever link speed has changed. */
@@ -4574,7 +4573,7 @@ union cvmx_bgxx_gmp_pcs_linkx_timer {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t count                        : 16; /**< (Coprocessor clock period * 1024) * COUNT should be 1.6 ms for SGMII and 10 ms otherwise,
-                                                         which is the link timer used in Auto-Negotiation. Reset assumes a 700 MHz coprocessor
+                                                         which is the link timer used in autonegotiation. Reset assumes a 700 MHz coprocessor
                                                          clock for 1.6 ms link timer. */
 #else
 	uint64_t count                        : 16;
@@ -4615,17 +4614,17 @@ union cvmx_bgxx_gmp_pcs_miscx_ctl {
                                                          LOOPBCK1 and LOOPBCK2 modes may not be supported simultaneously. */
 	uint64_t mac_phy                      : 1;  /**< MAC/PHY.
                                                          0 = MAC.
-                                                         1 = PHY decides the TX_CONFIG_REG value to be sent during Auto-Negotiation. */
+                                                         1 = PHY decides the TX_CONFIG_REG value to be sent during autonegotiation. */
 	uint64_t mode                         : 1;  /**< Mode bit.
                                                          _ 0 = SGMII mode is selected and the following note applies.
                                                          The SGMII AN advertisement register (BGX()_GMP_PCS_SGM()_AN_ADV) is sent during
-                                                         Auto-Negotiation if BGX()_GMP_PCS_MISC()_CTL[MAC_PHY] = 1 (PHY mode). If [MAC_PHY]
+                                                         Autonegotiation if BGX()_GMP_PCS_MISC()_CTL[MAC_PHY] = 1 (PHY mode). If [MAC_PHY]
                                                          = 0 (MAC mode), the TX_CONFIG_REG<14> becomes ACK bit and <0> is always 1. All other bits
-                                                         in TX_CONFIG_REG sent are 0. The PHY dictates the Auto-Negotiation results.
-                                                         _ 1 = 1000Base-X mode is selected. Auto-Negotiation follows IEEE 802.3 clause 37. */
-	uint64_t an_ovrd                      : 1;  /**< Auto-Negotiation results override:
+                                                         in TX_CONFIG_REG sent are 0. The PHY dictates the autonegotiation results.
+                                                         _ 1 = 1000Base-X mode is selected. Autonegotiation follows IEEE 802.3 clause 37. */
+	uint64_t an_ovrd                      : 1;  /**< Autonegotiation results override:
                                                          0 = Disable.
-                                                         1 = Enable override. Auto-Negotiation is allowed to happen but the results are ignored
+                                                         1 = Enable override. Autonegotiation is allowed to happen but the results are ignored
                                                          when this bit is set.  Duplex and Link speed values are set from BGX()_GMP_PCS_MISC()_CTL. */
 	uint64_t samp_pt                      : 7;  /**< Byte number in elongated frames for 10/100 Mb/s operation for data sampling on RX side in
                                                          PCS. Recommended values are 0x5 for 100 Mb/s operation and 0x32 for 10 Mb/s operation.
@@ -4668,27 +4667,27 @@ union cvmx_bgxx_gmp_pcs_mrx_control {
                                                            0 = Normal operation.
                                                            1 = Internal loopback mode.
                                                          The loopback mode returns loopback TX data from GMII TX back to GMII RX interface. The
-                                                         loopback happens in the PCS module. Auto-Negotiation is disabled even if AN_EN is set
+                                                         loopback happens in the PCS module. Autonegotiation is disabled even if AN_EN is set
                                                          during loopback. */
 	uint64_t spdlsb                       : 1;  /**< Least-significant bit of the link-speed field, i.e. SPD<0>. Refer to SPDMSB. */
-	uint64_t an_en                        : 1;  /**< Auto-Negotiation enable. */
+	uint64_t an_en                        : 1;  /**< Autonegotiation enable. */
 	uint64_t pwr_dn                       : 1;  /**< Power down:
                                                          0 = Normal operation.
                                                          1 = Power down (hardware reset). */
 	uint64_t reserved_10_10               : 1;
-	uint64_t rst_an                       : 1;  /**< Reset Auto-Negotiation. When set, if AN_EN = 1 and
-                                                         BGX()_GMP_PCS_MR()_STATUS[AN_ABIL] = 1, Auto-Negotiation begins. Otherwise,
+	uint64_t rst_an                       : 1;  /**< Reset autonegotiation. When set, if AN_EN = 1 and
+                                                         BGX()_GMP_PCS_MR()_STATUS[AN_ABIL] = 1, Autonegotiation begins. Otherwise,
                                                          software write requests are ignored and this bit remains at 0. This bit clears itself to
-                                                         0, when Auto-Negotiation starts. */
+                                                         0, when autonegotiation starts. */
 	uint64_t dup                          : 1;  /**< Duplex mode:
-                                                           0 = half duplex; effective only if Auto-Negotiation is disabled.
+                                                           0 = half duplex; effective only if autonegotiation is disabled.
                                                            1 = full duplex.
                                                          If BGX()_GMP_PCS_MR()_STATUS <15:9> and
                                                          BGX()_GMP_PCS_AN()_ADV<15:12> allow only one duplex mode, this bit corresponds to
                                                          that value and any attempts to write are ignored. */
 	uint64_t coltst                       : 1;  /**< Enable COL signal test.
                                                          During COL test, the COL signal reflects the GMII TX_EN signal with less than 16BT delay. */
-	uint64_t spdmsb                       : 1;  /**< Link speed most-significant bit, i.e SPD<1>; effective only if Auto-Negotiation is
+	uint64_t spdmsb                       : 1;  /**< Link speed most-significant bit, i.e SPD<1>; effective only if autonegotiation is
                                                          disabled.
                                                          <pre>
                                                          [SPDMSB]   [SPDLSB]   Link Speed
@@ -4698,7 +4697,7 @@ union cvmx_bgxx_gmp_pcs_mrx_control {
                                                           1          1         reserved
                                                          </pre> */
 	uint64_t uni                          : 1;  /**< Unidirectional (Std 802.3-2005, Clause 66.2). When set to 1, this bit overrides AN_EN and
-                                                         disables the Auto-Negotiation variable mr_an_enable. Used in both 1000BASE-X and SGMII
+                                                         disables the autonegotiation variable mr_an_enable. Used in both 1000BASE-X and SGMII
                                                          modes. */
 	uint64_t reserved_0_4                 : 5;
 #else
@@ -4747,17 +4746,17 @@ union cvmx_bgxx_gmp_pcs_mrx_status {
 	uint64_t prb_sup                      : 1;  /**< Preamble not needed.
                                                          0 = Cannot accept frames without preamble bytes.
                                                          1 = Can work without preamble bytes at the beginning of frames. */
-	uint64_t an_cpt                       : 1;  /**< Indicates Auto-Negotiation is complete; the contents of the
+	uint64_t an_cpt                       : 1;  /**< Indicates autonegotiation is complete; the contents of the
                                                          BGX()_GMP_PCS_AN()_RESULTS are valid. */
 	uint64_t rm_flt                       : 1;  /**< Indicates remote fault condition occurred. This bit implements a latching-high behavior.
                                                          It is cleared when software reads this register or when
                                                          BGX()_GMP_PCS_MR()_CONTROL[RESET] is asserted.
                                                          See BGX()_GMP_PCS_AN()_ADV[REM_FLT] for fault conditions. */
-	uint64_t an_abil                      : 1;  /**< Indicates Auto-Negotiation capable. */
+	uint64_t an_abil                      : 1;  /**< Indicates autonegotiation capable. */
 	uint64_t lnk_st                       : 1;  /**< Link state:
                                                            0 = link down.
                                                            1 = link up.
-                                                         Set during Auto-Negotiation process. Set whenever XMIT = DATA. Latching-low behavior when
+                                                         Set during autonegotiation process. Set whenever XMIT = DATA. Latching-low behavior when
                                                          link goes down. Link down value of the bit stays low until software reads the register. */
 	uint64_t reserved_1_1                 : 1;
 	uint64_t extnd                        : 1;  /**< This field is always 0, extended capability registers not present. */
@@ -4797,8 +4796,8 @@ union cvmx_bgxx_gmp_pcs_rxx_states {
 	uint64_t rx_st                        : 5;  /**< Receive state-machine state. */
 	uint64_t sync_bad                     : 1;  /**< Receive synchronization state machine is in an illegal state. */
 	uint64_t sync                         : 4;  /**< Receive synchronization state-machine state. */
-	uint64_t an_bad                       : 1;  /**< Auto-Negotiation state machine is in an illegal state. */
-	uint64_t an_st                        : 4;  /**< Auto-Negotiation state-machine state. */
+	uint64_t an_bad                       : 1;  /**< Autonegotiation state machine is in an illegal state. */
+	uint64_t an_st                        : 4;  /**< Autonegotiation state-machine state. */
 #else
 	uint64_t an_st                        : 4;
 	uint64_t an_bad                       : 1;
@@ -4836,11 +4835,11 @@ typedef union cvmx_bgxx_gmp_pcs_rxx_sync cvmx_bgxx_gmp_pcs_rxx_sync_t;
 /**
  * cvmx_bgx#_gmp_pcs_sgm#_an_adv
  *
- * This is the SGMII Auto-Negotiation advertisement register (sent out as TX_CONFIG_REG). This
- * register is sent during Auto-Negotiation if
+ * This is the SGMII Autonegotiation advertisement register (sent out as TX_CONFIG_REG). This
+ * register is sent during autonegotiation if
  * BGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set (1 = PHY mode). If the bit is not set (0 =
  * MAC mode), the TX_CONFIG_REG<14> becomes ACK bit and <0> is always 1. All other bits in
- * TX_CONFIG_REG sent will be 0. The PHY dictates the Auto-Negotiation results.
+ * TX_CONFIG_REG sent will be 0. The PHY dictates the autonegotiation results.
  */
 union cvmx_bgxx_gmp_pcs_sgmx_an_adv {
 	uint64_t u64;
@@ -4848,7 +4847,7 @@ union cvmx_bgxx_gmp_pcs_sgmx_an_adv {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t link                         : 1;  /**< Link status: 1 = Link up, 0 = Link down. */
-	uint64_t ack                          : 1;  /**< Auto-Negotiation acknowledgement. */
+	uint64_t ack                          : 1;  /**< Autonegotiation acknowledgement. */
 	uint64_t reserved_13_13               : 1;
 	uint64_t dup                          : 1;  /**< Duplex mode: 1 = full duplex, 0 = half duplex */
 	uint64_t speed                        : 2;  /**< Link speed:
@@ -4973,12 +4972,12 @@ union cvmx_bgxx_smux_cbfc_ctl {
 	uint64_t u64;
 	struct cvmx_bgxx_smux_cbfc_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t phys_en                      : 16; /**< Physical backpressure enable. Determines which LMACs will have physical backpressure PAUSE
-                                                         packets. The value placed in the Class Enable Vector field of the PFC/CBFC PAUSE packet is
-                                                         PHYS_EN | LOGL_EN. */
-	uint64_t logl_en                      : 16; /**< Logical backpressure enable. Determines which LMACs will have logical backpressure PAUSE
-                                                         packets. The value placed in the Class Enable Vector field of the PFC/CBFC PAUSE packet is
-                                                         PHYS_EN | LOGL_EN. */
+	uint64_t phys_en                      : 16; /**< Physical backpressure enable. Determines which classes/channels will have physical
+                                                         backpressure PAUSE packets. The value placed in the class enable vector field of the
+                                                         PFC/CBFC PAUSE packet is PHYS_EN | LOGL_EN. */
+	uint64_t logl_en                      : 16; /**< Logical backpressure enable. Determines which classes/channels will have logical
+                                                         backpressure PAUSE packets. The value placed in the class enable vector field of the
+                                                         PFC/CBFC PAUSE packet is PHYS_EN | LOGL_EN. */
 	uint64_t reserved_4_31                : 28;
 	uint64_t bck_en                       : 1;  /**< Forward PFC/CBFC PAUSE information to the backpressure block. */
 	uint64_t drp_en                       : 1;  /**< Drop-control enable. When set, drop PFC/CBFC PAUSE frames. */
@@ -5804,11 +5803,11 @@ typedef union cvmx_bgxx_smux_tx_thresh cvmx_bgxx_smux_tx_thresh_t;
  * cvmx_bgx#_spu#_an_adv
  *
  * Software programs this register with the contents of the AN-link code word base page to be
- * transmitted during Auto-Negotiation. (See Std 802.3 section 73.6 for details.) Any write
- * operations to this register prior to completion of Auto-Negotiation, as indicated by
+ * transmitted during autonegotiation. (See Std 802.3 section 73.6 for details.) Any write
+ * operations to this register prior to completion of autonegotiation, as indicated by
  * BGX()_SPU()_AN_STATUS[AN_COMPLETE], should be followed by a renegotiation in order for
  * the new values to take effect. Renegotiation is initiated by setting
- * BGX()_SPU()_AN_CONTROL[AN_RESTART]. Once Auto-Negotiation has completed, software can
+ * BGX()_SPU()_AN_CONTROL[AN_RESTART]. Once autonegotiation has completed, software can
  * examine this register along with BGX()_SPU()_AN_LP_BASE to determine the highest
  * common denominator technology.
  */
@@ -5825,10 +5824,10 @@ union cvmx_bgxx_spux_an_adv {
 	uint64_t a40g_kr4                     : 1;  /**< 40GBASE-KR4 ability. */
 	uint64_t a10g_kr                      : 1;  /**< 10GBASE-KR ability. */
 	uint64_t a10g_kx4                     : 1;  /**< 10GBASE-KX4 ability. */
-	uint64_t a1g_kx                       : 1;  /**< 1000BASE-KX ability. Should always be 0; Auto-Negotiation is not supported for 1000Base-KX. */
+	uint64_t a1g_kx                       : 1;  /**< 1000BASE-KX ability. Should always be 0; Autonegotiation is not supported for 1000Base-KX. */
 	uint64_t t                            : 5;  /**< Transmitted nonce. This field is automatically updated with a pseudo-random value on entry
                                                          to the AN ability detect state. */
-	uint64_t np                           : 1;  /**< Next page. Always 0; extended next pages are not used for 10G+ Auto-Negotiation. */
+	uint64_t np                           : 1;  /**< Next page. Always 0; extended next pages are not used for 10G+ Autonegotiation. */
 	uint64_t ack                          : 1;  /**< Acknowledge. Always 0 in this register. */
 	uint64_t rf                           : 1;  /**< Remote fault. */
 	uint64_t xnp_able                     : 1;  /**< Extended next page ability. */
@@ -5867,7 +5866,7 @@ typedef union cvmx_bgxx_spux_an_adv cvmx_bgxx_spux_an_adv_t;
  * cvmx_bgx#_spu#_an_bp_status
  *
  * The contents of this register (with the exception of the static BP_AN_ABLE bit) are updated
- * during Auto-Negotiation and are valid when BGX()_SPU()_AN_STATUS[AN_COMPLETE] is set.
+ * during autonegotiation and are valid when BGX()_SPU()_AN_STATUS[AN_COMPLETE] is set.
  * At that time, one of the port type bits (A100G_CR10, A40G_CR4, A40G_KR4, A10G_KR, A10G_KX4,
  * A1G_KX) will be set depending on the AN priority resolution. If a BASE-R type is negotiated,
  * then the FEC bit will be set to indicate that FEC operation has been negotiated, and will be
@@ -5912,7 +5911,7 @@ union cvmx_bgxx_spux_an_control {
 	struct cvmx_bgxx_spux_an_control_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t an_reset                     : 1;  /**< Auto-Negotiation reset. Setting this bit or BGX()_SPU()_CONTROL1[RESET] to 1
+	uint64_t an_reset                     : 1;  /**< Autonegotiation reset. Setting this bit or BGX()_SPU()_CONTROL1[RESET] to 1
                                                          causes the following to happen:
                                                          * Resets the logical PCS (LPCS)
                                                          * Sets the Std 802.3 PCS, FEC and AN registers for the LPCS to their default states
@@ -5921,11 +5920,11 @@ union cvmx_bgxx_spux_an_control {
                                                          automatically cleared. */
 	uint64_t reserved_14_14               : 1;
 	uint64_t xnp_en                       : 1;  /**< Extended next-page enable. */
-	uint64_t an_en                        : 1;  /**< Auto-Negotiation enable. This bit should not be set when
-                                                         BGX()_CMR()_CONFIG[LMAC_TYPE] is set to RXAUI; auto-negotiation is not supported
+	uint64_t an_en                        : 1;  /**< Autonegotiation enable. This bit should not be set when
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE] is set to RXAUI; autonegotiation is not supported
                                                          in RXAUI mode. */
 	uint64_t reserved_10_11               : 2;
-	uint64_t an_restart                   : 1;  /**< Auto-Negotiation restart. Writing a 1 to this bit restarts the Auto-Negotiation process if
+	uint64_t an_restart                   : 1;  /**< Autonegotiation restart. Writing a 1 to this bit restarts the autonegotiation process if
                                                          AN_EN is also set. This is a self-clearing bit. */
 	uint64_t reserved_0_8                 : 9;
 #else
@@ -5947,7 +5946,7 @@ typedef union cvmx_bgxx_spux_an_control cvmx_bgxx_spux_an_control_t;
  * cvmx_bgx#_spu#_an_lp_base
  *
  * This register captures the contents of the latest AN link code word base page received from
- * the link partner during Auto-Negotiation. (See Std 802.3 section 73.6 for details.)
+ * the link partner during autonegotiation. (See Std 802.3 section 73.6 for details.)
  * BGX()_SPU()_AN_STATUS[PAGE_RX] is set when this register is updated by hardware.
  */
 union cvmx_bgxx_spux_an_lp_base {
@@ -6003,7 +6002,7 @@ typedef union cvmx_bgxx_spux_an_lp_base cvmx_bgxx_spux_an_lp_base_t;
  * cvmx_bgx#_spu#_an_lp_xnp
  *
  * This register captures the contents of the latest next page code word received from the link
- * partner during Auto-Negotiation, if any. See section 802.3 section 73.7.7 for details.
+ * partner during autonegotiation, if any. See section 802.3 section 73.7.7 for details.
  */
 union cvmx_bgxx_spux_an_lp_xnp {
 	uint64_t u64;
@@ -6041,24 +6040,24 @@ union cvmx_bgxx_spux_an_status {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t prl_flt                      : 1;  /**< Parallel detection fault. Always 0; SPU does not support parallel detection as part of the
-                                                         auto-negotiation protocol. */
+                                                         autonegotiation protocol. */
 	uint64_t reserved_8_8                 : 1;
 	uint64_t xnp_stat                     : 1;  /**< Extended next-page status. */
 	uint64_t page_rx                      : 1;  /**< Page received. This latching-high bit is set when a new page has been received and stored
                                                          in BGX()_SPU()_AN_LP_BASE or BGX()_SPU()_AN_LP_XNP; stays set until a 1 is
-                                                         written by software, Auto-Negotiation is disabled or restarted, or next page exchange is
+                                                         written by software, Autonegotiation is disabled or restarted, or next page exchange is
                                                          initiated. Note that in order to avoid read side effects, this is implemented as a
                                                          write-1-to-clear bit, rather than latching high read-only as specified in 802.3. */
-	uint64_t an_complete                  : 1;  /**< Auto-Negotiation complete. Set when the Auto-Negotiation process has been completed and
+	uint64_t an_complete                  : 1;  /**< Autonegotiation complete. Set when the autonegotiation process has been completed and
                                                          the link is up and running using the negotiated highest common denominator (HCD)
                                                          technology. If AN is enabled (BGX()_SPU()_AN_CONTROL[AN_EN] = 1) and this bit is
                                                          read as a zero, it indicates that the AN process has not been completed, and the contents
                                                          of BGX()_SPU()_AN_LP_BASE, BGX()_SPU()_AN_XNP_TX, and
-                                                         BGX()_SPU()_AN_LP_XNP are as defined by the current state of the Auto-Negotiation
+                                                         BGX()_SPU()_AN_LP_XNP are as defined by the current state of the autonegotiation
                                                          protocol, or as written for manual configuration. This bit is always zero when AN is
                                                          disabled (BGX()_SPU()_AN_CONTROL[AN_EN] = 0). */
 	uint64_t rmt_flt                      : 1;  /**< Remote fault: Always 0. */
-	uint64_t an_able                      : 1;  /**< Auto-Negotiation ability: Always 1. */
+	uint64_t an_able                      : 1;  /**< Autonegotiation ability: Always 1. */
 	uint64_t link_status                  : 1;  /**< Link status. This bit captures the state of the link_status variable as defined in 802.3
                                                          section 73.9.1. When set, indicates that a valid link has been established. When clear,
                                                          indicates that the link has been invalid after this bit was last set by software. Latching
@@ -6066,8 +6065,8 @@ union cvmx_bgxx_spux_an_status {
                                                          side effects, this is implemented as a write-1-to-set bit, rather than latching low read-
                                                          only as specified in 802.3. */
 	uint64_t reserved_1_1                 : 1;
-	uint64_t lp_an_able                   : 1;  /**< Link partner Auto-Negotiation ability. Set to indicate that the link partner is able to
-                                                         participate in the Auto-Negotiation function, and cleared otherwise. */
+	uint64_t lp_an_able                   : 1;  /**< Link partner autonegotiation ability. Set to indicate that the link partner is able to
+                                                         participate in the autonegotiation function, and cleared otherwise. */
 #else
 	uint64_t lp_an_able                   : 1;
 	uint64_t reserved_1_1                 : 1;
@@ -6090,7 +6089,7 @@ typedef union cvmx_bgxx_spux_an_status cvmx_bgxx_spux_an_status_t;
  * cvmx_bgx#_spu#_an_xnp_tx
  *
  * Software programs this register with the contents of the AN message next page or unformatted
- * next page link code word to be transmitted during auto-negotiation. Next page exchange occurs
+ * next page link code word to be transmitted during autonegotiation. Next page exchange occurs
  * after the base link code words have been exchanged if either end of the link segment sets the
  * NP bit to 1, indicating that it has at least one next page to send. Once initiated, next page
  * exchange continues until both ends of the link segment set their NP bits to 0. See section
@@ -6960,12 +6959,12 @@ union cvmx_bgxx_spux_int {
                                                          successfully completed BASE-R PMD link training. Valid if the LPCS type selected by
                                                          BGX()_CMR()_CONFIG[LMAC_TYPE] is 10GBASE-R or 40GBASE-R and
                                                          BGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is 1, and never set otherwise. */
-	uint64_t an_complete                  : 1;  /**< Auto-Negotiation complete. Set when BGX()_SPU()_AN_STATUS[AN_COMPLETE] is set,
-                                                         indicating that the Auto-Negotiation process has been completed and the link is up and
+	uint64_t an_complete                  : 1;  /**< Autonegotiation complete. Set when BGX()_SPU()_AN_STATUS[AN_COMPLETE] is set,
+                                                         indicating that the autonegotiation process has been completed and the link is up and
                                                          running using the negotiated highest common denominator (HCD) technology. */
-	uint64_t an_link_good                 : 1;  /**< Auto-Negotiation link good. Set when the an_link_good variable is set as defined in
-                                                         802.3-2008 Figure 73-11, indicating that Auto-Negotiation has completed. */
-	uint64_t an_page_rx                   : 1;  /**< Auto-Negotiation page received. This bit is set along with
+	uint64_t an_link_good                 : 1;  /**< Autonegotiation link good. Set when the an_link_good variable is set as defined in
+                                                         802.3-2008 Figure 73-11, indicating that autonegotiation has completed. */
+	uint64_t an_page_rx                   : 1;  /**< Autonegotiation page received. This bit is set along with
                                                          BGX()_SPU()_AN_STATUS[PAGE_RX] when a new page has been received and stored in
                                                          BGX()_SPU()_AN_LP_BASE or BGX()_SPU()_AN_LP_XNP. */
 	uint64_t fec_uncorr                   : 1;  /**< Uncorrectable FEC error. Set when an FEC block with an uncorrectable error is received on
@@ -7273,10 +7272,10 @@ union cvmx_bgxx_spu_dbg_control {
 	uint64_t br_ber_mon_dis               : 1;  /**< BASE-R bit error rate monitor disable. This bit should be clear for normal operation.
                                                          Setting it disables the BASE-R BER monitor state machine defined in 802.3-2008 Figure
                                                          49-13 for 10GBASE-R and 802.3ba-2010 Figure 82-13 for 40GBASE-R. */
-	uint64_t an_nonce_match_dis           : 1;  /**< Auto-Negotiation nonce match disable. This bit should be clear for normal operation.
+	uint64_t an_nonce_match_dis           : 1;  /**< Autonegotiation nonce match disable. This bit should be clear for normal operation.
                                                          Setting it disables Nonce Match check by forcing nonce_match variable to 0 in the Auto-
                                                          Negotiation arbitration state diagram, as defined in 802.3-2008 Figure 73-11. This bit can
-                                                         be set by software for test purposes, e.g. for running auto-negotiation in loopback mode. */
+                                                         be set by software for test purposes, e.g. for running autonegotiation in loopback mode. */
 	uint64_t timestamp_norm_dis           : 1;  /**< 40GBASE-R RX timestamp normalization disable. This bit controls the generation of the
                                                          receive SOP timestamp passed to the SMU sub-block for a 40GBASE-R LMAC/LPCS. When this bit
                                                          is clear, SPU normalizes the receive SOP timestamp in order to compensate for lane-to-lane
@@ -7320,19 +7319,19 @@ union cvmx_bgxx_spu_dbg_control {
                                                          BGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set, the link training protocol is fully
                                                          automated in hardware, whereby the contents BGX()_SPU()_BR_PMD_LD_CUP and
                                                          BGX()_SPU()_BR_PMD_LD_REP registers are automatically updated by hardware. */
-	uint64_t an_arb_link_chk_en           : 1;  /**< Enable link status checking by Auto-Negotiation arbitration state machine. When Auto-
+	uint64_t an_arb_link_chk_en           : 1;  /**< Enable link status checking by autonegotiation arbitration state machine. When Auto-
                                                          Negotiation is enabled (BGX()_SPU()_AN_CONTROL[AN_EN] is set), this bit controls
-                                                         the behavior of the Auto-Negotiation arbitration state machine when it reaches the AN GOOD
+                                                         the behavior of the autonegotiation arbitration state machine when it reaches the AN GOOD
                                                          CHECK state after DME pages are successfully exchanged, as defined in Figure 73-11 in
                                                          802.3-2008.
                                                          When this bit is set and the negotiated highest common denominator (HCD) technology
-                                                         matches BGX()_CMR()_CONFIG[LMAC_TYPE], the Auto-Negotiation arbitration SM
+                                                         matches BGX()_CMR()_CONFIG[LMAC_TYPE], the autonegotiation arbitration SM
                                                          performs the actions defined for the AN GOOD CHECK state in Figure 73-11, i.e. run the
                                                          link_fail_inhibit timer and eventually transition to the AN GOOD or TRANSMIT DISABLE
                                                          state.
                                                          When this bit is clear or the HCD technology does not match LMAC_TYPE, the AN arbitration
                                                          SM stays in the AN GOOD CHECK state, with the expectation that software will perform the
-                                                         appropriate actions to complete the Auto-Negotiation protocol, as follows:
+                                                         appropriate actions to complete the autonegotiation protocol, as follows:
                                                          * If this bit is clear and the HCD technology matches LMAC_TYPE, clear AN_EN in
                                                          AN_CONTROL.
                                                          * Otherwise, disable the LPCS by clearing the BGX()_CMR()_CONFIG[ENABLE], clear
@@ -7458,8 +7457,8 @@ union cvmx_bgxx_spu_sdsx_states {
 	uint64_t train_lock_found_1st_marker  : 1;  /**< Link training lock state machine found first marker flag. */
 	uint64_t train_lock_bad_markers       : 3;  /**< Link training lock state machine bad markers counter. */
 	uint64_t reserved_35_35               : 1;
-	uint64_t an_arb_sm                    : 3;  /**< Auto-Negotiation arbitration state machine state. */
-	uint64_t an_rx_sm                     : 2;  /**< Auto-Negotiation receive state machine state. */
+	uint64_t an_arb_sm                    : 3;  /**< Autonegotiation arbitration state machine state. */
+	uint64_t an_rx_sm                     : 2;  /**< Autonegotiation receive state machine state. */
 	uint64_t reserved_29_29               : 1;
 	uint64_t fec_block_sync               : 1;  /**< FEC block sync status. */
 	uint64_t fec_sync_cnt                 : 4;  /**< FEC block sync state machine good/bad parity block counter. */
diff --git a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
index e03d950..ed35782 100644
--- a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
@@ -2129,18 +2129,38 @@ typedef union cvmx_dpi_ncbx_cfg cvmx_dpi_ncbx_cfg_t;
 /**
  * cvmx_dpi_ncb_ctl
  *
- * This register provides NCB unit control.
+ * This register chooses which NCB interface to direct traffic for internal only transactions.
  *
  */
 union cvmx_dpi_ncb_ctl {
 	uint64_t u64;
 	struct cvmx_dpi_ncb_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_1_63                : 63;
-	uint64_t prt                          : 1;  /**< Directs traffic to the specified NCB unit. */
+	uint64_t reserved_25_63               : 39;
+	uint64_t ncbsel_prt_xor_dis           : 1;  /**< Reserved. */
+	uint64_t reserved_21_23               : 3;
+	uint64_t ncbsel_zbw                   : 1;  /**< Reserved. */
+	uint64_t reserved_17_19               : 3;
+	uint64_t ncbsel_req                   : 1;  /**< Reserved. */
+	uint64_t reserved_13_15               : 3;
+	uint64_t ncbsel_dst                   : 1;  /**< Reserved. */
+	uint64_t reserved_9_11                : 3;
+	uint64_t ncbsel_src                   : 1;  /**< Reserved. */
+	uint64_t reserved_1_7                 : 7;
+	uint64_t prt                          : 1;  /**< Directs traffic to the specified NCB unit. (Pass 1 only) */
 #else
 	uint64_t prt                          : 1;
-	uint64_t reserved_1_63                : 63;
+	uint64_t reserved_1_7                 : 7;
+	uint64_t ncbsel_src                   : 1;
+	uint64_t reserved_9_11                : 3;
+	uint64_t ncbsel_dst                   : 1;
+	uint64_t reserved_13_15               : 3;
+	uint64_t ncbsel_req                   : 1;
+	uint64_t reserved_17_19               : 3;
+	uint64_t ncbsel_zbw                   : 1;
+	uint64_t reserved_21_23               : 3;
+	uint64_t ncbsel_prt_xor_dis           : 1;
+	uint64_t reserved_25_63               : 39;
 #endif
 	} s;
 	struct cvmx_dpi_ncb_ctl_s             cn78xx;
@@ -2412,6 +2432,112 @@ union cvmx_dpi_sli_prtx_cfg {
 	uint64_t u64;
 	struct cvmx_dpi_sli_prtx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t ncbsel                       : 1;  /**< Reserved. */
+	uint64_t reserved_25_27               : 3;
+	uint64_t halt                         : 1;  /**< When set, HALT indicates that the MAC has detected
+                                                         a reset condition. No further instructions that
+                                                         reference the MAC from any instruction Q will be
+                                                         issued until the MAC comes out of reset and HALT
+                                                         is cleared in SLI_CTL_PORTx[DIS_PORT]. */
+	uint64_t qlm_cfg                      : 4;  /**< QLM_CFG is a function of MIO_QLMx_CFG[QLM_CFG]
+                                                         QLM_CFG may contain values that are not normally
+                                                         used for DMA and/or packet operations.
+                                                         QLM_CFG does not indicate if a port is disabled.
+                                                         MIO_QLMx_CFG can be used for more complete QLM
+                                                         configuration information.
+                                                         0000 = MAC is PCIe 1x4 (QLM) or 1x2 (DLM)
+                                                         0001 = MAC is PCIe 2x1 (DLM only)
+                                                         0010 = MAC is SGMII
+                                                         0011 = MAC is XAUI
+                                                         all other encodings are RESERVED */
+	uint64_t reserved_17_19               : 3;
+	uint64_t rd_mode                      : 1;  /**< Read Mode
+                                                         0=Exact Read Mode
+                                                           If the port is a PCIe port, the HW reads on a
+                                                           4B granularity.  In this mode, the HW may break
+                                                           a given read into 3 operations to satisify
+                                                           PCIe rules.
+                                                           If the port is a SRIO port, the HW follows the
+                                                           SRIO read rules from the SRIO specification and
+                                                            only issues 32*n, 16, and 8 byte  operations
+                                                            on the SRIO bus.
+                                                         1=Block Mode
+                                                           The HW will read more data than requested in
+                                                           order to minimize the number of operations
+                                                           necessary to complete the operation.
+                                                           The memory region must be memory like. */
+	uint64_t reserved_14_15               : 2;
+	uint64_t molr                         : 6;  /**< Max Outstanding Load Requests
+                                                         Limits the number of oustanding load requests on
+                                                         the port by restricting the number of tags
+                                                         used by the SLI to track load responses.  This
+                                                         value can range from 1 to 32 depending on the MAC
+                                                         type and number of lanes.
+                                                         MAC == PCIe:           Max is 32
+                                                         MAC == sRio / 4 lanes: Max is 32
+                                                         MAC == sRio / 2 lanes: Max is 16
+                                                         MAC == sRio / 1 lane:  Max is  8
+                                                         Reset value is computed based on the MAC config.
+                                                         Setting MOLR to a value of 0 will halt all read
+                                                         traffic to the port.  There are no restrictions
+                                                         on when this value can be changed. */
+	uint64_t mps_lim                      : 1;  /**< MAC memory space write requests cannot cross the
+                                                         (naturally-aligned) MPS boundary.
+                                                         When clear, DPI is allowed to issue a MAC memory
+                                                         space read that crosses the naturally-aligned
+                                                         boundary of size defined by MPS. (DPI will still
+                                                         only cross the boundary when it would eliminate a
+                                                         write by doing so.)
+                                                         When set, DPI will never issue a MAC memory space
+                                                         write that crosses the naturally-aligned boundary
+                                                         of size defined by MPS. */
+	uint64_t reserved_5_6                 : 2;
+	uint64_t mps                          : 1;  /**< Max Payload Size
+                                                                 0 = 128B
+                                                                 1 = 256B
+                                                         For PCIe MACs, this MPS size must not exceed
+                                                               the size selected by PCIE*_CFG030[MPS].
+                                                         For sRIO MACs, all MPS values are allowed. */
+	uint64_t mrrs_lim                     : 1;  /**< MAC memory space read requests cannot cross the
+                                                         (naturally-aligned) MRRS boundary.
+                                                         When clear, DPI is allowed to issue a MAC memory
+                                                         space read that crosses the naturally-aligned
+                                                         boundary of size defined by MRRS. (DPI will still
+                                                         only cross the boundary when it would eliminate a
+                                                         read by doing so.)
+                                                         When set, DPI will never issue a MAC memory space
+                                                         read that crosses the naturally-aligned boundary
+                                                         of size defined by MRRS. */
+	uint64_t reserved_2_2                 : 1;
+	uint64_t mrrs                         : 2;  /**< Max Read Request Size
+                                                                 0 = 128B
+                                                                 1 = 256B
+                                                                 2 = 512B
+                                                                 3 = 1024B
+                                                         For PCIe MACs, this MRRS size must not exceed
+                                                               the size selected by PCIE*_CFG030[MRRS].
+                                                         For sRIO MACs, this MRRS size must be <= 256B. */
+#else
+	uint64_t mrrs                         : 2;
+	uint64_t reserved_2_2                 : 1;
+	uint64_t mrrs_lim                     : 1;
+	uint64_t mps                          : 1;
+	uint64_t reserved_5_6                 : 2;
+	uint64_t mps_lim                      : 1;
+	uint64_t molr                         : 6;
+	uint64_t reserved_14_15               : 2;
+	uint64_t rd_mode                      : 1;
+	uint64_t reserved_17_19               : 3;
+	uint64_t qlm_cfg                      : 4;
+	uint64_t halt                         : 1;
+	uint64_t reserved_25_27               : 3;
+	uint64_t ncbsel                       : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} s;
+	struct cvmx_dpi_sli_prtx_cfg_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
 	uint64_t halt                         : 1;  /**< When set, HALT indicates that the MAC has detected
                                                          a reset condition. No further instructions that
@@ -2511,8 +2637,7 @@ union cvmx_dpi_sli_prtx_cfg {
 	uint64_t halt                         : 1;
 	uint64_t reserved_25_63               : 39;
 #endif
-	} s;
-	struct cvmx_dpi_sli_prtx_cfg_s        cn61xx;
+	} cn61xx;
 	struct cvmx_dpi_sli_prtx_cfg_cn63xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
@@ -2608,7 +2733,7 @@ union cvmx_dpi_sli_prtx_cfg {
 #endif
 	} cn63xx;
 	struct cvmx_dpi_sli_prtx_cfg_cn63xx   cn63xxp1;
-	struct cvmx_dpi_sli_prtx_cfg_s        cn66xx;
+	struct cvmx_dpi_sli_prtx_cfg_cn61xx   cn66xx;
 	struct cvmx_dpi_sli_prtx_cfg_cn63xx   cn68xx;
 	struct cvmx_dpi_sli_prtx_cfg_cn63xx   cn68xxp1;
 	struct cvmx_dpi_sli_prtx_cfg_cn70xx {
@@ -2701,8 +2826,77 @@ union cvmx_dpi_sli_prtx_cfg {
 #endif
 	} cn70xx;
 	struct cvmx_dpi_sli_prtx_cfg_cn70xx   cn70xxp1;
-	struct cvmx_dpi_sli_prtx_cfg_cn63xx   cn78xx;
-	struct cvmx_dpi_sli_prtx_cfg_s        cnf71xx;
+	struct cvmx_dpi_sli_prtx_cfg_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t ncbsel                       : 1;  /**< Reserved. */
+	uint64_t reserved_25_27               : 3;
+	uint64_t halt                         : 1;  /**< When set, HALT indicates that the MAC has detected a reset condition. No further
+                                                         instructions that reference the MAC from any instruction queue will be issued until the
+                                                         MAC comes out of reset and HALT is cleared in SLI_CTL_PORT()[DIS_PORT]. */
+	uint64_t reserved_21_23               : 3;
+	uint64_t qlm_cfg                      : 1;  /**< Read only copy of the QLM CFG pin.
+                                                         0 = MAC is DPI.
+                                                         1 = Reserved.
+                                                         Since QLM_CFG is simply a copy of the QLM CFG pins, it could reflect values that are not
+                                                         normal for DMA or packet operations. QLM_CFG does not indicate if a port is disabled.
+                                                         GSER()_CFG can be used for more complete QLM configuration information. */
+	uint64_t reserved_17_19               : 3;
+	uint64_t rd_mode                      : 1;  /**< Read mode.
+                                                         0 = Exact read mode. The hardware reads on a four-byte granularity. In this mode, the
+                                                         hardware may break a given read into 3 operations to satisfy DPI rules.
+                                                         1 = Block mode. The hardware reads more data than requested in order to minimize the
+                                                         number of operations necessary to complete the operation. The memory region must be memory
+                                                         like. */
+	uint64_t reserved_14_15               : 2;
+	uint64_t molr                         : 6;  /**< Maximum outstanding load requests. Limits the number of outstanding load requests on the
+                                                         port by restricting the number of tags used by the SLI to track load responses. This value
+                                                         can range from 1 to 32. Setting MOLR to a value of 0 halts all read traffic to the port.
+                                                         There are no restrictions on when this value can be changed. */
+	uint64_t mps_lim                      : 1;  /**< MAC memory space write requests cannot cross the (naturally-aligned) MPS boundary.
+                                                         When clear, DPI is allowed to issue a MAC memory- space read that crosses the naturally-
+                                                         aligned boundary of size defined by MPS. (DPI will still only cross the boundary when it
+                                                         would eliminate a write by doing so.)
+                                                         When set, DPI will never issue a MAC memory space write that crosses the naturally-aligned
+                                                         boundary of size defined by MPS. */
+	uint64_t reserved_5_6                 : 2;
+	uint64_t mps                          : 1;  /**< Maximum payload size.
+                                                         0 = 128B.
+                                                         1 = 256B.
+                                                         The MPS size must not exceed the size selected by PCIE*_CFG030[MPS]. */
+	uint64_t mrrs_lim                     : 1;  /**< MAC memory space read requests cannot cross the (naturally-aligned) MRRS boundary.
+                                                         When clear, DPI is allowed to issue a MAC memory-space read that crosses the naturally-
+                                                         aligned boundary of size defined by MRRS. (DPI will still only cross the boundary when it
+                                                         would eliminate a read by doing so.)
+                                                         When set, DPI will never issue a MAC memory space read that crosses the naturally-aligned
+                                                         boundary of size defined by MRRS. */
+	uint64_t reserved_2_2                 : 1;
+	uint64_t mrrs                         : 2;  /**< Maximum read-request size.
+                                                         0x0 = 128B.
+                                                         0x1 = 256B.
+                                                         0x2 = 512B.
+                                                         0x3 = 1024B.
+                                                         The MRRS size must not exceed the size selected by PCIE*_CFG030[MRRS]. */
+#else
+	uint64_t mrrs                         : 2;
+	uint64_t reserved_2_2                 : 1;
+	uint64_t mrrs_lim                     : 1;
+	uint64_t mps                          : 1;
+	uint64_t reserved_5_6                 : 2;
+	uint64_t mps_lim                      : 1;
+	uint64_t molr                         : 6;
+	uint64_t reserved_14_15               : 2;
+	uint64_t rd_mode                      : 1;
+	uint64_t reserved_17_19               : 3;
+	uint64_t qlm_cfg                      : 1;
+	uint64_t reserved_21_23               : 3;
+	uint64_t halt                         : 1;
+	uint64_t reserved_25_27               : 3;
+	uint64_t ncbsel                       : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} cn78xx;
+	struct cvmx_dpi_sli_prtx_cfg_cn61xx   cnf71xx;
 };
 typedef union cvmx_dpi_sli_prtx_cfg cvmx_dpi_sli_prtx_cfg_t;
 
@@ -2836,6 +3030,9 @@ typedef union cvmx_dpi_sli_prtx_err_info cvmx_dpi_sli_prtx_err_info_t;
 
 /**
  * cvmx_dpi_swa_q_vmid
+ *
+ * Not used.
+ *
  */
 union cvmx_dpi_swa_q_vmid {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
index 2f6086f..155a93b 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
@@ -889,7 +889,8 @@ union cvmx_fpa_aurax_cnt_levels {
 	uint64_t u64;
 	struct cvmx_fpa_aurax_cnt_levels_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_40_63               : 24;
+	uint64_t reserved_41_63               : 23;
+	uint64_t drop_dis                     : 1;  /**< Reserved. */
 	uint64_t bp_ena                       : 1;  /**< Enable backpressure based on [BP] level. If set FPA_GEN_CFG[LVL_DLY] must be nonzero.
                                                          PKI_AURA()_CFG[ENA_BP] must also be set for backpressure to propagate through PKI. */
 	uint64_t red_ena                      : 1;  /**< Enable aura RED based on [DROP] and [PASS] levels. If set FPA_GEN_CFG[LVL_DLY] must be
@@ -924,7 +925,8 @@ union cvmx_fpa_aurax_cnt_levels {
 	uint64_t shift                        : 6;
 	uint64_t red_ena                      : 1;
 	uint64_t bp_ena                       : 1;
-	uint64_t reserved_40_63               : 24;
+	uint64_t drop_dis                     : 1;
+	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
 	struct cvmx_fpa_aurax_cnt_levels_s    cn78xx;
@@ -1020,7 +1022,8 @@ union cvmx_fpa_aurax_pool_levels {
 	uint64_t u64;
 	struct cvmx_fpa_aurax_pool_levels_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_40_63               : 24;
+	uint64_t reserved_41_63               : 23;
+	uint64_t drop_dis                     : 1;  /**< Reserved. */
 	uint64_t bp_ena                       : 1;  /**< Enable aura-unique pool backpressure based on [BP] level. If set FPA_GEN_CFG[LVL_DLY] must
                                                          be nonzero. */
 	uint64_t red_ena                      : 1;  /**< Enable aura-unique pool RED based on [DROP] and [PASS] levels. If set FPA_GEN_CFG[LVL_DLY]
@@ -1061,7 +1064,8 @@ union cvmx_fpa_aurax_pool_levels {
 	uint64_t shift                        : 6;
 	uint64_t red_ena                      : 1;
 	uint64_t bp_ena                       : 1;
-	uint64_t reserved_40_63               : 24;
+	uint64_t drop_dis                     : 1;
+	uint64_t reserved_41_63               : 23;
 #endif
 	} s;
 	struct cvmx_fpa_aurax_pool_levels_s   cn78xx;
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index c70f97d..92d23ce 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -757,6 +757,17 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_CTLE_CTRL(unsigned long offset, unsig
 #define CVMX_GSERX_LANEX_RX_CTLE_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440058ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_LOOP_CTRL(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_LOOP_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440048ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_LOOP_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440048ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_RX_MISC_OVRRD(unsigned long offset, unsigned long block_id)
 {
 	if (!(
@@ -2852,7 +2863,7 @@ typedef union cvmx_gserx_dlmx_tx_term_offset cvmx_gserx_dlmx_tx_term_offset_t;
  * cvmx_gser#_eq_wait_time
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_eq_wait_time {
@@ -2878,7 +2889,7 @@ typedef union cvmx_gserx_eq_wait_time cvmx_gserx_eq_wait_time_t;
  * cvmx_gser#_glbl_tad
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_glbl_tad {
@@ -2946,7 +2957,7 @@ typedef union cvmx_gserx_glbl_tad cvmx_gserx_glbl_tad_t;
  * cvmx_gser#_glbl_tm_admon
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_glbl_tm_admon {
@@ -2978,7 +2989,7 @@ typedef union cvmx_gserx_glbl_tm_admon cvmx_gserx_glbl_tm_admon_t;
 /**
  * cvmx_gser#_iddq_mode
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_iddq_mode {
@@ -2999,7 +3010,7 @@ typedef union cvmx_gserx_iddq_mode cvmx_gserx_iddq_mode_t;
 /**
  * cvmx_gser#_lane#_lbert_cfg
  *
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_lbert_cfg {
@@ -3073,7 +3084,7 @@ typedef union cvmx_gserx_lanex_lbert_cfg cvmx_gserx_lanex_lbert_cfg_t;
 /**
  * cvmx_gser#_lane#_lbert_ecnt
  *
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  * The error registers are reset on a read-only when the pattern matcher is enabled.
  * If the pattern matcher is disabled, the registers return the error count that was
@@ -3103,7 +3114,7 @@ typedef union cvmx_gserx_lanex_lbert_ecnt cvmx_gserx_lanex_lbert_ecnt_t;
 /**
  * cvmx_gser#_lane#_lbert_pat_cfg
  *
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_lbert_pat_cfg {
@@ -3127,7 +3138,7 @@ typedef union cvmx_gserx_lanex_lbert_pat_cfg cvmx_gserx_lanex_lbert_pat_cfg_t;
  * cvmx_gser#_lane#_misc_cfg_0
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_misc_cfg_0 {
@@ -3173,7 +3184,7 @@ typedef union cvmx_gserx_lanex_misc_cfg_0 cvmx_gserx_lanex_misc_cfg_0_t;
  * cvmx_gser#_lane#_misc_cfg_1
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_misc_cfg_1 {
@@ -3211,7 +3222,7 @@ typedef union cvmx_gserx_lanex_misc_cfg_1 cvmx_gserx_lanex_misc_cfg_1_t;
  * cvmx_gser#_lane#_pcs_ctlifc_0
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_pcs_ctlifc_0 {
@@ -3262,7 +3273,7 @@ typedef union cvmx_gserx_lanex_pcs_ctlifc_0 cvmx_gserx_lanex_pcs_ctlifc_0_t;
  * cvmx_gser#_lane#_pcs_ctlifc_1
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_pcs_ctlifc_1 {
@@ -3294,7 +3305,7 @@ typedef union cvmx_gserx_lanex_pcs_ctlifc_1 cvmx_gserx_lanex_pcs_ctlifc_1_t;
  * cvmx_gser#_lane#_pcs_ctlifc_2
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_pcs_ctlifc_2 {
@@ -3355,7 +3366,7 @@ typedef union cvmx_gserx_lanex_pcs_ctlifc_2 cvmx_gserx_lanex_pcs_ctlifc_2_t;
  * cvmx_gser#_lane#_pma_loopback_ctrl
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_pma_loopback_ctrl {
@@ -3379,7 +3390,7 @@ typedef union cvmx_gserx_lanex_pma_loopback_ctrl cvmx_gserx_lanex_pma_loopback_c
  * cvmx_gser#_lane#_pwr_ctrl
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_pwr_ctrl {
@@ -3407,7 +3418,8 @@ union cvmx_gserx_lanex_pwr_ctrl {
                                                          signal. When set, reset control signals are specified in
                                                          [RX_PCS_RESET_OVRRD_VAL]. */
 	uint64_t rx_lctrl_ovrrd_en            : 1;  /**< Override RX Power State machine loop control
-                                                         signals. */
+                                                         signals.  When set, the loop control settings are
+                                                         specified in the GSER()_LANE()_RX_LOOP_CTRL[CFG_RX_LCTRL] field. */
 	uint64_t rx_lctrl_ovrrd_val           : 1;  /**< Override RX Power State machine power down
                                                          control signal. When set, the power down control signal is
                                                          specified by GSER()_LANE()_RX_CFG_1[RX_CHPD_OVRRD_VAL]. */
@@ -3455,7 +3467,7 @@ typedef union cvmx_gserx_lanex_pwr_ctrl cvmx_gserx_lanex_pwr_ctrl_t;
  * cvmx_gser#_lane#_rx_aeq_out_0
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_aeq_out_0 {
@@ -3478,7 +3490,7 @@ typedef union cvmx_gserx_lanex_rx_aeq_out_0 cvmx_gserx_lanex_rx_aeq_out_0_t;
  * cvmx_gser#_lane#_rx_aeq_out_1
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_aeq_out_1 {
@@ -3502,7 +3514,7 @@ typedef union cvmx_gserx_lanex_rx_aeq_out_1 cvmx_gserx_lanex_rx_aeq_out_1_t;
  * cvmx_gser#_lane#_rx_aeq_out_2
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_aeq_out_2 {
@@ -3526,7 +3538,7 @@ typedef union cvmx_gserx_lanex_rx_aeq_out_2 cvmx_gserx_lanex_rx_aeq_out_2_t;
  * cvmx_gser#_lane#_rx_cfg_0
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_cfg_0 {
@@ -3574,7 +3586,7 @@ typedef union cvmx_gserx_lanex_rx_cfg_0 cvmx_gserx_lanex_rx_cfg_0_t;
  * cvmx_gser#_lane#_rx_cfg_1
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_cfg_1 {
@@ -3620,7 +3632,7 @@ typedef union cvmx_gserx_lanex_rx_cfg_1 cvmx_gserx_lanex_rx_cfg_1_t;
  * cvmx_gser#_lane#_rx_cfg_2
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_cfg_2 {
@@ -3662,7 +3674,7 @@ typedef union cvmx_gserx_lanex_rx_cfg_2 cvmx_gserx_lanex_rx_cfg_2_t;
  * cvmx_gser#_lane#_rx_cfg_3
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_cfg_3 {
@@ -3697,7 +3709,7 @@ typedef union cvmx_gserx_lanex_rx_cfg_3 cvmx_gserx_lanex_rx_cfg_3_t;
  * cvmx_gser#_lane#_rx_cfg_4
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_cfg_4 {
@@ -3732,7 +3744,7 @@ typedef union cvmx_gserx_lanex_rx_cfg_4 cvmx_gserx_lanex_rx_cfg_4_t;
  * cvmx_gser#_lane#_rx_cfg_5
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_cfg_5 {
@@ -3764,7 +3776,7 @@ typedef union cvmx_gserx_lanex_rx_cfg_5 cvmx_gserx_lanex_rx_cfg_5_t;
  * cvmx_gser#_lane#_rx_ctle_ctrl
  *
  * These are the RAW PCS per-lane RX CTLE control registers.
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_ctle_ctrl {
@@ -3807,10 +3819,46 @@ union cvmx_gserx_lanex_rx_ctle_ctrl {
 typedef union cvmx_gserx_lanex_rx_ctle_ctrl cvmx_gserx_lanex_rx_ctle_ctrl_t;
 
 /**
+ * cvmx_gser#_lane#_rx_loop_ctrl
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_loop_ctrl {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_loop_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t fast_dll_lock                : 1;  /**< Assert to enable fast DLL lock (for simulation purposes only). */
+	uint64_t fast_ofst_cncl               : 1;  /**< Assert to enable fast Offset cancellation (for simulation purposes only). */
+	uint64_t cfg_rx_lctrl                 : 10; /**< When GSER()_LANE()_PWR_CTRL[RX_LCTRL_OVRRD_EN] is set, loop control settings.
+                                                         0x0 = cdr_en_byp.
+                                                         0x1 = dfe_en_byp.
+                                                         0x2 = agc_en_byp.
+                                                         0x3 = ofst_cncl_en_byp.
+                                                         0x4 = CDR resetn.
+                                                         0x5 = CTLE resetn.
+                                                         0x6 = VMA resetn.
+                                                         0x7 = ofst_cncl_rstn_byp.
+                                                         0x8 = lctrl_men.
+                                                         0x9 - 0x3ff = Reserved. */
+#else
+	uint64_t cfg_rx_lctrl                 : 10;
+	uint64_t fast_ofst_cncl               : 1;
+	uint64_t fast_dll_lock                : 1;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_loop_ctrl_s cn78xx;
+};
+typedef union cvmx_gserx_lanex_rx_loop_ctrl cvmx_gserx_lanex_rx_loop_ctrl_t;
+
+/**
  * cvmx_gser#_lane#_rx_misc_ovrrd
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_misc_ovrrd {
@@ -3862,7 +3910,7 @@ typedef union cvmx_gserx_lanex_rx_misc_ovrrd cvmx_gserx_lanex_rx_misc_ovrrd_t;
  *
  * These are the RAW PCS per-lane RX precorrelation control registers. These registers are for
  * diagnostic use only.
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_precorr_ctrl {
@@ -3893,7 +3941,7 @@ typedef union cvmx_gserx_lanex_rx_precorr_ctrl cvmx_gserx_lanex_rx_precorr_ctrl_
 /**
  * cvmx_gser#_lane#_rx_valbbd_ctrl_0
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_valbbd_ctrl_0 {
@@ -3928,7 +3976,7 @@ typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_0 cvmx_gserx_lanex_rx_valbbd_ctrl_
 /**
  * cvmx_gser#_lane#_rx_valbbd_ctrl_1
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_valbbd_ctrl_1 {
@@ -3970,7 +4018,7 @@ typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_1 cvmx_gserx_lanex_rx_valbbd_ctrl_
 /**
  * cvmx_gser#_lane#_rx_valbbd_ctrl_2
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_valbbd_ctrl_2 {
@@ -4023,7 +4071,7 @@ typedef union cvmx_gserx_lanex_rx_valbbd_ctrl_2 cvmx_gserx_lanex_rx_valbbd_ctrl_
  *
  * These are the RAW PCS per-lane RX VMA control registers. These registers are for diagnostic
  * use only.
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_vma_ctrl {
@@ -4062,7 +4110,7 @@ typedef union cvmx_gserx_lanex_rx_vma_ctrl cvmx_gserx_lanex_rx_vma_ctrl_t;
  * cvmx_gser#_lane#_rx_vma_status_0
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_vma_status_0 {
@@ -4087,7 +4135,7 @@ typedef union cvmx_gserx_lanex_rx_vma_status_0 cvmx_gserx_lanex_rx_vma_status_0_
  * cvmx_gser#_lane#_rx_vma_status_1
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lanex_rx_vma_status_1 {
@@ -4116,7 +4164,7 @@ typedef union cvmx_gserx_lanex_rx_vma_status_1 cvmx_gserx_lanex_rx_vma_status_1_
 /**
  * cvmx_gser#_lane#_tx_cfg_0
  *
- * These registers are for diagnostic use only. These registers are only reset by hardware during
+ * These registers are for diagnostic use only. These registers are reset by hardware only during
  * chip cold reset. The values of the CSR fields in these registers do not change during chip
  * warm or soft resets.
  */
@@ -4156,7 +4204,7 @@ typedef union cvmx_gserx_lanex_tx_cfg_0 cvmx_gserx_lanex_tx_cfg_0_t;
 /**
  * cvmx_gser#_lane#_tx_cfg_1
  *
- * These registers are for diagnostic use only. These registers are only reset by hardware during
+ * These registers are for diagnostic use only. These registers are reset by hardware only during
  * chip cold reset. The values of the CSR fields in these registers do not change during chip
  * warm or soft resets.
  */
@@ -4217,7 +4265,7 @@ typedef union cvmx_gserx_lanex_tx_cfg_1 cvmx_gserx_lanex_tx_cfg_1_t;
 /**
  * cvmx_gser#_lane#_tx_cfg_2
  *
- * These registers are for diagnostic use only. These registers are only reset by hardware during
+ * These registers are for diagnostic use only. These registers are reset by hardware only during
  * chip cold reset. The values of the CSR fields in these registers do not change during chip
  * warm or soft resets.
  */
@@ -4248,7 +4296,7 @@ typedef union cvmx_gserx_lanex_tx_cfg_2 cvmx_gserx_lanex_tx_cfg_2_t;
 /**
  * cvmx_gser#_lane#_tx_cfg_3
  *
- * These registers are for diagnostic use only. These registers are only reset by hardware during
+ * These registers are for diagnostic use only. These registers are reset by hardware only during
  * chip cold reset. The values of the CSR fields in these registers do not change during chip
  * warm or soft resets.
  */
@@ -4279,7 +4327,7 @@ typedef union cvmx_gserx_lanex_tx_cfg_3 cvmx_gserx_lanex_tx_cfg_3_t;
 /**
  * cvmx_gser#_lane#_tx_pre_emphasis
  *
- * These registers are for diagnostic use only. These registers are only reset by hardware during
+ * These registers are for diagnostic use only. These registers are reset by hardware only during
  * chip cold reset. The values of the CSR fields in these registers do not change during chip
  * warm or soft resets.
  */
@@ -4304,7 +4352,7 @@ typedef union cvmx_gserx_lanex_tx_pre_emphasis cvmx_gserx_lanex_tx_pre_emphasis_
 /**
  * cvmx_gser#_lane_lpbken
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lane_lpbken {
@@ -4330,7 +4378,7 @@ typedef union cvmx_gserx_lane_lpbken cvmx_gserx_lane_lpbken_t;
 /**
  * cvmx_gser#_lane_mode
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lane_mode {
@@ -4389,7 +4437,7 @@ typedef union cvmx_gserx_lane_mode cvmx_gserx_lane_mode_t;
  * These are the RAW PCS lane settings mode 0 registers. There is one register per
  * 4 lanes per GSER per GSER_LMODE_E value (0..11). Only one entry is used at any given time in a
  * given GSER lane - the one selected by the corresponding GSER()_LANE_MODE[LMODE].
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lane_px_mode_0 {
@@ -4510,7 +4558,7 @@ typedef union cvmx_gserx_lane_px_mode_0 cvmx_gserx_lane_px_mode_0_t;
  * (0..3) per GSER per GSER_LMODE_E value (0..11). Only one entry is used at any given time in a
  * given
  * GSER lane - the one selected by the corresponding GSER()_LANE_MODE[LMODE].
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lane_px_mode_1 {
@@ -4567,7 +4615,7 @@ typedef union cvmx_gserx_lane_px_mode_1 cvmx_gserx_lane_px_mode_1_t;
 /**
  * cvmx_gser#_lane_poff
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lane_poff {
@@ -4593,7 +4641,7 @@ typedef union cvmx_gserx_lane_poff cvmx_gserx_lane_poff_t;
 /**
  * cvmx_gser#_lane_srst
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lane_srst {
@@ -4619,7 +4667,7 @@ typedef union cvmx_gserx_lane_srst cvmx_gserx_lane_srst_t;
  * cvmx_gser#_lane_vma_coarse_ctrl_0
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lane_vma_coarse_ctrl_0 {
@@ -4650,7 +4698,7 @@ typedef union cvmx_gserx_lane_vma_coarse_ctrl_0 cvmx_gserx_lane_vma_coarse_ctrl_
  * cvmx_gser#_lane_vma_coarse_ctrl_1
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lane_vma_coarse_ctrl_1 {
@@ -4676,7 +4724,7 @@ typedef union cvmx_gserx_lane_vma_coarse_ctrl_1 cvmx_gserx_lane_vma_coarse_ctrl_
  * cvmx_gser#_lane_vma_coarse_ctrl_2
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lane_vma_coarse_ctrl_2 {
@@ -4702,7 +4750,7 @@ typedef union cvmx_gserx_lane_vma_coarse_ctrl_2 cvmx_gserx_lane_vma_coarse_ctrl_
  * cvmx_gser#_lane_vma_fine_ctrl_0
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lane_vma_fine_ctrl_0 {
@@ -4742,7 +4790,7 @@ typedef union cvmx_gserx_lane_vma_fine_ctrl_0 cvmx_gserx_lane_vma_fine_ctrl_0_t;
  * cvmx_gser#_lane_vma_fine_ctrl_1
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lane_vma_fine_ctrl_1 {
@@ -4771,7 +4819,7 @@ typedef union cvmx_gserx_lane_vma_fine_ctrl_1 cvmx_gserx_lane_vma_fine_ctrl_1_t;
  * cvmx_gser#_lane_vma_fine_ctrl_2
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_lane_vma_fine_ctrl_2 {
@@ -5916,7 +5964,7 @@ typedef union cvmx_gserx_phyx_ovrd_in_lo cvmx_gserx_phyx_ovrd_in_lo_t;
  * cvmx_gser#_phy_ctl
  *
  * This register contains general PHY/PLL control of the RAW PCS.
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_phy_ctl {
@@ -5966,7 +6014,7 @@ typedef union cvmx_gserx_pipe_lpbk cvmx_gserx_pipe_lpbk_t;
  * These are the RAW PCS PLL global settings mode 0 registers. There is one register per GSER per
  * GSER_LMODE_E value (0..11). Only one entry is used at any given time in a given GSER - the one
  * selected by the corresponding GSER()_LANE_MODE[LMODE].
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during subsequent chip warm or
  * soft resets.
  */
@@ -6024,7 +6072,7 @@ typedef union cvmx_gserx_pll_px_mode_0 cvmx_gserx_pll_px_mode_0_t;
  * These are the RAW PCS PLL global settings mode 1 registers. There is one register per GSER per
  * GSER_LMODE_E value (0..11). Only one entry is used at any given time in a given GSER - the one
  * selected by the corresponding GSER()_LANE_MODE[LMODE].
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in this register do not change during subsequent chip warm or
  * soft resets.
  */
@@ -6134,7 +6182,7 @@ typedef union cvmx_gserx_qlm_stat cvmx_gserx_qlm_stat_t;
  * cvmx_gser#_rdet_time
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_rdet_time {
@@ -6162,7 +6210,7 @@ typedef union cvmx_gserx_rdet_time cvmx_gserx_rdet_time_t;
  * cvmx_gser#_refclk_sel
  *
  * This register selects the reference clock.
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_refclk_sel {
@@ -6193,7 +6241,7 @@ typedef union cvmx_gserx_refclk_sel cvmx_gserx_refclk_sel_t;
 /**
  * cvmx_gser#_rx_coast
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_rx_coast {
@@ -6223,7 +6271,7 @@ typedef union cvmx_gserx_rx_coast cvmx_gserx_rx_coast_t;
 /**
  * cvmx_gser#_rx_eie_deten
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_rx_eie_deten {
@@ -6333,7 +6381,7 @@ typedef union cvmx_gserx_rx_eie_filter cvmx_gserx_rx_eie_filter_t;
 /**
  * cvmx_gser#_rx_polarity
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_rx_polarity {
@@ -6361,7 +6409,7 @@ typedef union cvmx_gserx_rx_polarity cvmx_gserx_rx_polarity_t;
  * cvmx_gser#_rx_pwr_ctrl_p1
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_rx_pwr_ctrl_p1 {
@@ -6736,7 +6784,7 @@ typedef union cvmx_gserx_sata_tx_invert cvmx_gserx_sata_tx_invert_t;
 /**
  * cvmx_gser#_scratch
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_scratch {
@@ -6758,7 +6806,7 @@ typedef union cvmx_gserx_scratch cvmx_gserx_scratch_t;
  * cvmx_gser#_slice#_rx_sdll_ctrl
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_slicex_rx_sdll_ctrl {
@@ -6794,7 +6842,7 @@ typedef union cvmx_gserx_slicex_rx_sdll_ctrl cvmx_gserx_slicex_rx_sdll_ctrl_t;
  * cvmx_gser#_slice_cfg
  *
  * These registers are for diagnostic use only.
- * These registers are only reset by hardware during chip cold reset.
+ * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_slice_cfg {
@@ -6805,11 +6853,15 @@ union cvmx_gserx_slice_cfg {
 	uint64_t tx_rx_detect_lvl_enc         : 4;  /**< Determines the RX Detect level, pcs_sds_tx_rx_detect_lvl[9:0],
                                                          (which is a 1-hot signal), where the level is equal to to
                                                          2^TX_RX_DETECT_LVL_ENC. */
-	uint64_t reserved_2_7                 : 6;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t pcs_sds_rx_pcie_pterm        : 2;  /**< Reserved. */
+	uint64_t pcs_sds_rx_pcie_nterm        : 2;  /**< Reserved. */
 	uint64_t pcs_sds_tx_stress_eye        : 2;  /**< Controls TX stress eye. */
 #else
 	uint64_t pcs_sds_tx_stress_eye        : 2;
-	uint64_t reserved_2_7                 : 6;
+	uint64_t pcs_sds_rx_pcie_nterm        : 2;
+	uint64_t pcs_sds_rx_pcie_pterm        : 2;
+	uint64_t reserved_6_7                 : 2;
 	uint64_t tx_rx_detect_lvl_enc         : 4;
 	uint64_t reserved_12_63               : 52;
 #endif
@@ -6821,7 +6873,7 @@ typedef union cvmx_gserx_slice_cfg cvmx_gserx_slice_cfg_t;
 /**
  * cvmx_gser#_spd
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_spd {
@@ -6878,7 +6930,7 @@ typedef union cvmx_gserx_spd cvmx_gserx_spd_t;
 /**
  * cvmx_gser#_srst
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_srst {
@@ -6900,7 +6952,7 @@ typedef union cvmx_gserx_srst cvmx_gserx_srst_t;
 /**
  * cvmx_gser#_tx_vboost
  *
- * These registers are only reset by hardware during chip cold reset. The values of the CSR
+ * These registers are reset by hardware only during chip cold reset. The values of the CSR
  * fields in these registers do not change during chip warm or soft resets.
  */
 union cvmx_gserx_tx_vboost {
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-board.h b/arch/mips/include/asm/octeon/cvmx-helper-board.h
index c32bbdf..b57ff08 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-board.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-board.h
@@ -43,7 +43,7 @@
  * Helper functions to abstract board specific data about
  * network ports from the rest of the cvmx-helper files.
  *
- * <hr>$Revision: 100490 $<hr>
+ * <hr>$Revision: 103898 $<hr>
  */
 #ifndef __CVMX_HELPER_BOARD_H__
 #define __CVMX_HELPER_BOARD_H__
@@ -88,8 +88,6 @@ typedef enum {
 	set_phy_link_flags_flow_control_mask = 0x3 << 1,	/* Mask for 2 bit wide flow control field */
 } cvmx_helper_board_set_phy_link_flags_types_t;
 
-#if !defined(CVMX_BUILD_FOR_LINUX_KERNEL)
-
 /**
  * The EBB6600 board uses a MDIO mux device to select between the two QLM
  * modules since both QLM modules share the same PHY addresses.  The
@@ -101,7 +99,7 @@ typedef enum {
  * this board a very complex operation involving writing to the TWSI mux,
  * followed by the MDIO mux device.
  */
-
+#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 /** Maximum number of GPIO devices used to control the MDIO mux */
 #define CVMX_PHY_MUX_MAX_GPIO	2
 /** Type of MDIO mux device, currently OTHER isn't supported */
@@ -117,6 +115,9 @@ typedef enum {
 } cvmx_phy_gpio_type_t;
 
 struct cvmx_phy_device;
+struct cvmx_phy_info;
+#endif
+
 /**
  * @INTERNAL
  * This data structure is used to hold PHY information and is subject to change.
@@ -127,7 +128,9 @@ struct cvmx_phy_device;
  */
 typedef struct cvmx_phy_info {
 	int phy_addr;			/** MDIO address of PHY */
-
+	int phy_sub_addr;		/** Sub-address (i.e. slice), used by Cortina */
+	int ipd_port;			/** IPD port number for the PHY */
+#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 	/** MDIO bus PHY connected to (even if behind mux) */
 	int mdio_unit;
 	int direct_connect;		/** 1 if PHY is directly connected */
@@ -148,8 +151,10 @@ typedef struct cvmx_phy_info {
 	int mux_twsi_addr;		/** Address of the MDIO mux */
 	cvmx_phy_host_mode_t host_mode;	/** Used by Cortina PHY */
 	struct cvmx_phy_device *phydev;	/** Pointer to parent phy device */
+#endif
+	/** Pointer to function to return link information */
+	cvmx_helper_link_info_t (*link_function)(struct cvmx_phy_info *phy_info);
 } cvmx_phy_info_t;
-#endif /* !CVMX_BUILD_FOR_LINUX_KERNEL */
 
 /* Fake IPD port, the RGMII/MII interface may use different PHY, use this
    macro to return appropriate MIX address to read the PHY. */
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
index 0b636c9..6f4afce 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-cfg.h
@@ -411,19 +411,6 @@ extern void cvmx_helper_cfg_store_short_packets_in_wqe(void);
  int cvmx_pko_alloc_iport_and_queues(int interface, int port, int port_cnt,
 				     int queue_cnt);
 
-#if 0
-/*
- * Allocated a block of queues for the specified port.
- *
- * @param  port   the internal port for which the queues are requested
- * @param  count  the number of queues requested
- *
- * @return  0 on success
- *         -1 on failure
- */
-int cvmx_pko_queue_alloc(uint64_t port, uint64_t count);
-#endif
-
 /*
  * Free the queues that are associated with the specified port
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-hna-defs.h b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
index dea65b4..c6bdd88 100644
--- a/arch/mips/include/asm/octeon/cvmx-hna-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-hna-defs.h
@@ -498,9 +498,9 @@ union cvmx_hna_config {
                                                          correction logic. When clear (default) ECC correction is always enabled. */
 	uint64_t clmskcrip                    : 4;  /**< Cluster cripple mask. A one in each bit of the mask represents which HPC cluster to
                                                          cripple. CN78XX HNA has 4 clusters, where all CLMSKCRIP mask bits are used.
-                                                         Software NOTE: The MIO_FUS___HNA_CLMASK_CRIPPLE[3:0] fuse bits are forced into this
-                                                         register at reset. Any fuse bits that contain 1 are disallowed during a write and are
-                                                         always read as 1. */
+                                                         Software NOTE: The MIO_FUS___HNA_CLMASK_CRIPPLE[3:0] fuse bits are forced into
+                                                         this register at reset. Any fuse bits that contain 1 are disallowed during a
+                                                         write operation and are always read as 1. */
 	uint64_t hpu_clcrip                   : 3;  /**< HPU cluster cripple. Encoding which represents number of HPUs to cripple for each
                                                          cluster. Typically HPU_CLCRIP=0x0, which enables all HPUs within each cluster. However,
                                                          when the HNA performance counters are used, software may want to limit the number of HPUs
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
index 3b74904..05102f8 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c-defs.h
@@ -2544,7 +2544,9 @@ union cvmx_l2c_cbcx_iodisocierr {
 	uint64_t u64;
 	struct cvmx_l2c_cbcx_iodisocierr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_59_63               : 5;
+	uint64_t iorddisoci                   : 1;  /**< Reserved. */
+	uint64_t iowrdisoci                   : 1;  /**< Reserved. */
+	uint64_t reserved_59_61               : 3;
 	uint64_t cmd                          : 7;  /**< Encoding of XMC command.  INTERNAL: Enumerated with XMC_CMD_E. */
 	uint64_t ppvid                        : 6;  /**< CMB source PPVID. */
 	uint64_t node                         : 2;  /**< Destination node ID. */
@@ -2556,7 +2558,9 @@ union cvmx_l2c_cbcx_iodisocierr {
 	uint64_t node                         : 2;
 	uint64_t ppvid                        : 6;
 	uint64_t cmd                          : 7;
-	uint64_t reserved_59_63               : 5;
+	uint64_t reserved_59_61               : 3;
+	uint64_t iowrdisoci                   : 1;
+	uint64_t iorddisoci                   : 1;
 #endif
 	} s;
 	struct cvmx_l2c_cbcx_iodisocierr_s    cn78xx;
diff --git a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
index 49aa37b..67f640c 100644
--- a/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lapx-defs.h
@@ -896,12 +896,17 @@ union cvmx_lapx_xid_pos {
 	uint64_t rtn_wd                       : 4;  /**< Extract transaction tag from this 64-bit word number of the return packet; typically the
                                                          same value as [REQ_WD]. Word 0 is the Interlaken control word, word 1 is the first word of
                                                          payload. */
-	uint64_t rtn_lsb                      : 6;  /**< Extract transaction tag value's LSB into this LSB of the of request packet; typically the
-                                                         same value as [REQ_LSB]. */
+	uint64_t rtn_lsb                      : 6;  /**< Extract transaction tag value's LSB from this position of the of request packet;
+                                                         typically the same value as [REQ_LSB]. When [AS_ONLY] = 0, refers to a bit
+                                                         position in the input word. When [AS_ONLY] = 1, refers to a bit position within
+                                                         the Interlaken-LA application specific AS fields. */
 	uint64_t reserved_10_15               : 6;
 	uint64_t req_wd                       : 4;  /**< Insert transaction tag into this 64-bit word number of the request packet. Word 0 is the
                                                          Interlaken control word, word 1 is the first word of payload. */
-	uint64_t req_lsb                      : 6;  /**< Insert transaction tag value's LSB into this LSB of the of request packet. */
+	uint64_t req_lsb                      : 6;  /**< Insert transaction tag value's LSB into this LSB of the of request packet. When
+                                                         [AS_ONLY] = 0, refers to a bit position in the output word. When [AS_ONLY] = 1,
+                                                         refers to a bit position within the Interlaken-LA application specific AS
+                                                         fields. */
 #else
 	uint64_t req_lsb                      : 6;
 	uint64_t req_wd                       : 4;
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index 6e43dce..6396113 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -2324,58 +2324,90 @@ union cvmx_lmcx_comp_ctl2 {
 	uint64_t ptune                        : 5;  /**< PCTL impedance control in bypass mode. */
 	uint64_t ntune                        : 5;  /**< NCTL impedance control in bypass mode. */
 	uint64_t rodt_ctl                     : 4;  /**< RODT NCTL impedance control bits. This field controls ODT values during a memory read.
-                                                         0x0 = No ODT. 0x3 = 40 ohm.
-                                                         0x1 = 20 ohm. 0x4 = 60 ohm.
-                                                         0x2 = 30 ohm. 0x5 = 120 ohm.
-                                                         0x6-0xF = Reserved
+                                                           0x0 = No ODT.
+                                                           0x1 = 20 ohm.
+                                                           0x2 = 30 ohm.
+                                                           0x3 = 40 ohm.
+                                                           0x4 = 60 ohm.
+                                                           0x5 = 120 ohm.
+                                                           _ else = Reserved.
                                                          In DDR4 mode:
-                                                         0x0 = No ODT. 0x4 = 120 ohm.
-                                                         0x1 = 40 ohm. 0x5 = 240 ohm.
-                                                         0x2 = 60 ohm. 0x6 = 34 ohm.
-                                                         0x3 = 80 ohm. 0x7 = 48 ohm.
-                                                         0x8-0xF = Reserved */
+                                                           0x0 = No ODT.
+                                                           0x1 = 40 ohm.
+                                                           0x2 = 60 ohm.
+                                                           0x3 = 80 ohm.
+                                                           0x4 = 120 ohm.
+                                                           0x5 = 240 ohm.
+                                                           0x6 = 34 ohm.
+                                                           0x7 = 48 ohm.
+                                                           _ else = Reserved. */
 	uint64_t control_ctl                  : 4;  /**< Drive strength control for ODT, etc. drivers.
                                                          In DDR3 mode:
-                                                         0x1 = 24 ohm. 0x5 = 40 ohm.
-                                                         0x2 = 26.67 ohm. 0x6 = 48 ohm.
-                                                         0x3 = 30 ohm. 0x7 = 60 ohm.
-                                                         0x4 = 34.3 ohm. 0x0, 0x8-0xF = Reserved.
+                                                           0x1 = 24 ohm.
+                                                           0x2 = 26.67 ohm.
+                                                           0x3 = 30 ohm.
+                                                           0x4 = 34.3 ohm.
+                                                           0x5 = 40 ohm.
+                                                           0x6 = 48 ohm.
+                                                           0x7 = 60 ohm.
+                                                           _ else = Reserved.
                                                          In DDR4 mode:
-                                                         0x0 = Reserved. 0x4 = 34 ohm.
-                                                         0x1 = Reserved. 0x5 = 40 ohm.
-                                                         0x2 = 26 ohm. 0x6 = 48 ohm.
-                                                         0x3 = 30 ohm. 0x7 = 68 ohm.
-                                                         0x8-0xF = Reserved. */
+                                                           0x0 = Reserved.
+                                                           0x1 = Reserved.
+                                                           0x2 = 26 ohm.
+                                                         0x3 = 30 ohm.
+                                                           0x4 = 34 ohm.
+                                                           0x5 = 40 ohm.
+                                                           0x6 = 48 ohm.
+                                                           _ else = Reserved. */
 	uint64_t cmd_ctl                      : 4;  /**< Drive strength control for CMD/A/RESET_L drivers.
                                                          In DDR3 mode:
-                                                         0x1 = 24 ohm. 0x5 = 40 ohm.
-                                                         0x2 = 26.67 ohm. 0x6 = 48 ohm.
-                                                         0x3 = 30 ohm. 0x7 = 60 ohm.
-                                                         0x4 = 34.3 ohm. 0x0,0x8-0xF = Reserved.
+                                                           0x1 = 24 ohm.
+                                                           0x2 = 26.67 ohm.
+                                                           0x3 = 30 ohm.
+                                                           0x4 = 34.3 ohm.
+                                                           0x5 = 40 ohm.
+                                                           0x6 = 48 ohm.
+                                                           0x7 = 60 ohm.
+                                                           _ else = Reserved.
                                                          In DDR4 mode:
-                                                         0x0 = Reserved. 0x4 = 34 ohm.
-                                                         0x1 = Reserved. 0x5 = 40 ohm.
-                                                         0x2 = 26 ohm. 0x6 = 48 ohm.
-                                                         0x3 = 30 ohm. 0x7 = 68 ohm.
-                                                         0x8-0xF = Reserved. */
+                                                           0x0 = Reserved.
+                                                           0x1 = Reserved.
+                                                           0x2 = 26 ohm.
+                                                         0x3 = 30 ohm.
+                                                           0x4 = 34 ohm.
+                                                           0x5 = 40 ohm.
+                                                           0x6 = 48 ohm.
+                                                           _ else = Reserved. */
 	uint64_t ck_ctl                       : 4;  /**< "Drive strength control for DDR_CK_*_P/DDRCS*_L/DDR_ODT_* /DDR_CKE*
                                                          drivers.
                                                          In DDR3 mode:
-                                                         0x1 = 24 ohm. 0x5 = 40 ohm.
-                                                         0x2 = 26.67 ohm. 0x6 = 48 ohm.
-                                                         0x3 = 30 ohm. 0x7 = 60 ohm.
-                                                         0x4 = 34.3 ohm. 0x0,0x8-0xF = Reserved.
+                                                           0x1 = 24 ohm.
+                                                           0x2 = 26.67 ohm.
+                                                           0x3 = 30 ohm.
+                                                           0x4 = 34.3 ohm.
+                                                           0x5 = 40 ohm.
+                                                           0x6 = 48 ohm.
+                                                           0x7 = 60 ohm.
+                                                           _ else = Reserved.
                                                          In DDR4 mode:
-                                                         0x0 = Reserved. 0x4 = 34 ohm.
-                                                         0x1 = Reserved. 0x5 = 40 ohm.
-                                                         0x2 = 26 ohm. 0x6 = 48 ohm.
-                                                         0x3 = 30 ohm. 0x7 = 68 ohm.
-                                                         0x8-0xF = Reserved." */
+                                                           0x0 = Reserved.
+                                                           0x1 = Reserved.
+                                                           0x2 = 26 ohm.
+                                                         0x3 = 30 ohm.
+                                                           0x4 = 34 ohm.
+                                                           0x5 = 40 ohm.
+                                                           0x6 = 48 ohm.
+                                                           _ else = Reserved." */
 	uint64_t dqx_ctl                      : 4;  /**< Drive strength control for DDR_DQ* /DDR_DQS_*_P/N drivers.
-                                                         0x1 = 24 ohm. 0x5 = 40 ohm.
-                                                         0x2 = 26.67 ohm. 0x6 = 48 ohm.
-                                                         0x3 = 30 ohm. 0x7 = 60 ohm.
-                                                         0x4 = 34.3 ohm. 0x0,0x8-0xF = Reserved. */
+                                                         0x1 = 24 ohm.
+                                                         0x2 = 26.67 ohm.
+                                                         0x3 = 30 ohm.
+                                                         0x4 = 34.3 ohm.
+                                                         0x5 = 40 ohm.
+                                                         0x6 = 48 ohm.
+                                                         0x7 = 60 ohm.
+                                                         _ else = Reserved. */
 #else
 	uint64_t dqx_ctl                      : 4;
 	uint64_t ck_ctl                       : 4;
@@ -8450,8 +8482,9 @@ union cvmx_lmcx_phy_ctl {
 	uint64_t ddr_error_n_ena              : 1;  /**< Enable error_alert_n signal for PHY. */
 	uint64_t ref_pin_on                   : 1;  /**< Reserved. INTERNAL: Voltage reference pin enabled. */
 	uint64_t dac_on                       : 1;  /**< Reserved. INTERNAL: PHY DAC on. */
-	uint64_t int_pad_loopback_ena         : 1;  /**< DDR pad loopback enable. */
-	uint64_t int_phy_loopback_ena         : 1;  /**< Internal PHY loopback enable. */
+	uint64_t int_pad_loopback_ena         : 1;  /**< Reserved. INTERNAL: DDR pad loopback enable.  Also must set LMCX_PHY_CTL[PHY_DSK_BYP]
+                                                         when loopback is enabled. */
+	uint64_t int_phy_loopback_ena         : 1;  /**< Reserved. INTERNAL: PHY loopback enable. */
 	uint64_t phy_dsk_reset                : 1;  /**< PHY deskew reset. When set, the deskew reset signal goes active if the Vrefint/deskew
                                                          training sequence is in the idle state. */
 	uint64_t phy_dsk_byp                  : 1;  /**< PHY deskew bypass. */
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index 8cd2ece..6b6dc06 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -3693,9 +3693,11 @@ union cvmx_mio_emm_dma_fifo_adr {
 	struct cvmx_mio_emm_dma_fifo_adr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_42_63               : 22;
-	uint64_t adr                          : 42; /**< DMA engine address. Must be 64-bit aligned. */
+	uint64_t adr                          : 39; /**< DMA engine address. Must be 64-bit aligned. */
+	uint64_t reserved_0_2                 : 3;
 #else
-	uint64_t adr                          : 42;
+	uint64_t reserved_0_2                 : 3;
+	uint64_t adr                          : 39;
 	uint64_t reserved_42_63               : 22;
 #endif
 	} s;
@@ -4941,15 +4943,13 @@ union cvmx_mio_fus_dat3 {
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control */
 	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - DFA information (DTE) */
 	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - DFA information (Cluster mask) */
-	uint64_t reserved_40_40               : 1;
-	uint64_t ema                          : 2;  /**< Fuse information - EMA */
+	uint64_t pll_alt_matrix               : 1;  /**< Select alternate PLL matrix. Added in pass 2. */
+	uint64_t reserved_38_39               : 2;
 	uint64_t efus_lck_rsv                 : 1;  /**< Fuse information - efuse lockdown */
 	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown */
 	uint64_t pll_half_dis                 : 1;  /**< Fuse information - RCLK PLL control */
 	uint64_t l2c_crip                     : 3;  /**< Fuse information - L2C Cripple (1/8, 1/4, 1/2) */
-	uint64_t pll_div4                     : 1;  /**< Fuse information - PLL DIV4 mode
-                                                         (laser fuse only) */
-	uint64_t reserved_28_30               : 3;
+	uint64_t reserved_28_31               : 4;
 	uint64_t efus_lck                     : 1;  /**< Fuse information - efuse lockdown */
 	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore */
 	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable */
@@ -4961,14 +4961,13 @@ union cvmx_mio_fus_dat3 {
 	uint64_t nozip                        : 1;
 	uint64_t efus_ign                     : 1;
 	uint64_t efus_lck                     : 1;
-	uint64_t reserved_28_30               : 3;
-	uint64_t pll_div4                     : 1;
+	uint64_t reserved_28_31               : 4;
 	uint64_t l2c_crip                     : 3;
 	uint64_t pll_half_dis                 : 1;
 	uint64_t efus_lck_man                 : 1;
 	uint64_t efus_lck_rsv                 : 1;
-	uint64_t ema                          : 2;
-	uint64_t reserved_40_40               : 1;
+	uint64_t reserved_38_39               : 2;
+	uint64_t pll_alt_matrix               : 1;
 	uint64_t dfa_info_clm                 : 4;
 	uint64_t dfa_info_dte                 : 3;
 	uint64_t pll_ctl                      : 10;
@@ -5147,6 +5146,61 @@ union cvmx_mio_fus_dat3 {
 	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
 	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - HFA information (HTE). */
 	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - HFA information (cluster mask). */
+	uint64_t pll_alt_matrix               : 1;  /**< Select alternate PLL matrix. Added in pass 2. */
+	uint64_t pll_bwadj_denom              : 2;  /**< Select CLKF denominator for BWADJ value. Added in pass 2.
+                                                         0x0 = Selects CLKF/4.
+                                                         0x1 = Selects CLKF/2.
+                                                         0x2 = Selects CLKF/8. */
+	uint64_t efus_lck_rsv                 : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t pll_half_dis                 : 1;  /**< Fuse information - Coprocessor-clock PLL control. */
+	uint64_t l2c_crip                     : 3;  /**< Fuse information - L2C cripple:
+                                                         0x0 = Full cache (4-way 512 KB).
+                                                         0x1 = 3/4 ways (3-way 384 KB).
+                                                         0x2 = 1/2 ways (2-way 256 KB).
+                                                         0x3 = 1/4 ways (1-way 128 KB).
+                                                         0x4-0x7 = Reserved. */
+	uint64_t use_int_refclk               : 1;  /**< If set use the PLL output as the low-jitter reference clock to the rclk DLLs. Default is
+                                                         to use the external input reference clock.
+                                                         Added in pass 2. */
+	uint64_t zip_info                     : 2;  /**< Fuse information - Zip information. */
+	uint64_t bar2_sz_conf                 : 1;  /**< Fuse information - When 0, BAR2 size conforms to PCIE specification. */
+	uint64_t efus_lck                     : 1;  /**< Fuse information - efuse lockdown. */
+	uint64_t efus_ign                     : 1;  /**< Fuse information - efuse ignore. */
+	uint64_t nozip                        : 1;  /**< Fuse information - ZIP disable. */
+	uint64_t nodfa_dte                    : 1;  /**< Fuse information - HFA disable (HTE). */
+	uint64_t ema1                         : 6;  /**< Fuse information - EMA1. INTERNAL: dflt value is 0x11. Soft or hard blow
+                                                         of these fuses will XOR with this value. */
+	uint64_t reserved_0_17                : 18;
+#else
+	uint64_t reserved_0_17                : 18;
+	uint64_t ema1                         : 6;
+	uint64_t nodfa_dte                    : 1;
+	uint64_t nozip                        : 1;
+	uint64_t efus_ign                     : 1;
+	uint64_t efus_lck                     : 1;
+	uint64_t bar2_sz_conf                 : 1;
+	uint64_t zip_info                     : 2;
+	uint64_t use_int_refclk               : 1;
+	uint64_t l2c_crip                     : 3;
+	uint64_t pll_half_dis                 : 1;
+	uint64_t efus_lck_man                 : 1;
+	uint64_t efus_lck_rsv                 : 1;
+	uint64_t pll_bwadj_denom              : 2;
+	uint64_t pll_alt_matrix               : 1;
+	uint64_t dfa_info_clm                 : 4;
+	uint64_t dfa_info_dte                 : 3;
+	uint64_t pll_ctl                      : 10;
+	uint64_t ema0                         : 6;
+#endif
+	} cn70xx;
+	struct cvmx_mio_fus_dat3_cn70xxp1 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x02. Soft or hard blow of these fuses
+                                                         will XOR with this value. */
+	uint64_t pll_ctl                      : 10; /**< Fuse information - PLL control. */
+	uint64_t dfa_info_dte                 : 3;  /**< Fuse information - HFA information (HTE). */
+	uint64_t dfa_info_clm                 : 4;  /**< Fuse information - HFA information (cluster mask). */
 	uint64_t reserved_38_40               : 3;
 	uint64_t efus_lck_rsv                 : 1;  /**< Fuse information - efuse lockdown. */
 	uint64_t efus_lck_man                 : 1;  /**< Fuse information - efuse lockdown. */
@@ -5187,8 +5241,7 @@ union cvmx_mio_fus_dat3 {
 	uint64_t pll_ctl                      : 10;
 	uint64_t ema0                         : 6;
 #endif
-	} cn70xx;
-	struct cvmx_mio_fus_dat3_cn70xx       cn70xxp1;
+	} cn70xxp1;
 	struct cvmx_mio_fus_dat3_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ema0                         : 6;  /**< Fuse information - EMA0. INTERNAL: dflt value is 0x02. Soft or hard blow of these fuses
diff --git a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
index a3ec46f..4f270cd 100644
--- a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
@@ -698,16 +698,24 @@ union cvmx_oclax_fsmx_orx {
 	uint64_t u64;
 	struct cvmx_oclax_fsmx_orx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t or_state                     : 16; /**< Column to drive on PLA OR-plane. Widened to 16-bits in pass 2. */
+#else
+	uint64_t or_state                     : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_oclax_fsmx_orx_s          cn70xx;
+	struct cvmx_oclax_fsmx_orx_cn70xxp1 {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t or_state                     : 4;  /**< Column to drive on PLA OR-plane. */
+	uint64_t or_state                     : 4;  /**< Column to drive on PLA OR-plane. Widened to 16-bits in pass 2. */
 #else
 	uint64_t or_state                     : 4;
 	uint64_t reserved_4_63                : 60;
 #endif
-	} s;
-	struct cvmx_oclax_fsmx_orx_s          cn70xx;
-	struct cvmx_oclax_fsmx_orx_s          cn70xxp1;
-	struct cvmx_oclax_fsmx_orx_s          cn78xx;
+	} cn70xxp1;
+	struct cvmx_oclax_fsmx_orx_cn70xxp1   cn78xx;
 };
 typedef union cvmx_oclax_fsmx_orx cvmx_oclax_fsmx_orx_t;
 
@@ -873,8 +881,12 @@ union cvmx_oclax_matx_maskx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
 	uint64_t mask                         : 36; /**< Bitmask of which bits in OCLA()_MAT()_VALUE() are to be compared.
-                                                         0 = Do not compare bit.
-                                                         1 = Compare bit. */
+                                                         Each bit of OCLA()_MAT()_VALUE() and OCLA()_MAT()_MASK() are combined as
+                                                         follows:
+                                                         _ If MASK = 1 and VALUE = 0, matches when data = "0".
+                                                         _ If MASK = 1 and VALUE = 1, matches when data = "1".
+                                                         _ If MASK = 0 and VALUE = 0, matches any data.
+                                                         _ If MASK = 0 and VALUE = 1, reserved in pass 1, matches any data pass 2 and later. */
 #else
 	uint64_t mask                         : 36;
 	uint64_t reserved_36_63               : 28;
diff --git a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
index 946bb8b..68948f3 100644
--- a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
@@ -1986,13 +1986,14 @@ union cvmx_ocx_qlmx_cfg {
 	uint64_t ser_limit                    : 10; /**< Reduce latency by limiting the amount of data in flight for each SerDes. For diagnostic
                                                          use only.  Removed in pass 2. */
 	uint64_t crd_dis                      : 1;  /**< For diagnostic use only. */
-	uint64_t reserved_26_30               : 5;
+	uint64_t reserved_27_30               : 4;
+	uint64_t trn_rxeq_only                : 1;  /**< Reserved. */
 	uint64_t timer_dis                    : 1;  /**< Disable bad lane timer. A timer counts core clocks (RCLKs) when any enabled lane is not
                                                          ready, i.e. not in the scrambler sync state. If this timer expires before all enabled
                                                          lanes can be made ready, then any lane which is not ready is disabled via
                                                          OCX_QLM(0..5)_CFG[SER_LANE_BAD]. This field is not affected by soft or warm reset. */
 	uint64_t trn_ena                      : 1;  /**< Link training enable. Link training is performed during auto link bring up. Initialized to
-                                                         1 during cold reset when OCI_SPD<3:0> pins indicate speed > 6.25 GBAUD. Otherwise,
+                                                         1 during cold reset when OCI_SPD<3:0> pins indicate speed >= 5 GBAUD. Otherwise,
                                                          initialized to 0 during a cold reset. This field is not affected by soft or warm reset. */
 	uint64_t ser_lane_ready               : 4;  /**< SerDes lanes that are ready for bundling into the link. */
 	uint64_t ser_lane_bad                 : 4;  /**< SerDes lanes excluded from use. */
@@ -2035,7 +2036,8 @@ union cvmx_ocx_qlmx_cfg {
 	uint64_t ser_lane_ready               : 4;
 	uint64_t trn_ena                      : 1;
 	uint64_t timer_dis                    : 1;
-	uint64_t reserved_26_30               : 5;
+	uint64_t trn_rxeq_only                : 1;
+	uint64_t reserved_27_30               : 4;
 	uint64_t crd_dis                      : 1;
 	uint64_t ser_limit                    : 10;
 	uint64_t reserved_42_59               : 18;
diff --git a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
index 73c458d..1ef13c1 100644
--- a/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pciercx-defs.h
@@ -9435,19 +9435,19 @@ union cvmx_pciercx_cfg554 {
                                                          phase. Encoding scheme as follows:
                                                          Bit [15:0] = 0x0: No preset is requested and evaluated in the EQ master phase.
                                                          Bit [i] = 1: Preset=i is requested and evaluated in the EQ master phase.
-                                                         _ 0b0000000000000000: No preset req/evaluated in EQ master phase.
-                                                         _ 0b00000xxxxxxxxxx1: Preset 0 req/evaluated in EQ master phase.
-                                                         _ 0b00000xxxxxxxxx1x: Preset 1 req/evaluated in EQ master phase.
-                                                         _ 0b00000xxxxxxxx1xx: Preset 2 req/evaluated in EQ master phase.
-                                                         _ 0b00000xxxxxxx1xxx: Preset 3 req/evaluated in EQ master phase.
-                                                         _ 0b00000xxxxxx1xxxx: Preset 4 req/evaluated in EQ master phase.
-                                                         _ 0b00000xxxxx1xxxxx: Preset 5 req/evaluated in EQ master phase.
-                                                         _ 0b00000xxxx1xxxxxx: Preset 6 req/evaluated in EQ master phase.
-                                                         _ 0b00000xxx1xxxxxxx: Preset 7 req/evaluated in EQ master phase.
-                                                         _ 0b00000xx1xxxxxxxx: Preset 8 req/evaluated in EQ master phase.
-                                                         _ 0b00000x1xxxxxxxxx: Preset 9 req/evaluated in EQ master phase.
-                                                         _ 0b000001xxxxxxxxxx: Preset 10 req/evaluated in EQ master phase.
-                                                         _ All other encodings: Reserved */
+                                                         _ 0b0000000000000000 = No preset req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxxxx1 = Preset 0 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxxx1x = Preset 1 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxxx1xx = Preset 2 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxxx1xxx = Preset 3 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxxx1xxxx = Preset 4 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxxx1xxxxx = Preset 5 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxxx1xxxxxx = Preset 6 req/evaluated in EQ master phase.
+                                                         _ 0b00000xxx1xxxxxxx = Preset 7 req/evaluated in EQ master phase.
+                                                         _ 0b00000xx1xxxxxxxx = Preset 8 req/evaluated in EQ master phase.
+                                                         _ 0b00000x1xxxxxxxxx = Preset 9 req/evaluated in EQ master phase.
+                                                         _ 0b000001xxxxxxxxxx = Preset 10 req/evaluated in EQ master phase.
+                                                         _ All other encodings = Reserved. */
 	uint32_t reserved_6_7                 : 2;
 	uint32_t p23td                        : 1;  /**< Phase2_3 2 ms timeout disable. Determine behavior in Phase2 for USP (Phase3 if DSP) when
                                                          the PHY does not respond within 2 ms to the assertion of RxEqEval:
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index 5042256..3fe2b82 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -1106,7 +1106,7 @@ typedef union cvmx_pki_active2 cvmx_pki_active2_t;
 /**
  * cvmx_pki_aura#_cfg
  *
- * This register configures aura backpressure, etc; see Backpressure.
+ * This register configures aura backpressure, etc.
  *
  */
 union cvmx_pki_aurax_cfg {
@@ -1573,8 +1573,7 @@ union cvmx_pki_clx_pcamx_termx {
                                                          _ TERM1<n>=1, TERM0<n>=1: Reserved. */
 	uint64_t style0                       : 8;  /**< Previous interim style. The style that must have been calculated by the port
                                                          PKI_CL()_PKIND()_STYLE[STYLE] or as modified by previous CAM hits's
-                                                         PKI_CL()_PCAM()_ACTION()[STYLE]. This is used to form AND style matches; see
-                                                         Styles.
+                                                         PKI_CL()_PCAM()_ACTION()[STYLE]. This is used to form AND style matches.
                                                          The field value is ternary, where each bit matches as follows:
                                                          _ STYLE1<n>=0, STYLE0<n>=0: Always match; data<n> don't care.
                                                          _ STYLE1<n>=0, STYLE0<n>=1: Match when data<n> == 0.
diff --git a/arch/mips/include/asm/octeon/cvmx-pko-defs.h b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
index ca6233f..6648c33 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko-defs.h
@@ -1090,12 +1090,12 @@ static inline uint64_t CVMX_PKO_L4_SQX_SHAPE(unsigned long offset)
 static inline uint64_t CVMX_PKO_L4_SQX_SHAPE_STATE(unsigned long offset)
 {
 	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 511)))))
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1023)))))
 		cvmx_warn("CVMX_PKO_L4_SQX_SHAPE_STATE(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x0001540000180030ull) + ((offset) & 511) * 512;
+	return CVMX_ADD_IO_SEG(0x0001540000180030ull) + ((offset) & 1023) * 512;
 }
 #else
-#define CVMX_PKO_L4_SQX_SHAPE_STATE(offset) (CVMX_ADD_IO_SEG(0x0001540000180030ull) + ((offset) & 511) * 512)
+#define CVMX_PKO_L4_SQX_SHAPE_STATE(offset) (CVMX_ADD_IO_SEG(0x0001540000180030ull) + ((offset) & 1023) * 512)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PKO_L4_SQX_SW_XOFF(unsigned long offset)
@@ -2225,6 +2225,17 @@ static inline uint64_t CVMX_PKO_PEB_TRUNC_ERR_INFO_FUNC(void)
 #define CVMX_PKO_PEB_TRUNC_ERR_INFO (CVMX_ADD_IO_SEG(0x0001540000900C30ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_PEB_TSO_CFG CVMX_PKO_PEB_TSO_CFG_FUNC()
+static inline uint64_t CVMX_PKO_PEB_TSO_CFG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_PEB_TSO_CFG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001540000900310ull);
+}
+#else
+#define CVMX_PKO_PEB_TSO_CFG (CVMX_ADD_IO_SEG(0x0001540000900310ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PKO_PQA_DEBUG CVMX_PKO_PQA_DEBUG_FUNC()
 static inline uint64_t CVMX_PKO_PQA_DEBUG_FUNC(void)
 {
@@ -2785,6 +2796,17 @@ static inline uint64_t CVMX_PKO_PTGFX_CFG(unsigned long offset)
 #else
 #define CVMX_PKO_PTGFX_CFG(offset) (CVMX_ADD_IO_SEG(0x0001540000900200ull) + ((offset) & 7) * 8)
 #endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PKO_RED_SEND_CFG CVMX_PKO_RED_SEND_CFG_FUNC()
+static inline uint64_t CVMX_PKO_RED_SEND_CFG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PKO_RED_SEND_CFG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00015400000800F8ull);
+}
+#else
+#define CVMX_PKO_RED_SEND_CFG (CVMX_ADD_IO_SEG(0x00015400000800F8ull))
+#endif
 #define CVMX_PKO_REG_BIST_RESULT (CVMX_ADD_IO_SEG(0x0001180050000080ull))
 #define CVMX_PKO_REG_CMD_BUF (CVMX_ADD_IO_SEG(0x0001180050000010ull))
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
@@ -3192,8 +3214,12 @@ union cvmx_pko_dqx_cir {
 	struct cvmx_pko_dqx_cir_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
-	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
+	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
+	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
 	uint64_t reserved_17_28               : 12;
 	uint64_t rate_divider_exponent        : 4;  /**< Rate divider exponent. This 4-bit base-2 exponent is used to divide the credit rate by
                                                          specifying the number of time-wheel turns required before the accumulator is increased.
@@ -3319,7 +3345,7 @@ union cvmx_pko_dqx_pick {
 	struct cvmx_pko_dqx_pick_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t dq                           : 10; /**< Descriptor queue. Index of originating descriptor queue. */
-	uint64_t color                        : 2;  /**< See PKO_L2_SQ()_SHAPE[COLOR]. */
+	uint64_t color                        : 2;  /**< See PKO_COLORRESULT_E. */
 	uint64_t child                        : 10; /**< Child index. When the C_CON bit of this result is set, indicating that this result is
                                                          connected in a flow that extends through the child result, this is the index of that child
                                                          result. */
@@ -3327,14 +3353,29 @@ union cvmx_pko_dqx_pick {
 	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
 	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
-	uint64_t jump                         : 1;  /**< Jump. Set when metapacket originated from a jump descriptor. */
-	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when metapacket was the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< Don't send. Set when metapacket is not to be sent. */
-	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ()_SHAPE[ADJUST]. */
-	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. */
-	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. */
-	uint64_t red_algo_override            : 2;  /**< See PKO_L2_SQ()_SHAPE[RED_ALGO]. */
-	uint64_t length                       : 16; /**< Packet length. The packet length in bytes. */
+	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Has no effect on any shaper. */
+	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
+                                                         the corresponding descriptor. */
+	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
+                                                         (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
+                                                         corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
+                                                         shapers, but not used by the L1 rate limiters. */
+	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or
+                                                         EIR_PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
+                                                         present in the corresponding descriptor. See PKO_COLORALG_E. [CIR_DIS] is used by the
+                                                         DQ through L2 shapers, but not used by the L1 rate limiters. */
+	uint64_t red_algo_override            : 2;  /**< PKO_SEND_EXT_S[RA] from the corresponding packet descriptor. Zero
+                                                         (i.e. PKO_REDALG_E::STD) if a PKO_SEND_EXT_S is not present in the
+                                                         corresponding descriptor. [RED_ALGO_OVERRIDE] is used by the DQ through L2
+                                                         shapers, but not used by the L1 rate limiters. */
+	uint64_t length                       : 16; /**< The packet length in bytes including pad.
+                                                               PKO_SEND_HDR_S[TOTAL] + CALCPAD
+                                                         where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
+                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
+                                                         CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
+                                                         DQ the packet used. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -3368,8 +3409,12 @@ union cvmx_pko_dqx_pir {
 	struct cvmx_pko_dqx_pir_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
-	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
+	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
+	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
 	uint64_t reserved_17_28               : 12;
 	uint64_t rate_divider_exponent        : 4;  /**< Rate divider exponent. This 4-bit base-2 exponent is used to divide the credit rate by
                                                          specifying the number of time-wheel turns required before the accumulator is increased.
@@ -3463,16 +3508,15 @@ union cvmx_pko_dqx_schedule {
                                                          PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this is a round-robin child queue into
                                                          the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned
-                                                         integer).
-                                                         The packet size used in all DWRR calculations is:
-                                                         _  (PKO_Ln_SQm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD)) +
-                                                            PKO_SEND_EXT_S[SHAPECHG] +
-                                                            PKO_Ln_SQm_SHAPE[ADJUST]
-                                                         where n and m correspond to this PKO_Ln_SQm_SCHEDULE CSR. CALCPAD is zero when
-                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[MINLEN],
-                                                         else CALCPAD=PKO_PDM_CFG[MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the packet used.
-                                                         PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present in the send
-                                                         descriptor. */
+                                                         integer). The packet size used in all DWRR (RR_COUNT) calculations is:
+                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD +
+                                                            PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
+                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
+                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
+                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
+                                                         else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
+                                                         packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
+                                                         in the send descriptor. */
 #else
 	uint64_t rr_quantum                   : 24;
 	uint64_t prio                         : 4;
@@ -3495,12 +3539,10 @@ union cvmx_pko_dqx_shape {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
 	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
-                                                         and shaping calculations such that only the values of
-                                                         PKO_L5_SQ()_SHAPE[ADJUST] and PKO_SEND_EXT_S[SHAPECHG] are used. */
+                                                         and shaping calculations such that only the value of [ADJUST] is used. */
 	uint64_t reserved_13_23               : 11;
-	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
-	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
-                                                         transitions when set. */
+	uint64_t yellow_disable               : 1;  /**< See PKO_L2_SQ()_SHAPE[YELLOW_DISABLE]. */
+	uint64_t red_disable                  : 1;  /**< See PKO_L2_SQ()_SHAPE[RED_DISABLE]. */
 	uint64_t red_algo                     : 2;  /**< See PKO_L2_SQ()_SHAPE[RED_ALGO]. */
 	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ()_SHAPE[ADJUST]. */
 #else
@@ -3565,11 +3607,11 @@ union cvmx_pko_dqx_sw_xoff {
                                                          until the path has drained." */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
 	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_L1_SQ()_TOPOLOGY[LINK] must be configured before using this
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
                                                          register field. Writing to this register field before the associated
-                                                         PKO_L1_SQ()_TOPOLOGY[LINK] value is configured can result in modifying the software
+                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
                                                          XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
@@ -3746,17 +3788,43 @@ typedef union cvmx_pko_enable cvmx_pko_enable_t;
 
 /**
  * cvmx_pko_format#_ctl
+ *
+ * Describes packet marking calculations for YELLOW and for RED_SEND packets.
+ * PKO_SEND_HDR_S[FORMAT] selects the CSR used for the packet descriptor.
+ *
+ * All the packet marking calculations assume big-endian bits within a byte.
+ *
+ * For example, if MARKPTR is 3 and [OFFSET] is 5 and the packet is YELLOW,
+ * the PKO marking hardware would do this:
+ *
+ * _  byte[3]<2:0> |=   Y_VAL<3:1>
+ * _  byte[3]<2:0> &= ~Y_MASK<3:1>
+ * _  byte[4]<7>   |=   Y_VAL<0>
+ * _  byte[4]<7>   &= ~Y_MASK<0>
+ *
+ * where byte[3] is the 3rd byte in the packet, and byte[4] the 4th.
+ *
+ * For another example, if MARKPTR is 3 and [OFFSET] is 0 and the packet is RED_SEND,
+ *
+ * _   byte[3]<7:4> |=   R_VAL<3:0>
+ * _   byte[3]<7:4> &= ~R_MASK<3:0>
  */
 union cvmx_pko_formatx_ctl {
 	uint64_t u64;
 	struct cvmx_pko_formatx_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_27_63               : 37;
-	uint64_t offset                       : 11; /**< Bits to add to PKO_SEND_EXT_S[MARKPTR]*8 to determine where to start marking. */
-	uint64_t y_mask                       : 4;  /**< Yellow mark mask. Corresponding bits in packet's data are cleared when marking packet yellow. */
-	uint64_t y_val                        : 4;  /**< Yellow mark value. Corresponding bits in packet's data are set when marking packet yellow. */
-	uint64_t r_mask                       : 4;  /**< Red mark mask. Corresponding bits in packet's data are cleared when marking packet red. */
-	uint64_t r_val                        : 4;  /**< Red mark value. Corresponding bits in packet's data are set when marking packet red. */
+	uint64_t offset                       : 11; /**< Packet marking starts MARKPTR*8 + [OFFSET] bits into the packet.
+                                                         All processing with [Y_MASK,Y_VAL,R_MASK,R_VAL] starts at this offset.
+                                                         MARKPTR is PKO_SEND_EXT_S[MARKPTR] when present, else PKO_SEND_HDR_S[L3PTR]. */
+	uint64_t y_mask                       : 4;  /**< Yellow mark mask. Corresponding bits in packet's data are cleared when marking a YELLOW
+                                                         packet. [Y_MASK] & [Y_VAL] must be zero. */
+	uint64_t y_val                        : 4;  /**< Yellow mark value. Corresponding bits in packet's data are set when marking a YELLOW
+                                                         packet. [Y_MASK] & [Y_VAL] must be zero. */
+	uint64_t r_mask                       : 4;  /**< Red mark mask. Corresponding bits in packet's data are cleared when marking a RED_SEND
+                                                         packet. [R_MASK] & [R_VAL] must be zero. */
+	uint64_t r_val                        : 4;  /**< Red mark value. Corresponding bits in packet's data are set when marking a RED_SEND
+                                                         packet. [R_MASK] & [R_VAL] must be zero. */
 #else
 	uint64_t r_val                        : 4;
 	uint64_t r_mask                       : 4;
@@ -3778,8 +3846,12 @@ union cvmx_pko_l1_sqx_cir {
 	struct cvmx_pko_l1_sqx_cir_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
-	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
+	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
+	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
 	uint64_t reserved_17_28               : 12;
 	uint64_t rate_divider_exponent        : 4;  /**< Rate divider exponent. This 4-bit base-2 exponent is used to divide the credit rate by
                                                          specifying the number of time-wheel turns required before the accumulator is increased.
@@ -3859,9 +3931,13 @@ union cvmx_pko_l1_sqx_green {
 	struct cvmx_pko_l1_sqx_green_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t rr_active                    : 1;  /**< Round-robin red active. Indicates that the round-robin input is mapped to RED. */
-	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to this
-                                                         scheduling queue are active. For internal use only. */
+	uint64_t rr_active                    : 1;  /**< Round-robin red active. Set when the RED_SEND+RED_DROP DWRR child list is not empty.
+                                                         For internal use only. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 20-bit vector, 2 bits per each of the 10 supported priorities.
+                                                         For the non-RR_PRIO priorities, the 2 bits encode whether the child is active
+                                                         GREEN, active YELLOW, active RED_SEND+RED_DROP, or inactive. At RR_PRIO, one
+                                                         bit is set if the GREEN DWRR child list is not empty, and the other is set if the
+                                                         YELLOW DWRR child list is not empty. For internal use only. */
 	uint64_t reserved_19_19               : 1;
 	uint64_t head                         : 9;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
 	uint64_t reserved_9_9                 : 1;
@@ -3962,7 +4038,7 @@ union cvmx_pko_l1_sqx_pick {
 	struct cvmx_pko_l1_sqx_pick_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t dq                           : 10; /**< Descriptor queue. Index of originating descriptor queue. */
-	uint64_t color                        : 2;  /**< See PKO_L2_SQ()_SHAPE[COLOR]. */
+	uint64_t color                        : 2;  /**< See PKO_COLORRESULT_E. */
 	uint64_t child                        : 10; /**< Child index. When the C_CON bit of this result is set, indicating that this result is
                                                          connected in a flow that extends through the child result, this is the index of that child
                                                          result. */
@@ -3970,14 +4046,29 @@ union cvmx_pko_l1_sqx_pick {
 	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
 	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
-	uint64_t jump                         : 1;  /**< Jump. Set when metapacket originated from a jump descriptor. */
-	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when metapacket was the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< Don't send. Set when metapacket is not to be sent. */
-	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ()_SHAPE[ADJUST]. */
-	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. */
-	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. */
-	uint64_t red_algo_override            : 2;  /**< See PKO_L2_SQ()_SHAPE[RED_ALGO]. */
-	uint64_t length                       : 16; /**< Packet length. The packet length in bytes. */
+	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Has no effect on any shaper. */
+	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
+                                                         the corresponding descriptor. */
+	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
+                                                         (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
+                                                         corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
+                                                         shapers, but not used by the L1 rate limiters. */
+	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or
+                                                         EIR_PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
+                                                         present in the corresponding descriptor. See PKO_COLORALG_E. [CIR_DIS] is used by the
+                                                         DQ through L2 shapers, but not used by the L1 rate limiters. */
+	uint64_t red_algo_override            : 2;  /**< PKO_SEND_EXT_S[RA] from the corresponding packet descriptor. Zero
+                                                         (i.e. PKO_REDALG_E::STD) if a PKO_SEND_EXT_S is not present in the
+                                                         corresponding descriptor. [RED_ALGO_OVERRIDE] is used by the DQ through L2
+                                                         shapers, but not used by the L1 rate limiters. */
+	uint64_t length                       : 16; /**< The packet length in bytes including pad.
+                                                               PKO_SEND_HDR_S[TOTAL] + CALCPAD
+                                                         where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
+                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
+                                                         CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
+                                                         DQ the packet used. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -4153,11 +4244,11 @@ union cvmx_pko_l1_sqx_sw_xoff {
                                                          until the path has drained." */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
 	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_L1_SQ()_TOPOLOGY[LINK] must be configured before using this
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
                                                          register field. Writing to this register field before the associated
-                                                         PKO_L1_SQ()_TOPOLOGY[LINK] value is configured can result in modifying the software
+                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
                                                          XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
@@ -4190,7 +4281,31 @@ union cvmx_pko_l1_sqx_topology {
                                                          recommend PRIO_ANCHOR be zero. Note that there are 10 available priorities, 0 through 9,
                                                          with priority 0 being the highest and priority 9 being the lowest. */
 	uint64_t reserved_21_31               : 11;
-	uint64_t link                         : 5;  /**< Link index. Index of the link associated with this port queue. */
+	uint64_t link                         : 5;  /**< Link index. Selects the MAC or NULL FIFO used by the L1 SQ.
+                                                         Legal [LINK] values:
+                                                         <pre>
+                                                                        Relevant
+                                                           [LINK]  PKO_MAC()_CFG CSR   Description
+                                                          -----------------------------------------------
+                                                             0       PKO_MAC0_CFG      LBK loopback
+                                                             1       PKO_MAC1_CFG      DPI packet output
+                                                             2       PKO_MAC2_CFG      ILK link 0
+                                                             3       PKO_MAC3_CFG      ILK link 1
+                                                             4       PKO_MAC4_CFG      BGX0 logical MAC 0
+                                                             5       PKO_MAC5_CFG      BGX0 logical MAC 1
+                                                             6       PKO_MAC6_CFG      BGX0 logical MAC 2
+                                                             7       PKO_MAC7_CFG      BGX0 logical MAC 3
+                                                             8       PKO_MAC8_CFG      BGX1 logical MAC 0
+                                                             9       PKO_MAC9_CFG      BGX1 logical MAC 1
+                                                            10       PKO_MAC10_CFG     BGX1 logical MAC 2
+                                                            11       PKO_MAC11_CFG     BGX1 logical MAC 3
+                                                            12       PKO_MAC12_CFG     BGX2 logical MAC 0
+                                                            - ...
+                                                            27       PKO_MAC27_CFG     BGX5 logical MAC 3
+                                                            28          None           NULL FIFO
+                                                         </pre>
+                                                         When a MAC is used by the L1 SQ, [LINK] must be unique relative to
+                                                         other [LINK]'s. [LINK] should be 28 when the L1 SQ is not used. */
 	uint64_t reserved_5_15                : 11;
 	uint64_t rr_prio                      : 4;  /**< Round-robin priority. The priority assigned to the round-robin scheduler. A higher-level
                                                          queue is a child queue of this shaper when its PKO_*_TOPOLOGY[PARENT] selects this shaper,
@@ -4345,8 +4460,12 @@ union cvmx_pko_l2_sqx_cir {
 	struct cvmx_pko_l2_sqx_cir_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
-	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
+	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
+	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
 	uint64_t reserved_17_28               : 12;
 	uint64_t rate_divider_exponent        : 4;  /**< Rate divider exponent. This 4-bit base-2 exponent is used to divide the credit rate by
                                                          specifying the number of time-wheel turns required before the accumulator is increased.
@@ -4387,9 +4506,13 @@ union cvmx_pko_l2_sqx_green {
 	struct cvmx_pko_l2_sqx_green_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t rr_active                    : 1;  /**< Round-robin red active. Indicates that the round-robin input is mapped to RED. */
-	uint64_t active_vec                   : 20; /**< Active vector. A 10-bit vector, ordered by priority, that indicate which inputs to this
-                                                         scheduling queue are active. For internal use only. */
+	uint64_t rr_active                    : 1;  /**< Round-robin red active. Set when the RED_SEND+RED_DROP DWRR child list is not empty.
+                                                         For internal use only. */
+	uint64_t active_vec                   : 20; /**< Active vector. A 20-bit vector, 2 bits per each of the 10 supported priorities.
+                                                         For the non-RR_PRIO priorities, the 2 bits encode whether the child is active
+                                                         GREEN, active YELLOW, active RED_SEND+RED_DROP, or inactive. At RR_PRIO, one
+                                                         bit is set if the GREEN DWRR child list is not empty, and the other is set if the
+                                                         YELLOW DWRR child list is not empty. For internal use only. */
 	uint64_t reserved_19_19               : 1;
 	uint64_t head                         : 9;  /**< Head pointer. The index of round-robin linked-list head. For internal use only. */
 	uint64_t reserved_9_9                 : 1;
@@ -4419,7 +4542,7 @@ union cvmx_pko_l2_sqx_pick {
 	struct cvmx_pko_l2_sqx_pick_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t dq                           : 10; /**< Descriptor queue. Index of originating descriptor queue. */
-	uint64_t color                        : 2;  /**< See PKO_L2_SQ()_SHAPE[COLOR]. */
+	uint64_t color                        : 2;  /**< See PKO_COLORRESULT_E. */
 	uint64_t child                        : 10; /**< Child index. When the C_CON bit of this result is set, indicating that this result is
                                                          connected in a flow that extends through the child result, this is the index of that child
                                                          result. */
@@ -4427,14 +4550,29 @@ union cvmx_pko_l2_sqx_pick {
 	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
 	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
-	uint64_t jump                         : 1;  /**< Jump. Set when metapacket originated from a jump descriptor. */
-	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when metapacket was the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< Don't send. Set when metapacket is not to be sent. */
-	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ()_SHAPE[ADJUST]. */
-	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. */
-	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. */
-	uint64_t red_algo_override            : 2;  /**< See PKO_L2_SQ()_SHAPE[RED_ALGO]. */
-	uint64_t length                       : 16; /**< Packet length. The packet length in bytes. */
+	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Has no effect on any shaper. */
+	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
+                                                         the corresponding descriptor. */
+	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
+                                                         (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
+                                                         corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
+                                                         shapers, but not used by the L1 rate limiters. */
+	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or
+                                                         EIR_PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
+                                                         present in the corresponding descriptor. See PKO_COLORALG_E. [CIR_DIS] is used by the
+                                                         DQ through L2 shapers, but not used by the L1 rate limiters. */
+	uint64_t red_algo_override            : 2;  /**< PKO_SEND_EXT_S[RA] from the corresponding packet descriptor. Zero
+                                                         (i.e. PKO_REDALG_E::STD) if a PKO_SEND_EXT_S is not present in the
+                                                         corresponding descriptor. [RED_ALGO_OVERRIDE] is used by the DQ through L2
+                                                         shapers, but not used by the L1 rate limiters. */
+	uint64_t length                       : 16; /**< The packet length in bytes including pad.
+                                                               PKO_SEND_HDR_S[TOTAL] + CALCPAD
+                                                         where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
+                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
+                                                         CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
+                                                         DQ the packet used. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -4468,8 +4606,12 @@ union cvmx_pko_l2_sqx_pir {
 	struct cvmx_pko_l2_sqx_pir_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
-	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
+	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
+	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
 	uint64_t reserved_17_28               : 12;
 	uint64_t rate_divider_exponent        : 4;  /**< Rate divider exponent. This 4-bit base-2 exponent is used to divide the credit rate by
                                                          specifying the number of time-wheel turns required before the accumulator is increased.
@@ -4579,16 +4721,15 @@ union cvmx_pko_l2_sqx_schedule {
                                                          PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this is a round-robin child queue into
                                                          the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned
-                                                         integer).
-                                                         The packet size used in all DWRR calculations is:
-                                                         _  (PKO_Ln_SQm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD)) +
-                                                            PKO_SEND_EXT_S[SHAPECHG] +
-                                                            PKO_Ln_SQm_SHAPE[ADJUST]
-                                                         where n and m correspond to this PKO_Ln_SQm_SCHEDULE CSR. CALCPAD is zero when
-                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[MINLEN],
-                                                         else CALCPAD=PKO_PDM_CFG[MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the packet used.
-                                                         PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present in the send
-                                                         descriptor. */
+                                                         integer). The packet size used in all DWRR (RR_COUNT) calculations is:
+                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD +
+                                                            PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
+                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
+                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
+                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
+                                                         else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
+                                                         packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
+                                                         in the send descriptor. */
 #else
 	uint64_t rr_quantum                   : 24;
 	uint64_t prio                         : 4;
@@ -4609,19 +4750,40 @@ union cvmx_pko_l2_sqx_shape {
 	uint64_t reserved_25_63               : 39;
 	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
                                                          and shaping calculations such that only the values of
-                                                         PKO_L2_SQ()_SHAPE[ADJUST] and PKO_SEND_EXT_S[SHAPECHG] are used. */
+                                                         [ADJUST] and PKO_SEND_EXT_S[SHAPECHG] are used. */
 	uint64_t reserved_13_23               : 11;
-	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
+	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when
+                                                         set. Not used by hardware when corresponding PKO_*_CIR[ENABLE] is clear. */
 	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
-                                                         transitions when set. */
-	uint64_t red_algo                     : 2;  /**< Shaper red state algorithm.
-                                                         0x0 = Stall packets while in RED state until YELLOW or GREEN state is reached (aka never
-                                                         send RED packets).
-                                                         0x1 = Send packets while in RED state.
-                                                         0x2 = Same as 0 above (stall).
-                                                         0x3 = Discard packets while in RED state (red packets are converted to drop packets). */
-	uint64_t adjust                       : 9;  /**< Shaping calculation adjustment. This 9-bit signed values allows +/- 256 bytes to be added
-                                                         to the packet length for the shaping calculations. */
+                                                         transitions when set. Not used by hardware when [RED_ALGO]/PKO_SEND_EXT_S[RA]=0x2/STALL
+                                                         nor when corresponding PKO_*_PIR[ENABLE] is clear. */
+	uint64_t red_algo                     : 2;  /**< Shaper red state algorithm when not specified by the PKO SEND. Used by hardware
+                                                         only when the shaper is in RED state. (RED state is when
+                                                         PKO_*_SHAPE_STATE[COLOR]=0x2). When PKO_SEND_EXT_S[RA]!=STD (!=0) for a
+                                                         packet, this [RED_ALGO] is not used, and PKO_SEND_EXT_S[RA] instead defines
+                                                         the shaper red state algorithm used for the packet. The
+                                                         encoding for the [RED_ALGO]/PKO_SEND_EXT_S[RA] that is used:
+                                                         0x0 = STALL. See 0x2.
+                                                         0x1 = SEND. Send packets while the shaper is in RED state. When the shaper is
+                                                               in RED state, packets that traverse the shaper will be downgraded to RED_SEND.
+                                                               (if not already RED_SEND or RED_DROP) unless [RED_DISABLE] is set or
+                                                               PKO_SEND_EXT_S[COL] for the packet is CIR_ONLY or NO_COLOR.
+                                                               See also PKO_REDALG_E::SEND.
+                                                         0x2 = STALL. Stall packets while the shaper is in RED state until the shaper is
+                                                               YELLOW or GREEN state. Packets that traverse the shaper are never
+                                                               downgraded to the RED state in this mode.
+                                                               See also PKO_REDALG_E::STALL.
+                                                         0x3 = DISCARD. Continually discard packets while the shaper is in RED state.
+                                                               When the shaper is in RED state, all packets that traverse the shaper
+                                                               will be downgraded to RED_DROP (if not already RED_DROP), unless
+                                                               [RED_DISABLE] is set or PKO_SEND_EXT_S[COL] for the packet is CIR_ONLY
+                                                               or NO_COLOR. RED_DROP packets traverse all subsequent schedulers/shapers
+                                                               (all the way through L1), but do so as quickly as possible without
+                                                               affecting any RR_COUNT, CIR_ACCUM, or PIR_ACCUM state, and are then
+                                                               discarded by PKO. See also PKO_REDALG_E::DISCARD. */
+	uint64_t adjust                       : 9;  /**< Shaping and scheduling calculation adjustment. This 9-bit signed value allows
+                                                         +/- 256 bytes to be added to the packet length for shaping and scheduling
+                                                         calculations. */
 #else
 	uint64_t adjust                       : 9;
 	uint64_t red_algo                     : 2;
@@ -4681,11 +4843,11 @@ union cvmx_pko_l2_sqx_sw_xoff {
                                                          until the path has drained." */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
 	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_L1_SQ()_TOPOLOGY[LINK] must be configured before using this
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
                                                          register field. Writing to this register field before the associated
-                                                         PKO_L1_SQ()_TOPOLOGY[LINK] value is configured can result in modifying the software
+                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
                                                          XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
@@ -4857,8 +5019,12 @@ union cvmx_pko_l3_sqx_cir {
 	struct cvmx_pko_l3_sqx_cir_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
-	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
+	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
+	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
 	uint64_t reserved_17_28               : 12;
 	uint64_t rate_divider_exponent        : 4;  /**< Rate divider exponent. This 4-bit base-2 exponent is used to divide the credit rate by
                                                          specifying the number of time-wheel turns required before the accumulator is increased.
@@ -4924,7 +5090,7 @@ union cvmx_pko_l3_sqx_pick {
 	struct cvmx_pko_l3_sqx_pick_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t dq                           : 10; /**< Descriptor queue. Index of originating descriptor queue. */
-	uint64_t color                        : 2;  /**< See PKO_L2_SQ()_SHAPE[COLOR]. */
+	uint64_t color                        : 2;  /**< See PKO_COLORRESULT_E. */
 	uint64_t child                        : 10; /**< Child index. When the C_CON bit of this result is set, indicating that this result is
                                                          connected in a flow that extends through the child result, this is the index of that child
                                                          result. */
@@ -4932,14 +5098,29 @@ union cvmx_pko_l3_sqx_pick {
 	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
 	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
-	uint64_t jump                         : 1;  /**< Jump. Set when metapacket originated from a jump descriptor. */
-	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when metapacket was the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< Don't send. Set when metapacket is not to be sent. */
-	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ()_SHAPE[ADJUST]. */
-	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. */
-	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. */
-	uint64_t red_algo_override            : 2;  /**< See PKO_L2_SQ()_SHAPE[RED_ALGO]. */
-	uint64_t length                       : 16; /**< Packet length. The packet length in bytes. */
+	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Has no effect on any shaper. */
+	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
+                                                         the corresponding descriptor. */
+	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
+                                                         (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
+                                                         corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
+                                                         shapers, but not used by the L1 rate limiters. */
+	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or
+                                                         EIR_PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
+                                                         present in the corresponding descriptor. See PKO_COLORALG_E. [CIR_DIS] is used by the
+                                                         DQ through L2 shapers, but not used by the L1 rate limiters. */
+	uint64_t red_algo_override            : 2;  /**< PKO_SEND_EXT_S[RA] from the corresponding packet descriptor. Zero
+                                                         (i.e. PKO_REDALG_E::STD) if a PKO_SEND_EXT_S is not present in the
+                                                         corresponding descriptor. [RED_ALGO_OVERRIDE] is used by the DQ through L2
+                                                         shapers, but not used by the L1 rate limiters. */
+	uint64_t length                       : 16; /**< The packet length in bytes including pad.
+                                                               PKO_SEND_HDR_S[TOTAL] + CALCPAD
+                                                         where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
+                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
+                                                         CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
+                                                         DQ the packet used. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -4973,8 +5154,12 @@ union cvmx_pko_l3_sqx_pir {
 	struct cvmx_pko_l3_sqx_pir_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
-	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
+	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
+	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
 	uint64_t reserved_17_28               : 12;
 	uint64_t rate_divider_exponent        : 4;  /**< Rate divider exponent. This 4-bit base-2 exponent is used to divide the credit rate by
                                                          specifying the number of time-wheel turns required before the accumulator is increased.
@@ -5091,16 +5276,15 @@ union cvmx_pko_l3_sqx_schedule {
                                                          PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this is a round-robin child queue into
                                                          the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned
-                                                         integer).
-                                                         The packet size used in all DWRR calculations is:
-                                                         _  (PKO_Ln_SQm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD)) +
-                                                            PKO_SEND_EXT_S[SHAPECHG] +
-                                                            PKO_Ln_SQm_SHAPE[ADJUST]
-                                                         where n and m correspond to this PKO_Ln_SQm_SCHEDULE CSR. CALCPAD is zero when
-                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[MINLEN],
-                                                         else CALCPAD=PKO_PDM_CFG[MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the packet used.
-                                                         PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present in the send
-                                                         descriptor. */
+                                                         integer). The packet size used in all DWRR (RR_COUNT) calculations is:
+                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD +
+                                                            PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
+                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
+                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
+                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
+                                                         else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
+                                                         packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
+                                                         in the send descriptor. */
 #else
 	uint64_t rr_quantum                   : 24;
 	uint64_t prio                         : 4;
@@ -5120,12 +5304,10 @@ union cvmx_pko_l3_sqx_shape {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
 	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
-                                                         and shaping calculations such that only the values of
-                                                         PKO_L3_SQ()_SHAPE[ADJUST] and PKO_SEND_EXT_S[SHAPECHG] are used. */
+                                                         and shaping calculations such that only the value of [ADJUST] is used. */
 	uint64_t reserved_13_23               : 11;
-	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
-	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
-                                                         transitions when set. */
+	uint64_t yellow_disable               : 1;  /**< See PKO_L2_SQ()_SHAPE[YELLOW_DISABLE]. */
+	uint64_t red_disable                  : 1;  /**< See PKO_L2_SQ()_SHAPE[RED_DISABLE]. */
 	uint64_t red_algo                     : 2;  /**< See PKO_L2_SQ()_SHAPE[RED_ALGO]. */
 	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ()_SHAPE[ADJUST]. */
 #else
@@ -5190,11 +5372,11 @@ union cvmx_pko_l3_sqx_sw_xoff {
                                                          until the path has drained." */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
 	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_L1_SQ()_TOPOLOGY[LINK] must be configured before using this
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
                                                          register field. Writing to this register field before the associated
-                                                         PKO_L1_SQ()_TOPOLOGY[LINK] value is configured can result in modifying the software
+                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
                                                          XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
@@ -5321,8 +5503,12 @@ union cvmx_pko_l4_sqx_cir {
 	struct cvmx_pko_l4_sqx_cir_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
-	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
+	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
+	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
 	uint64_t reserved_17_28               : 12;
 	uint64_t rate_divider_exponent        : 4;  /**< Rate divider exponent. This 4-bit base-2 exponent is used to divide the credit rate by
                                                          specifying the number of time-wheel turns required before the accumulator is increased.
@@ -5391,7 +5577,7 @@ union cvmx_pko_l4_sqx_pick {
 	struct cvmx_pko_l4_sqx_pick_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t dq                           : 10; /**< Descriptor queue. Index of originating descriptor queue. */
-	uint64_t color                        : 2;  /**< See PKO_L2_SQ()_SHAPE[COLOR]. */
+	uint64_t color                        : 2;  /**< See PKO_COLORRESULT_E. */
 	uint64_t child                        : 10; /**< Child index. When the C_CON bit of this result is set, indicating that this result is
                                                          connected in a flow that extends through the child result, this is the index of that child
                                                          result. */
@@ -5399,14 +5585,29 @@ union cvmx_pko_l4_sqx_pick {
 	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
 	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
-	uint64_t jump                         : 1;  /**< Jump. Set when metapacket originated from a jump descriptor. */
-	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when metapacket was the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< Don't send. Set when metapacket is not to be sent. */
-	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ()_SHAPE[ADJUST]. */
-	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. */
-	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. */
-	uint64_t red_algo_override            : 2;  /**< See PKO_L2_SQ()_SHAPE[RED_ALGO]. */
-	uint64_t length                       : 16; /**< Packet length. The packet length in bytes. */
+	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Has no effect on any shaper. */
+	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
+                                                         the corresponding descriptor. */
+	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
+                                                         (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
+                                                         corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
+                                                         shapers, but not used by the L1 rate limiters. */
+	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or
+                                                         EIR_PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
+                                                         present in the corresponding descriptor. See PKO_COLORALG_E. [CIR_DIS] is used by the
+                                                         DQ through L2 shapers, but not used by the L1 rate limiters. */
+	uint64_t red_algo_override            : 2;  /**< PKO_SEND_EXT_S[RA] from the corresponding packet descriptor. Zero
+                                                         (i.e. PKO_REDALG_E::STD) if a PKO_SEND_EXT_S is not present in the
+                                                         corresponding descriptor. [RED_ALGO_OVERRIDE] is used by the DQ through L2
+                                                         shapers, but not used by the L1 rate limiters. */
+	uint64_t length                       : 16; /**< The packet length in bytes including pad.
+                                                               PKO_SEND_HDR_S[TOTAL] + CALCPAD
+                                                         where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
+                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
+                                                         CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
+                                                         DQ the packet used. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -5440,8 +5641,12 @@ union cvmx_pko_l4_sqx_pir {
 	struct cvmx_pko_l4_sqx_pir_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
-	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
+	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
+	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
 	uint64_t reserved_17_28               : 12;
 	uint64_t rate_divider_exponent        : 4;  /**< Rate divider exponent. This 4-bit base-2 exponent is used to divide the credit rate by
                                                          specifying the number of time-wheel turns required before the accumulator is increased.
@@ -5555,16 +5760,15 @@ union cvmx_pko_l4_sqx_schedule {
                                                          PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this is a round-robin child queue into
                                                          the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned
-                                                         integer).
-                                                         The packet size used in all DWRR calculations is:
-                                                         _  (PKO_Ln_SQm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD)) +
-                                                            PKO_SEND_EXT_S[SHAPECHG] +
-                                                            PKO_Ln_SQm_SHAPE[ADJUST]
-                                                         where n and m correspond to this PKO_Ln_SQm_SCHEDULE CSR. CALCPAD is zero when
-                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[MINLEN],
-                                                         else CALCPAD=PKO_PDM_CFG[MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the packet used.
-                                                         PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present in the send
-                                                         descriptor. */
+                                                         integer). The packet size used in all DWRR (RR_COUNT) calculations is:
+                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD +
+                                                            PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
+                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
+                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
+                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
+                                                         else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
+                                                         packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
+                                                         in the send descriptor. */
 #else
 	uint64_t rr_quantum                   : 24;
 	uint64_t prio                         : 4;
@@ -5587,12 +5791,10 @@ union cvmx_pko_l4_sqx_shape {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
 	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
-                                                         and shaping calculations such that only the values of
-                                                         PKO_L3_SQ()_SHAPE[ADJUST] and PKO_SEND_EXT_S[SHAPECHG] are used. */
+                                                         and shaping calculations such that only the value of [ADJUST] is used. */
 	uint64_t reserved_13_23               : 11;
-	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
-	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
-                                                         transitions when set. */
+	uint64_t yellow_disable               : 1;  /**< See PKO_L2_SQ()_SHAPE[YELLOW_DISABLE]. */
+	uint64_t red_disable                  : 1;  /**< See PKO_L2_SQ()_SHAPE[RED_DISABLE]. */
 	uint64_t red_algo                     : 2;  /**< See PKO_L2_SQ()_SHAPE[RED_ALGO]. */
 	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ()_SHAPE[ADJUST]. */
 #else
@@ -5657,11 +5859,11 @@ union cvmx_pko_l4_sqx_sw_xoff {
                                                          until the path has drained." */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
 	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_L1_SQ()_TOPOLOGY[LINK] must be configured before using this
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
                                                          register field. Writing to this register field before the associated
-                                                         PKO_L1_SQ()_TOPOLOGY[LINK] value is configured can result in modifying the software
+                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
                                                          XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
@@ -5791,8 +5993,12 @@ union cvmx_pko_l5_sqx_cir {
 	struct cvmx_pko_l5_sqx_cir_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
-	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
+	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
+	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
 	uint64_t reserved_17_28               : 12;
 	uint64_t rate_divider_exponent        : 4;  /**< Rate divider exponent. This 4-bit base-2 exponent is used to divide the credit rate by
                                                          specifying the number of time-wheel turns required before the accumulator is increased.
@@ -5861,7 +6067,7 @@ union cvmx_pko_l5_sqx_pick {
 	struct cvmx_pko_l5_sqx_pick_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t dq                           : 10; /**< Descriptor queue. Index of originating descriptor queue. */
-	uint64_t color                        : 2;  /**< See PKO_L2_SQ()_SHAPE[COLOR]. */
+	uint64_t color                        : 2;  /**< See PKO_COLORRESULT_E. */
 	uint64_t child                        : 10; /**< Child index. When the C_CON bit of this result is set, indicating that this result is
                                                          connected in a flow that extends through the child result, this is the index of that child
                                                          result. */
@@ -5869,14 +6075,29 @@ union cvmx_pko_l5_sqx_pick {
 	uint64_t p_con                        : 1;  /**< Parent connected flag. This pick has more picks in front of it. */
 	uint64_t c_con                        : 1;  /**< Child connected flag. This pick has more picks behind it. */
 	uint64_t uid                          : 7;  /**< Unique ID. 7-bit unique value assigned at the DQ level, increments for each packet. */
-	uint64_t jump                         : 1;  /**< Jump. Set when metapacket originated from a jump descriptor. */
-	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when metapacket was the first in a cacheline. */
-	uint64_t ds                           : 1;  /**< Don't send. Set when metapacket is not to be sent. */
-	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ()_SHAPE[ADJUST]. */
-	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. */
-	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. */
-	uint64_t red_algo_override            : 2;  /**< See PKO_L2_SQ()_SHAPE[RED_ALGO]. */
-	uint64_t length                       : 16; /**< Packet length. The packet length in bytes. */
+	uint64_t jump                         : 1;  /**< Set when the corresponding descriptor contains a PKO_SEND_JUMP_S. */
+	uint64_t fpd                          : 1;  /**< First packet descriptor. Set when corresponding descriptor is the first in a cacheline. */
+	uint64_t ds                           : 1;  /**< PKO_SEND_HDR_S[DS] from the corresponding descriptor. Has no effect on any shaper. */
+	uint64_t adjust                       : 9;  /**< The PKO_SEND_EXT_S[SHAPECHG] for the packet. Zero if a PKO_SEND_EXT_S is not present in
+                                                         the corresponding descriptor. */
+	uint64_t pir_dis                      : 1;  /**< PIR disable. Peak shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or CIR_ONLY
+                                                         (i.e. [PIR_DIS]=PKO_SEND_EXT_S[COL<1>]). Zero if a PKO_SEND_EXT_S is not present in the
+                                                         corresponding descriptor. See PKO_COLORALG_E. [PIR_DIS] is used by the DQ through L2
+                                                         shapers, but not used by the L1 rate limiters. */
+	uint64_t cir_dis                      : 1;  /**< CIR disable. Committed shaper disabled. Set when PKO_SEND_EXT_S[COL] is NO_COLOR or
+                                                         EIR_PIR_ONLY (i.e. [CIR_DIS]=PKO_SEND_EXT_S[COL<0>]). Zero if a PKO_SEND_EXT_S is not
+                                                         present in the corresponding descriptor. See PKO_COLORALG_E. [CIR_DIS] is used by the
+                                                         DQ through L2 shapers, but not used by the L1 rate limiters. */
+	uint64_t red_algo_override            : 2;  /**< PKO_SEND_EXT_S[RA] from the corresponding packet descriptor. Zero
+                                                         (i.e. PKO_REDALG_E::STD) if a PKO_SEND_EXT_S is not present in the
+                                                         corresponding descriptor. [RED_ALGO_OVERRIDE] is used by the DQ through L2
+                                                         shapers, but not used by the L1 rate limiters. */
+	uint64_t length                       : 16; /**< The packet length in bytes including pad.
+                                                               PKO_SEND_HDR_S[TOTAL] + CALCPAD
+                                                         where CALCPAD is zero when PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
+                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN], else
+                                                         CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the
+                                                         DQ the packet used. */
 #else
 	uint64_t length                       : 16;
 	uint64_t red_algo_override            : 2;
@@ -5910,8 +6131,12 @@ union cvmx_pko_l5_sqx_pir {
 	struct cvmx_pko_l5_sqx_pir_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_41_63               : 23;
-	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
-	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is specified as 1.BURST_MANTISSA << BURST_EXPONENT. */
+	uint64_t burst_exponent               : 4;  /**< Burst exponent. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
+	uint64_t burst_mantissa               : 8;  /**< Burst mantissa. The burst limit is 1.BURST_MANTISSA << (BURST_EXPONENT + 1).
+                                                         With BURST_EXPONENT=0xF and BURST_MANTISSA=0xFF, the burst limit is the largest
+                                                         possible value, which is 130,816 (0x1FF00) bytes. */
 	uint64_t reserved_17_28               : 12;
 	uint64_t rate_divider_exponent        : 4;  /**< Rate divider exponent. This 4-bit base-2 exponent is used to divide the credit rate by
                                                          specifying the number of time-wheel turns required before the accumulator is increased.
@@ -6028,16 +6253,15 @@ union cvmx_pko_l5_sqx_schedule {
                                                          PKO_*_TOPOLOGY[PARENT] for this SQ equals n, then this is a round-robin child queue into
                                                          the shaper at the next level. */
 	uint64_t rr_quantum                   : 24; /**< Round-robin (DWRR) quantum. The deficit-weighted round-robin quantum (24-bit unsigned
-                                                         integer).
-                                                         The packet size used in all DWRR calculations is:
-                                                         _  (PKO_Ln_SQm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD)) +
-                                                            PKO_SEND_EXT_S[SHAPECHG] +
-                                                            PKO_Ln_SQm_SHAPE[ADJUST]
-                                                         where n and m correspond to this PKO_Ln_SQm_SCHEDULE CSR. CALCPAD is zero when
-                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[MINLEN],
-                                                         else CALCPAD=PKO_PDM_CFG[MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the packet used.
-                                                         PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present in the send
-                                                         descriptor. */
+                                                         integer). The packet size used in all DWRR (RR_COUNT) calculations is:
+                                                         _  (PKO_nm_SHAPE[LENGTH_DISABLE] ? 0 : (PKO_SEND_HDR_S[TOTAL] + CALCPAD +
+                                                            PKO_SEND_EXT_S[SHAPECHG])) + PKO_nm_SHAPE[ADJUST]
+                                                         where nm corresponds to this PKO_nm_SCHEDULE CSR. CALCPAD is zero when
+                                                         PKO_PDM_DQd_MINPAD[MINPAD] is clear or when
+                                                         PKO_PDM_CFG[TOTAL]>=PKO_PDM_CFG[PKO_PAD_MINLEN],
+                                                         else CALCPAD=PKO_PDM_CFG[PKO_PAD_MINLEN]-PKO_SEND_HDR_S[TOTAL], where d is the DQ the
+                                                         packet used. PKO_SEND_EXT_S[SHAPECHG] is zero when a PKO_SEND_EXT_S is not present
+                                                         in the send descriptor. */
 #else
 	uint64_t rr_quantum                   : 24;
 	uint64_t prio                         : 4;
@@ -6057,12 +6281,10 @@ union cvmx_pko_l5_sqx_shape {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_25_63               : 39;
 	uint64_t length_disable               : 1;  /**< Length disable. Disables the use of packet lengths in DWRR scheduling
-                                                         and shaping calculations such that only the values of
-                                                         PKO_L5_SQ()_SHAPE[ADJUST] and PKO_SEND_EXT_S[SHAPECHG] are used. */
+                                                         and shaping calculations such that only the value of [ADJUST] is used. */
 	uint64_t reserved_13_23               : 11;
-	uint64_t yellow_disable               : 1;  /**< Disable yellow transitions. Disables green-to-yellow packet color marking transitions when set. */
-	uint64_t red_disable                  : 1;  /**< Disable red transitions. Disables green-to-red and yellow-to-red packet color marking
-                                                         transitions when set. */
+	uint64_t yellow_disable               : 1;  /**< See PKO_L2_SQ()_SHAPE[YELLOW_DISABLE]. */
+	uint64_t red_disable                  : 1;  /**< See PKO_L2_SQ()_SHAPE[RED_DISABLE]. */
 	uint64_t red_algo                     : 2;  /**< See PKO_L2_SQ()_SHAPE[RED_ALGO]. */
 	uint64_t adjust                       : 9;  /**< See PKO_L2_SQ()_SHAPE[ADJUST]. */
 #else
@@ -6127,11 +6349,11 @@ union cvmx_pko_l5_sqx_sw_xoff {
                                                          until the path has drained." */
 	uint64_t drain                        : 1;  /**< Drain. This control activates a drain path through the PSE that starts at this node and
                                                          ends at the SQ1 level. The drain path is prioritized over other paths through PSE and can
-                                                         be used in combination with DRAIN_NULL_LINK and DRAIN_IRQ. */
+                                                         be used in combination with [DRAIN_NULL_LINK] and [DRAIN_IRQ]. */
 	uint64_t xoff                         : 1;  /**< XOFF. The PQ is disabled when XOFF is asserted. PQ is enabled when XOFF is deasserted.
-                                                         NOTE: The associated PKO_L1_SQ()_TOPOLOGY[LINK] must be configured before using this
+                                                         NOTE: The associated PKO_*_TOPOLOGY[LINK/PARENT] must be configured before using this
                                                          register field. Writing to this register field before the associated
-                                                         PKO_L1_SQ()_TOPOLOGY[LINK] value is configured can result in modifying the software
+                                                         PKO_*_TOPOLOGY[LINK/PARENT] value is configured can result in modifying the software
                                                          XOFF state of the wrong SQ. */
 #else
 	uint64_t xoff                         : 1;
@@ -6397,11 +6619,29 @@ typedef union cvmx_pko_lut_ecc_sbe_sts_cmb0 cvmx_pko_lut_ecc_sbe_sts_cmb0_t;
 /**
  * cvmx_pko_mac#_cfg
  *
- * These registers create the links between the MACs and the TxFIFO used to store the data, and
- * hold
- * the per-MAC configuration bits.  These registers must be disabled (FIFO_NUM set to 0x1f) prior
- * to
- * reconfiguration of any of the other bits.
+ * These registers create the links between the MACs and the TxFIFO used to store the data,
+ * and hold the per-MAC configuration bits.  These registers must be disabled (FIFO_NUM set
+ * to 31) prior to reconfiguration of any of the other bits.
+ *
+ * <pre>
+ *   CSR Name        Associated MAC
+ *   ---------------------------------
+ *   PKO_MAC0_CFG   LBK loopback
+ *   PKO_MAC1_CFG   DPI packet output
+ *   PKO_MAC2_CFG   ILK link 0
+ *   PKO_MAC3_CFG   ILK link 1
+ *   PKO_MAC4_CFG   BGX0 logical MAC 0
+ *   PKO_MAC5_CFG   BGX0 logical MAC 1
+ *   PKO_MAC6_CFG   BGX0 logical MAC 2
+ *   PKO_MAC7_CFG   BGX0 logical MAC 3
+ *   PKO_MAC8_CFG   BGX1 logical MAC 0
+ *   PKO_MAC9_CFG   BGX1 logical MAC 1
+ *   PKO_MAC10_CFG  BGX1 logical MAC 2
+ *   PKO_MAC11_CFG  BGX1 logical MAC 3
+ *   PKO_MAC12_CFG  BGX2 logical MAC 0
+ *   - ...
+ *   PKO_MAC27_CFG  BGX5 logical MAC 3
+ * </pre>
  */
 union cvmx_pko_macx_cfg {
 	uint64_t u64;
@@ -6413,11 +6653,12 @@ union cvmx_pko_macx_cfg {
 	uint64_t fcs_sop_off                  : 8;  /**< FCS start of packet offset. For this MAC, the number of bytes in the front of each packet
                                                          to exclude from FCS. */
 	uint64_t skid_max_cnt                 : 2;  /**< Maximum number of SKID credits. 0x0 = 16; 0x1 = 32; 0x2 = 64. */
-	uint64_t fifo_num                     : 5;  /**< The PEB TX FIFO number assigned to the given MAC. A value of 0x1F means unassigned. Unused
-                                                         MACs must be assigned a FIFO_NUM = 0x1F. For each active MAC, a unique FIFO_NUM must be
-                                                         assigned. Legal values depend on the values in PKO_PTGF()_CFG[SIZE]. Assigning the
-                                                         same FIFO_NUM to more than a single active MAC will have unpredictable results. FIFOs 0x1E
-                                                         and 0x1D are invalid and will cause unpredictable results if used. */
+	uint64_t fifo_num                     : 5;  /**< The PEB TX FIFO number assigned to the given MAC. A value of 31 means unassigned. Unused
+                                                         MACs must have [FIFO_NUM] = 31. For each active MAC, a unique valid FIFO_NUM must
+                                                         be assigned. When all PKO_PTGF(0..6)_CFG[SIZE] are zero, legal [FIFO_NUM] values are
+                                                         0..27 and 31. [FIFO_NUM] can never select the NULL FIFO. At most one
+                                                         used MAC can be simultaneously assigned the same used [FIFO_NUM].
+                                                         [FIFO_NUM] values 28-30 are illegal and must not be used. */
 #else
 	uint64_t fifo_num                     : 5;
 	uint64_t skid_max_cnt                 : 2;
@@ -8847,8 +9088,8 @@ union cvmx_pko_pdm_bist_status {
 	uint64_t drp_lo_ram_bist_status       : 1;  /**< BIST status for DRP_LO_RAM. */
 	uint64_t dwp_hi_ram_bist_status       : 1;  /**< BIST status for DWP_HI_RAM. */
 	uint64_t dwp_lo_ram_bist_status       : 1;  /**< BIST status for DWP_LO_RAM. */
-	uint64_t mwp_hi_ram_bist_status       : 1;  /**< BIST status for MWP_HI_RAM. */
-	uint64_t mwp_lo_ram_bist_status       : 1;  /**< BIST status for MWP_LO_RAM. */
+	uint64_t mwp_hi_ram_bist_status       : 1;  /**< BIST status for MWP_RAM_MEM2. */
+	uint64_t mwp_lo_ram_bist_status       : 1;  /**< BIST status for MWP_RAM_MEM0. */
 	uint64_t fillb_m_rsp_ram_hi_bist_status : 1;/**< BIST status for FILLB_M_RSP_RAM_HI. */
 	uint64_t fillb_m_rsp_ram_lo_bist_status : 1;/**< BIST status for FILLB_M_RSP_RAM_LO. */
 	uint64_t fillb_d_rsp_ram_hi_bist_status : 1;/**< BIST status for FILLB_D_RSP_RAM_HI. */
@@ -8858,9 +9099,13 @@ union cvmx_pko_pdm_bist_status {
 	uint64_t flshb_m_dat_ram_bist_status  : 1;  /**< BIST status for FLSHB_M_DAT_RAM. */
 	uint64_t flshb_d_dat_ram_bist_status  : 1;  /**< BIST status for FLSHB_M_DAT_RAM. */
 	uint64_t minpad_ram_bist_status       : 1;  /**< BIST status for MINPAD_RAM. */
-	uint64_t reserved_0_37                : 38;
+	uint64_t mwp_hi_spt_ram_bist_status   : 1;  /**< Reserved. */
+	uint64_t mwp_lo_spt_ram_bist_status   : 1;  /**< Reserved. */
+	uint64_t reserved_0_35                : 36;
 #else
-	uint64_t reserved_0_37                : 38;
+	uint64_t reserved_0_35                : 36;
+	uint64_t mwp_lo_spt_ram_bist_status   : 1;
+	uint64_t mwp_hi_spt_ram_bist_status   : 1;
 	uint64_t minpad_ram_bist_status       : 1;
 	uint64_t flshb_d_dat_ram_bist_status  : 1;
 	uint64_t flshb_m_dat_ram_bist_status  : 1;
@@ -9046,15 +9291,22 @@ union cvmx_pko_pdm_dwpbuf_dbg {
 	uint64_t u64;
 	struct cvmx_pko_pdm_dwpbuf_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_43_63               : 21;
+	uint64_t reserved_48_63               : 16;
+	uint64_t cmd_proc                     : 1;  /**< Reserved. */
+	uint64_t reserved_46_46               : 1;
+	uint64_t mem_data_val                 : 1;  /**< Reserved. */
+	uint64_t insert_np                    : 1;  /**< Reserved. */
+	uint64_t reserved_43_43               : 1;
 	uint64_t sel_nxt_ptr                  : 1;  /**< Sel_nxt_ptr signal. */
 	uint64_t load_val                     : 1;  /**< Load valid signal. */
 	uint64_t rdy                          : 1;  /**< Ready signal. */
 	uint64_t cur_state                    : 3;  /**< Current state from the pbuf controller. */
-	uint64_t reserved_33_36               : 4;
+	uint64_t mem_rdy                      : 1;  /**< Reserved. */
+	uint64_t reserved_33_35               : 3;
 	uint64_t track_rd_cnt                 : 6;  /**< Track read count value. */
 	uint64_t track_wr_cnt                 : 6;  /**< Track write count value. */
-	uint64_t reserved_17_20               : 4;
+	uint64_t reserved_19_20               : 2;
+	uint64_t insert_dp                    : 2;  /**< Reserved. */
 	uint64_t mem_addr                     : 13; /**< Memory address for pbuf ram. */
 	uint64_t mem_en                       : 4;  /**< Memory write/chip enable signals. The order of the bits is:
                                                          0x3 = Low wen.
@@ -9064,15 +9316,22 @@ union cvmx_pko_pdm_dwpbuf_dbg {
 #else
 	uint64_t mem_en                       : 4;
 	uint64_t mem_addr                     : 13;
-	uint64_t reserved_17_20               : 4;
+	uint64_t insert_dp                    : 2;
+	uint64_t reserved_19_20               : 2;
 	uint64_t track_wr_cnt                 : 6;
 	uint64_t track_rd_cnt                 : 6;
-	uint64_t reserved_33_36               : 4;
+	uint64_t reserved_33_35               : 3;
+	uint64_t mem_rdy                      : 1;
 	uint64_t cur_state                    : 3;
 	uint64_t rdy                          : 1;
 	uint64_t load_val                     : 1;
 	uint64_t sel_nxt_ptr                  : 1;
-	uint64_t reserved_43_63               : 21;
+	uint64_t reserved_43_43               : 1;
+	uint64_t insert_np                    : 1;
+	uint64_t mem_data_val                 : 1;
+	uint64_t reserved_46_46               : 1;
+	uint64_t cmd_proc                     : 1;
+	uint64_t reserved_48_63               : 16;
 #endif
 	} s;
 	struct cvmx_pko_pdm_dwpbuf_dbg_s      cn78xx;
@@ -9186,13 +9445,23 @@ union cvmx_pko_pdm_ecc_ctl1 {
 	uint64_t u64;
 	struct cvmx_pko_pdm_ecc_ctl1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_3_63                : 61;
+	uint64_t reserved_12_63               : 52;
+	uint64_t mwp_mem0_ram_flip            : 2;  /**< Reserved. */
+	uint64_t mwp_mem1_ram_flip            : 2;  /**< Reserved. */
+	uint64_t mwp_mem2_ram_flip            : 2;  /**< Reserved. */
+	uint64_t mwp_mem3_ram_flip            : 2;  /**< Reserved. */
+	uint64_t mwp_ram_cdis                 : 1;  /**< Reserved. */
 	uint64_t minpad_ram_flip              : 2;  /**< MINPAD_RAM flip syndrome bits on write. */
 	uint64_t minpad_ram_cdis              : 1;  /**< MINPAD_RAM ECC correction disable. */
 #else
 	uint64_t minpad_ram_cdis              : 1;
 	uint64_t minpad_ram_flip              : 2;
-	uint64_t reserved_3_63                : 61;
+	uint64_t mwp_ram_cdis                 : 1;
+	uint64_t mwp_mem3_ram_flip            : 2;
+	uint64_t mwp_mem2_ram_flip            : 2;
+	uint64_t mwp_mem1_ram_flip            : 2;
+	uint64_t mwp_mem0_ram_flip            : 2;
+	uint64_t reserved_12_63               : 52;
 #endif
 	} s;
 	struct cvmx_pko_pdm_ecc_ctl1_s        cn78xx;
@@ -9236,10 +9505,10 @@ union cvmx_pko_pdm_ecc_dbe_sts0 {
                                                          pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_high */
 	uint64_t dwp_lo_ram_dbe               : 1;  /**< Double-bit error for DWP_LO_RAM. INTERNAL: Instances:
                                                          pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_low */
-	uint64_t mwp_hi_ram_dbe               : 1;  /**< Double-bit error for MWP_HI_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_high */
-	uint64_t mwp_lo_ram_dbe               : 1;  /**< Double-bit error for MWP_LO_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_low */
+	uint64_t mwp_hi_ram_dbe               : 1;  /**< Double-bit error for MWP_RAM_PBUF_MEM2. INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem2 */
+	uint64_t mwp_lo_ram_dbe               : 1;  /**< Double-bit error for MWP_RAM_PBUF_MEM0. INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem0 */
 	uint64_t fillb_m_rsp_ram_hi_dbe       : 1;  /**< Double-bit error for FILLB_M_DAT_RAM_HI. INTERNAL: Instances:
                                                          pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_ram_hi */
 	uint64_t fillb_m_rsp_ram_lo_dbe       : 1;  /**< Double-bit error for FILLB_D_DAT_RAM_LO. INTERNAL: Instances:
@@ -9249,9 +9518,13 @@ union cvmx_pko_pdm_ecc_dbe_sts0 {
 	uint64_t fillb_d_rsp_ram_lo_dbe       : 1;  /**< Double-bit error for FILLB_D_DAT_RAM_LO. INTERNAL: Instances:
                                                          pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_lo */
 	uint64_t minpad_ram_dbe               : 1;  /**< Double-bit error for MINPAD_RAM. INTERNAL: Instances: pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
-	uint64_t reserved_0_41                : 42;
+	uint64_t mwp_hi_spt_ram_dbe           : 1;  /**< Reserved. */
+	uint64_t mwp_lo_spt_ram_dbe           : 1;  /**< Reserved. */
+	uint64_t reserved_0_39                : 40;
 #else
-	uint64_t reserved_0_41                : 42;
+	uint64_t reserved_0_39                : 40;
+	uint64_t mwp_lo_spt_ram_dbe           : 1;
+	uint64_t mwp_hi_spt_ram_dbe           : 1;
 	uint64_t minpad_ram_dbe               : 1;
 	uint64_t fillb_d_rsp_ram_lo_dbe       : 1;
 	uint64_t fillb_d_rsp_ram_hi_dbe       : 1;
@@ -9359,10 +9632,10 @@ union cvmx_pko_pdm_ecc_sbe_sts0 {
                                                          pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_high */
 	uint64_t dwp_lo_ram_sbe               : 1;  /**< Single-bit error for DWP_LO_RAM. INTERNAL: Instances:
                                                          pko_pnr1.pko_pnr1_pdm.dwpbuf.ram_128k_pbuf_low */
-	uint64_t mwp_hi_ram_sbe               : 1;  /**< Single-bit error for MWP_HI_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_high */
-	uint64_t mwp_lo_ram_sbe               : 1;  /**< Single-bit error for MWP_LO_RAM. INTERNAL: Instances:
-                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_128k_pbuf_low */
+	uint64_t mwp_hi_ram_sbe               : 1;  /**< Single-bit error for MWP_RAM_PBUF_MEM2. INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem2 */
+	uint64_t mwp_lo_ram_sbe               : 1;  /**< Single-bit error for MWP_RAM_PBUF_MEM0. INTERNAL: Instances:
+                                                         pko_pnr1.pko_pnr1_pdm.mwpbuf.ram_pbuf_mem0 */
 	uint64_t fillb_m_rsp_ram_hi_sbe       : 1;  /**< Single-bit error for FILLB_M_RSP_RAM_HI. INTERNAL: Instances:
                                                          pko_pnr1.pko_pnr1_pdm.fillb.m_rsp_ram_hi */
 	uint64_t fillb_m_rsp_ram_lo_sbe       : 1;  /**< Single-bit error for FILLB_M_RSP_RAM_LO. INTERNAL: Instances:
@@ -9372,9 +9645,13 @@ union cvmx_pko_pdm_ecc_sbe_sts0 {
 	uint64_t fillb_d_rsp_ram_lo_sbe       : 1;  /**< Single-bit error for FILLB_D_RSP_RAM_LO. INTERNAL: Instances:
                                                          pko_pnr1.pko_pnr1_pdm.fillb.d_rsp_ram_lo */
 	uint64_t minpad_ram_sbe               : 1;  /**< Single-bit error for MINPAD_RAM. INTERNAL: Instances: pko_pnr1.pko_pnr1_pdm.cp.minpad_ram */
-	uint64_t reserved_0_41                : 42;
+	uint64_t mwp_hi_spt_ram_sbe           : 1;  /**< Reserved. */
+	uint64_t mwp_lo_spt_ram_sbe           : 1;  /**< Reserved. */
+	uint64_t reserved_0_39                : 40;
 #else
-	uint64_t reserved_0_41                : 42;
+	uint64_t reserved_0_39                : 40;
+	uint64_t mwp_lo_spt_ram_sbe           : 1;
+	uint64_t mwp_hi_spt_ram_sbe           : 1;
 	uint64_t minpad_ram_sbe               : 1;
 	uint64_t fillb_d_rsp_ram_lo_sbe       : 1;
 	uint64_t fillb_d_rsp_ram_hi_sbe       : 1;
@@ -9890,33 +10167,49 @@ union cvmx_pko_pdm_mwpbuf_dbg {
 	uint64_t u64;
 	struct cvmx_pko_pdm_mwpbuf_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t reserved_43_63               : 21;
+	uint64_t reserved_49_63               : 15;
+	uint64_t str_proc                     : 1;  /**< Reserved. */
+	uint64_t cmd_proc                     : 1;  /**< Reserved. */
+	uint64_t str_val                      : 1;  /**< Reserved. */
+	uint64_t mem_data_val                 : 1;  /**< Reserved. */
+	uint64_t insert_np                    : 1;  /**< Reserved. */
+	uint64_t insert_mp                    : 1;  /**< Reserved. */
 	uint64_t sel_nxt_ptr                  : 1;  /**< Sel_nxt_ptr signal. */
 	uint64_t load_val                     : 1;  /**< Load valid signal. */
 	uint64_t rdy                          : 1;  /**< Ready signal. */
 	uint64_t cur_state                    : 3;  /**< Current state from the pbuf controller. */
-	uint64_t reserved_33_36               : 4;
+	uint64_t mem_rdy                      : 1;  /**< Rreserved */
+	uint64_t str_rdy                      : 1;  /**< Reserved. */
+	uint64_t contention_type              : 2;  /**< Reserved. */
 	uint64_t track_rd_cnt                 : 6;  /**< Track read count value. */
 	uint64_t track_wr_cnt                 : 6;  /**< Track write count value. */
-	uint64_t reserved_17_20               : 4;
+	uint64_t mem_wen                      : 4;  /**< Reserved. */
 	uint64_t mem_addr                     : 13; /**< Memory address for pbuf ram. */
 	uint64_t mem_en                       : 4;  /**< Memory write/chip enable signals. The order of the bits is:
-                                                         0x3 = Low wen.
-                                                         0x2 = Low cen.
-                                                         0x1 = High wen.
-                                                         0x0 = High cen. */
+                                                         0x3 = cen mem3.
+                                                         0x2 = cen mem2.
+                                                         0x1 = cen mem1.
+                                                         0x0 = cen mem0. */
 #else
 	uint64_t mem_en                       : 4;
 	uint64_t mem_addr                     : 13;
-	uint64_t reserved_17_20               : 4;
+	uint64_t mem_wen                      : 4;
 	uint64_t track_wr_cnt                 : 6;
 	uint64_t track_rd_cnt                 : 6;
-	uint64_t reserved_33_36               : 4;
+	uint64_t contention_type              : 2;
+	uint64_t str_rdy                      : 1;
+	uint64_t mem_rdy                      : 1;
 	uint64_t cur_state                    : 3;
 	uint64_t rdy                          : 1;
 	uint64_t load_val                     : 1;
 	uint64_t sel_nxt_ptr                  : 1;
-	uint64_t reserved_43_63               : 21;
+	uint64_t insert_mp                    : 1;
+	uint64_t insert_np                    : 1;
+	uint64_t mem_data_val                 : 1;
+	uint64_t str_val                      : 1;
+	uint64_t cmd_proc                     : 1;
+	uint64_t str_proc                     : 1;
+	uint64_t reserved_49_63               : 15;
 #endif
 	} s;
 	struct cvmx_pko_pdm_mwpbuf_dbg_s      cn78xx;
@@ -10031,14 +10324,13 @@ union cvmx_pko_peb_bist_status {
 	uint64_t iobp0_fifo_ram               : 1;  /**< IOBP0_FIFO RAM BIST status. */
 	uint64_t iobp1_fifo_ram               : 1;  /**< IOBP1_FIFO RAM BIST status. */
 	uint64_t state_mem0                   : 1;  /**< STATE_MEM0 RAM BIST status. */
-	uint64_t state_mem1                   : 1;  /**< STATE_MEM1 RAM BIST status. */
-	uint64_t state_mem2                   : 1;  /**< STATE_MEM2 RAM BIST status. */
+	uint64_t reserved_19_20               : 2;
 	uint64_t state_mem3                   : 1;  /**< STATE_MEM3 RAM BIST status. */
 	uint64_t iobp1_uid_fifo_ram           : 1;  /**< IOBP1_UID_FIFO RAM BIST status. */
 	uint64_t nxt_link_ptr_ram             : 1;  /**< NXT_LINK_PTR RAM BIST status. */
 	uint64_t pd_bank0_ram                 : 1;  /**< PD_BANK0 RAM BIST status. */
-	uint64_t pd_bank1_ram                 : 1;  /**< PD_BANK1 RAM BIST status. */
-	uint64_t pd_bank2_ram                 : 1;  /**< PD_BANK2 RAM BIST status. */
+	uint64_t pd_bank1_ram                 : 1;  /**< PD_BANK1 RAM BIST status (pass 1 only). */
+	uint64_t pd_bank2_ram                 : 1;  /**< PD_BANK2 RAM BIST status (pass 1 only). */
 	uint64_t pd_bank3_ram                 : 1;  /**< PD_BANK3 RAM BIST status. */
 	uint64_t pd_var_bank_ram              : 1;  /**< PD_VAR_BANK RAM BIST status. */
 	uint64_t pdm_resp_buf_ram             : 1;  /**< PDM_RESP_BUF RAM BIST status. */
@@ -10072,8 +10364,7 @@ union cvmx_pko_peb_bist_status {
 	uint64_t nxt_link_ptr_ram             : 1;
 	uint64_t iobp1_uid_fifo_ram           : 1;
 	uint64_t state_mem3                   : 1;
-	uint64_t state_mem2                   : 1;
-	uint64_t state_mem1                   : 1;
+	uint64_t reserved_19_20               : 2;
 	uint64_t state_mem0                   : 1;
 	uint64_t iobp1_fifo_ram               : 1;
 	uint64_t iobp0_fifo_ram               : 1;
@@ -10109,10 +10400,10 @@ union cvmx_pko_peb_ecc_ctl0 {
 	uint64_t peb_st_inf_ram_cdis          : 1;  /**< PEB_ST_INF_RAM ECC correction disable. */
 	uint64_t pd_bank3_ram_flip            : 2;  /**< PD_BANK3_RAM flip syndrome bits on write. */
 	uint64_t pd_bank3_ram_cdis            : 1;  /**< PD_BANK3_RAM ECC correction disable. */
-	uint64_t pd_bank2_ram_flip            : 2;  /**< PD_BANK2_RAM flip syndrome bits on write. */
-	uint64_t pd_bank2_ram_cdis            : 1;  /**< PD_BANK2_RAM ECC correction disable. */
-	uint64_t pd_bank1_ram_flip            : 2;  /**< PD_BANK1_RAM flip syndrome bits on write. */
-	uint64_t pd_bank1_ram_cdis            : 1;  /**< PD_BANK1_RAM ECC correction disable. */
+	uint64_t pd_bank2_ram_flip            : 2;  /**< PD_BANK2_RAM flip syndrome bits on write (pass 1 only). */
+	uint64_t pd_bank2_ram_cdis            : 1;  /**< PD_BANK2_RAM ECC correction disable (pass 1 only). */
+	uint64_t pd_bank1_ram_flip            : 2;  /**< PD_BANK1_RAM flip syndrome bits on write (pass 1 only). */
+	uint64_t pd_bank1_ram_cdis            : 1;  /**< PD_BANK1_RAM ECC correction disable (pass 1 only). */
 	uint64_t pd_bank0_ram_flip            : 2;  /**< PD_BANK0_RAM flip syndrome bits on write. */
 	uint64_t pd_bank0_ram_cdis            : 1;  /**< PD_BANK0_RAM ECC correction disable. */
 	uint64_t pd_var_bank_ram_flip         : 2;  /**< PD_VAR_BANK_RAM flip syndrome bits on write. */
@@ -10357,7 +10648,7 @@ union cvmx_pko_peb_ecc_sbe_sts0 {
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank2_i */
 	uint64_t pd_bank1_ram_sbe             : 1;  /**< Single-bit error for PD_BANK1_RAM. INTERNAL: Instances:
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank1_i */
-	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK1_RAM. INTERNAL: Instances:
+	uint64_t pd_bank0_ram_sbe             : 1;  /**< Single-bit error for PD_BANK0_RAM. INTERNAL: Instances:
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_mem_bank0_i */
 	uint64_t pd_var_bank_ram_sbe          : 1;  /**< Single-bit error for PD_VAR_BANK_RAM. INTERNAL: Instances:
                                                          pko_pnr3.pko_pnr3_peb.pko_peb_state_mem_i.pko_peb_pd_var_mem_bank_i */
@@ -10736,6 +11027,28 @@ union cvmx_pko_peb_trunc_err_info {
 typedef union cvmx_pko_peb_trunc_err_info cvmx_pko_peb_trunc_err_info_t;
 
 /**
+ * cvmx_pko_peb_tso_cfg
+ */
+union cvmx_pko_peb_tso_cfg {
+	uint64_t u64;
+	struct cvmx_pko_peb_tso_cfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t fsf                          : 8;  /**< Reserved. */
+	uint64_t msf                          : 8;  /**< Reserved. */
+	uint64_t lsf                          : 8;  /**< Reserved. */
+#else
+	uint64_t lsf                          : 8;
+	uint64_t msf                          : 8;
+	uint64_t fsf                          : 8;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_pko_peb_tso_cfg_s         cn78xx;
+};
+typedef union cvmx_pko_peb_tso_cfg cvmx_pko_peb_tso_cfg_t;
+
+/**
  * cvmx_pko_pq_csr_bus_debug
  */
 union cvmx_pko_pq_csr_bus_debug {
@@ -13196,8 +13509,21 @@ typedef union cvmx_pko_ptf_iobp_cfg cvmx_pko_ptf_iobp_cfg_t;
 /**
  * cvmx_pko_ptgf#_cfg
  *
- * This register configurations specific to the PKO TX FIFO groups (clusters of four PKO TX FIFOs).
- *
+ * This register configures a PKO TX FIFO group. PKO supports up to 29 independent
+ * TX FIFOs, where 0-27 are physical and 28 is Virtual/NULL. (PKO drops packets
+ * targeting the NULL FIFO, returning their buffers to the FPA.) PKO puts each
+ * FIFO into one of eight groups:
+ *
+ * <pre>
+ *   CSR Name       FIFO's in FIFO Group
+ *   -----------------------------------
+ *   PKO_PTGF0_CFG      0,  1,  2,  3
+ *   PKO_PTGF1_CFG      4,  5,  6,  7
+ *   PKO_PTGF2_CFG      8,  9, 10, 11
+ *   - ...
+ *   PKO_PTGF6_CFG     24, 25, 26, 27
+ *   PKO_PTGF7_CFG      Virtual/NULL
+ * </pre>
  */
 union cvmx_pko_ptgfx_cfg {
 	uint64_t u64;
@@ -13205,52 +13531,51 @@ union cvmx_pko_ptgfx_cfg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
 	uint64_t reset                        : 1;  /**< This bit resets the address pointers for the FIFOs in this group. This should only be
-                                                         performed when a PTGF is empty and the SIZE field is to be being changed. */
-	uint64_t rate                         : 3;  /**< Each PTGF can support up to 100 Gb/s. The total aggregate rate across all FIFOs (including
-                                                         the NULL) should never exceed 250 Gb/s. This field represents the rate for each active
-                                                         FIFO
-                                                         in PEB; thus the calculation for throughput is a function of the SIZE field and whether or
-                                                         not the FIFO is assigned to a MAC in PKO_MAC()_CFG.
-                                                         0x0 = 6.25 Gb/s.
-                                                         0x1 = 12.5 Gb/s.
-                                                         0x2 = 25 Gb/s.
-                                                         0x3 = 50 Gb/s.
-                                                         0x4 = 100 Gb/s.
-                                                         else reserved. */
-	uint64_t size                         : 3;  /**< "PKO supports up to 29 independent TX FIFOs where 0-27 are physical and 28 is virtual. The
-                                                         FIFOs are grouped into 8 sets of four contiguously numbered queues where each FIFO has a
-                                                         base storage amount of 2.5K bytes of buffering.
-                                                         _ PKO_PTGF(0)_CFG -> FIFO 0-3
-                                                         _ PKO_PTGF(1)_CFG -> FIFO 4-7
-                                                         _ PKO_PTGF(2)_CFG -> FIFO 8-11
-                                                         _ PKO_PTGF(3)_CFG -> FIFO 12-15
-                                                         _ PKO_PTGF(4)_CFG -> FIFO 16-19
-                                                         _ PKO_PTGF(5)_CFG -> FIFO 20-23
-                                                         _ PKO_PTGF(6)_CFG -> FIFO 24-27
-                                                         _ PKO_PTGF(7)_CFG -> FIFO 28 (Virtual/NULL)
-                                                         Within each set, 2 or 4 FIFOs can be combined to produce a larger FIFO if desired. The
-                                                         SIZE field is used to configure the number and depth of the FIFOs in a set. The supported
-                                                         options for a FIFO set are as follows:
-                                                         _ SIZE: Set of 4 Contiguously Numbered FIFOs
-                                                         _ ------------------------------------------
-                                                         _ xxx      Queue0  Queue1  Queue2  Queue3
-                                                         _ 000 :     2.5k    2.5k    2.5k    2.5k
-                                                         _ 001 :     5.0k    0.0k    2.5k    2.5k
-                                                         _ 010 :     2.5k    2.5k    5.0k    0.0k
-                                                         _ 011 :     5.0k    0.0k    5.0k    0.0k
-                                                         _ 100 :    10.0k    0.0k    0.0k    0.0k
-                                                         Note: 101-111 are illegal SIZE values and should not be used.
-                                                         Note that when a FIFO is set to a size of 0K bytes, FIFO_NUM is no longer legal and cannot
-                                                         be assigned to an active MAC. For example, for the set of FIFOs 8-11, if the
-                                                         PKO_PTGF(2)_CFG[SIZE] = 3'b100, then FIFO_NUMs 9, 10 and 11 are no longer valid. Only
-                                                         FIFO_NUM = 8 is available from this set for assignment to a MAC because all of the 10
-                                                         Kbytes of buffering was configured to FIFO 8.
-                                                         FIFO_NUM = 28 is a virtual FIFO and is used exclusively to indicate the NULL FIFO. Packets
-                                                         targeting the NULL FIFO are dropped by PKO and their buffers returned to the FPA. The SIZE
-                                                         field for PKO_PTGF(7) should always be set to zero. Modifications to this field require
-                                                         two writes. The first write must assert PKO_PTGF()_CFG[RESET] to reset the address
-                                                         pointers for the FIFOS in this group. The second write clears the RESET bit as well as
-                                                         configures the new SIZE values." */
+                                                         performed when a PTGF is empty and the SIZE field is to be changed. */
+	uint64_t rate                         : 3;  /**< The rate / number of inflight packets allowed for the FIFO's in this group.
+                                                         An individual FIFO can support up to 100 Gbit/sec (i.e. up to 64 inflight packets).
+                                                         The total aggregate rate across all FIFOs (including the NULL) should never exceed
+                                                         250 Gbit/sec (i.e. up to 160 inflight packets). This field represents the rate for
+                                                         each active FIFO in in the group; thus the calculation for throughput is a function
+                                                         of the SIZE field and whether or not the FIFO's in the group are assigned to a MAC
+                                                         in PKO_MAC()_CFG.
+                                                         Encoding:
+                                                         0x0 = up to   6.25 Gbit/sec (i.e. up to  4 inflight packets).
+                                                         0x1 = up to  12.5  Gbit/sec (i.e. up to  8 inflight packets).
+                                                         0x2 = up to  25    Gbit/sec (i.e. up to 16 inflight packets).
+                                                         0x3 = up to  50    Gbit/sec (i.e. up to 32 inflight packets).
+                                                         0x4 = up to 100    Gbit/sec (i.e. up to 64 inflight packets).
+                                                         else reserved.
+                                                         [RATE] applies to all FIFO groups including the NULL. */
+	uint64_t size                         : 3;  /**< Determines the size and availability of the FIFO's in the FIFO group.
+                                                         10KB total storage is available to the FIFO group. Two or
+                                                         four FIFOs can be combined to produce a larger FIFO if desired.
+                                                         The supported SIZE values:
+                                                         <pre>
+                                                                   FIFO0   FIFO1   FIFO2   FIFO3
+                                                            SIZE   Size    Size    Size    Size
+                                                           --------------------------------------
+                                                             0     2.5KB   2.5KB   2.5KB   2.5KB
+                                                             1     5.0KB    N/A    2.5KB   2.5KB
+                                                             2     2.5KB   2.5KB   5.0KB    N/A
+                                                             3     5.0KB    N/A    5.0KB    N/A
+                                                             4    10.0KB    N/A     N/A     N/A
+                                                         </pre>
+                                                         Note: 5-7 are illegal SIZE values and should not be used.
+                                                         A FIFO labelled N/A in the above table must not be used, and no
+                                                         _PTGF(7)_CFG[SIZE] should not change from its reset value
+                                                         PKO_MAC(7)_CFG[FIFO_NUM] should select it. For example,
+                                                         if PKO_PTGF(2)_CFG[SIZE]=4, FIFO_NUM 8 is available (with
+                                                         10KB), but FIFO_NUMs 9, 10, and 11 are not valid and should
+                                                         not be used.
+                                                         Modifications to this field require two writes. The first
+                                                         write must not modify [SIZE], and must assert [RESET] to
+                                                         reset the address pointers for the FIFOs in this group.
+                                                         The second write has the new [SIZE] value, and should clear
+                                                         [RESET].
+                                                         PKO_PTGF(7)_CFG[SIZE] should not change from its reset value
+                                                         of zero. (The NULL FIFO has no real storage, and the SIZE table
+                                                         above does not apply to the NULL FIFO.) */
 #else
 	uint64_t size                         : 3;
 	uint64_t rate                         : 3;
@@ -13263,6 +13588,34 @@ union cvmx_pko_ptgfx_cfg {
 typedef union cvmx_pko_ptgfx_cfg cvmx_pko_ptgfx_cfg_t;
 
 /**
+ * cvmx_pko_red_send_cfg
+ */
+union cvmx_pko_red_send_cfg {
+	uint64_t u64;
+	struct cvmx_pko_red_send_cfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t red_send_as_yellow           : 1;  /**< RED_SEND as YELLOW. Configures the way packets colored RED_SEND are
+                                                         handled by the DQ through L2 shapers.  Packets colored RED_DROP do not decrement
+                                                         the PIR in DQ through L2 shapers while packets colored YELLOW do.  (Neither RED_DROP
+                                                         nor YELLOW packets decrement the CIR in DQ through L2 shapers.)  Packets colored
+                                                         RED_SEND are treated as either RED_DROP or YELLOW in the DQ through L2 shapers
+                                                         as follows:
+                                                         0 = treat RED_SEND as RED_DROP.
+                                                         1 = treat RED_SEND as YELLOW.
+                                                         In the L1 shapers, RED_DROP packets do not decrement the CIR, while YELLOW do.
+                                                         RED_SEND packets are always treated the same as YELLOW is in the L1 shapers,
+                                                         irrespective of [RED_SEND_AS_YELLOW]. */
+#else
+	uint64_t red_send_as_yellow           : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_pko_red_send_cfg_s        cn78xx;
+};
+typedef union cvmx_pko_red_send_cfg cvmx_pko_red_send_cfg_t;
+
+/**
  * cvmx_pko_reg_bist_result
  *
  * Notes:
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index 0b852a4..079bd89 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -358,10 +358,32 @@ static inline uint64_t CVMX_SLI_MSIXX_TABLE_DATA(unsigned long offset)
 	if (!(
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 64)))))
 		cvmx_warn("CVMX_SLI_MSIXX_TABLE_DATA(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000016800ull) + ((offset) & 127) * 16;
+	return CVMX_ADD_IO_SEG(0x00011F0000016008ull) + ((offset) & 127) * 16;
 }
 #else
-#define CVMX_SLI_MSIXX_TABLE_DATA(offset) (CVMX_ADD_IO_SEG(0x00011F0000016800ull) + ((offset) & 127) * 16)
+#define CVMX_SLI_MSIXX_TABLE_DATA(offset) (CVMX_ADD_IO_SEG(0x00011F0000016008ull) + ((offset) & 127) * 16)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SLI_MSIX_MACX_PF_TABLE_ADDR(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_SLI_MSIX_MACX_PF_TABLE_ADDR(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000017C00ull) + ((offset) & 3) * 16;
+}
+#else
+#define CVMX_SLI_MSIX_MACX_PF_TABLE_ADDR(offset) (CVMX_ADD_IO_SEG(0x00011F0000017C00ull) + ((offset) & 3) * 16)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_SLI_MSIX_MACX_PF_TABLE_DATA(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3)))))
+		cvmx_warn("CVMX_SLI_MSIX_MACX_PF_TABLE_DATA(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000017C08ull) + ((offset) & 3) * 16;
+}
+#else
+#define CVMX_SLI_MSIX_MACX_PF_TABLE_DATA(offset) (CVMX_ADD_IO_SEG(0x00011F0000017C08ull) + ((offset) & 3) * 16)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_MSIX_PBA0 CVMX_SLI_MSIX_PBA0_FUNC()
@@ -5361,6 +5383,48 @@ union cvmx_sli_msixx_table_data {
 typedef union cvmx_sli_msixx_table_data cvmx_sli_msixx_table_data_t;
 
 /**
+ * cvmx_sli_msix_mac#_pf_table_addr
+ *
+ * These registers shadow the four physical MSIX PF ERR entries.
+ * Each MAC sees its entry at its own TRS offset.
+ */
+union cvmx_sli_msix_macx_pf_table_addr {
+	uint64_t u64;
+	struct cvmx_sli_msix_macx_pf_table_addr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t addr                         : 64; /**< Message address <63:0>. */
+#else
+	uint64_t addr                         : 64;
+#endif
+	} s;
+	struct cvmx_sli_msix_macx_pf_table_addr_s cn78xx;
+};
+typedef union cvmx_sli_msix_macx_pf_table_addr cvmx_sli_msix_macx_pf_table_addr_t;
+
+/**
+ * cvmx_sli_msix_mac#_pf_table_data
+ *
+ * These registers shadow four physical MSIX PF ERR entries.
+ * Each MAC sees its entry at its own TRS offset.
+ */
+union cvmx_sli_msix_macx_pf_table_data {
+	uint64_t u64;
+	struct cvmx_sli_msix_macx_pf_table_data_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_33_63               : 31;
+	uint64_t vector_ctl                   : 1;  /**< Message mask. */
+	uint64_t data                         : 32; /**< Message data <31:0>. */
+#else
+	uint64_t data                         : 32;
+	uint64_t vector_ctl                   : 1;
+	uint64_t reserved_33_63               : 31;
+#endif
+	} s;
+	struct cvmx_sli_msix_macx_pf_table_data_s cn78xx;
+};
+typedef union cvmx_sli_msix_macx_pf_table_data cvmx_sli_msix_macx_pf_table_data_t;
+
+/**
  * cvmx_sli_msix_pba0
  *
  * "The MSI-X Pending Bit Array must be addressed on a 8-byte aligned boundary and
@@ -6344,8 +6408,9 @@ union cvmx_sli_pkt_cnt_int {
 	struct cvmx_sli_pkt_cnt_int_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ring                         : 64; /**< Output ring packet counter interrupt bits SLI sets RING<i> whenever
-                                                         SLI_PKT()_CNTS[CNT] > SLI_PKT()_INT_LEVELS[CNT]. SLI_PKT_CNT_INT_ENB[RING<i>] is
-                                                         the corresponding enable. */
+                                                         SLI_PKT()_CNTS[CNT] > SLI_PKT()_INT_LEVELS[CNT].
+                                                         SLI_PKT_CNT_INT_ENB[RING<i>] is the corresponding enable.
+                                                         This field will be updated whenever there is a change in SLI_PKT()_CNTS[CNT]; */
 #else
 	uint64_t ring                         : 64;
 #endif
@@ -7675,7 +7740,8 @@ union cvmx_sli_pkt_time_int {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t ring                         : 64; /**< Output ring packet timer interrupt bits SLI sets RING<i> whenever
                                                          SLI_PKT()_CNTS[TIMER] > SLI_PKT()_INT_LEVELS[TIME]. SLI_PKT_TIME_INT_ENB[RING<i>] is
-                                                         the corresponding enable. */
+                                                         the corresponding enable. This field will be updated whenever there is a change
+                                                         in SLI_PKT()_CNTS[TIMER]; */
 #else
 	uint64_t ring                         : 64;
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-sso-defs.h b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
index 9a043f9..4c16b7c 100644
--- a/arch/mips/include/asm/octeon/cvmx-sso-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
@@ -3968,10 +3968,12 @@ union cvmx_sso_sl_ppx_links {
 	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t reserved_25_25               : 1;
-	uint64_t revlink_index                : 12; /**< Prior SSO entry in the tag list when HEAD==0 and TT is not UNTAGGED nor EMPTY, otherwise
+	uint64_t revlink_index                : 12; /**< Prior SSO entry in the tag list when HEAD=0 and TT is not UNTAGGED nor EMPTY, otherwise
                                                          unpredictable. */
-	uint64_t link_index_vld               : 1;  /**< LINK_INDEX is valid when TAIL==1 and TT is ATOMIC, otherwise unpredictable. */
-	uint64_t link_index                   : 12; /**< Next SSO entry in the tag list when TAILC==0 and TT is ATOMIC, otherwise unpredictable. */
+	uint64_t link_index_vld               : 1;  /**< Indicates LINK_INDEX is valid. LINK_INDEX_VLD is itself valid when TAIL=1 and TT=ATOMIC,
+                                                         otherwise unpredictable. */
+	uint64_t link_index                   : 12; /**< Next SSO entry in the tag list when LINK_INDEX_VLD=1, TAILC=0 and TT=ATOMIC,
+                                                         otherwise unpredictable. */
 #else
 	uint64_t link_index                   : 12;
 	uint64_t link_index_vld               : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
index eb8109b..2eefa07 100644
--- a/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-usbdrdx-defs.h
@@ -5528,8 +5528,8 @@ union cvmx_usbdrdx_uctl_ctl {
                                                          0 = Use the divided coprocessor clock from the H_CLKDIV divider.
                                                          1 = Use the bypass clock from the GPIO pins.
                                                          This signal is just a multiplexer-select signal; it does not enable the controller clock.
-                                                         You must still set H_CLKDIV_EN separately. H_CLK_BYP_SEL select should not be changed
-                                                         unless H_CLKDIV_EN is disabled.
+                                                         You must still set H_CLK_EN separately. H_CLK_BYP_SEL select should not be changed
+                                                         unless H_CLK_EN is disabled.
                                                          The bypass clock can be selected and running even if the controller-clock dividers are not
                                                          running.
                                                          INTERNAL: Generally bypass is only used for scan purposes. */
diff --git a/arch/mips/include/asm/octeon/octeon-model.h b/arch/mips/include/asm/octeon/octeon-model.h
index 56ac429..fb4f50a 100644
--- a/arch/mips/include/asm/octeon/octeon-model.h
+++ b/arch/mips/include/asm/octeon/octeon-model.h
@@ -43,7 +43,7 @@
  * File defining different Octeon model IDs and macros to
  * compare them.
  *
- * <hr>$Revision: 102289 $<hr>
+ * <hr>$Revision: 103698 $<hr>
  */
 
 #ifndef __OCTEON_MODEL_H__
@@ -112,6 +112,7 @@ extern "C" {
 #define OCTEON_CN71XX		OCTEON_CN70XX
 
 #define OCTEON_CN78XX_PASS1_0   0x000d9500
+#define OCTEON_CN78XX_PASS1_1   0x000d9501
 #define OCTEON_CN78XX_PASS2_0   0x000d9508
 
 #define OCTEON_CN78XX           (OCTEON_CN78XX_PASS1_0 | OM_IGNORE_REVISION)
-- 
2.6.2

