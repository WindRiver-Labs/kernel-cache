From ebb6bfcc97c19f1a2d4f878b9ff2542bd0ce22a3 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Thu, 17 Jul 2014 18:05:50 -0700
Subject: [PATCH 905/974] MIPS:OCTEON: Sync-up SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |  266 ++-
 .../cavium-octeon/executive/cvmx-helper-board.c    |  169 +-
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c |    9 +-
 arch/mips/cavium-octeon/executive/cvmx-helper.c    |   11 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |   14 +-
 .../cavium-octeon/executive/cvmx-pki-resources.c   |   28 +
 arch/mips/cavium-octeon/executive/cvmx-pki.c       |  179 +-
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |   16 +-
 arch/mips/cavium-octeon/executive/octeon-feature.c |    1 +
 arch/mips/include/asm/octeon/cvmx-dma-engine.h     |    5 +-
 arch/mips/include/asm/octeon/cvmx-dtx-defs.h       |  170 +-
 .../include/asm/octeon/cvmx-global-resources.h     |    1 +
 arch/mips/include/asm/octeon/cvmx-helper-board.h   |   48 +-
 arch/mips/include/asm/octeon/cvmx-ocx-defs.h       |   18 +-
 arch/mips/include/asm/octeon/cvmx-pexp-defs.h      | 2173 +++++++++++++++++---
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |    5 +-
 arch/mips/include/asm/octeon/cvmx-pki-resources.h  |   19 +
 arch/mips/include/asm/octeon/cvmx-pki.h            |   27 +-
 arch/mips/include/asm/octeon/cvmx-sata-defs.h      |   72 +-
 arch/mips/include/asm/octeon/cvmx-sli-defs.h       | 1951 ++++++++++++++----
 arch/mips/include/asm/octeon/octeon-feature.h      |    6 +
 21 files changed, 4318 insertions(+), 870 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 11264ce..fd8b467 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -176,6 +176,111 @@ void cvmx_helper_bgx_disable(int xipd_port)
 	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, xi.interface), cmr_config.u64);
 }
 
+static int __cvmx_helper_bgx_rgmii_speed(cvmx_helper_link_info_t link_info)
+{
+	cvmx_xcv_reset_t xcv_reset;
+	cvmx_xcv_ctl_t xcv_ctl;
+	cvmx_xcv_batch_crd_ret_t crd_ret;
+	cvmx_xcv_dll_ctl_t dll_ctl;
+	cvmx_xcv_comp_ctl_t comp_ctl;
+	int speed;
+	int up = link_info.s.link_up;
+	int do_credits;
+
+	if (link_info.s.speed == 100)
+		speed = 1;
+	else if (link_info.s.speed == 10)
+		speed = 0;
+	else
+		speed = 2;
+
+	xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
+	xcv_ctl.u64 = cvmx_read_csr(CVMX_XCV_CTL);
+	do_credits = up && !xcv_reset.s.enable;
+
+	if (up && (!xcv_reset.s.enable || (xcv_ctl.s.speed != speed))) {
+		/* Enable the XCV block */
+		xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
+		xcv_reset.s.enable = 1;
+		cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
+
+		/* Set operating mode */
+		xcv_ctl.u64 = cvmx_read_csr(CVMX_XCV_CTL);
+		xcv_ctl.s.speed = speed;
+		cvmx_write_csr(CVMX_XCV_CTL, xcv_ctl.u64);
+
+		/* Configure DLL - enable or bypass bypass */
+		dll_ctl.u64 = cvmx_read_csr(CVMX_XCV_DLL_CTL);
+		dll_ctl.s.clkrx_set = 0;
+		dll_ctl.s.clktx_set = 31;  /* FIXME */
+		dll_ctl.s.clkrx_byp = 1;
+		dll_ctl.s.clktx_byp = 1;
+		cvmx_write_csr(CVMX_XCV_DLL_CTL, dll_ctl.u64);
+
+		/* Enable */
+		dll_ctl.u64 = cvmx_read_csr(CVMX_XCV_DLL_CTL);
+		dll_ctl.s.refclk_sel = 0;
+		cvmx_write_csr(CVMX_XCV_DLL_CTL, dll_ctl.u64);
+		xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
+		xcv_reset.s.dllrst = 0;
+		cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
+
+		comp_ctl.u64 = cvmx_read_csr(CVMX_XCV_COMP_CTL);
+		//comp_ctl.s.drv_pctl = 0;
+		//comp_ctl.s.drv_nctl = 0;
+		comp_ctl.s.drv_byp = 0;
+		cvmx_write_csr(CVMX_XCV_COMP_CTL, comp_ctl.u64);
+
+		/* enable */
+		xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
+		xcv_reset.s.comp = 1;
+		cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
+
+		/* setup the RXC */
+		xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
+		xcv_reset.s.clkrst = 1;
+		cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
+
+		/* datapaths come out of the reset
+		 * - the datapath resets will disengage BGX from the RGMII
+		 *   interface
+		 * - XCV will continue to return TX credits for each tick that
+		 *   is sent on the TX data path
+		 */
+		xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
+		xcv_reset.s.tx_dat_rst_n = 1;
+		xcv_reset.s.rx_dat_rst_n = 1;
+		cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
+	}
+
+	/* enable the packet flow
+	 * - The packet resets will be only disengage on packet boundaries
+	 * - XCV will continue to return TX credits for each tick that is
+	 *   sent on the TX datapath
+	 */
+	xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
+	xcv_reset.s.tx_pkt_rst_n = up;
+	xcv_reset.s.rx_pkt_rst_n = up;
+	cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
+
+	/* Full reset when link is down */
+	if (!up) {
+		/* wait 2*MTU in time */
+		cvmx_wait_usec(10000);
+		/* reset the world */
+		cvmx_write_csr(CVMX_XCV_RESET, 0);
+	}
+
+	/* grant PKO TX credits */
+	if (do_credits) {
+		crd_ret.u64 = cvmx_read_csr(CVMX_XCV_BATCH_CRD_RET);
+		crd_ret.s.crd_ret = 1;
+		cvmx_write_csr(CVMX_XCV_BATCH_CRD_RET, crd_ret.u64);
+	}
+
+	return link_info.s.speed;
+}
+
 
 /**
  * @INTERNAL
@@ -207,57 +312,6 @@ static void __cvmx_bgx_common_init(int xiface, int index)
 
 	/* Nothing to do here, already configured by u-boot */
 	if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
-		cvmx_bgxx_cmrx_config_t cmr_config;
-		cmr_config.u64 = cvmx_read_csr(CVMX_BGXX_CMRX_CONFIG(index, xi.interface));
-		if (cmr_config.s.lmac_type == 5) {
-			cvmx_xcv_reset_t xcv_reset;
-			cvmx_xcv_ctl_t xcv_ctl;
-			cvmx_xcv_batch_crd_ret_t crd_ret;
-
-			/* Initialize the physical layer */
-			xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
-			xcv_reset.s.dllrst = 0;
-			cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
-
-			xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
-			xcv_reset.s.clkrst = 0;
-			cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
-
-			cvmx_wait(256);
-
-			xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
-			xcv_reset.s.comp = 1;
-			cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
-			xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
-
-			cvmx_wait(1024);
-
-			xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
-			xcv_reset.s.enable = 1;
-			cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
-
-			xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
-			xcv_reset.s.clkrst = 1;
-			cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
-
-			xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
-			xcv_reset.s.tx_dat_rst_n = 1;
-			xcv_reset.s.rx_dat_rst_n = 1;
-			cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
-
-			xcv_reset.u64 = cvmx_read_csr(CVMX_XCV_RESET);
-			xcv_reset.s.tx_pkt_rst_n = 1;
-			xcv_reset.s.rx_pkt_rst_n = 1;
-			cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
-
-			crd_ret.u64 = cvmx_read_csr(CVMX_XCV_BATCH_CRD_RET);
-			crd_ret.s.crd_ret = 1;
-			cvmx_write_csr(CVMX_XCV_BATCH_CRD_RET, crd_ret.u64);
-
-			xcv_ctl.u64 = cvmx_read_csr(CVMX_XCV_CTL);
-			xcv_ctl.s.speed = 2;
-			cvmx_write_csr(CVMX_XCV_CTL, xcv_ctl.u64);
-		}
 		return;
 	}
 
@@ -752,7 +806,6 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_sgmii_link_get(int xipd_port)
 	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
 	int node = xi.node;
 	int index = cvmx_helper_get_interface_index_num(xp.port);
-	int speed = 1000;
 
 	result.u64 = 0;
 
@@ -767,27 +820,37 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_sgmii_link_get(int xipd_port)
 		/* The simulator gives you a simulated 1Gbps full duplex link */
 		result.s.link_up = 1;
 		result.s.full_duplex = 1;
-		result.s.speed = speed;
+		result.s.speed = 1000;
 		return result;
 	}
 
-	speed = cvmx_qlm_get_gbaud_mhz(0) * 8 / 10;
-
 	gmp_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MRX_CONTROL(index, xi.interface));
 	if (gmp_control.s.loopbck1) {
+		int qlm = cvmx_qlm_interface(xiface);
+		int speed;
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+			speed = cvmx_qlm_get_gbaud_mhz_node(node, qlm);
+		else
+			speed = cvmx_qlm_get_gbaud_mhz(qlm);
 		/* Force 1Gbps full duplex link for internal loopback */
 		result.s.link_up = 1;
 		result.s.full_duplex = 1;
-		result.s.speed = speed;
+		result.s.speed = speed * 8 / 10;
 		return result;
 	}
 
 	gmp_misc_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, xi.interface));
 	if (gmp_misc_ctl.s.mac_phy) {
+		int qlm = cvmx_qlm_interface(xiface);
+		int speed;
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+			speed = cvmx_qlm_get_gbaud_mhz_node(node, qlm);
+		else
+			speed = cvmx_qlm_get_gbaud_mhz(qlm);
 		/* PHY Mode */
 		/* Note that this also works for 1000base-X mode */
 
-		result.s.speed = speed;
+		result.s.speed = speed * 8 / 10;
 		result.s.full_duplex = 1;
 		result.s.link_up = 1;
 		return result;
@@ -857,6 +920,7 @@ int __cvmx_helper_bgx_sgmii_link_set(int xipd_port,
 	struct cvmx_xport xp = cvmx_helper_ipd_port_to_xport(xipd_port);
 	int node = xi.node;
 	int index = cvmx_helper_get_interface_index_num(xp.port);
+	int rc = 0;
 
 	if (!cvmx_helper_is_port_valid(xiface, index))
 		return 0;
@@ -898,9 +962,15 @@ int __cvmx_helper_bgx_sgmii_link_set(int xipd_port,
 		cvmx_write_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, xi.interface),
 			       gmp_misc_ctl.u64);
 		cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, xi.interface));
+		if (index == 0 && cmr_config.s.lmac_type == 5)
+			__cvmx_helper_bgx_rgmii_speed(link_info);
 		return 0;
 	}
-	return __cvmx_helper_bgx_sgmii_hardware_init_link_speed(xiface, index, link_info);
+	rc = __cvmx_helper_bgx_sgmii_hardware_init_link_speed(xiface, index, link_info);
+	if (index == 0 && cmr_config.s.lmac_type == 5)
+		rc = __cvmx_helper_bgx_rgmii_speed(link_info);
+
+	return rc;
 }
 
 
@@ -1540,6 +1610,7 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_xaui_link_get(int xipd_port)
 	cvmx_bgxx_smux_tx_ctl_t smu_tx_ctl;
 	cvmx_bgxx_smux_rx_ctl_t smu_rx_ctl;
 	cvmx_helper_link_info_t result;
+	int total_lanes = 4;
 
 	result.u64 = 0;
 
@@ -1560,10 +1631,23 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_xaui_link_get(int xipd_port)
 		cvmx_helper_interface_mode_t mode;
 		result.s.link_up = 1;
 		result.s.full_duplex = 1;
-		speed = cvmx_qlm_get_gbaud_mhz_node(node, qlm);
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+			speed = cvmx_qlm_get_gbaud_mhz_node(node, qlm);
+		else
+			speed = cvmx_qlm_get_gbaud_mhz(qlm);
 		mode = cvmx_helper_interface_get_mode(xiface);
-		lanes = 4 / cvmx_helper_ports_on_interface(xiface);
+		if (OCTEON_IS_MODEL(OCTEON_CN73XX) && (qlm == 5 || qlm == 6)) {
+			/* In this case we might have only 2 lanes */
+			if (mode != CVMX_HELPER_INTERFACE_MODE_40G_KR4 &&
+			    mode != CVMX_HELPER_INTERFACE_MODE_XLAUI &&
+			    mode != CVMX_HELPER_INTERFACE_MODE_XAUI)
+				total_lanes = 2;
+		}
 
+		lanes = total_lanes / cvmx_helper_ports_on_interface(xiface);
+		if (debug)
+			cvmx_dprintf("%s: baud: %llu, lanes: %d\n", __func__,
+				     (unsigned long long)speed, lanes);
 		switch(mode) {
 		case CVMX_HELPER_INTERFACE_MODE_XFI:
 		case CVMX_HELPER_INTERFACE_MODE_XLAUI:
@@ -1665,7 +1749,7 @@ int __cvmx_helper_bgx_mixed_enable(int xiface)
 
 		if (!cvmx_helper_is_port_valid(xiface, index))
 			continue;
-	
+
 		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
 		xipd_port = cvmx_helper_get_ipd_port(xiface, index);
 
@@ -2354,8 +2438,8 @@ int get_num_pcs_lanes(uint8_t lmac_type)
 	return num_pcs_lanes[lmac_type];
 }
 
-/* return SerDes lanes connected to lmac - string (up to 7 chars '0,1,2,3') 
- * or up to 9 chars "RGMII/XCV" for RGMII(lmac_type=5) 
+/* return SerDes lanes connected to lmac - string (up to 7 chars '0,1,2,3')
+ * or up to 9 chars "RGMII/XCV" for RGMII(lmac_type=5)
  */
 const char * get_bind_lanes_per_lmac(uint8_t ind, uint8_t lmac_type, uint8_t lane_to_sds)
 {
@@ -2365,9 +2449,9 @@ const char * get_bind_lanes_per_lmac(uint8_t ind, uint8_t lmac_type, uint8_t lan
 	if (lmac_type > 5 || ind > 3)
 		return "  ???  ";
 	if (ind != 0 && lmac_type == 5/*RGMII*/)
-		return "ERR:RGMII";	/* Only LMAC0 can connect to RGMII/XCV */ 
+		return "ERR:RGMII";	/* Only LMAC0 can connect to RGMII/XCV */
 	if (ind == 0 && lmac_type == 5/*RGMII*/)
-		return "RGMII/XCV";	/* Only LMAC0 can connect to RGMII/XCV */ 
+		return "RGMII/XCV";	/* Only LMAC0 can connect to RGMII/XCV */
 	bind_lanes_per_lmac[ind][0] = 0;
 	for (i=0; i < get_num_pcs_lanes(lmac_type); i++) {
 		sprintf(tmp[ind], ",%1d", (lane_to_sds >> (/*2*i*/i<<1)) & 3);
@@ -2427,7 +2511,7 @@ int cvmx_helper_bgx_rgmii_config(int node, int bgx, unsigned N)
 	xcv_dll_ctl.u64 = cvmx_read_csr_node(node, CVMX_XCV_DLL_CTL);
 	xcv_comp_ctl.u64 = cvmx_read_csr_node(node, CVMX_XCV_COMP_CTL);
 	xcv_ctl.u64 = cvmx_read_csr_node(node, CVMX_XCV_CTL);
-	
+
 	cvmx_dprintf("/*=== NODE%d: BGX%d RGMII config ===*/\n", node, bgx);
 
 	PRns("RGMII: Port Enable(enable)", 1, "   %8s    ",
@@ -2446,7 +2530,7 @@ int cvmx_helper_bgx_rgmii_config(int node, int bgx, unsigned N)
 		xcv_reset.s.rx_pkt_rst_n);
 	PRn("RGMII: Datapath reset for RX(rx_dat_rst_n)", 1, "       %1d       ",
 		xcv_reset.s.rx_dat_rst_n);
-	
+
 	PRn("RGMII: The clock delay measured by DLL(clk_set)",
 		1, "      %3d      ", xcv_dll_ctl.s.clk_set);
 	PRn("RGMII: Bypass the RX clock delay(clkrx_byp)",
@@ -2458,27 +2542,27 @@ int cvmx_helper_bgx_rgmii_config(int node, int bgx, unsigned N)
 	PRn("RGMII: TX clk delay when bypass mode(clktx_set)",
 		1, "      %3d      ", xcv_dll_ctl.s.clktx_set);
 	PRns("RGMII: Reference clock to use(refclk_sel)", 1, "  %10s   ",
-		xcv_dll_ctl.s.refclk_sel == 0 ? "   RGMII   " : 
-		xcv_dll_ctl.s.refclk_sel == 1 ? " RGMII RXC " : 
+		xcv_dll_ctl.s.refclk_sel == 0 ? "   RGMII   " :
+		xcv_dll_ctl.s.refclk_sel == 1 ? " RGMII RXC " :
 		xcv_dll_ctl.s.refclk_sel == 2 ? " CopClk/N  " : " Reserved ");
 
-	PRn("RGMII: Bypass Comp.(use DRV_[P,N]CTL)(drv_byp)", 1, 
+	PRn("RGMII: Bypass Comp.(use DRV_[P,N]CTL)(drv_byp)", 1,
 		"       %1d       ", xcv_comp_ctl.s.drv_byp);
-	PRn("RGMII: Contr. PCTL drive strength(cmp_pctl)", 1, 
+	PRn("RGMII: Contr. PCTL drive strength(cmp_pctl)", 1,
 		"       %2d      ", xcv_comp_ctl.s.cmp_pctl);
-	PRn("RGMII: Contr. NCTL drive strength(cmp_nctl)", 1, 
+	PRn("RGMII: Contr. NCTL drive strength(cmp_nctl)", 1,
 		"       %2d      ", xcv_comp_ctl.s.cmp_nctl);
-	PRn("RGMII: Bypass PCTL drive strength(drv_pctl)", 1, 
+	PRn("RGMII: Bypass PCTL drive strength(drv_pctl)", 1,
 		"       %2d      ", xcv_comp_ctl.s.drv_pctl);
-	PRn("RGMII: Bypass NCTL drive strength(drv_nctl)", 1, 
+	PRn("RGMII: Bypass NCTL drive strength(drv_nctl)", 1,
 		"       %2d      ", xcv_comp_ctl.s.drv_nctl);
-	PRn("RGMII: PCTL Lock(pctl_lock)", 1, 
+	PRn("RGMII: PCTL Lock(pctl_lock)", 1,
 		"       %1d       ", xcv_comp_ctl.s.pctl_lock);
-	PRn("RGMII: PCTL Saturate(pctl_sat)", 1, 
+	PRn("RGMII: PCTL Saturate(pctl_sat)", 1,
 		"       %1d       ", xcv_comp_ctl.s.pctl_sat);
-	PRn("RGMII: NCTL Lock(nctl_lock)", 1, 
+	PRn("RGMII: NCTL Lock(nctl_lock)", 1,
 		"       %1d       ", xcv_comp_ctl.s.nctl_lock);
-	PRn("RGMII: NCTL Saturate(nctl_sat)", 1, 
+	PRn("RGMII: NCTL Saturate(nctl_sat)", 1,
 		"       %1d       ", xcv_comp_ctl.s.nctl_sat);
 
 	PRns("RGMII:XCV: External Loopback Enabled(lpbk_ext)", 1, "   %8s    ",
@@ -2496,25 +2580,25 @@ int cvmx_helper_bgx_rgmii_status(int node, int bgx, unsigned N)
 {
 	cvmx_xcv_int_t			xcv_int;
 	cvmx_xcv_inbnd_status_t		xcv_inbnd_status;
-	
+
 	xcv_int.u64 = cvmx_read_csr_node(node, CVMX_XCV_INT);
 	xcv_inbnd_status.u64 = cvmx_read_csr_node(node, CVMX_XCV_INBND_STATUS);
-	
+
 	cvmx_dprintf("/*=== NODE%d: BGX%d RGMII status ===*/\n", node, bgx);
 
-	PRd("RGMII: TX FIFO overflow(tx_ovrflw)", 1, 
+	PRd("RGMII: TX FIFO overflow(tx_ovrflw)", 1,
 		"       %1d       ", xcv_int.s.tx_ovrflw);
-	PRd("RGMII: TX FIFO underflow(tx_undflw)", 1, 
+	PRd("RGMII: TX FIFO underflow(tx_undflw)", 1,
 		"       %1d       ", xcv_int.s.tx_undflw);
-	PRd("RGMII: Incomplete byte -10/100 mode(incomp_byte)", 1, 
+	PRd("RGMII: Incomplete byte -10/100 mode(incomp_byte)", 1,
 		"       %1d       ", xcv_int.s.incomp_byte);
-	PRd("RGMII: Inband status change on link duplex", 1, 
+	PRd("RGMII: Inband status change on link duplex", 1,
 		"       %1d       ", xcv_int.s.duplex);
-	PRd("RGMII: Inband status change on link duplex", 1, 
+	PRd("RGMII: Inband status change on link duplex", 1,
 		"       %1d       ", xcv_int.s.duplex);
-	PRd("RGMII: Inband status change on link up/down", 1, 
+	PRd("RGMII: Inband status change on link up/down", 1,
 		"       %1d       ", xcv_int.s.speed);
-	
+
 	PRns("RGMII: RGMII inband status (duplex)", 1, "  %10s   ",
 		xcv_inbnd_status.s.duplex ? "Full-duplex" : "Half-duplex");
 	PRns("RGMII: RGMII inband status (speed)", 1, "   %8s    ",
@@ -3254,7 +3338,7 @@ int cvmx_dump_bgx_config_node(unsigned node, unsigned bgx)
 		        rx_flow_ctl == 3 /* bck=1 & drp=1*/ ? " HW process " :
 		        "            ");
 	}
-	
+
 	if (lmac_sgmii != 0/*SGMII/1000BASE-X*/) {
 
 		PRMns("GMP: PCS_MODE(mode)",	      lmac_sgmii, "  %10s  ",
@@ -3264,9 +3348,9 @@ int cvmx_dump_bgx_config_node(unsigned node, unsigned bgx)
 
 		PRMd("GMP: Unidirectional (overwrite ANEG)", lmac_sgmii,
 			"       %d       ", lmac[ind].gmp_pcs_mr_control.s.uni);
-		
+
 		PRMns("GMP:Duplex mode (SGMII/1000Base-X only)(duplex)", lmac_sgmii,
-			"  %11s  ", 
+			"  %11s  ",
 			lmac[ind].gmp_gmi_prt_cfg.s.duplex ? "Full-duplex" : "Half-duplex");
 #undef		spd
 #define		spd 	(lmac[ind].gmp_gmi_prt_cfg.s.speed_msb << 1 \
@@ -3277,7 +3361,7 @@ int cvmx_dump_bgx_config_node(unsigned node, unsigned bgx)
 			spd == 1 ? "1000 Mb/s" :
 			spd == 2 ? "  10 Mb/s" : "Reserved ");
 	}
-	
+
 	if (lmac_rxaui != 0/*RXAUI*/) { /*ANEG not defined for RXAUI */
 		cvmx_helper_bgx_spu_loopback(node, bgx, N);
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
index 9a60f66..7bfee97 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
@@ -105,6 +105,14 @@ static const int device_tree_dbg = 0;
 static cvmx_helper_link_info_t
 __cvmx_get_cortina_phy_link_state(cvmx_phy_info_t *phy_info);
 
+#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
+/**
+ * @INTERNAL
+ * Get link state of generic C22 compliant PHYs
+ */
+static cvmx_helper_link_info_t
+__cvmx_get_generic_8023_c22_phy_link_state(cvmx_phy_info_t *phy_info);
+
 /**
  * @INTERNAL
  * Get link state of generic C45 compliant PHYs
@@ -119,7 +127,6 @@ __get_generic_8023_c45_phy_link_state(cvmx_phy_info_t *phy_info);
 static cvmx_helper_link_info_t
 __get_marvell_phy_link_state(cvmx_phy_info_t *phy_info);
 
-#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 /**
  * @INTERNAL
  * Get link state of Aquantia PHY
@@ -423,7 +430,7 @@ static int __get_muxed_mdio_info_from_dt(cvmx_phy_info_t *phy_info,
  * @return node, interface and port number, will be -1 for invalid address.
  */
 static struct cvmx_xiface
-__cvmx_78xx_bgx_reg_addr_to_xiface(uint64_t bgx_addr)
+__cvmx_bgx_reg_addr_to_xiface(uint64_t bgx_addr)
 {
 	struct cvmx_xiface xi = {-1, -1};
 
@@ -609,6 +616,7 @@ int __cvmx_helper_78xx_parse_phy(struct cvmx_phy_info *phy_info, int ipd_port)
 	int phy_addr;
 	int index = cvmx_helper_get_interface_index_num(ipd_port);
 	int xiface = cvmx_helper_get_interface_num(ipd_port);
+	int compat_len = 0;
 
 	if (fdt_addr == NULL)
 		fdt_addr = __cvmx_phys_addr_to_ptr(cvmx_sysinfo_get()->fdt_addr,
@@ -624,21 +632,27 @@ int __cvmx_helper_78xx_parse_phy(struct cvmx_phy_info *phy_info, int ipd_port)
 		 * device tree to get the node offsets.
 		 */
 		if (device_tree_dbg)
-			cvmx_dprintf("No config present, calling __cvmx_helper_parse_78xx_bgx_dt\n");
-		if (__cvmx_helper_parse_78xx_bgx_dt(fdt_addr)) {
-			cvmx_printf("Error: could not parse 78xx BGX\n");
+			cvmx_dprintf("No config present, calling __cvmx_helper_parse_bgx_dt\n");
+		if (__cvmx_helper_parse_bgx_dt(fdt_addr)) {
+			cvmx_printf("Error: could not parse BGX device tree\n");
+			return -1;
+		}
+		if (octeon_has_feature(OCTEON_FEATURE_BGX_XCV) &&
+		    __cvmx_helper_parse_bgx_rgmii_dt(fdt_addr)) {
+			cvmx_printf("Error: could not parse BGX XCV device tree\n");
 			return -1;
 		}
 		phy = cvmx_helper_get_phy_fdt_node_offset(xiface, index);
 		if (phy < 0) {
 			if (device_tree_dbg)
-				cvmx_dprintf("%s: Could not get PHY node offset for IPD port 0x%x\n",
-					     __func__, ipd_port);
+				cvmx_dprintf("%s: Could not get PHY node offset for IPD port 0x%x, xiface: 0x%x, index: %d\n",
+					     __func__, ipd_port, xiface, index);
 			return -1;
 		}
 	}
 
-	compat = (const char *)fdt_getprop(fdt_addr, phy, "compatible", NULL);
+	compat = (const char *)fdt_getprop(fdt_addr, phy, "compatible",
+					   &compat_len);
 	if (!compat) {
 		cvmx_printf("ERROR: %d:%d:no compatible prop in phy\n", xiface, index);
 		return -1;
@@ -668,6 +682,15 @@ int __cvmx_helper_78xx_parse_phy(struct cvmx_phy_info *phy_info, int ipd_port)
 	} else if (!strcmp("vitesse,vsc8490", compat)) {
 		phy_info->phy_type = VITESSE_VSC8490_PHY;
 		phy_info->link_function = __get_vitesse_vsc8490_phy_link_state;
+	} else if (fdt_stringlist_contains(compat, compat_len,
+					   "ethernet-phy-ieee802.3-c22")) {
+		phy_info->phy_type = GENERIC_8023_C22_PHY;
+		phy_info->link_function =
+				__cvmx_get_generic_8023_c22_phy_link_state;
+	} else if (fdt_stringlist_contains(compat, compat_len,
+					   "ethernet-phy-ieee802.3-c45")) {
+		phy_info->phy_type = GENERIC_8023_C22_PHY;
+		phy_info->link_function = __get_generic_8023_c45_phy_link_state;
 	}
 
 	phy_info->ipd_port = ipd_port;
@@ -744,7 +767,7 @@ int __cvmx_helper_78xx_parse_phy(struct cvmx_phy_info *phy_info, int ipd_port)
  *
  * @return 0 for success, -1 on error.
  */
-int __cvmx_helper_parse_78xx_bgx_dt(void *fdt_addr)
+int __cvmx_helper_parse_bgx_dt(void *fdt_addr)
 {
 	int port_index;
 	int dbg = device_tree_dbg;
@@ -792,7 +815,7 @@ int __cvmx_helper_parse_78xx_bgx_dt(void *fdt_addr)
 		reg_addr = cvmx_fdt_translate_address(fdt_addr,
 						      fdt_interface_node,
 						      (uint32_t *)&reg_addr);
-		xi = __cvmx_78xx_bgx_reg_addr_to_xiface(reg_addr);
+		xi = __cvmx_bgx_reg_addr_to_xiface(reg_addr);
 		if (xi.node < 0) {
 			cvmx_dprintf("Device tree BGX node has invalid address 0x%llx\n",
 				     (unsigned long long)reg_addr);
@@ -822,7 +845,6 @@ int __cvmx_helper_parse_78xx_bgx_dt(void *fdt_addr)
 							  fdt_phy_node, NULL));
 			}
 			cvmx_helper_set_port_phy_present(xiface, port_index, true);
-
 		} else {
 			cvmx_helper_set_phy_fdt_node_offset(xiface, port_index,
 							    -1);
@@ -835,6 +857,121 @@ int __cvmx_helper_parse_78xx_bgx_dt(void *fdt_addr)
 	return 0;
 }
 
+int __cvmx_helper_parse_bgx_rgmii_dt(const void *fdt_addr)
+{
+	uint64_t reg_addr;
+	struct cvmx_xiface xi;
+	int fdt_port_node = -1;
+	int fdt_interface_node;
+	int fdt_phy_node;
+	int port_index;
+	int xiface;
+	int dbg = device_tree_dbg;
+
+	/* There's only one xcv (RGMII) interface, so just search for the one
+	 * that's part of a BGX entry.
+	 */
+	while ((fdt_port_node = fdt_node_offset_by_compatible(fdt_addr,
+							      fdt_port_node,
+							      "cavium,octeon-7360-xcv")) >= 0) {
+		fdt_interface_node = fdt_parent_offset(fdt_addr, fdt_port_node);
+		if (fdt_interface_node < 0) {
+			cvmx_printf("Error: device tree corrupt!\n");
+			return -1;
+		}
+		if (dbg)
+			cvmx_dprintf("%s: XCV parent node compatible: %s\n",
+				     __func__,
+				     (char *)fdt_getprop(fdt_addr,
+							 fdt_interface_node,
+							 "compatible", NULL));
+		if (!fdt_node_check_compatible(fdt_addr, fdt_interface_node,
+					       "cavium,octeon-7890-bgx"))
+			break;
+	}
+	if (fdt_port_node == -FDT_ERR_NOTFOUND) {
+		if (dbg)
+			cvmx_dprintf("No XCV/RGMII interface found in device tree\n");
+		return 0;
+	} else if (fdt_port_node < 0) {
+		cvmx_dprintf("%s: Error %d parsing device tree\n",
+			     __func__, fdt_port_node);
+		return -1;
+	}
+	if (dbg) {
+		char path[256];
+		if (!fdt_get_path(fdt_addr, fdt_port_node, path, sizeof(path))) {
+			cvmx_dprintf("xcv path: %s\n", path);
+		}
+		if (!fdt_get_path(fdt_addr, fdt_interface_node, path,
+				  sizeof(path))) {
+			cvmx_dprintf("interface path: %s\n", path);
+		}
+	}
+	port_index = cvmx_fdt_get_int(fdt_addr, fdt_port_node, "reg", -1);
+	if (port_index != 0) {
+		cvmx_printf("%s: Error: port index (reg) must be 0, not %d.\n",
+			    __func__, port_index);
+		return -1;
+	}
+	reg_addr = cvmx_fdt_get_addr(fdt_addr, fdt_interface_node, "reg");
+	if (reg_addr == FDT_ADDR_T_NONE) {
+		cvmx_printf("%s: Error: could not get BGX interface address\n",
+			    __func__);
+		return -1;
+	}
+	/* We don't have to bother translating since only 78xx supports OCX and
+	 * doesn't support RGMII.
+	 */
+	xi = __cvmx_bgx_reg_addr_to_xiface(reg_addr);
+	if (dbg)
+		cvmx_dprintf("%s: xi.node: %d, xi.interface: 0x%x, addr: 0x%llx\n", __func__,
+			     xi.node, xi.interface,
+			     (unsigned long long)reg_addr);
+	if (xi.node < 0) {
+		cvmx_printf("%s: Device tree BGX node has invalid address 0x%llx\n",
+			    __func__, (unsigned long long)reg_addr);
+		return -1;
+	}
+	if (dbg) {
+		cvmx_dprintf("%s: Found XCV (RGMII) interface on interface %d\n",
+			     __func__, xi.interface);
+		cvmx_dprintf("  phy handle: 0x%x\n",
+			     cvmx_fdt_get_int(fdt_addr, fdt_port_node,
+					      "phy-handle", -1));
+	}
+	fdt_phy_node = cvmx_fdt_lookup_phandle(fdt_addr, fdt_port_node,
+					       "phy-handle");
+	if (dbg)
+		cvmx_dprintf("%s: phy-handle node: 0x%x\n", __func__,
+			     fdt_phy_node);
+	xiface = cvmx_helper_node_interface_to_xiface(xi.node, xi.interface);
+
+	cvmx_helper_set_port_fdt_node_offset(xiface, port_index,
+					     fdt_port_node);
+	if (fdt_phy_node >= 0) {
+		if (dbg) {
+			cvmx_dprintf("%s: Setting PHY fdt node offset for interface 0x%x, port %d to %d\n",
+				     __func__, xiface, port_index,
+				     fdt_phy_node);
+			cvmx_dprintf("%s: PHY node name: %s\n",
+				     __func__,
+				     fdt_get_name(fdt_addr,
+						  fdt_phy_node, NULL));
+		}
+		cvmx_helper_set_phy_fdt_node_offset(xiface, port_index,
+						    fdt_phy_node);
+		cvmx_helper_set_port_phy_present(xiface, port_index, true);
+	} else {
+		cvmx_helper_set_phy_fdt_node_offset(xiface, port_index, -1);
+		if (dbg)
+			cvmx_dprintf("%s: No PHY fdt node offset for interface 0x%x, port %d to %d\n",
+				     __func__, xiface, port_index, fdt_phy_node);
+		cvmx_helper_set_port_phy_present(xiface, port_index, false);
+	}
+	return 0;
+}
+
 /**
  * Returns if a port is present on an interface
  *
@@ -863,9 +1000,12 @@ int __cvmx_helper_board_get_port_from_dt(void *fdt_addr, int ipd_port)
 		port_index = cvmx_helper_get_interface_index_num(ipd_port);
 
 		if (!fdt_ports_initialized) {
-			if (!__cvmx_helper_parse_78xx_bgx_dt(fdt_addr))
+			if (octeon_has_feature(OCTEON_FEATURE_BGX_XCV))
+				if (!__cvmx_helper_parse_bgx_rgmii_dt(fdt_addr))
+					fdt_ports_initialized = 1;
+			if (!__cvmx_helper_parse_bgx_dt(fdt_addr)) {
 				fdt_ports_initialized = 1;
-			else {
+			} else {
 				cvmx_dprintf("%s: Error parsing FDT\n",
 					     __func__);
 				return -1;
@@ -2257,9 +2397,9 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 			case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 			case CVMX_HELPER_INTERFACE_MODE_XAUI:
 			case CVMX_HELPER_INTERFACE_MODE_10G_KR:
+			case CVMX_HELPER_INTERFACE_MODE_XFI:
 				result.s.speed = 10000;
 				break;
-			case CVMX_HELPER_INTERFACE_MODE_XFI:
 			case CVMX_HELPER_INTERFACE_MODE_XLAUI:
 			case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
 				result.s.speed = 40000;
@@ -2267,7 +2407,6 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 			default:
 				break;
 			}
-
 			return result;
 		}
 		phy_info = cvmx_helper_get_port_phy_info(xiface, index);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index ae1b70d..bb634ba 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -907,12 +907,17 @@ int __cvmx_helper_init_port_valid(void)
 	int i, j, n;
 	bool valid;
 	static void *fdt_addr = 0;
+	int rc;
 
 	if (fdt_addr == 0)
 		fdt_addr = __cvmx_phys_addr_to_ptr(cvmx_sysinfo_get()->fdt_addr,
 						   (128*1024));
-	if (octeon_has_feature(OCTEON_FEATURE_BGX))
-		return __cvmx_helper_parse_78xx_bgx_dt(fdt_addr);
+	if (octeon_has_feature(OCTEON_FEATURE_BGX)) {
+		rc = __cvmx_helper_parse_bgx_dt(fdt_addr);
+		if (!rc && octeon_has_feature(OCTEON_FEATURE_BGX_XCV))
+			rc = __cvmx_helper_parse_bgx_rgmii_dt(fdt_addr);
+		return rc;
+	}
 
 	/* TODO: Update this to behave more like 78XX */
 	for (i = 0; i < cvmx_helper_get_number_of_interfaces(); i++) {
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper.c b/arch/mips/cavium-octeon/executive/cvmx-helper.c
index b56104c..ba11d5d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper.c
@@ -843,7 +843,7 @@ static cvmx_helper_interface_mode_t __cvmx_get_mode_cn78xx(int xiface)
 				if (qlm_mode == CVMX_QLM_MODE_ILK)
 					found++;
 			}
-			if (found == 2)	
+			if (found == 2)
 				iface_node_ops[xi.node][intf] = &iface_ops_ilk;
 			else
 				iface_node_ops[xi.node][intf] = &iface_ops_dis;
@@ -855,7 +855,7 @@ static cvmx_helper_interface_mode_t __cvmx_get_mode_cn78xx(int xiface)
 				if (qlm_mode == CVMX_QLM_MODE_ILK)
 					found++;
 			}
-			if (found == 3)	
+			if (found == 3)
 				iface_node_ops[xi.node][intf] = &iface_ops_ilk;
 			else
 				iface_node_ops[xi.node][intf] = &iface_ops_dis;
@@ -867,7 +867,7 @@ static cvmx_helper_interface_mode_t __cvmx_get_mode_cn78xx(int xiface)
 				if (qlm_mode == CVMX_QLM_MODE_ILK)
 					found++;
 			}
-			if (found == 2)	
+			if (found == 2)
 				iface_node_ops[xi.node][intf] = &iface_ops_ilk;
 			else
 				iface_node_ops[xi.node][intf] = &iface_ops_dis;
@@ -900,7 +900,7 @@ static cvmx_helper_interface_mode_t __cvmx_get_mode_cn78xx(int xiface)
 				if (qlm_mode == CVMX_QLM_MODE_ILK)
 					found++;
 			}
-			if (found == 3)	
+			if (found == 3)
 				iface_node_ops[xi.node][intf] = &iface_ops_ilk;
 			else
 				iface_node_ops[xi.node][intf] = &iface_ops_dis;
@@ -1553,7 +1553,7 @@ static int __cvmx_helper_global_setup_backpressure(int node)
 		int num_interfaces = cvmx_helper_get_number_of_interfaces();
 		int interface;
 		for (interface = 0; interface < num_interfaces; interface++) {
-			int xiface = cvmx_helper_node_interface_to_xiface(node, interface);	
+			int xiface = cvmx_helper_node_interface_to_xiface(node, interface);
 			switch (cvmx_helper_interface_get_mode(xiface)) {
 			case CVMX_HELPER_INTERFACE_MODE_DISABLED:
 			case CVMX_HELPER_INTERFACE_MODE_PCIE:
@@ -1751,7 +1751,6 @@ int cvmx_helper_ipd_and_packet_input_enable_node(int node)
 
 	if (octeon_has_feature(OCTEON_FEATURE_PKI)) {
 		cvmx_helper_pki_enable(node);
-
 	} else
 		/* Enable IPD */
 		cvmx_ipd_enable();
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index 52caee3..bbb5bff 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 121092 $<hr>
+ * <hr>$Revision: 121833 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1452,7 +1452,7 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		}
 	}
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
 		CVMX_WRITE_CSR(CVMX_DTX_PEMX_SELX(0, pcie_port), 0x17);
 		CVMX_WRITE_CSR(CVMX_DTX_PEMX_SELX(1, pcie_port), 0);
 	}
@@ -1461,6 +1461,16 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		cvmx_printf("%d:PCIe: Port %d in endpoint mode.\n", node, pcie_port);
 		return -1;
 	}
+
+	/* No need to re-initialize if PCIe is already initialized */
+	if (OCTEON_IS_OCTEON3() && mio_rst_ctl.s.rst_done) {
+		pciercx_cfg032.u32 = CVMX_PCIE_CFGX_READ(pcie_port,
+						CVMX_PCIERCX_CFG032(pcie_port));
+		cvmx_printf("%d:PCIe: Port %d link active, %d lanes, speed gen%d\n",
+			node, pcie_port, pciercx_cfg032.s.nlw, pciercx_cfg032.s.ls);
+		return 0;
+	}
+	
 #if 0
 	/* Enable this code to force PCIe link for x1 lane card. */
 	__cvmx_qlm_pcie_cfg_rxd_set_tweak(qlm, 0);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pki-resources.c b/arch/mips/cavium-octeon/executive/cvmx-pki-resources.c
index 93efb29..78d64d0 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pki-resources.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pki-resources.c
@@ -493,3 +493,31 @@ int cvmx_pki_bpid_free(int node, int bpid)
 	return 0;
 }
 
+int cvmx_pki_mtag_idx_alloc(int node, int idx)
+{
+	if (cvmx_create_global_resource_range(CVMX_GR_TAG_MTAG_IDX(node), CVMX_PKI_NUM_MTAG_IDX)) {
+		cvmx_printf("ERROR: Failed to create MTAG-IDX global resource\n");
+		return -1;
+	}
+	if (idx >= 0) {
+		idx = cvmx_reserve_global_resource_range(CVMX_GR_TAG_MTAG_IDX(node), idx, idx, 1);
+		if (idx == -1) {
+			cvmx_dprintf("INFO: MTAG index %d is already reserved\n", (int)idx);
+			return CVMX_RESOURCE_ALREADY_RESERVED;
+		}
+	} else {
+		idx = cvmx_allocate_global_resource_range(CVMX_GR_TAG_MTAG_IDX(node), idx, 1, 1);
+		if (idx == -1) {
+			cvmx_printf("ERROR: Failed to allocate MTAG index\n");
+			return CVMX_RESOURCE_ALLOC_FAILED;
+		}
+	}
+	return idx;
+}
+
+void cvmx_pki_mtag_idx_free(int node, int idx)
+{
+	if (cvmx_free_global_resource_range_with_base(CVMX_GR_TAG_MTAG_IDX(node), idx, 1) == -1)
+		cvmx_printf("ERROR Failed to release MTAG index %d\n", (int)idx);
+}
+
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pki.c b/arch/mips/cavium-octeon/executive/cvmx-pki.c
index eb40e3d..a7233f9 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pki.c
@@ -49,6 +49,7 @@
 #include <asm/octeon/cvmx-pki.h>
 #include <asm/octeon/cvmx-fpa3.h>
 #include <asm/octeon/cvmx-pki-cluster.h>
+#include <asm/octeon/cvmx-pki-resources.h>
 #else
 #include "cvmx.h"
 #include "cvmx-version.h"
@@ -57,6 +58,7 @@
 #include "cvmx-pki.h"
 #include "cvmx-fpa3.h"
 #include "cvmx-pki-cluster.h"
+#include "cvmx-pki-resources.h"
 #endif
 
 
@@ -375,7 +377,9 @@ int cvmx_pki_write_pkind_config(int node, int pkind, struct cvmx_pki_pkind_confi
 	return 0;
 }
 
- /** This function reads parameters associated with tag configuration in hardware.
+ /**
+ * This function reads parameters associated with tag configuration in hardware.
+ * Only first cluster in the group is used.
  * @param node		node number.
  * @param style		style to configure tag for
  * @param cluster_mask	Mask of clusters to configure the style for.
@@ -384,15 +388,18 @@ int cvmx_pki_write_pkind_config(int node, int pkind, struct cvmx_pki_pkind_confi
 void cvmx_pki_read_tag_config(int node, int style, uint64_t cluster_mask,
 	struct cvmx_pki_style_tag_cfg *tag_cfg)
 {
+	int mask, tag_idx, index;
 	cvmx_pki_clx_stylex_cfg2_t style_cfg2_reg;
 	cvmx_pki_clx_stylex_alg_t style_alg_reg;
+	cvmx_pki_stylex_tag_sel_t tag_sel;
+	cvmx_pki_tag_incx_ctl_t tag_ctl;
+	cvmx_pki_tag_incx_mask_t tag_mask;
 	int cluster = __builtin_ffsll(cluster_mask) - 1;
 
-	style_cfg2_reg.u64 = cvmx_read_csr_node(node,
-		CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
-	style_alg_reg.u64 = cvmx_read_csr_node(node,
-		CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
+	style_cfg2_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
+	style_alg_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
 
+	/* 7-Tuple Tag: */
 	tag_cfg->tag_fields.layer_g_src = style_cfg2_reg.s.tag_src_lg;
 	tag_cfg->tag_fields.layer_f_src = style_cfg2_reg.s.tag_src_lf;
 	tag_cfg->tag_fields.layer_e_src = style_cfg2_reg.s.tag_src_le;
@@ -415,10 +422,29 @@ void cvmx_pki_read_tag_config(int node, int style, uint64_t cluster_mask,
 	tag_cfg->tag_fields.mpls_label = style_alg_reg.s.tag_mpls0;
 	tag_cfg->tag_fields.input_port = style_alg_reg.s.tag_prt;
 
-	/** TO_DO get mask tag*/
+	/* Custom-Mask Tag: */
+	tag_sel.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_TAG_SEL(style));
+	for (mask = 0; mask < 4; mask++) {
+		tag_cfg->mask_tag[mask].enable |= (style_cfg2_reg.s.tag_inc & (1 << mask)) != 0;
+		switch (mask) {
+		case 0: tag_idx = tag_sel.s.tag_idx0; break;
+		case 1: tag_idx = tag_sel.s.tag_idx1; break;
+		case 2: tag_idx = tag_sel.s.tag_idx2; break;
+		case 3: tag_idx = tag_sel.s.tag_idx3; break;
+		}
+		index = tag_idx * 4 + mask;
+		tag_mask.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_INCX_MASK(index));
+		tag_cfg->mask_tag[mask].val = tag_mask.s.en;
+ 		tag_ctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_INCX_CTL(index));
+		tag_cfg->mask_tag[mask].base = tag_ctl.s.ptr_sel;
+		tag_cfg->mask_tag[mask].offset = tag_ctl.s.offset;
+	}
 }
 
- /** This function writes/configures parameters associated with tag configuration in hardware.
+ /**
+ * This function writes/configures parameters associated with tag configuration in hardware.
+ * In Custom-Mask Tagging, all four masks use the same base index to access Tag Control and
+ * Tag Mask registers.
  * @param node	              node number.
  * @param style		      style to configure tag for
  * @param cluster_mask	      Mask of clusters to configure the style for.
@@ -427,12 +453,17 @@ void cvmx_pki_read_tag_config(int node, int style, uint64_t cluster_mask,
 void cvmx_pki_write_tag_config(int node, int style, uint64_t cluster_mask,
 			       struct cvmx_pki_style_tag_cfg *tag_cfg)
 {
+	int mask, index, tag_idx, mtag_en = 0;
+	unsigned cluster = 0;
 	cvmx_pki_clx_stylex_cfg2_t style_cfg2_reg;
 	cvmx_pki_clx_stylex_alg_t style_alg_reg;
-	unsigned cluster = 0;
+	cvmx_pki_tag_incx_ctl_t tag_ctl;
+	cvmx_pki_tag_incx_mask_t tag_mask;
+	cvmx_pki_stylex_tag_sel_t tag_sel;
 
 	while (cluster < CVMX_PKI_NUM_CLUSTER) {
 		if (cluster_mask & (0x01L << cluster)) {
+			/* 7-Tuple Tag: */
 			style_cfg2_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
 			style_cfg2_reg.s.tag_src_lg = tag_cfg->tag_fields.layer_g_src;
 			style_cfg2_reg.s.tag_src_lf = tag_cfg->tag_fields.layer_f_src;
@@ -446,11 +477,9 @@ void cvmx_pki_write_tag_config(int node, int style, uint64_t cluster_mask,
 			style_cfg2_reg.s.tag_dst_ld = tag_cfg->tag_fields.layer_d_dst;
 			style_cfg2_reg.s.tag_dst_lc = tag_cfg->tag_fields.layer_c_dst;
 			style_cfg2_reg.s.tag_dst_lb = tag_cfg->tag_fields.layer_b_dst;
-			cvmx_write_csr_node(node,
-				CVMX_PKI_CLX_STYLEX_CFG2(style, cluster),
-				style_cfg2_reg.u64);
-			style_alg_reg.u64 = cvmx_read_csr_node(node,
-				CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
+			cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster), style_cfg2_reg.u64);
+
+			style_alg_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster));
 			style_alg_reg.s.tag_vni = tag_cfg->tag_fields.tag_vni;
 			style_alg_reg.s.tag_gtp = tag_cfg->tag_fields.tag_gtp;
 			style_alg_reg.s.tag_spi = tag_cfg->tag_fields.tag_spi;
@@ -462,10 +491,50 @@ void cvmx_pki_write_tag_config(int node, int style, uint64_t cluster_mask,
 			style_alg_reg.s.tag_prt = tag_cfg->tag_fields.input_port;
 			cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_ALG(style, cluster), style_alg_reg.u64);
 
-			/* TO_DO add mask tag */
+			/* Custom-Mask Tag (Part 1): */
+			for (mask = 0; mask < 4; mask++) {
+				if (tag_cfg->mask_tag[mask].enable)
+					mtag_en++;
+			}
+			if (mtag_en) {
+				style_cfg2_reg.u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster));
+				style_cfg2_reg.s.tag_inc = 0;
+				for (mask = 0; mask < 4; mask++) {
+					if (tag_cfg->mask_tag[mask].enable)
+						style_cfg2_reg.s.tag_inc |= 1 << mask;
+				}
+				cvmx_write_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG2(style, cluster), style_cfg2_reg.u64);
+			}
 		}
 		cluster++;
 	}
+	/* Custom-Mask Tag (Part 2): */
+	if (mtag_en) {
+		if ((tag_idx = cvmx_pki_mtag_idx_alloc(node, -1)) < 0)
+			return;
+
+		tag_sel.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_TAG_SEL(style));
+		for (mask = 0; mask < 4; mask++) {
+			if (tag_cfg->mask_tag[mask].enable) {
+				switch (mask) {
+				case 0: tag_sel.s.tag_idx0 = tag_idx; break;
+				case 1: tag_sel.s.tag_idx1 = tag_idx; break;
+				case 2: tag_sel.s.tag_idx2 = tag_idx; break;
+				case 3: tag_sel.s.tag_idx3 = tag_idx; break;
+				}
+				index = tag_idx * 4 + mask;
+				tag_mask.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_INCX_MASK(index));
+				tag_mask.s.en = tag_cfg->mask_tag[mask].val;
+				cvmx_write_csr_node(node, CVMX_PKI_TAG_INCX_MASK(index), tag_mask.u64);
+
+   				tag_ctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_INCX_CTL(index));
+				tag_ctl.s.ptr_sel = tag_cfg->mask_tag[mask].base;
+				tag_ctl.s.offset = tag_cfg->mask_tag[mask].offset;
+				cvmx_write_csr_node(node, CVMX_PKI_TAG_INCX_CTL(index), tag_ctl.u64);
+			}
+		}
+		cvmx_write_csr_node(node, CVMX_PKI_STYLEX_TAG_SEL(style), tag_sel.u64);
+	}
 }
 
 /**
@@ -1207,6 +1276,24 @@ int cvmx_pki_config_dump(unsigned node)
 		[0x2] = "Untagged",
 		[0x3] = "Empty"
 	};
+	char *mtagptr_map[16] = {
+		[0]  = "SOP",
+		[1]  = "Undef",
+		[2]  = "Undef",
+		[3]  = "Undef",
+		[4]  = "Undef",
+		[5]  = "Undef",
+		[6]  = "Undef",
+		[7]  = "Undef",
+		[8]  = "LA",
+		[9]  = "LB",
+		[10] = "LC",
+		[11] = "LD",
+		[12] = "LE",
+		[13] = "LF",
+		[14] = "LG",
+		[15] = "VL"
+	};
 	int nclusters = CVMX_PKI_NUM_CLUSTER;
 	cvmx_pki_tag_secret_t secret;
 	cvmx_pki_buf_ctl_t ctl;
@@ -1282,10 +1369,11 @@ int cvmx_pki_config_dump(unsigned node)
 		ibase = pkind;
         
 		DLMPRINT("PKIND %02d:", pkind);
+		NSPRINT(nclusters, __i, sprintf(lines[__i], "Cluster%d", __i));
+		NMPRINT(nclusters, mask, __i, 0, "", "%*s", lines[__i]);
 		cvmx_printf("Mapping:\n");
 		printfl(1, "Cluster Group", "%*d", PKI_PRN_DATALEN, cgsel.s.icg);
-		NSPRINT(nclusters, __i, sprintf(lines[__i], "Cluster%d", __i));
-		NMPRINT(nclusters, mask, __i, 0, "Parsing:", "%*s", lines[__i]);
+		cvmx_printf("Parsing:\n");
 		NMPRINT(nclusters, mask, __i, 1, "Initial Style", "%*d", pkstyle[__i].s.style);
 		NSPRINT(nclusters, __i, sprintf(lines[__i], "%c%c%c%c%c%c%c",
 			(pkstyle[__i].s.pm & (1 << 0)) ? '-' : 'A', (pkstyle[__i].s.pm & (1 << 1)) ? '-' : 'B',
@@ -1323,6 +1411,8 @@ int cvmx_pki_config_dump(unsigned node)
 	/* Show Styles.*/
 	for (style = 0, pcrc32 = 0, ibase = 0; style < CVMX_PKI_NUM_FINAL_STYLE; style++) {
 		cvmx_pki_stylex_buf_t stbuf;
+		cvmx_pki_stylex_tag_sel_t tagsel;
+		cvmx_pki_stylex_tag_mask_t tagmask;
 		cvmx_pki_clx_stylex_cfg_t stcfg[CVMX_PKI_NUM_CLUSTER];
 		cvmx_pki_clx_stylex_cfg2_t stcfg2[CVMX_PKI_NUM_CLUSTER];
 		cvmx_pki_clx_stylex_alg_t stalg[CVMX_PKI_NUM_CLUSTER];
@@ -1331,6 +1421,10 @@ int cvmx_pki_config_dump(unsigned node)
 		CVMX_MT_CRC_IV(0xffffffff);
 		stbuf.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_BUF(style));
 		CVMX_MT_CRC_DWORD(stbuf.u64 & ((1ull << 33) - 1));
+		tagsel.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_TAG_SEL(style));
+		CVMX_MT_CRC_DWORD(tagsel.u64 & (0x7ull << 24 | 0x7ull << 16 | 0x7ull << 8 | 0x7ull));
+		tagmask.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_TAG_MASK(style));
+		CVMX_MT_CRC_DWORD(tagmask.u64 & ((1ull << 16) - 1));
 		mask = 0;
 		for (cluster = 0; cluster < nclusters; cluster++) {
 			stcfg[cluster].u64 = cvmx_read_csr_node(node, CVMX_PKI_CLX_STYLEX_CFG(style, cluster));
@@ -1350,6 +1444,8 @@ int cvmx_pki_config_dump(unsigned node)
 		ibase = style;
 
 		DLMPRINT("STYLE %02d:", style);
+		NSPRINT(nclusters, __i, sprintf(lines[__i], "Cluster%d", __i));
+		NMPRINT(nclusters, mask, __i, 0, "", "%*s", lines[__i]);
 		cvmx_printf("Buffering:\n");
 		stbuf.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_BUF(style));
 		printfl(1, "WQE header", "%s", stbuf.s.wqe_hsz ? "WORD0..5" : "WORD0..4");
@@ -1358,32 +1454,6 @@ int cvmx_pki_config_dump(unsigned node)
 		printfl(1, "First Skip", "%d", stbuf.s.first_skip);
 		printfl(1, "Later Skip", "%d", stbuf.s.later_skip);
 		printfl(1, "OPC Mode", "%d", stbuf.s.opc_mode);
-		if (NMCMPEQ(0, stcfg2[__i].s.tag_masken, 4, mask, __i) != 0) {
-			cvmx_pki_stylex_tag_mask_t sttmask;
-			sttmask.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_TAG_MASK(style));
-			printfl(0, "Tag Mask (hex)", "%*x", PKI_PRN_DATALEN, sttmask.s.mask);
-		}
-		if (NMCMPEQ(0, stcfg2[__i].s.tag_inc, 4, mask, __i) != 0) {
-			cvmx_pki_stylex_tag_sel_t tagsel;
-			cvmx_pki_tag_incx_ctl_t tagctl;
-			cvmx_pki_tag_incx_mask_t tagmask;
-			int tagx;
-			tagsel.u64 = cvmx_read_csr_node(node, CVMX_PKI_STYLEX_TAG_SEL(style));
-			for (i = 0; i < 4; i++) {
-				switch (i) {
-				case 0: tagx = tagsel.s.tag_idx0 * 4 + 0; break;
-				case 1: tagx = tagsel.s.tag_idx1 * 4 + 1; break;
-				case 2: tagx = tagsel.s.tag_idx2 * 4 + 2; break;
-				case 3: tagx = tagsel.s.tag_idx3 * 4 + 3; break;
-				}
-				tagctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_INCX_CTL(tagx));
-				tagmask.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_INCX_MASK(tagx));
-				sprintf(lines[0], "C-Tag%d = Ptr:Offs:Mask", i);
-				printfl(0, lines[0], "%d:%d:%llx", tagctl.s.ptr_sel, tagctl.s.offset, tagmask.s.en);
-			}
-		}
-		NSPRINT(nclusters, __i, sprintf(lines[__i], "Cluster%d", __i));
-		NMPRINT(nclusters, mask, __i, 0, "", "%*s", lines[__i]);
 		NMPRINT(nclusters, mask, __i, 0, "Strip FCS", "%*s", stcfg[__i].s.fcs_strip ? "Yes":"No");
 		NMPRINT(nclusters, mask, __i, 0, "Drop", "%*d", stcfg[__i].s.drop);
 		NMPRINT(nclusters, mask, __i, 0, "No Drop", "%*d", stcfg[__i].s.nodrop);
@@ -1406,8 +1476,29 @@ int cvmx_pki_config_dump(unsigned node)
 			NMPRINT(nclusters, mask, __i, 1, "T-Tag <= VLAN1", "%*s", stalg[__i].s.tag_vs1 ? "On":"Off");
 		if (NMCMPEQ(0, stalg[__i].s.tag_prt, 4, mask, __i) != 0)
 			NMPRINT(nclusters, mask, __i, 1, "T-Tag <= Port", "%*s", stalg[__i].s.tag_prt ? "On":"Off");
-		if (NMCMPEQ(0, stcfg2[__i].s.tag_inc, 4, mask, __i) != 0)
-			NMPRINT(nclusters, mask, __i, 1, "C-Tag Mask (hex)", "%*x", stcfg2[__i].s.tag_inc);
+		if (NMCMPEQ(0, stcfg2[__i].s.tag_inc, 4, mask, __i) != 0) {
+			cvmx_pki_tag_incx_ctl_t tagctl;
+			cvmx_pki_tag_incx_mask_t incmask;
+			int tagx, clx = __builtin_ffsll(mask) - 1;
+			cvmx_printf("%*s%s\n", 2, "", "M-Tag = Base:Offset:Mask (name:dec:hex)");
+			for (i = 0; i < 4; i++) {
+				if ((stcfg2[clx].s.tag_inc & (1 << i)) == 0)
+					continue;
+				switch (i) {
+				case 0: tagx = tagsel.s.tag_idx0 * 4 + 0; break;
+				case 1: tagx = tagsel.s.tag_idx1 * 4 + 1; break;
+				case 2: tagx = tagsel.s.tag_idx2 * 4 + 2; break;
+				case 3: tagx = tagsel.s.tag_idx3 * 4 + 3; break;
+				}
+				tagctl.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_INCX_CTL(tagx));
+				incmask.u64 = cvmx_read_csr_node(node, CVMX_PKI_TAG_INCX_MASK(tagx));
+				sprintf(lines[0], "M-Tag%d", i);
+				printfl(2, lines[0], "%s:%d:%016llx", mtagptr_map[tagctl.s.ptr_sel], tagctl.s.offset, incmask.s.en);
+			}
+		}
+		if (NMCMPEQ(0, stcfg2[__i].s.tag_masken, 4, mask, __i) != 0) {
+			printfl(1, "Tag Mask (hex)", "%*x", PKI_PRN_DATALEN, tagmask.s.mask);
+		}
 		cvmx_printf("QPG:\n");
 		NMPRINT(nclusters, mask, __i, 1, "QOS Algo", "%*s", qpgqos_map[stalg[__i].s.qpg_qos]);
 		NMPRINT(nclusters, mask, __i, 1, "QPG Base (dec)", "%*d", stcfg[__i].s.qpg_base);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index c8cf9ef..b23c31d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 121402 $<hr>
+ * <hr>$Revision: 121623 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1646,7 +1646,17 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 			break;
 		case 0x2:
 			if (mux == 2)
-				qlm_mode[qlm] = CVMX_QLM_MODE_RXAUI_1X2;
+				qlm_mode[qlm] = CVMX_QLM_MODE_RXAUI_1X2; // NONE+RXAUI
+			else if (mux == 0)
+				qlm_mode[qlm] = CVMX_QLM_MODE_MIXED; // RXAUI+SGMII
+			else
+				qlm_mode[qlm] = CVMX_QLM_MODE_DISABLED;
+			break;
+		case 0x202:
+			if (mux == 2 || mux == 1)
+				qlm_mode[qlm] = CVMX_QLM_MODE_RXAUI_1X2; // RXAUI+RXAUI
+			else if (mux == 0)
+				qlm_mode[qlm] = CVMX_QLM_MODE_RXAUI;
 			else
 				qlm_mode[qlm] = CVMX_QLM_MODE_DISABLED;
 			break;
@@ -1690,6 +1700,8 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cn73xx(int qlm)
 			break;
 
 		case 0x200:
+			if (mux == 2)
+				qlm_mode[qlm] = CVMX_QLM_MODE_RXAUI_1X2;
 		case 0x205:
 		case 0x233:
 		case 0x3305:
diff --git a/arch/mips/cavium-octeon/executive/octeon-feature.c b/arch/mips/cavium-octeon/executive/octeon-feature.c
index 6e70280..00bf736 100644
--- a/arch/mips/cavium-octeon/executive/octeon-feature.c
+++ b/arch/mips/cavium-octeon/executive/octeon-feature.c
@@ -143,6 +143,7 @@ void __init octeon_feature_init(void)
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_HNA);
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_BGX);
 	OCTEON_FEATURE_SET(OCTEON_FEATURE_BGX_MIX);
+	OCTEON_FEATURE_SET(OCTEON_FEATURE_BGX_XCV);
 	val = OCTEON_FEATURE_SUCCESS;
 
 feature_check:
diff --git a/arch/mips/include/asm/octeon/cvmx-dma-engine.h b/arch/mips/include/asm/octeon/cvmx-dma-engine.h
index 7b52ad6..794e6d2 100644
--- a/arch/mips/include/asm/octeon/cvmx-dma-engine.h
+++ b/arch/mips/include/asm/octeon/cvmx-dma-engine.h
@@ -43,7 +43,7 @@
  * Interface to the PCI / PCIe DMA engines. These are only avialable
  * on chips with PCI / PCIe.
  *
- * <hr>$Revision: 112023 $<hr>
+ * <hr>$Revision: 121436 $<hr>
  */
 
 #ifndef __CVMX_DMA_ENGINES_H__
@@ -279,7 +279,8 @@ typedef union {
                                                 components, and the number of 64-bit words required in the FIRST POINTERS
                                                 area is:
                                                     - HDR.NFST + ((HDR.NFST + 3)/4) where the division removes the fraction. */
-		uint64_t reserved_28_31:4;
+		uint64_t pvfe:1;            /**< Function Enable. */
+		uint64_t reserved_28_30:3;
 		uint64_t grp:10;	    /**< GRP  Group. */
 		uint64_t tt:2;		    /**< TT  SSO Tag Type. Sent to SSO upon instruction completion if
 						PT == DPI_HDR_PT_WQP. */
diff --git a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
index 8541b37..0b35f48 100644
--- a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
@@ -2210,6 +2210,61 @@ static inline uint64_t CVMX_DTX_MIO_SELX(unsigned long offset)
 #define CVMX_DTX_MIO_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE000000ull) + ((offset) & 1) * 8)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_OCX_BOT_BCST_RSP CVMX_DTX_OCX_BOT_BCST_RSP_FUNC()
+static inline uint64_t CVMX_DTX_OCX_BOT_BCST_RSP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_OCX_BOT_BCST_RSP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE198080ull);
+}
+#else
+#define CVMX_DTX_OCX_BOT_BCST_RSP (CVMX_ADD_IO_SEG(0x00011800FE198080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DTX_OCX_BOT_CTL CVMX_DTX_OCX_BOT_CTL_FUNC()
+static inline uint64_t CVMX_DTX_OCX_BOT_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DTX_OCX_BOT_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800FE198060ull);
+}
+#else
+#define CVMX_DTX_OCX_BOT_CTL (CVMX_ADD_IO_SEG(0x00011800FE198060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_BOT_DATX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_OCX_BOT_DATX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE198040ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_OCX_BOT_DATX(offset) (CVMX_ADD_IO_SEG(0x00011800FE198040ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_BOT_ENAX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_OCX_BOT_ENAX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE198020ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_OCX_BOT_ENAX(offset) (CVMX_ADD_IO_SEG(0x00011800FE198020ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DTX_OCX_BOT_SELX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DTX_OCX_BOT_SELX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800FE198000ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DTX_OCX_BOT_SELX(offset) (CVMX_ADD_IO_SEG(0x00011800FE198000ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_DTX_OCX_LNKX_BCST_RSP(unsigned long offset)
 {
 	if (!(
@@ -2576,7 +2631,7 @@ static inline uint64_t CVMX_DTX_PEMX_BCST_RSP(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PEMX_BCST_RSP(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE600080ull) + ((offset) & 3) * 32768;
 }
@@ -2590,7 +2645,7 @@ static inline uint64_t CVMX_DTX_PEMX_CTL(unsigned long offset)
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 1) && (offset <= 3)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
 		cvmx_warn("CVMX_DTX_PEMX_CTL(%lu) is invalid on this chip\n", offset);
 	return CVMX_ADD_IO_SEG(0x00011800FE600060ull) + ((offset) & 3) * 32768;
 }
@@ -2604,7 +2659,7 @@ static inline uint64_t CVMX_DTX_PEMX_DATX(unsigned long offset, unsigned long bl
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && (((block_id >= 1) && (block_id <= 3))))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_PEMX_DATX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE600040ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
 }
@@ -2618,7 +2673,7 @@ static inline uint64_t CVMX_DTX_PEMX_ENAX(unsigned long offset, unsigned long bl
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && (((block_id >= 1) && (block_id <= 3))))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_PEMX_ENAX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE600020ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
 }
@@ -2632,7 +2687,7 @@ static inline uint64_t CVMX_DTX_PEMX_SELX(unsigned long offset, unsigned long bl
 	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset <= 1)) && ((block_id <= 2)))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 1)) && (((block_id >= 1) && (block_id <= 3))))) ||
 	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 1)) && ((block_id <= 3)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 3))))))
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 1)) && ((block_id <= 1))))))
 		cvmx_warn("CVMX_DTX_PEMX_SELX(%lu,%lu) is invalid on this chip\n", offset, block_id);
 	return CVMX_ADD_IO_SEG(0x00011800FE600000ull) + (((offset) & 1) + ((block_id) & 3) * 0x1000ull) * 8;
 }
@@ -8593,6 +8648,111 @@ union cvmx_dtx_mio_selx {
 typedef union cvmx_dtx_mio_selx cvmx_dtx_mio_selx_t;
 
 /**
+ * cvmx_dtx_ocx_bot_bcst_rsp
+ */
+union cvmx_dtx_ocx_bot_bcst_rsp {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_bot_bcst_rsp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
+#else
+	uint64_t ena                          : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_bot_bcst_rsp_s    cn78xx;
+	struct cvmx_dtx_ocx_bot_bcst_rsp_s    cn78xxp2;
+};
+typedef union cvmx_dtx_ocx_bot_bcst_rsp cvmx_dtx_ocx_bot_bcst_rsp_t;
+
+/**
+ * cvmx_dtx_ocx_bot_ctl
+ */
+union cvmx_dtx_ocx_bot_ctl {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_bot_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
+	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
+#else
+	uint64_t swap                         : 1;
+	uint64_t echoen                       : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t active                       : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_bot_ctl_s         cn78xx;
+	struct cvmx_dtx_ocx_bot_ctl_s         cn78xxp2;
+};
+typedef union cvmx_dtx_ocx_bot_ctl cvmx_dtx_ocx_bot_ctl_t;
+
+/**
+ * cvmx_dtx_ocx_bot_dat#
+ */
+union cvmx_dtx_ocx_bot_datx {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_bot_datx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t raw                          : 36; /**< Raw debug data captured by the DTX before the ENA is applied. This gives the ability to
+                                                         peek into blocks during an OCLA capture without OCLA reconfiguration. */
+#else
+	uint64_t raw                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_bot_datx_s        cn78xx;
+	struct cvmx_dtx_ocx_bot_datx_s        cn78xxp2;
+};
+typedef union cvmx_dtx_ocx_bot_datx cvmx_dtx_ocx_bot_datx_t;
+
+/**
+ * cvmx_dtx_ocx_bot_ena#
+ */
+union cvmx_dtx_ocx_bot_enax {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_bot_enax_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t ena                          : 36; /**< Output enable vector of which bits to drive onto the low/high 36-bit debug buses. Normally
+                                                         only one block will drive each bit. */
+#else
+	uint64_t ena                          : 36;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_bot_enax_s        cn78xx;
+	struct cvmx_dtx_ocx_bot_enax_s        cn78xxp2;
+};
+typedef union cvmx_dtx_ocx_bot_enax cvmx_dtx_ocx_bot_enax_t;
+
+/**
+ * cvmx_dtx_ocx_bot_sel#
+ */
+union cvmx_dtx_ocx_bot_selx {
+	uint64_t u64;
+	struct cvmx_dtx_ocx_bot_selx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t value                        : 24; /**< Debug select. Selects which signals to drive onto low/high 36-bit debug buses. */
+#else
+	uint64_t value                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dtx_ocx_bot_selx_s        cn78xx;
+	struct cvmx_dtx_ocx_bot_selx_s        cn78xxp2;
+};
+typedef union cvmx_dtx_ocx_bot_selx cvmx_dtx_ocx_bot_selx_t;
+
+/**
  * cvmx_dtx_ocx_lnk#_bcst_rsp
  */
 union cvmx_dtx_ocx_lnkx_bcst_rsp {
diff --git a/arch/mips/include/asm/octeon/cvmx-global-resources.h b/arch/mips/include/asm/octeon/cvmx-global-resources.h
index 3e39f6b..4d7bea9 100644
--- a/arch/mips/include/asm/octeon/cvmx-global-resources.h
+++ b/arch/mips/include/asm/octeon/cvmx-global-resources.h
@@ -18,6 +18,7 @@
 #define CVMX_GR_TAG_STYLE(x)        cvmx_get_gr_tag('c','v','m','_','s','t','y','l','e','_',(x+'0'),'.','.','.','.','.')
 #define CVMX_GR_TAG_QPG_ENTRY(x)    cvmx_get_gr_tag('c','v','m','_','q','p','g','e','t','_',(x+'0'),'.','.','.','.','.')
 #define CVMX_GR_TAG_BPID(x)         cvmx_get_gr_tag('c','v','m','_','b','p','i','d','s','_',(x+'0'),'.','.','.','.','.')
+#define CVMX_GR_TAG_MTAG_IDX(x)     cvmx_get_gr_tag('c','v','m','_','m','t','a','g','x','_',(x+'0'),'.','.','.','.','.')
 #define CVMX_GR_TAG_PCAM(x,y,z) \
 	cvmx_get_gr_tag('c','v','m','_','p','c','a','m','_',(x+'0'),(y+'0'),(z+'0'),'.','.','.','.')
 
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-board.h b/arch/mips/include/asm/octeon/cvmx-helper-board.h
index 64aa47a..9aa4b92 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-board.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-board.h
@@ -43,7 +43,7 @@
  * Helper functions to abstract board specific data about
  * network ports from the rest of the cvmx-helper files.
  *
- * <hr>$Revision: 118784 $<hr>
+ * <hr>$Revision: 121712 $<hr>
  */
 #ifndef __CVMX_HELPER_BOARD_H__
 #define __CVMX_HELPER_BOARD_H__
@@ -71,6 +71,7 @@ typedef enum cvmx_phy_type {
  	INBAND_PHY,
 	QUALCOMM_S17,		/** Qualcomm QCA833X switch */
 	VITESSE_VSC8490_PHY,	/** Vitesse VSC8490 is non-standard for SGMII */
+	FAKE_PHY,		/** Unsupported or no PHY, use GPIOs for LEDs */
 } cvmx_phy_type_t;
 
 /** Used to record the host mode used by the Cortina CS4321 PHY */
@@ -115,13 +116,33 @@ typedef enum {
 	GPIO_OCTEON,	/** Native OCTEON */
 	GPIO_PCA8574	/** TWSI mux device */
 } cvmx_phy_gpio_type_t;
-
-struct cvmx_phy_device;
-struct cvmx_phy_info;
 #endif
 
 /**
  * @INTERNAL
+ * This data structure is used when the port LEDs are wired up to Octeon's GPIO
+ * lines instead of to a traditional PHY.
+ */
+typedef struct cvmx_phy_gpio_leds {
+	uint64_t last_rx_count;		/** Counters used to check for activity */
+	uint64_t last_tx_count;		/** Counters used to check for activity */
+	int link_polling_interval_ms;	/** Link polling interval in ms */
+	int link_status_gpio;		/** Link status LED GPIO, -1 if not used */
+	int error_gpio;			/** Error status LED GPIO, -1 if not used */
+	int rx_activity_gpio;		/** RX activity LED GPIO, -1 if not used */
+	int tx_activity_gpio;		/** TX activity LED GPIO, -1 if not used */
+	uint16_t rx_activity_on_ms;	/** RX activity on time in ms */
+	uint16_t rx_activity_off_ms;	/** RX activity off time in ms */
+	uint16_t tx_activity_on_ms;	/** TX activity on time in ms */
+	uint16_t tx_activity_off_ms;	/** TX activity off time in ms */
+	bool link_status_active_low;	/** True if active link is active low */
+	bool err_active_low;		/** True if error is active low */
+	bool rx_activity_active_low;	/** True if rx activity is active low */
+	bool tx_activity_active_low;	/** True if tx activity is active low */
+} cvmx_phy_gpio_leds_t;
+
+/**
+ * @INTERNAL
  * This data structure is used to hold PHY information and is subject to change.
  * Please do  not use this data structure directly.
  *
@@ -152,10 +173,15 @@ typedef struct cvmx_phy_info {
 	cvmx_phy_mux_type_t mux_type;	/** Type of MDIO mux */
 	int mux_twsi_addr;		/** Address of the MDIO mux */
 	cvmx_phy_host_mode_t host_mode;	/** Used by Cortina PHY */
-	struct cvmx_phy_device *phydev;	/** Pointer to parent phy device */
+	void *phydev;			/** Pointer to parent phy device */
 #endif
 	/** Pointer to function to return link information */
 	cvmx_helper_link_info_t (*link_function)(struct cvmx_phy_info *phy_info);
+	/**
+	 * If there are LEDs driven by GPIO lines instead of by a PHY device
+	 * then they are described here, otherwise gpio_leds should be NULL.
+	 */
+	struct cvmx_phy_gpio_leds *gpio_leds;
 } cvmx_phy_info_t;
 
 /* Fake IPD port, the RGMII/MII interface may use different PHY, use this
@@ -332,7 +358,17 @@ int cvmx_helper_board_get_phy_info(cvmx_phy_info_t *phy_info, int ipd_port);
  *
  * @return 0 for success, -1 on error.
  */
-int __cvmx_helper_parse_78xx_bgx_dt(void *fdt_addr);
+int __cvmx_helper_parse_bgx_dt(void *fdt_addr);
+
+/**
+ * @INTERNAL
+ * Parse the device tree and set whether a port is valid or not.
+ *
+ * @param fdt_addr	Pointer to device tree
+ *
+ * @return 0 for success, -1 on error.
+ */
+int __cvmx_helper_parse_bgx_rgmii_dt(const void *fdt_addr);
 #endif
 
 #ifdef	__cplusplus
diff --git a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
index 31be22d..0b6d169 100644
--- a/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ocx-defs.h
@@ -1777,7 +1777,8 @@ union cvmx_ocx_lnex_trn_ctl {
 	uint64_t reserved_4_63                : 60;
 	uint64_t lock                         : 1;  /**< Training frame boundary locked. */
 	uint64_t done                         : 1;  /**< Training done. For diagnostic use only may be written to 1 to force training done. */
-	uint64_t ena                          : 1;  /**< Training enabled. */
+	uint64_t ena                          : 1;  /**< Training enabled.
+                                                         Should match corresponding OCX_QLM()_CFG[TRN_ENA]. */
 	uint64_t eie_detect                   : 1;  /**< Electrical idle exit (EIE) detected. */
 #else
 	uint64_t eie_detect                   : 1;
@@ -1802,10 +1803,12 @@ union cvmx_ocx_lnex_trn_ld {
 	uint64_t lp_manual                    : 1;  /**< Allow software to manually manipulate local device CU/SR by ignoring hardware update. */
 	uint64_t reserved_49_62               : 14;
 	uint64_t ld_cu_val                    : 1;  /**< Local device coefficient update field valid. */
-	uint64_t ld_cu_dat                    : 16; /**< Local device coefficient update field data. */
+	uint64_t ld_cu_dat                    : 16; /**< Local device coefficient update field data.
+                                                         The format of this field is BGX_SPU_BR_TRAIN_CUP_S. */
 	uint64_t reserved_17_31               : 15;
 	uint64_t ld_sr_val                    : 1;  /**< Local device status report field valid. */
-	uint64_t ld_sr_dat                    : 16; /**< Local device status report field data. */
+	uint64_t ld_sr_dat                    : 16; /**< Local device status report field data.
+                                                         The format of this field is BGX_SPU_BR_TRAIN_REP_S. */
 #else
 	uint64_t ld_sr_dat                    : 16;
 	uint64_t ld_sr_val                    : 1;
@@ -1830,10 +1833,12 @@ union cvmx_ocx_lnex_trn_lp {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_49_63               : 15;
 	uint64_t lp_cu_val                    : 1;  /**< Link partner coefficient update field valid. */
-	uint64_t lp_cu_dat                    : 16; /**< Link partner coefficient update field data. */
+	uint64_t lp_cu_dat                    : 16; /**< Link partner coefficient update field data.
+                                                         The format of this field is BGX_SPU_BR_TRAIN_CUP_S. */
 	uint64_t reserved_17_31               : 15;
 	uint64_t lp_sr_val                    : 1;  /**< Link partner status report field valid. */
-	uint64_t lp_sr_dat                    : 16; /**< Link partner status report field data. */
+	uint64_t lp_sr_dat                    : 16; /**< Link partner status report field data.
+                                                         The format of this field is BGX_SPU_BR_TRAIN_REP_S. */
 #else
 	uint64_t lp_sr_dat                    : 16;
 	uint64_t lp_sr_val                    : 1;
@@ -2094,8 +2099,7 @@ union cvmx_ocx_qlmx_cfg {
 	uint64_t reserved_27_30               : 4;
 	uint64_t trn_rxeq_only                : 1;  /**< Shortened training sequence.  Initialized to 1 during cold reset when OCI_SPD<3:0> pins
                                                          indicate 5 GBAUD <=speed < 8 GBAUD. Otherwise, initialized to 0 during a cold reset. This
-                                                         field is
-                                                         not affected by soft or warm reset.  For diagnostic use only. */
+                                                         field is not affected by soft or warm reset.  For diagnostic use only. */
 	uint64_t timer_dis                    : 1;  /**< Disable bad lane timer. A timer counts core clocks (RCLKs) when any enabled lane is not
                                                          ready, i.e. not in the scrambler sync state. If this timer expires before all enabled
                                                          lanes can be made ready, then any lane which is not ready is disabled via
diff --git a/arch/mips/include/asm/octeon/cvmx-pexp-defs.h b/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
index 6e673e9..2b9c364 100644
--- a/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pexp-defs.h
@@ -1152,53 +1152,181 @@ static inline uint64_t CVMX_PEXP_NPEI_WINDOW_CTL_FUNC(void)
 #define CVMX_PEXP_SLI_BIST_STATUS CVMX_PEXP_SLI_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_BIST_STATUS not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000010580ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010580ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028580ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_BIST_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028580ull);
 }
 #else
-#define CVMX_PEXP_SLI_BIST_STATUS (CVMX_ADD_IO_SEG(0x00011F0000010580ull))
+#define CVMX_PEXP_SLI_BIST_STATUS CVMX_PEXP_SLI_BIST_STATUS_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_BIST_STATUS_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010580ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028580ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028580ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_CTL_PORTX(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PEXP_SLI_CTL_PORTX(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 3) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 1) * 16;
+			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 3) * 16;
+			break;
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 3) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011F00000106E0ull) + ((offset) & 3) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + ((offset) & 3) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_CTL_PORTX (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + ((offset) & 3) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_CTL_PORTX(offset) (CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 3) * 16)
+static inline uint64_t CVMX_PEXP_SLI_CTL_PORTX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 16;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 16;
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000106E0ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + (offset) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_CTL_STATUS CVMX_PEXP_SLI_CTL_STATUS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_CTL_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_CTL_STATUS not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000010570ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010570ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028570ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_CTL_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028570ull);
 }
 #else
-#define CVMX_PEXP_SLI_CTL_STATUS (CVMX_ADD_IO_SEG(0x00011F0000010570ull))
+#define CVMX_PEXP_SLI_CTL_STATUS CVMX_PEXP_SLI_CTL_STATUS_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_CTL_STATUS_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010570ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028570ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028570ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_DATA_OUT_CNT CVMX_PEXP_SLI_DATA_OUT_CNT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_DATA_OUT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_DATA_OUT_CNT not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F00000105F0ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000105F0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000285F0ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_DATA_OUT_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F00000285F0ull);
 }
 #else
-#define CVMX_PEXP_SLI_DATA_OUT_CNT (CVMX_ADD_IO_SEG(0x00011F00000105F0ull))
+#define CVMX_PEXP_SLI_DATA_OUT_CNT CVMX_PEXP_SLI_DATA_OUT_CNT_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_DATA_OUT_CNT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000105F0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000285F0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000285F0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_DBG_DATA CVMX_PEXP_SLI_DBG_DATA_FUNC()
@@ -1225,59 +1353,128 @@ static inline uint64_t CVMX_PEXP_SLI_DBG_SELECT_FUNC(void)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_DMAX_CNT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_PEXP_SLI_DMAX_CNT(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000010400ull) + ((offset) & 1) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F0000010400ull) + ((offset) & 1) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F0000028400ull) + ((offset) & 1) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_DMAX_CNT (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000028400ull) + ((offset) & 1) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_DMAX_CNT(offset) (CVMX_ADD_IO_SEG(0x00011F0000010400ull) + ((offset) & 1) * 16)
+static inline uint64_t CVMX_PEXP_SLI_DMAX_CNT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010400ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028400ull) + (offset) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028400ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_DMAX_INT_LEVEL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_PEXP_SLI_DMAX_INT_LEVEL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F00000103E0ull) + ((offset) & 1) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F00000103E0ull) + ((offset) & 1) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F00000283E0ull) + ((offset) & 1) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_DMAX_INT_LEVEL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F00000283E0ull) + ((offset) & 1) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_DMAX_INT_LEVEL(offset) (CVMX_ADD_IO_SEG(0x00011F00000103E0ull) + ((offset) & 1) * 16)
+static inline uint64_t CVMX_PEXP_SLI_DMAX_INT_LEVEL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000103E0ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000283E0ull) + (offset) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000283E0ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_DMAX_TIM(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_PEXP_SLI_DMAX_TIM(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000010420ull) + ((offset) & 1) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F0000010420ull) + ((offset) & 1) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F0000028420ull) + ((offset) & 1) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_DMAX_TIM (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000028420ull) + ((offset) & 1) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_DMAX_TIM(offset) (CVMX_ADD_IO_SEG(0x00011F0000010420ull) + ((offset) & 1) * 16)
+static inline uint64_t CVMX_PEXP_SLI_DMAX_TIM(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010420ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028420ull) + (offset) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028420ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_INT_ENB_CIU CVMX_PEXP_SLI_INT_ENB_CIU_FUNC()
@@ -1366,53 +1563,285 @@ static inline uint64_t CVMX_PEXP_SLI_LAST_WIN_RDATA3_FUNC(void)
 #define CVMX_PEXP_SLI_MAC_CREDIT_CNT CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_MAC_CREDIT_CNT not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000013D70ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013D70ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023D70ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MAC_CREDIT_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023D70ull);
 }
 #else
-#define CVMX_PEXP_SLI_MAC_CREDIT_CNT (CVMX_ADD_IO_SEG(0x00011F0000013D70ull))
+#define CVMX_PEXP_SLI_MAC_CREDIT_CNT CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013D70ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023D70ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023D70ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_MAC_CREDIT_CNT2 CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_MAC_CREDIT_CNT2 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000013E10ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013E10ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023E10ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MAC_CREDIT_CNT2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023E10ull);
 }
 #else
-#define CVMX_PEXP_SLI_MAC_CREDIT_CNT2 (CVMX_ADD_IO_SEG(0x00011F0000013E10ull))
+#define CVMX_PEXP_SLI_MAC_CREDIT_CNT2 CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MAC_CREDIT_CNT2_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013E10ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023E10ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023E10ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_MEM_ACCESS_CTL CVMX_PEXP_SLI_MEM_ACCESS_CTL_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_MEM_ACCESS_CTL not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F00000102F0ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000102F0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000282F0ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MEM_ACCESS_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F00000282F0ull);
 }
 #else
-#define CVMX_PEXP_SLI_MEM_ACCESS_CTL (CVMX_ADD_IO_SEG(0x00011F00000102F0ull))
+#define CVMX_PEXP_SLI_MEM_ACCESS_CTL CVMX_PEXP_SLI_MEM_ACCESS_CTL_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000102F0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000282F0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000282F0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset >= 12) && (offset <= 27))))))
-		cvmx_warn("CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F00000100E0ull) + ((offset) & 31) * 16 - 16*12;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if (((offset >= 12) && (offset <= 27)))
+				return CVMX_ADD_IO_SEG(0x00011F00000100E0ull) + ((offset) & 31) * 16 - 16*12;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset >= 12) && (offset <= 27)))
+				return CVMX_ADD_IO_SEG(0x00011F00000280E0ull) + ((offset) & 31) * 16 - 16*12;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F00000280E0ull) + ((offset) & 31) * 16 - 16*12;
 }
 #else
-#define CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(offset) (CVMX_ADD_IO_SEG(0x00011F00000100E0ull) + ((offset) & 31) * 16 - 16*12)
+static inline uint64_t CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000100E0ull) + (offset) * 16 - 16*12;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000280E0ull) + (offset) * 16 - 16*12;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000280E0ull) + (offset) * 16 - 16*12;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_MEM_CTL CVMX_PEXP_SLI_MEM_CTL_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MEM_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MEM_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
+}
+#else
+#define CVMX_PEXP_SLI_MEM_CTL CVMX_PEXP_SLI_MEM_CTL_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MEM_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000105E0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000285E0ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_MEM_INT_SUM CVMX_PEXP_SLI_MEM_INT_SUM_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MEM_INT_SUM_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MEM_INT_SUM not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
+}
+#else
+#define CVMX_PEXP_SLI_MEM_INT_SUM CVMX_PEXP_SLI_MEM_INT_SUM_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MEM_INT_SUM_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000105D0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000285D0ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_MSIX_PBA0 CVMX_PEXP_SLI_MSIX_PBA0_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MSIX_PBA0_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MSIX_PBA0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
+}
+#else
+#define CVMX_PEXP_SLI_MSIX_PBA0 CVMX_PEXP_SLI_MSIX_PBA0_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MSIX_PBA0_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000017000ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000001000ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_MSIX_PBA1 CVMX_PEXP_SLI_MSIX_PBA1_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MSIX_PBA1_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000001008ull);
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MSIX_PBA1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000001008ull);
+}
+#else
+#define CVMX_PEXP_SLI_MSIX_PBA1 CVMX_PEXP_SLI_MSIX_PBA1_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MSIX_PBA1_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000001008ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000017010ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000001008ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_MSI_ENB0 CVMX_PEXP_SLI_MSI_ENB0_FUNC()
@@ -1462,56 +1891,211 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_ENB3_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_RCV0 CVMX_PEXP_SLI_MSI_RCV0_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV0 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000013C10ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C10ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C10ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MSI_RCV0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023C10ull);
 }
 #else
-#define CVMX_PEXP_SLI_MSI_RCV0 (CVMX_ADD_IO_SEG(0x00011F0000013C10ull))
+#define CVMX_PEXP_SLI_MSI_RCV0 CVMX_PEXP_SLI_MSI_RCV0_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MSI_RCV0_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C10ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C10ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023C10ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_MSI_RCV1 CVMX_PEXP_SLI_MSI_RCV1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV1 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000013C20ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C20ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C20ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MSI_RCV1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023C20ull);
 }
 #else
-#define CVMX_PEXP_SLI_MSI_RCV1 (CVMX_ADD_IO_SEG(0x00011F0000013C20ull))
+#define CVMX_PEXP_SLI_MSI_RCV1 CVMX_PEXP_SLI_MSI_RCV1_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MSI_RCV1_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C20ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C20ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023C20ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_MSI_RCV2 CVMX_PEXP_SLI_MSI_RCV2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV2 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000013C30ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C30ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C30ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MSI_RCV2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023C30ull);
 }
 #else
-#define CVMX_PEXP_SLI_MSI_RCV2 (CVMX_ADD_IO_SEG(0x00011F0000013C30ull))
+#define CVMX_PEXP_SLI_MSI_RCV2 CVMX_PEXP_SLI_MSI_RCV2_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MSI_RCV2_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C30ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C30ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023C30ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_MSI_RCV3 CVMX_PEXP_SLI_MSI_RCV3_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RCV3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_MSI_RCV3 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000013C40ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C40ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C40ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MSI_RCV3 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023C40ull);
 }
 #else
-#define CVMX_PEXP_SLI_MSI_RCV3 (CVMX_ADD_IO_SEG(0x00011F0000013C40ull))
+#define CVMX_PEXP_SLI_MSI_RCV3 CVMX_PEXP_SLI_MSI_RCV3_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MSI_RCV3_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C40ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C40ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023C40ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_MSI_RD_MAP CVMX_PEXP_SLI_MSI_RD_MAP_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_RD_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_MSI_RD_MAP not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000013CA0ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013CA0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023CA0ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MSI_RD_MAP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023CA0ull);
 }
 #else
-#define CVMX_PEXP_SLI_MSI_RD_MAP (CVMX_ADD_IO_SEG(0x00011F0000013CA0ull))
+#define CVMX_PEXP_SLI_MSI_RD_MAP CVMX_PEXP_SLI_MSI_RD_MAP_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MSI_RD_MAP_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013CA0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023CA0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023CA0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_MSI_W1C_ENB0 CVMX_PEXP_SLI_MSI_W1C_ENB0_FUNC()
@@ -1605,132 +2189,395 @@ static inline uint64_t CVMX_PEXP_SLI_MSI_W1S_ENB3_FUNC(void)
 #define CVMX_PEXP_SLI_MSI_WR_MAP CVMX_PEXP_SLI_MSI_WR_MAP_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_MSI_WR_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_MSI_WR_MAP not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000013C90ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C90ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C90ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_MSI_WR_MAP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023C90ull);
 }
 #else
-#define CVMX_PEXP_SLI_MSI_WR_MAP (CVMX_ADD_IO_SEG(0x00011F0000013C90ull))
+#define CVMX_PEXP_SLI_MSI_WR_MAP CVMX_PEXP_SLI_MSI_WR_MAP_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_MSI_WR_MAP_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C90ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C90ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023C90ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000013CB0ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013CB0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023CB0ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023CB0ull);
 }
 #else
-#define CVMX_PEXP_SLI_PCIE_MSI_RCV (CVMX_ADD_IO_SEG(0x00011F0000013CB0ull))
+#define CVMX_PEXP_SLI_PCIE_MSI_RCV CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013CB0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023CB0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023CB0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV_B1 CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B1 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000010650ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010650ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028650ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028650ull);
 }
 #else
-#define CVMX_PEXP_SLI_PCIE_MSI_RCV_B1 (CVMX_ADD_IO_SEG(0x00011F0000010650ull))
+#define CVMX_PEXP_SLI_PCIE_MSI_RCV_B1 CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B1_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010650ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028650ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028650ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV_B2 CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B2 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000010660ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010660ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028660ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028660ull);
 }
 #else
-#define CVMX_PEXP_SLI_PCIE_MSI_RCV_B2 (CVMX_ADD_IO_SEG(0x00011F0000010660ull))
+#define CVMX_PEXP_SLI_PCIE_MSI_RCV_B2 CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B2_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010660ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028660ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028660ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PCIE_MSI_RCV_B3 CVMX_PEXP_SLI_PCIE_MSI_RCV_B3_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B3 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000010670ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010670ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028670ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PCIE_MSI_RCV_B3 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028670ull);
 }
 #else
-#define CVMX_PEXP_SLI_PCIE_MSI_RCV_B3 (CVMX_ADD_IO_SEG(0x00011F0000010670ull))
+#define CVMX_PEXP_SLI_PCIE_MSI_RCV_B3 CVMX_PEXP_SLI_PCIE_MSI_RCV_B3_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PCIE_MSI_RCV_B3_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010670ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028670ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028670ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_CNTS(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_PEXP_SLI_PKTX_CNTS(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F00000100B0ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKTX_CNTS (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F00000100B0ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_CNTS(offset) (CVMX_ADD_IO_SEG(0x00011F0000012400ull) + ((offset) & 127) * 16)
+static inline uint64_t CVMX_PEXP_SLI_PKTX_CNTS(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000100B0ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000100B0ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BADDR(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_BADDR(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010010ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_BADDR (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010010ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_INSTR_BADDR(offset) (CVMX_ADD_IO_SEG(0x00011F0000012800ull) + ((offset) & 127) * 16)
+static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BADDR(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010010ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010010ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010020ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010020ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(offset) (CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + ((offset) & 127) * 16)
+static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010020ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010020ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010030ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010030ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(offset) (CVMX_ADD_IO_SEG(0x00011F0000013000ull) + ((offset) & 127) * 16)
+static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010030ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010030ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_INSTR_HEADER(unsigned long offset)
@@ -1766,89 +2613,239 @@ static inline uint64_t CVMX_PEXP_SLI_PKTX_IN_BP(unsigned long offset)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_OUT_SIZE(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_PEXP_SLI_PKTX_OUT_SIZE(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010060ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKTX_OUT_SIZE (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010060ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_OUT_SIZE(offset) (CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + ((offset) & 127) * 16)
+static inline uint64_t CVMX_PEXP_SLI_PKTX_OUT_SIZE(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010060ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010060ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BADDR(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_BADDR(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010070ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_BADDR (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010070ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_SLIST_BADDR(offset) (CVMX_ADD_IO_SEG(0x00011F0000011400ull) + ((offset) & 127) * 16)
+static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BADDR(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010070ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010070ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010080ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010080ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(offset) (CVMX_ADD_IO_SEG(0x00011F0000011800ull) + ((offset) & 127) * 16)
+static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010080ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010080ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010090ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010090ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(offset) (CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + ((offset) & 127) * 16)
+static inline uint64_t CVMX_PEXP_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010090ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010090ull) + (offset) * 0x20000ull;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_BIST_STATUS CVMX_PEXP_SLI_PKT_BIST_STATUS_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_BIST_STATUS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+		cvmx_warn("CVMX_PEXP_SLI_PKT_BIST_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029220ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_BIST_STATUS (CVMX_ADD_IO_SEG(0x00011F0000029220ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_CNT_INT CVMX_PEXP_SLI_PKT_CNT_INT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_CNT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_PKT_CNT_INT not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000011130ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011130ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029130ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKT_CNT_INT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029130ull);
 }
 #else
-#define CVMX_PEXP_SLI_PKT_CNT_INT (CVMX_ADD_IO_SEG(0x00011F0000011130ull))
+#define CVMX_PEXP_SLI_PKT_CNT_INT CVMX_PEXP_SLI_PKT_CNT_INT_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_CNT_INT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011130ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029130ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000029130ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_CNT_INT_ENB CVMX_PEXP_SLI_PKT_CNT_INT_ENB_FUNC()
@@ -1917,6 +2914,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_DPADDR_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_DPADDR (CVMX_ADD_IO_SEG(0x00011F0000011080ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_GBL_CONTROL CVMX_PEXP_SLI_PKT_GBL_CONTROL_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_GBL_CONTROL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+		cvmx_warn("CVMX_PEXP_SLI_PKT_GBL_CONTROL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029210ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_GBL_CONTROL (CVMX_ADD_IO_SEG(0x00011F0000029210ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_INPUT_CONTROL CVMX_PEXP_SLI_PKT_INPUT_CONTROL_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_INPUT_CONTROL_FUNC(void)
 {
@@ -1961,6 +2969,36 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_INSTR_SIZE_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_INSTR_SIZE (CVMX_ADD_IO_SEG(0x00011F0000011020ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_INT CVMX_PEXP_SLI_PKT_INT_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_INT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKT_INT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_INT CVMX_PEXP_SLI_PKT_INT_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_INT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011160ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000029160ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_INT_LEVELS CVMX_PEXP_SLI_PKT_INT_LEVELS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_INT_LEVELS_FUNC(void)
 {
@@ -1985,32 +3023,131 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IN_BP_FUNC(void)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010040ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010040ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(offset) (CVMX_ADD_IO_SEG(0x00011F0000012000ull) + ((offset) & 127) * 16)
+static inline uint64_t CVMX_PEXP_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010040ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010040ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000011200ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011200ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029200ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029200ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011200ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029200ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000029200ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_IN_INT CVMX_PEXP_SLI_PKT_IN_INT_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKT_IN_INT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_IN_INT CVMX_PEXP_SLI_PKT_IN_INT_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_IN_INT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011150ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000029150ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_IN_JABBER CVMX_PEXP_SLI_PKT_IN_JABBER_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_IN_JABBER_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+		cvmx_warn("CVMX_PEXP_SLI_PKT_IN_JABBER not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029170ull);
 }
 #else
-#define CVMX_PEXP_SLI_PKT_IN_INSTR_COUNTS (CVMX_ADD_IO_SEG(0x00011F0000011200ull))
+#define CVMX_PEXP_SLI_PKT_IN_JABBER (CVMX_ADD_IO_SEG(0x00011F0000029170ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_IN_PCIE_PORT CVMX_PEXP_SLI_PKT_IN_PCIE_PORT_FUNC()
@@ -2035,15 +3172,120 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_IPTR_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_IPTR (CVMX_ADD_IO_SEG(0x00011F0000011070ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_MAC0_SIG0 CVMX_PEXP_SLI_PKT_MAC0_SIG0_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_MAC0_SIG0_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PEXP_SLI_PKT_MAC0_SIG0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000011300ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_MAC0_SIG0 (CVMX_ADD_IO_SEG(0x00011F0000011300ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_MAC0_SIG1 CVMX_PEXP_SLI_PKT_MAC0_SIG1_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_MAC0_SIG1_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PEXP_SLI_PKT_MAC0_SIG1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000011310ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_MAC0_SIG1 (CVMX_ADD_IO_SEG(0x00011F0000011310ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_MAC1_SIG0 CVMX_PEXP_SLI_PKT_MAC1_SIG0_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_MAC1_SIG0_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PEXP_SLI_PKT_MAC1_SIG0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000011320ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_MAC1_SIG0 (CVMX_ADD_IO_SEG(0x00011F0000011320ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_MAC1_SIG1 CVMX_PEXP_SLI_PKT_MAC1_SIG1_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_MAC1_SIG1_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_PEXP_SLI_PKT_MAC1_SIG1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000011330ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_MAC1_SIG1 (CVMX_ADD_IO_SEG(0x00011F0000011330ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_MEM_CTL CVMX_PEXP_SLI_PKT_MEM_CTL_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_MEM_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKT_MEM_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_MEM_CTL CVMX_PEXP_SLI_PKT_MEM_CTL_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_MEM_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_OUTPUT_WMARK CVMX_PEXP_SLI_PKT_OUTPUT_WMARK_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUTPUT_WMARK_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_PKT_OUTPUT_WMARK not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000011180ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011180ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029180ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKT_OUTPUT_WMARK not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029180ull);
 }
 #else
-#define CVMX_PEXP_SLI_PKT_OUTPUT_WMARK (CVMX_ADD_IO_SEG(0x00011F0000011180ull))
+#define CVMX_PEXP_SLI_PKT_OUTPUT_WMARK CVMX_PEXP_SLI_PKT_OUTPUT_WMARK_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_OUTPUT_WMARK_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011180ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029180ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000029180ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_OUT_BMODE CVMX_PEXP_SLI_PKT_OUT_BMODE_FUNC()
@@ -2068,6 +3310,50 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_OUT_BP_EN (CVMX_ADD_IO_SEG(0x00011F0000011240ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1C CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1C_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1C_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1C not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029290ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1C (CVMX_ADD_IO_SEG(0x00011F0000029290ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1S CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1S_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1S_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1S not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029270ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_OUT_BP_EN2_W1S (CVMX_ADD_IO_SEG(0x00011F0000029270ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1C CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1C_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1C_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1C not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029280ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1C (CVMX_ADD_IO_SEG(0x00011F0000029280ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1S CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1S_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1S_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+		cvmx_warn("CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1S not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029260ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_OUT_BP_EN_W1S (CVMX_ADD_IO_SEG(0x00011F0000029260ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_OUT_ENB CVMX_PEXP_SLI_PKT_OUT_ENB_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_OUT_ENB_FUNC(void)
 {
@@ -2090,6 +3376,17 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_PCIE_PORT_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_PCIE_PORT (CVMX_ADD_IO_SEG(0x00011F00000110E0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_PKIND_VALID CVMX_PEXP_SLI_PKT_PKIND_VALID_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_PKIND_VALID_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
+		cvmx_warn("CVMX_PEXP_SLI_PKT_PKIND_VALID not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029190ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_PKIND_VALID (CVMX_ADD_IO_SEG(0x00011F0000029190ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_PORT_IN_RST CVMX_PEXP_SLI_PKT_PORT_IN_RST_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_PORT_IN_RST_FUNC(void)
 {
@@ -2101,6 +3398,36 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_PORT_IN_RST_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_PORT_IN_RST (CVMX_ADD_IO_SEG(0x00011F00000111F0ull))
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_PEXP_SLI_PKT_RING_RST CVMX_PEXP_SLI_PKT_RING_RST_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_RING_RST_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKT_RING_RST not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
+}
+#else
+#define CVMX_PEXP_SLI_PKT_RING_RST CVMX_PEXP_SLI_PKT_RING_RST_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_RING_RST_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000111E0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000291E0ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_SLIST_ES CVMX_PEXP_SLI_PKT_SLIST_ES_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_SLIST_ES_FUNC(void)
 {
@@ -2137,12 +3464,43 @@ static inline uint64_t CVMX_PEXP_SLI_PKT_SLIST_ROR_FUNC(void)
 #define CVMX_PEXP_SLI_PKT_TIME_INT CVMX_PEXP_SLI_PKT_TIME_INT_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_PKT_TIME_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_PKT_TIME_INT not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000011140ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011140ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029140ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_PKT_TIME_INT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029140ull);
 }
 #else
-#define CVMX_PEXP_SLI_PKT_TIME_INT (CVMX_ADD_IO_SEG(0x00011F0000011140ull))
+#define CVMX_PEXP_SLI_PKT_TIME_INT CVMX_PEXP_SLI_PKT_TIME_INT_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_PKT_TIME_INT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011140ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029140ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000029140ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_PKT_TIME_INT_ENB CVMX_PEXP_SLI_PKT_TIME_INT_ENB_FUNC()
@@ -2169,76 +3527,262 @@ static inline uint64_t CVMX_PEXP_SLI_PORTX_PKIND(unsigned long offset)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_PEXP_SLI_S2M_PORTX_CTL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_PEXP_SLI_S2M_PORTX_CTL(%lu) is invalid on this chip\n", offset);
-	return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + ((offset) & 3) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + ((offset) & 1) * 16;
+			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + ((offset) & 3) * 16;
+			break;
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + ((offset) & 3) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011F0000023D80ull) + ((offset) & 3) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_S2M_PORTX_CTL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000023D80ull) + ((offset) & 3) * 16;
 }
 #else
-#define CVMX_PEXP_SLI_S2M_PORTX_CTL(offset) (CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + ((offset) & 3) * 16)
+static inline uint64_t CVMX_PEXP_SLI_S2M_PORTX_CTL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + (offset) * 16;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + (offset) * 16;
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023D80ull) + (offset) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023D80ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_SCRATCH_1 CVMX_PEXP_SLI_SCRATCH_1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_SCRATCH_1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_SCRATCH_1 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F00000103C0ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000103C0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000283C0ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_SCRATCH_1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F00000283C0ull);
 }
 #else
-#define CVMX_PEXP_SLI_SCRATCH_1 (CVMX_ADD_IO_SEG(0x00011F00000103C0ull))
+#define CVMX_PEXP_SLI_SCRATCH_1 CVMX_PEXP_SLI_SCRATCH_1_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_SCRATCH_1_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000103C0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000283C0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000283C0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_SCRATCH_2 CVMX_PEXP_SLI_SCRATCH_2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_SCRATCH_2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_SCRATCH_2 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F00000103D0ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000103D0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000283D0ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_SCRATCH_2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F00000283D0ull);
 }
 #else
-#define CVMX_PEXP_SLI_SCRATCH_2 (CVMX_ADD_IO_SEG(0x00011F00000103D0ull))
+#define CVMX_PEXP_SLI_SCRATCH_2 CVMX_PEXP_SLI_SCRATCH_2_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_SCRATCH_2_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000103D0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000283D0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000283D0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_STATE1 CVMX_PEXP_SLI_STATE1_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_STATE1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_STATE1 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000010620ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010620ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028620ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_STATE1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028620ull);
 }
 #else
-#define CVMX_PEXP_SLI_STATE1 (CVMX_ADD_IO_SEG(0x00011F0000010620ull))
+#define CVMX_PEXP_SLI_STATE1 CVMX_PEXP_SLI_STATE1_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_STATE1_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010620ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028620ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028620ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_STATE2 CVMX_PEXP_SLI_STATE2_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_STATE2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_STATE2 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000010630ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010630ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028630ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_STATE2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028630ull);
 }
 #else
-#define CVMX_PEXP_SLI_STATE2 (CVMX_ADD_IO_SEG(0x00011F0000010630ull))
+#define CVMX_PEXP_SLI_STATE2 CVMX_PEXP_SLI_STATE2_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_STATE2_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010630ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028630ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028630ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_STATE3 CVMX_PEXP_SLI_STATE3_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_STATE3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_STATE3 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000010640ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010640ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028640ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_STATE3 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028640ull);
 }
 #else
-#define CVMX_PEXP_SLI_STATE3 (CVMX_ADD_IO_SEG(0x00011F0000010640ull))
+#define CVMX_PEXP_SLI_STATE3 CVMX_PEXP_SLI_STATE3_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_STATE3_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010640ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028640ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028640ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_PEXP_SLI_TX_PIPE CVMX_PEXP_SLI_TX_PIPE_FUNC()
@@ -2255,12 +3799,43 @@ static inline uint64_t CVMX_PEXP_SLI_TX_PIPE_FUNC(void)
 #define CVMX_PEXP_SLI_WINDOW_CTL CVMX_PEXP_SLI_WINDOW_CTL_FUNC()
 static inline uint64_t CVMX_PEXP_SLI_WINDOW_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_PEXP_SLI_WINDOW_CTL not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F00000102E0ull);
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000102E0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000282E0ull);
+			break;
+	}
+	cvmx_warn("CVMX_PEXP_SLI_WINDOW_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F00000282E0ull);
 }
 #else
-#define CVMX_PEXP_SLI_WINDOW_CTL (CVMX_ADD_IO_SEG(0x00011F00000102E0ull))
+#define CVMX_PEXP_SLI_WINDOW_CTL CVMX_PEXP_SLI_WINDOW_CTL_FUNC()
+static inline uint64_t CVMX_PEXP_SLI_WINDOW_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000102E0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000282E0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000282E0ull);
+}
 #endif
 
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index e185d18..c2ea598 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -3552,7 +3552,8 @@ typedef union cvmx_pki_pkt_err cvmx_pki_pkt_err_t;
  * cvmx_pki_ptag_avail
  *
  * This register configures tag management. It is suggested that this
- * register only be written when PKI_BUF_CTL[PKI_EN] is clear.
+ * register only be written when PKI_BUF_CTL[PKI_EN] is clear and must not be reconfigured
+ * without soft resetting PKI.
  * INTERNAL: Therefore do not put other fields into this register unless the same constraint
  * applies.
  */
@@ -3601,7 +3602,7 @@ union cvmx_pki_qpg_tblx {
 	uint64_t aura_node                    : 2;  /**< Aura node number. The node number is part of the upper aura bits, however PKI can only
                                                          allocate from auras on the local node, therefore these bits are hardcoded to the node
                                                          number. */
-	uint64_t laura                        : 10; /**< Aura on local node for QOS calculations and loading into WQE[AURA]WQE[AURA]. */
+	uint64_t laura                        : 10; /**< Aura on local node for QOS calculations and loading into WQE[AURA]. */
 #else
 	uint64_t laura                        : 10;
 	uint64_t aura_node                    : 2;
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-resources.h b/arch/mips/include/asm/octeon/cvmx-pki-resources.h
index e716c6c..76901d1 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-resources.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-resources.h
@@ -184,6 +184,25 @@ int cvmx_pki_bpid_free(int node, int bpid);
  * This function frees all the PKI software resources
  * (clusters, styles, qpg_entry, pcam_entry etc) for the specified node
  */
+
+/**
+ * This function allocates/reserves an index from pool of global MTAG-IDX per node.
+ * @param node	node to allocate index from.
+ * @param idx	index  to allocate, if -1 it will be allocated
+ * @return 	MTAG index number on success,
+ *		-1 on alloc failure.
+ *		-2 on resource already reserved.
+ */
+int cvmx_pki_mtag_idx_alloc(int node, int idx);
+
+/**
+ * This function frees an index from pool of global MTAG-IDX per node.
+ * @param node	 node to free bpid from.
+ * @param bpid	 bpid to free
+ * @return 	 0 on success, -1 on failure or
+ */
+int cvmx_pki_mtag_idx_free(int node, int idx);
+
 void __cvmx_pki_global_rsrc_free(int node);
 
 #ifdef	__cplusplus
diff --git a/arch/mips/include/asm/octeon/cvmx-pki.h b/arch/mips/include/asm/octeon/cvmx-pki.h
index d368ebd..ae3279c 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki.h
@@ -81,6 +81,7 @@ extern "C" {
 #define CVMX_PKI_NUM_INTERNAL_STYLE     (256)
 #define CVMX_PKI_NUM_FINAL_STYLE 	(64)
 #define CVMX_PKI_NUM_QPG_ENTRY		(2048)
+#define CVMX_PKI_NUM_MTAG_IDX	(32)
 #define CVMX_PKI_NUM_LTYPE		(32)
 #define CVMX_PKI_NUM_PCAM_BANK		(2)
 #define CVMX_PKI_NUM_PCAM_ENTRY		(192)
@@ -393,20 +394,28 @@ struct cvmx_pki_style_parm {
    that modiying that style will modify the respective parameters for all the ports which
    are using this style */
 
+enum cvmx_pki_mtag_ptrsel {
+	CVMX_PKI_MTAG_PTRSEL_SOP = 0,
+	CVMX_PKI_MTAG_PTRSEL_LA = 8,
+	CVMX_PKI_MTAG_PTRSEL_LB = 9,
+	CVMX_PKI_MTAG_PTRSEL_LC = 10,
+	CVMX_PKI_MTAG_PTRSEL_LD = 11,
+	CVMX_PKI_MTAG_PTRSEL_LE = 12,
+	CVMX_PKI_MTAG_PTRSEL_LF = 13,
+	CVMX_PKI_MTAG_PTRSEL_LG = 14,
+	CVMX_PKI_MTAG_PTRSEL_VL = 15,
+};
+
 struct cvmx_pki_mask_tag {
-	uint64_t tag_inc;			/**< Include masked tags using PKI_TAG_INC(0..31)_MASK. Each bit indicates to include the
-						     corresponding PKI_TAG_INC_MASK range. */
-	uint64_t tag_masken;			/**< Apply PKI_STYLE(0..63)_TAG_MASK to computed tag.*/
-	uint64_t mask;				/**< When set, each bit excludes corresponding bit of the tuple computed tag from being
-						     included in the final tag. PKI_CL(0..3)_STYLE(0..63)_CFG2 [TAG_MASKEN] must be set. Does
-						     not affect tags from packets with a PKI_INST_HDR_S when PKI_INST_HDR[UTAG] is set */
-	uint64_t tag_idx[4];			/**< Index 0-3 for TAG_INC<3>. This value is multipled by 4 to index into PKI_TAG_INC(0..31)_MASK.
-						     See WQE[TAG]. */
+	bool enable;
+	int base; /* CVMX_PKI_MTAG_PTRSEL_XXX */
+	int offset; /* Offset from base. */
+	uint64_t val; /* Bitmask: 1 = enable, 0 = disabled for each byte in the 64-byte array.*/
 };
 
 struct cvmx_pki_style_tag_cfg {
 	struct cvmx_pki_tag_fields tag_fields;
-	struct cvmx_pki_mask_tag   mask_tag;
+	struct cvmx_pki_mask_tag mask_tag[4];
 };
 
 struct cvmx_pki_style_config {
diff --git a/arch/mips/include/asm/octeon/cvmx-sata-defs.h b/arch/mips/include/asm/octeon/cvmx-sata-defs.h
index 0d12d6e..fef85dc 100644
--- a/arch/mips/include/asm/octeon/cvmx-sata-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sata-defs.h
@@ -998,6 +998,39 @@ union cvmx_sata_uahc_gbl_gparam2r {
 	uint32_t u32;
 	struct cvmx_sata_uahc_gbl_gparam2r_s {
 #ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_31_31               : 1;
+	uint32_t rxoob_clk_units              : 1;  /**< RX OOB clock frequency units. */
+	uint32_t rxoob_clk_u                  : 10; /**< Upper bits of the RX OOB clock frequency. */
+	uint32_t bist_m                       : 1;  /**< BIST loopback checking depth (BIST_MODE). */
+	uint32_t fbs_mem_s                    : 1;  /**< Context RAM memory location (FBS_MEM_S). */
+	uint32_t fbs_pmpn                     : 2;  /**< Maximum number of port multiplier ports (FBS_PMPN_MAX). */
+	uint32_t fbs_support                  : 1;  /**< FIS-based switching support (FBS_SUPPORT). */
+	uint32_t dev_cp                       : 1;  /**< Cold presence detect (DEV_CP_DET). */
+	uint32_t dev_mp                       : 1;  /**< Mechanical presence switch (DEV_MP_SWITCH). */
+	uint32_t encode_m                     : 1;  /**< 8b/10b encoding/decoding (ENCODE_MODE). */
+	uint32_t rxoob_clk_m                  : 1;  /**< RX OOB clock mode (RXOOB_CLK_MODE). */
+	uint32_t rx_oob_m                     : 1;  /**< RX OOB mode (RX_OOB_MODE). */
+	uint32_t tx_oob_m                     : 1;  /**< TX OOB mode (TX_OOB_MODE). */
+	uint32_t reserved_0_8                 : 9;
+#else
+	uint32_t reserved_0_8                 : 9;
+	uint32_t tx_oob_m                     : 1;
+	uint32_t rx_oob_m                     : 1;
+	uint32_t rxoob_clk_m                  : 1;
+	uint32_t encode_m                     : 1;
+	uint32_t dev_mp                       : 1;
+	uint32_t dev_cp                       : 1;
+	uint32_t fbs_support                  : 1;
+	uint32_t fbs_pmpn                     : 2;
+	uint32_t fbs_mem_s                    : 1;
+	uint32_t bist_m                       : 1;
+	uint32_t rxoob_clk_u                  : 10;
+	uint32_t rxoob_clk_units              : 1;
+	uint32_t reserved_31_31               : 1;
+#endif
+	} s;
+	struct cvmx_sata_uahc_gbl_gparam2r_cn70xx {
+#ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_20_31               : 12;
 	uint32_t bist_m                       : 1;  /**< BIST loopback checking depth (BIST_MODE). */
 	uint32_t fbs_mem_s                    : 1;  /**< Context RAM memory location (FBS_MEM_S). */
@@ -1024,10 +1057,41 @@ union cvmx_sata_uahc_gbl_gparam2r {
 	uint32_t bist_m                       : 1;
 	uint32_t reserved_20_31               : 12;
 #endif
-	} s;
-	struct cvmx_sata_uahc_gbl_gparam2r_s  cn70xx;
-	struct cvmx_sata_uahc_gbl_gparam2r_s  cn70xxp1;
-	struct cvmx_sata_uahc_gbl_gparam2r_s  cn73xx;
+	} cn70xx;
+	struct cvmx_sata_uahc_gbl_gparam2r_cn70xx cn70xxp1;
+	struct cvmx_sata_uahc_gbl_gparam2r_cn73xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint32_t reserved_31_31               : 1;
+	uint32_t rxoob_clk_units              : 1;  /**< RX OOB clock frequency units. */
+	uint32_t rxoob_clk_u                  : 10; /**< Upper bits of the RX OOB clock frequency. */
+	uint32_t bist_m                       : 1;  /**< BIST loopback checking depth (BIST_MODE). */
+	uint32_t fbs_mem_s                    : 1;  /**< Context RAM memory location (FBS_MEM_S). */
+	uint32_t fbs_pmpn                     : 2;  /**< Maximum number of port multiplier ports (FBS_PMPN_MAX). */
+	uint32_t fbs_support                  : 1;  /**< FIS-based switching support (FBS_SUPPORT). */
+	uint32_t dev_cp                       : 1;  /**< Cold presence detect (DEV_CP_DET). */
+	uint32_t dev_mp                       : 1;  /**< Mechanical presence switch (DEV_MP_SWITCH). */
+	uint32_t encode_m                     : 1;  /**< 8b/10b encoding/decoding (ENCODE_MODE). */
+	uint32_t rxoob_clk_m                  : 1;  /**< RX OOB clock mode (RXOOB_CLK_MODE). */
+	uint32_t rx_oob_m                     : 1;  /**< RX OOB mode (RX_OOB_MODE). */
+	uint32_t tx_oob_m                     : 1;  /**< TX OOB mode (TX_OOB_MODE). */
+	uint32_t rxoob_clk_l                  : 9;  /**< RX OOB clock frequency (RXOOB_CLK). */
+#else
+	uint32_t rxoob_clk_l                  : 9;
+	uint32_t tx_oob_m                     : 1;
+	uint32_t rx_oob_m                     : 1;
+	uint32_t rxoob_clk_m                  : 1;
+	uint32_t encode_m                     : 1;
+	uint32_t dev_mp                       : 1;
+	uint32_t dev_cp                       : 1;
+	uint32_t fbs_support                  : 1;
+	uint32_t fbs_pmpn                     : 2;
+	uint32_t fbs_mem_s                    : 1;
+	uint32_t bist_m                       : 1;
+	uint32_t rxoob_clk_u                  : 10;
+	uint32_t rxoob_clk_units              : 1;
+	uint32_t reserved_31_31               : 1;
+#endif
+	} cn73xx;
 };
 typedef union cvmx_sata_uahc_gbl_gparam2r cvmx_sata_uahc_gbl_gparam2r_t;
 
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index 6e197ca..9c86091 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -56,12 +56,43 @@
 #define CVMX_SLI_BIST_STATUS CVMX_SLI_BIST_STATUS_FUNC()
 static inline uint64_t CVMX_SLI_BIST_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_BIST_STATUS not supported on this chip\n");
-	return 0x0000000000000580ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0000000000010580ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0000000000028580ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_BIST_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0000000000028580ull);
 }
 #else
-#define CVMX_SLI_BIST_STATUS (0x0000000000000580ull)
+#define CVMX_SLI_BIST_STATUS CVMX_SLI_BIST_STATUS_FUNC()
+static inline uint64_t CVMX_SLI_BIST_STATUS_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0000000000010580ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0000000000028580ull);
+	}
+	return CVMX_ADD_IO_SEG(0x0000000000028580ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_CIU_INT_ENB CVMX_SLI_CIU_INT_ENB_FUNC()
@@ -88,43 +119,140 @@ static inline uint64_t CVMX_SLI_CIU_INT_SUM_FUNC(void)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_CTL_PORTX(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_SLI_CTL_PORTX(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000050ull + ((offset) & 3) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 1) * 16;
+			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 3) * 16;
+			break;
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + ((offset) & 3) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011F00000106E0ull) + ((offset) & 3) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + ((offset) & 3) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_CTL_PORTX (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + ((offset) & 3) * 16;
 }
 #else
-#define CVMX_SLI_CTL_PORTX(offset) (0x0000000000000050ull + ((offset) & 3) * 16)
+static inline uint64_t CVMX_SLI_CTL_PORTX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 16;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 16;
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010050ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000106E0ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + (offset) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000286E0ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_CTL_STATUS CVMX_SLI_CTL_STATUS_FUNC()
 static inline uint64_t CVMX_SLI_CTL_STATUS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_CTL_STATUS not supported on this chip\n");
-	return 0x0000000000000570ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0000000000010570ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0000000000028570ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_CTL_STATUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0000000000028570ull);
 }
 #else
-#define CVMX_SLI_CTL_STATUS (0x0000000000000570ull)
+#define CVMX_SLI_CTL_STATUS CVMX_SLI_CTL_STATUS_FUNC()
+static inline uint64_t CVMX_SLI_CTL_STATUS_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0000000000010570ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x0000000000028570ull);
+	}
+	return CVMX_ADD_IO_SEG(0x0000000000028570ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_DATA_OUT_CNT CVMX_SLI_DATA_OUT_CNT_FUNC()
 static inline uint64_t CVMX_SLI_DATA_OUT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_DATA_OUT_CNT not supported on this chip\n");
-	return 0x00000000000005F0ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000105F0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000285F0ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_DATA_OUT_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F00000285F0ull);
 }
 #else
-#define CVMX_SLI_DATA_OUT_CNT (0x00000000000005F0ull)
+#define CVMX_SLI_DATA_OUT_CNT CVMX_SLI_DATA_OUT_CNT_FUNC()
+static inline uint64_t CVMX_SLI_DATA_OUT_CNT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000105F0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000285F0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000285F0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_DBG_DATA CVMX_SLI_DBG_DATA_FUNC()
@@ -151,59 +279,128 @@ static inline uint64_t CVMX_SLI_DBG_SELECT_FUNC(void)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_DMAX_CNT(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_SLI_DMAX_CNT(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000400ull + ((offset) & 1) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F0000010400ull) + ((offset) & 1) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F0000028400ull) + ((offset) & 1) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_DMAX_CNT (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000028400ull) + ((offset) & 1) * 16;
 }
 #else
-#define CVMX_SLI_DMAX_CNT(offset) (0x0000000000000400ull + ((offset) & 1) * 16)
+static inline uint64_t CVMX_SLI_DMAX_CNT(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010400ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028400ull) + (offset) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028400ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_DMAX_INT_LEVEL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_SLI_DMAX_INT_LEVEL(%lu) is invalid on this chip\n", offset);
-	return 0x00000000000003E0ull + ((offset) & 1) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F00000103E0ull) + ((offset) & 1) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F00000283E0ull) + ((offset) & 1) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_DMAX_INT_LEVEL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F00000283E0ull) + ((offset) & 1) * 16;
 }
 #else
-#define CVMX_SLI_DMAX_INT_LEVEL(offset) (0x00000000000003E0ull + ((offset) & 1) * 16)
+static inline uint64_t CVMX_SLI_DMAX_INT_LEVEL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000103E0ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000283E0ull) + (offset) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000283E0ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_DMAX_TIM(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 1)))))
-		cvmx_warn("CVMX_SLI_DMAX_TIM(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000420ull + ((offset) & 1) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F0000010420ull) + ((offset) & 1) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F0000028420ull) + ((offset) & 1) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_DMAX_TIM (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000028420ull) + ((offset) & 1) * 16;
 }
 #else
-#define CVMX_SLI_DMAX_TIM(offset) (0x0000000000000420ull + ((offset) & 1) * 16)
+static inline uint64_t CVMX_SLI_DMAX_TIM(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010420ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028420ull) + (offset) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028420ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_INT_ENB_CIU CVMX_SLI_INT_ENB_CIU_FUNC()
@@ -412,28 +609,6 @@ static inline uint64_t CVMX_SLI_MACX_PFX_PP_VF_INT_ENB(unsigned long offset, uns
 #define CVMX_SLI_MAC_CREDIT_CNT CVMX_SLI_MAC_CREDIT_CNT_FUNC()
 static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_MAC_CREDIT_CNT not supported on this chip\n");
-	return 0x0000000000003D70ull;
-}
-#else
-#define CVMX_SLI_MAC_CREDIT_CNT (0x0000000000003D70ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_SLI_MAC_CREDIT_CNT2 CVMX_SLI_MAC_CREDIT_CNT2_FUNC()
-static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT2_FUNC(void)
-{
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_MAC_CREDIT_CNT2 not supported on this chip\n");
-	return 0x0000000000003E10ull;
-}
-#else
-#define CVMX_SLI_MAC_CREDIT_CNT2 (0x0000000000003E10ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_SLI_MAC_NUMBER CVMX_SLI_MAC_NUMBER_FUNC()
-static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
-{
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
@@ -442,19 +617,19 @@ static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000003E00ull;
+			return CVMX_ADD_IO_SEG(0x00011F0000013D70ull);
 			break;
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000020050ull;
+			return CVMX_ADD_IO_SEG(0x00011F0000023D70ull);
 			break;
 	}
-	cvmx_warn("CVMX_SLI_MAC_NUMBER not supported on this chip\n");
-	return 0x0000000000020050ull;
+	cvmx_warn("CVMX_SLI_MAC_CREDIT_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023D70ull);
 }
 #else
-#define CVMX_SLI_MAC_NUMBER CVMX_SLI_MAC_NUMBER_FUNC()
-static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
+#define CVMX_SLI_MAC_CREDIT_CNT CVMX_SLI_MAC_CREDIT_CNT_FUNC()
+static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
 		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
@@ -464,43 +639,177 @@ static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
 		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000003E00ull;
+			return CVMX_ADD_IO_SEG(0x00011F0000013D70ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return 0x0000000000020050ull;
+			return CVMX_ADD_IO_SEG(0x00011F0000023D70ull);
 	}
-	return 0x0000000000020050ull;
+	return CVMX_ADD_IO_SEG(0x00011F0000023D70ull);
 }
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_SLI_MEM_ACCESS_CTL CVMX_SLI_MEM_ACCESS_CTL_FUNC()
-static inline uint64_t CVMX_SLI_MEM_ACCESS_CTL_FUNC(void)
+#define CVMX_SLI_MAC_CREDIT_CNT2 CVMX_SLI_MAC_CREDIT_CNT2_FUNC()
+static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_MEM_ACCESS_CTL not supported on this chip\n");
-	return 0x00000000000002F0ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013E10ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023E10ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MAC_CREDIT_CNT2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023E10ull);
 }
 #else
-#define CVMX_SLI_MEM_ACCESS_CTL (0x00000000000002F0ull)
+#define CVMX_SLI_MAC_CREDIT_CNT2 CVMX_SLI_MAC_CREDIT_CNT2_FUNC()
+static inline uint64_t CVMX_SLI_MAC_CREDIT_CNT2_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013E10ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023E10ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023E10ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SLI_MAC_NUMBER CVMX_SLI_MAC_NUMBER_FUNC()
+static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000003E00ull;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020050ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MAC_NUMBER not supported on this chip\n");
+	return 0x0000000000020050ull;
+}
+#else
+#define CVMX_SLI_MAC_NUMBER CVMX_SLI_MAC_NUMBER_FUNC()
+static inline uint64_t CVMX_SLI_MAC_NUMBER_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000003E00ull;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return 0x0000000000020050ull;
+	}
+	return 0x0000000000020050ull;
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SLI_MEM_ACCESS_CTL CVMX_SLI_MEM_ACCESS_CTL_FUNC()
+static inline uint64_t CVMX_SLI_MEM_ACCESS_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000102F0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000282F0ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MEM_ACCESS_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F00000282F0ull);
+}
+#else
+#define CVMX_SLI_MEM_ACCESS_CTL CVMX_SLI_MEM_ACCESS_CTL_FUNC()
+static inline uint64_t CVMX_SLI_MEM_ACCESS_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000102F0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000282F0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000282F0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && (((offset >= 12) && (offset <= 27)))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset >= 12) && (offset <= 27))))))
-		cvmx_warn("CVMX_SLI_MEM_ACCESS_SUBIDX(%lu) is invalid on this chip\n", offset);
-	return 0x00000000000000E0ull + ((offset) & 31) * 16 - 16*12;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if (((offset >= 12) && (offset <= 27)))
+				return CVMX_ADD_IO_SEG(0x00011F00000100E0ull) + ((offset) & 31) * 16 - 16*12;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if (((offset >= 12) && (offset <= 27)))
+				return CVMX_ADD_IO_SEG(0x00011F00000280E0ull) + ((offset) & 31) * 16 - 16*12;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MEM_ACCESS_SUBIDX (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F00000280E0ull) + ((offset) & 31) * 16 - 16*12;
 }
 #else
-#define CVMX_SLI_MEM_ACCESS_SUBIDX(offset) (0x00000000000000E0ull + ((offset) & 31) * 16 - 16*12)
+static inline uint64_t CVMX_SLI_MEM_ACCESS_SUBIDX(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000100E0ull) + (offset) * 16 - 16*12;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000280E0ull) + (offset) * 16 - 16*12;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000280E0ull) + (offset) * 16 - 16*12;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_MEM_CTL CVMX_SLI_MEM_CTL_FUNC()
@@ -752,68 +1061,223 @@ static inline uint64_t CVMX_SLI_MSI_ENB3_FUNC(void)
 #define CVMX_SLI_MSI_RCV0 CVMX_SLI_MSI_RCV0_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV0_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_MSI_RCV0 not supported on this chip\n");
-	return 0x0000000000003C10ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C10ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C10ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MSI_RCV0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023C10ull);
 }
 #else
-#define CVMX_SLI_MSI_RCV0 (0x0000000000003C10ull)
+#define CVMX_SLI_MSI_RCV0 CVMX_SLI_MSI_RCV0_FUNC()
+static inline uint64_t CVMX_SLI_MSI_RCV0_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C10ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C10ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023C10ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_MSI_RCV1 CVMX_SLI_MSI_RCV1_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_MSI_RCV1 not supported on this chip\n");
-	return 0x0000000000003C20ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C20ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C20ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MSI_RCV1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023C20ull);
 }
 #else
-#define CVMX_SLI_MSI_RCV1 (0x0000000000003C20ull)
+#define CVMX_SLI_MSI_RCV1 CVMX_SLI_MSI_RCV1_FUNC()
+static inline uint64_t CVMX_SLI_MSI_RCV1_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C20ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C20ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023C20ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_MSI_RCV2 CVMX_SLI_MSI_RCV2_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_MSI_RCV2 not supported on this chip\n");
-	return 0x0000000000003C30ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C30ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C30ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MSI_RCV2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023C30ull);
 }
 #else
-#define CVMX_SLI_MSI_RCV2 (0x0000000000003C30ull)
+#define CVMX_SLI_MSI_RCV2 CVMX_SLI_MSI_RCV2_FUNC()
+static inline uint64_t CVMX_SLI_MSI_RCV2_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C30ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C30ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023C30ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_MSI_RCV3 CVMX_SLI_MSI_RCV3_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RCV3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_MSI_RCV3 not supported on this chip\n");
-	return 0x0000000000003C40ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C40ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C40ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MSI_RCV3 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023C40ull);
 }
 #else
-#define CVMX_SLI_MSI_RCV3 (0x0000000000003C40ull)
+#define CVMX_SLI_MSI_RCV3 CVMX_SLI_MSI_RCV3_FUNC()
+static inline uint64_t CVMX_SLI_MSI_RCV3_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C40ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C40ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023C40ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_MSI_RD_MAP CVMX_SLI_MSI_RD_MAP_FUNC()
 static inline uint64_t CVMX_SLI_MSI_RD_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_MSI_RD_MAP not supported on this chip\n");
-	return 0x0000000000003CA0ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013CA0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023CA0ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MSI_RD_MAP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023CA0ull);
 }
 #else
-#define CVMX_SLI_MSI_RD_MAP (0x0000000000003CA0ull)
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_SLI_MSI_W1C_ENB0 CVMX_SLI_MSI_W1C_ENB0_FUNC()
-static inline uint64_t CVMX_SLI_MSI_W1C_ENB0_FUNC(void)
+#define CVMX_SLI_MSI_RD_MAP CVMX_SLI_MSI_RD_MAP_FUNC()
+static inline uint64_t CVMX_SLI_MSI_RD_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
-		cvmx_warn("CVMX_SLI_MSI_W1C_ENB0 not supported on this chip\n");
-	return 0x0000000000003CF0ull;
-}
-#else
-#define CVMX_SLI_MSI_W1C_ENB0 (0x0000000000003CF0ull)
-#endif
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013CA0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023CA0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023CA0ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SLI_MSI_W1C_ENB0 CVMX_SLI_MSI_W1C_ENB0_FUNC()
+static inline uint64_t CVMX_SLI_MSI_W1C_ENB0_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX)))
+		cvmx_warn("CVMX_SLI_MSI_W1C_ENB0 not supported on this chip\n");
+	return 0x0000000000003CF0ull;
+}
+#else
+#define CVMX_SLI_MSI_W1C_ENB0 (0x0000000000003CF0ull)
+#endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_MSI_W1C_ENB1 CVMX_SLI_MSI_W1C_ENB1_FUNC()
 static inline uint64_t CVMX_SLI_MSI_W1C_ENB1_FUNC(void)
@@ -895,12 +1359,43 @@ static inline uint64_t CVMX_SLI_MSI_W1S_ENB3_FUNC(void)
 #define CVMX_SLI_MSI_WR_MAP CVMX_SLI_MSI_WR_MAP_FUNC()
 static inline uint64_t CVMX_SLI_MSI_WR_MAP_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_MSI_WR_MAP not supported on this chip\n");
-	return 0x0000000000003C90ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C90ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C90ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_MSI_WR_MAP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023C90ull);
 }
 #else
-#define CVMX_SLI_MSI_WR_MAP (0x0000000000003C90ull)
+#define CVMX_SLI_MSI_WR_MAP CVMX_SLI_MSI_WR_MAP_FUNC()
+static inline uint64_t CVMX_SLI_MSI_WR_MAP_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013C90ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023C90ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023C90ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_NQM_RSP_ERR_SND_DBG CVMX_SLI_NQM_RSP_ERR_SND_DBG_FUNC()
@@ -917,64 +1412,215 @@ static inline uint64_t CVMX_SLI_NQM_RSP_ERR_SND_DBG_FUNC(void)
 #define CVMX_SLI_PCIE_MSI_RCV CVMX_SLI_PCIE_MSI_RCV_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV not supported on this chip\n");
-	return 0x0000000000003CB0ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013CB0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023CB0ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PCIE_MSI_RCV not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000023CB0ull);
 }
 #else
-#define CVMX_SLI_PCIE_MSI_RCV (0x0000000000003CB0ull)
+#define CVMX_SLI_PCIE_MSI_RCV CVMX_SLI_PCIE_MSI_RCV_FUNC()
+static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013CB0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023CB0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023CB0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PCIE_MSI_RCV_B1 CVMX_SLI_PCIE_MSI_RCV_B1_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B1 not supported on this chip\n");
-	return 0x0000000000000650ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010650ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028650ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028650ull);
 }
 #else
-#define CVMX_SLI_PCIE_MSI_RCV_B1 (0x0000000000000650ull)
+#define CVMX_SLI_PCIE_MSI_RCV_B1 CVMX_SLI_PCIE_MSI_RCV_B1_FUNC()
+static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B1_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010650ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028650ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028650ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PCIE_MSI_RCV_B2 CVMX_SLI_PCIE_MSI_RCV_B2_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B2 not supported on this chip\n");
-	return 0x0000000000000660ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010660ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028660ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028660ull);
 }
 #else
-#define CVMX_SLI_PCIE_MSI_RCV_B2 (0x0000000000000660ull)
+#define CVMX_SLI_PCIE_MSI_RCV_B2 CVMX_SLI_PCIE_MSI_RCV_B2_FUNC()
+static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B2_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010660ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028660ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028660ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PCIE_MSI_RCV_B3 CVMX_SLI_PCIE_MSI_RCV_B3_FUNC()
 static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B3 not supported on this chip\n");
-	return 0x0000000000000670ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010670ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028670ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PCIE_MSI_RCV_B3 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028670ull);
 }
 #else
-#define CVMX_SLI_PCIE_MSI_RCV_B3 (0x0000000000000670ull)
+#define CVMX_SLI_PCIE_MSI_RCV_B3 CVMX_SLI_PCIE_MSI_RCV_B3_FUNC()
+static inline uint64_t CVMX_SLI_PCIE_MSI_RCV_B3_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010670ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028670ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028670ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_CNTS(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_SLI_PKTX_CNTS(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002400ull + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F00000100B0ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKTX_CNTS (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F00000100B0ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_SLI_PKTX_CNTS(offset) (0x0000000000002400ull + ((offset) & 127) * 16)
+static inline uint64_t CVMX_SLI_PKTX_CNTS(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012400ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000100B0ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000100B0ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_ERROR_INFO(unsigned long offset)
@@ -1021,59 +1667,140 @@ static inline uint64_t CVMX_SLI_PKTX_INPUT_CONTROL(unsigned long offset)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_INSTR_BADDR(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_SLI_PKTX_INSTR_BADDR(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002800ull + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010010ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKTX_INSTR_BADDR (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010010ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_SLI_PKTX_INSTR_BADDR(offset) (0x0000000000002800ull + ((offset) & 127) * 16)
+static inline uint64_t CVMX_SLI_PKTX_INSTR_BADDR(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012800ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010010ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010010ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002C00ull + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010020ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKTX_INSTR_BAOFF_DBELL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010020ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(offset) (0x0000000000002C00ull + ((offset) & 127) * 16)
+static inline uint64_t CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012C00ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010020ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010020ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000003000ull + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010030ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKTX_INSTR_FIFO_RSIZE (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010030ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(offset) (0x0000000000003000ull + ((offset) & 127) * 16)
+static inline uint64_t CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013000ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010030ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010030ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_INSTR_HEADER(unsigned long offset)
@@ -1181,21 +1908,48 @@ static inline uint64_t CVMX_SLI_PKTX_OUTPUT_CONTROL(unsigned long offset)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_OUT_SIZE(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_SLI_PKTX_OUT_SIZE(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000000C00ull + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010060ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKTX_OUT_SIZE (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010060ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_SLI_PKTX_OUT_SIZE(offset) (0x0000000000000C00ull + ((offset) & 127) * 16)
+static inline uint64_t CVMX_SLI_PKTX_OUT_SIZE(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010C00ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010060ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010060ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_PF_VF_MBOX_SIGX(unsigned long offset, unsigned long block_id)
@@ -1212,59 +1966,140 @@ static inline uint64_t CVMX_SLI_PKTX_PF_VF_MBOX_SIGX(unsigned long offset, unsig
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_SLIST_BADDR(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_SLI_PKTX_SLIST_BADDR(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000001400ull + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010070ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKTX_SLIST_BADDR (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010070ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_SLI_PKTX_SLIST_BADDR(offset) (0x0000000000001400ull + ((offset) & 127) * 16)
+static inline uint64_t CVMX_SLI_PKTX_SLIST_BADDR(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011400ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010070ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010070ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000001800ull + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010080ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKTX_SLIST_BAOFF_DBELL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010080ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(offset) (0x0000000000001800ull + ((offset) & 127) * 16)
+static inline uint64_t CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011800ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010080ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010080ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000001C00ull + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010090ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKTX_SLIST_FIFO_RSIZE (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010090ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(offset) (0x0000000000001C00ull + ((offset) & 127) * 16)
+static inline uint64_t CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011C00ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010090ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010090ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKTX_VF_INT_SUM(unsigned long offset)
@@ -1295,21 +2130,52 @@ static inline uint64_t CVMX_SLI_PKT_BIST_STATUS_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_BIST_STATUS not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000029220ull);
+	return 0x0000000000029220ull;
 }
 #else
-#define CVMX_SLI_PKT_BIST_STATUS (CVMX_ADD_IO_SEG(0x00011F0000029220ull))
+#define CVMX_SLI_PKT_BIST_STATUS (0x0000000000029220ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_CNT_INT CVMX_SLI_PKT_CNT_INT_FUNC()
 static inline uint64_t CVMX_SLI_PKT_CNT_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_PKT_CNT_INT not supported on this chip\n");
-	return 0x0000000000001130ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011130ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029130ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKT_CNT_INT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029130ull);
 }
 #else
-#define CVMX_SLI_PKT_CNT_INT (0x0000000000001130ull)
+#define CVMX_SLI_PKT_CNT_INT CVMX_SLI_PKT_CNT_INT_FUNC()
+static inline uint64_t CVMX_SLI_PKT_CNT_INT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011130ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029130ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000029130ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_CNT_INT_ENB CVMX_SLI_PKT_CNT_INT_ENB_FUNC()
@@ -1383,10 +2249,10 @@ static inline uint64_t CVMX_SLI_PKT_GBL_CONTROL_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_GBL_CONTROL not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000029210ull);
+	return 0x0000000000029210ull;
 }
 #else
-#define CVMX_SLI_PKT_GBL_CONTROL (CVMX_ADD_IO_SEG(0x00011F0000029210ull))
+#define CVMX_SLI_PKT_GBL_CONTROL (0x0000000000029210ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_INPUT_CONTROL CVMX_SLI_PKT_INPUT_CONTROL_FUNC()
@@ -1487,32 +2353,90 @@ static inline uint64_t CVMX_SLI_PKT_IN_BP_FUNC(void)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 127))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 63))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 31))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 127)))))
-		cvmx_warn("CVMX_SLI_PKT_IN_DONEX_CNTS(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000002000ull + ((offset) & 127) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 31))
+				return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + ((offset) & 31) * 16;
+			break;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 63))
+				return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + ((offset) & 63) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 127))
+				return CVMX_ADD_IO_SEG(0x00011F0000010040ull) + ((offset) & 127) * 0x20000ull;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKT_IN_DONEX_CNTS (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000010040ull) + ((offset) & 127) * 0x20000ull;
 }
 #else
-#define CVMX_SLI_PKT_IN_DONEX_CNTS(offset) (0x0000000000002000ull + ((offset) & 127) * 16)
+static inline uint64_t CVMX_SLI_PKT_IN_DONEX_CNTS(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + (offset) * 16;
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000012000ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010040ull) + (offset) * 0x20000ull;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000010040ull) + (offset) * 0x20000ull;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_IN_INSTR_COUNTS CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC()
 static inline uint64_t CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_PKT_IN_INSTR_COUNTS not supported on this chip\n");
-	return 0x0000000000001200ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011200ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029200ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKT_IN_INSTR_COUNTS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029200ull);
 }
 #else
-#define CVMX_SLI_PKT_IN_INSTR_COUNTS (0x0000000000001200ull)
+#define CVMX_SLI_PKT_IN_INSTR_COUNTS CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC()
+static inline uint64_t CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011200ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029200ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000029200ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_IN_INT CVMX_SLI_PKT_IN_INT_FUNC()
@@ -1550,10 +2474,10 @@ static inline uint64_t CVMX_SLI_PKT_IN_JABBER_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_IN_JABBER not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000029170ull);
+	return 0x0000000000029170ull;
 }
 #else
-#define CVMX_SLI_PKT_IN_JABBER (CVMX_ADD_IO_SEG(0x00011F0000029170ull))
+#define CVMX_SLI_PKT_IN_JABBER (0x0000000000029170ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_IN_PCIE_PORT CVMX_SLI_PKT_IN_PCIE_PORT_FUNC()
@@ -1583,10 +2507,10 @@ static inline uint64_t CVMX_SLI_PKT_MAC0_SIG0_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_MAC0_SIG0 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000011300ull);
+	return 0x0000000000011300ull;
 }
 #else
-#define CVMX_SLI_PKT_MAC0_SIG0 (CVMX_ADD_IO_SEG(0x00011F0000011300ull))
+#define CVMX_SLI_PKT_MAC0_SIG0 (0x0000000000011300ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_MAC0_SIG1 CVMX_SLI_PKT_MAC0_SIG1_FUNC()
@@ -1594,10 +2518,10 @@ static inline uint64_t CVMX_SLI_PKT_MAC0_SIG1_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_MAC0_SIG1 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000011310ull);
+	return 0x0000000000011310ull;
 }
 #else
-#define CVMX_SLI_PKT_MAC0_SIG1 (CVMX_ADD_IO_SEG(0x00011F0000011310ull))
+#define CVMX_SLI_PKT_MAC0_SIG1 (0x0000000000011310ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_MAC1_SIG0 CVMX_SLI_PKT_MAC1_SIG0_FUNC()
@@ -1605,10 +2529,10 @@ static inline uint64_t CVMX_SLI_PKT_MAC1_SIG0_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_MAC1_SIG0 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000011320ull);
+	return 0x0000000000011320ull;
 }
 #else
-#define CVMX_SLI_PKT_MAC1_SIG0 (CVMX_ADD_IO_SEG(0x00011F0000011320ull))
+#define CVMX_SLI_PKT_MAC1_SIG0 (0x0000000000011320ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_MAC1_SIG1 CVMX_SLI_PKT_MAC1_SIG1_FUNC()
@@ -1616,10 +2540,10 @@ static inline uint64_t CVMX_SLI_PKT_MAC1_SIG1_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
 		cvmx_warn("CVMX_SLI_PKT_MAC1_SIG1 not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000011330ull);
+	return 0x0000000000011330ull;
 }
 #else
-#define CVMX_SLI_PKT_MAC1_SIG1 (CVMX_ADD_IO_SEG(0x00011F0000011330ull))
+#define CVMX_SLI_PKT_MAC1_SIG1 (0x0000000000011330ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_PKT_MACX_PFX_RINFO(unsigned long offset, unsigned long block_id)
@@ -1657,33 +2581,64 @@ static inline uint64_t CVMX_SLI_PKT_MEM_CTL_FUNC(void)
 			return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
 			break;
 	}
-	cvmx_warn("CVMX_SLI_PKT_MEM_CTL not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
+	cvmx_warn("CVMX_SLI_PKT_MEM_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
+}
+#else
+#define CVMX_SLI_PKT_MEM_CTL CVMX_SLI_PKT_MEM_CTL_FUNC()
+static inline uint64_t CVMX_SLI_PKT_MEM_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
+}
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_SLI_PKT_OUTPUT_WMARK CVMX_SLI_PKT_OUTPUT_WMARK_FUNC()
+static inline uint64_t CVMX_SLI_PKT_OUTPUT_WMARK_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011180ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029180ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKT_OUTPUT_WMARK not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029180ull);
 }
 #else
-#define CVMX_SLI_PKT_MEM_CTL CVMX_SLI_PKT_MEM_CTL_FUNC()
-static inline uint64_t CVMX_SLI_PKT_MEM_CTL_FUNC(void)
+#define CVMX_SLI_PKT_OUTPUT_WMARK CVMX_SLI_PKT_OUTPUT_WMARK_FUNC()
+static inline uint64_t CVMX_SLI_PKT_OUTPUT_WMARK_FUNC(void)
 {
 	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011180ull);
 		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
 		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
-		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
-			return CVMX_ADD_IO_SEG(0x00011F0000011120ull);
+			return CVMX_ADD_IO_SEG(0x00011F0000029180ull);
 	}
-	return CVMX_ADD_IO_SEG(0x00011F0000029120ull);
-}
-#endif
-#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
-#define CVMX_SLI_PKT_OUTPUT_WMARK CVMX_SLI_PKT_OUTPUT_WMARK_FUNC()
-static inline uint64_t CVMX_SLI_PKT_OUTPUT_WMARK_FUNC(void)
-{
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_PKT_OUTPUT_WMARK not supported on this chip\n");
-	return 0x0000000000001180ull;
+	return CVMX_ADD_IO_SEG(0x00011F0000029180ull);
 }
-#else
-#define CVMX_SLI_PKT_OUTPUT_WMARK (0x0000000000001180ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_OUT_BMODE CVMX_SLI_PKT_OUT_BMODE_FUNC()
@@ -1713,10 +2668,10 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN2_W1C_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN2_W1C not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000029290ull);
+	return 0x0000000000029290ull;
 }
 #else
-#define CVMX_SLI_PKT_OUT_BP_EN2_W1C (CVMX_ADD_IO_SEG(0x00011F0000029290ull))
+#define CVMX_SLI_PKT_OUT_BP_EN2_W1C (0x0000000000029290ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_OUT_BP_EN2_W1S CVMX_SLI_PKT_OUT_BP_EN2_W1S_FUNC()
@@ -1724,10 +2679,10 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN2_W1S_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN2_W1S not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000029270ull);
+	return 0x0000000000029270ull;
 }
 #else
-#define CVMX_SLI_PKT_OUT_BP_EN2_W1S (CVMX_ADD_IO_SEG(0x00011F0000029270ull))
+#define CVMX_SLI_PKT_OUT_BP_EN2_W1S (0x0000000000029270ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_OUT_BP_EN_W1C CVMX_SLI_PKT_OUT_BP_EN_W1C_FUNC()
@@ -1735,10 +2690,10 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_W1C_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN_W1C not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000029280ull);
+	return 0x0000000000029280ull;
 }
 #else
-#define CVMX_SLI_PKT_OUT_BP_EN_W1C (CVMX_ADD_IO_SEG(0x00011F0000029280ull))
+#define CVMX_SLI_PKT_OUT_BP_EN_W1C (0x0000000000029280ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_OUT_BP_EN_W1S CVMX_SLI_PKT_OUT_BP_EN_W1S_FUNC()
@@ -1746,10 +2701,10 @@ static inline uint64_t CVMX_SLI_PKT_OUT_BP_EN_W1S_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_OUT_BP_EN_W1S not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000029260ull);
+	return 0x0000000000029260ull;
 }
 #else
-#define CVMX_SLI_PKT_OUT_BP_EN_W1S (CVMX_ADD_IO_SEG(0x00011F0000029260ull))
+#define CVMX_SLI_PKT_OUT_BP_EN_W1S (0x0000000000029260ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_OUT_ENB CVMX_SLI_PKT_OUT_ENB_FUNC()
@@ -1779,10 +2734,10 @@ static inline uint64_t CVMX_SLI_PKT_PKIND_VALID_FUNC(void)
 {
 	if (!(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
 		cvmx_warn("CVMX_SLI_PKT_PKIND_VALID not supported on this chip\n");
-	return CVMX_ADD_IO_SEG(0x00011F0000029190ull);
+	return 0x0000000000029190ull;
 }
 #else
-#define CVMX_SLI_PKT_PKIND_VALID (CVMX_ADD_IO_SEG(0x00011F0000029190ull))
+#define CVMX_SLI_PKT_PKIND_VALID (0x0000000000029190ull)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_PORT_IN_RST CVMX_SLI_PKT_PORT_IN_RST_FUNC()
@@ -1862,12 +2817,43 @@ static inline uint64_t CVMX_SLI_PKT_SLIST_ROR_FUNC(void)
 #define CVMX_SLI_PKT_TIME_INT CVMX_SLI_PKT_TIME_INT_FUNC()
 static inline uint64_t CVMX_SLI_PKT_TIME_INT_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_PKT_TIME_INT not supported on this chip\n");
-	return 0x0000000000001140ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011140ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029140ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_PKT_TIME_INT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000029140ull);
 }
 #else
-#define CVMX_SLI_PKT_TIME_INT (0x0000000000001140ull)
+#define CVMX_SLI_PKT_TIME_INT CVMX_SLI_PKT_TIME_INT_FUNC()
+static inline uint64_t CVMX_SLI_PKT_TIME_INT_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000011140ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000029140ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000029140ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_PKT_TIME_INT_ENB CVMX_SLI_PKT_TIME_INT_ENB_FUNC()
@@ -1935,76 +2921,262 @@ static inline uint64_t CVMX_SLI_S2C_END_MERGE_FUNC(void)
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_SLI_S2M_PORTX_CTL(unsigned long offset)
 {
-	if (!(
-	      (OCTEON_IS_MODEL(OCTEON_CN61XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN68XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN70XX) && ((offset <= 2))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && ((offset <= 3))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF71XX) && ((offset <= 1))) ||
-	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && ((offset <= 3)))))
-		cvmx_warn("CVMX_SLI_S2M_PORTX_CTL(%lu) is invalid on this chip\n", offset);
-	return 0x0000000000003D80ull + ((offset) & 3) * 16;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 1))
+				return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + ((offset) & 1) * 16;
+			break;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 2))
+				return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + ((offset) & 3) * 16;
+			break;
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + ((offset) & 3) * 16;
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			if ((offset <= 3))
+				return CVMX_ADD_IO_SEG(0x00011F0000023D80ull) + ((offset) & 3) * 16;
+			break;
+	}
+	cvmx_warn("CVMX_SLI_S2M_PORTX_CTL (offset = %lu) not supported on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011F0000023D80ull) + ((offset) & 3) * 16;
 }
 #else
-#define CVMX_SLI_S2M_PORTX_CTL(offset) (0x0000000000003D80ull + ((offset) & 3) * 16)
+static inline uint64_t CVMX_SLI_S2M_PORTX_CTL(unsigned long offset)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + (offset) * 16;
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + (offset) * 16;
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000013D80ull) + (offset) * 16;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000023D80ull) + (offset) * 16;
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000023D80ull) + (offset) * 16;
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_SCRATCH_1 CVMX_SLI_SCRATCH_1_FUNC()
 static inline uint64_t CVMX_SLI_SCRATCH_1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_SCRATCH_1 not supported on this chip\n");
-	return 0x00000000000003C0ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000103C0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000283C0ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_SCRATCH_1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F00000283C0ull);
 }
 #else
-#define CVMX_SLI_SCRATCH_1 (0x00000000000003C0ull)
+#define CVMX_SLI_SCRATCH_1 CVMX_SLI_SCRATCH_1_FUNC()
+static inline uint64_t CVMX_SLI_SCRATCH_1_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000103C0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000283C0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000283C0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_SCRATCH_2 CVMX_SLI_SCRATCH_2_FUNC()
 static inline uint64_t CVMX_SLI_SCRATCH_2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_SCRATCH_2 not supported on this chip\n");
-	return 0x00000000000003D0ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000103D0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000283D0ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_SCRATCH_2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F00000283D0ull);
 }
 #else
-#define CVMX_SLI_SCRATCH_2 (0x00000000000003D0ull)
+#define CVMX_SLI_SCRATCH_2 CVMX_SLI_SCRATCH_2_FUNC()
+static inline uint64_t CVMX_SLI_SCRATCH_2_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000103D0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F00000283D0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F00000283D0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_STATE1 CVMX_SLI_STATE1_FUNC()
 static inline uint64_t CVMX_SLI_STATE1_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_STATE1 not supported on this chip\n");
-	return 0x0000000000000620ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010620ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028620ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_STATE1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028620ull);
 }
 #else
-#define CVMX_SLI_STATE1 (0x0000000000000620ull)
+#define CVMX_SLI_STATE1 CVMX_SLI_STATE1_FUNC()
+static inline uint64_t CVMX_SLI_STATE1_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010620ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028620ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028620ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_STATE2 CVMX_SLI_STATE2_FUNC()
 static inline uint64_t CVMX_SLI_STATE2_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_STATE2 not supported on this chip\n");
-	return 0x0000000000000630ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010630ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028630ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_STATE2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028630ull);
 }
 #else
-#define CVMX_SLI_STATE2 (0x0000000000000630ull)
+#define CVMX_SLI_STATE2 CVMX_SLI_STATE2_FUNC()
+static inline uint64_t CVMX_SLI_STATE2_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010630ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028630ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028630ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_STATE3 CVMX_SLI_STATE3_FUNC()
 static inline uint64_t CVMX_SLI_STATE3_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_STATE3 not supported on this chip\n");
-	return 0x0000000000000640ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010640ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028640ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_STATE3 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011F0000028640ull);
 }
 #else
-#define CVMX_SLI_STATE3 (0x0000000000000640ull)
+#define CVMX_SLI_STATE3 CVMX_SLI_STATE3_FUNC()
+static inline uint64_t CVMX_SLI_STATE3_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000010640ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00011F0000028640ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00011F0000028640ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_TX_PIPE CVMX_SLI_TX_PIPE_FUNC()
@@ -2021,12 +3193,43 @@ static inline uint64_t CVMX_SLI_TX_PIPE_FUNC(void)
 #define CVMX_SLI_WINDOW_CTL CVMX_SLI_WINDOW_CTL_FUNC()
 static inline uint64_t CVMX_SLI_WINDOW_CTL_FUNC(void)
 {
-	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CN78XX) || OCTEON_IS_MODEL(OCTEON_CNF71XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)))
-		cvmx_warn("CVMX_SLI_WINDOW_CTL not supported on this chip\n");
-	return 0x00000000000002E0ull;
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00000000000102E0ull);
+			break;
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00000000000282E0ull);
+			break;
+	}
+	cvmx_warn("CVMX_SLI_WINDOW_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00000000000282E0ull);
 }
 #else
-#define CVMX_SLI_WINDOW_CTL (0x00000000000002E0ull)
+#define CVMX_SLI_WINDOW_CTL CVMX_SLI_WINDOW_CTL_FUNC()
+static inline uint64_t CVMX_SLI_WINDOW_CTL_FUNC(void)
+{
+	switch(cvmx_get_octeon_family()) {
+		case OCTEON_CNF71XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN61XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN70XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN66XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN78XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN63XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN68XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00000000000102E0ull);
+		case OCTEON_CNF75XX & OCTEON_FAMILY_MASK:
+		case OCTEON_CN73XX & OCTEON_FAMILY_MASK:
+			return CVMX_ADD_IO_SEG(0x00000000000282E0ull);
+	}
+	return CVMX_ADD_IO_SEG(0x00000000000282E0ull);
+}
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 #define CVMX_SLI_WIN_RD_ADDR CVMX_SLI_WIN_RD_ADDR_FUNC()
diff --git a/arch/mips/include/asm/octeon/octeon-feature.h b/arch/mips/include/asm/octeon/octeon-feature.h
index 69a42ac..7c3aa42 100644
--- a/arch/mips/include/asm/octeon/octeon-feature.h
+++ b/arch/mips/include/asm/octeon/octeon-feature.h
@@ -176,6 +176,8 @@ typedef enum {
 				/**<  On of the BGX is used for MIX */
 	OCTEON_FEATURE_HNA,
 				/**<  Octeon has HNA */
+	OCTEON_FEATURE_BGX_XCV,
+				/**< Octeon has BGX XCV RGMII support */
 	OCTEON_MAX_FEATURE
 } octeon_feature_t;
 
@@ -513,6 +515,10 @@ static inline int octeon_has_feature_OCTEON_FEATURE_BGX_MIX(void)
 		|| OCTEON_IS_MODEL(OCTEON_CN73XX));
 }
 
+static inline int octeon_has_feature_OCTEON_FEATURE_BGX_XCV(void)
+{
+	return OCTEON_IS_MODEL(OCTEON_CN73XX);
+}
 /*
  * bit map for octeon features
  */
-- 
2.6.2

