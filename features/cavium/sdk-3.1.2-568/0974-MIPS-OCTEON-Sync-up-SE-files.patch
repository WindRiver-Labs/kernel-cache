From 0ce711f69067280561f98364a132eb595d679b5a Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Thu, 19 Nov 2015 14:44:12 -0800
Subject: [PATCH 974/974] MIPS:OCTEON: Sync-up SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c | 57 +++++++++++++++++---
 .../cavium-octeon/executive/cvmx-helper-board.c    | 13 ++++-
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      | 60 +++++++++++++++++-----
 arch/mips/include/asm/octeon/cvmx-helper-bgx.h     |  1 +
 4 files changed, 110 insertions(+), 21 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 2fd823d..92f0a50 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -378,6 +378,50 @@ EXPORT_SYMBOL(__cvmx_helper_bgx_probe);
 
 /**
  * @INTERNAL
+ * Return the size of the BGX TX_FIFO for a given LMAC,
+ * or 0 if the requested LMAC is inactive.
+ *
+ * TBD: Need also to add a "__cvmx_helper_bgx_speed()" function to
+ * return the speed of each LMAC.
+ */
+int __cvmx_helper_bgx_fifo_size(int xiface, unsigned lmac)
+{
+	cvmx_bgxx_cmr_tx_lmacs_t lmacs;
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	unsigned tx_fifo_size = CVMX_BGX_TX_FIFO_SIZE;
+
+	/* FIXME: Add validation for interface# < BGX_count */
+	lmacs.u64 = cvmx_read_csr_node(xi.node,
+		CVMX_BGXX_CMR_TX_LMACS(xi.interface));
+
+	switch (lmacs.s.lmacs) {
+	case 1:
+		if (lmac > 0)
+			return 0;
+		else
+			return tx_fifo_size;
+	case 2:
+		if (lmac > 1)
+			return 0;
+		else
+			return tx_fifo_size >> 1;
+	case 3:
+		if (lmac > 2)
+			return 0;
+		else
+			return tx_fifo_size >> 2;
+	case 4:
+		if (lmac > 3)
+			return 0;
+		else
+			return tx_fifo_size >> 2;
+	default:
+		return 0;
+	}
+}
+
+/**
+ * @INTERNAL
  * Perform initialization required only once for an SGMII port.
  *
  * @param xiface Interface to init
@@ -1288,7 +1332,7 @@ int __cvmx_helper_bgx_port_init(int xipd_port, int phy_pres)
 			cvmx_write_csr(CVMX_XCV_RESET, xcv_reset.u64);
 		}
 	} else {
-		int res, lmacs, cred;
+		int res, cred;
 		cvmx_bgxx_smux_tx_thresh_t smu_tx_thresh;
 
 		res = __cvmx_helper_bgx_xaui_init(index, xiface);
@@ -1296,14 +1340,13 @@ int __cvmx_helper_bgx_port_init(int xipd_port, int phy_pres)
 			/*cvmx_dprintf("Failed to enable XAUI for %d:BGX(%d,%d)\n", xi.node, xi.interface, index);*/
 			return res;
 		}
-		/* Threshold value is calculated based on the PKO_MCI1_MAX_CRED(x)
-		 * description in HRM.*/
-		lmacs = __cvmx_helper_bgx_enumerate(xi.interface);
-		cred = CVMX_BGX_TX_FIFO_SIZE / lmacs / 16;
+		/* See BVX_SMU_TX_THRESH register descriptin */
+		cred = __cvmx_helper_bgx_fifo_size(xiface, index) >> 4;
 		smu_tx_thresh.u64 = 0;
 		smu_tx_thresh.s.cnt = cred - 10;
-		cvmx_write_csr_node(xi.node, CVMX_BGXX_SMUX_TX_THRESH(index, xi.interface),
-				    smu_tx_thresh.u64);
+		cvmx_write_csr_node(xi.node,
+			CVMX_BGXX_SMUX_TX_THRESH(index, xi.interface),
+			smu_tx_thresh.u64);
 		if (debug)
 			cvmx_dprintf("%s: BGX%d:%d TX-thresh=%d\n",
 				__func__, xi.interface, index, smu_tx_thresh.s.cnt);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
index 66e164f..b8b02fd 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
@@ -69,6 +69,7 @@
 #include "cvmx-helper-board.h"
 #include "cvmx-helper-cfg.h"
 #include "cvmx-gpio.h"
+#include "cvmx-qlm.h"
 #include "octeon_mem_map.h"
 #include "cvmx-bootmem.h"
 
@@ -2760,7 +2761,17 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 			case CVMX_HELPER_INTERFACE_MODE_QSGMII:
 			case CVMX_HELPER_INTERFACE_MODE_AGL:
 			case CVMX_HELPER_INTERFACE_MODE_SPI:
-				result.s.speed = 1000;
+				if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
+					struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+					uint64_t gbaud = cvmx_qlm_get_gbaud_mhz(0);
+					result.s.speed = gbaud * 8 / 10;
+					if (cvmx_qlm_get_dlm_mode(0, xi.interface) == CVMX_QLM_MODE_SGMII)
+						result.s.speed >>= 1;
+					else
+						result.s.speed >>= 2;
+				} else {
+					result.s.speed = 1000;
+				}
 				break;
 			case CVMX_HELPER_INTERFACE_MODE_RXAUI:
 			case CVMX_HELPER_INTERFACE_MODE_XAUI:
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index e9dae54..3d92fa1 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -47,6 +47,7 @@
 #include <asm/octeon/cvmx-pko3.h>
 #include <asm/octeon/cvmx-pko3-resources.h>
 #include <asm/octeon/cvmx-helper-pko3.h>
+#include <asm/octeon/cvmx-helper-bgx.h>
 #else
 #include "cvmx.h"
 #include "cvmx-hwpko.h"	/* For legacy support */
@@ -54,6 +55,7 @@
 #include "cvmx-pko3.h"
 #include "cvmx-pko3-resources.h"
 #include "cvmx-helper-pko3.h"
+#include "cvmx-helper-bgx.h"
 #include <errno.h>
 #endif
 
@@ -599,26 +601,51 @@ static int cvmx_pko_setup_macs(int node)
 			}
 
 			if(mode == CVMX_HELPER_INTERFACE_MODE_RXAUI) {
-				cvmx_pko3_mac_table[i].fifo_cnt = 2;
+				unsigned bgx_fifo_size = 
+				  __cvmx_helper_bgx_fifo_size(xiface, port);
+				cvmx_pko3_mac_table[i].mac_fifo_cnt = 
+				    bgx_fifo_size / (CVMX_BGX_TX_FIFO_SIZE/4);
 				cvmx_pko3_mac_table[i].pri = 2;
 				cvmx_pko3_mac_table[i].spd = 10;
-				cvmx_pko3_mac_table[i].mac_fifo_cnt = 2;
-			} else if (mode == CVMX_HELPER_INTERFACE_MODE_XAUI) {
+				cvmx_pko3_mac_table[i].fifo_cnt = 2;
+			} else if (mode == CVMX_HELPER_INTERFACE_MODE_XLAUI) {
+				unsigned bgx_fifo_size = 
+				  __cvmx_helper_bgx_fifo_size(xiface, port);
+				cvmx_pko3_mac_table[i].mac_fifo_cnt = 
+				    bgx_fifo_size / (CVMX_BGX_TX_FIFO_SIZE/4);
+				cvmx_pko3_mac_table[i].pri = 2;
+				cvmx_pko3_mac_table[i].spd = 40;
 				cvmx_pko3_mac_table[i].fifo_cnt = 4;
+			} else if (mode == CVMX_HELPER_INTERFACE_MODE_XAUI) {
+				unsigned bgx_fifo_size = 
+				  __cvmx_helper_bgx_fifo_size(xiface, port);
+				cvmx_pko3_mac_table[i].mac_fifo_cnt = 
+				    bgx_fifo_size / (CVMX_BGX_TX_FIFO_SIZE/4);
 				cvmx_pko3_mac_table[i].pri = 2;
+				cvmx_pko3_mac_table[i].fifo_cnt = 2;
 				/* DXAUI at 20G, or XAU at 10G */
 				cvmx_pko3_mac_table[i].spd = 20;
-				cvmx_pko3_mac_table[i].mac_fifo_cnt = 4;
 			} else if (mode == CVMX_HELPER_INTERFACE_MODE_XFI) {
-				cvmx_pko3_mac_table[i].fifo_cnt = 4;
+				unsigned bgx_fifo_size = 
+				  __cvmx_helper_bgx_fifo_size(xiface, port);
+				cvmx_pko3_mac_table[i].mac_fifo_cnt = 
+				    bgx_fifo_size / (CVMX_BGX_TX_FIFO_SIZE/4);
 				cvmx_pko3_mac_table[i].pri = 3;
+				cvmx_pko3_mac_table[i].fifo_cnt = 2;
 				cvmx_pko3_mac_table[i].spd = 10;
-				cvmx_pko3_mac_table[i].mac_fifo_cnt = 1;
 			} else if (mode == CVMX_HELPER_INTERFACE_MODE_XLAUI) {
-				cvmx_pko3_mac_table[i].fifo_cnt = 4;
+				unsigned bgx_fifo_size = 
+				  __cvmx_helper_bgx_fifo_size(xiface, port);
+				cvmx_pko3_mac_table[i].mac_fifo_cnt = 
+				    bgx_fifo_size / (CVMX_BGX_TX_FIFO_SIZE/4);
 				cvmx_pko3_mac_table[i].pri = 4;
+				cvmx_pko3_mac_table[i].fifo_cnt = 4;
 				cvmx_pko3_mac_table[i].spd = 40;
-				cvmx_pko3_mac_table[i].mac_fifo_cnt = 4;
+			} else if (mode == CVMX_HELPER_INTERFACE_MODE_LOOP) {
+				cvmx_pko3_mac_table[i].fifo_cnt = 1;
+				cvmx_pko3_mac_table[i].pri = 1;
+				cvmx_pko3_mac_table[i].spd = 1;
+				cvmx_pko3_mac_table[i].mac_fifo_cnt = 1;
 			} else if (mode == CVMX_HELPER_INTERFACE_MODE_ILK ||
 				mode == CVMX_HELPER_INTERFACE_MODE_SRIO) {
 				cvmx_pko3_mac_table[i].fifo_cnt = 4;
@@ -634,17 +661,24 @@ static int cvmx_pko_setup_macs(int node)
 				/* SLI Tx FIFO size to be revisitted */
 				cvmx_pko3_mac_table[i].mac_fifo_cnt = 1;
 			} else {
-				cvmx_pko3_mac_table[i].fifo_cnt = 1;
+				/* Assuming it is a BGX interface,
+ * 				   e.g. SGMII/RGMII or MIXED */
+				unsigned bgx_fifo_size = 
+				  __cvmx_helper_bgx_fifo_size(xiface, port);
+				cvmx_pko3_mac_table[i].mac_fifo_cnt = 
+				    bgx_fifo_size / (CVMX_BGX_TX_FIFO_SIZE/4);
+				cvmx_pko3_mac_table[i].fifo_cnt = 2;
 				cvmx_pko3_mac_table[i].pri = 1;
-				cvmx_pko3_mac_table[i].spd = 1;
-				cvmx_pko3_mac_table[i].mac_fifo_cnt = 1;
+				cvmx_pko3_mac_table[i].spd = 10;
 			}
 
 			if(debug)
-				cvmx_dprintf("%s: intf %d:%u port %u %s mac %02u cnt %u spd %u\n",
+				cvmx_dprintf("%s: intf %d:%u port %u %s mac %02u cnt %u macfifo %uk spd %u\n",
 					     __FUNCTION__, node, interface, port,
 				cvmx_helper_interface_mode_to_string(mode),
-				i, cvmx_pko3_mac_table[i].fifo_cnt,
+				i,
+				cvmx_pko3_mac_table[i].fifo_cnt,
+				cvmx_pko3_mac_table[i].mac_fifo_cnt*8,
 				cvmx_pko3_mac_table[i].spd);
 
 		} /* for port */
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-bgx.h b/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
index c1b7b8b..f6f520d 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-bgx.h
@@ -284,6 +284,7 @@ extern int __cvmx_helper_bgx_port_init(int xipd_port, int phy_pres);
 extern void cvmx_helper_bgx_set_jabber(int xiface, unsigned index, unsigned size);
 extern int cvmx_helper_bgx_shutdown_port(int xiface, int index);
 extern int cvmx_bgx_set_backpressure_override(int xiface, unsigned port_mask);
+extern int __cvmx_helper_bgx_fifo_size(int xiface, unsigned lmac);
 
 /**
  * Returns if an interface is RGMII or not
-- 
2.6.2

