From 762f7d1dd02d29163fb00c8d2935f56605fcf34a Mon Sep 17 00:00:00 2001
From: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
Date: Wed, 11 Sep 2013 10:29:21 -0700
Subject: [PATCH 299/974] MIPS: Octeon: Add HOTPLUG_CPU support in
 LITTLE_ENDIAN mode

At entry, the kernel will switch into LE mode when CONFIG_CPU_LITTLE_ENDIAN
is true, so it does not depend on the bootloader setting the correct
endianness either at boot entry or for hotplugged CPUs.
When a CPU is unplugged, it is switched to BE mode right before
it is returned back to the bootloader.

Signed-off-by: Leonid Rosenboim <lrosenboim@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/Kconfig                                  |  2 +-
 arch/mips/cavium-octeon/smp.c                      | 53 ++++++++++++++++------
 .../asm/mach-cavium-octeon/kernel-entry-init.h     | 17 ++++++-
 drivers/watchdog/Kconfig                           |  1 +
 4 files changed, 57 insertions(+), 16 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 467dfd8..b0e69ac 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -746,7 +746,7 @@ config CAVIUM_OCTEON_SOC
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select EDAC_SUPPORT
 	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_HOTPLUG_CPU if CPU_BIG_ENDIAN
+	select SYS_SUPPORTS_HOTPLUG_CPU
 	select SYS_HAS_EARLY_PRINTK
 	select SYS_HAS_CPU_CAVIUM_OCTEON
 	select SWAP_IO_SPACE
diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index a886099..d8fe68c 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -23,9 +23,9 @@
 #include <asm/octeon/cvmx-app-hotplug.h>
 #include <asm/octeon/cvmx-spinlock.h>
 
-volatile unsigned long octeon_processor_boot = 0xff;
-volatile unsigned long octeon_processor_sp;
-volatile unsigned long octeon_processor_gp;
+unsigned long octeon_processor_boot = 0xff;
+__cpuinitdata unsigned long octeon_processor_sp;
+__cpuinitdata unsigned long octeon_processor_gp;
 
 #ifdef CONFIG_HOTPLUG_CPU
 static uint32_t octeon_hotplug_entry_addr;
@@ -157,10 +157,6 @@ static inline void octeon_send_ipi_mask(const struct cpumask *mask,
 
 #ifdef CONFIG_HOTPLUG_CPU
 
-#ifndef	CVMX_HOTPLUG_MAGIC_VERSION
-#define CVMX_HOTPLUG_MAGIC_VERSION      0x1abe1000UL
-#endif
-
 /*
  * Initialize the content of struct * cvmx_app_hotplug_global
  * if it is allocated, atomically.
@@ -265,6 +261,7 @@ static void octeon_smp_setup(void)
 	/* Validate magic number */
 	if (hgp->magic_version != CVMX_HOTPLUG_MAGIC_VERSION) {
 		pr_err("Cavium Hotplug: data record invalid\n");
+		octeon_hotplug_entry_addr = 0;
 		return;
 	}
 
@@ -283,7 +280,7 @@ static void octeon_smp_setup(void)
  * Firmware CPU startup hook
  *
  */
-static void octeon_boot_secondary(int cpu, struct task_struct *idle)
+static void __cpuinit octeon_boot_secondary(int cpu, struct task_struct *idle)
 {
 	int count;
 
@@ -292,7 +289,13 @@ static void octeon_boot_secondary(int cpu, struct task_struct *idle)
 
 	octeon_processor_sp = __KSTK_TOS(idle);
 	octeon_processor_gp = (unsigned long)(task_thread_info(idle));
+	/* This barrier is needed to guarangee the following is done last */
+	mb();
+
+	/* Indicate which core is being brought up out of pan */
 	octeon_processor_boot = cpu_logical_map(cpu);
+
+	/* Push the last update out before polling */
 	mb();
 
 	count = 10000;
@@ -300,6 +303,7 @@ static void octeon_boot_secondary(int cpu, struct task_struct *idle)
 		/* Waiting for processor to get the SP and GP */
 		udelay(1);
 		count--;
+		mb();
 	}
 	if (count == 0)
 		pr_err("Secondary boot timeout\n");
@@ -487,17 +491,34 @@ static void octeon_cpu_die(unsigned int cpu)
 void play_dead(void)
 {
 	int cpu = cpu_number_map(cvmx_get_core_num());
+	register unsigned long v;
+	v = ~0ULL;
 
 	idle_task_exit();
-	octeon_processor_boot = 0xff;
+	octeon_processor_boot = v;
 	per_cpu(cpu_state, cpu) = CPU_DEAD;
 
 	wmb(); /* nudge writeback */
 
-	while (1)	/* core will be reset here */
-		;
+#ifdef	CONFIG_CPU_LITTLE_ENDIAN
+	/* Switch CPU core back to Big Endian mode */
+	CVMX_MF_CVM_CTL(v);
+	v &= ~2;
+	CVMX_MT_CVM_CTL(v);
+	mb();
+#endif	/*CONFIG_CPU_LITTLE_ENDIAN*/
+
+	while (1) {	/* core will be reset here */
+		asm volatile ("nop\n wait\n nop\n");
+	}
 }
 
+#ifdef	CONFIG_CPU_LITTLE_ENDIAN
+# ifdef __BIG_ENDIAN_BITFIELD
+#   error "Endian Configuration Mismatch"
+# endif
+#endif
+
 static int octeon_update_boot_vector(unsigned int cpu)
 {
 	int coreid = cpu_logical_map(cpu);
@@ -520,14 +541,18 @@ static int octeon_update_boot_vector(unsigned int cpu)
 		return -EINVAL;
 	}
 
-	cvmx_spinlock_lock(&hgp->hotplug_global_lock);
 	/*
 	 * A core being brought up must be present either in the boot
 	 * core_mask or in the hotplug available coremask
 	 */
 	if (boot_core_mask & (1 << coreid)) {
 		boot_core_mask &= ~(1 << coreid);
-	} else if (!cvmx_coremask_is_core_set(&hgp->avail_coremask, coreid)) {
+		/* CPU in boot core mask needs no further handling */
+		return 0;
+	}
+
+	cvmx_spinlock_lock(&hgp->hotplug_global_lock);
+	if (!cvmx_coremask_is_core_set(&hgp->avail_coremask, coreid)) {
 		cvmx_spinlock_unlock(&hgp->hotplug_global_lock);
 		pr_warn("Cavium Hotplog: cpu %u core %u is not available\n",
 			cpu, coreid);
@@ -556,7 +581,7 @@ static int __cpuinit octeon_cpu_callback(struct notifier_block *nfb,
 	unsigned long action, void *hcpu)
 {
 	unsigned int cpu = (unsigned long)hcpu;
-	int ret;
+	int ret = 0;
 
 	switch (action) {
 	case CPU_UP_PREPARE_FROZEN:
diff --git a/arch/mips/include/asm/mach-cavium-octeon/kernel-entry-init.h b/arch/mips/include/asm/mach-cavium-octeon/kernel-entry-init.h
index 17dbc66..c094113 100644
--- a/arch/mips/include/asm/mach-cavium-octeon/kernel-entry-init.h
+++ b/arch/mips/include/asm/mach-cavium-octeon/kernel-entry-init.h
@@ -8,6 +8,8 @@
 #ifndef __ASM_MACH_CAVIUM_OCTEON_KERNEL_ENTRY_H
 #define __ASM_MACH_CAVIUM_OCTEON_KERNEL_ENTRY_H
 
+#include "asm/octeon/cvmx-asm.h"
+
 #define CP0_CVMCTL_REG $9, 7
 #define CP0_CVMMEMCTL_REG $11,7
 #define CP0_PRID_REG $15, 0
@@ -29,6 +31,7 @@
 	.set arch=octeon
 #ifdef CONFIG_HOTPLUG_CPU
 	b	7f
+	nop
 
 FEXPORT(octeon_hotplug_entry)
 	move	a0, zero
@@ -36,7 +39,19 @@ FEXPORT(octeon_hotplug_entry)
 	move	a2, zero
 	move	a3, zero
 7:
-#endif
+#endif	/* CONFIG_HOTPLUG_CPU */
+#ifdef	CONFIG_CPU_LITTLE_ENDIAN
+	.set push
+	.set noreorder
+	/* Hotpplugged CPUs enter in Big-Endian mode, switch here to LE */
+	dmfc0   v0, COP0_CVMCTL
+	nop
+	ori     v0, v0, 2
+	nop
+	dmtc0   v0, COP0_CVMCTL	/* little-endian */
+	synci	0($0)
+	.set pop
+#endif	/* CONFIG_CPU_LITTLE_ENDIAN */
 	mfc0	v0, CP0_STATUS
 	/* Force 64-bit addressing enabled */
 	ori	v0, v0, (ST0_UX | ST0_SX | ST0_KX)
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 3c7e1fc..e320bf6 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -1082,6 +1082,7 @@ config TXX9_WDT
 config OCTEON_WDT
 	tristate "Cavium OCTEON SOC family Watchdog Timer"
 	depends on CAVIUM_OCTEON_SOC
+	depends on CPU_BIG_ENDIAN || !HOTPLUG_CPU
 	default y
 	select EXPORT_UASM if OCTEON_WDT = m
 	help
-- 
2.6.2

