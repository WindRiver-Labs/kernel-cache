From 5e6914014a81d9f5ca66c2d9239eb5d3cb5cb2c8 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Tue, 13 Aug 2013 12:15:08 -0700
Subject: [PATCH 265/974] MIPS/EDAC: Cavium: Updated L2C error checking for
 OCTEON3.

Use correct CSR for checking Double/Single bit ECC errors for various types.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/edac/octeon_edac-l2c.c | 96 +++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 95 insertions(+), 1 deletion(-)

diff --git a/drivers/edac/octeon_edac-l2c.c b/drivers/edac/octeon_edac-l2c.c
index afea7fc..8017604 100644
--- a/drivers/edac/octeon_edac-l2c.c
+++ b/drivers/edac/octeon_edac-l2c.c
@@ -131,6 +131,97 @@ static void octeon_l2c_poll_oct2(struct edac_device_ctl_info *l2c)
 		_octeon_l2c_poll_oct2(l2c, i);
 }
 
+static void _octeon_l2c_poll_oct3(struct edac_device_ctl_info *l2c, int tad)
+{
+	union cvmx_l2c_tqdx_err tqdx_err;
+	union cvmx_l2c_ttgx_err ttgx_err;
+	union cvmx_l2c_tadx_int l2c_reset;
+	int way, l2idx;
+
+	char buf1[64];
+	char buf2[80];
+
+	l2c_reset.u64 = 0;
+
+	tqdx_err.u64 = cvmx_read_csr(CVMX_L2C_TQDX_ERR(tad));
+	if (tqdx_err.s.l2ddbe || tqdx_err.s.l2dsbe ||
+	    tqdx_err.s.sbfdbe || tqdx_err.s.sbfsbe ||
+	    tqdx_err.s.fbfdbe || tqdx_err.s.fbfsbe)
+		snprintf(buf1, sizeof(buf1),
+			 "L2D: syn:0x%x, quad:%d, index:%d",
+			 tqdx_err.s.syn, tqdx_err.s.qdnum, tqdx_err.s.l2didx);
+
+	if (tqdx_err.s.l2ddbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "L2D Double bit error (detected):%s", buf1);
+		l2c_reset.cn70xx.l2ddbe = 1;
+		edac_device_handle_ue(l2c, tad, 1, buf2);
+	}
+	if (tqdx_err.s.l2dsbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "L2D Single bit error (corrected):%s", buf1);
+		l2c_reset.cn70xx.l2dsbe = 1;
+		edac_device_handle_ce(l2c, tad, 1, buf2);
+	}
+	if (tqdx_err.s.sbfdbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "SBF Double bit error (detected):%s", buf1);
+		l2c_reset.cn70xx.sbfdbe = 1;
+		edac_device_handle_ue(l2c, tad, 1, buf2);
+	}
+	if (tqdx_err.s.sbfsbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "SBF Single bit error (corrected):%s", buf1);
+		l2c_reset.cn70xx.sbfsbe = 1;
+		edac_device_handle_ce(l2c, tad, 1, buf2);
+	}
+	if (tqdx_err.s.fbfdbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "FBF Double bit error (detected):%s", buf1);
+		l2c_reset.cn70xx.fbfdbe = 1;
+		edac_device_handle_ue(l2c, tad, 1, buf2);
+	}
+	if (tqdx_err.s.fbfsbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "FBF Single bit error (corrected):%s", buf1);
+		l2c_reset.cn70xx.fbfsbe = 1;
+		edac_device_handle_ce(l2c, tad, 1, buf2);
+	}
+
+	ttgx_err.u64 = cvmx_read_csr(CVMX_L2C_TTGX_ERR(tad));
+	way = OCTEON_IS_MODEL(OCTEON_CN70XX) ? ttgx_err.cn70xx.way
+				: ttgx_err.cn78xx.way;
+	l2idx = OCTEON_IS_MODEL(OCTEON_CN70XX) ? ttgx_err.cn70xx.l2idx
+				: ttgx_err.cn78xx.l2idx;
+
+	if (ttgx_err.s.tagdbe || ttgx_err.s.tagsbe)
+		snprintf(buf1, sizeof(buf1),
+			 "tag type error: syn:0x%x, way:%d, index:%d",
+			 ttgx_err.s.syn, way, l2idx);
+
+	if (ttgx_err.s.tagdbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "Tag Double bit error (detected):%s", buf1);
+		l2c_reset.cn70xx.tagdbe = 1;
+		edac_device_handle_ue(l2c, tad, 0, buf2);
+	}
+	if (ttgx_err.s.tagsbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "Tag Single bit error (corrected):%s", buf1);
+		l2c_reset.cn70xx.tagsbe = 1;
+		edac_device_handle_ce(l2c, tad, 0, buf2);
+	}
+	if (l2c_reset.u64)
+		cvmx_write_csr(CVMX_L2C_TADX_INT(tad), l2c_reset.u64);
+}
+
+static void octeon_l2c_poll_oct3(struct edac_device_ctl_info *l2c)
+{
+	int i;
+	for (i = 0; i < l2c->nr_instances; i++)
+		_octeon_l2c_poll_oct3(l2c, i);
+}
+
 static int octeon_l2c_probe(struct platform_device *pdev)
 {
 	struct edac_device_ctl_info *l2c;
@@ -166,9 +257,12 @@ static int octeon_l2c_probe(struct platform_device *pdev)
 		cvmx_write_csr(CVMX_L2T_ERR, l2d_err.u64);
 
 		l2c->edac_check = octeon_l2c_poll_oct1;
-	} else {
+	} else if (current_cpu_type() == CPU_CAVIUM_OCTEON2) {
 		/* OCTEON II */
 		l2c->edac_check = octeon_l2c_poll_oct2;
+	} else {
+		/* OCTEON III */
+		l2c->edac_check = octeon_l2c_poll_oct3;
 	}
 
 	if (edac_device_add_device(l2c) > 0) {
-- 
2.6.2

