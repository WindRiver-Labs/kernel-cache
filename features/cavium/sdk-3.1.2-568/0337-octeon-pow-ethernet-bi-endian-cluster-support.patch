From c8bfee8fa2f0102ab46c33c52a6d74de0895aa48 Mon Sep 17 00:00:00 2001
From: Peter Swain <pswain@cavium.com>
Date: Tue, 15 Oct 2013 18:21:07 -0700
Subject: [PATCH 337/974] octeon-pow-ethernet: bi-endian cluster support

Modparam reverse_endian added, for use in clusters where CPUs
are running different kernels with mixed big/little-endian model.
One side should set reverse_endian=1, forcing all its POW traffic
to be byte-swapped in driver.

bug #7820: support bi-endian clusters

From example by David Daney <david.daney@cavium.com>
Signed-off-by: Peter Swain <peter.swain@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/net/ethernet/octeon/octeon-pow-ethernet.c | 61 +++++++++++++++++++++--
 1 file changed, 56 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/octeon/octeon-pow-ethernet.c b/drivers/net/ethernet/octeon/octeon-pow-ethernet.c
index 4aec9d0..c6039a4 100644
--- a/drivers/net/ethernet/octeon/octeon-pow-ethernet.c
+++ b/drivers/net/ethernet/octeon/octeon-pow-ethernet.c
@@ -62,6 +62,41 @@ MODULE_PARM_DESC(ptp_tx_group,
 		 "For the PTP POW device, 0-64 POW group to transmit packets to.\n"
 		 "\t\tIf you don't specify a value, the 'pow0' device will not be created\n.");
 
+static int reverse_endian;
+module_param(reverse_endian, int, 0444);
+MODULE_PARM_DESC(reverse_endian,
+		 "Link partner is running with different endianness (set on only one end of the link).\n");
+
+
+
+static void *memcpy_re_to(void *d, const void *s, size_t n)
+{
+	u8 *dst = d;
+	const u8 *src = s;
+	while (n) {
+		u8 *pd = (u8 *)((unsigned long)dst ^ 7);
+		*pd = *src;
+		n--;
+		dst++;
+		src++;
+	}
+	return d;
+}
+static void *memcpy_re_from(void *d, const void *s, size_t n)
+{
+	u8 *dst = d;
+	const u8 *src = s;
+	while (n) {
+		u8 *ps = (u8 *)((unsigned long)src ^ 7);
+		*dst = *ps;
+		n--;
+		dst++;
+		src++;
+	}
+	return d;
+}
+static void * (*octeon_pow_copy_to)(void *d, const void *s, size_t n);
+static void * (*octeon_pow_copy_from)(void *d, const void *s, size_t n);
 
 /*
  * This is the definition of the Ethernet driver's private
@@ -171,7 +206,7 @@ static int octeon_pow_xmit(struct sk_buff *skb, struct net_device *dev)
 			goto fail;
 		}
 
-		memcpy(copy_location, skb->data, skb->len);
+		octeon_pow_copy_to(copy_location, skb->data, skb->len);
 
 		/* Fill in some of the work queue fields. We may need
 		 * to add more if the software at the other end needs
@@ -238,7 +273,7 @@ static int octeon_pow_xmit(struct sk_buff *skb, struct net_device *dev)
 
 			/* When copying the data, include 4 bytes of the
 			   ethernet header to align the same way hardware does */
-			memcpy(work->packet_data, skb->data + 10,
+			octeon_pow_copy_to(work->packet_data, skb->data + 10,
 			       sizeof(work->packet_data));
 		} else {
 			#if 0
@@ -263,7 +298,7 @@ static int octeon_pow_xmit(struct sk_buff *skb, struct net_device *dev)
 			work->word2.snoip.err_code = 0;  /* No error, packet
 							    is internal */
 			#endif
-			memcpy(work->packet_data, skb->data,
+			octeon_pow_copy_to(work->packet_data, skb->data,
 			       sizeof(work->packet_data));
 		}
 
@@ -366,7 +401,7 @@ static irqreturn_t octeon_pow_interrupt(int cpl, void *dev_id)
 		if (unlikely(work->word2.s.bufs == 0)) {
 			DEBUGPRINT("%s: Received a work with work->word2.s.bufs=0, untested\n",
 				   dev->name);
-			memcpy(skb_put(skb, work->word1.len), work->packet_data,
+			octeon_pow_copy_from(skb_put(skb, work->word1.len), work->packet_data,
 			       work->word1.len);
 		} else {
 			int segments = work->word2.s.bufs;
@@ -391,7 +426,7 @@ static irqreturn_t octeon_pow_interrupt(int cpl, void *dev_id)
 				if (segment_size > len)
 					segment_size = len;
 				/* Copy the data into the packet */
-				memcpy(skb_put(skb, segment_size),
+				octeon_pow_copy_from(skb_put(skb, segment_size),
 				       phys_to_virt(segment_ptr.s.addr),
 				       segment_size);
 				/* Reduce the amount of bytes left to copy */
@@ -510,10 +545,26 @@ static const struct net_device_ops octeon_pow_netdev_ops = {
 #endif
 };
 
+
+/*
+ * Module/ driver initialization. Creates the linux network
+ * devices.
+ *
+ * @return Zero on success
+ */
 static int __init octeon_pow_mod_init(void)
 {
 	struct octeon_pow *priv;
 	u64 allowed_group_mask;
+
+	if (reverse_endian) {
+		octeon_pow_copy_to = memcpy_re_to;
+		octeon_pow_copy_from = memcpy_re_from;
+	} else {
+		octeon_pow_copy_to = memcpy;
+		octeon_pow_copy_from = memcpy;
+	}
+
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
 		octeon_pow_num_groups = 64;
 		allowed_group_mask = 0xffffffffffffffffull;
-- 
2.6.2

