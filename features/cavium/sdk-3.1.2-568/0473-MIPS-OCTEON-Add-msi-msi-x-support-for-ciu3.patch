From 762ab35f991eba7cdca2551b86b9167ce8c1f933 Mon Sep 17 00:00:00 2001
From: Carlos Munoz <carlos.munoz@caviumnetworks.com>
Date: Fri, 7 Feb 2014 13:46:59 -0800
Subject: [PATCH 473/974] MIPS/OCTEON: Add msi/msi-x support for ciu3.

Signed-off-by: Carlos Munoz <carlos.munoz@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c  |  78 ++++++++++++----------
 arch/mips/include/asm/octeon/octeon.h |  33 ++++++++++
 arch/mips/pci/msi-octeon.c            | 121 +++++++++++++++++++++++++++++-----
 3 files changed, 183 insertions(+), 49 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index a34845c..e2b1046 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -65,21 +65,6 @@ struct octeon_irq_ciu_domain_data {
 
 static __read_mostly u8 octeon_irq_ciu_to_irq[8][64];
 
-struct octeon_ciu_chip_data {
-	union {
-		struct {		/* only used for ciu3 */
-			u64 ciu3_addr;
-			unsigned int intsn;
-		};
-		struct {		/* only used for ciu/ciu2 */
-			u8 line;
-			u8 bit;
-			u8 gpio_line;
-		};
-	};
-	int current_cpu;	/* Next CPU expected to take this irq */
-};
-
 struct octeon_core_chip_data {
 	struct mutex core_irq_mutex;
 	bool current_en;
@@ -111,7 +96,7 @@ static int octeon_irq_set_ciu_mapping(int irq, int line, int bit, int gpio_line,
 	return 0;
 }
 
-static void octeon_irq_free_cd(struct irq_domain *d, unsigned int irq)
+void octeon_irq_free_cd(struct irq_domain *d, unsigned int irq)
 {
 	struct irq_data *data = irq_get_irq_data(irq);
 	struct octeon_ciu_chip_data *cd = irq_data_get_irq_chip_data(data);
@@ -2050,7 +2035,7 @@ err:
 	return r;
 }
 
-static void octeon_irq_ciu3_enable(struct irq_data *data)
+void octeon_irq_ciu3_enable(struct irq_data *data)
 {
 	int cpu;
 	union cvmx_ciu3_iscx_ctl isc_ctl;
@@ -2075,7 +2060,7 @@ static void octeon_irq_ciu3_enable(struct irq_data *data)
 	cvmx_read_csr(isc_ctl_addr);
 }
 
-static void octeon_irq_ciu3_disable(struct irq_data *data)
+void octeon_irq_ciu3_disable(struct irq_data *data)
 {
 	u64 isc_ctl_addr;
 	union cvmx_ciu3_iscx_w1c isc_w1c;
@@ -2093,7 +2078,7 @@ static void octeon_irq_ciu3_disable(struct irq_data *data)
 	cvmx_read_csr(isc_ctl_addr);
 }
 
-static void octeon_irq_ciu3_ack(struct irq_data *data)
+void octeon_irq_ciu3_ack(struct irq_data *data)
 {
 	u64 isc_w1c_addr;
 	union cvmx_ciu3_iscx_w1c isc_w1c;
@@ -2117,7 +2102,7 @@ static void octeon_irq_ciu3_ack(struct irq_data *data)
 	cvmx_read_csr(isc_w1c_addr);
 }
 
-static void octeon_irq_ciu3_mask(struct irq_data *data)
+void octeon_irq_ciu3_mask(struct irq_data *data)
 {
 	union cvmx_ciu3_iscx_w1c isc_w1c;
 	u64 isc_w1c_addr;
@@ -2133,7 +2118,7 @@ static void octeon_irq_ciu3_mask(struct irq_data *data)
 	cvmx_read_csr(isc_w1c_addr);
 }
 
-static void octeon_irq_ciu3_mask_ack(struct irq_data *data)
+void octeon_irq_ciu3_mask_ack(struct irq_data *data)
 {
 	union cvmx_ciu3_iscx_w1c isc_w1c;
 	u64 isc_w1c_addr;
@@ -2158,8 +2143,8 @@ static void octeon_irq_ciu3_mask_ack(struct irq_data *data)
 }
 
 #ifdef CONFIG_SMP
-static int octeon_irq_ciu3_set_affinity(struct irq_data *data,
-					const struct cpumask *dest, bool force)
+int octeon_irq_ciu3_set_affinity(struct irq_data *data,
+				 const struct cpumask *dest, bool force)
 {
 	union cvmx_ciu3_iscx_ctl isc_ctl;
 	union cvmx_ciu3_iscx_w1c isc_w1c;
@@ -2206,12 +2191,12 @@ static struct irq_chip octeon_irq_chip_ciu3 = {
 #endif
 };
 
-static int octeon_irq_ciu3_xlat(struct irq_domain *d,
-				struct device_node *node,
-				const u32 *intspec,
-				unsigned int intsize,
-				unsigned long *out_hwirq,
-				unsigned int *out_type)
+int octeon_irq_ciu3_xlat(struct irq_domain *d,
+			 struct device_node *node,
+			 const u32 *intspec,
+			 unsigned int intsize,
+			 unsigned long *out_hwirq,
+			 unsigned int *out_type)
 {
 	struct octeon_ciu3_info *ciu3_info = d->host_data;
 	unsigned int hwirq, type, intsn_major;
@@ -2251,8 +2236,8 @@ static int octeon_irq_ciu3_xlat(struct irq_domain *d,
 	return 0;
 }
 
-static int octeon_irq_ciu3_map(struct irq_domain *d,
-			       unsigned int virq, irq_hw_number_t hw)
+int octeon_irq_ciu3_mapx(struct irq_domain *d, unsigned int virq,
+			 irq_hw_number_t hw, struct irq_chip *chip)
 {
 	struct octeon_ciu3_info *ciu3_info = d->host_data;
 	struct octeon_ciu_chip_data *cd = kzalloc_node(sizeof(*cd), GFP_KERNEL,
@@ -2263,13 +2248,18 @@ static int octeon_irq_ciu3_map(struct irq_domain *d,
 	cd->current_cpu = -1;
 	cd->ciu3_addr = ciu3_info->ciu3_addr;
 
-	irq_set_chip_and_handler(virq, &octeon_irq_chip_ciu3,
-				 octeon_irq_handle_trigger);
+	irq_set_chip_and_handler(virq, chip, octeon_irq_handle_trigger);
 	irq_set_chip_data(virq, cd);
 
 	return 0;
 }
 
+static int octeon_irq_ciu3_map(struct irq_domain *d,
+			       unsigned int virq, irq_hw_number_t hw)
+{
+	return octeon_irq_ciu3_mapx(d, virq, hw, &octeon_irq_chip_ciu3);
+}
+
 static struct irq_domain_ops octeon_dflt_domain_ciu3_ops = {
 	.map = octeon_irq_ciu3_map,
 	.unmap = octeon_irq_free_cd,
@@ -2867,3 +2857,25 @@ void fixup_irqs(void)
 }
 
 #endif /* CONFIG_HOTPLUG_CPU */
+
+void *octeon_irq_get_ciu3_info(int node)
+{
+	return octeon_ciu3_info_per_node[node & CVMX_NODE_MASK];
+}
+
+void octeon_irq_add_block_domain(int node, uint8_t block,
+				 struct irq_domain *domain)
+{
+	struct octeon_ciu3_info *ciu3_info;
+
+	ciu3_info = octeon_ciu3_info_per_node[node & CVMX_NODE_MASK];
+	ciu3_info->domain[block] = domain;
+}
+
+struct irq_domain *octeon_irq_get_block_domain(int node, uint8_t block)
+{
+	struct octeon_ciu3_info *ciu3_info;
+
+	ciu3_info = octeon_ciu3_info_per_node[node & CVMX_NODE_MASK];
+	return ciu3_info->domain[block];
+}
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 96003af..4e3e07f 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -12,6 +12,7 @@
 #include <linux/irqflags.h>
 #include <linux/notifier.h>
 #include <asm/octeon/cvmx.h>
+#include <linux/irq.h>
 
 extern uint64_t octeon_bootmem_alloc_range_phys(uint64_t size,
 						uint64_t alignment,
@@ -329,6 +330,21 @@ union octeon_cvmemctl {
 	} s;
 };
 
+struct octeon_ciu_chip_data {
+	union {
+		struct {		/* only used for ciu3 */
+			u64 ciu3_addr;
+			unsigned int intsn;
+		};
+		struct {		/* only used for ciu/ciu2 */
+			u8 line;
+			u8 bit;
+			u8 gpio_line;
+		};
+	};
+	int current_cpu;	/* Next CPU expected to take this irq */
+};
+
 extern void octeon_write_lcd(const char *s);
 extern void octeon_check_cpu_bist(void);
 extern int octeon_get_boot_debug_flag(void);
@@ -400,6 +416,23 @@ int octeon_request_ipi_handler(octeon_message_fn_t fn);
 void octeon_send_ipi_single(int cpu, unsigned int action);
 void octeon_release_ipi_handler(int action);
 void octeon_ciu3_mbox_send(int cpu, unsigned int mbox);
+void octeon_irq_ciu3_enable(struct irq_data *data);
+void octeon_irq_ciu3_disable(struct irq_data *data);
+void octeon_irq_ciu3_mask(struct irq_data *data);
+void octeon_irq_ciu3_ack(struct irq_data *data);
+void octeon_irq_ciu3_mask_ack(struct irq_data *data);
+int octeon_irq_ciu3_set_affinity(struct irq_data *data,
+				 const struct cpumask *dest, bool force);
+void octeon_irq_free_cd(struct irq_domain *d, unsigned int irq);
+int octeon_irq_ciu3_xlat(struct irq_domain *d, struct device_node *node,
+			 const u32 *intspec, unsigned int intsize,
+			 unsigned long *out_hwirq, unsigned int *out_type);
+int octeon_irq_ciu3_mapx(struct irq_domain *d, unsigned int virq,
+			 irq_hw_number_t hw, struct irq_chip *chip);
+void *octeon_irq_get_ciu3_info(int node);
+void octeon_irq_add_block_domain(int node, uint8_t block,
+				 struct irq_domain *domain);
+struct irq_domain *octeon_irq_get_block_domain(int node, uint8_t block);
 
 #define OCTEON_DEBUG_UART 1
 
diff --git a/arch/mips/pci/msi-octeon.c b/arch/mips/pci/msi-octeon.c
index f43393d..4f9585a 100644
--- a/arch/mips/pci/msi-octeon.c
+++ b/arch/mips/pci/msi-octeon.c
@@ -21,13 +21,16 @@
 #include <asm/octeon/cvmx-ciu2-defs.h>
 #include <asm/octeon/pci-octeon.h>
 
+/* MSI major block number (8 MSBs of intsn) */
+#define MSI_BLOCK_NUMBER	0x1e
+
 #define MSI_IRQ_SIZE		256
 
 /*
  * Each bit in msi_free_irq_bitmap represents a MSI interrupt that is
- * in use.
+ * in use. Each node requires its own set of bits.
  */
-static DECLARE_BITMAP(msi_free_irq_bitmap, MSI_IRQ_SIZE);
+static DECLARE_BITMAP(msi_free_irq_bitmap[CVMX_MAX_NODES], MSI_IRQ_SIZE);
 
 /*
  * This lock controls updates to msi_free_irq_bitmap.
@@ -56,27 +59,41 @@ int arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc)
 {
 	struct msi_msg msg;
 	int irq;
+	int hwirq;
+	int msi;
+	struct irq_domain *domain;
+	int node = 0; /* Must use the correct node. TODO */
 
 	/*
 	 * We're going to search msi_free_irq_bitmap for zero bits. This
 	 * represents an MSI interrupt number that isn't in use.
 	 */
 	spin_lock(&msi_free_irq_bitmap_lock);
-	irq = find_next_zero_bit(msi_free_irq_bitmap, MSI_IRQ_SIZE, 1);
-	if (irq < MSI_IRQ_SIZE) {
-		set_bit(irq, msi_free_irq_bitmap);
-		spin_unlock(&msi_free_irq_bitmap_lock);
-	}
-	else {
+	msi = find_next_zero_bit(msi_free_irq_bitmap[node], MSI_IRQ_SIZE, 0);
+	if (msi >= MSI_IRQ_SIZE) {
 		spin_unlock(&msi_free_irq_bitmap_lock);
 		WARN(1, "arch_setup_msi_irq: Unable to find a free MSI "
 		     "interrupt");
 		return -ENOSPC;
 	}
 
-	/* MSI interrupts start at logical IRQ OCTEON_IRQ_MSI_BIT0 */
-	msg.data = irq;
-	irq += OCTEON_IRQ_MSI_BIT0;
+	set_bit(msi, msi_free_irq_bitmap[node]);
+	spin_unlock(&msi_free_irq_bitmap_lock);
+	msg.data = msi;
+
+	if (octeon_has_feature(OCTEON_FEATURE_CIU3)) {
+		/* Get the domain for the msi interrupts */
+		domain = octeon_irq_get_block_domain(node, MSI_BLOCK_NUMBER);
+
+		/* Get a irq for the msi intsn (hardware interrupt) */
+		hwirq = MSI_BLOCK_NUMBER << 12 | msi;
+		irq = irq_create_mapping(domain, hwirq);
+		irqd_set_trigger_type(irq_get_irq_data(irq),
+				      IRQ_TYPE_EDGE_RISING);
+	} else {
+		/* MSI interrupts start at logical IRQ OCTEON_IRQ_MSI_BIT0 */
+		irq = msi + OCTEON_IRQ_MSI_BIT0;
+	}
 
 	switch (octeon_dma_bar_type) {
 	case OCTEON_DMA_BAR_TYPE_SMALL:
@@ -119,6 +136,7 @@ int arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc)
 void arch_teardown_msi_irq(unsigned int irq)
 {
 	int old;
+	int node = 0; /* Must use node device is in. TODO */
 
 	if ((irq < OCTEON_IRQ_MSI_BIT0)
 		|| (irq > msi_irq_size + OCTEON_IRQ_MSI_BIT0 - 1))
@@ -127,7 +145,7 @@ void arch_teardown_msi_irq(unsigned int irq)
 
 	irq -= OCTEON_IRQ_MSI_BIT0;
 	spin_lock(&msi_free_irq_bitmap_lock);
-	old = test_and_clear_bit(irq, msi_free_irq_bitmap);
+	old = test_and_clear_bit(irq, msi_free_irq_bitmap[node]);
 	spin_unlock(&msi_free_irq_bitmap_lock);
 
 	if (!old) {
@@ -491,21 +509,92 @@ static int __init octeon_msi_68XX_init(void)
 }
 #endif /* 0 */
 
+static void octeon_irq_msi_ciu3_ack(struct irq_data *data)
+{
+	u64 csr_addr;
+	struct octeon_ciu_chip_data *cd;
+	int msi;
+
+	octeon_irq_ciu3_ack(data);
+
+	cd = irq_data_get_irq_chip_data(data);
+
+	/* Acknowledge lsi (msi) interrupt (get the node from the ciu3 addr) */
+	msi = cd->intsn & 0xff;
+	csr_addr = (cd->ciu3_addr & CVMX_NODE_MASK) | msi_rcv_reg[msi >> 6];
+	cvmx_write_csr(csr_addr, 1 << (msi & 0x3f));
+}
+
+static void octeon_irq_msi_ciu3_mask_ack(struct irq_data *data)
+{
+	u64 csr_addr;
+	struct octeon_ciu_chip_data *cd;
+	int msi;
+
+	octeon_irq_ciu3_mask_ack(data);
+
+	cd = irq_data_get_irq_chip_data(data);
+
+	/* Acknowledge lsi (msi) interrupt (get the node from the ciu3 addr) */
+	msi = cd->intsn & 0xff;
+	csr_addr = (cd->ciu3_addr & CVMX_NODE_MASK) | msi_rcv_reg[msi >> 6];
+	cvmx_write_csr(csr_addr, 1 << (msi & 0x3f));
+}
+
+static struct irq_chip octeon_irq_msi_chip_ciu3 = {
+	.name = "CIU3",
+	.irq_enable = octeon_irq_ciu3_enable,
+	.irq_disable = octeon_irq_ciu3_disable,
+	.irq_ack = octeon_irq_msi_ciu3_ack,
+	.irq_mask = octeon_irq_ciu3_mask,
+	.irq_mask_ack = octeon_irq_msi_ciu3_mask_ack,
+	.irq_unmask = octeon_irq_ciu3_enable,
+#ifdef CONFIG_SMP
+	.irq_set_affinity = octeon_irq_ciu3_set_affinity,
+#endif
+};
+
+static int octeon_irq_msi_ciu3_map(struct irq_domain *d,
+				   unsigned int virq, irq_hw_number_t hw)
+{
+	return octeon_irq_ciu3_mapx(d, virq, hw, &octeon_irq_msi_chip_ciu3);
+}
+
+struct irq_domain_ops octeon_msi_domain_ciu3_ops = {
+	.map = octeon_irq_msi_ciu3_map,
+	.unmap = octeon_irq_free_cd,
+	.xlate = octeon_irq_ciu3_xlat,
+};
+
 /*
  * Initializes the MSI interrupt handling code
  */
 int __init octeon_msi_initialize(void)
 {
 	int irq;
+	struct irq_domain *domain;
 	struct irq_chip *msi;
 	u64 msi_map_reg;
-
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
-		return 0;
+	int i;
+	int node = 0; /* Must use correct node. TODO */
 
 	/* Clear msi irq bitmap */
-	bitmap_zero(msi_free_irq_bitmap, MSI_IRQ_SIZE);
+	for (i = 0; i < CVMX_MAX_NODES; i++)
+		bitmap_zero(msi_free_irq_bitmap[i], MSI_IRQ_SIZE);
+
+	if (octeon_has_feature(OCTEON_FEATURE_CIU3)) {
+		/* MSI interrupts use their own domain */
+		domain = irq_domain_add_tree(NULL, &octeon_msi_domain_ciu3_ops,
+					     octeon_irq_get_ciu3_info(node));
+		octeon_irq_add_block_domain(node, MSI_BLOCK_NUMBER, domain);
 
+		/* Registers to acknowledge msi interrupts */
+		msi_rcv_reg[0] = CVMX_PEXP_SLI_MSI_RCV0;
+		msi_rcv_reg[1] = CVMX_PEXP_SLI_MSI_RCV1;
+		msi_rcv_reg[2] = CVMX_PEXP_SLI_MSI_RCV2;
+		msi_rcv_reg[3] = CVMX_PEXP_SLI_MSI_RCV3;
+		return 0;
+	}
 #if 0
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX) && !OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_X))
 		return octeon_msi_68XX_init();
-- 
2.6.2

