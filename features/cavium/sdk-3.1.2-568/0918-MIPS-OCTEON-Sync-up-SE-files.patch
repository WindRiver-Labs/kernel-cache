From ba635b07c5d6529aa1a700cd01d178b5bc7aef7a Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Thu, 31 Jul 2014 18:05:50 -0700
Subject: [PATCH 918/974] MIPS: OCTEON: Sync-up SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/Makefile         |   2 +-
 arch/mips/cavium-octeon/executive/cvmx-bootmem.c   |   2 +-
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c | 290 +++++++-------------
 .../mips/cavium-octeon/executive/cvmx-helper-cfg.c |  22 +-
 .../cavium-octeon/executive/cvmx-helper-loop.c     |   2 +-
 .../mips/cavium-octeon/executive/cvmx-helper-npi.c |   2 +-
 .../mips/cavium-octeon/executive/cvmx-helper-pko.c |   2 +-
 .../cavium-octeon/executive/cvmx-helper-pko3.c     | 245 ++++++++++++-----
 .../cavium-octeon/executive/cvmx-helper-sgmii.c    |   5 +-
 arch/mips/cavium-octeon/executive/cvmx-helper.c    |   4 +
 arch/mips/cavium-octeon/executive/cvmx-ila.c       | 295 +++++++++++++++++++++
 arch/mips/cavium-octeon/executive/cvmx-l2c.c       |   2 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      | 128 ++++-----
 .../mips/cavium-octeon/executive/cvmx-pko3-queue.c | 173 ++++++------
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      |   5 +
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |  18 +-
 arch/mips/cavium-octeon/executive/octeon-model.c   |   2 +-
 arch/mips/include/asm/octeon/cvmx-app-init.h       |   4 +-
 arch/mips/include/asm/octeon/cvmx-cmd-queue.h      |   2 +-
 arch/mips/include/asm/octeon/cvmx-coremask.h       |   2 +-
 arch/mips/include/asm/octeon/cvmx-dma-engine.h     |   2 +-
 arch/mips/include/asm/octeon/cvmx-fpa.h            |   2 +-
 arch/mips/include/asm/octeon/cvmx-fpa1.h           |   2 +-
 arch/mips/include/asm/octeon/cvmx-fpa3.h           |   9 +-
 arch/mips/include/asm/octeon/cvmx-helper-board.h   |   2 +-
 arch/mips/include/asm/octeon/cvmx-helper-loop.h    |   2 +-
 arch/mips/include/asm/octeon/cvmx-helper.h         |   2 +-
 arch/mips/include/asm/octeon/cvmx-ila.h            | 118 +++++++++
 arch/mips/include/asm/octeon/cvmx-ipd.h            |   2 +-
 arch/mips/include/asm/octeon/cvmx-l2c.h            |   2 +-
 arch/mips/include/asm/octeon/cvmx-pcie.h           |   2 +-
 arch/mips/include/asm/octeon/cvmx-pip.h            |   2 +-
 arch/mips/include/asm/octeon/cvmx-pko3-queue.h     |  11 +-
 arch/mips/include/asm/octeon/cvmx-pko3.h           |  25 ++
 arch/mips/include/asm/octeon/cvmx-qlm.h            |   2 +-
 arch/mips/include/asm/octeon/cvmx-spinlock.h       |   2 +-
 arch/mips/include/asm/octeon/octeon-model.h        |   2 +-
 37 files changed, 929 insertions(+), 467 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/executive/cvmx-ila.c
 create mode 100644 arch/mips/include/asm/octeon/cvmx-ila.h

diff --git a/arch/mips/cavium-octeon/executive/Makefile b/arch/mips/cavium-octeon/executive/Makefile
index 5e683c50..0ce1908 100644
--- a/arch/mips/cavium-octeon/executive/Makefile
+++ b/arch/mips/cavium-octeon/executive/Makefile
@@ -24,7 +24,7 @@ obj-y += cvmx-pko.o cvmx-spi.o cvmx-cmd-queue.o cvmx-helper-cfg.o	\
 	cvmx-helper-bgx.o cvmx-pko3.o cvmx-helper-pki.o			\
 	cvmx-helper-pko3.o cvmx-pko3-resources.o cvmx-helper-pko.o	\
 	cvmx-helper-ipd.o cvmx-sso-resources.o cvmx-ocla.o cvmx-boot-vector.o \
-	cvmx-lap.o cvmx-osm.o
+	cvmx-lap.o cvmx-osm.o cvmx-ila.o
 
 obj-y += cvmx-helper-errata.o cvmx-helper-jtag.o
 obj-$(CONFIG_PCI) += cvmx-pcie.o
diff --git a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
index 6a83f2d..7ad99a0 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
@@ -43,7 +43,7 @@
  * Simple allocate only memory allocator.  Used to allocate memory at
  * application start time.
  *
- * <hr>$Revision: 112708 $<hr>
+ * <hr>$Revision: 112705 $<hr>
  *
  */
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 5d7d6ca..4ec8e31 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -106,50 +106,66 @@ __cvmx_helper_bgx_interface_enable_delay(cvmx_helper_interface_mode_t mode)
  */
 int __cvmx_helper_bgx_enumerate(int xiface)
 {
+	cvmx_bgxx_cmr_tx_lmacs_t lmacs;
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-	int node = xi.node;
-	int qlm;
-	enum cvmx_qlm_mode mode;
 
-	/*
-	 * Check the QLM is configured correctly for SGMII, verify the
-	 * speed as well as the mode.
-	 */
-	qlm = cvmx_qlm_lmac(xiface, 0);
-	if (qlm == -1)
-		return 0;
+	lmacs.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_CMR_TX_LMACS(xi.interface));
+	return lmacs.s.lmacs;
 
-	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
-		mode = cvmx_qlm_get_mode_cn78xx(node, qlm);
-	else
-		mode = cvmx_qlm_get_mode(qlm);
+}
 
-	switch (mode) {
-	case CVMX_QLM_MODE_SGMII:
-	case CVMX_QLM_MODE_10G_KR:
-	case CVMX_QLM_MODE_XFI:
-	case CVMX_QLM_MODE_RGMII_SGMII:
-	case CVMX_QLM_MODE_RGMII_10G_KR:
-	case CVMX_QLM_MODE_RGMII_XFI:
-	case CVMX_QLM_MODE_MIXED:
-		return 4;
-	case CVMX_QLM_MODE_XAUI:
-	case CVMX_QLM_MODE_40G_KR4:
-	case CVMX_QLM_MODE_XLAUI:
-		return 1;
-	case CVMX_QLM_MODE_RGMII_XAUI:
-	case CVMX_QLM_MODE_RGMII_40G_KR4:
-	case CVMX_QLM_MODE_RGMII_XLAUI:
-	case CVMX_QLM_MODE_RXAUI:
-	case CVMX_QLM_MODE_RGMII_RXAUI:
-	case CVMX_QLM_MODE_SGMII_2X1:
-	case CVMX_QLM_MODE_RGMII_SGMII_1X1:
-	case CVMX_QLM_MODE_10G_KR_1X2:
-	case CVMX_QLM_MODE_XFI_1X2:
-	case CVMX_QLM_MODE_RXAUI_1X2:
-		return 4;
+/**
+ * @INTERNAL
+ *
+ * Returns mode of each port in a BDK
+ * @param xiface Which xiface
+ * @param index port in a BDK
+ * @returns mode of each port in a BDK
+ */
+static cvmx_helper_interface_mode_t cvmx_helper_bgx_get_mode(int xiface, int index)
+{
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	cvmx_bgxx_cmrx_config_t cmr_config;
+	cvmx_bgxx_spux_br_pmd_control_t pmd_control;
+
+	cmr_config.u64 = cvmx_read_csr_node(xi.node, CVMX_BGXX_CMRX_CONFIG(index, xi.interface));
+
+	switch (cmr_config.s.lmac_type)
+	{
+	case 0:
+		return CVMX_HELPER_INTERFACE_MODE_SGMII;
+		break;
+	case 1:
+		return CVMX_HELPER_INTERFACE_MODE_XAUI;
+		break;
+	case 2:
+		return CVMX_HELPER_INTERFACE_MODE_RXAUI;
+		break;
+	case 3:
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+			return cvmx_helper_interface_get_mode(xiface);
+		pmd_control.u64 = cvmx_read_csr_node(xi.node,
+					CVMX_BGXX_SPUX_BR_PMD_CONTROL(index,
+							xi.interface));
+		if (pmd_control.s.train_en)
+			return CVMX_HELPER_INTERFACE_MODE_10G_KR;
+		else
+			return CVMX_HELPER_INTERFACE_MODE_XFI;
+		break;
+	case 4:
+		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+			return cvmx_helper_interface_get_mode(xiface);
+		pmd_control.u64 = cvmx_read_csr_node(xi.node,
+					CVMX_BGXX_SPUX_BR_PMD_CONTROL(index,
+							xi.interface));
+		if (pmd_control.s.train_en)
+			return CVMX_HELPER_INTERFACE_MODE_40G_KR4;
+		else
+			return CVMX_HELPER_INTERFACE_MODE_XLAUI;
+		break;
 	default:
-		return 0;
+		return CVMX_HELPER_INTERFACE_MODE_DISABLED;
+		break;
 	}
 }
 
@@ -281,96 +297,6 @@ static int __cvmx_helper_bgx_rgmii_speed(cvmx_helper_link_info_t link_info)
 	return link_info.s.speed;
 }
 
-
-/**
- * @INTERNAL
- * Configure the bgx mac.
- *
- * @param xiface Interface to bring up
- * @param index  port on interface to bring up
- */
-static void __cvmx_bgx_common_init(int xiface, int index)
-{
-	cvmx_bgxx_cmrx_config_t	cmr_config;
-	cvmx_bgxx_cmr_rx_lmacs_t bgx_cmr_rx_lmacs;
-	cvmx_bgxx_cmr_tx_lmacs_t bgx_cmr_tx_lmacs;
-	cvmx_helper_interface_mode_t mode;
-	int num_ports;
-	int lmac_type = 0;
-	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-	int node = xi.node;
-	int lane_to_sds = 0;
-
-	if (debug)
-		cvmx_dprintf("%s: interface %u:%d/%d\n",
-		__func__, xi.node, xi.interface, index);
-
-	/* Nothing to do here, already configured by u-boot */
-	if (OCTEON_IS_MODEL(OCTEON_CNF75XX)) {
-		return;
-	}
-
-	/* Nothing to do here, already configured by u-boot */
-	if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
-		return;
-	}
-
-	num_ports = cvmx_helper_ports_on_interface(xiface);
-	mode = cvmx_helper_interface_get_mode(xiface);
-
-	switch (mode) {
-	case CVMX_HELPER_INTERFACE_MODE_SGMII:
-		lmac_type = 0;
-		lane_to_sds = 1;
-		break;
-	case CVMX_HELPER_INTERFACE_MODE_XAUI:
-		lmac_type = 1;
-		lane_to_sds = 0xe4;
-		break;
-	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
-		lmac_type = 2;
-		break;
-	case CVMX_HELPER_INTERFACE_MODE_XFI:
-	case CVMX_HELPER_INTERFACE_MODE_10G_KR:
-		lmac_type = 3;
-		lane_to_sds = 1;
-		break;
-	case CVMX_HELPER_INTERFACE_MODE_XLAUI:
-	case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
-		lmac_type = 4;
-		lane_to_sds = 0xe4;
-		break;
-	default:
-		break;
-	}
-
-	/* Set mode and lanes for all interface ports */
-	cmr_config.u64 =
-		cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, xi.interface));
-	cmr_config.s.enable = 0;
-	cmr_config.s.data_pkt_tx_en = 0;
-	cmr_config.s.data_pkt_rx_en = 0;
-	cmr_config.s.lmac_type = lmac_type;
-	cmr_config.s.lane_to_sds = ((lane_to_sds == 1) ? index
-				: ((lane_to_sds == 0)
-				? (index ? 0xe : 4) : lane_to_sds));
-	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, xi.interface), cmr_config.u64);
-
-	if (debug)
-		cvmx_dprintf("%s: lane_to_sds=%#x\n",
-		__func__, cmr_config.s.lane_to_sds);
-
-	if (index == 0) {
-		bgx_cmr_rx_lmacs.u64 = 0;
-		bgx_cmr_rx_lmacs.s.lmacs = num_ports;
-		cvmx_write_csr_node(node, CVMX_BGXX_CMR_RX_LMACS(xi.interface), bgx_cmr_rx_lmacs.u64);
-
-		bgx_cmr_tx_lmacs.u64 = 0;
-		bgx_cmr_tx_lmacs.s.lmacs = num_ports;
-		cvmx_write_csr_node(node, CVMX_BGXX_CMR_TX_LMACS(xi.interface), bgx_cmr_tx_lmacs.u64);
-	}
-}
-
 static void __cvmx_bgx_common_init_pknd(int xiface, int index)
 {
 	int num_ports;
@@ -455,12 +381,6 @@ static void __cvmx_helper_bgx_adjust_index(int xiface, int *start, int *end)
  */
 int __cvmx_helper_bgx_probe(int xiface)
 {
-	int index, start, end;
-
-	__cvmx_helper_bgx_adjust_index(xiface, &start, &end);
-
-	for (index = start; index < end; index++)
-		__cvmx_bgx_common_init(xiface, index);
 	return __cvmx_helper_bgx_enumerate(xiface);
 }
 EXPORT_SYMBOL(__cvmx_helper_bgx_probe);
@@ -874,7 +794,8 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_sgmii_link_get(int xipd_port)
 	}
 
 	gmp_misc_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_GMP_PCS_MISCX_CTL(index, xi.interface));
-	if (gmp_misc_ctl.s.mac_phy) {
+	if (gmp_misc_ctl.s.mac_phy ||
+	    cvmx_helper_get_port_force_link_up(xiface, index)) {
 		int qlm = cvmx_qlm_lmac(xiface, index);
 		int speed;
 		if (OCTEON_IS_MODEL(OCTEON_CN78XX))
@@ -1041,15 +962,14 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 		cvmx_dprintf("%s: interface %u:%d/%d\n",
 		__func__, xi.node, xi.interface, index);
 
-	mode = cvmx_helper_interface_get_mode(xiface);
+	mode = cvmx_helper_bgx_get_mode(xiface, index);
 
-	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, xi.interface));
-	pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
-	if ((cmr_config.s.lmac_type == 3 || cmr_config.s.lmac_type == 4)
-	    && pmd_control.s.train_en
-	    && !OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+	if (mode == CVMX_HELPER_INTERFACE_MODE_10G_KR
+	    || mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4)
 		use_auto_neg = 1;
-	}
+
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+		use_auto_neg = 0;
 
 	/* NOTE: This code was moved first, out of order compared to the HRM
 	   because the RESET causes all SPU registers to loose their value */
@@ -1156,8 +1076,8 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 		spu_an_adv.s.fec_able = 1;
 		spu_an_adv.s.a100g_cr10 = 0;
 		spu_an_adv.s.a40g_cr4 = 0;
-		spu_an_adv.s.a40g_kr4 = (cmr_config.s.lmac_type == 4 && use_auto_neg);
-		spu_an_adv.s.a10g_kr = (cmr_config.s.lmac_type == 3 && use_auto_neg);
+		spu_an_adv.s.a40g_kr4 = (mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4 && use_auto_neg);
+		spu_an_adv.s.a10g_kr = (mode == CVMX_HELPER_INTERFACE_MODE_10G_KR && use_auto_neg);
 		spu_an_adv.s.a10g_kx4 = 0;
 		spu_an_adv.s.a1g_kx = 0;
 		spu_an_adv.s.rf = 0;
@@ -1165,7 +1085,7 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 
 		/* 3. Set BGX(0..5)_SPU_DBG_CONTROL[AN_ARB_LINK_CHK_EN] = 1. */
 		spu_dbg_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(xi.interface));
-		spu_dbg_control.s.an_arb_link_chk_en = use_auto_neg;
+		spu_dbg_control.s.an_arb_link_chk_en |= use_auto_neg;
 		cvmx_write_csr_node(node, CVMX_BGXX_SPU_DBG_CONTROL(xi.interface), spu_dbg_control.u64);
 
 		/* 4. Execute the link bring-up sequence in Section 33.6.3. */
@@ -1190,6 +1110,11 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 	   Section 33.4.1, BGX(0..5)_SPU(0..3)_MISC_CONTROL[XOR_TXPLRT,XOR_RXPLRT]
 	   and BGX(0..5)_SPU(0..3)_MISC_CONTROL[TXPLRT,RXPLRT]. */
 
+	/* 4c. Write BGX(0..5)_SPU(0..3)_CONTROL1[LO_PWR] = 0. */
+	spu_control1.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, xi.interface));
+	spu_control1.s.lo_pwr = 0;
+	cvmx_write_csr_node(node, CVMX_BGXX_SPUX_CONTROL1(index, xi.interface), spu_control1.u64);
+
 	/* 4d. Select Deficit Idle Count mode and unidirectional enable/disable
 	   via BGX(0..5)_SMU(0..3)_TX_CTL[DIC_EN,UNI_EN]. */
 	smu_tx_ctl.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, xi.interface));
@@ -1295,9 +1220,7 @@ int __cvmx_helper_bgx_port_init(int xipd_port, int phy_pres)
 		cvmx_dprintf("%s: interface %u:%d/%d\n",
 		__func__, xi.node, xi.interface, index);
 
-	mode = cvmx_helper_interface_get_mode(xiface);
-
-	__cvmx_bgx_common_init(xiface, index);
+	mode = cvmx_helper_bgx_get_mode(xiface, index);
 
 	__cvmx_bgx_common_init_pknd(xiface, index);
 
@@ -1407,8 +1330,8 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 	cvmx_bgxx_spux_status2_t spu_status2;
 	cvmx_bgxx_spux_int_t spu_int;
 	cvmx_bgxx_spux_misc_control_t spu_misc_control;
-	cvmx_bgxx_spux_br_pmd_control_t pmd_control;
 	cvmx_bgxx_cmrx_config_t cmr_config;
+	cvmx_helper_interface_mode_t mode;
 	int use_training = 0;
 	int rgmii_first = 0;
 
@@ -1417,14 +1340,12 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 		__func__, xi.node, xi.interface, index);
 
 	cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(0, xi.interface));
-	pmd_control.u64 = cvmx_read_csr_node(node, CVMX_BGXX_SPUX_BR_PMD_CONTROL(index, interface));
 	rgmii_first = (cmr_config.s.lmac_type == 5);
 
-	if ((cmr_config.s.lmac_type == 3 || cmr_config.s.lmac_type == 4)
-	    && pmd_control.s.train_en
-	    && !OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+	mode = cvmx_helper_bgx_get_mode(xiface, index);
+	if (mode == CVMX_HELPER_INTERFACE_MODE_10G_KR
+	    || mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4)
 		use_training = 1;
-	}
 
 	/* Disable packet reception */
 	spu_misc_control.u64 = cvmx_read_csr_node(node,
@@ -1470,46 +1391,35 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 		if (use_training == 0) {
 			int qlm = cvmx_qlm_lmac(xiface, index);
 			int lane = index;
-			int mux = 0;
 			cmr_config.u64 = cvmx_read_csr_node(node,
 					CVMX_BGXX_CMRX_CONFIG(index, xi.interface));
-			/* Check if BGX2 uses both dlms (mux = 0), or
-			   qlm5 only (mux = 1) or qlm6 only (mux = 2) */
-			if (qlm == 5 || qlm == 6)
-				mux = cvmx_qlm_mux_interface(xi.interface);
-			if (cmr_config.s.lmac_type == 4
-			    || cmr_config.s.lmac_type == 1) { // XLAUI/DXAUI
+			if (mode == CVMX_HELPER_INTERFACE_MODE_XLAUI
+			    || mode == CVMX_HELPER_INTERFACE_MODE_XAUI) { // XLAUI/DXAUI
 				lane = -1;
 				__cvmx_qlm_rx_equalization(node, qlm, lane);
 				/* If BGX2 uses both dlms, then configure other dlm also. */
-				if (mux == 0 && qlm == 5)
+				if (OCTEON_IS_MODEL(OCTEON_CN73XX) && xi.interface == 2)
 					__cvmx_qlm_rx_equalization(node, 6, lane);
-			} else if (cmr_config.s.lmac_type == 2) { // RXAUI
+			} else if (CVMX_HELPER_INTERFACE_MODE_RXAUI) { // RXAUI
 				lane = index * 2;
-				if (mux == 0 && index != 0 && qlm == 5) {
-					lane = 0;
-					qlm = 6;
-				} else if (mux == 2) {
+				if (OCTEON_IS_MODEL(OCTEON_CN73XX)
+				    && index >= 2
+				    && xi.interface == 2) {
 					lane = 0;
-					qlm = 6;
 				}
 				if (rgmii_first)
 					lane--;
 				__cvmx_qlm_rx_equalization(node, qlm, lane);
 				__cvmx_qlm_rx_equalization(node, qlm, lane + 1);
 			} else if (cmr_config.s.lmac_type != 5) { // !RGMII
-				if (mux == 2)
-					lane = index - 2;
 				if (rgmii_first)
 					lane--;
-				if (mux == 0 && qlm == 5 && index >= 2) {
-					lane = index - 2;
-					__cvmx_qlm_rx_equalization(node, qlm+1, lane);
-				} else if (mux == 0 && qlm == 6 && index >= 2) {
-					lane = index - 2;
-					__cvmx_qlm_rx_equalization(node, qlm, lane);
-				} else
-					__cvmx_qlm_rx_equalization(node, qlm, lane);
+				if (OCTEON_IS_MODEL(OCTEON_CN73XX)
+				    && index >= 2
+				    && xi.interface == 2) {
+					lane = 0;
+				}
+				__cvmx_qlm_rx_equalization(node, qlm, lane);
 			}
 		}
 
@@ -1520,7 +1430,10 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 		}
 
 
-		if (cmr_config.s.lmac_type == 3 || cmr_config.s.lmac_type == 4) {
+		if (mode == CVMX_HELPER_INTERFACE_MODE_XFI
+		    || mode == CVMX_HELPER_INTERFACE_MODE_XLAUI
+		    || mode == CVMX_HELPER_INTERFACE_MODE_10G_KR
+		    || mode == CVMX_HELPER_INTERFACE_MODE_40G_KR4) {
 			if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BR_STATUS1(index, xi.interface),
 					  cvmx_bgxx_spux_br_status1_t, blk_lock, ==, 1, 10000)) {
 				//cvmx_dprintf("ERROR: %d:BGX%d:%d: BASE-R PCS block not locked\n", node, interface, index);
@@ -1609,8 +1522,6 @@ int __cvmx_helper_bgx_xaui_enable(int xiface)
 	cvmx_helper_interface_mode_t mode;
 	int start = 0, end = 0;
 
-	mode = cvmx_helper_interface_get_mode(xiface);
-
 	__cvmx_helper_bgx_adjust_index(xiface, &start, &end);
 
 	for (index = start; index < end; index++) {
@@ -1618,6 +1529,8 @@ int __cvmx_helper_bgx_xaui_enable(int xiface)
 		int xipd_port = cvmx_helper_get_ipd_port(xiface, index);
 		int phy_pres;
 
+		mode = cvmx_helper_bgx_get_mode(xiface, index);
+
 		/* Set disparity for RXAUI interface as described in the
 		   Marvell RXAUI Interface specification. */
 		if (mode == CVMX_HELPER_INTERFACE_MODE_RXAUI &&
@@ -1778,26 +1691,27 @@ int __cvmx_helper_bgx_mixed_enable(int xiface)
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int interface = xi.interface;
 	int node = xi.node;
+	cvmx_helper_interface_mode_t mode;
 
 	for (index = 0; index < num_ports; index++) {
-		cvmx_bgxx_cmrx_config_t cmr_config;
 		int xipd_port, phy_pres = 0;
 
 		if (!cvmx_helper_is_port_valid(xiface, index))
 			continue;
 
-		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
+		mode = cvmx_helper_bgx_get_mode(xiface, index);
+
 		xipd_port = cvmx_helper_get_ipd_port(xiface, index);
 
-		if (cmr_config.s.lmac_type == 2 &&
-			(cvmx_helper_get_port_phy_present(xiface, index)))
+		if (mode == CVMX_HELPER_INTERFACE_MODE_RXAUI
+		    && (cvmx_helper_get_port_phy_present(xiface, index)))
 			phy_pres = 1;
 
 		if (__cvmx_helper_bgx_port_init(xipd_port, phy_pres))
 			continue;
 
 		/* Call SGMII init code for lmac_type = 0 */
-		if (cmr_config.s.lmac_type == 0) {
+		if (mode == CVMX_HELPER_INTERFACE_MODE_SGMII) {
 			int do_link_set = 1;
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 			if (!(cvmx_sysinfo_get()->board_type == CVMX_BOARD_TYPE_SIM))
@@ -2089,7 +2003,7 @@ void cvmx_helper_bgx_set_mac(int xipd_port, int bcst, int mcst, uint64_t mac)
 	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, xi.interface), cmr_config.u64);
 	/* Wait 100ms after bringing up the link to give the PHY some time */
 	if (cmr_config.s.enable) {
-		mode = cvmx_helper_interface_get_mode(xiface);
+		mode = cvmx_helper_bgx_get_mode(xiface, index);
 		__cvmx_helper_bgx_interface_enable_delay(mode);
 	}
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
index 6b5cd10..3e13adb 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-cfg.c
@@ -918,18 +918,16 @@ int __cvmx_helper_init_port_valid(void)
 			rc = __cvmx_helper_parse_bgx_rgmii_dt(fdt_addr);
 
 		/* Some ports are not in sequence, the device tree does not clear them */
-		if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
-			for (i = 0; i < CVMX_HELPER_MAX_GMX; i++) {
-				int j;
-				for (j = 0; j < cvmx_helper_interface_enumerate(i); j++) {
-					cvmx_bgxx_cmrx_config_t cmr_config;
-					cmr_config.u64 = cvmx_read_csr(CVMX_BGXX_CMRX_CONFIG(j, i));
-					if (cmr_config.s.lane_to_sds == 0xe4
-				    	&& cmr_config.s.lmac_type != 4
-				    	&& cmr_config.s.lmac_type != 1
-				    	&& cmr_config.s.lmac_type != 5)
-						cvmx_helper_set_port_valid(i, j, false);
-				}
+		for (i = 0; i < CVMX_HELPER_MAX_GMX; i++) {
+			int j;
+			for (j = 0; j < cvmx_helper_interface_enumerate(i); j++) {
+				cvmx_bgxx_cmrx_config_t cmr_config;
+				cmr_config.u64 = cvmx_read_csr(CVMX_BGXX_CMRX_CONFIG(j, i));
+				if (cmr_config.s.lane_to_sds == 0xe4
+				    && cmr_config.s.lmac_type != 4
+				    && cmr_config.s.lmac_type != 1
+				    && cmr_config.s.lmac_type != 5)
+					cvmx_helper_set_port_valid(i, j, false);
 			}
 		}
 		return rc;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c b/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c
index 664432d..c5eb1de 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-loop.c
@@ -43,7 +43,7 @@
  * Functions for LOOP initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 115885 $<hr>
+ * <hr>$Revision: 115656 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c b/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
index afc9c0f..4559307 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-npi.c
@@ -43,7 +43,7 @@
  * Functions for NPI initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 121089 $<hr>
+ * <hr>$Revision: 120569 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko.c
index a206296..e398cf7 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko.c
@@ -42,7 +42,7 @@
  *
  * Helper Functions for the PKO
  *
- * $Id: cvmx-helper-pko.c 115885 2015-04-07 17:42:09Z fhooker $
+ * $Id: cvmx-helper-pko.c 115744 2015-04-04 04:36:36Z awilliams $
  */
 
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index aaf4ffe..54a4d62 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -1470,6 +1470,14 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 	cvmx_pko_l1_sqx_link_t l1link;
 	uint32_t crc32, pcrc32;
 	char lines[4][128];
+	int ciren, piren;
+	uint64_t dqsh_clk, pqsh_clk;
+	int shaper_rate(int shclk, int man, int exp, int div) {
+		return (CVMX_SHOFT_TO_U64(man, exp) * shclk >> div) * 8/*bits*/ / 1000000/*Mbps*/;
+	}
+	int shaper_burst(int man, int exp) {
+		return CVMX_SHOFT_TO_U64(man, (exp + 1));
+	}
 
 	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX) ||
 		OCTEON_IS_MODEL(OCTEON_CN73XX) ||
@@ -1477,6 +1485,9 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 		cvmx_printf("PKO3 Config Dump is not supported on this OCTEON model\n");
 		return 0;
 	}
+	dqsh_clk = cvmx_pko3_dq_tw_clock_rate_node(node);
+	pqsh_clk = cvmx_pko3_pq_tw_clock_rate_node(node);
+
 	memset(lines[3], '*', PKO_PRN_LINELEN);  lines[3][PKO_PRN_LINELEN] = '\0';
 	cvmx_printf("\n%s\n", lines[3]);
 	cvmx_printf("   PKO Configuration (Node %d)\n", node);
@@ -1642,135 +1653,229 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 		pcrc32 = crc32;
 		base = queue;
 		cvmx_printf("DQ%d:\n", queue);
-		PARPRINT(4, "Channel", "%*s%-*s%*s%*s%*s%*s%-*s%*s\n",
+		PARPRINT(2, "Channel", "%*s%-*s%*s%*s%*s%*s%-*s%*s\n",
 			PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8) + 1, lines[0],
 			PKO_PRN_DPLEN(8) - 1, "", PKO_PRN_DPLEN(8), lines[2],
 			PKO_PRN_DPLEN(8), lines[3], PKO_PRN_DPLEN(8), "",
 			PKO_PRN_DPLEN(8), chcfg.s.cc_enable ? "CC-En" : "CC-Dis",
 			PKO_PRN_DPLEN(8), l1link.s.cc_enable ? "LC-En" : "LC-Dis");
 		if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
-			PARPRINT(4, "Path", "%*s%*d%*d%*d%*d%*d%*d%*s\n",
+			ciren = dqcir.s.enable + l5cir.s.enable + l4cir.s.enable +
+				l3cir.s.enable + l2cir.s.enable + l1cir.s.enable;
+			piren = dqpir.s.enable + l5pir.s.enable + l4pir.s.enable +
+				l3pir.s.enable + l2pir.s.enable;
+
+			PARPRINT(2, "Path", "%*s%*d%*d%*d%*d%*d%*d%*s\n",
 				PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), dqtop.s.parent,
 				PKO_PRN_DPLEN(8), l5top.s.parent, PKO_PRN_DPLEN(8), l4top.s.parent,
 				PKO_PRN_DPLEN(8), l3top.s.parent, PKO_PRN_DPLEN(8), l2top.s.parent,
 				PKO_PRN_DPLEN(8), l1top.s.link, PKO_PRN_DPLEN(8), lines[1]);
-			PARPRINT(4, "Prio-Anchor", "%*s%*d%*d%*d%*d%*d%*s%*s\n",
+			PARPRINT(2, "Prio-Anchor", "%*s%*d%*d%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), l5top.s.prio_anchor,
 				PKO_PRN_DPLEN(8), l4top.s.prio_anchor, PKO_PRN_DPLEN(8), l3top.s.prio_anchor,
 				PKO_PRN_DPLEN(8), l2top.s.prio_anchor, PKO_PRN_DPLEN(8), l1top.s.prio_anchor,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "Prio", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
+			PARPRINT(2, "Prio", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqsch.s.prio, PKO_PRN_DPLEN(8), l5sch.s.prio,
 				PKO_PRN_DPLEN(8), l4sch.s.prio, PKO_PRN_DPLEN(8), l3sch.s.prio,
 				PKO_PRN_DPLEN(8), l2sch.s.prio, PKO_PRN_DPLEN(8), "--",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "RR-Prio", "%*s%*d%*d%*d%*d%*d%*s%*s\n",
+			PARPRINT(2, "RR-Prio", "%*s%*d%*d%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), l5top.s.rr_prio,
 				PKO_PRN_DPLEN(8), l4top.s.rr_prio, PKO_PRN_DPLEN(8), l3top.s.rr_prio,
 				PKO_PRN_DPLEN(8), l2top.s.rr_prio, PKO_PRN_DPLEN(8), l1top.s.rr_prio,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "RR-Quantum", "%*x%*x%*x%*x%*x%*x%*s%*s\n",
+			PARPRINT(2, "RR-Quantum", "%*x%*x%*x%*x%*x%*x%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqsch.s.rr_quantum, PKO_PRN_DPLEN(8), l5sch.s.rr_quantum,
 				PKO_PRN_DPLEN(8), l4sch.s.rr_quantum, PKO_PRN_DPLEN(8), l3sch.s.rr_quantum,
 				PKO_PRN_DPLEN(8), l2sch.s.rr_quantum, PKO_PRN_DPLEN(8), l1sch.s.rr_quantum,
 				PKO_PRN_DPLEN(8), "(hex)", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "Length Dis", "%*d%*d%*d%*d%*d%*d%*s%*s\n",
+			PARPRINT(2, "Len.Disable", "%*d%*d%*d%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqshape.s.length_disable, PKO_PRN_DPLEN(8), l5shape.s.length_disable,
 				PKO_PRN_DPLEN(8), l4shape.s.length_disable, PKO_PRN_DPLEN(8), l3shape.s.length_disable,
 				PKO_PRN_DPLEN(8), l2shape.s.length_disable, PKO_PRN_DPLEN(8), l1shape.s.length_disable,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "Adjust", "%*d%*d%*d%*d%*d%*d%*s%*s\n",
+			PARPRINT(2, "Len.Adjust", "%*d%*d%*d%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqshape.s.adjust, PKO_PRN_DPLEN(8), l5shape.s.adjust,
 				PKO_PRN_DPLEN(8), l4shape.s.adjust, PKO_PRN_DPLEN(8), l3shape.s.adjust,
 				PKO_PRN_DPLEN(8), l2shape.s.adjust, PKO_PRN_DPLEN(8), l1shape.s.adjust,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "YELLOW Dis", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
-				PKO_PRN_DPLEN(8), dqshape.s.yellow_disable, PKO_PRN_DPLEN(8), l5shape.s.yellow_disable,
-				PKO_PRN_DPLEN(8), l4shape.s.yellow_disable, PKO_PRN_DPLEN(8), l3shape.s.yellow_disable,
-				PKO_PRN_DPLEN(8), l2shape.s.yellow_disable, PKO_PRN_DPLEN(8), "--",
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "RED Dis", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
-				PKO_PRN_DPLEN(8), dqshape.s.red_disable, PKO_PRN_DPLEN(8), l5shape.s.red_disable,
-				PKO_PRN_DPLEN(8), l4shape.s.red_disable, PKO_PRN_DPLEN(8), l3shape.s.red_disable,
-				PKO_PRN_DPLEN(8), l2shape.s.red_disable, PKO_PRN_DPLEN(8), "--",
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "RED Algo", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
-				PKO_PRN_DPLEN(8), dqshape.s.red_algo, PKO_PRN_DPLEN(8), l5shape.s.red_algo,
-				PKO_PRN_DPLEN(8), l4shape.s.red_algo, PKO_PRN_DPLEN(8), l3shape.s.red_algo,
-				PKO_PRN_DPLEN(8), l2shape.s.red_algo, PKO_PRN_DPLEN(8), "--",
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "PIR Enable", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
-				PKO_PRN_DPLEN(8), dqpir.s.enable, PKO_PRN_DPLEN(8), l5pir.s.enable,
-				PKO_PRN_DPLEN(8), l4pir.s.enable, PKO_PRN_DPLEN(8), l3pir.s.enable,
-				PKO_PRN_DPLEN(8), l2pir.s.enable, PKO_PRN_DPLEN(8), "--",
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "CIR Enable", "%*d%*d%*d%*d%*d%*d%*s%*s\n",
-				PKO_PRN_DPLEN(8), dqcir.s.enable, PKO_PRN_DPLEN(8), l5cir.s.enable,
-				PKO_PRN_DPLEN(8), l4cir.s.enable, PKO_PRN_DPLEN(8), l3cir.s.enable,
-				PKO_PRN_DPLEN(8), l2cir.s.enable, PKO_PRN_DPLEN(8), l1cir.s.enable,
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			if (ciren || piren) {
+				PARPRINT(2, "YELLOW Dis", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
+					PKO_PRN_DPLEN(8), dqshape.s.yellow_disable, PKO_PRN_DPLEN(8), l5shape.s.yellow_disable,
+					PKO_PRN_DPLEN(8), l4shape.s.yellow_disable, PKO_PRN_DPLEN(8), l3shape.s.yellow_disable,
+					PKO_PRN_DPLEN(8), l2shape.s.yellow_disable, PKO_PRN_DPLEN(8), "--",
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+				PARPRINT(2, "RED Dis", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
+					PKO_PRN_DPLEN(8), dqshape.s.red_disable, PKO_PRN_DPLEN(8), l5shape.s.red_disable,
+					PKO_PRN_DPLEN(8), l4shape.s.red_disable, PKO_PRN_DPLEN(8), l3shape.s.red_disable,
+					PKO_PRN_DPLEN(8), l2shape.s.red_disable, PKO_PRN_DPLEN(8), "--",
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+				PARPRINT(2, "RED Algo", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
+					PKO_PRN_DPLEN(8), dqshape.s.red_algo, PKO_PRN_DPLEN(8), l5shape.s.red_algo,
+					PKO_PRN_DPLEN(8), l4shape.s.red_algo, PKO_PRN_DPLEN(8), l3shape.s.red_algo,
+					PKO_PRN_DPLEN(8), l2shape.s.red_algo, PKO_PRN_DPLEN(8), "--",
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			}
+			if (ciren) {
+				PARPRINT(2, "CIR Enable", "%*d%*d%*d%*d%*d%*d%*s%*s\n",
+					PKO_PRN_DPLEN(8), dqcir.s.enable, PKO_PRN_DPLEN(8), l5cir.s.enable,
+					PKO_PRN_DPLEN(8), l4cir.s.enable, PKO_PRN_DPLEN(8), l3cir.s.enable,
+					PKO_PRN_DPLEN(8), l2cir.s.enable, PKO_PRN_DPLEN(8), l1cir.s.enable,
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+				PARPRINT(2, "CIR Burst", "%*d%*d%*d%*d%*d%*d%*s%*s\n",
+					PKO_PRN_DPLEN(8), shaper_burst(dqcir.s.burst_mantissa, dqcir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), shaper_burst(l5cir.s.burst_mantissa, l5cir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), shaper_burst(l4cir.s.burst_mantissa, l4cir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), shaper_burst(l3cir.s.burst_mantissa, l3cir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), shaper_burst(l2cir.s.burst_mantissa, l2cir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), shaper_burst(l1cir.s.burst_mantissa, l1cir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), "(bytes)", PKO_PRN_DPLEN(8), "");
+				PARPRINT(2, "CIR Rate", "%*d%*d%*d%*d%*d%*d%*s%*s\n",
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, dqcir.s.rate_mantissa,
+						dqcir.s.rate_exponent, dqcir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, l5cir.s.rate_mantissa,
+						l5cir.s.rate_exponent, l5cir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, l4cir.s.rate_mantissa,
+						l4cir.s.rate_exponent, l4cir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, l3cir.s.rate_mantissa,
+						l3cir.s.rate_exponent, l3cir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, l2cir.s.rate_mantissa,
+						l2cir.s.rate_exponent, l2cir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), shaper_rate(pqsh_clk, l1cir.s.rate_mantissa,
+						l1cir.s.rate_exponent, l1cir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), "(Mbps)", PKO_PRN_DPLEN(8), "");
+			}
+			if (piren) {
+				PARPRINT(2, "PIR Enable", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
+					PKO_PRN_DPLEN(8), dqpir.s.enable, PKO_PRN_DPLEN(8), l5pir.s.enable,
+					PKO_PRN_DPLEN(8), l4pir.s.enable, PKO_PRN_DPLEN(8), l3pir.s.enable,
+					PKO_PRN_DPLEN(8), l2pir.s.enable, PKO_PRN_DPLEN(8), "--",
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+				PARPRINT(2, "PIR Burst", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
+					PKO_PRN_DPLEN(8), shaper_burst(dqpir.s.burst_mantissa, dqpir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), shaper_burst(l5pir.s.burst_mantissa, l5pir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), shaper_burst(l4pir.s.burst_mantissa, l4pir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), shaper_burst(l3pir.s.burst_mantissa, l3pir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), shaper_burst(l2pir.s.burst_mantissa, l2pir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), "(bytes)", PKO_PRN_DPLEN(8), "");
+				PARPRINT(2, "PIR Rate", "%*d%*d%*d%*d%*d%*s%*s%*s\n",
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, dqpir.s.rate_mantissa,
+						dqpir.s.rate_exponent, dqpir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, l5pir.s.rate_mantissa,
+						l5pir.s.rate_exponent, l5pir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, l4pir.s.rate_mantissa,
+						l4pir.s.rate_exponent, l4pir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, l3pir.s.rate_mantissa,
+						l3pir.s.rate_exponent, l3pir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, l2pir.s.rate_mantissa,
+						l2pir.s.rate_exponent, l2pir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), "(Mbps)", PKO_PRN_DPLEN(8), "");
+			}
 		}
 		else {
-			PARPRINT(4, "Path", "%*s%*s%*s%*d%*d%*d%*d%*s\n",
+			ciren = dqcir.s.enable + l3cir.s.enable + l2cir.s.enable + l1cir.s.enable;
+			piren = dqpir.s.enable + l3pir.s.enable + l2pir.s.enable;
+
+			PARPRINT(2, "Path", "%*s%*s%*s%*d%*d%*d%*d%*s\n",
 				PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), "",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), dqtop.s.parent,
 				PKO_PRN_DPLEN(8), l3top.s.parent, PKO_PRN_DPLEN(8), l2top.s.parent,
 				PKO_PRN_DPLEN(8), l1top.s.link, PKO_PRN_DPLEN(8), lines[1]);
-			PARPRINT(4, "Prio-Anchor", "%*s%*s%*s%*d%*d%*d%*s%*s\n",
+			PARPRINT(2, "Prio-Anchor", "%*s%*s%*s%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), "",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3top.s.prio_anchor,
 				PKO_PRN_DPLEN(8), l2top.s.prio_anchor, PKO_PRN_DPLEN(8), l1top.s.prio_anchor,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "Prio", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
+			PARPRINT(2, "Prio", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqsch.s.prio, PKO_PRN_DPLEN(8), "",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3sch.s.prio,
 				PKO_PRN_DPLEN(8), l2sch.s.prio, PKO_PRN_DPLEN(8), "--",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "RR-Prio", "%*s%*s%*s%*d%*d%*d%*s%*s\n",
+			PARPRINT(2, "RR-Prio", "%*s%*s%*s%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), "",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3top.s.rr_prio,
 				PKO_PRN_DPLEN(8), l2top.s.rr_prio, PKO_PRN_DPLEN(8), l1top.s.rr_prio,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "RR-Quantum", "%*x%*s%*s%*x%*x%*x%*s%*s\n",
+			PARPRINT(2, "RR-Quantum", "%*x%*s%*s%*x%*x%*x%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqsch.s.rr_quantum, PKO_PRN_DPLEN(8), "",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3sch.s.rr_quantum,
 				PKO_PRN_DPLEN(8), l2sch.s.rr_quantum, PKO_PRN_DPLEN(8), l1sch.s.rr_quantum,
 				PKO_PRN_DPLEN(8), "(hex)", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "Length Dis", "%*d%*s%*s%*d%*d%*d%*s%*s\n",
+			PARPRINT(2, "Len.Disable", "%*d%*s%*s%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqshape.s.length_disable, PKO_PRN_DPLEN(8), "",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.length_disable,
 				PKO_PRN_DPLEN(8), l2shape.s.length_disable, PKO_PRN_DPLEN(8), l1shape.s.length_disable,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "Adjust", "%*d%*s%*s%*d%*d%*d%*s%*s\n",
+			PARPRINT(2, "Len.Adjust", "%*d%*s%*s%*d%*d%*d%*s%*s\n",
 				PKO_PRN_DPLEN(8), dqshape.s.adjust, PKO_PRN_DPLEN(8), "",
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.adjust,
 				PKO_PRN_DPLEN(8), l2shape.s.adjust, PKO_PRN_DPLEN(8), l1shape.s.adjust,
 				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "YELLOW Dis", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
-				PKO_PRN_DPLEN(8), dqshape.s.yellow_disable, PKO_PRN_DPLEN(8), "",
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.yellow_disable,
-				PKO_PRN_DPLEN(8), l2shape.s.yellow_disable, PKO_PRN_DPLEN(8), "--",
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "RED Dis", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
-				PKO_PRN_DPLEN(8), dqshape.s.red_disable, PKO_PRN_DPLEN(8), "",
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.red_disable,
-				PKO_PRN_DPLEN(8), l2shape.s.red_disable, PKO_PRN_DPLEN(8), "--",
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "RED Algo", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
-				PKO_PRN_DPLEN(8), dqshape.s.red_algo, PKO_PRN_DPLEN(8), "",
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.red_algo,
-				PKO_PRN_DPLEN(8), l2shape.s.red_algo, PKO_PRN_DPLEN(8), "--",
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "PIR Enable", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
-				PKO_PRN_DPLEN(8), dqpir.s.enable, PKO_PRN_DPLEN(8), "",
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3pir.s.enable,
-				PKO_PRN_DPLEN(8), l2pir.s.enable, PKO_PRN_DPLEN(8), "--",
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
-			PARPRINT(4, "CIR Enable", "%*d%*s%*s%*d%*d%*d%*s%*s\n",
-				PKO_PRN_DPLEN(8), dqcir.s.enable, PKO_PRN_DPLEN(8), "",
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3cir.s.enable,
-				PKO_PRN_DPLEN(8), l2cir.s.enable, PKO_PRN_DPLEN(8), l1cir.s.enable,
-				PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			if (ciren || piren) {
+				PARPRINT(2, "YELLOW Dis", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
+					PKO_PRN_DPLEN(8), dqshape.s.yellow_disable, PKO_PRN_DPLEN(8), "",
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.yellow_disable,
+					PKO_PRN_DPLEN(8), l2shape.s.yellow_disable, PKO_PRN_DPLEN(8), "--",
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+				PARPRINT(2, "RED Dis", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
+					PKO_PRN_DPLEN(8), dqshape.s.red_disable, PKO_PRN_DPLEN(8), "",
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.red_disable,
+					PKO_PRN_DPLEN(8), l2shape.s.red_disable, PKO_PRN_DPLEN(8), "--",
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+				PARPRINT(2, "RED Algo", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
+					PKO_PRN_DPLEN(8), dqshape.s.red_algo, PKO_PRN_DPLEN(8), "",
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3shape.s.red_algo,
+					PKO_PRN_DPLEN(8), l2shape.s.red_algo, PKO_PRN_DPLEN(8), "--",
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+			}
+			if (ciren) {
+				PARPRINT(2, "CIR Enable", "%*d%*s%*s%*d%*d%*d%*s%*s\n",
+					PKO_PRN_DPLEN(8), dqcir.s.enable, PKO_PRN_DPLEN(8), "",
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3cir.s.enable,
+					PKO_PRN_DPLEN(8), l2cir.s.enable, PKO_PRN_DPLEN(8), l1cir.s.enable,
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+				PARPRINT(2, "CIR Burst", "%*d%*s%*s%*d%*d%*d%*s%*s\n",
+					PKO_PRN_DPLEN(8), shaper_burst(dqcir.s.burst_mantissa, dqcir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "",
+					PKO_PRN_DPLEN(8), shaper_burst(l3cir.s.burst_mantissa, l3cir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), shaper_burst(l2cir.s.burst_mantissa, l2cir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), shaper_burst(l1cir.s.burst_mantissa, l1cir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), "(bytes)", PKO_PRN_DPLEN(8), "");
+				PARPRINT(2, "CIR Rate", "%*d%*s%*s%*d%*d%*d%*s%*s\n",
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, dqcir.s.rate_mantissa,
+						dqcir.s.rate_exponent, dqcir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "",
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, l3cir.s.rate_mantissa,
+						l3cir.s.rate_exponent, l3cir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, l2cir.s.rate_mantissa,
+						l2cir.s.rate_exponent, l2cir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), shaper_rate(pqsh_clk, l1cir.s.rate_mantissa,
+						l1cir.s.rate_exponent, l1cir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), "(Mbps)", PKO_PRN_DPLEN(8), "");
+			}
+			if (piren) {
+				PARPRINT(2, "PIR Enable", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
+					PKO_PRN_DPLEN(8), dqpir.s.enable, PKO_PRN_DPLEN(8), "",
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), l3pir.s.enable,
+					PKO_PRN_DPLEN(8), l2pir.s.enable, PKO_PRN_DPLEN(8), "--",
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "");
+				PARPRINT(2, "PIR Burst", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
+					PKO_PRN_DPLEN(8), shaper_burst(dqpir.s.burst_mantissa, dqpir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "",
+					PKO_PRN_DPLEN(8), shaper_burst(l3pir.s.burst_mantissa, l3pir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), shaper_burst(l2pir.s.burst_mantissa, l2pir.s.burst_exponent),
+					PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), "(bytes)", PKO_PRN_DPLEN(8), "");
+				PARPRINT(2, "PIR Rate", "%*d%*s%*s%*d%*d%*s%*s%*s\n",
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, dqpir.s.rate_mantissa,
+						dqpir.s.rate_exponent, dqpir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), "", PKO_PRN_DPLEN(8), "",
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, l3pir.s.rate_mantissa,
+						l3pir.s.rate_exponent, l3pir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), shaper_rate(dqsh_clk, l2pir.s.rate_mantissa,
+						l2pir.s.rate_exponent, l2pir.s.rate_divider_exponent),
+					PKO_PRN_DPLEN(8), "--", PKO_PRN_DPLEN(8), "(Mbps)", PKO_PRN_DPLEN(8), "");
+			}
 		}
 	}
 	if ((queue - 1) != base)
@@ -1800,8 +1905,8 @@ int cvmx_helper_pko3_config_dump(unsigned int node)
 		base = group;
 		cvmx_printf("Group %d: (%d, %d, %d, %d)\n",
 			group, group * 4, group * 4 + 1, group * 4 + 2, group * 4 + 3);
-		PARPRINT(4, "Size", "%*d\n", PKO_PRN_DPLEN(1), fgcfg.s.size);
-		PARPRINT(4, "Rate", "%*d\n", PKO_PRN_DPLEN(1), fgcfg.s.rate);
+		PARPRINT(2, "Size", "%*d\n", PKO_PRN_DPLEN(1), fgcfg.s.size);
+		PARPRINT(2, "Rate", "%*d\n", PKO_PRN_DPLEN(1), fgcfg.s.rate);
 	}
 	if ((group - 1) != base)
 		cvmx_printf("\nGROUP(s) %02d-%02d -- same as GROUP %02d\n",
@@ -1856,7 +1961,7 @@ int cvmx_helper_pko3_stats_dump(unsigned int node)
 		case 2: sprintf(lines[0], "Red"); break;
 		default: sprintf(lines[0], "Undef"); break;
 		}
-		PARPRINT(4, "Color", "%*s\n", PKO_PRN_DPLEN(1), lines[0]);
+		PARPRINT(4, "Conn.Status", "%*s\n", PKO_PRN_DPLEN(1), lines[0]);
 		PARPRINT(4, "PIR Accum", "%*d\n", PKO_PRN_DPLEN(1), dq_shape_stat.s.pir_accum);
 		PARPRINT(4, "CIR Accum", "%*d\n", PKO_PRN_DPLEN(1), dq_shape_stat.s.cir_accum);
 		if (dq_pkts.s.count)
@@ -1877,6 +1982,8 @@ int cvmx_helper_pko3_stats_dump(unsigned int node)
 		l1_yelbytes.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_YELLOW_BYTES(queue));
 		l1_redpkts.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_RED_PACKETS(queue));
 		l1_redbytes.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_RED_BYTES(queue));
+		l1_drppkts.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_DROPPED_PACKETS(queue));
+		l1_drpbytes.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_DROPPED_BYTES(queue));
 		n = l1_grnpkts.s.count + l1_grnbytes.s.count + l1_yelpkts.s.count + l1_yelbytes.s.count +
 			l1_redpkts.s.count + l1_redbytes.s.count + l1_drppkts.s.count + l1_drpbytes.s.count;
 		if (n == 0)
@@ -1892,7 +1999,7 @@ int cvmx_helper_pko3_stats_dump(unsigned int node)
 			sprintf(lines[0], "%s", pko_macmap[l1top.s.link][2]);
 		maccfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_MACX_CFG(l1top.s.link));
 		cvmx_printf("L1-SQ%d => MAC%d (%s) => FIFO%d:\n", queue, l1top.s.link, lines[0], maccfg.s.fifo_num);
-		PARPRINT(4, "Color", "%*s\n", PKO_PRN_DPLEN(1), (l1_shape_stat.s.color == 0) ? "Green" : "Red");
+		PARPRINT(4, "Conn.Status", "%*s\n", PKO_PRN_DPLEN(1), (l1_shape_stat.s.color == 0) ? "Green" : "Red");
 		PARPRINT(4, "CIR Accum", "%*d\n", PKO_PRN_DPLEN(1), l1_shape_stat.s.cir_accum);
 		if (l1_grnpkts.s.count)
 			PARPRINT(4, "Green Packets", "%*lld\n", PKO_PRN_DPLEN(1), (long long)l1_grnpkts.s.count);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
index 030c14c..0880e32 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
@@ -43,7 +43,7 @@
  * Functions for SGMII initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 107438 $<hr>
+ * <hr>$Revision: 122069 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -682,7 +682,8 @@ cvmx_helper_link_info_t __cvmx_helper_sgmii_link_get(int ipd_port)
 
 	pcsx_miscx_ctl_reg.u64 =
 		cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
-	if (pcsx_miscx_ctl_reg.s.mac_phy) {
+	if (pcsx_miscx_ctl_reg.s.mac_phy ||
+	    cvmx_helper_get_port_force_link_up(interface, index)) {
 		/* PHY Mode */
 		/* Note that this also works for 1000base-X mode */
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper.c b/arch/mips/cavium-octeon/executive/cvmx-helper.c
index 8d762f5e..a41264a 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper.c
@@ -803,10 +803,14 @@ static cvmx_helper_interface_mode_t __cvmx_get_mode_cn78xx(int xiface)
 			iface_node_ops[xi.node][xi.interface] = &iface_ops_bgx_xlaui;
 		else if (qlm_mode == CVMX_QLM_MODE_XFI)
 			iface_node_ops[xi.node][xi.interface] = &iface_ops_bgx_xfi;
+#ifndef CVMX_BUILD_FOR_UBOOT
+		/* Disable 10G_KR and 40G_KR4 in u-boot, 78xx pass1.x has
+		   errata related to training */
 		else if (qlm_mode == CVMX_QLM_MODE_10G_KR)
 			iface_node_ops[xi.node][xi.interface] = &iface_ops_bgx_10G_KR;
 		else if (qlm_mode == CVMX_QLM_MODE_40G_KR4)
 			iface_node_ops[xi.node][xi.interface] = &iface_ops_bgx_40G_KR4;
+#endif
 		else if (qlm_mode == CVMX_QLM_MODE_RXAUI)
 			iface_node_ops[xi.node][xi.interface] = &iface_ops_bgx_rxaui;
 		else
diff --git a/arch/mips/cavium-octeon/executive/cvmx-ila.c b/arch/mips/cavium-octeon/executive/cvmx-ila.c
new file mode 100644
index 0000000..cab3ede
--- /dev/null
+++ b/arch/mips/cavium-octeon/executive/cvmx-ila.c
@@ -0,0 +1,295 @@
+/***********************license start***************
+ * Copyright (c) 2014  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Functions to configure the ILK-LA interface.
+ *
+ * <hr>$Id$<hr>
+ */
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-ila.h>
+#include <asm/octeon/cvmx-ila-defs.h>
+#include <asm/octeon/cvmx-qlm.h>
+#else
+#include "cvmx.h"
+#include "cvmx-helper.h"
+#include "cvmx-ila.h"
+#include "cvmx-qlm.h"
+#endif
+
+CVMX_SHARED int cvmx_ila_chans = 2;
+
+/**
+ * @INTERNAL
+ * Return the link state of an IPD/PKO port as returned by ILK-LA link status.
+ *
+ * @param lane_mask lane_mask
+ *
+ * @return Link state
+ */
+static cvmx_helper_link_info_t __cvmx_ila_link_get(int lane_mask)
+{
+	cvmx_helper_link_info_t result;
+	int node = cvmx_get_node_num();
+	int retry_count = 0;
+	cvmx_ila_rxx_cfg1_t rx_cfg1;
+	cvmx_ila_rxx_int_t rx_int;
+	int i;
+
+	result.u64 = 0;
+
+retry:
+	retry_count++;
+	if (retry_count > 10)
+		goto fail;
+
+	/* Read RX config and status bits */
+	rx_cfg1.u64 = cvmx_read_csr_node(node, CVMX_ILA_RXX_CFG1(0));
+	rx_int.u64 = cvmx_read_csr_node(node, CVMX_ILA_RXX_INT(0));
+
+	if (rx_cfg1.s.rx_bdry_lock_ena == 0) {
+		/* Clear the boundary lock status bit */
+		rx_int.u64 = 0;
+		rx_int.s.word_sync_done = 1;
+		cvmx_write_csr_node(node, CVMX_ILA_RXX_INT(0), rx_int.u64);
+
+		/* We need to start looking for work boundary lock */
+		rx_cfg1.s.rx_bdry_lock_ena = lane_mask;
+		rx_cfg1.s.rx_align_ena = 0;
+		cvmx_write_csr_node(node, CVMX_ILA_RXX_CFG1(0), rx_cfg1.u64);
+		//cvmx_dprintf("ILK-LA: Looking for word boundary lock\n");
+
+		goto retry;
+	}
+
+	if (rx_cfg1.s.rx_align_ena == 0) {	
+		if (rx_int.s.word_sync_done) {
+			/* Clear the lane align status bits */
+			rx_int.u64 = 0;
+			rx_int.s.lane_align_fail = 1;
+			rx_int.s.lane_align_done = 1;
+			cvmx_write_csr_node(node, CVMX_ILA_RXX_INT(0), rx_int.u64);
+
+			rx_cfg1.s.rx_align_ena = 1;
+			cvmx_write_csr_node(node, CVMX_ILA_RXX_CFG1(0), rx_cfg1.u64);
+			//cvmx_printf("ILK-LA: Looking for lane alignment\n");
+			goto retry;
+		}
+		goto fail;
+	}
+
+	if (rx_int.s.lane_align_fail) {	
+		rx_cfg1.s.rx_bdry_lock_ena = 0;
+		rx_cfg1.s.rx_align_ena = 0;
+		cvmx_write_csr_node(node, CVMX_ILA_RXX_CFG1(0), rx_cfg1.u64);
+		//cvmx_dprintf("ILK-LA: Lane alignment failed\n");
+		goto fail;
+	}
+
+	if (rx_cfg1.s.pkt_ena == 0 && rx_int.s.lane_align_done) {
+		cvmx_ila_txx_cfg1_t tx_cfg1;
+
+		rx_cfg1.u64 = cvmx_read_csr_node(node, CVMX_ILA_RXX_CFG1(0));
+		tx_cfg1.u64 = cvmx_read_csr_node(node, CVMX_ILA_TXX_CFG1(0));
+
+		rx_cfg1.s.pkt_ena = tx_cfg1.s.pkt_ena = 1;
+		cvmx_write_csr_node(node, CVMX_ILA_RXX_CFG1(0), rx_cfg1.u64);
+		cvmx_write_csr_node(node, CVMX_ILA_TXX_CFG1(0), tx_cfg1.u64);
+
+		/* Clear and enable error interrupts */
+		for (i = 0; i < 8; i++) {
+			if ((1 << i) & lane_mask) {
+				/* Clear pending interrupts */
+				cvmx_write_csr_node(node, CVMX_ILA_RX_LNEX_INT(i), 0x3ff);
+				/* Enable bad_64b67b, bdry_sync_loss, crc32_err, dskew_fifo_ovfl,
+ *                                    scrm_sync_loss, serdes_lock_loss, stat_msg, ukwn_cntl_word */
+			}
+		}
+
+		//cvmx_dprintf("ILK-LA: Lane alignment complete\n");
+	}
+
+	result.u64 = 0;
+	result.s.link_up = 1;
+	result.s.full_duplex = 1;
+	result.s.speed = cvmx_qlm_get_gbaud_mhz(2) * 64 / 67;
+	result.s.speed *= cvmx_pop(lane_mask);
+
+	return result;
+
+fail:
+	if (rx_cfg1.s.pkt_ena) {
+		/* Disable the interface */
+		rx_cfg1.s.pkt_ena = 0;
+		cvmx_write_csr_node(node, CVMX_ILA_RXX_CFG1(0), rx_cfg1.u64);
+
+		/* Disable error interrupts */
+	}
+
+	return result;
+}
+
+/**
+ * Initialize ILK-LA interface
+ *
+ * @param lane_mask  Lanes to initialize ILK-LA interface.
+ * @return  0 on success and -1 on failure.
+ */
+int cvmx_ila_initialize(int lane_mask)
+{
+	cvmx_ila_rxx_cfg0_t rx_cfg0;
+	cvmx_ila_txx_cfg0_t tx_cfg0;
+	cvmx_ila_rxx_cfg1_t rx_cfg1;
+	cvmx_ila_txx_cfg1_t tx_cfg1;
+	cvmx_ila_txx_cha_xon_t tx_cha_xon;
+	cvmx_ila_ser_cfg_t ser_cfg;
+	int node = cvmx_get_node_num();
+	int lane0 = 0, lane1 = 0;
+	cvmx_helper_link_info_t result;
+	int retry_count = 0;
+
+	ser_cfg.u64 = cvmx_read_csr_node(node, CVMX_ILA_SER_CFG);
+	ser_cfg.s.ser_rxpol_auto = 1;
+	cvmx_write_csr_node(node, CVMX_ILA_SER_CFG, ser_cfg.u64);
+
+	if (cvmx_qlm_get_mode_cn78xx(node, 2) == CVMX_QLM_MODE_ILK)
+		lane0 = 0xf;
+
+	if (cvmx_qlm_get_mode_cn78xx(node, 3) == CVMX_QLM_MODE_ILK)
+		lane1 = 0xf;
+
+	if ((lane_mask & 0xf) != lane0) {
+		cvmx_dprintf("ERROR: Invalid configuration for QLM2\n");
+		return -1;
+	}
+	if (((lane_mask >> 4) & 0xf) == lane1) {
+		cvmx_dprintf("ERROR: Invalid configuration for QLM3\n");
+		return -1;
+	}
+
+	/* Enable RX lanes */
+	rx_cfg0.u64 = cvmx_read_csr_node(node, CVMX_ILA_RXX_CFG0(0));
+	rx_cfg0.s.lane_ena = lane_mask;
+	cvmx_write_csr_node(node, CVMX_ILA_RXX_CFG0(0), rx_cfg0.u64);
+
+	/* Enable TX lanes */
+	tx_cfg0.u64 = cvmx_read_csr_node(node, CVMX_ILA_TXX_CFG0(0));
+	tx_cfg0.s.lane_ena = lane_mask;
+	cvmx_write_csr_node(node, CVMX_ILA_TXX_CFG0(0), tx_cfg0.u64);
+
+	/* Set XON/XOFF state to XON */
+	tx_cha_xon.u64 = cvmx_read_csr_node(node, CVMX_ILA_TXX_CHA_XON(0));
+	tx_cha_xon.s.ch0_xon = 1;
+	tx_cha_xon.s.ch1_xon = 1;
+	cvmx_write_csr_node(node, CVMX_ILA_TXX_CHA_XON(0), tx_cha_xon.u64);
+
+	/* Enable TX packet reception. */
+	tx_cfg1.u64 = cvmx_read_csr_node(node, CVMX_ILA_TXX_CFG1(0));
+	tx_cfg1.s.pkt_ena = 1;
+	cvmx_write_csr_node(node, CVMX_ILA_TXX_CFG1(0), tx_cfg1.u64);	
+
+	result.u64 = 0;
+
+retry:
+	retry_count++;
+	if (retry_count > 10)
+		goto out;
+
+	/* Make sure the link is up, so that packets can be sent */
+	result = __cvmx_ila_link_get(lane_mask);
+
+	/* Small delay before another retry */
+	cvmx_wait_usec(100);
+
+	rx_cfg1.u64 = cvmx_read_csr_node(node, CVMX_ILA_RXX_CFG1(0));
+	if (rx_cfg1.s.pkt_ena == 0)
+		goto retry;
+
+out:
+	if (result.s.link_up)
+		return 0;
+
+	return -1;
+}
+
+int cvmx_ila_disable(void)
+{
+	int node = cvmx_get_node_num();
+	cvmx_ila_rxx_cfg0_t rx_cfg0;
+	cvmx_ila_txx_cfg0_t tx_cfg0;
+
+	/* Disable RX lanes */
+	rx_cfg0.u64 = cvmx_read_csr_node(node, CVMX_ILA_RXX_CFG0(0));
+	rx_cfg0.s.lane_ena = 0;
+	cvmx_write_csr_node(node, CVMX_ILA_RXX_CFG0(0), rx_cfg0.u64);
+
+	/* Disable TX lanes */
+	tx_cfg0.u64 = cvmx_read_csr_node(node, CVMX_ILA_TXX_CFG0(0));
+	tx_cfg0.s.lane_ena = 0;
+	cvmx_write_csr_node(node, CVMX_ILA_TXX_CFG0(0), tx_cfg0.u64);
+
+	return 0;
+}
+
+/**
+ * Enable or disable LA mode in ILK header.
+ *
+ * @param channel channel
+ * @param mode   If set, enable LA mode in ILK header, else disable
+ *
+ * @return ILK header
+ */
+cvmx_ila_header_t cvmx_ila_configure_header(int channel, int mode)
+{
+	cvmx_ila_header_t ila_header;
+
+	ila_header.u64 = 0;
+
+	if (mode) {
+		ila_header.s.la_mode = mode;
+		ila_header.s.ilk_channel = channel;
+	}
+
+	return ila_header;
+}
+			
diff --git a/arch/mips/cavium-octeon/executive/cvmx-l2c.c b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
index 8486cf4..006e63b 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-l2c.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-l2c.c
@@ -43,7 +43,7 @@
  * Implementation of the Level 2 Cache (L2C) control,
  * measurement, and debugging facilities.
  *
- * <hr>$Revision: 118038 $<hr>
+ * <hr>$Revision: 115982 $<hr>
  *
  */
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index dc6f44d..5fdfb0d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 122165 $<hr>
+ * <hr>$Revision: 122729 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -93,8 +93,10 @@
 #include "octeon_mem_map.h"
 #ifdef __U_BOOT__
 # include <libfdt.h>
+# include <asm/arch/cvmx-helper-fdt.h>
 #else
 # include "libfdt/libfdt.h"
+# include "libfdt/cvmx-helper-fdt.h"
 #endif
 #endif
 
@@ -224,7 +226,7 @@ static int __cvmx_pcie_get_qlm(int node, int pcie_port)
 				if (gserx_cfg.s.pcie)
 					return 5;  /* PEM2 is on DLM5 */
 				else
-					return -1; /* PEM2 is disabled */ 
+					return -1; /* PEM2 is disabled */
 			}
 			gserx_cfg.u64 = CVMX_READ_CSR(CVMX_GSERX_CFG(2));
 			if (gserx_cfg.s.pcie)
@@ -238,7 +240,7 @@ static int __cvmx_pcie_get_qlm(int node, int pcie_port)
 				if (gserx_cfg.s.pcie)
 					return 6;  /* PEM2 is on DLM5 */
 				else
-					return -1; /* PEM2 is disabled */ 
+					return -1; /* PEM2 is disabled */
 			}
 			pem_cfg.u64 = CVMX_READ_CSR(CVMX_PEMX_CFG(2));
 			gserx_cfg.u64 = CVMX_READ_CSR(CVMX_GSERX_CFG(3));
@@ -296,7 +298,7 @@ static int __cvmx_pcie_get_qlm(int node, int pcie_port)
 		default:
 			cvmx_dprintf("Invalid %d PCIe port\n", pcie_port);
 			return -1;
-		}	
+		}
 	} else if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
 		enum cvmx_qlm_mode mode1 = cvmx_qlm_get_mode(1);
 		enum cvmx_qlm_mode mode2 = cvmx_qlm_get_mode(2);
@@ -550,7 +552,7 @@ static void __cvmx_pcie_rc_initialize_config_space(int node, int pcie_port)
 
 			/* Set the target link speed */
 			cfg040.u32 = CVMX_PCIE_CFGX_READ(pcie_port,
-						CVMX_PCIERCX_CFG040(pcie_port));	
+						CVMX_PCIERCX_CFG040(pcie_port));
 			cfg040.s.tls = 1;
 			CVMX_PCIE_CFGX_WRITE(pcie_port, CVMX_PCIERCX_CFG040(pcie_port),
 						cfg040.u32);
@@ -562,7 +564,7 @@ static void __cvmx_pcie_rc_initialize_config_space(int node, int pcie_port)
 
 			/* Set the target link speed */
 			cfg040.u32 = CVMX_PCIE_CFGX_READ(pcie_port,
-						CVMX_PCIERCX_CFG040(pcie_port));	
+						CVMX_PCIERCX_CFG040(pcie_port));
 			cfg040.s.tls = 2;
 			CVMX_PCIE_CFGX_WRITE(pcie_port, CVMX_PCIERCX_CFG040(pcie_port),
 						cfg040.u32);
@@ -574,7 +576,7 @@ static void __cvmx_pcie_rc_initialize_config_space(int node, int pcie_port)
 
 			/* Set the target link speed */
 			cfg040.u32 = CVMX_PCIE_CFGX_READ(pcie_port,
-						CVMX_PCIERCX_CFG040(pcie_port));	
+						CVMX_PCIERCX_CFG040(pcie_port));
 			cfg040.s.tls = 3;
 			CVMX_PCIE_CFGX_WRITE(pcie_port, CVMX_PCIERCX_CFG040(pcie_port),
 						cfg040.u32);
@@ -582,10 +584,10 @@ static void __cvmx_pcie_rc_initialize_config_space(int node, int pcie_port)
 		default:
 			break;
 		}
-		
+
 		/* Link Width Mode (PCIERCn_CFG452[LME]) */
 		pem_cfg.u64 = CVMX_READ_CSR(CVMX_PEMX_CFG(pcie_port));
-		cfg452.u32 = CVMX_PCIE_CFGX_READ(pcie_port, CVMX_PCIERCX_CFG452(pcie_port));	
+		cfg452.u32 = CVMX_PCIE_CFGX_READ(pcie_port, CVMX_PCIERCX_CFG452(pcie_port));
 		if (qlm >= 5)
 			cfg452.s.lme = 0x3;
 		else
@@ -762,24 +764,23 @@ static void __cvmx_increment_ba(cvmx_sli_mem_access_subidx_t * pmas)
 /*
  * milliseconds to retry PCIe cfg-space access:
  * Value 32(unscaled) was recommended in HRM, but may be too small for
- * some PCIe devices. This 48mS default should cover most devices,
+ * some PCIe devices. This 200mS default should cover most devices,
  * but can be extended by bootparam cvmx-pcie.cfg_timeout, or reduced
  * to speed boot if it is known that no devices need so much time.
  */
-static int cfg_timeout = 48;
+static int cfg_timeout = 200;
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 module_param(cfg_timeout, int, 0644);
 MODULE_PARM_DESC(cfg_timeout, "PCIe config-space i/o timeout in mS,"
 	" to accomodate slow-to-start devices");
 #endif
-
 static int cfg_retries(void)
 {
 	static int cfg_ticks = -1;
 
 	if (cfg_ticks < 0) {
 		uint64_t nS = cfg_timeout * 1000000;
-		const int ceiling = 0xffff;
+		const int ceiling = 0xfffff;
 
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 		cfg_ticks = nS / (octeon_get_io_clock_rate() >> 16);
@@ -1202,7 +1203,9 @@ static int __cvmx_pcie_rc_initialize_link_gen2(int node, int pcie_port)
 	cvmx_pciercx_cfg448_t pciercx_cfg448;
 
 	if (OCTEON_IS_OCTEON3()) {
-		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_PEMX_ON(pcie_port), cvmx_pemx_on_t, pemoor, ==, 1, 100000)) {
+		if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_PEMX_ON(pcie_port),
+					       cvmx_pemx_on_t, pemoor, ==, 1,
+					       100000)) {
 			cvmx_printf("%d:PCIe: Port %d PEM not on, skipping\n", node, pcie_port);
 			return -1;
 		}
@@ -1210,7 +1213,8 @@ static int __cvmx_pcie_rc_initialize_link_gen2(int node, int pcie_port)
 
 	/* Remember if the link should be Gen3. This is needed for the CN78XX
 	   pass 1.x workaround below */
-	pciercx_cfg031.u32 = CVMX_PCIE_CFGX_READ(pcie_port, CVMX_PCIERCX_CFG031(pcie_port));
+	pciercx_cfg031.u32 = CVMX_PCIE_CFGX_READ(pcie_port,
+						 CVMX_PCIERCX_CFG031(pcie_port));
 	try_gen3 = (pciercx_cfg031.s.mls == 3);
 
 	/* Errata (GSER-21178) PCIe gen3 doesn't work */
@@ -1232,8 +1236,9 @@ static int __cvmx_pcie_rc_initialize_link_gen2(int node, int pcie_port)
 	/* Wait for the link to come up */
 	start_cycle = cvmx_get_cycle();
 	do {
-		if (cvmx_get_cycle() - start_cycle > cvmx_clock_get_rate(CVMX_CLOCK_CORE))
+		if (cvmx_get_cycle() - start_cycle > cvmx_clock_get_rate(CVMX_CLOCK_CORE)) {
 			return -1;
+		}
 		cvmx_wait(10000);
 		pciercx_cfg032.u32 = CVMX_PCIE_CFGX_READ(pcie_port,
 							 CVMX_PCIERCX_CFG032(pcie_port));
@@ -1367,7 +1372,7 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 	cvmx_sli_mem_access_ctl_t sli_mem_access_ctl;
 	cvmx_sli_mem_access_subidx_t mem_access_subid;
 	cvmx_pemx_bar1_indexx_t bar1_index;
-	uint64_t ciu_soft_prst_reg, rst_ctl_reg;
+	uint64_t ciu_soft_prst_reg, ciu_soft_prst_reg_alt, rst_ctl_reg;
 	int ep_mode;
 	int qlm;
 	int node = (pcie_port >> 4) & 0x3;
@@ -1391,6 +1396,7 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 				    pcie_port);
 			return -1;
 		}
+		mode = cvmx_qlm_get_mode(qlm);
 	} else if (octeon_has_feature(OCTEON_FEATURE_PCIE)) {
 		/* Requires reading the MIO_QLMX_CFG register to figure
 		   out the port type. */
@@ -1465,10 +1471,13 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 	 */
 	if (OCTEON_IS_OCTEON3()) {
 		ciu_soft_prst_reg = CVMX_RST_SOFT_PRSTX(pcie_port);
+		ciu_soft_prst_reg_alt = CVMX_RST_SOFT_PRSTX(pcie_port ^ 1);
 		rst_ctl_reg = CVMX_RST_CTLX(pcie_port);
 	} else {
 		ciu_soft_prst_reg = (pcie_port) ?
 				 CVMX_CIU_SOFT_PRST1 : CVMX_CIU_SOFT_PRST;
+		ciu_soft_prst_reg_alt = (pcie_port ^ 1) ?
+				 CVMX_CIU_SOFT_PRST1 : CVMX_CIU_SOFT_PRST;
 		rst_ctl_reg = CVMX_MIO_RST_CTLX(pcie_port);
 	}
 
@@ -1547,16 +1556,14 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		fdt_addr = __cvmx_phys_addr_to_ptr(cvmx_sysinfo_get()->fdt_addr,
 						   OCTEON_FDT_MAX_SIZE);
 	if (fdt_addr && mode == CVMX_QLM_MODE_PCIE_2X1) {
-		uint32_t *prop;
 		int offset;
 
 		offset = fdt_path_offset(fdt_addr, "/soc");
 		if (offset >= 0) {
-			prop = (uint32_t *)fdt_getprop(fdt_addr, offset,
-						       "cavium,connected-pcie-reset-2x1",
-						       NULL);
-			if (prop)
-				connected_pcie_reset = fdt32_to_cpu(*prop);
+			connected_pcie_reset =
+				cvmx_fdt_get_int(fdt_addr, offset,
+						 "cavium,connected-pcie-reset-2x1",
+						 -1);
 		}
 	}
 #else
@@ -1575,52 +1582,28 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 	   followed by PCIe0. */
 	switch (connected_pcie_reset) {
 	case 0:
-		if (pcie_port == 1 &&
-		    (CVMX_READ_CSR(CVMX_MIO_QLMX_CFG(1)) & 0x3) == 1) {
-			ciu_soft_prst.u64 = CVMX_READ_CSR(CVMX_CIU_SOFT_PRST);
-			if (ciu_soft_prst.s.soft_prst == 0) {
-				/* Reset the port */
-				ciu_soft_prst.s.soft_prst = 1;
-				CVMX_WRITE_CSR(CVMX_CIU_SOFT_PRST,
-					ciu_soft_prst.u64);
-				/* Wait until pcie resets the ports. */
-				cvmx_wait_usec(2000);
-				CVMX_WRITE_CSR(CVMX_CIU_SOFT_PRST1,
-					ciu_soft_prst.u64);
-				/* Wait until pcie resets the ports. */
-				cvmx_wait_usec(2000);
-			}
-			ciu_soft_prst.u64 = CVMX_READ_CSR(CVMX_CIU_SOFT_PRST);
-			ciu_soft_prst.s.soft_prst = 0;
-			CVMX_WRITE_CSR(CVMX_CIU_SOFT_PRST, ciu_soft_prst.u64);
-			ciu_soft_prst.u64 = CVMX_READ_CSR(CVMX_CIU_SOFT_PRST1);
-			ciu_soft_prst.s.soft_prst = 0;
-			CVMX_WRITE_CSR(CVMX_CIU_SOFT_PRST1, ciu_soft_prst.u64);
-		}
-		break;
 	case 1:
-		if (pcie_port == 0 &&
-		    (CVMX_READ_CSR(CVMX_MIO_QLMX_CFG(1)) & 0x3) == 1) {
-			ciu_soft_prst.u64 = CVMX_READ_CSR(CVMX_CIU_SOFT_PRST1);
+		if ((pcie_port != connected_pcie_reset) &&
+		    (mode == CVMX_QLM_MODE_PCIE_2X1)) {
+			ciu_soft_prst.u64 = CVMX_READ_CSR(ciu_soft_prst_reg);
 			if (ciu_soft_prst.s.soft_prst == 0) {
 				/* Reset the port */
 				ciu_soft_prst.s.soft_prst = 1;
-				CVMX_WRITE_CSR(CVMX_CIU_SOFT_PRST1,
-					ciu_soft_prst.u64);
-				/* Wait until pcie resets the ports. */
-				cvmx_wait_usec(2000);
-				CVMX_WRITE_CSR(CVMX_CIU_SOFT_PRST,
-					ciu_soft_prst.u64);
+				CVMX_WRITE_CSR(ciu_soft_prst_reg,
+					       ciu_soft_prst.u64);
+				CVMX_WRITE_CSR(ciu_soft_prst_reg_alt,
+					       ciu_soft_prst.u64);
 				/* Wait until pcie resets the ports. */
 				cvmx_wait_usec(2000);
+
 			}
-			ciu_soft_prst.u64 = CVMX_READ_CSR(CVMX_CIU_SOFT_PRST1);
-			ciu_soft_prst.s.soft_prst = 0;
-			CVMX_WRITE_CSR(CVMX_CIU_SOFT_PRST1, ciu_soft_prst.u64);
-			ciu_soft_prst.u64 = CVMX_READ_CSR(CVMX_CIU_SOFT_PRST);
-			ciu_soft_prst.s.soft_prst = 0;
-			CVMX_WRITE_CSR(CVMX_CIU_SOFT_PRST, ciu_soft_prst.u64);
 		}
+		ciu_soft_prst.u64 = CVMX_READ_CSR(ciu_soft_prst_reg);
+		ciu_soft_prst.s.soft_prst = 0;
+		CVMX_WRITE_CSR(ciu_soft_prst_reg, ciu_soft_prst.u64);
+		ciu_soft_prst.u64 = CVMX_READ_CSR(ciu_soft_prst_reg_alt);
+		ciu_soft_prst.s.soft_prst = 0;
+		CVMX_WRITE_CSR(ciu_soft_prst_reg_alt, ciu_soft_prst.u64);
 		break;
 	case -1:
 	default:
@@ -1645,10 +1628,24 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 	/* Wait for PCIe reset to complete */
 	cvmx_wait_usec(1000);
 
+
 	/* Set MPLL multiplier as per Errata 20669. */
 	if (OCTEON_IS_MODEL(OCTEON_CN70XX)) {
 		int qlm = __cvmx_pcie_get_qlm(0, pcie_port);
-		__cvmx_qlm_set_mult(qlm, 2500, 56);
+		int old_mult;
+		uint64_t meas_refclock = cvmx_qlm_measure_clock(qlm);
+		if (meas_refclock > 99000000 && meas_refclock < 101000000)
+			old_mult = 35;
+		else if (meas_refclock > 124000000 && meas_refclock < 126000000)
+			old_mult = 56;
+		else if (meas_refclock > 156000000 && meas_refclock < 156500000)
+			old_mult = 45;
+		else {
+			cvmx_dprintf("%s: Invalid reference clock for qlm %d\n",
+				     __func__, qlm);
+			return -1;
+		}
+		__cvmx_qlm_set_mult(qlm, 2500, old_mult);
 	}
 
 	/* Check and make sure PCIe came out of reset. If it doesn't the board
@@ -1800,10 +1797,17 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
 		bar1_index.s.addr_idx += (((1ull << 28) / 16ull) >> 22);
 	}
 
+	/* Wait for 200ms */
 	pemx_ctl_status.u64 = CVMX_READ_CSR(CVMX_PEMX_CTL_STATUS(pcie_port));
 	pemx_ctl_status.cn63xx.cfg_rtry = cfg_retries();
 	CVMX_WRITE_CSR(CVMX_PEMX_CTL_STATUS(pcie_port), pemx_ctl_status.u64);
 
+	/* Here is the second part of the config retry changes. Wait for 700ms
+	   after setting up the link before continuing. PCIe says the devices
+	   may need up to 900ms to come up. 700ms plus 200ms from above gives 
+	   us a total of 900ms */
+	cvmx_wait_usec(700000);
+
 	/* Display the link status */
 	pciercx_cfg032.u32 = CVMX_PCIE_CFGX_READ(pcie_port,
 						 CVMX_PCIERCX_CFG032(pcie_port));
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
index 112eebc..fb97816 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
@@ -36,8 +36,6 @@
  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
  ***********************license end**************************************/
-
-
 /*
  * File version info: $Rev:$
  *
@@ -47,26 +45,25 @@
 #include <linux/module.h>
 #include <asm/octeon/cvmx.h>
 #include <asm/octeon/cvmx-pko3.h>
+#include <asm/octeon/cvmx-pko3-resources.h>
+#include <asm/octeon/cvmx-pko3-queue.h>
 #include <asm/octeon/cvmx-helper-pko3.h>
 #include <asm/octeon/cvmx-bootmem.h>
 #include <asm/octeon/cvmx-clock.h>
 #else
 #include "cvmx.h"
 #include "cvmx-pko3.h"
+#include "cvmx-pko3-resources.h"
+#include "cvmx-pko3-queue.h"
 #include "cvmx-helper-pko3.h"
 #include "cvmx-bootmem.h"
 #endif
 
-
-
 /* Smalles Round-Robin quantum to use +1 */
 #define	CVMX_PKO3_RR_QUANTUM_MIN	0x10
 
 static int debug = 0;	/* 1 for basic, 2 for detailed trace */
 
-/* Minimum MTU assumed for shaping configuration */
-static unsigned __pko3_min_mtu = 9080;	/* Could be per-port in the future */
-
 struct cvmx_pko3_dq {
 #ifdef __BIG_ENDIAN_BITFIELD
 	unsigned	dq_count :6;	/* Number of descriptor queues */
@@ -142,6 +139,30 @@ int cvmx_pko3_get_queue_num(int ipd_port)
 }
 
 /**
+ * Get L1/Port Queue number assigned to interface port.
+ *
+ * @param xiface is interface number.
+ * @param index is port index.
+ */
+int cvmx_pko3_get_port_queue(int xiface, int index)
+{
+	int queue;
+	cvmx_pko_l1_sqx_topology_t qtop;
+	int mac = __cvmx_pko3_get_mac_num(xiface, index);
+	int nqueues = cvmx_pko3_num_level_queues(CVMX_PKO_PORT_QUEUES);
+	cvmx_xiface_t xi = cvmx_helper_xiface_to_node_interface(xiface);
+
+	for (queue = 0; queue < nqueues; queue++) {
+		qtop.u64 = cvmx_read_csr_node(xi.node, CVMX_PKO_L1_SQX_TOPOLOGY(queue));
+		if (qtop.s.link == mac)
+			break;
+	}
+	if (queue >= nqueues)
+		return -1;
+	return queue;
+}
+
+/**
  * @INTERNAL
  *
  * Initialize port/dq table contents
@@ -1019,14 +1040,13 @@ static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
 
 	/* Find the biggest divider that has the short float fit */
 	for (div_exp = 0; div_exp <= max_exp; div_exp++) {
-		tmp = (rate_tocks << div_exp) / tclk;
+		tmp = ((rate_tocks << div_exp) + (tclk / 2)) / tclk;
 		if (tmp > fmax) {
 			if (div_exp > 0)
 				div_exp --;
 			break;
 		}
 	}
-
 	/* Make sure divider, rate are within valid range */
 	if (div_exp > max_exp) {
 		/* Minimum reached */
@@ -1036,7 +1056,6 @@ static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
 		if ((rate_tocks / tclk) > fmax)
 			rate_tocks = fmax * tclk;
 	}
-
 	/* Store common divider */
 	reg->s.rate_divider_exponent = div_exp;
 
@@ -1045,12 +1064,8 @@ static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
 	 * should not be less than RATE/Tclk
 	 */
 
-	/* Find the minimum burst size needed for rate */
-	min_burst = (rate_tocks << div_exp) / tclk;
-
-	/* Override with minimum MTU (could become per-port cfg) */
-	if (min_burst < __pko3_min_mtu)
-		min_burst = __pko3_min_mtu;
+	/* Find the minimum burst size needed for rate (burst ~ 4x rate) */
+	min_burst = (rate_tocks << (div_exp + 4)) / tclk;
 
 	/* Apply the minimum */
 	if (burst_tocks < min_burst)
@@ -1066,16 +1081,15 @@ static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
 	tmp = (burst_tocks << 8);
 	CVMX_SHOFT_FROM_U64(tmp, mant, exp);
 	reg->s.burst_mantissa = mant;
-	reg->s.burst_exponent = exp - 8;
+	reg->s.burst_exponent = exp - 8 - 1;
 
 	if (debug)
 		cvmx_dprintf("%s: RATE=%llu BURST=%llu DIV_EXP=%d\n",
 			__func__,
 			CVMX_SHOFT_TO_U64(reg->s.rate_mantissa,
-					reg->s.rate_exponent),
+				reg->s.rate_exponent),
 			CVMX_SHOFT_TO_U64(reg->s.burst_mantissa,
-					reg->s.burst_exponent),
-			div_exp);
+				(reg->s.burst_exponent + 1)), div_exp);
 
 	/* Validate the resulting rate */
 	rate_v = CVMX_SHOFT_TO_U64(reg->s.rate_mantissa,
@@ -1086,7 +1100,7 @@ static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
 	rate_v >>= div_exp;
 
 	burst_v = CVMX_SHOFT_TO_U64(reg->s.burst_mantissa,
-				reg->s.burst_exponent);
+				(reg->s.burst_exponent + 1));
 	/* Convert in additional bytes as in argument */
 	burst_v = burst_v << (tock_bytes_exp);
 
@@ -1103,7 +1117,10 @@ static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
 			__func__, rate_v, burst_v);
 
 	rate_v = (rate_v * 1000000ULL) / rate_kbips;
-	burst_v = (burst_v * 1000000ULL) / burst_bytes;
+	if (burst_bytes > 0)
+		burst_v = (burst_v * 1000000ULL) / burst_bytes;
+	else
+		burst_v = 0;
 
 	if (debug)
 		cvmx_dprintf("%s: error rate=%llu burst=%llu ppm\n",
@@ -1135,11 +1152,11 @@ static int cvmx_pko3_shaper_rate_compute(unsigned long tclk,
  * is returned as a positive integer.
  */
 int cvmx_pko3_port_cir_set(unsigned node, unsigned pq_num,
-		unsigned long rate_kbips, unsigned burst_bytes)
+		unsigned long rate_kbips, unsigned burst_bytes, int adj_bytes)
 {
-	const unsigned time_wheel_turn = 96; /* S-Clock cycles */
 	unsigned long tclk;
 	cvmx_pko_l1_sqx_cir_t sqx_cir;
+	cvmx_pko_l1_sqx_shape_t shape;
 	int rc;
 
 	if (debug)
@@ -1150,31 +1167,29 @@ int cvmx_pko3_port_cir_set(unsigned node, unsigned pq_num,
 
 	/* When rate == 0, disable the shaper */
 	if( rate_kbips == 0ULL) {
-		/* Disable shaping */
 		sqx_cir.s.enable = 0;
-		cvmx_write_csr_node(node,
-			CVMX_PKO_L1_SQX_CIR(pq_num), sqx_cir.u64);
+		cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_CIR(pq_num), sqx_cir.u64);
 		return 0;
 	}
-
 	/* Compute time-wheel frequency */
-	tclk = cvmx_clock_get_rate_node(node, CVMX_CLOCK_SCLK)/
-		time_wheel_turn;
+	tclk = cvmx_pko3_pq_tw_clock_rate_node(node);
 
 	/* Compute shaper values */
-	rc = cvmx_pko3_shaper_rate_compute(tclk, &sqx_cir,
-		rate_kbips, burst_bytes);
-
-	/* Refuse to set register if insane rates, 25% = 250,000 PPM  */
-	if (rc < 250000)
-		return rc;
-
-	/* Enable shaping */
-	sqx_cir.s.enable = 1;
+	rc = cvmx_pko3_shaper_rate_compute(tclk, &sqx_cir, rate_kbips, burst_bytes);
 
 	/* Apply new settings */
+	sqx_cir.s.enable = 1;
+	sqx_cir.s. rate_divider_exponent = sqx_cir.s. rate_divider_exponent;
+	sqx_cir.s. rate_mantissa  = sqx_cir.s. rate_mantissa;
+	sqx_cir.s. rate_exponent  = sqx_cir.s. rate_exponent;
+	sqx_cir.s. burst_mantissa = sqx_cir.s. burst_mantissa;
+	sqx_cir.s. burst_exponent = sqx_cir.s. burst_exponent - 1;
 	cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_CIR(pq_num), sqx_cir.u64);
 
+	shape.u64 = cvmx_read_csr_node(node, CVMX_PKO_L1_SQX_SHAPE(pq_num));
+	shape.s.adjust = adj_bytes;
+	cvmx_write_csr_node(node, CVMX_PKO_L1_SQX_SHAPE(pq_num), shape.u64);
+
 	return rc;
 }
 
@@ -1196,14 +1211,12 @@ int cvmx_pko3_port_cir_set(unsigned node, unsigned pq_num,
 int cvmx_pko3_dq_cir_set(unsigned node, unsigned dq_num,
 		unsigned long rate_kbips, unsigned burst_bytes)
 {
-	const unsigned time_wheel_turn = 768; /* S-Clock cycles */
 	unsigned long tclk;
 	cvmx_pko_l1_sqx_cir_t sqx_cir;
 	cvmx_pko_dqx_cir_t dqx_cir;
 	int rc;
 
-	dq_num &= (1<<10)-1;
-
+	dq_num &= cvmx_pko3_num_level_queues(CVMX_PKO_DESCR_QUEUES) - 1;
 	if (debug)
 		cvmx_dprintf("%s: dq=%u rate=%lu kbps, burst=%u bytes\n",
 			__func__, dq_num, rate_kbips, burst_bytes);
@@ -1212,34 +1225,23 @@ int cvmx_pko3_dq_cir_set(unsigned node, unsigned dq_num,
 
 	/* When rate == 0, disable the shaper */
 	if( rate_kbips == 0ULL) {
-		/* Disable shaping */
 		dqx_cir.s.enable = 0;
-		cvmx_write_csr_node(node,
-			CVMX_PKO_DQX_CIR(dq_num), dqx_cir.u64);
+		cvmx_write_csr_node(node, CVMX_PKO_DQX_CIR(dq_num), dqx_cir.u64);
 		return 0;
 	}
-
 	/* Compute time-wheel frequency */
-	tclk = cvmx_clock_get_rate_node(node, CVMX_CLOCK_SCLK)/
-		time_wheel_turn;
+	tclk = cvmx_pko3_dq_tw_clock_rate_node(node);
 
 	/* Compute shaper values */
-	rc = cvmx_pko3_shaper_rate_compute(tclk, &sqx_cir,
-		rate_kbips, burst_bytes);
-
-	/* Refuse to set register if insane rates, 25% = 250,000 PPM  */
-	if (rc < 250000)
-		return rc;
+	rc = cvmx_pko3_shaper_rate_compute(tclk, &sqx_cir, rate_kbips, burst_bytes);
 
-	/* Enable shaping */
+	/* Apply new settings */
 	dqx_cir.s.enable = 1;
 	dqx_cir.s. rate_divider_exponent = sqx_cir.s. rate_divider_exponent;
 	dqx_cir.s. rate_mantissa  = sqx_cir.s. rate_mantissa;
 	dqx_cir.s. rate_exponent  = sqx_cir.s. rate_exponent;
 	dqx_cir.s. burst_mantissa = sqx_cir.s. burst_mantissa;
-	dqx_cir.s. burst_exponent = sqx_cir.s. burst_exponent ;
-
-	/* Apply new settings */
+	dqx_cir.s. burst_exponent = sqx_cir.s. burst_exponent - 1;
 	cvmx_write_csr_node(node, CVMX_PKO_DQX_CIR(dq_num), dqx_cir.u64);
 
 	return rc;
@@ -1263,13 +1265,12 @@ int cvmx_pko3_dq_cir_set(unsigned node, unsigned dq_num,
 int cvmx_pko3_dq_pir_set(unsigned node, unsigned dq_num,
 		unsigned long rate_kbips, unsigned burst_bytes)
 {
-	const unsigned time_wheel_turn = 768; /* S-Clock cycles */
 	unsigned long tclk;
 	cvmx_pko_l1_sqx_cir_t sqx_cir;
 	cvmx_pko_dqx_pir_t dqx_pir;
 	int rc;
 
-	dq_num &= (1<<10)-1;
+	dq_num &= cvmx_pko3_num_level_queues(CVMX_PKO_DESCR_QUEUES) - 1;
 	if (debug)
 		cvmx_dprintf("%s: dq=%u rate=%lu kbps, burst=%u bytes\n",
 			__func__, dq_num, rate_kbips, burst_bytes);
@@ -1278,34 +1279,23 @@ int cvmx_pko3_dq_pir_set(unsigned node, unsigned dq_num,
 
 	/* When rate == 0, disable the shaper */
 	if( rate_kbips == 0ULL) {
-		/* Disable shaping */
 		dqx_pir.s.enable = 0;
-		cvmx_write_csr_node(node,
-			CVMX_PKO_DQX_PIR(dq_num), dqx_pir.u64);
+		cvmx_write_csr_node(node, CVMX_PKO_DQX_PIR(dq_num), dqx_pir.u64);
 		return 0;
 	}
-
 	/* Compute time-wheel frequency */
-	tclk = cvmx_clock_get_rate_node(node, CVMX_CLOCK_SCLK)/
-		time_wheel_turn;
+	tclk = cvmx_pko3_dq_tw_clock_rate_node(node);
 
 	/* Compute shaper values */
-	rc = cvmx_pko3_shaper_rate_compute(tclk, &sqx_cir,
-		rate_kbips, burst_bytes);
-
-	/* Refuse to set register if insane rates, 25% = 250,000 PPM  */
-	if (rc < 250000)
-		return rc;
+	rc = cvmx_pko3_shaper_rate_compute(tclk, &sqx_cir, rate_kbips, burst_bytes);
 
-	/* Enable shaping */
+	/* Apply new settings */
 	dqx_pir.s.enable = 1;
 	dqx_pir.s. rate_divider_exponent = sqx_cir.s. rate_divider_exponent;
 	dqx_pir.s. rate_mantissa  = sqx_cir.s. rate_mantissa;
 	dqx_pir.s. rate_exponent  = sqx_cir.s. rate_exponent;
 	dqx_pir.s. burst_mantissa = sqx_cir.s. burst_mantissa;
-	dqx_pir.s. burst_exponent = sqx_cir.s. burst_exponent ;
-
-	/* Apply new settings */
+	dqx_pir.s. burst_exponent = sqx_cir.s. burst_exponent - 1;
 	cvmx_write_csr_node(node, CVMX_PKO_DQX_PIR(dq_num), dqx_pir.u64);
 
 	return rc;
@@ -1338,30 +1328,27 @@ void cvmx_pko3_dq_red(unsigned node, unsigned dq_num, red_action_t red_act,
 {
 	cvmx_pko_dqx_shape_t dqx_shape;
 
-	dq_num &= (1<<10)-1;
-
+	dq_num &= cvmx_pko3_num_level_queues(CVMX_PKO_DESCR_QUEUES) - 1;
 	dqx_shape.u64 = 0;
 
-        if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
 		if (len_adjust < 0)
 			len_adjust = 0;
 	}
-
-        dqx_shape.s.adjust = len_adjust;
+	dqx_shape.s.adjust = len_adjust;
 
 	switch(red_act) {
-		default:
-		case CVMX_PKO3_SHAPE_RED_STALL:
-			dqx_shape.s.red_algo = 0x0;
-			break;
-		case CVMX_PKO3_SHAPE_RED_DISCARD:
-			dqx_shape.s.red_algo = 0x3;
-			break;
-		case CVMX_PKO3_SHAPE_RED_PASS:
-			dqx_shape.s.red_algo = 0x1;
-			break;
-		}
-
+	default:
+	case CVMX_PKO3_SHAPE_RED_STALL:
+		dqx_shape.s.red_algo = 0x0;
+		break;
+	case CVMX_PKO3_SHAPE_RED_DISCARD:
+		dqx_shape.s.red_algo = 0x3;
+		break;
+	case CVMX_PKO3_SHAPE_RED_PASS:
+		dqx_shape.s.red_algo = 0x1;
+		break;
+	}
 	cvmx_write_csr_node(node, CVMX_PKO_DQX_SHAPE(dq_num), dqx_shape.u64);
 }
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index 7f5d570..83772a9 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -131,6 +131,7 @@ int cvmx_pko3_hw_init_global(int node, uint16_t aura)
 	cvmx_pko_enable_t pko_enable;
 	cvmx_pko_dpfi_status_t dpfi_status;
 	cvmx_pko_status_t pko_status;
+	cvmx_pko_shaper_cfg_t shaper_cfg;
 	uint64_t cycles;
 	const unsigned timeout = 100;	/* 100 milliseconds */
 
@@ -143,6 +144,10 @@ int cvmx_pko3_hw_init_global(int node, uint16_t aura)
 			__func__, node);
 		return 0;
 	}
+	/* Enable color awareness. */
+	shaper_cfg.u64 = cvmx_read_csr_node(node, CVMX_PKO_SHAPER_CFG);
+	shaper_cfg.s.color_aware = 1;
+	cvmx_write_csr_node(node, CVMX_PKO_SHAPER_CFG, shaper_cfg.u64);
 
 	/* Clear FLUSH command to be sure */
 	pko_flush.u64 = 0;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index 009ff33..186f01e 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 122165 $<hr>
+ * <hr>$Revision: 122709 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -1026,7 +1026,8 @@ int cvmx_qlm_get_gbaud_mhz(int qlm)
 		return freq;
 	} else if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
 		return cvmx_qlm_get_gbaud_mhz_node(cvmx_get_node_num(), qlm);
-	} else if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
+	} else if (OCTEON_IS_MODEL(OCTEON_CN73XX)
+		   || OCTEON_IS_MODEL(OCTEON_CNF75XX)) {
 		cvmx_gserx_lane_mode_t lane_mode;
 		lane_mode.u64 = cvmx_read_csr(CVMX_GSERX_LANE_MODE(qlm));
 		switch (lane_mode.s.lmode) {
@@ -1432,17 +1433,16 @@ void __cvmx_qlm_set_mult(int qlm, int baud_mhz, int old_multiplier)
 		return;
 	}
 
-	mult = (uint64_t)baud_mhz * 1000000 + (meas_refclock / 2);
-	mult /= meas_refclock;
-
 	/* The baud rate multiplier needs to be adjusted on the CN70XX if
 	 * the reference clock is > 100MHz.
 	 */
 	if (qlm == 0) {
 		clkdiv.u64 = cvmx_read_csr(CVMX_GSERX_DLMX_REF_CLKDIV2(qlm, 0));
 		if (clkdiv.s.ref_clkdiv2)
-			mult *= 2;
+			baud_mhz *= 2;
 	}
+	mult = (uint64_t)baud_mhz * 1000000 + (meas_refclock / 2);
+	mult /= meas_refclock;
 
 #ifdef CVMX_BUILD_FOR_UBOOT
 	/* For simulator just write the multiplier directly, to make it
@@ -1460,9 +1460,11 @@ void __cvmx_qlm_set_mult(int qlm, int baud_mhz, int old_multiplier)
 	     21-1, 21-2, and 21-3. This is not required with the HRM
 	     sequence. */
 	do {
-		mpll_multiplier.u64 = cvmx_read_csr(CVMX_GSERX_DLMX_MPLL_MULTIPLIER(qlm, 0));
+		mpll_multiplier.u64 =
+			cvmx_read_csr(CVMX_GSERX_DLMX_MPLL_MULTIPLIER(qlm, 0));
 		mpll_multiplier.s.mpll_multiplier = --old_multiplier;
-		cvmx_write_csr(CVMX_GSERX_DLMX_MPLL_MULTIPLIER(qlm, 0), mpll_multiplier.u64);
+		cvmx_write_csr(CVMX_GSERX_DLMX_MPLL_MULTIPLIER(qlm, 0),
+			       mpll_multiplier.u64);
 		/* Wait for 1 ms */
 		cvmx_wait_usec(1000);
 	} while (old_multiplier > (int)mult);
diff --git a/arch/mips/cavium-octeon/executive/octeon-model.c b/arch/mips/cavium-octeon/executive/octeon-model.c
index 95c0757..74de6c5 100644
--- a/arch/mips/cavium-octeon/executive/octeon-model.c
+++ b/arch/mips/cavium-octeon/executive/octeon-model.c
@@ -43,7 +43,7 @@
  * File defining functions for working with different Octeon
  * models.
  *
- * <hr>$Revision: 122165 $<hr>
+ * <hr>$Revision: 122055 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/octeon.h>
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index b16d2f9..a0afda2 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -41,7 +41,7 @@
  * @file
  * Header file for simple executive application initialization.  This defines
  * part of the ABI between the bootloader and the application.
- * <hr>$Revision: 121150 $<hr>
+ * <hr>$Revision: 122068 $<hr>
  *
  */
 
@@ -293,6 +293,7 @@ enum cvmx_board_types_enum {
 	CVMX_BOARD_TYPE_NIAGARA830 = 75,
 	CVMX_BOARD_TYPE_EBB7304 = 76,
 	CVMX_BOARD_TYPE_NIC73 = 77,	/* Liquid I/O */
+	CVMX_BOARD_TYPE_NIAGARA830_IM13166 = 78,
 	CVMX_BOARD_TYPE_MAX,
 	/* NOTE:  256-257 are being used by a customer. */
 
@@ -438,6 +439,7 @@ static inline const char *cvmx_board_type_to_string(enum cvmx_board_types_enum t
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIAGARA830)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBB7304)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC73)
+		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIAGARA830_IM13166)
 		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
 
 		/* Customer boards listed here */
diff --git a/arch/mips/include/asm/octeon/cvmx-cmd-queue.h b/arch/mips/include/asm/octeon/cvmx-cmd-queue.h
index 2d9cb4d..8809e2e 100644
--- a/arch/mips/include/asm/octeon/cvmx-cmd-queue.h
+++ b/arch/mips/include/asm/octeon/cvmx-cmd-queue.h
@@ -82,7 +82,7 @@
  * internal cycle counter to completely eliminate any causes of
  * bus traffic.
  *
- * <hr> $Revision: 115642 $ <hr>
+ * <hr> $Revision: 114431 $ <hr>
  */
 
 #ifndef __CVMX_CMD_QUEUE_H__
diff --git a/arch/mips/include/asm/octeon/cvmx-coremask.h b/arch/mips/include/asm/octeon/cvmx-coremask.h
index 574d9fc..fa47ee4 100644
--- a/arch/mips/include/asm/octeon/cvmx-coremask.h
+++ b/arch/mips/include/asm/octeon/cvmx-coremask.h
@@ -60,7 +60,7 @@
  * provide future compatibility if more cores are added to future processors
  * or more nodes are supported.
  *
- * <hr>$Revision: 115642 $<hr>
+ * <hr>$Revision: 114431 $<hr>
  *
  */
 
diff --git a/arch/mips/include/asm/octeon/cvmx-dma-engine.h b/arch/mips/include/asm/octeon/cvmx-dma-engine.h
index 10fe7cc..794e6d2 100644
--- a/arch/mips/include/asm/octeon/cvmx-dma-engine.h
+++ b/arch/mips/include/asm/octeon/cvmx-dma-engine.h
@@ -43,7 +43,7 @@
  * Interface to the PCI / PCIe DMA engines. These are only avialable
  * on chips with PCI / PCIe.
  *
- * <hr>$Revision: 121532 $<hr>
+ * <hr>$Revision: 121436 $<hr>
  */
 
 #ifndef __CVMX_DMA_ENGINES_H__
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa.h b/arch/mips/include/asm/octeon/cvmx-fpa.h
index 773df6b..e892dcc 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa.h
@@ -42,7 +42,7 @@
  *
  * Interface to the hardware Free Pool Allocator.
  *
- * <hr>$Revision: 120141 $<hr>
+ * <hr>$Revision: 120123 $<hr>
  *
  */
 
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa1.h b/arch/mips/include/asm/octeon/cvmx-fpa1.h
index 93268d0..b8c6b6e 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa1.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa1.h
@@ -43,7 +43,7 @@
  * Interface to the hardware Free Pool Allocator on Octeon chips.
  * These are the legacy models, i.e. prior to CN78XX/CN76XX.
  *
- * <hr>$Revision: 120141 $<hr>
+ * <hr>$Revision: 120123 $<hr>
  *
  */
 
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa3.h b/arch/mips/include/asm/octeon/cvmx-fpa3.h
index fbc25f6..523cf3f 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa3.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa3.h
@@ -42,7 +42,7 @@
  *
  * Interface to the CN78XX Free Pool Allocator, a.k.a. FPA3
  *
- * <hr>$Revision: 121532 $<hr>
+ * <hr>$Revision: 122227 $<hr>
  *
  */
 
@@ -285,7 +285,6 @@ static inline int cvmx_fpa3_num_auras(void)
 /**
  * Get the FPA3 POOL underneath FPA3 AURA, containing all its buffers
  *
- * @INTERNAL
  */
 static inline cvmx_fpa3_pool_t
 cvmx_fpa3_aura_to_pool(cvmx_fpa3_gaura_t aura)
@@ -308,8 +307,6 @@ cvmx_fpa3_aura_to_pool(cvmx_fpa3_gaura_t aura)
 /**
  * Get a new block from the FPA pool
  *
- * @INTERNAL
- *
  * @param aura  - aura number
  * @return pointer to the block or NULL on failure
  */
@@ -341,7 +338,6 @@ static inline void *cvmx_fpa3_alloc(cvmx_fpa3_gaura_t aura)
 
 /**
  * Asynchronously get a new block from the FPA
- * @INTERNAL
  *
  * The result of cvmx_fpa_async_alloc() may be retrieved using
  * cvmx_fpa_async_alloc_finish().
@@ -372,7 +368,6 @@ cvmx_fpa3_async_alloc(uint64_t scr_addr, cvmx_fpa3_gaura_t aura)
 
 /**
  * Retrieve the result of cvmx_fpa3_async_alloc
- * @INTERNAL
  *
  * @param scr_addr The Local scratch address.  Must be the same value
  * passed to cvmx_fpa_async_alloc().
@@ -399,7 +394,6 @@ cvmx_fpa3_async_alloc_finish(uint64_t scr_addr, cvmx_fpa3_gaura_t aura)
 
 /**
  * Free a pointer back to the pool.
- * @INTERNAL
  *
  * @param aura   global aura number
  * @param ptr    physical address of block to free.
@@ -437,7 +431,6 @@ static inline void cvmx_fpa3_free(void *ptr, cvmx_fpa3_gaura_t aura,
 
 /**
  * Free a pointer back to the pool without flushing the write buffer.
- * @INTERNAL
  *
  * @param aura   global aura number
  * @param ptr    physical address of block to free.
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-board.h b/arch/mips/include/asm/octeon/cvmx-helper-board.h
index c9c71f6..9aa4b92 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-board.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-board.h
@@ -43,7 +43,7 @@
  * Helper functions to abstract board specific data about
  * network ports from the rest of the cvmx-helper files.
  *
- * <hr>$Revision: 121857 $<hr>
+ * <hr>$Revision: 121712 $<hr>
  */
 #ifndef __CVMX_HELPER_BOARD_H__
 #define __CVMX_HELPER_BOARD_H__
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-loop.h b/arch/mips/include/asm/octeon/cvmx-helper-loop.h
index 9d26585..577ad33 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-loop.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-loop.h
@@ -43,7 +43,7 @@
  * Functions for LOOP initialization, configuration,
  * and monitoring.
  *
- * <hr>$Revision: 115885 $<hr>
+ * <hr>$Revision: 115656 $<hr>
  */
 #ifndef __CVMX_HELPER_LOOP_H__
 #define __CVMX_HELPER_LOOP_H__
diff --git a/arch/mips/include/asm/octeon/cvmx-helper.h b/arch/mips/include/asm/octeon/cvmx-helper.h
index 6d537b0..2b2cfd5 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper.h
@@ -42,7 +42,7 @@
  *
  * Helper functions for common, but complicated tasks.
  *
- * <hr>$Revision: 118038 $<hr>
+ * <hr>$Revision: 117608 $<hr>
  */
 
 #ifndef __CVMX_HELPER_H__
diff --git a/arch/mips/include/asm/octeon/cvmx-ila.h b/arch/mips/include/asm/octeon/cvmx-ila.h
new file mode 100644
index 0000000..82db35d
--- /dev/null
+++ b/arch/mips/include/asm/octeon/cvmx-ila.h
@@ -0,0 +1,118 @@
+/***********************license start***************
+ * Copyright (c) 2014  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * This file contains defines for the ILA interface
+ *
+ * <hr>$Revision: 49448 $<hr>
+ *
+ *
+ */
+
+#ifndef __CVMX_HELPER_ILA_H__
+#define __CVMX_HELPER_ILA_H__
+
+#include "cvmx-ilk.h"
+
+#ifdef	__cplusplus
+/* *INDENT-OFF* */
+extern "C" {
+/* *INDENT-ON* */
+#endif
+
+#define CVMX_ILA_GBL_BASE 10 
+
+/**
+ * This header is placed in front of all received ILA look-aside mode packets
+ */
+typedef union {
+	uint64_t u64;
+
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint32_t reserved_63_57:7;	/**< bits 63...57 */
+		uint32_t app_spec0:15;		/**< Application Specific 0 */
+		uint32_t chan1:1;		/**< Channel 1 XON */
+		uint32_t chan0:1;		/**< Channel 0 XON */
+		uint32_t la_mode:1;		/**< Protocol Type */
+		uint32_t app_spec1:6;		/**< Application Specific 1 */
+		uint32_t ilk_channel:1;		/**< ILK channel number, 0 or 1 */
+		uint32_t app_spec2:8;		/**< Application Specific 2 */
+		uint32_t reserved_23_0:24;	/**< Unpredictable, may be any value */
+#else
+		uint32_t reserved_23_0:24;	/**< Unpredictable, may be any value */
+		uint32_t app_spec2:8;		/**< Application Specific 2 */
+		uint32_t ilk_channel:1;		/**< ILK channel number, 0 or 1 */
+		uint32_t app_spec1:6;		/**< Application Specific 1 */
+		uint32_t la_mode:1;		/**< Protocol Type */
+		uint32_t chan0:1;		/**< Channel 0 XON */
+		uint32_t chan1:1;		/**< Channel 1 XON */
+		uint32_t app_spec0:15;		/**< Application Specific 0 */
+		uint32_t reserved_63_57:7;	/**< bits 63...57 */
+#endif
+	} s;
+} cvmx_ila_header_t;
+
+
+/**
+ * Initialize ILK-LA interface
+ *
+ * @param lane_mask  Lanes to initialize ILK-LA interface.
+ * @return  0 on success and -1 on failure.
+ */
+extern int cvmx_ila_initialize(int lane_mask);
+
+/**
+ * Enable or disable LA mode in ILK header.
+ *
+ * @param channel channel
+ * @param mode   If set, enable LA mode in ILK header, else disable
+ *
+ * @return ILK header
+ */
+extern cvmx_ila_header_t cvmx_ila_configure_header(int channel, int mode);
+
+#ifdef	__cplusplus
+/* *INDENT-OFF* */
+}
+/* *INDENT-ON* */
+#endif
+#endif /* __CVMX_HELPER_ILA_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-ipd.h b/arch/mips/include/asm/octeon/cvmx-ipd.h
index d16d173..a07f8cb 100644
--- a/arch/mips/include/asm/octeon/cvmx-ipd.h
+++ b/arch/mips/include/asm/octeon/cvmx-ipd.h
@@ -42,7 +42,7 @@
  *
  * Interface to the hardware Input Packet Data unit.
  *
- * <hr>$Revision: 118038 $<hr>
+ * <hr>$Revision: 116854 $<hr>
  */
 
 #ifndef __CVMX_IPD_H__
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c.h b/arch/mips/include/asm/octeon/cvmx-l2c.h
index f713166..633031c 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c.h
@@ -43,7 +43,7 @@
  * Interface to the Level 2 Cache (L2C) control, measurement, and debugging
  * facilities.
  *
- * <hr>$Revision: 118038 $<hr>
+ * <hr>$Revision: 115982 $<hr>
  *
  */
 
diff --git a/arch/mips/include/asm/octeon/cvmx-pcie.h b/arch/mips/include/asm/octeon/cvmx-pcie.h
index 7c13847..1a67c60 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcie.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcie.h
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 115885 $<hr>
+ * <hr>$Revision: 115657 $<hr>
  */
 
 #ifndef __CVMX_PCIE_H__
diff --git a/arch/mips/include/asm/octeon/cvmx-pip.h b/arch/mips/include/asm/octeon/cvmx-pip.h
index 3f1a8f1..ad33e11 100644
--- a/arch/mips/include/asm/octeon/cvmx-pip.h
+++ b/arch/mips/include/asm/octeon/cvmx-pip.h
@@ -42,7 +42,7 @@
  *
  * Interface to the hardware Packet Input Processing unit.
  *
- * <hr>$Revision: 118038 $<hr>
+ * <hr>$Revision: 115965 $<hr>
  */
 
 #ifndef __CVMX_PIP_H__
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3-queue.h b/arch/mips/include/asm/octeon/cvmx-pko3-queue.h
index 1a59714..c67159e 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3-queue.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3-queue.h
@@ -74,6 +74,14 @@ int cvmx_pko3_get_queue_base(int ipd_port);
  */
 int cvmx_pko3_get_queue_num(int ipd_port);
 
+/**
+ * Get L1/Port Queue number assigned to interface port.
+ *
+ * @param xiface is interface number.
+ * @param index is port index.
+ */
+int cvmx_pko3_get_port_queue(int xiface, int index);
+
 /*
  * Configure L3 through L5 Scheduler Queues and Descriptor Queues
  *
@@ -162,7 +170,7 @@ extern int cvmx_pko3_pq_config(unsigned node, unsigned mac_num,
 			 unsigned pq_num);
 
 extern int cvmx_pko3_port_cir_set(unsigned node, unsigned pq_num,
-		unsigned long rate_kbips, unsigned burst_bytes);
+		unsigned long rate_kbips, unsigned burst_bytes, int adj_bytes);
 extern int cvmx_pko3_dq_cir_set(unsigned node, unsigned pq_num,
 		unsigned long rate_kbips, unsigned burst_bytes);
 extern int cvmx_pko3_dq_pir_set(unsigned node, unsigned pq_num,
@@ -209,7 +217,6 @@ extern void cvmx_pko3_dq_red(unsigned node, unsigned dq_num,
 						(1<<CVMX_SHOFT_EXP_BITS)-1)
 #define	CVMX_SHOFT_MIN()	CVMX_SHOFT_TO_U64(0, 0)
 
-
 #ifdef	__cplusplus
 /* *INDENT-OFF* */
 }
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3.h b/arch/mips/include/asm/octeon/cvmx-pko3.h
index bb60640..5d8b720 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3.h
@@ -59,6 +59,7 @@ extern "C" {
 #include <asm/octeon/cvmx-ilk.h>
 #include <asm/octeon/cvmx-scratch.h>
 #include <asm/octeon/cvmx-atomic.h>
+#include <asm/octeon/cvmx-clock.h>
 #include <asm/octeon/cvmx-pow.h>
 #else
 #include "cvmx-pko-defs.h"
@@ -99,6 +100,30 @@ enum cvmx_pko_dqop {
 };
 
 /**
+ * Returns the PKO DQ..L2 Shaper Time-Wheel clock rate for specified node.
+ */
+static inline
+uint64_t cvmx_pko3_dq_tw_clock_rate_node(int node)
+{
+	return cvmx_clock_get_rate_node(node, CVMX_CLOCK_SCLK) / 768;
+}
+
+/**
+ * Returns the PKO Port Shaper Time-Wheel clock rate for specified node.
+ */
+static inline
+uint64_t cvmx_pko3_pq_tw_clock_rate_node(int node)
+{
+	int div;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN78XX))
+		div = 96;
+	else
+		div = 48;
+	return cvmx_clock_get_rate_node(node, CVMX_CLOCK_SCLK) / div;
+}
+
+/**
  * @INTERNAL
  * Return the number of MACs in the PKO (exclusing the NULL MAC)
  * in a model-dependent manner.
diff --git a/arch/mips/include/asm/octeon/cvmx-qlm.h b/arch/mips/include/asm/octeon/cvmx-qlm.h
index d14cf93..24e8bc7 100644
--- a/arch/mips/include/asm/octeon/cvmx-qlm.h
+++ b/arch/mips/include/asm/octeon/cvmx-qlm.h
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 122165 $<hr>
+ * <hr>$Revision: 122066 $<hr>
  */
 
 #ifndef __CVMX_QLM_H__
diff --git a/arch/mips/include/asm/octeon/cvmx-spinlock.h b/arch/mips/include/asm/octeon/cvmx-spinlock.h
index 45e8e90..2783c80 100644
--- a/arch/mips/include/asm/octeon/cvmx-spinlock.h
+++ b/arch/mips/include/asm/octeon/cvmx-spinlock.h
@@ -42,7 +42,7 @@
  *
  * Implementation of spinlocks.
  *
- * <hr>$Revision: 115885 $<hr>
+ * <hr>$Revision: 115744 $<hr>
  */
 
 #ifndef __CVMX_SPINLOCK_H__
diff --git a/arch/mips/include/asm/octeon/octeon-model.h b/arch/mips/include/asm/octeon/octeon-model.h
index 99d9c39..29b24b0 100644
--- a/arch/mips/include/asm/octeon/octeon-model.h
+++ b/arch/mips/include/asm/octeon/octeon-model.h
@@ -43,7 +43,7 @@
  * File defining different Octeon model IDs and macros to
  * compare them.
  *
- * <hr>$Revision: 115642 $<hr>
+ * <hr>$Revision: 114196 $<hr>
  */
 
 #ifndef __OCTEON_MODEL_H__
-- 
2.6.2

