From d87266144d3c936b112ee0417f0e058ea65354c1 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Fri, 6 Sep 2013 13:10:51 -0700
Subject: [PATCH 293/974] MIPS: OCTEON: Use static resource allocation for CIU3
 interrupt controller.

We can simplify the code by assuming 4 IDTs and 10 mailboxes per core.
Fewer dynamic lookups are then needed, and allocations will never fail.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c | 124 ++++++++++++++++++-----------------
 1 file changed, 64 insertions(+), 60 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index 90d0fe4..a8a4c42 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -18,7 +18,6 @@
 #include <linux/of.h>
 
 #include <asm/octeon/octeon.h>
-#include <asm/octeon/cvmx-global-resources.h>
 #include <asm/octeon/cvmx-ciu2-defs.h>
 #include <asm/octeon/cvmx-ciu3-defs.h>
 
@@ -28,10 +27,9 @@ static DEFINE_PER_CPU(raw_spinlock_t, octeon_irq_ciu_spinlock);
 
 static DEFINE_PER_CPU(unsigned int, octeon_irq_ciu3_idt_ip2);
 static DEFINE_PER_CPU(unsigned int, octeon_irq_ciu3_idt_ip3);
-#define OCTEON_IRQ_MBOX_BITS 8
-static DEFINE_PER_CPU(unsigned int, octeon_irq_ciu3_mbox_isc[OCTEON_IRQ_MBOX_BITS]);
 static DEFINE_PER_CPU(struct irq_domain *, octeon_irq_ciu3_domain);
 static DEFINE_PER_CPU(u64, octeon_irq_ciu3_addr);
+#define CIU3_MBOX_PER_CORE 10
 
 static struct irq_domain *octeon_irq_ciu_domain_per_node[4];
 
@@ -2100,13 +2098,19 @@ static struct irq_domain_ops octeon_irq_domain_ciu3_ops = {
 	.xlate = octeon_irq_ciu3_xlat,
 };
 
+static int octeon_irq_get_local_core_num(void)
+{
+	/* Mask out the node bits */
+	return 0x7f & cvmx_get_core_num();
+}
+
 static void octeon_irq_ciu3_ip2(void)
 {
 	union cvmx_ciu3_destx_pp_int dest_pp_int;
 	struct irq_domain *d = __this_cpu_read(octeon_irq_ciu3_domain);
 	u64 ciu3_addr =  __this_cpu_read(octeon_irq_ciu3_addr);
 
-	dest_pp_int.u64 = cvmx_read_csr(ciu3_addr + CIU3_DEST_PP_INT(3 * (0x7f & cvmx_get_core_num())));
+	dest_pp_int.u64 = cvmx_read_csr(ciu3_addr + CIU3_DEST_PP_INT(3 * octeon_irq_get_local_core_num()));
 
 	if (likely(dest_pp_int.s.intr)) {
 		irq_hw_number_t intsn = dest_pp_int.s.intsn;
@@ -2125,28 +2129,40 @@ static void octeon_irq_ciu3_ip2(void)
 	}
 }
 
+/*
+ * 10 mbox per core starting from zero.
+ * Base mbox is core * 10
+ */
+static unsigned int octeon_irq_ciu3_base_mbox_intsn(int core)
+{
+	/* SW (mbox) are 0x04 in bits 12..19 */
+	return 0x04000 + CIU3_MBOX_PER_CORE * core;
+}
+
+static unsigned int octeon_irq_ciu3_mbox_intsn_for_core(int core, unsigned int mbox)
+{
+	return octeon_irq_ciu3_base_mbox_intsn(core) + mbox;
+}
+
+static unsigned int octeon_irq_ciu3_mbox_intsn_for_cpu(int cpu, unsigned int mbox)
+{
+	return octeon_irq_ciu3_mbox_intsn_for_core(octeon_coreid_for_cpu(cpu), mbox);
+}
+
 static void octeon_irq_ciu3_mbox(void)
 {
 	union cvmx_ciu3_destx_pp_int dest_pp_int;
 	u64 ciu3_addr = __this_cpu_read(octeon_irq_ciu3_addr);
+	int core = octeon_irq_get_local_core_num();
 
-	dest_pp_int.u64 = cvmx_read_csr(ciu3_addr + CIU3_DEST_PP_INT(1 + 3 * (0x7f & cvmx_get_core_num())));
+	dest_pp_int.u64 = cvmx_read_csr(ciu3_addr + CIU3_DEST_PP_INT(1 + 3 * core));
 
 	if (likely(dest_pp_int.s.intr)) {
 		irq_hw_number_t intsn = dest_pp_int.s.intsn;
-		unsigned int *pisc = this_cpu_ptr(&octeon_irq_ciu3_mbox_isc[0]);
-		int i;
-		int irq = 0;
+		int mbox = intsn - octeon_irq_ciu3_base_mbox_intsn(core);
 
-		for (i = 0; i < OCTEON_IRQ_MBOX_BITS; i++) {
-			if (pisc[i] == intsn) {
-				irq = i + OCTEON_IRQ_MBOX0;
-				break;
-			}
-		}
-
-		if (likely(irq)) {
-			do_IRQ(irq);
+		if (likely(mbox >= 0 && mbox < CIU3_MBOX_PER_CORE)) {
+			do_IRQ(mbox + OCTEON_IRQ_MBOX0);
 		} else {
 			u64 isc_ctl_addr = ciu3_addr + CIU3_ISC_CTL(intsn);
 			cvmx_write_csr(isc_ctl_addr, 0);
@@ -2158,18 +2174,13 @@ static void octeon_irq_ciu3_mbox(void)
 	}
 }
 
-static unsigned int octeon_irq_ciu3_mbox_intsn_for_cpu(int cpu, unsigned int mbox)
-{
-	return per_cpu(octeon_irq_ciu3_mbox_isc[mbox], cpu);
-}
-
 void octeon_ciu3_mbox_send(int cpu, unsigned int mbox)
 {
 	unsigned int intsn;
 	union cvmx_ciu3_iscx_w1s isc_w1s;
 	u64 isc_w1s_addr;
 
-	if (WARN_ON_ONCE(mbox >= OCTEON_IRQ_MBOX_BITS))
+	if (WARN_ON_ONCE(mbox >= CIU3_MBOX_PER_CORE))
 		return;
 
 	intsn = octeon_irq_ciu3_mbox_intsn_for_cpu(cpu, mbox);
@@ -2211,7 +2222,7 @@ static void octeon_irq_ciu3_mbox_enable(struct irq_data *data)
 	int cpu;
 	unsigned int mbox = data->irq - OCTEON_IRQ_MBOX0;
 
-	WARN_ON(mbox >= OCTEON_IRQ_MBOX_BITS);
+	WARN_ON(mbox >= CIU3_MBOX_PER_CORE);
 
 	for_each_online_cpu(cpu)
 		octeon_irq_ciu3_mbox_set_enable(data, cpu, true);
@@ -2222,7 +2233,7 @@ static void octeon_irq_ciu3_mbox_disable(struct irq_data *data)
 	int cpu;
 	unsigned int mbox = data->irq - OCTEON_IRQ_MBOX0;
 
-	WARN_ON(mbox >= OCTEON_IRQ_MBOX_BITS);
+	WARN_ON(mbox >= CIU3_MBOX_PER_CORE);
 
 	for_each_online_cpu(cpu)
 		octeon_irq_ciu3_mbox_set_enable(data, cpu, false);
@@ -2235,7 +2246,7 @@ static void octeon_irq_ciu3_mbox_ack(struct irq_data *data)
 	union cvmx_ciu3_iscx_w1c isc_w1c;
 	unsigned int mbox = data->irq - OCTEON_IRQ_MBOX0;
 
-	intsn = __this_cpu_read(octeon_irq_ciu3_mbox_isc[mbox]);
+	intsn = octeon_irq_ciu3_mbox_intsn_for_core(octeon_irq_get_local_core_num(), mbox);
 
 	isc_w1c.u64 = 0;
 	isc_w1c.s.raw = 1;
@@ -2259,31 +2270,24 @@ static int octeon_irq_ciu3_alloc_resources(struct irq_domain *domain)
 {
 	struct octeon_irq_ciu3_domain_data *dd = domain->host_data;
 	u64 b = dd->ciu3_addr;
-	int idt[2];
 	int idt_ip2, idt_ip3;
-	int isc[OCTEON_IRQ_MBOX_BITS];
-	int r, i;
-
-	r = cvmx_resource_alloc_many(CVMX_GR_TAG_CIU3_IDT(0),
-				     0,
-				     ARRAY_SIZE(idt), idt);
-	if (r)
-		return r;
-
-	r = cvmx_resource_alloc_many(CVMX_GR_TAG_CIU3_SWINTSN(0),
-				     0,
-				     ARRAY_SIZE(isc), isc);
-	if (r)
-		return r;
+	int unused_idt1, unused_idt2;
+	int core = octeon_irq_get_local_core_num();
+	int i;
 
 	__this_cpu_write(octeon_irq_ciu3_domain, domain);
 	__this_cpu_write(octeon_irq_ciu3_addr, dd->ciu3_addr);
-	idt_ip2 = idt[0] + 1;
-	idt_ip3 = idt[1] + 1;
+
+	/*
+	 * 4 idt per core starting from 1 because zero is reserved.
+	 * Base idt per core is 4 * core + 1
+	 */
+	idt_ip2 = core * 4 + 1;
+	idt_ip3 = core * 4 + 2;
+	unused_idt1 = core * 4 + 3;
+	unused_idt2 = core * 4 + 4;
 	__this_cpu_write(octeon_irq_ciu3_idt_ip2, idt_ip2);
 	__this_cpu_write(octeon_irq_ciu3_idt_ip3, idt_ip3);
-	for (i = 0; i < ARRAY_SIZE(isc); i++)
-		__this_cpu_write(octeon_irq_ciu3_mbox_isc[i], (0x4 << 12) + isc[i]);
 
 	/* ip2 interrupts for this CPU */
 	cvmx_write_csr(b + CIU3_IDT_CTL(idt_ip2), 0);
@@ -2295,6 +2299,20 @@ static int octeon_irq_ciu3_alloc_resources(struct irq_domain *domain)
 	cvmx_write_csr(b + CIU3_IDT_PP(idt_ip3, 0), 1ull << cvmx_get_core_num());
 	cvmx_write_csr(b + CIU3_IDT_IO(idt_ip3), 0);
 
+	cvmx_write_csr(b + CIU3_IDT_CTL(unused_idt1), 0);
+	cvmx_write_csr(b + CIU3_IDT_PP(unused_idt1, 0), 0);
+	cvmx_write_csr(b + CIU3_IDT_IO(unused_idt1), 0);
+
+	cvmx_write_csr(b + CIU3_IDT_CTL(unused_idt2), 0);
+	cvmx_write_csr(b + CIU3_IDT_PP(unused_idt2, 0), 0);
+	cvmx_write_csr(b + CIU3_IDT_IO(unused_idt2), 0);
+
+	for (i = 0; i < CIU3_MBOX_PER_CORE; i++) {
+		unsigned int intsn = octeon_irq_ciu3_mbox_intsn_for_core(core, i);
+		cvmx_write_csr(b + CIU3_ISC_W1C(intsn), 2);
+		cvmx_write_csr(b + CIU3_ISC_CTL(intsn), 0);
+	}
+
 	return 0;
 }
 
@@ -2326,14 +2344,12 @@ static struct irq_chip octeon_irq_chip_ciu3_mbox = {
 static int __init octeon_irq_init_ciu3(struct device_node *ciu_node,
 				       struct device_node *parent)
 {
-	int i, r;
+	int i;
 	int node;
-	int num_swintsn;
 	struct octeon_irq_ciu3_domain_data *dd;
 	const __be32 *zero_addr;
 	u64 base_addr;
 	union cvmx_ciu3_const consts;
-	union cvmx_ciu3_iscx_ctl isc_ctl;
 
 	dd = kzalloc_node(sizeof(*dd), GFP_KERNEL, of_node_to_nid(ciu_node));
 	if (!dd)
@@ -2351,20 +2367,8 @@ static int __init octeon_irq_init_ciu3(struct device_node *ciu_node,
 
 	consts.u64 = cvmx_read_csr(base_addr + CIU3_CONST);
 
-	num_swintsn = 0;
-	for (;;) {
-		isc_ctl.u64 = cvmx_read_csr(base_addr + CIU3_ISC_CTL(0x4000 + num_swintsn));
-		if (!isc_ctl.s.imp)
-			break;
-		num_swintsn++;
-	}
-
-	r = cvmx_create_global_resource_range(CVMX_GR_TAG_CIU3_IDT(0), consts.s.idt - 1);
-	r = cvmx_create_global_resource_range(CVMX_GR_TAG_CIU3_SWINTSN(0), num_swintsn);
-
 	octeon_irq_setup_secondary = octeon_irq_setup_secondary_ciu3;
 
-
 	octeon_irq_ip2 = octeon_irq_ciu3_ip2;
 	octeon_irq_ip3 = octeon_irq_ciu3_mbox;
 	octeon_irq_ip4 = octeon_irq_ip4_mask;
-- 
2.6.2

