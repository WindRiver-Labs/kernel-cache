From a21f2be9ca9f8279ad614fa8dc1c8cfd91e922bb Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@caviumnetworks.com>
Date: Fri, 18 Dec 2015 17:21:09 -0800
Subject: [PATCH 07/13] MIPS_OCTEON: Sync up SE files.

Signed-off-by: Chandrakala Chavva <cchavva@caviumnetworks.com>
[Original patch taken from patch set for OCTEON SDK 3.1.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |    2 +-
 .../cavium-octeon/executive/cvmx-helper-pko3.c     |    7 +-
 arch/mips/cavium-octeon/executive/cvmx-pcie.c      |    2 +-
 .../mips/cavium-octeon/executive/cvmx-pko3-queue.c |    3 +-
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      |    7 +-
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |   22 +-
 arch/mips/cavium-octeon/executive/cvmx-srio.c      |   67 +++--
 arch/mips/cavium-octeon/executive/cvmx-twsi.c      |    4 +-
 arch/mips/cavium-octeon/executive/octeon-feature.c |    4 +-
 arch/mips/include/asm/octeon/cvmx-app-init.h       |    2 +-
 arch/mips/include/asm/octeon/cvmx-asm.h            |   14 +-
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      |  374 ++++++++++---------
 arch/mips/include/asm/octeon/cvmx-bootmem.h        |   15 +
 arch/mips/include/asm/octeon/cvmx-dpi-defs.h       |    6 +-
 arch/mips/include/asm/octeon/cvmx-fpa-defs.h       |    2 +-
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     |  198 ++++++++++-
 arch/mips/include/asm/octeon/cvmx-helper.h         |   12 +-
 arch/mips/include/asm/octeon/cvmx-ila-defs.h       |   77 +++--
 arch/mips/include/asm/octeon/cvmx-ilk-defs.h       |  160 +++++----
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h      |   26 +-
 arch/mips/include/asm/octeon/cvmx-mio-defs.h       |   11 +-
 arch/mips/include/asm/octeon/cvmx-pemx-defs.h      |   18 +-
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |   94 +++---
 arch/mips/include/asm/octeon/cvmx-qlm.h            |    4 +-
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |    6 +-
 arch/mips/include/asm/octeon/cvmx-sli-defs.h       |   92 +++--
 arch/mips/include/asm/octeon/cvmx-spemx-defs.h     |    6 +-
 27 files changed, 783 insertions(+), 452 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index 163e6be..9c1e38e 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -345,7 +345,7 @@ static void __cvmx_bgx_common_init_pknd(int xiface, int index)
 	cmr_rx_id_map.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_RX_ID_MAP(index, xi.interface));
 	cmr_rx_id_map.s.pknd = pknd;
 	/* Change the default reassembly id (RID), as max 14 RIDs allowed */
-	if (OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX))
+	if (OCTEON_IS_MODEL(OCTEON_CN73XX))
 		cmr_rx_id_map.s.rid = ((4 * xi.interface) + 2 + index);
 	cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_ID_MAP(index, xi.interface),
 			    cmr_rx_id_map.u64);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
index fb8e1e6..a59ea6d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pko3.c
@@ -707,9 +707,10 @@ static int __cvmx_pko3_config_null_interface(unsigned int node)
 
 	if(OCTEON_IS_MODEL(OCTEON_CN78XX))
 		pko_mac_num = 0x1C; /* MAC# 28 virtual MAC for NULL */
-	else if (OCTEON_IS_MODEL(OCTEON_CN73XX) ||
-		OCTEON_IS_MODEL(OCTEON_CNF75XX))
-		pko_mac_num = 0x0F; /* MAC# 16 !? virtual MAC for NULL */
+	else if (OCTEON_IS_MODEL(OCTEON_CN73XX))
+		pko_mac_num = 0x0F; /* MAC# 16 virtual MAC for NULL */
+	else if (OCTEON_IS_MODEL(OCTEON_CNF75XX))
+		pko_mac_num = 0x0A; /* MAC# 10 virtual MAC for NULL */
 	else
 		return -1;
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pcie.c b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
index ff2d64c..cc1b219 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pcie.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pcie.c
@@ -42,7 +42,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 129050 $<hr>
+ * <hr>$Revision: 129228 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
index fb97816..89a5e84 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3-queue.c
@@ -386,7 +386,6 @@ static int cvmx_pko3_chan_2_xchan(uint16_t ipd_port)
 		/* IPD 0xe00 */ 0xfff >> 4,	/* not used */
 		/* IPD 0xf00 */ 0xfff >> 4	/* not used */
 	};
-	// FIXME: These values are wild guess, check with CSR again!
 	static const uint8_t xchan_base_cn75xx[16] = {
 		/* IPD 0x000 */ 0x040 >> 4,	/* LBK */
 		/* IPD 0x100 */ 0x080 >> 4,	/* DPI */
@@ -397,7 +396,7 @@ static int cvmx_pko3_chan_2_xchan(uint16_t ipd_port)
 		/* IPD 0x600 */ 0xfff >> 4,	/* not used */
 		/* IPD 0x700 */ 0xfff >> 4,	/* not used */
 		/* IPD 0x800 */ 0x000 >> 4,	/* BGX0 */
-		/* IPD 0x900 */ 0x020 >> 4,	/* BGX1 */
+		/* IPD 0x900 */ 0xfff >> 4,	/* not used */
 		/* IPD 0xa00 */ 0xfff >> 4,	/* not used */
 		/* IPD 0xb00 */ 0xfff >> 4,	/* not used */
 		/* IPD 0xc00 */ 0xfff >> 4,	/* not used */
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index 3d92fa1..3e3049e 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -260,11 +260,16 @@ int cvmx_pko3_hw_disable(int node)
 	cvmx_write_csr_node(node, CVMX_PKO_ENABLE, pko_enable.u64);
 
 	/* Assign NULL MAC# for L1/SQ disabled state */
-        if(OCTEON_IS_MODEL(OCTEON_CN73XX) || OCTEON_IS_MODEL(OCTEON_CNF75XX)) {
+        if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
 		null_mac_num = 0x0f;
 		null_fifo_num = 0x1f;
 		fifo_grp_count = 4;
 		pq_count = 16;
+	} else if (OCTEON_IS_MODEL(OCTEON_CNF75XX)) {
+		null_mac_num = 0x0a;
+		null_fifo_num = 0x1f;
+		fifo_grp_count = 4;
+		pq_count = 16;
 	} else {
 		null_mac_num = 0x1c;
 		null_fifo_num = 0x1f;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index 36c40b2..e8b360d 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 129042 $<hr>
+ * <hr>$Revision: 130011 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -306,23 +306,25 @@ int cvmx_qlm_lmac(int xiface, int index)
 			if (g2.s.bgx) {
 				if (g1.s.bgx) {
 					cvmx_gserx_phy_ctl_t phy_ctl1;
-					phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(5));
-					phy_ctl1.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(6));
+					phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(4));
+					phy_ctl1.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(5));
 					if ((phy_ctl.s.phy_pd
 					     || phy_ctl.s.phy_reset)
 					    && (phy_ctl1.s.phy_pd
 					        || phy_ctl1.s.phy_reset))
 						return -1;
+					if (index >= 2)
+						return 5;
 					return 4;
 				} else { /* QLM5 is BGX0 */
-					phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(6));
+					phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(5));
 					if (phy_ctl.s.phy_pd
 					    || phy_ctl.s.phy_reset)
 						return -1;
 					return 5;
 				}
 			} else if (g1.s.bgx) {
-				phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(5));
+				phy_ctl.u64 = cvmx_read_csr(CVMX_GSERX_PHY_CTL(4));
 				if (phy_ctl.s.phy_pd || phy_ctl.s.phy_reset)
 					return -1;
 				return 4;
@@ -355,8 +357,6 @@ int cvmx_qlm_mux_interface(int bgx)
 		return -1;
 	else if (OCTEON_IS_MODEL(OCTEON_CNF75XX) && bgx != 0)
 		return -1;
-	else
-		return -1;
 
 	if (OCTEON_IS_MODEL(OCTEON_CN73XX)) {
 		qlm1 = 5;
@@ -364,7 +364,8 @@ int cvmx_qlm_mux_interface(int bgx)
 	} else if (OCTEON_IS_MODEL(OCTEON_CNF75XX)) {
 		qlm1 = 4;
 		qlm2 = 5;
-	}
+	} else
+		return -1;
 
 	gser1.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm1));
 	gser2.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm2));
@@ -1925,7 +1926,10 @@ enum cvmx_qlm_mode __cvmx_qlm_get_mode_cnf75xx(int qlm)
 			if (mux == 0)
 				qlm_mode[qlm] = CVMX_QLM_MODE_MIXED;
 			else if (mux == 2)
-				qlm_mode[qlm] = CVMX_QLM_MODE_XFI_1X2;
+				if (train_mask)
+					qlm_mode[qlm] = CVMX_QLM_MODE_10G_KR_1X2;
+				else
+					qlm_mode[qlm] = CVMX_QLM_MODE_XFI_1X2;
 			else
 				qlm_mode[qlm] = CVMX_QLM_MODE_DISABLED;
 			break;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-srio.c b/arch/mips/cavium-octeon/executive/cvmx-srio.c
index a8be00a..3e45b53 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-srio.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-srio.c
@@ -163,6 +163,7 @@ static unsigned __cvmx_srio_to_sli(unsigned srio_port)
 		return srio_port;
 }
 
+#ifndef CVMX_BUILD_FOR_LINUX_HOST
 /**
  * @INTERNAL
  * Return the number of S2M_TYPE registers per sRIO port
@@ -173,7 +174,6 @@ static unsigned __cvmx_srio_num_s2m(unsigned srio_port)
 	return 16;
 }
 
-#ifndef CVMX_BUILD_FOR_LINUX_HOST
 /**
  * @INTERNAL
  * Allocate a SRIOX_S2M_TYPEX register for mapping a remote SRIO
@@ -515,8 +515,14 @@ cvmx_srio_init_cn75xx(int srio_port, cvmx_srio_initialize_flags_t flags)
 	}
 
 	rst_port = __cvmx_srio_to_rst(srio_port);
+
 	rst_ctl.u64 = cvmx_read_csr(CVMX_RST_CTLX(rst_port));
+	rst_ctl.s.rst_drv = 0;
+	rst_ctl.s.rst_rcv = 0;
+	rst_ctl.s.rst_chip = 0;
+	cvmx_write_csr(CVMX_RST_CTLX(rst_port), rst_ctl.u64);
 
+	rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CTLX(rst_port));
 	cvmx_dprintf("INFO: SRIO%d: Port in %s mode\n",
 		srio_port, (rst_ctl.s.host_mode) ? "host" : "endpoint");
 
@@ -589,7 +595,6 @@ cvmx_srio_init_cn75xx(int srio_port, cvmx_srio_initialize_flags_t flags)
 	if (__cvmx_srio_local_read32(srio_port,
 	    CVMX_SRIOMAINTX_PORT_LT_CTL(srio_port), &port_lt_ctl.u32))
 		return -1;
-	// FIXME: review math below - where is the clock coming from ??
 	port_lt_ctl.s.timeout = 1000000 / 200;	/* 1ms = 1000000ns / 200ns */
 	if (__cvmx_srio_local_write32(srio_port,
 	    CVMX_SRIOMAINTX_PORT_LT_CTL(srio_port), port_lt_ctl.u32))
@@ -632,11 +637,14 @@ cvmx_srio_init_cn75xx(int srio_port, cvmx_srio_initialize_flags_t flags)
 	/* Configure SLI for sRIO operation */
 	sli_port = __cvmx_srio_to_sli(srio_port);
 
-	/* Set the MRRS and MPS for optimal SRIO performance */
+	/* Set the MRRS and MPS for optimal SRIO performance. SRIO transfers
+	   data in 256 byte blocks. */
 	prt_cfg.u64 = cvmx_read_csr(CVMX_DPI_SLI_PRTX_CFG(sli_port));
-	prt_cfg.cnf75xx.mps = 1;
-	prt_cfg.cnf75xx.mrrs = 1;
-	prt_cfg.cnf75xx.molr = 32;
+	prt_cfg.cnf75xx.rd_mode = 1;	/* Non-exact reads, read extra */
+	prt_cfg.cnf75xx.mps_lim = 1;	/* Writes can't cross MPS size or alignment */
+	prt_cfg.cnf75xx.mps = 1;	/* Max payload of 256 bytes*/
+	prt_cfg.cnf75xx.mrrs_lim = 1;	/* Read requests can't cross MRRS boundary */
+	prt_cfg.cnf75xx.mrrs = 1;	/* Max read request is 256 bytes */
 
 	if (debug)
 		cvmx_dprintf("%s: DPI_SLI_PRTX_CFG QLM_CFG=%u\n",
@@ -645,25 +653,40 @@ cvmx_srio_init_cn75xx(int srio_port, cvmx_srio_initialize_flags_t flags)
 	/* Note: QLM_CFG here always reads as 0 */
 	cvmx_write_csr(CVMX_DPI_SLI_PRTX_CFG(sli_port), prt_cfg.u64);
 
-	/* Setup RX messaging thresholds */
+	/* Setup RX messaging thresholds
+	   RID 0 = LOOP
+ 	   RID 1 = DPI
+	   RID 4-7 = BGX ports
+	   RID 8-51 = SRIO0
+	   RID 52-95 = SRIO1
+	   Range used by SRIO is defined as base .. base + max_tot + sp_vport (inclusive) */
 	sriox_imsg_vport_thr.u64 = cvmx_read_csr(CVMX_SRIOX_IMSG_VPORT_THR(srio_port));
-	sriox_imsg_vport_thr.cnf75xx.base = 8 + (44 * srio_port);
-	sriox_imsg_vport_thr.cnf75xx.max_tot = 44;
+	sriox_imsg_vport_thr.cnf75xx.base = 8 + (43 * srio_port) + srio_port;
+	sriox_imsg_vport_thr.cnf75xx.max_tot = 42;	/* Inclusive and sp_vport reserves one */
+	sriox_imsg_vport_thr.cnf75xx.max_s1 = 24;
+	sriox_imsg_vport_thr.cnf75xx.max_s0 = 24;
 	sriox_imsg_vport_thr.cnf75xx.sp_vport = 1;
-	sriox_imsg_vport_thr.cnf75xx.buf_thr = 8;
-	sriox_imsg_vport_thr.cnf75xx.max_p1 = 12;	// FIXME: try 22 ?
-	sriox_imsg_vport_thr.cnf75xx.max_p0 = 12;
+	sriox_imsg_vport_thr.cnf75xx.buf_thr = 4;
+	sriox_imsg_vport_thr.cnf75xx.max_p1 = 43;
+	sriox_imsg_vport_thr.cnf75xx.max_p0 = 43;
 	cvmx_write_csr(CVMX_SRIOX_IMSG_VPORT_THR(srio_port), sriox_imsg_vport_thr.u64);
 
-	/* Bring the link down, then up,
-	 * by writing to the SRIO port's PORT_0_CTL2 CSR.
-	 */
-	if (__cvmx_srio_local_read32(srio_port,
-	    CVMX_SRIOMAINTX_PORT_0_CTL2(srio_port), &port_0_ctl2.u32))
-		return -1;
-	if (__cvmx_srio_local_write32(srio_port,
-	    CVMX_SRIOMAINTX_PORT_0_CTL2(srio_port), port_0_ctl2.u32))
-		return -1;
+	if (rst_ctl.s.host_mode) {
+		/* Clear the ACK state */
+		if (__cvmx_srio_local_write32(srio_port,
+				CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(srio_port), 0))
+			return -1;
+		
+		/* Bring the link down, then up,
+	 	* by writing to the SRIO port's PORT_0_CTL2 CSR.
+	 	*/
+		if (__cvmx_srio_local_read32(srio_port,
+				CVMX_SRIOMAINTX_PORT_0_CTL2(srio_port), &port_0_ctl2.u32))
+			return -1;
+		if (__cvmx_srio_local_write32(srio_port,
+				CVMX_SRIOMAINTX_PORT_0_CTL2(srio_port), port_0_ctl2.u32))
+			return -1;
+	}
 
 	/* Clear any pending interrupts */
 	cvmx_write_csr(CVMX_SRIOX_INT_REG(srio_port),
@@ -1827,7 +1850,7 @@ uint64_t cvmx_srio_physical_map(int srio_port, cvmx_srio_write_mode_t write_op,
 
 	/* Build the needed SubID config */
 	needed_subid.u64 = 0;
-	needed_subid.s.port = srio_port;
+	needed_subid.s.port = __cvmx_srio_to_sli(srio_port);
 	needed_subid.s.nmerge = 0;
 
 	/* We might want to use the device ID swapping modes so the device
diff --git a/arch/mips/cavium-octeon/executive/cvmx-twsi.c b/arch/mips/cavium-octeon/executive/cvmx-twsi.c
index 785f104..cfbc568 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-twsi.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-twsi.c
@@ -42,7 +42,7 @@
  *
  * Interface to the TWSI / I2C bus
  *
- * <hr>$Revision: 130004 $<hr>
+ * <hr>$Revision: 130009 $<hr>
  *
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
@@ -69,6 +69,7 @@
 #define cvmx_csr_db_decode(...)
 #endif /*PRINT_TWSI_CONFIG */
 
+#if 0
 static int node_bus_to_i2c_bus(int node, int bus)
 {
 	if (octeon_has_feature(OCTEON_FEATURE_MULTINODE))
@@ -76,6 +77,7 @@ static int node_bus_to_i2c_bus(int node, int bus)
 	else
 		return bus;
 }
+#endif
 
 static int i2c_bus_to_node(int i2c_bus)
 {
diff --git a/arch/mips/cavium-octeon/executive/octeon-feature.c b/arch/mips/cavium-octeon/executive/octeon-feature.c
index d881b47..1b0546a 100644
--- a/arch/mips/cavium-octeon/executive/octeon-feature.c
+++ b/arch/mips/cavium-octeon/executive/octeon-feature.c
@@ -81,7 +81,7 @@ static int octeon_map_clear_bit(uint8_t *map, int pos)
 CVMX_SHARED uint8_t octeon_feature_map[FEATURE_MAP_SIZE] __attribute__ ((aligned(128)));
 EXPORT_SYMBOL(octeon_feature_map);
 
-void __init octeon_feature_init(void)
+void octeon_feature_init(void)
 {
 	octeon_feature_result_t val;
 
@@ -235,7 +235,7 @@ int octeon_clear_attr(octeon_attr_t attr)
 	return 0;
 }
 
-void __init octeon_attr_init(void)
+void octeon_attr_init(void)
 {
 #ifndef CVMX_BUILD_FOR_LINUX_KERNEL
 	if (cvmx_is_init_core())
diff --git a/arch/mips/include/asm/octeon/cvmx-app-init.h b/arch/mips/include/asm/octeon/cvmx-app-init.h
index ad6c5c1..e51b514 100644
--- a/arch/mips/include/asm/octeon/cvmx-app-init.h
+++ b/arch/mips/include/asm/octeon/cvmx-app-init.h
@@ -41,7 +41,7 @@
  * @file
  * Header file for simple executive application initialization.  This defines
  * part of the ABI between the bootloader and the application.
- * <hr>$Revision: 128584 $<hr>
+ * <hr>$Revision: 129870 $<hr>
  *
  */
 
diff --git a/arch/mips/include/asm/octeon/cvmx-asm.h b/arch/mips/include/asm/octeon/cvmx-asm.h
index aa58f1e..d3eb416 100644
--- a/arch/mips/include/asm/octeon/cvmx-asm.h
+++ b/arch/mips/include/asm/octeon/cvmx-asm.h
@@ -42,7 +42,7 @@
  *
  * This is file defines ASM primitives for the executive.
 
- * <hr>$Revision: 102444 $<hr>
+ * <hr>$Revision: 129707 $<hr>
  *
  *
  */
@@ -590,11 +590,11 @@ extern "C" {
 /* SMS4 */
 
 /* pos can be 0-1 */
-#define CVMX_MF_SMS4_IV(val,pos)	asm volatile ("dmfc2 %[rt],0x0102+"CVMX_TMP_STR(pos) : [rt] "=d" (val) :               )
+#define CVMX_MF_SMS4_IV(val,pos)	asm volatile ("dmfc2 %[rt],0x0102+" CVMX_TMP_STR(pos) : [rt] "=d" (val) :               )
 /* pos can be 0-1 */
-#define CVMX_MF_SMS4_KEY(val,pos)	asm volatile ("dmfc2 %[rt],0x0104+"CVMX_TMP_STR(pos) : [rt] "=d" (val) :               )
+#define CVMX_MF_SMS4_KEY(val,pos)	asm volatile ("dmfc2 %[rt],0x0104+" CVMX_TMP_STR(pos) : [rt] "=d" (val) :               )
 /* pos can be 0-1 */
-#define CVMX_MF_SMS4_RESINP(val,pos)	asm volatile ("dmfc2 %[rt],0x0100+"CVMX_TMP_STR(pos) : [rt] "=d" (val) :               )
+#define CVMX_MF_SMS4_RESINP(val,pos)	asm volatile ("dmfc2 %[rt],0x0100+" CVMX_TMP_STR(pos) : [rt] "=d" (val) :               )
 #define CVMX_MT_SMS4_DEC_CBC0(val)	asm volatile ("dmtc2 %[rt],0x010c"                   : : [rt] "d" (val))
 #define CVMX_MT_SMS4_DEC_CBC1(val)	asm volatile ("dmtc2 %[rt],0x311d"      : : [rt] "d" (val))
 #define CVMX_MT_SMS4_DEC0(val)		asm volatile ("dmtc2 %[rt],0x010e"      : : [rt] "d" (val))
@@ -604,11 +604,11 @@ extern "C" {
 #define CVMX_MT_SMS4_ENC0(val)		asm volatile ("dmtc2 %[rt],0x010a"      : : [rt] "d" (val))
 #define CVMX_MT_SMS4_ENC1(val)		asm volatile ("dmtc2 %[rt],0x311b"      : : [rt] "d" (val))
 /* pos can be 0-1 */
-#define CVMX_MT_SMS4_IV(val,pos)	asm volatile ("dmtc2 %[rt],0x0102+"CVMX_TMP_STR(pos) : : [rt] "d" (val))
+#define CVMX_MT_SMS4_IV(val,pos)	asm volatile ("dmtc2 %[rt],0x0102+" CVMX_TMP_STR(pos) : : [rt] "d" (val))
 /* pos can be 0-1 */
-#define CVMX_MT_SMS4_KEY(val,pos)	asm volatile ("dmtc2 %[rt],0x0104+"CVMX_TMP_STR(pos) : : [rt] "d" (val))
+#define CVMX_MT_SMS4_KEY(val,pos)	asm volatile ("dmtc2 %[rt],0x0104+" CVMX_TMP_STR(pos) : : [rt] "d" (val))
 /* pos can be 0-1 */
-#define CVMX_MT_SMS4_RESINP(val,pos)	asm volatile ("dmtc2 %[rt],0x0100+"CVMX_TMP_STR(pos) : : [rt] "d" (val))
+#define CVMX_MT_SMS4_RESINP(val,pos)	asm volatile ("dmtc2 %[rt],0x0100+" CVMX_TMP_STR(pos) : : [rt] "d" (val))
 
 /* CAMELLIA */
 
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index e97964c..b8c7ae3 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -2437,15 +2437,18 @@ union cvmx_bgxx_cmrx_config {
                                                          When set, LMAC operation is enabled, including link bring-up, synchronization, and
                                                          transmit/receive of idles and fault sequences. Note that configuration registers for an
                                                          LMAC are not reset when this bit is clear, allowing software to program them before
-                                                         setting this bit to enable the LMAC. This bit together with LMAC_TYPE is also used to
+                                                         setting this bit to enable the LMAC. This bit together with [LMAC_TYPE] is also used to
                                                          enable the clocking to the GMP and/or blocks of the Super path (SMU and SPU). CMR clocking
                                                          is enabled when any of the paths are enabled. */
-	uint64_t data_pkt_rx_en               : 1;  /**< Data packet receive enable. When ENABLE = 1 and DATA_PKT_RX_EN = 1, the reception of data
-                                                         packets is enabled in the MAC layer. When ENABLE = 1 and DATA_PKT_RX_EN = 0, the MAC layer
+	uint64_t data_pkt_rx_en               : 1;  /**< Data packet receive enable. When ENABLE = 1 and [DATA_PKT_RX_EN] = 1, the reception of
+                                                         data
+                                                         packets is enabled in the MAC layer. When ENABLE = 1 and [DATA_PKT_RX_EN] = 0, the MAC
+                                                         layer
                                                          drops received data and flow-control packets. */
-	uint64_t data_pkt_tx_en               : 1;  /**< Data packet transmit enable. When ENABLE = 1 and DATA_PKT_TX_EN = 1, the transmission of
+	uint64_t data_pkt_tx_en               : 1;  /**< Data packet transmit enable. When ENABLE = 1 and [DATA_PKT_TX_EN] = 1, the transmission of
                                                          data
-                                                         packets is enabled in the MAC layer. When ENABLE = 1 and DATA_PKT_TX_EN = 0, the MAC layer
+                                                         packets is enabled in the MAC layer. When ENABLE = 1 and [DATA_PKT_TX_EN] = 0, the MAC
+                                                         layer
                                                          suppresses the transmission of new data and packets for the LMAC. */
 	uint64_t int_beat_gen                 : 1;  /**< Internal beat generation. This bit is used for debug/test purposes and should be clear
                                                          during normal operation. When set, the LMAC's PCS layer ignores RXVALID and
@@ -2453,10 +2456,7 @@ union cvmx_bgxx_cmrx_config {
                                                          RXVALID and TXCREDIT pulses, and suppresses transmission to the SerDes. */
 	uint64_t mix_en                       : 1;  /**< Management enable. This bit is used by LMACs 0 and 1 only, and should be kept clear for
                                                          LMACs 2 and 3. Setting it will pipe the LMAC to and from the MIX interface (LMAC0 to/from
-                                                         MIX0, LMAC1 to/from MIX1). LMAC_TYPE must be 0 (SGMII) then this bit is set. Note that at
-                                                         most one BGX can be attached to each of MIX0 and MIX1, i.e. at most one
-                                                         BGX(0)_CMR(0)_CONFIG[MIX_EN] bit and one BGX(0)_CMR(1)_CONFIG[MIX_EN] bit can be
-                                                         set.
+                                                         MIX0, LMAC1 to/from MIX1).  [LMAC_TYPE] must be 0 (SGMII) then this bit is set.
                                                          This field must be programmed to its final value before [ENABLE] is set, and must not
                                                          be changed when [ENABLE]=1. */
 	uint64_t lmac_type                    : 3;  /**< Logical MAC/PCS/prt type:
@@ -2490,10 +2490,10 @@ union cvmx_bgxx_cmrx_config {
                                                            <1:0>   PCS Lane 0 SerDes ID       0x0
                                                          </pre>
                                                          PCS lanes 0 through NUM_PCS_LANES-1 are valid, where NUM_PCS_LANES is a function of the
-                                                         logical MAC/PCS type. (See definition of LMAC_TYPE.) For example, when LMAC_TYPE = RXAUI,
+                                                         logical MAC/PCS type (see [LMAC_TYPE]). For example, when [LMAC_TYPE] = RXAUI,
                                                          then NUM_PCS_LANES = 2, PCS lanes 0 and 1 valid and the associated physical SerDes lanes
                                                          are selected by bits <1:0> and <3:2>, respectively.
-                                                         For 40GBASE-R (LMAC_TYPE = 40G_R), all four PCS lanes are valid, and the PCS lane IDs
+                                                         For 40GBASE-R ([LMAC_TYPE] = 40G_R), all four PCS lanes are valid, and the PCS lane IDs
                                                          determine the block distribution order and associated alignment markers on the transmit
                                                          side. This is not necessarily the order in which PCS lanes receive data because 802.3
                                                          allows multilane BASE-R receive lanes to be reordered. When a lane (called service
@@ -2559,8 +2559,8 @@ union cvmx_bgxx_cmrx_prt_cbfc_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
 	uint64_t phys_bp                      : 16; /**< When BGX()_SMU()_CBFC_CTL[RX_EN] is set and the hardware is backpressuring any
-                                                         LMACs (from either PFC/CBFC PAUSE packets or BGX()_CMR()_TX_OVR_BP[TX_CHAN_BP])
-                                                         and all LMACs indicated by PHYS_BP are backpressured, simulate physical backpressure by
+                                                         LMACs (from either PFC packets or BGX()_CMR()_TX_OVR_BP[TX_CHAN_BP])
+                                                         and all LMACs indicated by [PHYS_BP] are backpressured, simulate physical backpressure by
                                                          deferring all packets on the transmitter. */
 	uint64_t reserved_0_15                : 16;
 #else
@@ -2665,15 +2665,15 @@ union cvmx_bgxx_cmrx_rx_bp_on {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t mark                         : 12; /**< High watermark. Buffer depth in multiple of 16-bytes, at which BGX will
-                                                         assert backpressure for each individual LMAC.  MARK must satisfy:
-                                                           BGX()_CMR()_RX_BP_OFF[MARK] <= MARK <
+                                                         assert backpressure for each individual LMAC. Must satisfy:
+                                                           BGX()_CMR()_RX_BP_OFF[MARK] <= BGX()_CMR()_RX_BP_ON[MARK] <
                                                            (FIFO_SIZE - BGX()_CMR()_RX_BP_DROP[MARK]).
                                                          A value of 0x0 immediately asserts backpressure.
                                                          The recommended value is 1/4th the size of the per-LMAC RX FIFO_SIZE as
                                                          determined by BGX()_CMR_RX_LMACS[LMACS]. For example in SGMII mode with
                                                          four LMACs of type SGMII, where BGX()_CMR_RX_LMACS[LMACS]=0x4, there is
                                                          16 KB of buffering. The recommended 1/4th size of that 16 KB is 4 KB, which
-                                                         in units of 16 bytes gives MARK = 0x100 (the reset value). */
+                                                         in units of 16 bytes gives [MARK] = 0x100 (the reset value). */
 #else
 	uint64_t mark                         : 12;
 	uint64_t reserved_12_63               : 52;
@@ -3186,11 +3186,11 @@ union cvmx_bgxx_cmrx_tx_hg2_status {
 	struct cvmx_bgxx_cmrx_tx_hg2_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t xof                          : 16; /**< 16-bit XOF back pressure vector from HiGig2 message packet or from PFC/CBFC packets. Non-
+	uint64_t xof                          : 16; /**< 16-bit XOF back pressure vector from HiGig2 message packet or from PFC packets. Non-
                                                          zero only when logical back pressure is active. All bits are 0 when LGTIM2GO=0x0. */
 	uint64_t lgtim2go                     : 16; /**< Logical packet flow back pressure time remaining. Initial value set from XOF time field of
                                                          HiGig2 message packet received or a function of the enabled and current timers for
-                                                         PFC/CBFC packets. Non-zero only when logical back pressure is active. */
+                                                         PFC packets. Non-zero only when logical back pressure is active. */
 #else
 	uint64_t lgtim2go                     : 16;
 	uint64_t xof                          : 16;
@@ -3735,9 +3735,10 @@ union cvmx_bgxx_cmr_chan_msk_and {
 	uint64_t u64;
 	struct cvmx_bgxx_cmr_chan_msk_and_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t msk_and                      : 64; /**< Assert physical backpressure when the backpressure channel vector combined with MSK_AND
+	uint64_t msk_and                      : 64; /**< Assert physical backpressure when the backpressure channel vector combined with [MSK_AND]
                                                          indicates backpressure as follows:
-                                                         _ phys_bp_msk_and = MSK_AND<x:y> != 0 && (CHAN_VECTOR<x:y> & MSK_AND<x:y>) == MSK_AND<x:y>
+                                                         _ phys_bp_msk_and = [MSK_AND]<x:y> != 0 && (chan_vector<x:y> & [MSK_AND]<x:y>) ==
+                                                         [MSK_AND]<x:y>
                                                          _ phys_bp = phys_bp_msk_or || phys_bp_msk_and
                                                          In single LMAC configurations, x = 63, y = 0.
                                                          In multi-LMAC configurations, x/y are set as follows:
@@ -3763,9 +3764,9 @@ union cvmx_bgxx_cmr_chan_msk_or {
 	uint64_t u64;
 	struct cvmx_bgxx_cmr_chan_msk_or_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t msk_or                       : 64; /**< Assert physical backpressure when the backpressure channel vector combined with MSK_OR
+	uint64_t msk_or                       : 64; /**< Assert physical backpressure when the backpressure channel vector combined with [MSK_OR]
                                                          indicates backpressure as follows:
-                                                         _ phys_bp_msk_or = (CHAN_VECTOR<x:y> & MSK_OR<x:y>) != 0
+                                                         _ phys_bp_msk_or = (chan_vector<x:y> & [MSK_OR]<x:y>) != 0
                                                          _ phys_bp = phys_bp_msk_or || phys_bp_msk_and
                                                          In single LMAC configurations, x = 63, y = 0.
                                                          In multi-LMAC configurations, x/y are set as follows:
@@ -3819,17 +3820,17 @@ union cvmx_bgxx_cmr_global_config {
                                                          setting this bit to 1. It resets the MIX interface state in the BGX (mix FIFO and pending
                                                          requests to MIX) and prevents the RXB FIFOs for all LMACs from pushing data to the
                                                          interface. Setting this bit to 0 will not reset the MIX interface. After MIX comes out of
-                                                         reset, software should clear CMR_MIX_RESET. */
+                                                         reset, software should clear this bit. */
 	uint64_t cmr_mix0_reset               : 1;  /**< If the MIX0 block is reset, software also needs to reset the MIX interface in the BGX by
                                                          setting this bit to 1. It resets the MIX interface state in the BGX (mix FIFO and pending
                                                          requests to MIX) and prevents the RXB FIFOs for all LMACs from pushing data to the
                                                          interface. Setting this bit to 0 will not reset the MIX interface. After MIX comes out of
-                                                         reset, software should clear CMR_MIX_RESET. */
+                                                         reset, software should clear this bit. */
 	uint64_t cmr_x2p_reset                : 1;  /**< If the PKI block is reset, software also needs to reset the X2P interface in the BGX by
                                                          setting this bit to 1. It resets the X2P interface state in the BGX (skid FIFO and pending
                                                          requests to PKI) and prevents the RXB FIFOs for all LMACs from pushing data to the
                                                          interface. Setting this bit to 0 does not reset the X2P interface. After PKI comes out of
-                                                         reset, software should clear CMR_X2P_RESET. */
+                                                         reset, software should clear this bit. */
 	uint64_t bgx_clk_enable               : 1;  /**< The global clock enable for BGX. Setting this bit overrides clock enables set by
                                                          BGX()_CMR()_CONFIG[ENABLE] and BGX()_CMR()_CONFIG[LMAC_TYPE], essentially
                                                          turning on clocks for the entire BGX. Setting this bit to 0 results in not overriding
@@ -3993,20 +3994,20 @@ union cvmx_bgxx_cmr_rx_adrx_cam {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
 	uint64_t id                           : 2;  /**< Logical MAC ID that this DMAC CAM address applies to. BGX has 32 DMAC CAM entries that can
-                                                         be accessed with the BGX()_CMR_RX_ADR_CAM() CSRs. These 32 DMAC entries can be used by
+                                                         be accessed with these registers. These 32 DMAC entries can be used by
                                                          any of the four SGMII MACs or the 10G/40G MACs using these register bits.
                                                          A typical configuration is to provide eight CAM entries per LMAC ID, which is configured
                                                          using the following settings:
-                                                         * LMAC interface 0: BGX(0)_CMR_RX_ADR(0..7)_CAM[ID] = 0x0.
-                                                         * LMAC interface 1: BGX(0)_CMR_RX_ADR(8..15)_CAM[ID] = 0x1.
-                                                         * LMAC interface 2: BGX(0)_CMR_RX_ADR(16..23)_CAM[ID] = 0x2.
-                                                         * LMAC interface 3: BGX(0)_CMR_RX_ADR(24..31)_CAM[ID] = 0x3. */
+                                                         * LMAC interface 0: BGX()_CMR_RX_ADR(0..7)_CAM[ID] = 0x0.
+                                                         * LMAC interface 1: BGX()_CMR_RX_ADR(8..15)_CAM[ID] = 0x1.
+                                                         * LMAC interface 2: BGX()_CMR_RX_ADR(16..23)_CAM[ID] = 0x2.
+                                                         * LMAC interface 3: BGX()_CMR_RX_ADR(24..31)_CAM[ID] = 0x3. */
 	uint64_t reserved_49_51               : 3;
 	uint64_t en                           : 1;  /**< CAM entry enable for this DMAC address.
                                                          1 = Include this address in the matching algorithm.
                                                          0 = Don't include this address in the matching algorithm. */
 	uint64_t adr                          : 48; /**< DMAC address in the CAM used for matching. Specified in network byte order, i.e.
-                                                         ADR[47:40] is for the first DMAC byte on the wire. The CAM matches against unicast or
+                                                         ADR<47:40> is for the first DMAC byte on the wire. The CAM matches against unicast or
                                                          multicast DMAC addresses. All BGX()_CMR_RX_ADR()_CAM CSRs can be used in any of the LMAC
                                                          combinations such that any BGX MAC can use any of the 32 common DMAC entries. */
 #else
@@ -4079,8 +4080,9 @@ union cvmx_bgxx_cmr_rx_ovr_bp {
                                                          0 = LMAC is available.
                                                          1 = LMAC should be backpressured.
                                                          Bit<4> represents LMAC 0, ..., bit<7> represents LMAC 3. */
-	uint64_t ign_fifo_bp                  : 4;  /**< Ignore the RX FIFO BP_ON signal when computing backpressure. CMR does not backpressure the
-                                                         MAC due to the FIFO length passing BP_ON mark. */
+	uint64_t ign_fifo_bp                  : 4;  /**< Ignore BGX()_CMR()_RX_BP_ON[MARK] when computing backpressure. CMR does not backpressure
+                                                         the
+                                                         MAC due to the FIFO length passing BGX()_CMR()_RX_BP_ON[MARK]. */
 #else
 	uint64_t ign_fifo_bp                  : 4;
 	uint64_t bp                           : 4;
@@ -4155,10 +4157,10 @@ union cvmx_bgxx_gmp_gmi_prtx_cfg {
                                                          0 = half-duplex (collisions/extensions/bursts).
                                                          1 = full-duplex. */
 	uint64_t speed                        : 1;  /**< Link Speed LSB (SGMII/1000Base-X only):
-                                                         _ [SPEED_MSB:SPEED] = 0x0: 100 Mb/s operation.
-                                                         _ [SPEED_MSB:SPEED] = 0x1: 1000 Mb/s operation.
-                                                         _ [SPEED_MSB:SPEED] = 0x2: 10 Mb/s operation.
-                                                         _ [SPEED_MSB:SPEED] = 0x3: Reserved. */
+                                                         _ [SPEED_MSB,SPEED] = 0x0: 100 Mb/s operation.
+                                                         _ [SPEED_MSB,SPEED] = 0x1: 1000 Mb/s operation.
+                                                         _ [SPEED_MSB,SPEED] = 0x2: 10 Mb/s operation.
+                                                         _ [SPEED_MSB,SPEED] = 0x3: Reserved. */
 	uint64_t reserved_0_0                 : 1;
 #else
 	uint64_t reserved_0_0                 : 1;
@@ -4184,8 +4186,8 @@ typedef union cvmx_bgxx_gmp_gmi_prtx_cfg cvmx_bgxx_gmp_gmi_prtx_cfg_t;
  * cvmx_bgx#_gmp_gmi_rx#_decision
  *
  * This register specifies the byte count used to determine when to accept or to filter a packet.
- * As each byte in a packet is received by GMI, the L2 byte count is compared against the
- * BGX()_GMP_GMI_RX()_DECISION[CNT]. In normal operation, the L2 header begins after the
+ * As each byte in a packet is received by GMI, the L2 byte count is compared against
+ * [CNT]. In normal operation, the L2 header begins after the
  * PREAMBLE + SFD (BGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] = 1) and any optional UDD skip
  * data (BGX()_GMP_GMI_RX()_UDD_SKP[LEN]).
  */
@@ -4194,7 +4196,7 @@ union cvmx_bgxx_gmp_gmi_rxx_decision {
 	struct cvmx_bgxx_gmp_gmi_rxx_decision_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
-	uint64_t cnt                          : 5;  /**< The byte count used to decide when to accept or filter a packet. Refer to GMI Decisions. */
+	uint64_t cnt                          : 5;  /**< The byte count used to decide when to accept or filter a packet. */
 #else
 	uint64_t cnt                          : 5;
 	uint64_t reserved_5_63                : 59;
@@ -4246,13 +4248,15 @@ typedef union cvmx_bgxx_gmp_gmi_rxx_frm_chk cvmx_bgxx_gmp_gmi_rxx_frm_chk_t;
  * cvmx_bgx#_gmp_gmi_rx#_frm_ctl
  *
  * This register controls the handling of the frames.
- * The CTL_BCK/CTL_DRP bits control how the hardware handles incoming PAUSE packets. The most
+ * The [CTL_BCK] and [CTL_DRP] bits control how the hardware handles incoming PAUSE packets. The
+ * most
  * common modes of operation:
- * _ CTL_BCK = 1, CTL_DRP = 1: hardware handles everything.
- * _ CTL_BCK = 0, CTL_DRP = 0: software sees all PAUSE frames.
- * _ CTL_BCK = 0, CTL_DRP = 1: all PAUSE frames are completely ignored.
+ * _ [CTL_BCK] = 1, [CTL_DRP] = 1: hardware handles everything.
+ * _ [CTL_BCK] = 0, [CTL_DRP] = 0: software sees all PAUSE frames.
+ * _ [CTL_BCK] = 0, [CTL_DRP] = 1: all PAUSE frames are completely ignored.
  *
- * These control bits should be set to CTL_BCK = 0,CTL_DRP = 0 in half-duplex mode. Since PAUSE
+ * These control bits should be set to [CTL_BCK] = 0, [CTL_DRP] = 0 in half-duplex mode. Since
+ * PAUSE
  * packets only apply to full duplex operation, any PAUSE packet would constitute an exception
  * which should be handled by the processing cores. PAUSE packets should not be forwarded.
  */
@@ -4261,7 +4265,7 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_ctl {
 	struct cvmx_bgxx_gmp_gmi_rxx_frm_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_13_63               : 51;
-	uint64_t ptp_mode                     : 1;  /**< Timestamp mode. When PTP_MODE is set, a 64-bit timestamp is prepended to every incoming
+	uint64_t ptp_mode                     : 1;  /**< Timestamp mode. When [PTP_MODE] is set, a 64-bit timestamp is prepended to every incoming
                                                          packet.
                                                          The timestamp bytes are added to the packet in such a way as to not modify the packet's
                                                          receive byte count. This implies that the BGX()_GMP_GMI_RX()_JABBER,
@@ -4270,8 +4274,8 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_ctl {
                                                          do not require any adjustment as they operate on the received
                                                          packet size. When the packet reaches PKI, its size reflects the additional bytes and is
                                                          subject to the following restrictions:
-                                                         If PTP_MODE = 1 and PRE_CHK = 1, PRE_STRP must be 1.
-                                                         If PTP_MODE = 1:
+                                                         If [PTP_MODE] = 1 and [PRE_CHK] = 1, [PRE_STRP] must be 1.
+                                                         If [PTP_MODE] = 1:
                                                          * PKI_CL()_PKIND()_SKIP[FCS_SKIP,INST_SKIP] should be increased by 8.
                                                          * PKI_CL()_PKIND()_CFG[HG_EN] should be 0.
                                                          * PKI_FRM_LEN_CHK()[MAXLEN] should be increased by 8.
@@ -4280,12 +4284,12 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_ctl {
 	uint64_t reserved_11_11               : 1;
 	uint64_t null_dis                     : 1;  /**< When set, do not modify the MOD bits on NULL ticks due to partial packets. */
 	uint64_t pre_align                    : 1;  /**< When set, PREAMBLE parser aligns the SFD byte regardless of the number of previous
-                                                         PREAMBLE nibbles. In this mode, PRE_STRP should be set to account for the variable nature
-                                                         of the PREAMBLE. PRE_CHK must be set to enable this and all PREAMBLE features.
+                                                         PREAMBLE nibbles. In this mode, [PRE_STRP] should be set to account for the variable
+                                                         nature of the PREAMBLE. [PRE_CHK] must be set to enable this and all PREAMBLE features.
                                                          SGMII at 10/100Mbs only. */
 	uint64_t reserved_7_8                 : 2;
 	uint64_t pre_free                     : 1;  /**< When set, PREAMBLE checking is less strict. GMI will begin the frame at the first SFD.
-                                                         PRE_CHK must be set to enable this and all PREAMBLE features. SGMII/1000Base-X only. */
+                                                         [PRE_CHK] must be set to enable this and all PREAMBLE features. SGMII/1000Base-X only. */
 	uint64_t ctl_smac                     : 1;  /**< Control PAUSE frames can match station SMAC. */
 	uint64_t ctl_mcst                     : 1;  /**< Control PAUSE frames can match globally assigned multicast address. */
 	uint64_t ctl_bck                      : 1;  /**< Forward PAUSE information to TX block. */
@@ -4294,18 +4298,19 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_ctl {
                                                          0 = PREAMBLE + SFD is sent to core as part of frame.
                                                          1 = PREAMBLE + SFD is dropped.
                                                          [PRE_CHK] must be set to enable this and all PREAMBLE features.
-                                                         If PTP_MODE=1 and PRE_CHK=1, PRE_STRP must be 1.
-                                                         When PRE_CHK is set (indicating that the PREAMBLE will be sent), PRE_STRP determines if
+                                                         If [PTP_MODE]=1 and [PRE_CHK]=1, [PRE_STRP] must be 1.
+                                                         When [PRE_CHK] is set (indicating that the PREAMBLE will be sent), [PRE_STRP] determines
+                                                         if
                                                          the PREAMBLE+SFD bytes are thrown away or sent to the core as part of the packet. In
                                                          either mode, the PREAMBLE+SFD bytes are not counted toward the packet size when checking
                                                          against the MIN and MAX bounds. Furthermore, the bytes are skipped when locating the start
                                                          of the L2 header for DMAC and Control frame recognition. */
 	uint64_t pre_chk                      : 1;  /**< Check the preamble for correctness. This port is configured to send a valid 802.3 PREAMBLE
-                                                         to begin every frame. GMI checks that a valid PREAMBLE is received (based on PRE_FREE).
+                                                         to begin every frame. GMI checks that a valid PREAMBLE is received (based on [PRE_FREE]).
                                                          When a problem does occur within the PREAMBLE sequence, the frame is marked as bad and not
                                                          sent into the core. The BGX()_SMU()_RX_INT[PCTERR] interrupt is also raised.
-                                                         When BGX()_SMU()_TX_CTL[HG_EN] is set, PRE_CHK must be 0. If PTP_MODE = 1 and
-                                                         PRE_CHK = 1, PRE_STRP must be 1. */
+                                                         When BGX()_SMU()_TX_CTL[HG_EN] is set, [PRE_CHK] must be 0. If [PTP_MODE] = 1 and
+                                                         [PRE_CHK] = 1, [PRE_STRP] must be 1. */
 #else
 	uint64_t pre_chk                      : 1;
 	uint64_t pre_strp                     : 1;
@@ -4459,8 +4464,7 @@ union cvmx_bgxx_gmp_gmi_rxx_udd_skp {
 	uint64_t fcssel                       : 1;  /**< Include the skip bytes in the FCS calculation.
                                                          0 = All skip bytes are included in FCS.
                                                          1 = The skip bytes are not included in FCS.
-                                                         When BGX()_GMP_GMI_TX()_CTL[HG_EN] is set, this field must be 0.
-                                                         The skip bytes are part of the packet and are sent down the NCB packet interface and are
+                                                         The skip bytes are part of the packet and are
                                                          handled by PKI. The system can determine if the UDD bytes are included in the FCS check by
                                                          using the FCSSEL field, if the FCS check is enabled. */
 	uint64_t reserved_7_7                 : 1;
@@ -4621,7 +4625,7 @@ union cvmx_bgxx_gmp_gmi_txx_min_pkt {
 	uint64_t min_size                     : 8;  /**< Minimum frame size in bytes before the FCS is applied.
                                                          Padding is only appended when BGX()_GMP_GMI_TX()_APPEND[PAD] for the corresponding
                                                          LMAC is set.
-                                                         In SGMII mode, packets are padded to MIN_SIZE+1. The reset value pads to 60 bytes. */
+                                                         In SGMII mode, packets are padded to [MIN_SIZE]+1. The reset value pads to 60 bytes. */
 #else
 	uint64_t min_size                     : 8;
 	uint64_t reserved_8_63                : 56;
@@ -4670,7 +4674,7 @@ union cvmx_bgxx_gmp_gmi_txx_pause_pkt_time {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t ptime                        : 16; /**< Provides the pause_time field placed in outbound 802.3 PAUSE packets
-                                                         in 512 bit-times. Normally, P_TIME >
+                                                         in 512 bit-times. Normally, [PTIME] >
                                                          BGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL[INTERVAL]. For programming information see
                                                          BGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL. */
 #else
@@ -4791,7 +4795,7 @@ union cvmx_bgxx_gmp_gmi_txx_soft_pause {
 	struct cvmx_bgxx_gmp_gmi_txx_soft_pause_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t ptime                        : 16; /**< Back off the TX bus for (PTIME * 512) bit-times. */
+	uint64_t ptime                        : 16; /**< Back off the TX bus for ([PTIME] * 512) bit-times. */
 #else
 	uint64_t ptime                        : 16;
 	uint64_t reserved_16_63               : 48;
@@ -4815,11 +4819,9 @@ union cvmx_bgxx_gmp_gmi_txx_thresh {
 	uint64_t cnt                          : 11; /**< Number of 128-bit words to accumulate in the TX FIFO before sending on the packet
                                                          interface. This field should be large enough to prevent underflow on the packet interface
                                                          and must never be set to 0x0.
-                                                         10G/40G Mode, CNT = 0x100. In all modes, this register cannot exceed the TX FIFO depth as
-                                                         follows:
-                                                         _ BGX()_CMR_TX_LMACS = 0,1:  CNT maximum = 0x7FF.
-                                                         _ BGX()_CMR_TX_LMACS = 2:    CNT maximum = 0x3FF.
-                                                         _ BGX()_CMR_TX_LMACS = 3,4:  CNT maximum = 0x1FF. */
+                                                         In all modes, this register cannot exceed the TX FIFO depth configured by
+                                                         BGX()_CMR_TX_LMACS[LMACS].
+                                                         Additionally, cannot exceed corresponding PKO_MCI1_MAX_CRED()[MAX_CRED_LIM] - 9. */
 #else
 	uint64_t cnt                          : 11;
 	uint64_t reserved_11_63               : 53;
@@ -5154,7 +5156,8 @@ union cvmx_bgxx_gmp_pcs_intx {
 	struct cvmx_bgxx_gmp_pcs_intx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_13_63               : 51;
-	uint64_t dbg_sync                     : 1;  /**< Code group sync failure debug help. DBG_SYNC interrupt fires when code group
+	uint64_t dbg_sync                     : 1;  /**< Code group sync failure debug help. BGX()_GMP_PCS_INT()[DBG_SYNC] interrupt fires when
+                                                         code group
                                                          synchronization state machine makes a transition from SYNC_ACQUIRED_1 state to
                                                          SYNC_ACQUIRED_2 state. (See IEEE 802.3-2005, figure 37-9). It indicates that a bad code
                                                          group was received after code group synchronization was achieved. This interrupt should be
@@ -5246,13 +5249,13 @@ union cvmx_bgxx_gmp_pcs_miscx_ctl {
                                                          LOOPBCK1 and LOOPBCK2 modes may not be supported simultaneously. */
 	uint64_t mac_phy                      : 1;  /**< MAC/PHY.
                                                          0 = MAC.
-                                                         1 = PHY decides the TX_CONFIG_REG value to be sent during autonegotiation. */
+                                                         1 = PHY decides the tx_Config_Reg value to be sent during autonegotiation. */
 	uint64_t mode                         : 1;  /**< Mode bit.
                                                          _ 0 = SGMII mode is selected and the following note applies.
                                                          The SGMII AN advertisement register (BGX()_GMP_PCS_SGM()_AN_ADV) is sent during
-                                                         Autonegotiation if BGX()_GMP_PCS_MISC()_CTL[MAC_PHY] = 1 (PHY mode). If [MAC_PHY]
-                                                         = 0 (MAC mode), the TX_CONFIG_REG<14> becomes ACK bit and <0> is always 1. All other bits
-                                                         in TX_CONFIG_REG sent are 0. The PHY dictates the autonegotiation results.
+                                                         Autonegotiation if [MAC_PHY] = 1 (PHY mode). If [MAC_PHY]
+                                                         = 0 (MAC mode), the tx_Config_Reg<14> becomes ACK bit and tx_Config_Reg<0> is always 1.
+                                                         All other bits in tx_Config_Reg sent are 0. The PHY dictates the autonegotiation results.
                                                          _ 1 = 1000Base-X mode is selected. Autonegotiation follows IEEE 802.3 clause 37. */
 	uint64_t an_ovrd                      : 1;  /**< Autonegotiation results override:
                                                          0 = Disable.
@@ -5303,7 +5306,7 @@ union cvmx_bgxx_gmp_pcs_mrx_control {
                                                            0 = Normal operation.
                                                            1 = Internal loopback mode.
                                                          The loopback mode returns loopback TX data from GMII TX back to GMII RX interface. The
-                                                         loopback happens in the PCS module. Autonegotiation is disabled even if AN_EN is set
+                                                         loopback happens in the PCS module. Autonegotiation is disabled even if [AN_EN] is set
                                                          during loopback. */
 	uint64_t spdlsb                       : 1;  /**< Least-significant bit of the link-speed field, i.e. SPD<0>. Refer to SPDMSB. */
 	uint64_t an_en                        : 1;  /**< Autonegotiation enable. */
@@ -5311,7 +5314,7 @@ union cvmx_bgxx_gmp_pcs_mrx_control {
                                                          0 = Normal operation.
                                                          1 = Power down (hardware reset). */
 	uint64_t reserved_10_10               : 1;
-	uint64_t rst_an                       : 1;  /**< Reset autonegotiation. When set, if AN_EN = 1 and
+	uint64_t rst_an                       : 1;  /**< Reset autonegotiation. When set, if [AN_EN] = 1 and
                                                          BGX()_GMP_PCS_MR()_STATUS[AN_ABIL] = 1, Autonegotiation begins. Otherwise,
                                                          software write requests are ignored and this bit remains at 0. This bit clears itself to
                                                          0, when autonegotiation starts. */
@@ -5332,7 +5335,8 @@ union cvmx_bgxx_gmp_pcs_mrx_control {
                                                           1          0         1000 Mb/s
                                                           1          1         reserved
                                                          </pre> */
-	uint64_t uni                          : 1;  /**< Unidirectional (Std 802.3-2005, Clause 66.2). When set to 1, this bit overrides AN_EN and
+	uint64_t uni                          : 1;  /**< Unidirectional (Std 802.3-2005, Clause 66.2). When set to 1, this bit overrides [AN_EN]
+                                                         and
                                                          disables the autonegotiation variable mr_an_enable. Used in both 1000BASE-X and SGMII
                                                          modes. */
 	uint64_t reserved_0_4                 : 5;
@@ -5483,11 +5487,11 @@ typedef union cvmx_bgxx_gmp_pcs_rxx_sync cvmx_bgxx_gmp_pcs_rxx_sync_t;
 /**
  * cvmx_bgx#_gmp_pcs_sgm#_an_adv
  *
- * This is the SGMII Autonegotiation advertisement register (sent out as TX_CONFIG_REG). This
- * register is sent during autonegotiation if
+ * This is the SGMII Autonegotiation advertisement register (sent out as tx_Config_Reg<15:0> as
+ * defined in IEEE 802.3 clause 37). This register is sent during autonegotiation if
  * BGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set (1 = PHY mode). If the bit is not set (0 =
- * MAC mode), the TX_CONFIG_REG<14> becomes ACK bit and <0> is always 1. All other bits in
- * TX_CONFIG_REG sent will be 0. The PHY dictates the autonegotiation results.
+ * MAC mode), then tx_Config_Reg<14> becomes ACK bit and tx_Config_Reg<0> is always 1. All other
+ * bits in tx_Config_Reg sent will be 0. The PHY dictates the autonegotiation results.
  */
 union cvmx_bgxx_gmp_pcs_sgmx_an_adv {
 	uint64_t u64;
@@ -5504,7 +5508,7 @@ union cvmx_bgxx_gmp_pcs_sgmx_an_adv {
                                                          0x2 = 1000 Mb/s.
                                                          0x3 = Reserved. */
 	uint64_t reserved_1_9                 : 9;
-	uint64_t one                          : 1;  /**< Always set to match TX_CONFIG_REG<0>. */
+	uint64_t one                          : 1;  /**< Always set to match tx_Config_Reg<0>. */
 #else
 	uint64_t one                          : 1;
 	uint64_t reserved_1_9                 : 9;
@@ -5526,8 +5530,8 @@ typedef union cvmx_bgxx_gmp_pcs_sgmx_an_adv cvmx_bgxx_gmp_pcs_sgmx_an_adv_t;
 /**
  * cvmx_bgx#_gmp_pcs_sgm#_lp_adv
  *
- * This is the SGMII Link partner advertisement register (received as RX_CONFIG_REG).
- *
+ * This is the SGMII Link partner advertisement register (received as rx_Config_Reg<15:0> as
+ * defined in IEEE 802.3 clause 37).
  */
 union cvmx_bgxx_gmp_pcs_sgmx_lp_adv {
 	uint64_t u64;
@@ -5543,7 +5547,7 @@ union cvmx_bgxx_gmp_pcs_sgmx_lp_adv {
                                                          0x2 = 1000 Mb/s.
                                                          0x3 = Reserved. */
 	uint64_t reserved_1_9                 : 9;
-	uint64_t one                          : 1;  /**< Always set to match TX_CONFIG_REG<0> */
+	uint64_t one                          : 1;  /**< Always set to match tx_Config_Reg<0> */
 #else
 	uint64_t one                          : 1;
 	uint64_t reserved_1_9                 : 9;
@@ -5602,7 +5606,7 @@ union cvmx_bgxx_gmp_pcs_tx_rxx_polarity {
 	uint64_t reserved_4_63                : 60;
 	uint64_t rxovrd                       : 1;  /**< RX polarity override.
                                                          0 = AUTORXPL determines polarity.
-                                                         1 = RXPLRT determines polarity. */
+                                                         1 = [RXPLRT] determines polarity. */
 	uint64_t autorxpl                     : 1;  /**< Auto RX polarity detected:
                                                          0 = Normal polarity.
                                                          1 = Inverted polarity.
@@ -5632,19 +5636,17 @@ union cvmx_bgxx_smux_cbfc_ctl {
 	uint64_t u64;
 	struct cvmx_bgxx_smux_cbfc_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t phys_en                      : 16; /**< Physical backpressure enable. Determines which classes/channels will have physical
-                                                         backpressure PAUSE packets. The value placed in the class enable vector field of the
-                                                         PFC/CBFC PAUSE packet is PHYS_EN | LOGL_EN. */
-	uint64_t logl_en                      : 16; /**< Logical backpressure enable. Determines which classes/channels will have logical
-                                                         backpressure PAUSE packets. The value placed in the class enable vector field of the
-                                                         PFC/CBFC PAUSE packet is PHYS_EN | LOGL_EN. */
+	uint64_t phys_en                      : 16; /**< Physical backpressure enable. Determines which classes/channels in the class enable vector
+                                                         field of a transmitted PFC packet can be asserted due to RX physical backpressure. */
+	uint64_t logl_en                      : 16; /**< Logical backpressure enable. Determines which classes/channels in the class enable vector
+                                                         field of a transmitted PFC packet can be asserted due to RX logical backpressure. */
 	uint64_t reserved_4_31                : 28;
-	uint64_t bck_en                       : 1;  /**< Forward PFC/CBFC PAUSE information to the backpressure block. */
-	uint64_t drp_en                       : 1;  /**< Drop-control enable. When set, drop PFC/CBFC PAUSE frames. */
-	uint64_t tx_en                        : 1;  /**< Transmit enable. When set, allow for PFC/CBFC PAUSE packets. Must be clear in HiGig2 mode
+	uint64_t bck_en                       : 1;  /**< Forward PFC information to the backpressure block. */
+	uint64_t drp_en                       : 1;  /**< Drop-control enable. When set, drop PFC frames. */
+	uint64_t tx_en                        : 1;  /**< Transmit enable. When set, allow for PFC packets. Must be clear in HiGig2 mode
                                                          i.e. when BGX()_SMU()_TX_CTL[HG_EN] = 1 and BGX()_SMU()_RX_UDD_SKP[LEN] =
                                                          16. */
-	uint64_t rx_en                        : 1;  /**< Receive enable. When set, allow for PFC/CBFC PAUSE packets. Must be clear in HiGig2 mode
+	uint64_t rx_en                        : 1;  /**< Receive enable. When set, allow for PFC packets. Must be clear in HiGig2 mode
                                                          i.e. when BGX()_SMU()_TX_CTL[HG_EN] = 1 and BGX()_SMU()_RX_UDD_SKP[LEN] =
                                                          16. */
 #else
@@ -5733,9 +5735,9 @@ typedef union cvmx_bgxx_smux_ext_loopback cvmx_bgxx_smux_ext_loopback_t;
  *
  * BGX()_CMR_RX_OVR_BP[EN<0>] must be set and BGX()_CMR_RX_OVR_BP[BP<0>] must be cleared
  * to 0 (to forcibly disable hardware-automatic 802.3 PAUSE packet generation) with the HiGig2
- * Protocol when BGX()_SMU()_HG2_CONTROL[HG2TX_EN] = 0. (The HiGig2 protocol is indicated
+ * Protocol when [HG2TX_EN] = 0. (The HiGig2 protocol is indicated
  * by BGX()_SMU()_TX_CTL[HG_EN] = 1 and BGX()_SMU()_RX_UDD_SKP[LEN]=16.) Hardware
- * can only autogenerate backpressure via HiGig2 messages (optionally, when HG2TX_EN = 1) with
+ * can only autogenerate backpressure via HiGig2 messages (optionally, when [HG2TX_EN] = 1) with
  * the HiGig2 protocol.
  */
 union cvmx_bgxx_smux_hg2_control {
@@ -5744,19 +5746,17 @@ union cvmx_bgxx_smux_hg2_control {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_19_63               : 45;
 	uint64_t hg2tx_en                     : 1;  /**< Enable transmission of HG2 physical and logical messages. When set, also disables hardware
-                                                         autogenerated (802.3 and PFC/CBFC) PAUSE frames. (CNXXXX cannot generate proper 802.3 or
-                                                         PFC/CBFC PAUSE frames in HiGig2 mode.) */
+                                                         autogenerated 802.3 PAUSE and PFC frames. (CNXXXX cannot generate proper 802.3 or
+                                                         PFC frames in HiGig2 mode.) */
 	uint64_t hg2rx_en                     : 1;  /**< Enable extraction and processing of HG2 message packet from RX flow. Physical and logical
                                                          PAUSE information is used to PAUSE physical-link, backpressure PKO. This field must be set
                                                          when HiGig2 messages are present in the receive stream. This bit is also forwarded to CMR
                                                          so it can generate the required deferring signals to SMU TX and backpressure signals to
                                                          PKO. */
-	uint64_t phys_en                      : 1;  /**< Physical-link PAUSE enable for received HiGig2 physical PAUSE message. This bit enables
+	uint64_t phys_en                      : 1;  /**< Physical-link backpressure enable for received physical HiGig2 messages. This bit enables
                                                          the SMU TX to CMR HG2 deferring counter to be set every time SMU RX receives and filters
                                                          out a valid physical HG2 message. */
-	uint64_t logl_en                      : 16; /**< 16-bit XOF enables for received HiGig2 messages or PFC/CBFC packets. This field is NOT
-                                                         used by SMU at all. It is forwarded to CMR without alteration. It appears here for
-                                                         backward compatibility. */
+	uint64_t logl_en                      : 16; /**< 16-bit logical-link backpressure enables for received HiGig2 messages or PFC packets. */
 #else
 	uint64_t logl_en                      : 16;
 	uint64_t phys_en                      : 1;
@@ -5805,7 +5805,7 @@ union cvmx_bgxx_smux_rx_bad_col_lo {
 	uint64_t u64;
 	struct cvmx_bgxx_smux_rx_bad_col_lo_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t lane_rxd                     : 64; /**< When BGX()_SMU()_RX_INT[PCTERR] is set, LANE_RXD contains the XAUI/RXAUI column at
+	uint64_t lane_rxd                     : 64; /**< When BGX()_SMU()_RX_INT[PCTERR] is set, [LANE_RXD] contains the XAUI/RXAUI column at
                                                          the time of the error. */
 #else
 	uint64_t lane_rxd                     : 64;
@@ -5857,7 +5857,7 @@ union cvmx_bgxx_smux_rx_decision {
 	struct cvmx_bgxx_smux_rx_decision_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
-	uint64_t cnt                          : 5;  /**< The byte count to decide when to accept or filter a packet. Refer to SMU Decisions. */
+	uint64_t cnt                          : 5;  /**< The byte count to decide when to accept or filter a packet. */
 #else
 	uint64_t cnt                          : 5;
 	uint64_t reserved_5_63                : 59;
@@ -5910,13 +5910,15 @@ typedef union cvmx_bgxx_smux_rx_frm_chk cvmx_bgxx_smux_rx_frm_chk_t;
  * cvmx_bgx#_smu#_rx_frm_ctl
  *
  * This register controls the handling of the frames.
- * The CTL_BCK/CTL_DRP bits control how the hardware handles incoming PAUSE packets. The most
+ * The [CTL_BCK] and [CTL_DRP] bits control how the hardware handles incoming PAUSE packets. The
+ * most
  * common modes of operation:
- * _ CTL_BCK = 1, CTL_DRP = 1: hardware handles everything
- * _ CTL_BCK = 0, CTL_DRP = 0: software sees all PAUSE frames
- * _ CTL_BCK = 0, CTL_DRP = 1: all PAUSE frames are completely ignored
+ * _ [CTL_BCK] = 1, [CTL_DRP] = 1: hardware handles everything
+ * _ [CTL_BCK] = 0, [CTL_DRP] = 0: software sees all PAUSE frames
+ * _ [CTL_BCK] = 0, [CTL_DRP] = 1: all PAUSE frames are completely ignored
  *
- * These control bits should be set to CTL_BCK = 0, CTL_DRP = 0 in half-duplex mode. Since PAUSE
+ * These control bits should be set to [CTL_BCK] = 0, [CTL_DRP] = 0 in half-duplex mode. Since
+ * PAUSE
  * packets only apply to full duplex operation, any PAUSE packet would constitute an exception
  * which should be handled by the processing cores. PAUSE packets should not be forwarded.
  */
@@ -5925,15 +5927,15 @@ union cvmx_bgxx_smux_rx_frm_ctl {
 	struct cvmx_bgxx_smux_rx_frm_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_13_63               : 51;
-	uint64_t ptp_mode                     : 1;  /**< Timestamp mode. When PTP_MODE is set, a 64-bit timestamp is prepended to every incoming
+	uint64_t ptp_mode                     : 1;  /**< Timestamp mode. When [PTP_MODE] is set, a 64-bit timestamp is prepended to every incoming
                                                          packet.
                                                          The timestamp bytes are added to the packet in such a way as to not modify the packet's
                                                          receive byte count. This implies that the BGX()_SMU()_RX_JABBER,
                                                          BGX()_SMU()_RX_DECISION, and BGX()_SMU()_RX_UDD_SKP do not require any
                                                          adjustment as they operate on the received packet size. When the packet reaches PKI, its
                                                          size reflects the additional bytes and is subject to the following restrictions:
-                                                         If PTP_MODE = 1 and PRE_CHK = 1, PRE_STRP must be 1.
-                                                         If PTP_MODE = 1:
+                                                         If [PTP_MODE] = 1 and [PRE_CHK] = 1, [PRE_STRP] must be 1.
+                                                         If [PTP_MODE] = 1:
                                                          * PKI_CL()_PKIND()_SKIP[FCS_SKIP,INST_SKIP] should be increased by 8.
                                                          * PKI_CL()_PKIND()_CFG[HG_EN] should be 0.
                                                          * PKI_FRM_LEN_CHK()[MAXLEN] should be increased by 8.
@@ -5948,19 +5950,20 @@ union cvmx_bgxx_smux_rx_frm_ctl {
                                                          0 = PREAMBLE + SFD is sent to core as part of frame.
                                                          1 = PREAMBLE + SFD is dropped.
                                                          [PRE_CHK] must be set to enable this and all PREAMBLE features.
-                                                         If PTP_MODE = 1 and PRE_CHK = 1, PRE_STRP must be 1.
-                                                         When PRE_CHK is set (indicating that the PREAMBLE will be sent), PRE_STRP determines if
+                                                         If [PTP_MODE] = 1 and [PRE_CHK] = 1, [PRE_STRP] must be 1.
+                                                         When [PRE_CHK] is set (indicating that the PREAMBLE will be sent), [PRE_STRP] determines
+                                                         if
                                                          the PREAMBLE+SFD bytes are thrown away or sent to the core as part of the packet. In
                                                          either mode, the PREAMBLE+SFD bytes are not counted toward the packet size when checking
                                                          against the MIN and MAX bounds. Furthermore, the bytes are skipped when locating the start
                                                          of the L2 header for DMAC and control frame recognition. */
 	uint64_t pre_chk                      : 1;  /**< Check the preamble for correctness.
                                                          This port is configured to send a valid 802.3 PREAMBLE to begin every frame. BGX checks
-                                                         that a valid PREAMBLE is received (based on PRE_FREE). When a problem does occur within
+                                                         that a valid PREAMBLE is received. When a problem does occur within
                                                          the PREAMBLE sequence, the frame is marked as bad and not sent into the core. The
                                                          BGX()_SMU()_RX_INT[PCTERR] interrupt is also raised.
-                                                         When BGX()_SMU()_TX_CTL[HG_EN] is set, PRE_CHK must be 0.
-                                                         If PTP_MODE = 1 and PRE_CHK = 1, PRE_STRP must be 1. */
+                                                         When BGX()_SMU()_TX_CTL[HG_EN] is set, [PRE_CHK] must be 0.
+                                                         If [PTP_MODE] = 1 and [PRE_CHK] = 1, [PRE_STRP] must be 1. */
 #else
 	uint64_t pre_chk                      : 1;
 	uint64_t pre_strp                     : 1;
@@ -6057,7 +6060,7 @@ union cvmx_bgxx_smux_rx_jabber {
 	uint64_t reserved_16_63               : 48;
 	uint64_t cnt                          : 16; /**< Byte count for jabber check. Failing packets set the JABBER interrupt and are optionally
                                                          sent with opcode = JABBER. BGX truncates the packet to CNT+1 to CNT+8 bytes.
-                                                         CNT must be 8-byte aligned such that CNT[2:0] = 000. */
+                                                         CNT must be 8-byte aligned such that CNT<2:0> = 000. */
 #else
 	uint64_t cnt                          : 16;
 	uint64_t reserved_16_63               : 48;
@@ -6142,7 +6145,7 @@ union cvmx_bgxx_smux_tx_append {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
 	uint64_t fcs_c                        : 1;  /**< Append the Ethernet FCS on each PAUSE packet. PAUSE packets are normally padded to 60
-                                                         bytes. If BGX()_SMU()_TX_MIN_PKT[MIN_SIZE] exceeds 59, then FCS_C is not used. */
+                                                         bytes. If BGX()_SMU()_TX_MIN_PKT[MIN_SIZE] exceeds 59, then [FCS_C] is not used. */
 	uint64_t fcs_d                        : 1;  /**< Append the Ethernet FCS on each data packet. */
 	uint64_t pad                          : 1;  /**< Append PAD bytes such that minimum-sized packet is transmitted. */
 	uint64_t preamble                     : 1;  /**< Prepend the Ethernet preamble on each transfer. When BGX()_SMU()_TX_CTL[HG_EN] is
@@ -6270,7 +6273,7 @@ union cvmx_bgxx_smux_tx_int {
 	uint64_t lb_ovrflw                    : 1;  /**< TX loopback overflow. */
 	uint64_t lb_undflw                    : 1;  /**< TX loopback underflow. */
 	uint64_t fake_commit                  : 1;  /**< TX SMU started a packet with PTP on SOP and has not seen a commit for it from TX SPU after
-                                                         2^SMU_TX_PTP_TIMEOUT_WIDTH (2^8) cycles so it faked a commit to CMR. */
+                                                         256 cycles so it faked a commit to CMR. */
 	uint64_t xchange                      : 1;  /**< Link status changed. This denotes a change to BGX()_SMU()_RX_CTL[STATUS]. */
 	uint64_t undflw                       : 1;  /**< TX underflow. */
 #else
@@ -6349,12 +6352,12 @@ union cvmx_bgxx_smux_tx_pause_pkt_interval {
 	uint64_t reserved_33_63               : 31;
 	uint64_t hg2_intra_en                 : 1;  /**< Allow intrapacket HiGig2 message generation. Relevant only if HiGig2 message generation is enabled. */
 	uint64_t hg2_intra_interval           : 16; /**< Arbitrate for a HiGig2 message, every (INTERVAL*512) bit-times whilst sending regular
-                                                         packet data. Relevant only if HiGig2 message generation and HG2_INTRA_EN are both set.
+                                                         packet data. Relevant only if HiGig2 message generation and [HG2_INTRA_EN] are both set.
                                                          Normally, 0 < INTERVAL < BGX()_SMU()_TX_PAUSE_PKT_TIME.
                                                          INTERVAL = 0 only sends a single PAUSE packet for each backpressure event. */
-	uint64_t interval                     : 16; /**< Arbitrate for a 802.3 PAUSE packet, HiGig2 message, or PFC/CBFC PAUSE packet every
+	uint64_t interval                     : 16; /**< Arbitrate for a 802.3 PAUSE packet, HiGig2 message, or PFC packet every
                                                          (INTERVAL * 512) bit-times.
-                                                         Normally, 0 < INTERVAL < BGX()_SMU()_TX_PAUSE_PKT_TIME[PTIME].
+                                                         Normally, 0 < INTERVAL < BGX()_SMU()_TX_PAUSE_PKT_TIME[P_TIME].
                                                          INTERVAL = 0 only sends a single PAUSE packet for each backpressure event. */
 #else
 	uint64_t interval                     : 16;
@@ -6379,7 +6382,7 @@ union cvmx_bgxx_smux_tx_pause_pkt_time {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t p_time                       : 16; /**< Provides the pause_time field placed in outbound 802.3 PAUSE packets, HiGig2 messages, or
-                                                         PFC/CBFC PAUSE packets in 512 bit-times. Normally, P_TIME >
+                                                         PFC packets in 512 bit-times. Normally, [P_TIME] >
                                                          BGX()_SMU()_TX_PAUSE_PKT_INTERVAL[INTERVAL]. See programming notes in
                                                          BGX()_SMU()_TX_PAUSE_PKT_INTERVAL. */
 #else
@@ -6472,7 +6475,7 @@ union cvmx_bgxx_smux_tx_soft_pause {
 	struct cvmx_bgxx_smux_tx_soft_pause_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t p_time                       : 16; /**< Back off the TX bus for (P_TIME * 512) bit-times */
+	uint64_t p_time                       : 16; /**< Back off the TX bus for ([P_TIME] * 512) bit-times */
 #else
 	uint64_t p_time                       : 16;
 	uint64_t reserved_16_63               : 48;
@@ -6497,10 +6500,8 @@ union cvmx_bgxx_smux_tx_thresh {
                                                          interface. This field should be large enough to prevent underflow on the packet interface
                                                          and must never be set to 0x0.
                                                          In 10G/40G mode, CNT = 0x100.
-                                                         In all modes, cannot exceed the TX FIFO depth as follows.
-                                                         _ BGX()_CMR_TX_PRTS = 0,1:  CNT maximum = 0x7FF.
-                                                         _ BGX()_CMR_TX_PRTS = 2:    CNT maximum = 0x3FF.
-                                                         _ BGX()_CMR_TX_PRTS = 3,4:  CNT maximum = 0x1FF.
+                                                         In all modes, this register cannot exceed the TX FIFO depth configured by
+                                                         BGX()_CMR_TX_LMACS[LMACS].
                                                          Additionally, cannot exceed corresponding PKO_MCI1_MAX_CRED()[MAX_CRED_LIM] - 9. */
 #else
 	uint64_t cnt                          : 11;
@@ -6583,11 +6584,12 @@ typedef union cvmx_bgxx_spux_an_adv cvmx_bgxx_spux_an_adv_t;
 /**
  * cvmx_bgx#_spu#_an_bp_status
  *
- * The contents of this register (with the exception of the static BP_AN_ABLE bit) are updated
+ * The contents of this register are updated
  * during autonegotiation and are valid when BGX()_SPU()_AN_STATUS[AN_COMPLETE] is set.
- * At that time, one of the port type bits (A100G_CR10, A40G_CR4, A40G_KR4, A10G_KR, A10G_KX4,
- * A1G_KX) will be set depending on the AN priority resolution. If a BASE-R type is negotiated,
- * then the FEC bit will be set to indicate that FEC operation has been negotiated, and will be
+ * At that time, one of the port type bits ([N100G_CR10], [N40G_CR4], [N40G_KR4], [N10G_KR],
+ * [N10G_KX4],
+ * [N1G_KX]) will be set depending on the AN priority resolution. If a BASE-R type is negotiated,
+ * then [FEC] will be set to indicate that FEC operation has been negotiated, and will be
  * clear otherwise.
  */
 union cvmx_bgxx_spux_an_bp_status {
@@ -6646,7 +6648,7 @@ union cvmx_bgxx_spux_an_control {
                                                          in RXAUI mode. */
 	uint64_t reserved_10_11               : 2;
 	uint64_t an_restart                   : 1;  /**< Autonegotiation restart. Writing a 1 to this bit restarts the autonegotiation process if
-                                                         AN_EN is also set. This is a self-clearing bit. */
+                                                         [AN_EN] is also set. This is a self-clearing bit. */
 	uint64_t reserved_0_8                 : 9;
 #else
 	uint64_t reserved_0_8                 : 9;
@@ -6873,7 +6875,7 @@ typedef union cvmx_bgxx_spux_an_xnp_tx cvmx_bgxx_spux_an_xnp_tx_t;
  * (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x4), and always returns 0x0 for all other LPCS
  * types. Std 802.3 bits that are not applicable to 40GBASE-R (e.g. status bits for PCS lanes
  * 19-4) are not implemented and marked as reserved. PCS lanes 3-0 are valid and are mapped to
- * physical SerDes lanes based on the programming of BGX()_CMR()_CONFIG[[LANE_TO_SDS].
+ * physical SerDes lanes based on the programming of BGX()_CMR()_CONFIG[LANE_TO_SDS].
  */
 union cvmx_bgxx_spux_br_algn_status {
 	uint64_t u64;
@@ -7002,8 +7004,8 @@ union cvmx_bgxx_spux_br_pmd_control {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t train_en                     : 1;  /**< BASE-R training enable */
-	uint64_t train_restart                : 1;  /**< BASE-R training restart. Writing a 1 to this bit restarts the training process if the
-                                                         TRAIN_EN bit in this register is also set. This is a self-clearing bit. Software should
+	uint64_t train_restart                : 1;  /**< BASE-R training restart. Writing a 1 to this bit restarts the training process if
+                                                         [TRAIN_EN] is also set. This is a self-clearing bit. Software should
                                                          wait a minimum of 1.7ms after BGX()_SPU()_INT[TRAINING_FAILURE] is set before
                                                          restarting the training process. */
 #else
@@ -7025,7 +7027,8 @@ typedef union cvmx_bgxx_spux_br_pmd_control cvmx_bgxx_spux_br_pmd_control_t;
  * This register implements 802.3 MDIO register 1.153 for 10GBASE-R (when
  * BGX()_CMR()_CONFIG[LMAC_TYPE] = 10G_R)
  * and MDIO registers 1.1300-1.1303 for 40GBASE-R (when
- * LMAC_TYPE = 40G_R). It is automatically cleared at the start of training. When link training
+ * BGX()_CMR()_CONFIG[LMAC_TYPE] = 40G_R). It is automatically cleared at the start of training.
+ * When link training
  * is in progress, each field reflects the contents of the coefficient update field in the
  * associated lane's outgoing training frame. The fields in this register are read/write even
  * though they are specified as read-only in 802.3.
@@ -7069,8 +7072,9 @@ typedef union cvmx_bgxx_spux_br_pmd_ld_cup cvmx_bgxx_spux_br_pmd_ld_cup_t;
  * cvmx_bgx#_spu#_br_pmd_ld_rep
  *
  * This register implements 802.3 MDIO register 1.154 for 10GBASE-R (when
- * BGX()_CMR()_CONFIG[LMAC_TYPE] = IOG_R) and MDIO registers 1.1400-1.1403 for 40GBASE-R
- * (when LMAC_TYPE = 40G_R). It is automatically cleared at the start of training. Each field
+ * BGX()_CMR()_CONFIG[LMAC_TYPE] = 10G_R) and MDIO registers 1.1400-1.1403 for 40GBASE-R
+ * (when BGX()_CMR()_CONFIG[LMAC_TYPE] = 40G_R). It is automatically cleared at the start of
+ * training. Each field
  * reflects the contents of the status report field in the associated lane's outgoing training
  * frame. The fields in this register are read/write even though they are specified as read-only
  * in 802.3. If BGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register must
@@ -7114,10 +7118,12 @@ typedef union cvmx_bgxx_spux_br_pmd_ld_rep cvmx_bgxx_spux_br_pmd_ld_rep_t;
  * This register implements 802.3 MDIO register 1.152 for 10GBASE-R (when
  * BGX()_CMR()_CONFIG[LMAC_TYPE] = 10G_R)
  * and MDIO registers 1.1100-1.1103 for 40GBASE-R (when
- * LMAC_TYPE = 40G_R). It is automatically cleared at the start of training. Each field reflects
+ * BGX()_CMR()_CONFIG[LMAC_TYPE] = 40G_R). It is automatically cleared at the start of training.
+ * Each field reflects
  * the contents of the coefficient update field in the lane's most recently received training
- * frame. This register should not be written when link training is enabled, i.e. when TRAIN_EN
- * is set BR_PMD_CONTROL. The lane fields in this register are indexed by logical PCS lane ID.
+ * frame. This register should not be written when link training is enabled, i.e. when
+ * BGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set. The lane fields in this register are indexed by
+ * logical PCS lane ID.
  *
  * The lane 0 field (LN0_*) is valid for both 10GBASE-R and 40GBASE-R. The remaining fields
  * (LN1_*, LN2_*, LN3_*) are only valid for 40GBASE-R.
@@ -7153,7 +7159,8 @@ typedef union cvmx_bgxx_spux_br_pmd_lp_cup cvmx_bgxx_spux_br_pmd_lp_cup_t;
  * This register implements 802.3 MDIO register 1.153 for 10GBASE-R (when
  * BGX()_CMR()_CONFIG[LMAC_TYPE] = 10G_R)
  * and MDIO registers 1.1200-1.1203 for 40GBASE-R (when
- * LMAC_TYPE = 40G_R). It is automatically cleared at the start of training. Each field reflects
+ * BGX()_CMR()_CONFIG[LMAC_TYPE] = 40G_R). It is automatically cleared at the start of training.
+ * Each field reflects
  * the contents of the status report field in the associated lane's most recently received
  * training frame. The lane fields in this register are indexed by logical PCS lane ID.
  *
@@ -7276,9 +7283,9 @@ typedef union cvmx_bgxx_spux_br_status1 cvmx_bgxx_spux_br_status1_t;
  *
  * Note that the relative locations of some fields have been moved from Std 802.3 in order to
  * make the register layout more software friendly: the BER counter high-order and low-order bits
- * from sections 3.44 and 3.33 have been combined into the contiguous, 22-bit BER_CNT field;
+ * from sections 3.44 and 3.33 have been combined into the contiguous, 22-bit [BER_CNT] field;
  * likewise, the errored-blocks counter high-order and low-order bits from section 3.45 have been
- * combined into the contiguous, 22-bit ERR_BLKS field.
+ * combined into the contiguous, 22-bit [ERR_BLKS] field.
  */
 union cvmx_bgxx_spux_br_status2 {
 	uint64_t u64;
@@ -7348,7 +7355,7 @@ union cvmx_bgxx_spux_br_tp_control {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
 	uint64_t scramble_tp                  : 1;  /**< Select scrambled idle test pattern. This bit selects the transmit test pattern used when
-                                                         TX_TP_EN is set:
+                                                         [TX_TP_EN] is set:
                                                          0 = Square wave test pattern.
                                                          1 = Scrambled idle test pattern. */
 	uint64_t prbs9_tx                     : 1;  /**< 10GBASE-R PRBS9 TP transmit enable. Always 0; PRBS9 pattern testing is not supported. */
@@ -7518,7 +7525,7 @@ union cvmx_bgxx_spux_control2 {
                                                          BGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                          follows:
                                                          <pre>
-                                                                       PCS_TYPE
+                                                                       [PCS_TYPE]
                                                            LMAC_TYPE   Read Value      Comment
                                                            -------------------------------------------------
                                                            XAUI        0x1             10GBASE-X PCS type
@@ -7573,8 +7580,8 @@ union cvmx_bgxx_spux_fec_control {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t err_en                       : 1;  /**< BASE-R FEC error-indication enable. This bit corresponds to FEC_Enable_Error_to_PCS
-                                                         variable for BASE-R as defined in 802.3 Clause 74. When FEC is enabled (per FEC_EN bit in
-                                                         this register) and this bit is set, the FEC decoder on the receive side signals an
+                                                         variable for BASE-R as defined in 802.3 Clause 74. When FEC is enabled ([FEC_EN] is set)
+                                                         and this bit is set, the FEC decoder on the receive side signals an
                                                          uncorrectable FEC error to the BASE-R decoder by driving a value of 2'b11 on the sync bits
                                                          for some of the 32 64B/66B blocks belonging to the uncorrectable FEC block. See
                                                          802.3-2008/802.3ba-2010 section 74.7.4.5.1 for more details. */
@@ -7784,7 +7791,7 @@ union cvmx_bgxx_spux_int {
                                                          * XAUI or RXAUI: Set when any lane's PCS synchronization state transitions from
                                                          SYNC_ACQUIRED_1 to SYNC_ACQUIRED_2 (see 802.3-2008 Figure 48-7).
                                                          * 10GBASE-R or 40GBASE-R with FEC disabled: Set when sh_invalid_cnt increments to 1 while
-                                                         block_lock is 1 (see 802.3-2008 Figure 49-12 and 802.3ba-2010 Figure 82-20).
+                                                         BLOCK_LOCK is 1 (see 802.3-2008 Figure 49-12 and 802.3ba-2010 Figure 82-20).
                                                          * 10GBASE-R or 40GBASE-R with FEC enabled: Set when parity_invalid_cnt increments to 1
                                                          while fec_block_lock is 1 (see 802.3-2008 Figure 74-8). */
 	uint64_t algnlos                      : 1;  /**< Loss of lane alignment. Set when lane-to-lane alignment is lost. This is only valid if the
@@ -7796,7 +7803,7 @@ union cvmx_bgxx_spux_int {
                                                          BGX()_SPU()_FEC_CONTROL[FEC_EN]:
                                                          * XAUI or RXAUI: Set when any lane's PCS synchronization state transitions to LOSS_OF_SYNC
                                                          (see 802.3-2008 Figure 48-7)
-                                                         * 10GBASE-R or 40GBASE-R with FEC disabled: set when the block_lock variable is cleared on
+                                                         * 10GBASE-R or 40GBASE-R with FEC disabled: set when the BLOCK_LOCK variable is cleared on
                                                          the 10G lane or any 40G lane (see 802.3-2008 Figure 49-12 and 802.3ba-2010 Figure 82-20).
                                                          * 10GBASE-R or 40GBASE-R with FEC enabled: set when the fec_block_lock variable is cleared
                                                          on the 10G lane or any 40G lane (see 802.3-2008 Figure 74-8). */
@@ -7868,10 +7875,11 @@ typedef union cvmx_bgxx_spux_lpcs_states cvmx_bgxx_spux_lpcs_states_t;
 /**
  * cvmx_bgx#_spu#_misc_control
  *
- * "* RX logical PCS lane polarity vector [3:0] = XOR_RXPLRT[3:0] ^ [4[RXPLRT]].
- *  * TX logical PCS lane polarity vector [3:0] = XOR_TXPLRT[3:0] ^ [4[TXPLRT]].
+ * "* RX logical PCS lane polarity vector <3:0> = [XOR_RXPLRT]<3:0> ^ [4[[RXPLRT]]].
+ *  * TX logical PCS lane polarity vector <3:0> = [XOR_TXPLRT]<3:0> ^ [4[[TXPLRT]]].
  *
- *  In short, keep RXPLRT and TXPLRT cleared, and use XOR_RXPLRT and XOR_TXPLRT fields to define
+ *  In short, keep [RXPLRT] and [TXPLRT] cleared, and use [XOR_RXPLRT] and [XOR_TXPLRT] fields to
+ *  define
  *  the polarity per logical PCS lane. Only bit 0 of vector is used for 10GBASE-R, and only bits
  * - 1:0 of vector are used for RXAUI."
  */
@@ -8054,7 +8062,7 @@ typedef union cvmx_bgxx_spux_status2 cvmx_bgxx_spux_status2_t;
 /**
  * cvmx_bgx#_spu_bist_status
  *
- * This register provides memory BIST status from the SPU RX_BUF lane FIFOs.
+ * This register provides memory BIST status from the SPU receive buffer lane FIFOs.
  *
  */
 union cvmx_bgxx_spu_bist_status {
@@ -8062,8 +8070,9 @@ union cvmx_bgxx_spu_bist_status {
 	struct cvmx_bgxx_spu_bist_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t rx_buf_bist_status           : 4;  /**< SPU RX_BUF BIST status for lanes 3-0. One bit per SerDes lane, set to indicate BIST
-                                                         failure for the associated RX_BUF lane FIFO. */
+	uint64_t rx_buf_bist_status           : 4;  /**< SPU receive buffer BIST status for lanes 3-0. One bit per SerDes lane, set to indicate
+                                                         BIST
+                                                         failure for the associated receive buffer lane FIFO. */
 #else
 	uint64_t rx_buf_bist_status           : 4;
 	uint64_t reserved_4_63                : 60;
@@ -8112,22 +8121,29 @@ union cvmx_bgxx_spu_dbg_control {
                                                          the link partner.
                                                          SPU captures the timestamp of the alignment marker received on each SerDes lane during
                                                          align/skew detection; the captured value can be read from the SerDes lane's
-                                                         BGX()_SPU_SDS()_SKEW_STATUS[SKEW_STATUS] field (AM_TIMESTAMP sub-field). If
+                                                         BGX()_SPU_SDS()_SKEW_STATUS[SKEW_STATUS] field (BGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP]
+                                                         sub-field). If
                                                          alignment markers are transmitted at about the same time on all lanes by the link partner,
-                                                         then the difference between the AM_TIMESTAMP values for a pair of lanes represents the
+                                                         then the difference between the BGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] values for a pair
+                                                         of lanes represents the
                                                          approximate skew between those lanes.
                                                          SPU uses the 40GBASE-R LMAC's programmed PCS lane 0 as a reference and computes the
-                                                         AM_TIMESTAMP delta of every other lane relative to PCS lane 0. When normalization is
+                                                         BGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] delta of every other lane relative to PCS lane 0.
+                                                         When normalization is
                                                          enabled, SPU adjusts the timestamp of a received SOP by subtracting the receiving lane's
-                                                         AM_TIMESTAMP delta from the captured timestamp value. The adjusted/normalized timestamp
+                                                         BGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] delta from the captured timestamp value. The
+                                                         adjusted/normalized timestamp
                                                          value is then passed to SMU along with the SOP.
                                                          Software can determine the actual maximum skew of a 40GBASE-R link by examining the
-                                                         AM_TIMESTAMP values in the BGX()_SPU_SDS()_SKEW_STATUS registers, and decide if
+                                                         BGX_SPU_SDS_SKEW_STATUS_S[AM_TIMESTAMP] values in the BGX()_SPU_SDS()_SKEW_STATUS
+                                                         registers, and decide if
                                                          timestamp normalization should be enabled or disabled to improve PTP accuracy.
                                                          Normalization improves accuracy for larger skew values but reduces the accuracy (due to
                                                          timestamp measurement errors) for small skew values. */
-	uint64_t rx_buf_flip_synd             : 8;  /**< Flip SPU RX_BUF FIFO ECC bits. Two bits per SerDes lane; used to inject single-bit and
-                                                         double-bit errors into the ECC field on writes to the associated SPU RX_BUF lane FIFO, as
+	uint64_t rx_buf_flip_synd             : 8;  /**< Flip SPU receive buffer FIFO ECC bits. Two bits per SerDes lane; used to inject single-bit
+                                                         and
+                                                         double-bit errors into the ECC field on writes to the associated SPU receive buffer lane
+                                                         FIFO, as
                                                          follows:
                                                          0x0 = Normal operation.
                                                          0x1 = SBE on ECC bit 0.
@@ -8152,17 +8168,19 @@ union cvmx_bgxx_spu_dbg_control {
                                                          performs the actions defined for the AN GOOD CHECK state in Figure 73-11, i.e. run the
                                                          link_fail_inhibit timer and eventually transition to the AN GOOD or TRANSMIT DISABLE
                                                          state.
-                                                         When this bit is clear or the HCD technology does not match LMAC_TYPE, the AN arbitration
+                                                         When this bit is clear or the HCD technology does not match BGX()_CMR()_CONFIG[LMAC_TYPE],
+                                                         the AN arbitration
                                                          SM stays in the AN GOOD CHECK state, with the expectation that software will perform the
                                                          appropriate actions to complete the autonegotiation protocol, as follows:
-                                                         * If this bit is clear and the HCD technology matches LMAC_TYPE, clear AN_EN in
-                                                         AN_CONTROL.
+                                                         * If this bit is clear and the HCD technology matches BGX()_CMR()_CONFIG[LMAC_TYPE], clear
+                                                         BGX()_SPU()_AN_CONTROL[AN_EN].
                                                          * Otherwise, disable the LPCS by clearing the BGX()_CMR()_CONFIG[ENABLE], clear
-                                                         BGX()_SPU()_AN_CONTROL[AN_EN], reconfigure the LPCS with the correct LMAC_TYPE,
+                                                         BGX()_SPU()_AN_CONTROL[AN_EN], reconfigure the LPCS with the correct
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE],
                                                          and re-enable the LPCS by setting BGX()_CMR()_CONFIG[ENABLE].
                                                          In both cases, software should implement the link_fail_inhibit timer and verify the link
                                                          status as specified for the AN GOOD CHECK state. */
-	uint64_t rx_buf_cor_dis               : 1;  /**< When set, disables ECC correction on all SPU RX_BUF FIFOs. */
+	uint64_t rx_buf_cor_dis               : 1;  /**< When set, disables ECC correction on all SPU receive buffer FIFOs. */
 	uint64_t scramble_dis                 : 1;  /**< BASE-R scrambler/descrambler disable. Setting this bit to 1 disables the BASE-R scrambler
                                                          & descrambler functions and FEC PN-2112 scrambler & descrambler functions for debug
                                                          purposes. */
@@ -8204,10 +8222,10 @@ union cvmx_bgxx_spu_mem_int {
 	struct cvmx_bgxx_spu_mem_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t rx_buf_sbe                   : 4;  /**< SPU RX_BUF single-bit error for lanes 3-0. One bit per physical SerDes lane. Each bit is
-                                                         set when the associated RX_BUF lane FIFO detects a single-bit ECC error. */
-	uint64_t rx_buf_dbe                   : 4;  /**< SPU RX_BUF double-bit error for lanes 3-0. One bit per physical SerDes lane. Each bit is
-                                                         set when the associated RX_BUF lane FIFO detects a double-bit ECC error. */
+	uint64_t rx_buf_sbe                   : 4;  /**< SPU receive buffer single-bit error for lanes 3-0. One bit per physical SerDes lane. Each
+                                                         bit is set when the associated receive buffer lane FIFO detects a single-bit ECC error. */
+	uint64_t rx_buf_dbe                   : 4;  /**< SPU receive buffer double-bit error for lanes 3-0. One bit per physical SerDes lane. Each
+                                                         bit is set when the associated receive buffer lane FIFO detects a double-bit ECC error. */
 #else
 	uint64_t rx_buf_dbe                   : 4;
 	uint64_t rx_buf_sbe                   : 4;
@@ -8224,7 +8242,7 @@ typedef union cvmx_bgxx_spu_mem_int cvmx_bgxx_spu_mem_int_t;
 /**
  * cvmx_bgx#_spu_mem_status
  *
- * This register provides memory ECC status from the SPU RX_BUF lane FIFOs.
+ * This register provides memory ECC status from the SPU receive buffer lane FIFOs.
  *
  */
 union cvmx_bgxx_spu_mem_status {
@@ -8232,10 +8250,12 @@ union cvmx_bgxx_spu_mem_status {
 	struct cvmx_bgxx_spu_mem_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t rx_buf_ecc_synd              : 32; /**< SPU RX_BUF ECC syndromes for lanes 3-0. 8-bit syndrome sub-field per SerDes lane. Each
+	uint64_t rx_buf_ecc_synd              : 32; /**< SPU receive buffer ECC syndromes for lanes 3-0. 8-bit syndrome sub-field per SerDes lane.
+                                                         Each
                                                          8-bit sub-field contains the syndrome of the latest single-bit or double-bit ECC error
-                                                         detected by the associated RX_BUF lane FIFO, i.e. it is loaded when the corresponding
-                                                         RX_BUF_SBE or RX_BUF_DBE bit is set in the SPU MEM_INT register. */
+                                                         detected by the associated receive buffer lane FIFO, i.e. it is loaded when the
+                                                         corresponding
+                                                         BGX()_SPU_MEM_INT[RX_BUF_SBE] or BGX()_SPU_MEM_INT[RX_BUF_DBE] bit is set. */
 #else
 	uint64_t rx_buf_ecc_synd              : 32;
 	uint64_t reserved_32_63               : 32;
diff --git a/arch/mips/include/asm/octeon/cvmx-bootmem.h b/arch/mips/include/asm/octeon/cvmx-bootmem.h
index 7a748e0..731d828 100644
--- a/arch/mips/include/asm/octeon/cvmx-bootmem.h
+++ b/arch/mips/include/asm/octeon/cvmx-bootmem.h
@@ -126,6 +126,7 @@ typedef struct cvmx_bootmem_named_block_desc cvmx_bootmem_named_block_desc_t;
 */
 typedef struct {
 	/* Linux compatible proxy for __BIG_ENDIAN */
+#if defined(__BIG_ENDIAN_BITFIELD) || defined(CVMX_BUILD_FOR_LINUX_HOST)
 	uint32_t lock;
 			    /**< spinlock to control access to list */
 	uint32_t flags;
@@ -145,6 +146,20 @@ typedef struct {
 					 /**< length of name array in bootmem blocks */
 	uint64_t named_block_array_addr;
 					 /**< address of named memory block descriptors */
+#else				/* __LITTLE ENDIAN */
+	uint32_t flags;
+	uint32_t lock;
+	uint64_t head_addr;
+
+	uint32_t minor_version;
+	uint32_t major_version;
+	uint64_t app_data_addr;
+	uint64_t app_data_size;
+
+	uint32_t named_block_name_len;
+	uint32_t named_block_num_blocks;
+	uint64_t named_block_array_addr;
+#endif
 } cvmx_bootmem_desc_t;
 
 /**
diff --git a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
index 70ad363..6bca3cb 100644
--- a/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dpi-defs.h
@@ -2799,7 +2799,7 @@ typedef union cvmx_dpi_req_gbl_en cvmx_dpi_req_gbl_en_t;
  * cvmx_dpi_sli_prt#_cfg
  *
  * This register configures the max read request size, max payload size, and max number of SLI
- * tags in use.
+ * tags in use. Indexed by SLI_PORT_E.
  */
 union cvmx_dpi_sli_prtx_cfg {
 	uint64_t u64;
@@ -3261,7 +3261,7 @@ typedef union cvmx_dpi_sli_prtx_cfg cvmx_dpi_sli_prtx_cfg_t;
  * cvmx_dpi_sli_prt#_err
  *
  * This register logs the address associated with the reported SLI error response.
- *
+ * Indexed by SLI_PORT_E.
  */
 union cvmx_dpi_sli_prtx_err {
 	uint64_t u64;
@@ -3296,7 +3296,7 @@ typedef union cvmx_dpi_sli_prtx_err cvmx_dpi_sli_prtx_err_t;
  * cvmx_dpi_sli_prt#_err_info
  *
  * This register logs information associated with the reported SLI error response.
- *
+ * Indexed by SLI_PORT_E.
  */
 union cvmx_dpi_sli_prtx_err_info {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
index e05569c..0283840 100644
--- a/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-fpa-defs.h
@@ -3488,7 +3488,7 @@ union cvmx_fpa_poolx_fpf_marks {
                                                          It is recommended that software APIs represent this value as a percentage of fpf_sz, as
                                                          fpf_sz may vary between products. */
 	uint64_t reserved_11_15               : 5;
-	uint64_t fpf_level                    : 11; /**< The current number of free-page pointers in the pool, in entries. For diagnostic use. */
+	uint64_t fpf_level                    : 11; /**< Reserved. */
 #else
 	uint64_t fpf_level                    : 11;
 	uint64_t reserved_11_15               : 5;
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index 32a21be..f090c89 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -1073,6 +1073,66 @@ static inline uint64_t CVMX_GSERX_LANEX_RX_MISC_OVRRD(unsigned long offset, unsi
 #define CVMX_GSERX_LANEX_RX_MISC_OVRRD(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440258ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_OS_MVALBBD_1(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_OS_MVALBBD_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440230ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_OS_MVALBBD_1(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440230ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_OS_MVALBBD_2(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_OS_MVALBBD_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x0001180090440238ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_OS_MVALBBD_2(offset, block_id) (CVMX_ADD_IO_SEG(0x0001180090440238ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_OS_OUT_1(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_OS_OUT_1(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904402A0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_OS_OUT_1(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904402A0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_OS_OUT_2(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_OS_OUT_2(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904402A8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_OS_OUT_2(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904402A8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_RX_OS_OUT_3(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN73XX) && (((offset <= 3)) && ((block_id <= 6)))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CNF75XX) && (((offset <= 3)) && ((block_id <= 8))))))
+		cvmx_warn("CVMX_GSERX_LANEX_RX_OS_OUT_3(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904402B0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_RX_OS_OUT_3(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904402B0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_RX_PRECORR_CTRL(unsigned long offset, unsigned long block_id)
 {
 	if (!(
@@ -5732,6 +5792,136 @@ union cvmx_gserx_lanex_rx_misc_ovrrd {
 typedef union cvmx_gserx_lanex_rx_misc_ovrrd cvmx_gserx_lanex_rx_misc_ovrrd_t;
 
 /**
+ * cvmx_gser#_lane#_rx_os_mvalbbd_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_os_mvalbbd_1 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_os_mvalbbd_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t pcs_sds_rx_os_mval           : 16; /**< Offset calibration override value when GSER()_LANE()_RX_CFG_1[PCS_SDS_RX_OS_MEN] is set.
+                                                         Requires SIGN-MAG format.
+                                                         <15:14> = Not used.
+                                                         <13:8> = Qerr0.
+                                                         <7:2> = I.
+                                                         <3:0> = Ib. */
+#else
+	uint64_t pcs_sds_rx_os_mval           : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_os_mvalbbd_1_s cn73xx;
+	struct cvmx_gserx_lanex_rx_os_mvalbbd_1_s cnf75xx;
+};
+typedef union cvmx_gserx_lanex_rx_os_mvalbbd_1 cvmx_gserx_lanex_rx_os_mvalbbd_1_t;
+
+/**
+ * cvmx_gser#_lane#_rx_os_mvalbbd_2
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_os_mvalbbd_2 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_os_mvalbbd_2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t pcs_sds_rx_os_mval           : 16; /**< Offset calibration override value when GSER()_LANE()_RX_CFG_1[PCS_SDS_RX_OS_MEN] is set.
+                                                         Requires SIGN-MAG format.
+                                                         <15:12> = Ib.
+                                                         <11:6> = Q.
+                                                         <5:0> = Qb. */
+#else
+	uint64_t pcs_sds_rx_os_mval           : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_os_mvalbbd_2_s cn73xx;
+	struct cvmx_gserx_lanex_rx_os_mvalbbd_2_s cnf75xx;
+};
+typedef union cvmx_gserx_lanex_rx_os_mvalbbd_2 cvmx_gserx_lanex_rx_os_mvalbbd_2_t;
+
+/**
+ * cvmx_gser#_lane#_rx_os_out_1
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_os_out_1 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_os_out_1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t sds_pcs_rx_os_out            : 12; /**< Offset calibration code for readout, 2's complement.
+                                                         <11:6> = Not used.
+                                                         <5:0> = Qerr0. */
+#else
+	uint64_t sds_pcs_rx_os_out            : 12;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_os_out_1_s cn73xx;
+	struct cvmx_gserx_lanex_rx_os_out_1_s cnf75xx;
+};
+typedef union cvmx_gserx_lanex_rx_os_out_1 cvmx_gserx_lanex_rx_os_out_1_t;
+
+/**
+ * cvmx_gser#_lane#_rx_os_out_2
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_os_out_2 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_os_out_2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t sds_pcs_rx_os_out            : 12; /**< Offset calibration code for readout, 2's complement.
+                                                         <11:6> = I.
+                                                         <5:0> = Ib. */
+#else
+	uint64_t sds_pcs_rx_os_out            : 12;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_os_out_2_s cn73xx;
+	struct cvmx_gserx_lanex_rx_os_out_2_s cnf75xx;
+};
+typedef union cvmx_gserx_lanex_rx_os_out_2 cvmx_gserx_lanex_rx_os_out_2_t;
+
+/**
+ * cvmx_gser#_lane#_rx_os_out_3
+ *
+ * These registers are for diagnostic use only.
+ * These registers are reset by hardware only during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_rx_os_out_3 {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_rx_os_out_3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t sds_pcs_rx_os_out            : 12; /**< Offset calibration code for readout, 2's complement.
+                                                         <11:6> = Q.
+                                                         <5:0> = Qb. */
+#else
+	uint64_t sds_pcs_rx_os_out            : 12;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_rx_os_out_3_s cn73xx;
+	struct cvmx_gserx_lanex_rx_os_out_3_s cnf75xx;
+};
+typedef union cvmx_gserx_lanex_rx_os_out_3 cvmx_gserx_lanex_rx_os_out_3_t;
+
+/**
  * cvmx_gser#_lane#_rx_precorr_ctrl
  *
  * These are the RAW PCS per-lane RX precorrelation control registers. These registers are for
@@ -6159,9 +6349,9 @@ union cvmx_gserx_lanex_rx_vma_status_1 {
 	struct cvmx_gserx_lanex_rx_vma_status_1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t sds_pcs_rx_vma_status        : 16; /**< <15:8>: Output is controlled by GSER()_LANE()_RX_CFG_3[CFG_RX_ERRDET_CTRL[6:5]:
-                                                         0x0 = Window counter[19:12] (VMA RAW FOM).
-                                                         0x1 = Window counter[11:4].
+	uint64_t sds_pcs_rx_vma_status        : 16; /**< <15:8>: Output is controlled by GSER()_LANE()_RX_CFG_4[CFG_RX_ERRDET_CTRL]<6:5>:
+                                                         0x0 = Window counter<19:12> (VMA RAW FOM).
+                                                         0x1 = Window counter<11:4>.
                                                          0x2 = CTLE (continous time linear equalizer) pole, SDLL_IQ.
                                                          0x3 = Pre-CTLE gain, CTLE Peak.
                                                          <7>: Training done.
@@ -9543,6 +9733,8 @@ typedef union cvmx_gserx_scratch cvmx_gserx_scratch_t;
  * These registers are for diagnostic use only.
  * These registers are reset by hardware only during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ *
+ * Slice 1 does not exist on GSER0, GSER1, GSER4, GSER5, GSER6, GSER7, and GSER8.
  */
 union cvmx_gserx_slicex_rx_sdll_ctrl {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-helper.h b/arch/mips/include/asm/octeon/cvmx-helper.h
index 2b2cfd5..7cdd52d 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper.h
@@ -42,7 +42,7 @@
  *
  * Helper functions for common, but complicated tasks.
  *
- * <hr>$Revision: 117608 $<hr>
+ * <hr>$Revision: 129707 $<hr>
  */
 
 #ifndef __CVMX_HELPER_H__
@@ -170,6 +170,11 @@ void cvmx_rgmii_set_back_pressure(uint64_t backpressure_dis);
 #include "cvmx-helper-util.h"
 #include "cvmx-helper-xaui.h"
 
+enum cvmx_pko_padding {
+	CVMX_PKO_PADDING_NONE = 0,
+	CVMX_PKO_PADDING_60 = 1,
+};
+
 /**
  * cvmx_override_iface_phy_mode(int interface, int index) is a function pointer.
  * It is meant to allow customization of interfaces which do not have a PHY.
@@ -531,11 +536,6 @@ int __cvmx_helper_set_link_info(int xiface, int index, cvmx_helper_link_info_t l
  */
 cvmx_helper_link_info_t __cvmx_helper_get_link_info(int xiface, int port);
 
-enum cvmx_pko_padding {
-	CVMX_PKO_PADDING_NONE = 0,
-	CVMX_PKO_PADDING_60 = 1,
-};
-
 /**
  * @INTERNAL
  *
diff --git a/arch/mips/include/asm/octeon/cvmx-ila-defs.h b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
index 7417ed2..52e33d3 100644
--- a/arch/mips/include/asm/octeon/cvmx-ila-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ila-defs.h
@@ -842,7 +842,8 @@ union cvmx_ila_rxx_cfg0 {
                                                          This field affects the ILA_RX()_STAT4[BRST_SHRT_ERR_CNT] counter. It does not affect
                                                          correct operation of the link. */
 	uint64_t lane_rev                     : 1;  /**< Lane reversal. When enabled, lane destriping is performed from most-significant lane
-                                                         enabled to least-significant lane enabled. LANE_ENA must be 0 before changing LANE_REV. */
+                                                         enabled to least-significant lane enabled. [LANE_ENA] must be 0 before changing
+                                                         [LANE_REV]. */
 	uint64_t brst_max                     : 5;  /**< Maximum size of a data burst, as a multiple of 64-byte blocks. Supported range is from 64
                                                          to 1024 bytes
                                                          (i.e. 0 < BRST_MAX <= 16).
@@ -852,15 +853,15 @@ union cvmx_ila_rxx_cfg0 {
 	uint64_t reserved_8_25                : 18;
 	uint64_t lane_ena                     : 8;  /**< Lane enable mask. The link is enabled if any lane is enabled. The same lane should not be
                                                          enabled in multiple ILA_RXn_CFG0. Each bit of LANE_ENA maps to an RX lane (RLE) and a QLM
-                                                         lane. Note that LANE_REV has no effect on this mapping.
-                                                         _ LANE_ENA[0] = RLE0 =  QLM2 lane 0.
-                                                         _ LANE_ENA[1] = RLE1 =  QLM2 lane 1.
-                                                         _ LANE_ENA[2] = RLE2 =  QLM2 lane 2.
-                                                         _ LANE_ENA[3] = RLE3 =  QLM2 lane 3.
-                                                         _ LANE_ENA[4] = RLE4 =  QLM3 lane 0.
-                                                         _ LANE_ENA[5] = RLE5 =  QLM3 lane 1.
-                                                         _ LANE_ENA[6] = RLE6 =  QLM3 lane 2.
-                                                         _ LANE_ENA[7] = RLE7 =  QLM3 lane 3. */
+                                                         lane. Note that [LANE_REV] has no effect on this mapping.
+                                                         _ [LANE_ENA<0>]  = RLE0  = QLM2 lane 0.
+                                                         _ [LANE_ENA<1>]  = RLE1  = QLM2 lane 1.
+                                                         _ [LANE_ENA<2>]  = RLE2  = QLM2 lane 2.
+                                                         _ [LANE_ENA<3>]  = RLE3  = QLM2 lane 3.
+                                                         _ [LANE_ENA<4>]  = RLE4  = QLM3 lane 0.
+                                                         _ [LANE_ENA<5>]  = RLE5  = QLM3 lane 1.
+                                                         _ [LANE_ENA<6>]  = RLE6  = QLM3 lane 2.
+                                                         _ [LANE_ENA<7>]  = RLE7  = QLM3 lane 3. */
 #else
 	uint64_t lane_ena                     : 8;
 	uint64_t reserved_8_25                : 18;
@@ -1546,13 +1547,42 @@ union cvmx_ila_ser_cfg {
 	uint64_t reserved_48_55               : 8;
 	uint64_t ser_rxpol                    : 8;  /**< SerDes lane receive polarity.
                                                          0x0 = RX without inversion.
-                                                         0x1 = RX with inversion. */
+                                                         0x1 = RX with inversion.
+                                                         Note that ILK_RX()_CFG0[LANE_REV] has no effect on this mapping.
+                                                          _ [SER_RXPOL<0>]  = QLM2 lane 0.
+                                                          _ [SER_RXPOL<1>]  = QLM2 lane 1.
+                                                          _ [SER_RXPOL<2>]  = QLM2 lane 2.
+                                                          _ [SER_RXPOL<3>]  = QLM2 lane 3.
+                                                          _ [SER_RXPOL<4>]  = QLM3 lane 0.
+                                                          _ [SER_RXPOL<5>]  = QLM3 lane 1.
+                                                          _ [SER_RXPOL<6>]  = QLM3 lane 2.
+                                                          _ [SER_RXPOL<7>]  = QLM3 lane 3. */
 	uint64_t reserved_32_39               : 8;
 	uint64_t ser_txpol                    : 8;  /**< SerDes lane transmit polarity.
                                                          0x0 = TX without inversion.
-                                                         0x1 = TX with inversion. */
+                                                         0x1 = TX with inversion.
+                                                         Note that ILK_TX()_CFG0[LANE_REV] has no effect on this mapping.
+                                                          _ [SER_TXPOL<0>]  = QLM2 lane 0.
+                                                          _ [SER_TXPOL<1>]  = QLM2 lane 1.
+                                                          _ [SER_TXPOL<2>]  = QLM2 lane 2.
+                                                          _ [SER_TXPOL<3>]  = QLM2 lane 3.
+                                                          _ [SER_TXPOL<4>]  = QLM3 lane 0.
+                                                          _ [SER_TXPOL<5>]  = QLM3 lane 1.
+                                                          _ [SER_TXPOL<6>]  = QLM3 lane 2.
+                                                          _ [SER_TXPOL<7>]  = QLM3 lane 3. */
 	uint64_t reserved_16_23               : 8;
-	uint64_t ser_reset_n                  : 8;  /**< SerDes lane reset. */
+	uint64_t ser_reset_n                  : 8;  /**< SerDes lane reset. Should be set when the GSER is ready to transfer data, as indicated
+                                                         by the corresponding GSER()_QLM_STAT[RST_RDY]. Note that
+                                                         neither ILK_TX()_CFG0[LANE_REV] nor ILK_RX()_CFG0[LANE_REV] has an effect on this mapping.
+                                                         The correlation of [SER_RESET_N] bits to GSER's is as follows:
+                                                         _ [SER_RESET_N<0>]  = QLM2 lane 0, GSER(2)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<1>]  = QLM2 lane 1, GSER(2)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<2>]  = QLM2 lane 2, GSER(2)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<3>]  = QLM2 lane 3, GSER(2)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<4>]  = QLM3 lane 0, GSER(3)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<5>]  = QLM3 lane 1, GSER(3)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<6>]  = QLM3 lane 2, GSER(3)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<7>]  = QLM3 lane 3, GSER(3)_QLM_STAT[RST_RDY]. */
 	uint64_t reserved_0_7                 : 8;
 #else
 	uint64_t reserved_0_7                 : 8;
@@ -1617,22 +1647,23 @@ union cvmx_ila_txx_cfg0 {
                                                          range from eight to 512 bytes
                                                          (i.e. 0 < BRST_SHRT <= 64). */
 	uint64_t lane_rev                     : 1;  /**< Lane reversal.   When enabled, lane striping is performed from most significant lane
-                                                         enabled to least significant lane enabled. LANE_ENA must be zero before changing LANE_REV. */
+                                                         enabled to least significant lane enabled. [LANE_ENA] must be zero before changing
+                                                         [LANE_REV]. */
 	uint64_t brst_max                     : 5;  /**< Maximum size of a data burst, as a multiple of 64 byte blocks.
                                                          Supported range is from 64 bytes to 1024 bytes
                                                          (i.e. 0 < BRST_MAX <= 16). */
 	uint64_t reserved_8_25                : 18;
 	uint64_t lane_ena                     : 8;  /**< Lane enable mask. Link is enabled if any lane is enabled. The same lane should not be
                                                          enabled in multiple ILA_TX()_CFG0. Each bit of LANE_ENA maps to a TX lane (TLE) and a QLM
-                                                         lane. Note that LANE_REV has no effect on this mapping.
-                                                         _ LANE_ENA[0] = TLE0  =  QLM2 lane 0.
-                                                         _ LANE_ENA[1] = TLE1  =  QLM2 lane 1.
-                                                         _ LANE_ENA[2] = TLE2  =  QLM2 lane 2.
-                                                         _ LANE_ENA[3] = TLE3  =  QLM2 lane 3.
-                                                         _ LANE_ENA[4] = TLE4  =  QLM3 lane 0.
-                                                         _ LANE_ENA[5] = TLE5  =  QLM3 lane 1.
-                                                         _ LANE_ENA[6] = TLE6  =  QLM3 lane 2.
-                                                         _ LANE_ENA[7] = TLE7  =  QLM3 lane 3. */
+                                                         lane. Note that [LANE_REV] has no effect on this mapping.
+                                                         _ [LANE_ENA<0>]  = TLE0  =  QLM2 lane 0.
+                                                         _ [LANE_ENA<1>]  = TLE1  =  QLM2 lane 1.
+                                                         _ [LANE_ENA<2>]  = TLE2  =  QLM2 lane 2.
+                                                         _ [LANE_ENA<3>]  = TLE3  =  QLM2 lane 3.
+                                                         _ [LANE_ENA<4>]  = TLE4  =  QLM3 lane 0.
+                                                         _ [LANE_ENA<5>]  = TLE5  =  QLM3 lane 1.
+                                                         _ [LANE_ENA<6>]  = TLE6  =  QLM3 lane 2.
+                                                         _ [LANE_ENA<7>]  = TLE7  =  QLM3 lane 3. */
 #else
 	uint64_t lane_ena                     : 8;
 	uint64_t reserved_8_25                : 18;
diff --git a/arch/mips/include/asm/octeon/cvmx-ilk-defs.h b/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
index f15c533..3a05756 100644
--- a/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ilk-defs.h
@@ -1969,7 +1969,8 @@ union cvmx_ilk_rxx_cfg0 {
                                                          This field affects the ILK_RX()_STAT4[BRST_SHRT_ERR_CNT] counter. It does not affect
                                                          correct operation of the link. */
 	uint64_t lane_rev                     : 1;  /**< Lane reversal. When enabled, lane destriping is performed from most-significant lane
-                                                         enabled to least-significant lane enabled. LANE_ENA must be 0 before changing LANE_REV. */
+                                                         enabled to least-significant lane enabled. [LANE_ENA] must be 0 before changing
+                                                         [LANE_REV]. */
 	uint64_t brst_max                     : 5;  /**< Maximum size of a data burst, as a multiple of 64-byte blocks. Supported range is from 64
                                                          to 1024 bytes
                                                          (i.e. 0 < BRST_MAX <= 16).
@@ -1980,23 +1981,23 @@ union cvmx_ilk_rxx_cfg0 {
 	uint64_t cal_depth                    : 9;  /**< Indicates the number of valid entries in the calendar.   Supported range from 1 to 288. */
 	uint64_t lane_ena                     : 16; /**< Lane-enable mask. The link is enabled if any lane is enabled. The same lane should not be
                                                          enabled in multiple ILK_RXn_CFG0. Each bit of LANE_ENA maps to an RX lane (RLE) and a QLM
-                                                         lane. Note that LANE_REV has no effect on this mapping.
-                                                         _ LANE_ENA<0> = RLE0 = QLM4 lane 0.
-                                                         _ LANE_ENA<1> = RLE1 = QLM4 lane 1.
-                                                         _ LANE_ENA<2> = RLE2 = QLM4 lane 2.
-                                                         _ LANE_ENA<3> = RLE3 = QLM4 lane 3.
-                                                         _ LANE_ENA<4> = RLE4 = QLM5 lane 0.
-                                                         _ LANE_ENA<5> = RLE5 = QLM5 lane 1.
-                                                         _ LANE_ENA<6> = RLE6 = QLM5 lane 2.
-                                                         _ LANE_ENA<7> = RLE7 = QLM5 lane 3.
-                                                         _ LANE_ENA<8> = RLE8 = QLM6 lane 0.
-                                                         _ LANE_ENA<9> = RLE9 = QLM6 lane 1.
-                                                         _ LANE_ENA<10> = RLE10 = QLM6 lane 2.
-                                                         _ LANE_ENA<11> = RLE11 = QLM6 lane 3.
-                                                         _ LANE_ENA<12> = RLE12 = QLM7 lane 0.
-                                                         _ LANE_ENA<13> = RLE13 = QLM7 lane 1.
-                                                         _ LANE_ENA<14> = RLE14 = QLM7 lane 2.
-                                                         _ LANE_ENA<15> = RLE15 = QLM7 lane 3. */
+                                                         lane. Note that [LANE_REV] has no effect on this mapping.
+                                                         _ [LANE_ENA<0>]  = RLE0  = QLM4 lane 0.
+                                                         _ [LANE_ENA<1>]  = RLE1  = QLM4 lane 1.
+                                                         _ [LANE_ENA<2>]  = RLE2  = QLM4 lane 2.
+                                                         _ [LANE_ENA<3>]  = RLE3  = QLM4 lane 3.
+                                                         _ [LANE_ENA<4>]  = RLE4  = QLM5 lane 0.
+                                                         _ [LANE_ENA<5>]  = RLE5  = QLM5 lane 1.
+                                                         _ [LANE_ENA<6>]  = RLE6  = QLM5 lane 2.
+                                                         _ [LANE_ENA<7>]  = RLE7  = QLM5 lane 3.
+                                                         _ [LANE_ENA<8>]  = RLE8  = QLM6 lane 0.
+                                                         _ [LANE_ENA<9>]  = RLE9  = QLM6 lane 1.
+                                                         _ [LANE_ENA<10>] = RLE10 = QLM6 lane 2.
+                                                         _ [LANE_ENA<11>] = RLE11 = QLM6 lane 3.
+                                                         _ [LANE_ENA<12>] = RLE12 = QLM7 lane 0.
+                                                         _ [LANE_ENA<13>] = RLE13 = QLM7 lane 1.
+                                                         _ [LANE_ENA<14>] = RLE14 = QLM7 lane 2.
+                                                         _ [LANE_ENA<15>] = RLE15 = QLM7 lane 3. */
 #else
 	uint64_t lane_ena                     : 16;
 	uint64_t cal_depth                    : 9;
@@ -3945,42 +3946,63 @@ union cvmx_ilk_ser_cfg {
 	uint64_t ser_rxpol                    : 16; /**< SerDes lane receive polarity.
                                                          0 = RX without inversion.
                                                          1 = RX with inversion.
-                                                         _ SER_RXPOL<0>  = QLM4 lane 0.
-                                                         _ SER_RXPOL<1>  = QLM4 lane 1.
-                                                         _ SER_RXPOL<2>  = QLM4 lane 2.
-                                                         _ SER_RXPOL<3>  = QLM4 lane 3.
-                                                         _ SER_RXPOL<4>  = QLM5 lane 0.
-                                                         _ SER_RXPOL<5>  = QLM5 lane 1.
-                                                         _ SER_RXPOL<6>  = QLM5 lane 2.
-                                                         _ SER_RXPOL<7>  = QLM5 lane 3.
-                                                         _ SER_RXPOL<8>  = QLM6 lane 0.
-                                                         _ SER_RXPOL<9>  = QLM6 lane 1.
-                                                         _ SER_RXPOL<10> = QLM6 lane 2.
-                                                         _ SER_RXPOL<11> = QLM6 lane 3.
-                                                         _ SER_RXPOL<12> = QLM7 lane 0.
-                                                         _ SER_RXPOL<13> = QLM7 lane 1.
-                                                         _ SER_RXPOL<14> = QLM7 lane 2.
-                                                         _ SER_RXPOL<15> = QLM7 lane 3. */
+                                                         Note that ILK_RX()_CFG0[LANE_REV] has no effect on this mapping.
+                                                         _ [SER_RXPOL<0>]  = QLM4 lane 0.
+                                                         _ [SER_RXPOL<1>]  = QLM4 lane 1.
+                                                         _ [SER_RXPOL<2>]  = QLM4 lane 2.
+                                                         _ [SER_RXPOL<3>]  = QLM4 lane 3.
+                                                         _ [SER_RXPOL<4>]  = QLM5 lane 0.
+                                                         _ [SER_RXPOL<5>]  = QLM5 lane 1.
+                                                         _ [SER_RXPOL<6>]  = QLM5 lane 2.
+                                                         _ [SER_RXPOL<7>]  = QLM5 lane 3.
+                                                         _ [SER_RXPOL<8>]  = QLM6 lane 0.
+                                                         _ [SER_RXPOL<9>]  = QLM6 lane 1.
+                                                         _ [SER_RXPOL<10>] = QLM6 lane 2.
+                                                         _ [SER_RXPOL<11>] = QLM6 lane 3.
+                                                         _ [SER_RXPOL<12>] = QLM7 lane 0.
+                                                         _ [SER_RXPOL<13>] = QLM7 lane 1.
+                                                         _ [SER_RXPOL<14>] = QLM7 lane 2.
+                                                         _ [SER_RXPOL<15>] = QLM7 lane 3. */
 	uint64_t ser_txpol                    : 16; /**< SerDes lane transmit polarity.
                                                          0 = TX without inversion.
                                                          1 = TX with inversion.
-                                                         _ SER_TXPOL<0>  = QLM4 lane 0.
-                                                         _ SER_TXPOL<1>  = QLM4 lane 1.
-                                                         _ SER_TXPOL<2>  = QLM4 lane 2.
-                                                         _ SER_TXPOL<3>  = QLM4 lane 3.
-                                                         _ SER_TXPOL<4>  = QLM5 lane 0.
-                                                         _ SER_TXPOL<5>  = QLM5 lane 1.
-                                                         _ SER_TXPOL<6>  = QLM5 lane 2.
-                                                         _ SER_TXPOL<7>  = QLM5 lane 3.
-                                                         _ SER_TXPOL<8>  = QLM6 lane 0.
-                                                         _ SER_TXPOL<9>  = QLM6 lane 1.
-                                                         _ SER_TXPOL<10> = QLM6 lane 2.
-                                                         _ SER_TXPOL<11> = QLM6 lane 3.
-                                                         _ SER_TXPOL<12> = QLM7 lane 0.
-                                                         _ SER_TXPOL<13> = QLM7 lane 1.
-                                                         _ SER_TXPOL<14> = QLM7 lane 2.
-                                                         _ SER_TXPOL<15> = QLM7 lane 3. */
-	uint64_t ser_reset_n                  : 16; /**< SerDes lane reset. */
+                                                         Note that ILK_TX()_CFG0[LANE_REV] has no effect on this mapping.
+                                                         _ [SER_TXPOL<0>]  = QLM4 lane 0.
+                                                         _ [SER_TXPOL<1>]  = QLM4 lane 1.
+                                                         _ [SER_TXPOL<2>]  = QLM4 lane 2.
+                                                         _ [SER_TXPOL<3>]  = QLM4 lane 3.
+                                                         _ [SER_TXPOL<4>]  = QLM5 lane 0.
+                                                         _ [SER_TXPOL<5>]  = QLM5 lane 1.
+                                                         _ [SER_TXPOL<6>]  = QLM5 lane 2.
+                                                         _ [SER_TXPOL<7>]  = QLM5 lane 3.
+                                                         _ [SER_TXPOL<8>]  = QLM6 lane 0.
+                                                         _ [SER_TXPOL<9>]  = QLM6 lane 1.
+                                                         _ [SER_TXPOL<10>] = QLM6 lane 2.
+                                                         _ [SER_TXPOL<11>] = QLM6 lane 3.
+                                                         _ [SER_TXPOL<12>] = QLM7 lane 0.
+                                                         _ [SER_TXPOL<13>] = QLM7 lane 1.
+                                                         _ [SER_TXPOL<14>] = QLM7 lane 2.
+                                                         _ [SER_TXPOL<15>] = QLM7 lane 3. */
+	uint64_t ser_reset_n                  : 16; /**< SerDes lane reset. Should be set when the GSER is ready to transfer data, as indicated
+                                                         by the corresponding GSER()_QLM_STAT[RST_RDY]. Note that
+                                                         neither ILK_TX()_CFG0[LANE_REV] nor ILK_RX()_CFG0[LANE_REV] has an effect on this mapping.
+                                                         The correlation of [SER_RESET_N] bits to GSER's is as follows:
+                                                         _ [SER_RESET_N<0>]  = QLM4 lane 0, GSER(4)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<1>]  = QLM4 lane 1, GSER(4)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<2>]  = QLM4 lane 2, GSER(4)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<3>]  = QLM4 lane 3, GSER(4)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<4>]  = QLM5 lane 0, GSER(5)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<5>]  = QLM5 lane 1, GSER(5)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<6>]  = QLM5 lane 2, GSER(5)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<7>]  = QLM5 lane 3, GSER(5)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<8>]  = QLM6 lane 0, GSER(6)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<9>]  = QLM6 lane 1, GSER(6)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<10>] = QLM6 lane 2, GSER(6)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<11>] = QLM6 lane 3, GSER(6)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<12>] = QLM7 lane 0, GSER(7)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<13>] = QLM7 lane 1, GSER(7)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<14>] = QLM7 lane 2, GSER(7)_QLM_STAT[RST_RDY].
+                                                         _ [SER_RESET_N<15>] = QLM7 lane 3, GSER(7)_QLM_STAT[RST_RDY]. */
 	uint64_t ser_pwrup                    : 4;  /**< Reserved. */
 	uint64_t ser_haul                     : 4;  /**< Reserved. */
 #else
@@ -4124,7 +4146,7 @@ union cvmx_ilk_txx_cfg0 {
 	uint64_t brst_shrt                    : 7;  /**< Minimum interval between burst control words, as a multiple of eight bytes. Supported
                                                          range from eight to 512 bytes (i.e. 0 < BRST_SHRT <= 64). */
 	uint64_t lane_rev                     : 1;  /**< Lane reversal. When enabled, lane striping is performed from most significant lane enabled
-                                                         to least significant lane enabled. LANE_ENA must be zero before changing LANE_REV. */
+                                                         to least significant lane enabled. [LANE_ENA] must be zero before changing [LANE_REV]. */
 	uint64_t brst_max                     : 5;  /**< Maximum size of a data burst, as a multiple of 64-byte blocks. Supported range is from 64
                                                          to 1024 bytes (i.e. 0 < BRST_MAX <= 16). */
 	uint64_t reserved_25_25               : 1;
@@ -4135,23 +4157,23 @@ union cvmx_ilk_txx_cfg0 {
 	uint64_t lane_ena                     : 16; /**< Lane enable mask. Link is enabled if any lane is enabled. The same lane should not be
                                                          enabled in multiple
                                                          ILK_TX0/1_CFG0. Each bit of LANE_ENA maps to a TX lane (TLE) and a QLM lane. Note that
-                                                         LANE_REV has no effect on this mapping.
-                                                         _ LANE_ENA<0> = TLE0  =  QLM4 lane 0.
-                                                         _ LANE_ENA<1> = TLE1  =  QLM4 lane 1.
-                                                         _ LANE_ENA<2> = TLE2  =  QLM4 lane 2.
-                                                         _ LANE_ENA<3> = TLE3  =  QLM4 lane 3.
-                                                         _ LANE_ENA<4> = TLE4  =  QLM5 lane 0.
-                                                         _ LANE_ENA<5> = TLE5  =  QLM5 lane 1.
-                                                         _ LANE_ENA<6> = TLE6  =  QLM5 lane 2.
-                                                         _ LANE_ENA<7> = TLE7  =  QLM5 lane 3.
-                                                         _ LANE_ENA<8> = TLE8  =  QLM6 lane 0.
-                                                         _ LANE_ENA<9> = TLE9  =  QLM6 lane 1.
-                                                         _ LANE_ENA<10> = TLE10  =  QLM6 lane 2.
-                                                         _ LANE_ENA<11> = TLE11  =  QLM6 lane 3.
-                                                         _ LANE_ENA<12> = TLE12  =  QLM7 lane 0.
-                                                         _ LANE_ENA<13> = TLE13  =  QLM7 lane 1.
-                                                         _ LANE_ENA<14> = TLE14  =  QLM7 lane 2.
-                                                         _ LANE_ENA<15> = TLE15  =  QLM7 lane 3. */
+                                                         [LANE_REV] has no effect on this mapping.
+                                                         _ [LANE_ENA<0>]  = TLE0   =  QLM4 lane 0.
+                                                         _ [LANE_ENA<1>]  = TLE1   =  QLM4 lane 1.
+                                                         _ [LANE_ENA<2>]  = TLE2   =  QLM4 lane 2.
+                                                         _ [LANE_ENA<3>]  = TLE3   =  QLM4 lane 3.
+                                                         _ [LANE_ENA<4>]  = TLE4   =  QLM5 lane 0.
+                                                         _ [LANE_ENA<5>]  = TLE5   =  QLM5 lane 1.
+                                                         _ [LANE_ENA<6>]  = TLE6   =  QLM5 lane 2.
+                                                         _ [LANE_ENA<7>]  = TLE7   =  QLM5 lane 3.
+                                                         _ [LANE_ENA<8>]  = TLE8   =  QLM6 lane 0.
+                                                         _ [LANE_ENA<9>]  = TLE9   =  QLM6 lane 1.
+                                                         _ [LANE_ENA<10>] = TLE10  =  QLM6 lane 2.
+                                                         _ [LANE_ENA<11>] = TLE11  =  QLM6 lane 3.
+                                                         _ [LANE_ENA<12>] = TLE12  =  QLM7 lane 0.
+                                                         _ [LANE_ENA<13>] = TLE13  =  QLM7 lane 1.
+                                                         _ [LANE_ENA<14>] = TLE14  =  QLM7 lane 2.
+                                                         _ [LANE_ENA<15>] = TLE15  =  QLM7 lane 3. */
 #else
 	uint64_t lane_ena                     : 16;
 	uint64_t cal_depth                    : 9;
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index be94bd7..5859fe9 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -13131,15 +13131,15 @@ union cvmx_lmcx_timing_params1 {
                                                          frequency (not data rate).
                                                          TYP=max(3nCK, 7.5 ns) */
 	uint64_t trrd                         : 3;  /**< Indicates TRRD constraints. Set this field as follows:
-                                                         _ RNDUP[TRRD(ns) / TCYC(ns)] - 1,
+                                                         _ RNDUP[TRRD(ns) / TCYC(ns)] - 2,
                                                          where TRRD is from the JEDEC DDR3/DDR4 spec, and TCYC(ns) is the DDR clock
                                                          frequency (not data rate).
                                                          TYP = max(4nCK, 10 ns)
                                                          0x0 = Reserved.
-                                                         0x1 = 2 TCYC.
+                                                         0x1 = 3 TCYC.
                                                          - ...
-                                                         0x6 = 7 TCYC.
-                                                         0x7 = 8 TCYC.
+                                                         0x6 = 8 TCYC.
+                                                         0x7 = 9 TCYC.
                                                          For DDR4, this is the TRRD_S parameter. */
 	uint64_t trfc                         : 7;  /**< Indicates TRFC constraints. Set this field as follows:
                                                          _ RNDUP[TRFC(ns) / (8 * TCYC(ns))]
@@ -13230,7 +13230,7 @@ union cvmx_lmcx_timing_params2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t trrd_l_ext                   : 1;  /**< MSB of TWTR_L constraints. Set this field
-                                                         when requiring tRRD_L of more than 8 nCK. Otherwise
+                                                         when requiring tRRD_L of more than 9 nCK. Otherwise
                                                          this bit must be 0. */
 	uint64_t trtp                         : 4;  /**< Specifies the TRTP parameter, in cycles. Set this field as follows:
                                                          _ RNDUP[TRTP(ns) / TCYC(ns)] - 1,
@@ -13246,18 +13246,18 @@ union cvmx_lmcx_timing_params2 {
                                                          data rate).
                                                          Typical = MAX(4 nCK, 7.5 ns) */
 	uint64_t trrd_l                       : 3;  /**< Specifies TRRD_L constraints. Set this field as follows:
-                                                         _ RNDUP[TRRD_L(ns) / TCYC(ns)] - 1,
+                                                         _ RNDUP[TRRD_L(ns) / TCYC(ns)] - 2,
                                                          where TRRD_L is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not the
                                                          data rate).
                                                          Typical = MAX(4 nCK, 7.5 ns).
                                                          0x0 = reserved.
-                                                         0x1 = two TCYC.
-                                                         0x2 = three TCYC.
-                                                         0x3 = four TCYC.
-                                                         0x4 = five TCYC.
-                                                         0x5 = six TCYC.
-                                                         0x6 = seven TCYC.
-                                                         0x7 = eight TCYC. */
+                                                         0x1 = three TCYC.
+                                                         0x2 = four TCYC.
+                                                         0x3 = five TCYC.
+                                                         0x4 = six TCYC.
+                                                         0x5 = seven TCYC.
+                                                         0x6 = eight TCYC.
+                                                         0x7 = nine TCYC. */
 #else
 	uint64_t trrd_l                       : 3;
 	uint64_t twtr_l                       : 4;
diff --git a/arch/mips/include/asm/octeon/cvmx-mio-defs.h b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
index ba91aef..5845475 100644
--- a/arch/mips/include/asm/octeon/cvmx-mio-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mio-defs.h
@@ -6489,14 +6489,9 @@ typedef union cvmx_mio_fus_pdf cvmx_mio_fus_pdf_t;
 /**
  * cvmx_mio_fus_pll
  *
- * Notes:
- * The core clkout postscaler should be placed in reset at least 10 ref clocks prior to changing
- * the core clkout select.  The core clkout postscaler should remain under reset for at least 10
- * ref clocks after the core clkout select changes.
- *
- * The pnr clkout postscaler should be placed in reset at least 10 ref clocks prior to changing
- * the pnr clkout select.  The pnr clkout postscaler should remain under reset for at least 10
- * ref clocks after the pnr clkout select changes.
+ * This register contains PLL Status and controls for the MSC_CLKOUT and
+ * MSC_SYS_CLKOUT pins.  The fields are reset to zero on a cold reset.
+ * the values are preserved on both a warm and soft reset for pass 2.
  */
 union cvmx_mio_fus_pll {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
index 6e6ad7d..93ce8ea 100644
--- a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
@@ -2067,12 +2067,12 @@ union cvmx_pemx_dbg_info {
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RPTAMRC. */
 	uint64_t rpmerc                       : 1;  /**< Received PME message (RC mode only).
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RPMERC. */
-	uint64_t rfemrc                       : 1;  /**< Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
+	uint64_t rfemrc                       : 1;  /**< Received fatal-error message. This bit is set when a message with ERR_FATAL
                                                          is set.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RFEMRC. */
-	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message (RC mode only).
+	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RNFEMRC. */
-	uint64_t rcemrc                       : 1;  /**< Received correctable error message (RC mode only).
+	uint64_t rcemrc                       : 1;  /**< Received correctable error message.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RCEMRC. */
 	uint64_t rpoison                      : 1;  /**< Received poisoned TLP.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RPOISON. */
@@ -2518,12 +2518,12 @@ union cvmx_pemx_dbg_info {
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RPTAMRC. */
 	uint64_t rpmerc                       : 1;  /**< Received PME message (RC mode only).
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RPMERC. */
-	uint64_t rfemrc                       : 1;  /**< Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
+	uint64_t rfemrc                       : 1;  /**< Received fatal-error message. This bit is set when a message with ERR_FATAL
                                                          is set.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RFEMRC. */
-	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message (RC mode only).
+	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RNFEMRC. */
-	uint64_t rcemrc                       : 1;  /**< Received correctable error message (RC mode only).
+	uint64_t rcemrc                       : 1;  /**< Received correctable error message.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RCEMRC. */
 	uint64_t rpoison                      : 1;  /**< Received poisoned TLP.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RPOISON. */
@@ -2707,12 +2707,12 @@ union cvmx_pemx_dbg_info {
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RPTAMRC. */
 	uint64_t rpmerc                       : 1;  /**< Received PME message (RC mode only).
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RPMERC. */
-	uint64_t rfemrc                       : 1;  /**< Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
+	uint64_t rfemrc                       : 1;  /**< Received fatal-error message. This bit is set when a message with ERR_FATAL
                                                          is set.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RFEMRC. */
-	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message (RC mode only).
+	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RNFEMRC. */
-	uint64_t rcemrc                       : 1;  /**< Received correctable error message (RC mode only).
+	uint64_t rcemrc                       : 1;  /**< Received correctable error message.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RCEMRC. */
 	uint64_t rpoison                      : 1;  /**< Received poisoned TLP.
                                                          Throws PEM_INTSN_E::PEM()_ERROR_RPOISON. */
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index 7c4141c..faedd0c 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -1742,9 +1742,8 @@ union cvmx_pki_clx_int {
 	struct cvmx_pki_clx_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
-	uint64_t iptint                       : 1;  /**< PCAM sequencer debug interrupt. Throws PKI_INTSN_E::PKI_CL()_INT_IPTINT. */
-	uint64_t sched_conf                   : 1;  /**< PCAM/SMEM internal port conflict, sequencer mis-scheduled PCAM or SMEM
-                                                         ops with overlapping accesses. Internal error, should not occur. Throws
+	uint64_t iptint                       : 1;  /**< PCAM parse engine debug interrupt. Throws PKI_INTSN_E::PKI_CL()_INT_IPTINT. */
+	uint64_t sched_conf                   : 1;  /**< PCAM/SMEM internal port conflict. Internal error, should not occur. Throws
                                                          PKI_INTSN_E::PKI_CL()_INT_SCHED_CONF. */
 	uint64_t pcam_conf                    : 2;  /**< PCAM() match hit multiple rows, indicating either a soft error in the PCAM or a
                                                          programming error in PKI_CL()_PCAM()_MATCH() or related registers. Throws
@@ -1773,7 +1772,7 @@ typedef union cvmx_pki_clx_int cvmx_pki_clx_int_t;
  *
  * For each legal j and k, PKI_CL(i)_PCAM(j)_ACTION(k) must be configured identically for i=0..1.
  *
- * With the current sequencer code:
+ * With the current parse engine code:
  *
  * Action performed based on PCAM lookup using the PKI_CL()_PCAM()_TERM() and
  * PKI_CL()_PCAM()_MATCH() registers.
@@ -1792,7 +1791,7 @@ union cvmx_pki_clx_pcamx_actionx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_31_63               : 33;
 	uint64_t pmc                          : 7;  /**< Parse mode change. Where to resume parsing after applying the scan offset (if any) as bit
-                                                         mask of which sequence steps to no longer process:
+                                                         mask of which parse engine steps to no longer process:
                                                          _ <0> = LA (L2).
                                                          _ <1> = LB (Custom).
                                                          _ <2> = LC (L3).
@@ -1889,7 +1888,7 @@ typedef union cvmx_pki_clx_pcamx_matchx cvmx_pki_clx_pcamx_matchx_t;
  *
  * This register configures the match side of the PCAM. PKI HW is opaque as to the use
  * of the 16 bits of CAM data; the split between TERM and STYLE is defined by the
- * sequencer.
+ * parse engine.
  *
  * For each legal j and k, PKI_CL(i)_PCAM(j)_TERM(k) must be configured identically for i=0..1.
  */
@@ -1937,7 +1936,7 @@ typedef union cvmx_pki_clx_pcamx_termx cvmx_pki_clx_pcamx_termx_t;
  * cvmx_pki_cl#_pkind#_cfg
  *
  * This register is inside PKI_CL()_PKIND()_KMEM(). These CSRs are used only by
- * the PKI parse engine/sequencer.
+ * the PKI parse engine.
  *
  * For each legal j, PKI_CL(i)_PKIND(j)_CFG must be configured identically for i=0..1.
  */
@@ -2004,10 +2003,10 @@ typedef union cvmx_pki_clx_pkindx_cfg cvmx_pki_clx_pkindx_cfg_t;
 /**
  * cvmx_pki_cl#_pkind#_kmem#
  *
- * This register initializes the KMEM, which initializes the sequencer state for each
- * pkind. These CSRs are used only by the PKI parse engine/sequencer.
+ * This register initializes the KMEM, which initializes the parse engine state for each
+ * pkind. These CSRs are used only by the PKI parse engine.
  *
- * Inside the KMEM are the following sequencer registers. These registers are the
+ * Inside the KMEM are the following parse engine registers. These registers are the
  * preferred access method for software:
  * * PKI_CL()_PKIND()_CFG.
  * * PKI_CL()_PKIND()_STYLE.
@@ -2047,7 +2046,7 @@ typedef union cvmx_pki_clx_pkindx_kmemx cvmx_pki_clx_pkindx_kmemx_t;
  * cvmx_pki_cl#_pkind#_l2_custom
  *
  * This register is inside PKI_CL()_PKIND()_KMEM(). These CSRs are used only by
- * the PKI parse engine/sequencer.
+ * the PKI parse engine.
  *
  * For each legal j, PKI_CL(i)_PKIND(j)_L2_CUSTOM must be configured identically for i=0..1.
  */
@@ -2081,7 +2080,7 @@ typedef union cvmx_pki_clx_pkindx_l2_custom cvmx_pki_clx_pkindx_l2_custom_t;
  * cvmx_pki_cl#_pkind#_lg_custom
  *
  * This register is inside PKI_CL()_PKIND()_KMEM(). These CSRs are used only by
- * the PKI parse engine/sequencer.
+ * the PKI parse engine.
  *
  * For each legal j, PKI_CL(i)_PKIND(j)_LG_CUSTOM must be configured identically for i=0..1.
  */
@@ -2110,7 +2109,7 @@ typedef union cvmx_pki_clx_pkindx_lg_custom cvmx_pki_clx_pkindx_lg_custom_t;
  * cvmx_pki_cl#_pkind#_skip
  *
  * This register is inside PKI_CL()_PKIND()_KMEM(). These CSRs are used only by
- * the PKI parse engine/sequencer.
+ * the PKI parse engine.
  *
  * For each legal j, PKI_CL(i)_PKIND(j)_SKIP must be configured identically for i=0..1.
  */
@@ -2144,7 +2143,7 @@ typedef union cvmx_pki_clx_pkindx_skip cvmx_pki_clx_pkindx_skip_t;
  * cvmx_pki_cl#_pkind#_style
  *
  * This register is inside PKI_CL()_PKIND()_KMEM(). These CSRs are used only by
- * the PKI parse engine/sequencer.
+ * the PKI parse engine.
  *
  * For each legal j, PKI_CL(i)_PKIND(j)_STYLE must be configured identically for i=0..1.
  */
@@ -2153,20 +2152,20 @@ union cvmx_pki_clx_pkindx_style {
 	struct cvmx_pki_clx_pkindx_style_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
-	uint64_t pm                           : 7;  /**< Initial parse mode. Bit mask of which sequence steps to perform, refer to Parse Mode:
-                                                         _ <0> = LA (L2).
-                                                         _ <1> = LB (Custom).
-                                                         _ <2> = LC (L3).
-                                                         _ <3> = LD (L4 Virt).
-                                                         _ <4> = LE (IL3).
-                                                         _ <5> = LF (L4).
-                                                         _ <6> = LG (Custom/Application).
+	uint64_t pm                           : 7;  /**< Initial parse mode. Bit mask of which steps the parse engine should perform, refer
+                                                         to Parse Mode:
+                                                         _ <0> = LA - Layer A (Ethernet dest+src, Higig/Fulcrum/DSA).
+                                                         _ <1> = LB - Layer B (Ethertype/VLAN, MPLS/ARP/REVARP/SNAP).
+                                                         _ <2> = LC - Layer C (Outer IPv4 or IPv6).
+                                                         _ <3> = LD - Layer D (Geneve/VXLAN/VXLANGPE/NVGRE).
+                                                         _ <4> = LE - Layer E (Inner IPv4 or IPv6).
+                                                         _ <5> = LF - Layer F (UDP, TCP, SCTP, IPCOMP, IPSEC ESP/AH, GRE).
+                                                         _ <6> = LG - Layer G (Custom/Application).
                                                          The legal values are:
                                                          _ 0x0 = Parse LA..LG.
                                                          _ 0x1 = Parse LB..LG.
                                                          _ 0x3 = Parse LC..LG.
-                                                         _ 0x3F = Parse LG.
-                                                         _ 0x7F = Parse nothing.
+                                                         _ 0x7F = Parse none and error check none of LA..LG.
                                                          _ else = Reserved. */
 	uint64_t style                        : 8;  /**< Initial style. Initial style number for packets on this port, will remain as final style
                                                          if no PCAM entries match the packet. Note only 64 final styles exist, the upper two bits
@@ -2187,10 +2186,10 @@ typedef union cvmx_pki_clx_pkindx_style cvmx_pki_clx_pkindx_style_t;
 /**
  * cvmx_pki_cl#_smem#
  *
- * This register initializes the SMEM, which configures the sequencer. These CSRs
- * are used by the PKI parse engine/sequencer and other PKI HW.
+ * This register initializes the SMEM, which configures the parse engine. These CSRs
+ * are used by the PKI parse engine and other PKI HW.
  *
- * Inside the SMEM are the following sequencer registers. These registers are the
+ * Inside the SMEM are the following parse engine registers. These registers are the
  * preferred access method for software:
  * * PKI_CL()_STYLE()_CFG
  * * PKI_CL()_STYLE()_CFG2
@@ -2251,7 +2250,7 @@ typedef union cvmx_pki_clx_start cvmx_pki_clx_start_t;
  * cvmx_pki_cl#_style#_alg
  *
  * This register is inside PKI_CL()_SMEM(). These CSRs are used only by
- * the PKI parse engine/sequencer.
+ * the PKI parse engine.
  *
  * For each legal j, PKI_CL(i)_STYLE(j)_ALG must be configured identically for i=0..1.
  */
@@ -2270,7 +2269,8 @@ union cvmx_pki_clx_stylex_alg {
                                                          8 = Include port<7:0>.
                                                          else Reserved. */
 	uint64_t reserved_11_16               : 6;
-	uint64_t tag_vni                      : 1;  /**< When NVGRE/VXLAN/GENEVE is found, include VNI in tag generation. When NVGRE is found, include TNI. */
+	uint64_t tag_vni                      : 1;  /**< When NVGRE/VXLAN/VXLANGPE/GENEVE is found, include VNI in tag generation. When NVGRE is
+                                                         found, include VSID. */
 	uint64_t tag_gtp                      : 1;  /**< When GTP is parsed, include GTP's TEID in tag generation.
                                                          The GTP PKI_PCAM_TERM_E::L4_PORT PCAM entry must have
                                                          PKI_CL()_PCAM()_ACTION()[SETTY,ADVANCE]
@@ -2323,7 +2323,7 @@ typedef union cvmx_pki_clx_stylex_alg cvmx_pki_clx_stylex_alg_t;
  * cvmx_pki_cl#_style#_cfg
  *
  * This register is inside PKI_CL()_SMEM(). These CSRs are used by
- * the PKI parse engine/sequencer and other PKI HW.
+ * the PKI parse engine and other PKI HW.
  *
  * For each legal j, PKI_CL(i)_STYLE(j)_CFG must be configured identically for i=0..1.
  */
@@ -2407,7 +2407,7 @@ typedef union cvmx_pki_clx_stylex_cfg cvmx_pki_clx_stylex_cfg_t;
  * cvmx_pki_cl#_style#_cfg2
  *
  * This register is inside PKI_CL()_SMEM(). These CSRs are used by
- * the PKI parse engine/sequencer and other PKI HW.
+ * the PKI parse engine and other PKI HW.
  *
  * For each legal j, PKI_CL(i)_STYLE(j)_CFG2 must be configured identically for i=0..1.
  */
@@ -3097,8 +3097,8 @@ typedef union cvmx_pki_frm_len_chkx cvmx_pki_frm_len_chkx_t;
  * pkinds. The values are opaque to PKI HW.
  *
  * This is intended for communication between the higher-level software SDK, and the
- * SDK code that loads PKI_IMEM() with the sequencer code.  This allows the loader to
- * appropriately select the sequencer code with only those features required, so that
+ * SDK code that loads PKI_IMEM() with the parse engine code.  This allows the loader to
+ * appropriately select the parse engine code with only those features required, so that
  * performance will be optimized.
  */
 union cvmx_pki_gbl_pen {
@@ -3107,9 +3107,9 @@ union cvmx_pki_gbl_pen {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t virt_pen                     : 1;  /**< Virtualization parsing enable.
-                                                         0 = VXLAN/NVGRE/GENEVE is never used in any style. This enables internal power
+                                                         0 = VXLAN/VXLANGPE/NVGRE/GENEVE is never used in any style. This enables internal power
                                                          and latency reductions.
-                                                         1 = VXLAN/NVGRE/GENEVE parsing may be used.
+                                                         1 = VXLAN/VXLANGPE/NVGRE/GENEVE parsing may be used.
                                                          See [L3_PEN] for supported [L3_PEN,VIRT_PEN,IL3_PEN,L4_PEN,CLG_PEN] combinations. */
 	uint64_t clg_pen                      : 1;  /**< Custom LG parsing enable.
                                                          0 = Custom LG is never used in any style; i.e. PKI_CL()_PKIND()_CFG[LG_CUSTOM_LAYER]
@@ -3289,7 +3289,7 @@ union cvmx_pki_icgx_cfg {
 	uint64_t pena                         : 1;  /**< Parse enable. Must be set after PKI has been initialized and PKI_IMEM() loaded.
                                                          0 = IPE transitions from start directly to done without executing a sequence, and the KMEM
                                                          bits effectively are copied through to the WQ.
-                                                         1 = Normal sequencer operation. */
+                                                         1 = Normal parse engine operation. */
 	uint64_t timer                        : 12; /**< Current hold-off timer. Enables even spreading of cluster utilization over time; while
                                                          TIMER is non-zero, a cluster in this group will not start parsing. When a cluster in this
                                                          group starts parsing, TIMER is set to DELAY, and decrements every coprocessor-clock. TIMER
@@ -3327,7 +3327,7 @@ union cvmx_pki_imemx {
 	uint64_t u64;
 	struct cvmx_pki_imemx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t data                         : 64; /**< Sequencer instruction word. Software must reload PKI_IMEM() upon the detection
+	uint64_t data                         : 64; /**< Parse engine instruction word. Software must reload PKI_IMEM() upon the detection
                                                          of PKI_ECC_INT2[IMEM_SBE] or PKI_ECC_INT2[IMEM_DBE] errors. */
 #else
 	uint64_t data                         : 64;
@@ -3822,14 +3822,14 @@ union cvmx_pki_req_wgt {
 	struct cvmx_pki_req_wgt_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
-	uint64_t wgt8                         : 4;  /**< Weight for ILK0. */
-	uint64_t wgt7                         : 4;  /**< Weight for LBK. */
-	uint64_t wgt6                         : 4;  /**< Weight for DPI. */
-	uint64_t wgt5                         : 4;  /**< Weight for BGX5. */
-	uint64_t wgt4                         : 4;  /**< Weight for BGX4. */
-	uint64_t wgt3                         : 4;  /**< Weight for BGX3. */
-	uint64_t wgt2                         : 4;  /**< Weight for BGX2. */
-	uint64_t wgt1                         : 4;  /**< Weight for BGX1. */
+	uint64_t wgt8                         : 4;  /**< Reserved. */
+	uint64_t wgt7                         : 4;  /**< Reserved. */
+	uint64_t wgt6                         : 4;  /**< Reserved. */
+	uint64_t wgt5                         : 4;  /**< Reserved. */
+	uint64_t wgt4                         : 4;  /**< Weight for LBK */
+	uint64_t wgt3                         : 4;  /**< Weight for DPI. */
+	uint64_t wgt2                         : 4;  /**< Weight for SRIO1. */
+	uint64_t wgt1                         : 4;  /**< Weight for SRIO0. */
 	uint64_t wgt0                         : 4;  /**< Weight for BGX0. */
 #else
 	uint64_t wgt0                         : 4;
@@ -4488,9 +4488,9 @@ union cvmx_pki_stylex_buf {
                                                          0x1 = WORD0..5.
                                                          0x2 = Reserved.
                                                          0x3 = Reserved.
-                                                         Selects which sequencer words are transferred to the PKI BE. If a word is not
+                                                         Selects which parse engine words are transferred to the PKI BE. If a word is not
                                                          transferred and the word will reach memory (FIRST_SKIP is greater than that word
-                                                         number), then the final WQE memory word will be zero, not the sequencer register
+                                                         number), then the final WQE memory word will be zero, not the parse engine register
                                                          contents. */
 	uint64_t wqe_skip                     : 2;  /**< WQE start offset. The number of 128-byte cache lines to skip between the buffer pointer
                                                          and WORD0 of the work-queue entry.
diff --git a/arch/mips/include/asm/octeon/cvmx-qlm.h b/arch/mips/include/asm/octeon/cvmx-qlm.h
index b2ae632..b228d88 100644
--- a/arch/mips/include/asm/octeon/cvmx-qlm.h
+++ b/arch/mips/include/asm/octeon/cvmx-qlm.h
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 123908 $<hr>
+ * <hr>$Revision: 129707 $<hr>
  */
 
 #ifndef __CVMX_QLM_H__
@@ -235,6 +235,8 @@ enum cvmx_qlm_mode {
 	CVMX_QLM_MODE_RGMII_SGMII_2X1, /* Configure BGX2, applies to DLM6 */
 	CVMX_QLM_MODE_RGMII_10G_KR_1X1, /* Configure BGX2, applies to DLM6 */
 	CVMX_QLM_MODE_RGMII_XFI_1X1, /* Configure BGX2, applies to DLM6 */
+	CVMX_QLM_MODE_SDL,	  /* RMAC Pipe */
+	CVMX_QLM_MODE_CPRI,	  /* RMAC */
 	CVMX_QLM_MODE_OCI
 };
 
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index a6f3e45..989ddac 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -393,11 +393,7 @@ union cvmx_rst_bphy_soft_rst {
 	struct cvmx_rst_bphy_soft_rst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t soft_rst                     : 1;  /**< Reserved.  For diagonistic use only.
-                                                         Internal:  When set, resets the Baseband PHY Logic independent of the
-                                                         reset of the chip.  Software must guarantee that NCB operations have
-                                                         completed and credits have been returned before asserting this bit.
-                                                         Minimum assertion time 1uS. */
+	uint64_t soft_rst                     : 1;  /**< Reserved.  For diagonistic use only. */
 #else
 	uint64_t soft_rst                     : 1;
 	uint64_t reserved_1_63                : 63;
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index 1e04d25..269ae54 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -4578,7 +4578,7 @@ typedef union cvmx_sli_ciu_int_sum cvmx_sli_ciu_int_sum_t;
 /**
  * cvmx_sli_ctl_port#
  *
- * These registers contains control information for access to ports.
+ * These registers contains control information for access to ports. Indexed by SLI_PORT_E.
  * Note: SLI_CTL_PORT0 controls PF0 and PF1
  */
 union cvmx_sli_ctl_portx {
@@ -7364,6 +7364,7 @@ typedef union cvmx_sli_last_win_rdata3 cvmx_sli_last_win_rdata3_t;
  *
  * When an error response is received for a VF DMA transaction read, the appropriate VF indexed
  * bit is set.  The appropriate PF should read the appropriate register.
+ * Indexed by (MAC index) SLI_PORT_E.
  * These registers are only valid for PEM0
  */
 union cvmx_sli_macx_pfx_dma_vf_int {
@@ -7386,8 +7387,8 @@ typedef union cvmx_sli_macx_pfx_dma_vf_int cvmx_sli_macx_pfx_dma_vf_int_t;
 /**
  * cvmx_sli_mac#_pf#_dma_vf_int_enb
  *
+ * Indexed by (MAC index) SLI_PORT_E.
  * These registers are only valid for PEM0 PF0
- *
  */
 union cvmx_sli_macx_pfx_dma_vf_int_enb {
 	uint64_t u64;
@@ -7408,6 +7409,7 @@ typedef union cvmx_sli_macx_pfx_dma_vf_int_enb cvmx_sli_macx_pfx_dma_vf_int_enb_
  * cvmx_sli_mac#_pf#_flr_vf_int
  *
  * When a
+ * Indexed by (MAC index) SLI_PORT_E.
  * These registers are only valid for PEM0 PF0
  */
 union cvmx_sli_macx_pfx_flr_vf_int {
@@ -7429,6 +7431,7 @@ typedef union cvmx_sli_macx_pfx_flr_vf_int cvmx_sli_macx_pfx_flr_vf_int_t;
  * cvmx_sli_mac#_pf#_int_enb
  *
  * Interrupt enable register for a given PF SLI_MAC()_PF()_INT_SUM register.
+ * Indexed by (MAC index) SLI_PORT_E.
  * CN73XX valid copies are MAC0 PF0, MAC0 PF1, MAC1 PF0, MAC2 PF0, MAC3 PF3
  * PEM0 PF0, PEM0 PF1, PEM1 PF0, PEM2 PF0, PEM3 PF0,
  */
@@ -7512,7 +7515,7 @@ typedef union cvmx_sli_macx_pfx_int_enb cvmx_sli_macx_pfx_int_enb_t;
 /**
  * cvmx_sli_mac#_pf#_int_sum
  *
- * Interrupt summary register for a given PF.
+ * Interrupt summary register for a given PF. Indexed (MAC index) by SLI_PORT_E.
  * CN73XX valid copies are MAC0 PF0, MAC0 PF1, MAC1 PF0, MAC2 PF0, MAC3 PF0
  * The fields in this register are set when an interrupt condition occurs; write 1 to clear.
  * These register are valid for these physical functions
@@ -7620,8 +7623,8 @@ typedef union cvmx_sli_macx_pfx_int_sum cvmx_sli_macx_pfx_int_sum_t;
 /**
  * cvmx_sli_mac#_pf#_mbox_int
  *
+ * Indexed by (MAC index) SLI_PORT_E.
  * These registers are only valid for PEM0 PF0
- *
  */
 union cvmx_sli_macx_pfx_mbox_int {
 	uint64_t u64;
@@ -7647,6 +7650,7 @@ typedef union cvmx_sli_macx_pfx_mbox_int cvmx_sli_macx_pfx_mbox_int_t;
  * overflow for a ring associated with a VF occurs or an illegal memory access from a VF occurs,
  * the appropriate VF indexed bit is set.  The appropriate PF should read the appropriate
  * register.
+ * Indexed by (MAC index) SLI_PORT_E.
  * These registers are only valid for PEM0 PF0
  */
 union cvmx_sli_macx_pfx_pkt_vf_int {
@@ -7669,8 +7673,8 @@ typedef union cvmx_sli_macx_pfx_pkt_vf_int cvmx_sli_macx_pfx_pkt_vf_int_t;
 /**
  * cvmx_sli_mac#_pf#_pkt_vf_int_enb
  *
+ * Indexed by (MAC index) SLI_PORT_E.
  * These registers are only valid for PEM0 PF0
- *
  */
 union cvmx_sli_macx_pfx_pkt_vf_int_enb {
 	uint64_t u64;
@@ -7692,6 +7696,7 @@ typedef union cvmx_sli_macx_pfx_pkt_vf_int_enb cvmx_sli_macx_pfx_pkt_vf_int_enb_
  *
  * When an error response is received for a VF PP transaction read, the appropriate VF indexed
  * bit is set.  The appropriate PF should read the appropriate register.
+ * Indexed by (MAC index) SLI_PORT_E.
  * These registers are only valid for PEM0 PF0
  */
 union cvmx_sli_macx_pfx_pp_vf_int {
@@ -7714,8 +7719,8 @@ typedef union cvmx_sli_macx_pfx_pp_vf_int cvmx_sli_macx_pfx_pp_vf_int_t;
 /**
  * cvmx_sli_mac#_pf#_pp_vf_int_enb
  *
+ * Indexed by (MAC index) SLI_PORT_E.
  * These registers are only valid for PEM0 PF0
- *
  */
 union cvmx_sli_macx_pfx_pp_vf_int_enb {
 	uint64_t u64;
@@ -7878,7 +7883,7 @@ union cvmx_sli_mac_number {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t a_mode                       : 1;  /**< SLI in Authentik mode. */
-	uint64_t num                          : 8;  /**< MAC number. */
+	uint64_t num                          : 8;  /**< MAC number. Enumerated by SLI_PORT_E. */
 #else
 	uint64_t num                          : 8;
 	uint64_t a_mode                       : 1;
@@ -7964,7 +7969,7 @@ union cvmx_sli_mem_access_subidx {
 	uint64_t reserved_43_43               : 1;
 	uint64_t zero                         : 1;  /**< Causes all byte read operations to be zero-length read operations. Returns 0s to the EXEC
                                                          for all read data. This must be zero for SRIO ports. */
-	uint64_t port                         : 3;  /**< The MAC that the reads/writes/atomics are sent to. */
+	uint64_t port                         : 3;  /**< The MAC that the reads/writes/atomics are sent to. Enumerated by SLI_PORT_E. */
 	uint64_t nmerge                       : 1;  /**< When set, no merging is allowed in this window. Applicable to writes only. */
 	uint64_t esr                          : 2;  /**< Endian swap for read operations. ES<1:0> for read operations to this subID. ES<1:0> is the
                                                          endian-swap attribute for these MAC memory space read operations. Not used for write or
@@ -8103,7 +8108,7 @@ union cvmx_sli_mem_access_subidx {
 	uint64_t reserved_43_43               : 1;
 	uint64_t zero                         : 1;  /**< Causes all byte read operations to be zero-length read operations. Returns 0s to the EXEC
                                                          for all read data. */
-	uint64_t port                         : 3;  /**< The MAC that the reads/writes/atomics are sent to. */
+	uint64_t port                         : 3;  /**< The MAC that the reads/writes/atomics are sent to. Enumerated by SLI_PORT_E. */
 	uint64_t nmerge                       : 1;  /**< When set, no merging is allowed in this window. Applicable to writes only. */
 	uint64_t esr                          : 2;  /**< Endian swap for read operations. ES<1:0> for read operations to this subID. ES<1:0> is the
                                                          endian-swap attribute for these MAC memory space read operations. Not used for write or
@@ -8799,8 +8804,7 @@ typedef union cvmx_sli_msi_wr_map cvmx_sli_msi_wr_map_t;
 /**
  * cvmx_sli_msix#_table_addr
  *
- * The MSI-X table must be addressed on a 8-byte aligned boundary and cannot be burst read or
- * written.
+ * The MSI-X table cannot be burst read or written.
  *
  * The MSI-X Table is (128 + 5) entries deep. Each PF of a MAC can see up to 64 VF ring entries
  * and its own PF entry. The (MAC0,PF0), (MAC0,PF1), (MAC1,PF0), (MAC2,PF0), and (MAC3,PF0),
@@ -8855,8 +8859,8 @@ typedef union cvmx_sli_msixx_table_addr cvmx_sli_msixx_table_addr_t;
 /**
  * cvmx_sli_msix#_table_data
  *
- * The MSI-X table must be addressed on a 8-byte aligned boundary and cannot be burst read or
- * written. F/PF access is the same as described for the SLI_MSIX()_TABLE_ADDR.
+ * The MSI-X table cannot be burst read or written. F/PF access is the same as described
+ * for the SLI_MSIX()_TABLE_ADDR.
  */
 union cvmx_sli_msixx_table_data {
 	uint64_t u64;
@@ -8923,8 +8927,7 @@ typedef union cvmx_sli_msix_macx_pf_table_data cvmx_sli_msix_macx_pf_table_data_
 /**
  * cvmx_sli_msix_pba0
  *
- * The MSI-X Pending Bit Array must be addressed on a 8-byte aligned boundary and
- * cannot be burst read.
+ * The MSI-X Pending Bit Array cannot be burst read.
  * In SRIO-V Mode, a VF will find its pending completion interrupts in bit
  * positions [(RPVF-1):0]. If RPVF<64, bits [63:RPVF] are returned as zero.
  *
@@ -8973,8 +8976,7 @@ typedef union cvmx_sli_msix_pba0 cvmx_sli_msix_pba0_t;
 /**
  * cvmx_sli_msix_pba1
  *
- * The MSI-X pending bit array must be addressed on a 8-byte aligned boundary and cannot be
- * burst read.
+ * The MSI-X pending bit array cannot be burst read.
  *
  * PF_PND is assigned to PCIe related errors. The error bit can only be found in PBA1 when
  * SLI_PEM()_TNR=63 (i.e. 64 total DPI Packet Rings configured).
@@ -9414,7 +9416,7 @@ union cvmx_sli_pktx_input_control {
 	uint64_t rpvf                         : 7;  /**< The number of rings assigned to this VF.
                                                          Read only copy of SLI_PKT_MAC(0..3)_PF(0..1)_RINFO[RPVF] */
 	uint64_t reserved_31_47               : 17;
-	uint64_t mac_num                      : 2;  /**< The MAC (PEM) that the physical function belongs to. Legal value are 0-3.
+	uint64_t mac_num                      : 2;  /**< The MAC (PEM) that the physical function belongs to. Enumerated by SLI_PORT_E.
                                                          [MAC_NUM] is RO when accessed via BAR0 of a virtual function, and R/W otherwise.
                                                          [MAC_NUM] applies to the ring pair, which includes both this input
                                                          ring and to the output ring of the same index. */
@@ -9517,7 +9519,7 @@ union cvmx_sli_pktx_input_control {
                                                          [PVF_NUM] applies to the ring pair, which includes both this input
                                                          ring and to the output ring of the same index. */
 	uint64_t reserved_31_31               : 1;
-	uint64_t mac_num                      : 2;  /**< The MAC (PEM) that the physical function belongs to. Legal value are 0-3.
+	uint64_t mac_num                      : 2;  /**< The MAC (PEM) that the physical function belongs to. Enumerated by SLI_PORT_E.
                                                          [MAC_NUM] is RO when accessed via BAR0 of a virtual function, and R/W otherwise.
                                                          [MAC_NUM] applies to the ring pair, which includes both this input
                                                          ring and to the output ring of the same index. */
@@ -11463,7 +11465,8 @@ typedef union cvmx_sli_pkt_iptr cvmx_sli_pkt_iptr_t;
  * cvmx_sli_pkt_mac#_pf#_rinfo
  *
  * This register sets the total number and starting number of rings for a given MAC and PF
- * combination. In SRIOV mode SLI_PKT_MAC()_PF()_RINFO[RPVF] and
+ * combination. Indexed by (MAC index) SLI_PORT_E. In SRIOV mode SLI_PKT_MAC()_PF()_RINFO[RPVF]
+ * and
  * SLI_PKT_MAC()_PF()_RINFO[NVFS] must be non zero and determine which rings the PF and
  * VF's own.
  *
@@ -11480,14 +11483,14 @@ typedef union cvmx_sli_pkt_iptr cvmx_sli_pkt_iptr_t;
  * _ SLI_PKT_MAC0_PF1_RINFO[TRS] = 35,
  * _ SLI_PKT_MAC0_PF1_RINFO[RPVF] = 4,
  * _ SLI_PKT_MAC0_PF1_RINFO[NVFS] = 7:
- * _ rings owned by VF1 32,33,34,35
- * _ rings owned by VF2 36,37,38,39
- * _ rings owned by VF3 40,41,42,43
- * _ rings owned by VF4 44,45,46,47
- * _ rings owned by VF5 48,49,50,51
- * _ rings owned by VF6 52,53,54,55
- * _ rings owned by VF7 56,57,58,59
- * _ rings owned by PF  60,61,62,63,64,65,66
+ * _ rings owned by VF1: 32,33,34,35
+ * _ rings owned by VF2: 36,37,38,39
+ * _ rings owned by VF3: 40,41,42,43
+ * _ rings owned by VF4: 44,45,46,47
+ * _ rings owned by VF5: 48,49,50,51
+ * _ rings owned by VF6: 52,53,54,55
+ * _ rings owned by VF7: 56,57,58,59
+ * _ rings owned by PF:  60,61,62,63,64,65,66
  *
  * CNXXXX valid copies are MAC0 PF0, MAC0 PF1, MAC1 PF0, MAC2 PF0, MAC3 PF3.
  */
@@ -12447,14 +12450,34 @@ typedef union cvmx_sli_portx_pkind cvmx_sli_portx_pkind_t;
  * cvmx_sli_pp_pkt_csr_control
  *
  * This register provides access to SLI packet register space from the cores.
- *
+ * These SLI packet registers include the following:
+ * SLI_MSIXX_TABLE_ADDR,
+ * SLI_MSIXX_TABLE_DATA,
+ * SLI_MSIX_PBA0,
+ * SLI_MSIX_PBA1,
+ * SLI_PKTX_INPUT_CONTROL,
+ * SLI_PKTX_INSTR_BADDR,
+ * SLI_PKTX_INSTR_BAOFF_DBELL,
+ * SLI_PKTX_INSTR_FIFO_RSIZE,
+ * SLI_PKT_IN_DONEX_CNTS,
+ * SLI_PKTX_OUTPUT_CONTROL,
+ * SLI_PKTX_OUT_SIZE,
+ * SLI_PKTX_SLIST_BADDR,
+ * SLI_PKTX_SLIST_BAOFF_DBELL,
+ * SLI_PKTX_SLIST_FIFO_RSIZE,
+ * SLI_PKTX_INT_LEVELS,
+ * SLI_PKTX_CNTS,
+ * SLI_PKTX_ERROR_INFO,
+ * SLI_PKTX_VF_INT_SUM,
+ * SLI_PKTX_PF_VF_MBOX_SIG,
+ * SLI_PKTX_MBOX_INT.
  */
 union cvmx_sli_pp_pkt_csr_control {
 	uint64_t u64;
 	struct cvmx_sli_pp_pkt_csr_control_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
-	uint64_t mac                          : 2;  /**< MAC number to use on a PP register accesses to SLI Packet CSRs. */
+	uint64_t mac                          : 2;  /**< MAC number to use on a PP register accesses to SLI Packet CSRs. Enumerated by SLI_PORT_E. */
 	uint64_t pvf                          : 16; /**< Function number to use on a PP register accesses to SLI Packet CSRs,
                                                          where <15:13> selects the PF the
                                                          VF belongs to, and <12:0> selects the VF within that PF (or 0x0 for the PF
@@ -12496,10 +12519,11 @@ typedef union cvmx_sli_s2c_end_merge cvmx_sli_s2c_end_merge_t;
 /**
  * cvmx_sli_s2m_port#_ctl
  *
- * These registers contain control for access from SLI to a MAC port. Write operations to these
- * registers are not ordered with write/read operations to the MAC memory space. To ensure that a
- * write operation has completed, read the register before making an access (i.e. MAC memory
- * space) that requires the value of this register to be updated.
+ * These registers contain control for access from SLI to a MAC port. Indexed by SLI_PORT_E.
+ * Write operations to these registers are not ordered with write/read operations to the MAC
+ * memory space. To ensure that a write operation has completed, read the register before
+ * making an access (i.e. MAC memory space) that requires the value of this register to be
+ * updated.
  */
 union cvmx_sli_s2m_portx_ctl {
 	uint64_t u64;
diff --git a/arch/mips/include/asm/octeon/cvmx-spemx-defs.h b/arch/mips/include/asm/octeon/cvmx-spemx-defs.h
index 7fd2554..2a9b16c 100644
--- a/arch/mips/include/asm/octeon/cvmx-spemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-spemx-defs.h
@@ -1009,12 +1009,12 @@ union cvmx_spemx_dbg_info {
                                                          Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RPTAMRC. */
 	uint64_t rpmerc                       : 1;  /**< Received PME message (RC mode only).
                                                          Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RPMERC. */
-	uint64_t rfemrc                       : 1;  /**< Received fatal-error message (RC mode only). This bit is set when a message with ERR_FATAL
+	uint64_t rfemrc                       : 1;  /**< Received fatal-error message. This bit is set when a message with ERR_FATAL
                                                          is set.
                                                          Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RFEMRC. */
-	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message (RC mode only).
+	uint64_t rnfemrc                      : 1;  /**< Received nonfatal error message.
                                                          Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RNFEMRC. */
-	uint64_t rcemrc                       : 1;  /**< Received correctable error message (RC mode only).
+	uint64_t rcemrc                       : 1;  /**< Received correctable error message.
                                                          Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RCEMRC. */
 	uint64_t rpoison                      : 1;  /**< Received poisoned TLP.
                                                          Throws corresponding SPEM_INTSN_E::SPEM()_ERROR_RPOISON. */
-- 
1.7.5.4

