From 9e85509dd5f7ad4153d33065c24ba4e4b8cada9f Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Sun, 9 Feb 2014 13:46:59 -0800
Subject: [PATCH 531/974] MIPS: OCTEON: Sync up S.E. files.

Signed-off-by: David Daney <david.daney@cavium.com>
[Original patch taken from Cavium SDK 3.1.2-568]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bch.c       |   46 +-
 .../mips/cavium-octeon/executive/cvmx-helper-bgx.c |  154 ++-
 .../cavium-octeon/executive/cvmx-helper-board.c    |   14 +-
 .../mips/cavium-octeon/executive/cvmx-helper-pki.c |    4 +-
 .../cavium-octeon/executive/cvmx-helper-util.c     |    3 +-
 arch/mips/cavium-octeon/executive/cvmx-pko3.c      |   39 +
 arch/mips/cavium-octeon/executive/cvmx-qlm.c       |   52 +-
 arch/mips/include/asm/octeon/cvmx-bgxx-defs.h      | 1167 +++++++++++---------
 arch/mips/include/asm/octeon/cvmx-ciu-defs.h       |    8 +-
 arch/mips/include/asm/octeon/cvmx-ciu3-defs.h      |   38 +-
 arch/mips/include/asm/octeon/cvmx-dtx-defs.h       |  233 ++--
 arch/mips/include/asm/octeon/cvmx-gserx-defs.h     |  739 +++++++------
 arch/mips/include/asm/octeon/cvmx-helper-fpa.h     |    2 +
 arch/mips/include/asm/octeon/cvmx-lmcx-defs.h      |  198 ++--
 arch/mips/include/asm/octeon/cvmx-mixx-defs.h      |    4 +-
 arch/mips/include/asm/octeon/cvmx-oclax-defs.h     |    4 +-
 arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h |    2 +-
 arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h   |    2 +-
 arch/mips/include/asm/octeon/cvmx-pemx-defs.h      |    2 +-
 arch/mips/include/asm/octeon/cvmx-pki-defs.h       |  352 +++---
 arch/mips/include/asm/octeon/cvmx-pko3.h           |    2 +
 arch/mips/include/asm/octeon/cvmx-rst-defs.h       |    6 +-
 arch/mips/include/asm/octeon/cvmx-sli-defs.h       |   13 +-
 arch/mips/include/asm/octeon/cvmx-sso-defs.h       |  228 ++--
 arch/mips/include/asm/octeon/cvmx-tim-defs.h       |   40 +-
 arch/mips/include/asm/octeon/octeon-feature.h      |    2 +-
 26 files changed, 1851 insertions(+), 1503 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bch.c b/arch/mips/cavium-octeon/executive/cvmx-bch.c
index c90a78d..25ed7cf 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bch.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bch.c
@@ -53,6 +53,8 @@
 # include <asm/octeon/cvmx-fpa1.h>
 # include <asm/octeon/cvmx-helper-fpa.h>
 # include <asm/octeon/cvmx-cmd-queue.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
 #elif defined(CVMX_BUILD_FOR_UBOOT)
 # include <common.h>
 # include <asm/arch/cvmx.h>
@@ -88,6 +90,8 @@ extern int cvm_oct_mem_fill_fpa(int pool, int elements);
 extern int cvm_oct_alloc_fpa_pool(int pool, int size);
 #endif
 
+static uint8_t *bounce_buff;
+
 /**
  * Initialize the BCH block
  *
@@ -103,19 +107,24 @@ int cvmx_bch_initialize(void)
 
 	/* Initialize FPA pool for BCH pool buffers */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
-	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL;
-	bch_pool_size = CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE;
+	int bch_aura, i;
+	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL, bch_aura = CVMX_FPA_OUTPUT_BUFFER_POOL;
+	bch_pool_size = CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE << 4;
 
 	debug("pool: %d, pool size: %llu\n", bch_pool, bch_pool_size);
 	/* Setup the FPA */
 	cvmx_fpa1_enable();
 
-	bch_pool = cvm_oct_alloc_fpa_pool(bch_pool, bch_pool_size);
 	if (bch_pool < 0) {
 		pr_err("cvm_oct_alloc_fpa_pool(%d, %lld)\n", bch_pool, bch_pool_size);
 		return -ENOMEM;
 	}
-	cvm_oct_mem_fill_fpa(bch_pool, 128);
+	
+	for (i = 0; i < 16; i++) {
+		cvmx_fpa1_free(kmalloc(bch_pool_size, GFP_KERNEL), bch_pool, 0);
+	}
+	
+	
 #else
 	bch_pool = (int)cvmx_fpa_get_bch_pool();
 	bch_pool_size = cvmx_fpa_get_bch_pool_block_size();
@@ -132,6 +141,7 @@ int cvmx_bch_initialize(void)
 			"BCH Buffers");
 
 #endif
+	bounce_buff = cvmx_fpa1_alloc(bch_pool);
 	result = cvmx_cmd_queue_initialize(CVMX_CMD_QUEUE_BCH, 0, bch_pool,
 					   bch_pool_size);
 
@@ -170,6 +180,7 @@ EXPORT_SYMBOL(cvmx_bch_initialize);
 int cvmx_bch_shutdown(void)
 {
 	cvmx_bch_ctl_t bch_ctl;
+	int bch_pool;
 
 	debug("%s: ENTER\n", __func__);
 	bch_ctl.u64 = cvmx_read_csr(CVMX_BCH_CTL);
@@ -177,8 +188,26 @@ int cvmx_bch_shutdown(void)
 	cvmx_write_csr(CVMX_BCH_CTL, bch_ctl.u64);
 	cvmx_wait(4);
 
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	bch_pool = CVMX_FPA_OUTPUT_BUFFER_POOL;
+#else
+	bch_pool = (int)cvmx_fpa_get_bch_pool();
+#endif
+	cvmx_fpa1_free(bounce_buff, bch_pool, 0);
 	cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_BCH);
 
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+	/* FIXME: BCH cleanup in SE : AJ */
+	{
+		int i;
+		for (i = 0; i < 16; i++) {
+			kfree(cvmx_fpa1_alloc(bch_pool));
+		}
+	}
+#else
+	cvmx_fpa_shutdown_pool(bch_pool);
+#endif
+	/* AJ: Fix for FPA3 */
 	return 0;
 }
 EXPORT_SYMBOL(cvmx_bch_shutdown);
@@ -228,6 +257,12 @@ int cvmx_bch_encode(const void *block, uint16_t block_size,
 
 	debug("%s(%p, %u, %u, %p, %p) ENTRY\n", __func__, block, block_size,
 	      ecc_level, ecc, response);
+	/* there was a problem when the first argument is used directly
+	 * despite of the fact it was 8-byte aligned (maybe not proper
+	 * cvmx_prt_to_phys), so we copy data to dedicated 'bounce_buff'
+	 * and set command.s.iword.prt to cvmx_ptr_to_phys((void *)bounce_buff)
+	 */
+	memcpy(bounce_buff, block, block_size);
 	memset(&result, 0, sizeof(result));
 	memset(&command, 0, sizeof(command));
 	command.s.cword.ecc_gen = CVMX_BCH_INST_ECC_GENERATION;
@@ -235,7 +270,8 @@ int cvmx_bch_encode(const void *block, uint16_t block_size,
 	command.s.cword.size = block_size;
 
 	command.s.oword.ptr = cvmx_ptr_to_phys(ecc);
-	command.s.iword.ptr = cvmx_ptr_to_phys((void *)block);
+/*	command.s.iword.ptr = cvmx_ptr_to_phys((void *)block);*/
+	command.s.iword.ptr = cvmx_ptr_to_phys((void *)bounce_buff);
 	command.s.resp.ptr = cvmx_ptr_to_phys((void *)response);
 	debug("Command: cword: 0x%llx, oword: 0x%llx, iword: 0x%llx, resp: 0x%llx\n",
 	      command.u64[0], command.u64[1], command.u64[2], command.u64[3]);
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
index dd5e5f2..e1626f5 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-bgx.c
@@ -53,6 +53,7 @@
 #include <asm/octeon/cvmx-helper-board.h>
 #include <asm/octeon/cvmx-helper-cfg.h>
 #include <asm/octeon/cvmx-bgxx-defs.h>
+#include <asm/octeon/cvmx-gserx-defs.h>
 #else
 #include "cvmx.h"
 #include "cvmx-helper.h"
@@ -108,6 +109,7 @@ static void __cvmx_bgx_common_init(int xiface)
 	cvmx_bgxx_cmrx_rx_bp_on_t bgx_rx_bp_on;
 	cvmx_helper_interface_mode_t mode;
 	int num_ports;
+        int num_chl = 16; /*modify it to 64 for xlaui and xaui*/
 	int index;
 	int lmac_type = 0;
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
@@ -167,25 +169,23 @@ static void __cvmx_bgx_common_init(int xiface)
 		/* Setup pkind */
 		int pknd = cvmx_helper_get_pknd(xiface, index);
 		cvmx_bgxx_cmrx_rx_id_map_t cmr_rx_id_map;
-		cvmx_bgxx_cmr_chan_msk_and_t chan_msk_and;
-		cvmx_bgxx_cmr_chan_msk_or_t chan_msk_or;
+                cvmx_bgxx_cmr_chan_msk_and_t chan_msk_and;
+	        cvmx_bgxx_cmr_chan_msk_or_t chan_msk_or;
+
 		cmr_rx_id_map.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_RX_ID_MAP(index, interface));
 		cmr_rx_id_map.s.pknd = pknd;
 		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_ID_MAP(index, interface),
 			       cmr_rx_id_map.u64);
-
-		/* Set backpressure channel mask AND/OR registers */
-		chan_msk_and.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_AND(interface));
-		chan_msk_or.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_OR(interface));
-		chan_msk_and.s.msk_and &= ~(0xffull << index);
-		chan_msk_or.s.msk_or |= (0xffull << index);
-		cvmx_write_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_AND(interface), chan_msk_and.u64);
-		cvmx_write_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_OR(interface), chan_msk_or.u64);
-
+                 /* Set backpressure channel mask AND/OR registers */
+                chan_msk_and.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_AND(interface));
+                chan_msk_or.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_OR(interface));
+                chan_msk_and.s.msk_and |= ((1 << num_chl) - 1) << (16 * index);
+                chan_msk_or.s.msk_or |= ((1 << num_chl) - 1) << (16 * index);
+                cvmx_write_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_AND(interface), chan_msk_and.u64);
+                cvmx_write_csr_node(node, CVMX_BGXX_CMR_CHAN_MSK_OR(interface), chan_msk_or.u64);
 		/* set rx back pressure (bp_on) on value */
 		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_RX_BP_ON(index, interface), bgx_rx_bp_on.u64);
-	}
-
+	}                                                   
 #if 0
 	/* FIXME for MIX configuration */
 	/* Check if interface 0 or 1 must be routed to the mix */
@@ -773,6 +773,8 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 	int interface = xi.interface;
 	int node = xi.node;
 	int use_auto_neg = 0;
+	int qlm = cvmx_qlm_interface(xiface);
+	int lane;
 
 	mode = cvmx_helper_interface_get_mode(xiface);
 
@@ -928,60 +930,67 @@ static int __cvmx_helper_bgx_xaui_init(int index, int xiface)
 	smu_tx_ctl.s.uni_en = 0;
 	cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_CTL(index, interface), smu_tx_ctl.u64);
 
+	/* Errata #20844
+	  1) After the link first comes up write the following
+	     register on each lane to prevent the application logic
+	     from stomping on the Coast inputs. This is a one time write,
+	     or if you prefer you could put it in the link up loop and
+	     write it every time the link comes up.
+	  1a) Then write GSER(0..13)_LANE(0..3)_PCS_CTLIFC_2
+	     Set CTLIFC_OVRRD_REQ (later)
+	     Set CFG_RX_CDR_COAST_REQ_OVRRD_EN
+	        Its not clear if #1 and #1a can be combined, lets try it
+	        this way first. */
+	for (lane=0; lane<4; lane++)
+	{
+		cvmx_gserx_lanex_pcs_ctlifc_2_t ctlifc;
+		ctlifc.u64 = cvmx_read_csr_node(node, CVMX_GSERX_LANEX_PCS_CTLIFC_2(lane, qlm));
+		ctlifc.s.cfg_rx_cdr_coast_req_ovrrd_en = 1;
+		cvmx_write_csr_node(node, CVMX_GSERX_LANEX_PCS_CTLIFC_2(lane, qlm), ctlifc.u64);
+	}
+
 	return 0;
 }
 
-int __cvmx_helper_bgx_xaui_enable(int xiface)
+static void __link_errata_20844(int qlm, int node)
 {
-	//cvmx_bgxx_smux_tx_append_t smu_tx_append;
-	cvmx_bgxx_smux_tx_thresh_t smu_tx_thresh;
-	cvmx_bgxx_cmrx_config_t cmr_config;
-	int index;
-	int num_ports = cvmx_helper_ports_on_interface(xiface);
-	cvmx_helper_interface_mode_t mode;
-	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
-	int interface = xi.interface;
-	int node = xi.node;
-
-	mode = cvmx_helper_interface_get_mode(xiface);
-
-	__cvmx_bgx_common_init(xiface);
-	for (index = 0; index < num_ports; index++) {
-		int res = __cvmx_helper_bgx_xaui_init(index, xiface);
-		if (res == -1) {
-			cvmx_dprintf("Failed to enable XAUI for BGX(%d,%d)\n", interface, index);
-			return res;
-		}
-		smu_tx_thresh.u64 = 0;
-		if (mode == CVMX_HELPER_INTERFACE_MODE_XLAUI
-		    || mode == CVMX_HELPER_INTERFACE_MODE_XFI)
-			smu_tx_thresh.s.cnt = 0x100;
-		else if (num_ports == 2)
-			smu_tx_thresh.s.cnt = 0x3ff;
-		else
-			smu_tx_thresh.s.cnt = 0x7ff;
-		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_THRESH(index, interface),
-					smu_tx_thresh.u64);
+	int lane;
+	cvmx_gserx_lanex_rx_misc_ovrrd_t misc_ovrrd;
+	cvmx_gserx_lanex_pcs_ctlifc_2_t ctlifc_2;
+
+	/* Errata #20844
+	  2) When a link down event is registered, write the following
+	     register across all lanes twice. */
+	for (lane=0; lane<4; lane++) {
+        	misc_ovrrd.u64 = cvmx_read_csr_node(node, CVMX_GSERX_LANEX_RX_MISC_OVRRD(lane, qlm));
+        	misc_ovrrd.s.cfg_rx_eie_det_ovrrd_en = 1;
+        	misc_ovrrd.s.cfg_rx_eie_det_ovrrd_val = 0;
+        	cvmx_write_csr_node(node, CVMX_GSERX_LANEX_RX_MISC_OVRRD(lane, qlm), misc_ovrrd.u64);
+	}
 
-		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
-		cmr_config.s.enable = 1;
-		cmr_config.s.data_pkt_tx_en = 1;
-		cmr_config.s.data_pkt_rx_en = 1;
-		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+	for (lane=0; lane<4; lane++) {
+        	misc_ovrrd.u64 = cvmx_read_csr_node(node, CVMX_GSERX_LANEX_RX_MISC_OVRRD(lane, qlm));
+        	misc_ovrrd.s.cfg_rx_eie_det_ovrrd_en = 1;
+        	misc_ovrrd.s.cfg_rx_eie_det_ovrrd_val = 1;
+        	cvmx_write_csr_node(node, CVMX_GSERX_LANEX_RX_MISC_OVRRD(lane, qlm), misc_ovrrd.u64);
+        	ctlifc_2.u64 = cvmx_read_csr_node(node, CVMX_GSERX_LANEX_PCS_CTLIFC_2(lane, qlm));
+        	ctlifc_2.s.ctlifc_ovrrd_req = 1;
+        	cvmx_write_csr_node(node, CVMX_GSERX_LANEX_PCS_CTLIFC_2(lane, qlm), ctlifc_2.u64);
 	}
-	return 0;
 }
 
+
 static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 {
 	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
 	int interface = xi.interface;
 	int node = xi.node;
-	cvmx_bgxx_spux_br_status1_t spu_status1;
+	cvmx_bgxx_spux_status1_t spu_status1;
 	cvmx_bgxx_spux_status2_t spu_status2;
 	cvmx_bgxx_spux_int_t spu_int;
 	cvmx_bgxx_spux_misc_control_t spu_misc_control;
 	cvmx_helper_interface_mode_t mode;
+	int qlm = cvmx_qlm_interface(xiface);
 
 	mode = cvmx_helper_interface_get_mode(xiface);
 
@@ -1024,6 +1033,7 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 			if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BR_STATUS1(index, interface),
 					  cvmx_bgxx_spux_br_status1_t, blk_lock, ==, 1, 10000))
 				cvmx_dprintf("ERROR: %d:BGX%d:%d: BASE-R PCS block not locked\n", node, interface, index);
+				 __link_errata_20844(qlm, node);
                 		return -1;
 		} else {
 			/* (5) Check to make sure that the link appears up and stable. */
@@ -1031,6 +1041,7 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 			if (CVMX_WAIT_FOR_FIELD64_NODE(node, CVMX_BGXX_SPUX_BX_STATUS(index, interface),
 				  cvmx_bgxx_spux_bx_status_t, alignd, ==, 1, 10000)) {
 				cvmx_dprintf("ERROR: %d:BGX%d:%d: PCS not aligned\n", node, interface, index);
+				 __link_errata_20844(qlm, node);
 				return -1;
 			}
 		}
@@ -1109,6 +1120,47 @@ static int __cvmx_helper_bgx_xaui_link_init(int index, int xiface)
 	return 0;
 }
 
+int __cvmx_helper_bgx_xaui_enable(int xiface)
+{
+	//cvmx_bgxx_smux_tx_append_t smu_tx_append;
+	cvmx_bgxx_smux_tx_thresh_t smu_tx_thresh;
+	cvmx_bgxx_cmrx_config_t cmr_config;
+	int index;
+	int num_ports = cvmx_helper_ports_on_interface(xiface);
+	cvmx_helper_interface_mode_t mode;
+	struct cvmx_xiface xi = cvmx_helper_xiface_to_node_interface(xiface);
+	int interface = xi.interface;
+	int node = xi.node;
+
+	mode = cvmx_helper_interface_get_mode(xiface);
+
+	__cvmx_bgx_common_init(xiface);
+	for (index = 0; index < num_ports; index++) {
+		int res = __cvmx_helper_bgx_xaui_init(index, xiface);
+		if (res == -1) {
+			cvmx_dprintf("Failed to enable XAUI for BGX(%d,%d)\n", interface, index);
+			return res;
+		}
+		smu_tx_thresh.u64 = 0;
+		if (mode == CVMX_HELPER_INTERFACE_MODE_XLAUI
+		    || mode == CVMX_HELPER_INTERFACE_MODE_XFI)
+			smu_tx_thresh.s.cnt = 0x100;
+		else if (num_ports == 2)
+			smu_tx_thresh.s.cnt = 0x3ff;
+		else
+			smu_tx_thresh.s.cnt = 0x7ff;
+		cvmx_write_csr_node(node, CVMX_BGXX_SMUX_TX_THRESH(index, interface),
+					smu_tx_thresh.u64);
+
+		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface));
+		cmr_config.s.enable = 1;
+		cmr_config.s.data_pkt_tx_en = 1;
+		cmr_config.s.data_pkt_rx_en = 1;
+		cvmx_write_csr_node(node, CVMX_BGXX_CMRX_CONFIG(index, interface), cmr_config.u64);
+	}
+	return 0;
+}
+
 cvmx_helper_link_info_t __cvmx_helper_bgx_xaui_link_get(int xipd_port)
 {
 	int xiface = cvmx_helper_get_interface_num(xipd_port);
@@ -1117,7 +1169,7 @@ cvmx_helper_link_info_t __cvmx_helper_bgx_xaui_link_get(int xipd_port)
 	int interface = xi.interface;
 	int node = xi.node;
 	int index = cvmx_helper_get_interface_index_num(xp.port);
-	cvmx_bgxx_spux_br_status1_t spu_status1;
+	cvmx_bgxx_spux_status1_t spu_status1;
 	cvmx_helper_link_info_t result;
 
 	result.u64 = 0;
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
index 13b8cf7..f86fc96 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-board.c
@@ -558,7 +558,7 @@ int __cvmx_helper_78xx_parse_phy(struct cvmx_phy_info *phy_info, int ipd_port)
 		}
 		phy = cvmx_helper_get_phy_fdt_node_offset(xiface, index);
 		if (phy < 0) {
-			cvmx_printf("%s: Cannot find PHY node in device tree\n", __func__);
+			//cvmx_dprintf("%s: Cannot find PHY node in device tree\n", __func__);
 			return -1;
 		}
 	}
@@ -1834,8 +1834,8 @@ static int __switch_mdio_mux(int ipd_port, const cvmx_phy_info_t *phy_info)
 			old_mux = __set_twsi_mux(phy_info->gpio_parent_mux_twsi,
 					         1 << phy_info->gpio_parent_mux_select);
 			if (old_mux < 0) {
-				cvmx_dprintf("%s: Error: could not read old MUX value for port %d\n",
-					     __func__, ipd_port);
+				/*cvmx_dprintf("%s: Error: could not read old MUX value for port %d\n",
+					     __func__, ipd_port); */
 				return -1;
 			}
 		}
@@ -1880,8 +1880,8 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 
 	if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
 		if (__cvmx_helper_78xx_parse_phy(&phy_info, ipd_port)) {
-			cvmx_printf("Error parsing PHY info for 78xx for ipd port %d\n",
-				    ipd_port);
+			/*cvmx_dprintf("Error parsing PHY info for 78xx for ipd port %d\n",
+				    ipd_port); */
 		}
 	} else if (__get_phy_info_from_dt(&phy_info, ipd_port) < 0) {
 		/* If we can't get the PHY info from the device tree then try
@@ -1899,8 +1899,8 @@ cvmx_helper_link_info_t __cvmx_helper_board_link_get_from_dt(int ipd_port)
 	}
 
 	if (phy_info.phy_addr < 0) {
-		cvmx_dprintf("%s: phy address invalid for port %d\n",
-			     __func__, ipd_port);
+		/*cvmx_dprintf("%s: phy address invalid for port %d\n",
+			     __func__, ipd_port); */
 		return result;
 	}
 
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
index cbd4bd5..9f7f1b9 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-pki.c
@@ -688,7 +688,7 @@ int cvmx_helper_pki_set_gbl_schd(int node, struct cvmx_pki_global_schd *gblsch)
                 cvmx_helper_fpa3_add_aura_to_pool(node, gblsch->pool, &gblsch->aura,
                                 gblsch->aura_buff_cnt, NULL, gblsch->aura_name);
                 if (pki_helper_debug)
-                        cvmx_dprintf("aura alloced is %d\n", gblsch->pool);
+                        cvmx_dprintf("aura alloced is %d\n", gblsch->aura);
 
         }
         if (gblsch->setup_sso_grp) {
@@ -699,7 +699,7 @@ int cvmx_helper_pki_set_gbl_schd(int node, struct cvmx_pki_global_schd *gblsch)
                 }
                 gblsch->sso_grp = rs;
                 if (pki_helper_debug)
-                        cvmx_dprintf("pki-helper:qos: sso grp alloced is %d\n", gblsch->sso_grp);
+                        cvmx_dprintf("pki-helper:gbl: sso grp alloced is %d\n", gblsch->sso_grp);
         }
         return 0;
 }
diff --git a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
index 56a68ee..ce7cff3 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-helper-util.c
@@ -839,8 +839,7 @@ int cvmx_helper_get_ipd_port(int xiface, int index)
 		if (port_map[xi.interface].type == GMII) {
 			cvmx_helper_interface_mode_t mode;
 			mode = cvmx_helper_interface_get_mode(xiface);
-			if (mode == CVMX_HELPER_INTERFACE_MODE_XAUI ||
-			    mode == CVMX_HELPER_INTERFACE_MODE_RXAUI) {
+			if (mode == CVMX_HELPER_INTERFACE_MODE_XAUI) {
 				ipd_port += port_map[xi.interface].ipd_port_adj;
 				return ipd_port;
 			} else
diff --git a/arch/mips/cavium-octeon/executive/cvmx-pko3.c b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
index c9a6fe4..302bee4 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-pko3.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-pko3.c
@@ -931,6 +931,45 @@ void cvmx_pko3_dq_options(unsigned node, unsigned dq, bool min_pad)
 	cvmx_write_csr_node(node, CVMX_PKO_PDM_DQX_MINPAD(dq), reg.u64);
 }
 
+/**
+ * Get number of PKO internal buffers available
+ *
+ * This function may be used to throttle output processing
+ * when the PKO runs out of internal buffers, to avoid discarding
+ * of packets or returning error results from transmission function.
+ *
+ * Returns negative numbers on error, positive number ti nidicate the
+ * number of buffers available, or 0 when no more buffers are available.
+ *
+ * @INTERNAL
+ */
+int cvmx_pko3_internal_buffer_count(unsigned node)
+{
+	cvmx_pko_dpfi_fpa_aura_t pko_aura;
+	unsigned laura, pool;
+	long long avail1, avail2;
+
+	/* get the aura number in pko, use aura node from parameter */
+	pko_aura.u64 = cvmx_read_csr_node(node, CVMX_PKO_DPFI_FPA_AURA);
+	laura = pko_aura.s.laura;
+
+	/* form here on, node is the AURA node */
+	node = pko_aura.s.node;
+
+	/* get the POOL number for this AURA */
+	pool = cvmx_read_csr_node(node, CVMX_FPA_AURAX_POOL(laura));
+
+	avail1 = cvmx_read_csr_node(node, CVMX_FPA_POOLX_AVAILABLE(pool));
+
+	avail2 = cvmx_read_csr_node(node, CVMX_FPA_AURAX_CNT_LIMIT(laura)) -
+		cvmx_read_csr_node(node, CVMX_FPA_AURAX_CNT(laura));
+
+	if (avail1 < avail2)
+		return avail1;
+
+	return avail2;
+}
+
 /******************************************************************************
 *
 * New PKO3 API - Experimental
diff --git a/arch/mips/cavium-octeon/executive/cvmx-qlm.c b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
index e1a8ad4..030b0e2 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-qlm.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-qlm.c
@@ -42,7 +42,7 @@
  *
  * Helper utilities for qlm.
  *
- * <hr>$Revision: 97444 $<hr>
+ * <hr>$Revision: 97979 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -84,7 +84,7 @@ DECLARE_GLOBAL_DATA_PTR;
 #define R_8G_REFCLK100              0x2
 #define R_125G_REFCLK15625_KX       0x3
 #define R_3125G_REFCLK15625_XAUI    0x4
-#define R_103215G_REFCLK15625_KR    0x5
+#define R_103125G_REFCLK15625_KR    0x5
 #define R_125G_REFCLK15625_SGMII    0x6
 #define R_5G_REFCLK15625_QSGMII     0x7
 #define R_625G_REFCLK15625_RXAUI    0x8
@@ -776,7 +776,7 @@ int cvmx_qlm_get_gbaud_mhz(int qlm)
 	} else if (OCTEON_IS_MODEL(OCTEON_CN78XX)) {
 		cvmx_gserx_lane_mode_t lane_mode;
 		cvmx_gserx_cfg_t cfg;
-		if (qlm < 8)
+		if (qlm >= 8)
 			return -1;	/* FIXME for OCI */
 		/* Check if QLM is configured */
 		cfg.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm));
@@ -843,8 +843,8 @@ int cvmx_qlm_get_gbaud_mhz(int qlm)
 				return 1250;
 			case R_3125G_REFCLK15625_XAUI:
 				return 3125;
-			case R_103215G_REFCLK15625_KR:
-				return 10321;
+			case R_103125G_REFCLK15625_KR:
+				return 10312;
 			case R_125G_REFCLK15625_SGMII:
 				return 1250;
 			case R_5G_REFCLK15625_QSGMII:
@@ -1272,33 +1272,17 @@ enum cvmx_qlm_mode cvmx_qlm_get_mode_cn78xx(int node, int qlm)
 	} else if (gserx_cfg.s.ila) {
 		return CVMX_QLM_MODE_ILK;
 	} else if (gserx_cfg.s.bgx) {
-		cvmx_gserx_lane_mode_t lane_mode;
-		lane_mode.u64 = cvmx_read_csr_node(node, CVMX_GSERX_LANE_MODE(qlm));
-		switch(lane_mode.s.lmode) {
-		case 0x0: /* R_25G_REFCLK100 */
-		case 0x1: /* R_5G_REFCLK100 */
-		case 0x2: /* R_8G_REFCLK100 */
-		case 0x3: /* R_125G_REFCLK15625_KX */
-			return CVMX_QLM_MODE_DISABLED;
-		case 0x4: /* R_3125G_REFCLK15625_XAUI */
-			return CVMX_QLM_MODE_XAUI;
-		case 0x5: /* R_103215G_REFCLK15625_KR */
-			if (gserx_cfg.s.bgx_quad)
-				return CVMX_QLM_MODE_XLAUI;
-			else
-				return CVMX_QLM_MODE_XFI;
-		case 0x6: /* R_125G_REFCLK15625_SGMII */
-			return CVMX_QLM_MODE_SGMII;
-		case 0x7: /* R_5G_REFCLK15625_QSGMII */
-			return CVMX_QLM_MODE_DISABLED;
-		case 0x8: /* R_625G_REFCLK15625_RXAUI */
-			return CVMX_QLM_MODE_RXAUI;
-		case 0x9: /* R_25G_REFCLK125 */
-		case 0xa: /* R_5G_REFCLK125 */
-		case 0xb: /* R_8G_REFCLK125 */
-			return CVMX_QLM_MODE_DISABLED;
-		default:
-			return CVMX_QLM_MODE_DISABLED;
+		cvmx_bgxx_cmrx_config_t cmr_config;
+		int bgx = (qlm > 2) ? (qlm - 2) : qlm;
+		
+		cmr_config.u64 = cvmx_read_csr_node(node, CVMX_BGXX_CMRX_CONFIG(0, bgx));
+		switch(cmr_config.s.lmac_type) {
+		case 0: return CVMX_QLM_MODE_SGMII;
+		case 1:	return CVMX_QLM_MODE_XAUI;
+		case 2:	return CVMX_QLM_MODE_RXAUI;
+		case 3:	return CVMX_QLM_MODE_XFI;
+		case 4:	return CVMX_QLM_MODE_XLAUI;
+		default: return CVMX_QLM_MODE_DISABLED;
 		}
 	} else
 		return CVMX_QLM_MODE_DISABLED;
@@ -1325,7 +1309,7 @@ int cvmx_qlm_measure_clock_cn78xx(int qlm)
 	cvmx_gserx_refclk_sel_t refclk_sel;
 	cvmx_gserx_lane_mode_t lane_mode;
 
-	if (qlm < 8)
+	if (qlm >= 8)
 		return -1; /* FIXME for OCI */
 
 	cfg.u64 = cvmx_read_csr(CVMX_GSERX_CFG(qlm));
@@ -1350,7 +1334,7 @@ int cvmx_qlm_measure_clock_cn78xx(int qlm)
 		return REF_156MHZ;
 	case R_3125G_REFCLK15625_XAUI:
 		return REF_156MHZ;
-	case R_103215G_REFCLK15625_KR:
+	case R_103125G_REFCLK15625_KR:
 		return REF_156MHZ;
 	case R_125G_REFCLK15625_SGMII:
 		return REF_156MHZ;
diff --git a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
index afb64b8..81c56ab 100644
--- a/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-bgxx-defs.h
@@ -1906,8 +1906,11 @@ static inline uint64_t CVMX_BGXX_SPU_SDSX_STATES(unsigned long offset, unsigned
  *
  * Logical MAC/PCS configuration registers; one per LMAC. The maximum number of LMACs (and
  * maximum LMAC ID) that can be enabled by these registers is limited by
- * BGX(0..5)_CMR_RX_LMACS[LMACS] and BGX(0..5)_CMR_TX_LMACS[LMACS]. When multiple LMACs are
+ * BGX()_CMR_RX_LMACS[LMACS] and BGX()_CMR_TX_LMACS[LMACS]. When multiple LMACs are
  * enabled, they must be configured with the same [LMAC_TYPE] value.
+ *
+ * INTERNAL:
+ * <pre>
  * Typical configurations:
  *   ---------------------------------------------------------------------------
  *   Configuration           LMACS  Register             [ENABLE]    [LMAC_TYPE]
@@ -1937,6 +1940,7 @@ static inline uint64_t CVMX_BGXX_SPU_SDSX_STATES(unsigned long offset, unsigned
  *                                  BGXn_CMR2_CONFIG     1           0
  *                                  BGXn_CMR3_CONFIG     1           0
  *   ---------------------------------------------------------------------------
+ * </pre>
  */
 union cvmx_bgxx_cmrx_config {
 	uint64_t u64;
@@ -1966,36 +1970,37 @@ union cvmx_bgxx_cmrx_config {
                                                          LMACs 2 and 3. Setting it will pipe the LMAC to and from the MIX interface (LMAC0 to/from
                                                          MIX0, LMAC1 to/from MIX1). LMAC_TYPE must be 0 (SGMII) then this bit is set. Note that at
                                                          most one BGX can be attached to each of MIX0 and MIX1, i.e. at most one
-                                                         BGX(0..5)_CMR0_CONFIG[MIX_EN] bit and one BGX(0..5)_CMR1_CONFIG[MIX_EN] bit can be set.
+                                                         BGX(0..5)_CMR(0)_CONFIG[MIX_EN] bit and one BGX(0..5)_CMR(1)_CONFIG[MIX_EN] bit can be
+                                                         set.
                                                          This field must be programmed to its final value before [ENABLE] is set, and must not
                                                          be changed when [ENABLE]=1. */
-	uint64_t lmac_type                    : 3;  /**< Logical MAC/PCS Type:
-                                                           ----------+----------------------------------------------------------
-                                                           LMAC_TYPE | Name         Description                NUM_PCS_LANES
-                                                           ----------+----------------------------------------------------------
-                                                           0         | SGMII      SGMII/1000BASE-X             1
-                                                           1         | XAUI       10GBASE-X/XAUI or DXAUI      4
-                                                           2         | RXAUI      Reduced XAUI                 2
-                                                           3         | 10G_R      10GBASE-R                    1
-                                                           4         | 40G_R      40GBASE-R                    4
-                                                           Other     | -          Reserved                     -
-                                                           ----------+----------------------------------------------------------
-                                                         NUM_PCS_LANES specifies the number of of PCS lanes that are valid for
-                                                         each type. Each valid PCS lane is mapped to a physical serdes lane
+	uint64_t lmac_type                    : 3;  /**< Logical MAC/PCS/prt type:
+                                                         <pre>
+                                                           LMAC_TYPE  Name       Description            NUM_PCS_LANES
+                                                           ----------------------------------------------------------
+                                                           0x0        SGMII      SGMII/1000BASE-X             1
+                                                           0x1        XAUI       10GBASE-X/XAUI or DXAUI      4
+                                                           0x2        RXAUI      Reduced XAUI                 2
+                                                           0x3        10G_R      10GBASE-R                    1
+                                                           0x4        40G_R      40GBASE-R                    4
+                                                           Other      --         Reserved                     -
+                                                         </pre>
+                                                         NUM_PCS_LANES specifies the number of PCS lanes that are valid for
+                                                         each type. Each valid PCS lane is mapped to a physical SerDes lane
                                                          based on the programming of [LANE_TO_SDS].
                                                          This field must be programmed to its final value before [ENABLE] is set, and must not
                                                          be changed when [ENABLE]=1. */
-	uint64_t lane_to_sds                  : 8;  /**< PCS Lane to Serdes Mapping.
+	uint64_t lane_to_sds                  : 8;  /**< PCS lane-to-SerDes Mapping.
                                                          This is an array of 2-bit values that map each logical PCS Lane to a
                                                          physical SerDes lane, as follows:
-                                                           ----------+----------------------------------------------------------
-                                                           Bits     | Description                     Reset value
-                                                           ----------+----------------------------------------------------------
-                                                           <7:6>    | PCS Lane 3 SerDes ID            0x3
-                                                           <5:4>    | PCS Lane 2 SerDes ID            0x2
-                                                           <3:2>    | PCS Lane 1 SerDes ID            0x1
-                                                           <1:0>    | PCS Lane 0 SerDes ID            0x0
-                                                           ----------+----------------------------------------------------------
+                                                         <pre>
+                                                           Bits    Description            Reset value
+                                                           ------------------------------------------
+                                                           <7:6>   PCS Lane 3 SerDes ID       0x3
+                                                           <5:4>   PCS Lane 2 SerDes ID       0x2
+                                                           <3:2>   PCS Lane 1 SerDes ID       0x1
+                                                           <1:0>   PCS Lane 0 SerDes ID       0x0
+                                                         </pre>
                                                          PCS lanes 0 through NUM_PCS_LANES-1 are valid, where NUM_PCS_LANES is a function of the
                                                          logical MAC/PCS type. (See definition of LMAC_TYPE.) For example, when LMAC_TYPE = RXAUI,
                                                          then NUM_PCS_LANES = 2, PCS lanes 0 and 1 valid and the associated physical SerDes lanes
@@ -2005,9 +2010,9 @@ union cvmx_bgxx_cmrx_config {
                                                          side. This is not necessarily the order in which PCS lanes receive data because 802.3
                                                          allows multilane BASE-R receive lanes to be reordered. When a lane (called service
                                                          interface in 802.3ba-2010) has achieved alignment marker lock on the receive side (i.e.
-                                                         the associated BGX(0..5)_SPU(0..3)_BR_ALGN_STATUS[MARKER_LOCK] = 1), then the actual
+                                                         the associated BGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK] = 1), then the actual
                                                          detected RX PCS lane number is recorded in the corresponding
-                                                         BGX(0..5)_SPU(0..3)_BR_LANE_MAP[LNx_MAPPING].
+                                                         BGX()_SPU()_BR_LANE_MAP[LNx_MAPPING].
                                                          This field must be programmed to its final value before [ENABLE] is set, and must not
                                                          be changed when [ENABLE]=1. */
 #else
@@ -2051,7 +2056,7 @@ typedef union cvmx_bgxx_cmrx_int cvmx_bgxx_cmrx_int_t;
 /**
  * cvmx_bgx#_cmr#_prt_cbfc_ctl
  *
- * See XOFF definition listed under BGX(0..5)_SMU(0..3)_CBFC_CTL.
+ * See XOFF definition listed under BGX()_SMU()_CBFC_CTL.
  *
  */
 union cvmx_bgxx_cmrx_prt_cbfc_ctl {
@@ -2059,8 +2064,8 @@ union cvmx_bgxx_cmrx_prt_cbfc_ctl {
 	struct cvmx_bgxx_cmrx_prt_cbfc_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t phys_bp                      : 16; /**< When BGX(0..5)_SMU(0..3)_CBFC_CTL[RX_EN] is set and the hardware is backpressuring any
-                                                         LMACs (from either PFC/CBFC PAUSE packets or BGX(0..5)_CMR(0..3)_TX_OVR_BP[TX_CHAN_BP])
+	uint64_t phys_bp                      : 16; /**< When BGX()_SMU()_CBFC_CTL[RX_EN] is set and the hardware is backpressuring any
+                                                         LMACs (from either PFC/CBFC PAUSE packets or BGX()_CMR()_TX_OVR_BP[TX_CHAN_BP])
                                                          and all LMACs indicated by PHYS_BP are backpressured, simulate physical backpressure by
                                                          deferring all packets on the transmitter. */
 	uint64_t reserved_0_15                : 16;
@@ -2083,13 +2088,13 @@ union cvmx_bgxx_cmrx_rx_adr_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
 	uint64_t cam_accept                   : 1;  /**< Allow or deny DMAC address filter.
-                                                         0 = Reject the packet on DMAC CAM address match
-                                                         1 = Accept the packet on DMAC CAM address match */
+                                                         0 = Reject the packet on DMAC CAM address match.
+                                                         1 = Accept the packet on DMAC CAM address match. */
 	uint64_t mcst_mode                    : 2;  /**< Multicast mode.
-                                                         0x0 = Force reject all multicast packets
-                                                         0x1 = Force accept all multicast packets
-                                                         0x2 = Use the address filter CAM
-                                                         0x3 = Reserved */
+                                                         0x0 = Force reject all multicast packets.
+                                                         0x1 = Force accept all multicast packets.
+                                                         0x2 = Use the address filter CAM.
+                                                         0x3 = Reserved. */
 	uint64_t bcst_accept                  : 1;  /**< Allow or deny broadcast packets.
                                                          0 = Reject all broadcast packets.
                                                          1 = Accept all broadcast Packets. */
@@ -2155,12 +2160,12 @@ union cvmx_bgxx_cmrx_rx_bp_on {
 	uint64_t reserved_12_63               : 52;
 	uint64_t mark                         : 12; /**< High watermark. Buffer depth in multiple of 16-bytes, at which BGX will
                                                          assert backpressure for each individual LMAC.  MARK must satisfy:
-                                                         BGX(0..5)_CMR(0..3)_RX_BP_OFF[MARK] <= MARK <
-                                                         (FIFO_SIZE - BGX(0..5)_CMR(0..3)_RX_BP_DROP[MARK]).
+                                                           BGX()_CMR()_RX_BP_OFF[MARK] <= MARK <
+                                                           (FIFO_SIZE - BGX()_CMR()_RX_BP_DROP[MARK]).
                                                          A value of 0x0 immediately asserts backpressure.
                                                          The recommended value is 1/4th the size of the per-LMAC RX FIFO_SIZE as
-                                                         determined by BGX(0..5)_CMR_RX_LMACS[LMACS]. For example in SGMII mode with
-                                                         four LMACs of type SGMII, where BGX(0..5)_CMR_RX_LMACS[LMACS]=0x4, there is
+                                                         determined by BGX()_CMR_RX_LMACS[LMACS]. For example in SGMII mode with
+                                                         four LMACs of type SGMII, where BGX()_CMR_RX_LMACS[LMACS]=0x4, there is
                                                          16 KB of buffering. The recommended 1/4th size of that 16 KB is 4 KB, which
                                                          in units of 16 bytes gives MARK = 0x100 (the reset value). */
 #else
@@ -2181,8 +2186,8 @@ union cvmx_bgxx_cmrx_rx_bp_status {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t bp                           : 1;  /**< Per-LMAC backpressure status.
-                                                         0 = LMAC is not backpressured
-                                                         1 = LMAC is backpressured */
+                                                         0 = LMAC is not backpressured.
+                                                         1 = LMAC is backpressured. */
 #else
 	uint64_t bp                           : 1;
 	uint64_t reserved_1_63                : 63;
@@ -2225,7 +2230,7 @@ union cvmx_bgxx_cmrx_rx_id_map {
                                                          MACs.
                                                          The RID for this LMAC must be constrained such that it does not overlap with any other MAC
                                                          in the system. Its reset value has been chosen such that this condition is satisfied:
-                                                         RID reset value = 4*(BGX_ID + 1) + LMAC_ID
+                                                         _ RID reset value = 4*(BGX_ID + 1) + LMAC_ID
                                                          Changes to RID must only occur when the LMAC is quiescent (i.e. the LMAC receive interface
                                                          is down and the RX FIFO is empty). */
 	uint64_t pknd                         : 8;  /**< Port kind for this LMAC.  Only bits [5:0] are used.  Bits [7:6] are not used and should
@@ -2248,10 +2253,10 @@ union cvmx_bgxx_cmrx_rx_logl_xoff {
 	struct cvmx_bgxx_cmrx_rx_logl_xoff_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t xoff                         : 16; /**< Together with BGX(0..5)_CMR(0..3)_RX_LOGL_XON, defines type of channel backpressure to
+	uint64_t xoff                         : 16; /**< Together with BGX()_CMR()_RX_LOGL_XON, defines type of channel backpressure to
                                                          apply to the SMU. Do not write when HiGig2 is enabled. Writing 1 sets the same physical
-                                                         register as that which is cleared by XON. An XOFF value of 1 will cause a backpressure on
-                                                         SMU. */
+                                                         register as that which is cleared by BGX()_CMR()_RX_LOGL_XON[XON]. An XOFF value
+                                                         of 1 will cause a backpressure on SMU. */
 #else
 	uint64_t xoff                         : 16;
 	uint64_t reserved_16_63               : 48;
@@ -2269,10 +2274,10 @@ union cvmx_bgxx_cmrx_rx_logl_xon {
 	struct cvmx_bgxx_cmrx_rx_logl_xon_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t xon                          : 16; /**< Together with BGX(0..5)_CMR(0..3)_RX_LOGL_XOFF, defines type of channel backpressure to
+	uint64_t xon                          : 16; /**< Together with BGX()_CMR()_RX_LOGL_XOFF, defines type of channel backpressure to
                                                          apply. Do not write when HiGig2 is enabled. Writing 1 clears the same physical register as
-                                                         that which is set by XOFF. An XON value of 1 means only PKI channel BP can cause a
-                                                         backpressure on SMU. */
+                                                         that which is set by BGX()_CMR()_RX_LOGL_XOFF[XOFF]. An XON value of 1 will
+                                                         cause a backpressure on SMU. */
 #else
 	uint64_t xon                          : 16;
 	uint64_t reserved_16_63               : 48;
@@ -2315,7 +2320,7 @@ union cvmx_bgxx_cmrx_rx_stat0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t cnt                          : 48; /**< Count of received packets. CNT will wrap and is cleared if LMAC is disabled with
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t cnt                          : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2337,7 +2342,7 @@ union cvmx_bgxx_cmrx_rx_stat1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t cnt                          : 48; /**< Octet count of received packets. CNT will wrap and is cleared if LMAC is disabled with
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t cnt                          : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2352,10 +2357,10 @@ typedef union cvmx_bgxx_cmrx_rx_stat1 cvmx_bgxx_cmrx_rx_stat1_t;
  *
  * These registers provide a count of all packets received that were recognized as flow-control
  * or PAUSE packets. PAUSE packets with any kind of error are counted in
- * BGX(0..5)_CMR(0..3)_RX_STAT8 (error stats register). Pause packets can be optionally dropped
- * or forwarded based on BGX(0..5)_SMU(0..3)_RX_FRM_CTL[CTL_DRP]. This count increments
+ * BGX()_CMR()_RX_STAT8 (error stats register). Pause packets can be optionally dropped
+ * or forwarded based on BGX()_SMU()_RX_FRM_CTL[CTL_DRP]. This count increments
  * regardless of whether the packet is dropped. PAUSE packets are never counted in
- * BGX(0..5)_CMR(0..3)_RX_STAT0.
+ * BGX()_CMR()_RX_STAT0.
  */
 union cvmx_bgxx_cmrx_rx_stat2 {
 	uint64_t u64;
@@ -2363,7 +2368,7 @@ union cvmx_bgxx_cmrx_rx_stat2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t cnt                          : 48; /**< Count of received PAUSE packets. CNT will wrap and is cleared if LMAC is disabled with
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t cnt                          : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2385,7 +2390,7 @@ union cvmx_bgxx_cmrx_rx_stat3 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t cnt                          : 48; /**< Octet count of received PAUSE packets. CNT will wrap and is cleared if LMAC is disabled
-                                                         with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t cnt                          : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2400,9 +2405,9 @@ typedef union cvmx_bgxx_cmrx_rx_stat3 cvmx_bgxx_cmrx_rx_stat3_t;
  *
  * These registers provide a count of all packets received that were dropped by the DMAC filter.
  * Packets that match the DMAC are dropped and counted here regardless of whether they were ERR
- * packets, but does not include those reported in BGX(0..5)_CMR(0..3)_RX_STAT6. These packets
- * are never counted in BGX(0..5)_CMR(0..3)_RX_STAT0. Eight-byte packets as the result of
- * truncation or other means are not dropped by CN78XX and will never appear in this count.
+ * packets, but does not include those reported in BGX()_CMR()_RX_STAT6. These packets
+ * are never counted in BGX()_CMR()_RX_STAT0. Eight-byte packets as the result of
+ * truncation or other means are not dropped by CNXXXX and will never appear in this count.
  */
 union cvmx_bgxx_cmrx_rx_stat4 {
 	uint64_t u64;
@@ -2410,7 +2415,7 @@ union cvmx_bgxx_cmrx_rx_stat4 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t cnt                          : 48; /**< Count of filtered DMAC packets. CNT will wrap and is cleared if LMAC is disabled with
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t cnt                          : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2432,7 +2437,7 @@ union cvmx_bgxx_cmrx_rx_stat5 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t cnt                          : 48; /**< Octet count of filtered DMAC packets. CNT will wrap and is cleared if LMAC is disabled
-                                                         with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t cnt                          : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2456,7 +2461,7 @@ union cvmx_bgxx_cmrx_rx_stat6 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t cnt                          : 48; /**< Count of dropped packets. CNT will wrap and is cleared if LMAC is disabled with
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t cnt                          : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2478,7 +2483,7 @@ union cvmx_bgxx_cmrx_rx_stat7 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t cnt                          : 48; /**< Octet count of dropped packets. CNT will wrap and is cleared if LMAC is disabled with
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t cnt                          : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2494,9 +2499,12 @@ typedef union cvmx_bgxx_cmrx_rx_stat7 cvmx_bgxx_cmrx_rx_stat7_t;
  * These registers provide a count of all packets received with some error that were not dropped
  * either due to the DMAC filter or lack of room in the receive FIFO.
  * This does not include packets which were counted in
- * BGX(0..5)_CMR(0..3)_RX_STAT2, BGX(0..5)_CMR(0..3)_RX_STAT4 nor
- * BGX(0..5)_CMR(0..3)_RX_STAT6.
+ * BGX()_CMR()_RX_STAT2, BGX()_CMR()_RX_STAT4 nor
+ * BGX()_CMR()_RX_STAT6.
+ *
  * Which statistics are updated on control packet errors and drops are shown below:
+ *
+ * <pre>
  * if dropped [
  *   if !errored STAT8
  *   if overflow STAT6
@@ -2506,6 +2514,7 @@ typedef union cvmx_bgxx_cmrx_rx_stat7 cvmx_bgxx_cmrx_rx_stat7_t;
  *   if errored STAT2
  *   else STAT8
  * ]
+ * </pre>
  */
 union cvmx_bgxx_cmrx_rx_stat8 {
 	uint64_t u64;
@@ -2513,7 +2522,7 @@ union cvmx_bgxx_cmrx_rx_stat8 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t cnt                          : 48; /**< Count of error packets. CNT will wrap and is cleared if LMAC is disabled with
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t cnt                          : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2621,7 +2630,8 @@ union cvmx_bgxx_cmrx_tx_ovr_bp {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t tx_chan_bp                   : 16; /**< Per-channel backpressure status sent to PKO.
-                                                         1 = channel should be backpressured, 0 = channel is available */
+                                                         0 = channel is available.
+                                                         1 = channel should be backpressured. */
 #else
 	uint64_t tx_chan_bp                   : 16;
 	uint64_t reserved_16_63               : 48;
@@ -2640,9 +2650,9 @@ union cvmx_bgxx_cmrx_tx_stat0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t xscol                        : 48; /**< Number of packets dropped (never successfully sent) due to excessive collision. Defined by
-                                                         BGX(0..5)_GMP_GMI_TX_COL_ATTEMPT[LIMIT]. SGMII/1000Base-X half-duplex only.
+                                                         BGX()_GMP_GMI_TX_COL_ATTEMPT[LIMIT]. SGMII/1000Base-X half-duplex only.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t xscol                        : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2663,7 +2673,7 @@ union cvmx_bgxx_cmrx_tx_stat1 {
 	uint64_t xsdef                        : 48; /**< Number of packets dropped (never successfully sent) due to excessive deferral.
                                                          SGMII/1000BASE-X half-duplex only.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t xsdef                        : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2686,7 +2696,7 @@ union cvmx_bgxx_cmrx_tx_stat10 {
                                                          FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or
                                                          EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t hist4                        : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2708,8 +2718,8 @@ union cvmx_bgxx_cmrx_tx_stat11 {
                                                          all data transmitted on the wire for the given packet including packet data, pad bytes,
                                                          FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or
                                                          EXTEND cycles.
-                                                         Not cleared on read; cleared on a write with 0x0.Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t hist5                        : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2732,7 +2742,7 @@ union cvmx_bgxx_cmrx_tx_stat12 {
                                                          FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or
                                                          EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t hist6                        : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2755,7 +2765,7 @@ union cvmx_bgxx_cmrx_tx_stat13 {
                                                          PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
                                                          cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t hist7                        : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2779,7 +2789,7 @@ union cvmx_bgxx_cmrx_tx_stat14 {
                                                          assumes that the DMAC lies in the first six bytes of the packet as per the 802.3 frame
                                                          definition. If the system requires additional data before the L2 header, the MCST and BCST
                                                          counters may not reflect reality and should be ignored by software. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t bcst                         : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2803,7 +2813,7 @@ union cvmx_bgxx_cmrx_tx_stat15 {
                                                          assumes that the DMAC lies in the first six bytes of the packet as per the 802.3 frame
                                                          definition. If the system requires additional data before the L2 header, then the MCST and
                                                          BCST counters may not reflect reality and should be ignored by software. Cleared if LMAC
-                                                         is disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         is disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t mcst                         : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2823,7 +2833,7 @@ union cvmx_bgxx_cmrx_tx_stat16 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t undflw                       : 48; /**< Number of underflow packets.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t undflw                       : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2846,7 +2856,7 @@ union cvmx_bgxx_cmrx_tx_stat17 {
                                                          CTL counts the number of generated PFC frames and does not track the number of generated
                                                          HG2 messages.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t ctl                          : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2865,9 +2875,9 @@ union cvmx_bgxx_cmrx_tx_stat2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t mcol                         : 48; /**< Number of packets sent with multiple collisions. Must be less than
-                                                         BGX(0..5)_GMP_GMI_TX_COL_ATTEMPT[LIMIT]. SGMII/1000BASE-X half-duplex only.
+                                                         BGX()_GMP_GMI_TX_COL_ATTEMPT[LIMIT]. SGMII/1000BASE-X half-duplex only.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t mcol                         : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2887,7 +2897,7 @@ union cvmx_bgxx_cmrx_tx_stat3 {
 	uint64_t reserved_48_63               : 16;
 	uint64_t scol                         : 48; /**< Number of packets sent with a single collision. SGMII/1000BASE-X half-duplex only.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t scol                         : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2911,7 +2921,7 @@ union cvmx_bgxx_cmrx_tx_stat4 {
                                                          bytes, FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE
                                                          byte or EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t octs                         : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2932,7 +2942,7 @@ union cvmx_bgxx_cmrx_tx_stat5 {
 	uint64_t pkts                         : 48; /**< Number of total frames sent on the interface. Does not count octets from frames that were
                                                          truncated due to collisions in half-duplex mode.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t pkts                         : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2955,7 +2965,7 @@ union cvmx_bgxx_cmrx_tx_stat6 {
                                                          PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
                                                          cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t hist0                        : 48;
 	uint64_t reserved_48_63               : 16;
@@ -2978,7 +2988,7 @@ union cvmx_bgxx_cmrx_tx_stat7 {
                                                          PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
                                                          cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t hist1                        : 48;
 	uint64_t reserved_48_63               : 16;
@@ -3001,7 +3011,7 @@ union cvmx_bgxx_cmrx_tx_stat8 {
                                                          bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or EXTEND
                                                          cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t hist2                        : 48;
 	uint64_t reserved_48_63               : 16;
@@ -3024,7 +3034,7 @@ union cvmx_bgxx_cmrx_tx_stat9 {
                                                          FCS bytes, PAUSE bytes, and JAM bytes. The octet counts do not include PREAMBLE byte or
                                                          EXTEND cycles.
                                                          Not cleared on read; cleared on a write with 0x0. Counters will wrap. Cleared if LMAC is
-                                                         disabled with BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]=0. */
+                                                         disabled with BGX()_CMR()_CONFIG[ENABLE]=0. */
 #else
 	uint64_t hist3                        : 48;
 	uint64_t reserved_48_63               : 16;
@@ -3042,7 +3052,7 @@ union cvmx_bgxx_cmr_bad {
 	struct cvmx_bgxx_cmr_bad_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t rxb_nxl                      : 1;  /**< Receive side lmac_id > BGX_CMR_RX_LMACS */
+	uint64_t rxb_nxl                      : 1;  /**< Receive side LMAC ID > BGX()_CMR_RX_LMACS. */
 #else
 	uint64_t rxb_nxl                      : 1;
 	uint64_t reserved_1_63                : 63;
@@ -3096,14 +3106,14 @@ union cvmx_bgxx_cmr_chan_msk_and {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t msk_and                      : 64; /**< Assert physical backpressure when the backpressure channel vector combined with MSK_AND
                                                          indicates backpressure as follows:
-                                                         phys_bp_msk_and = (CHAN_VECTOR<x:y> & MSK_AND<x:y>) == MSK_AND<x:y>
-                                                         phys_bp = phys_bp_msk_or || phys_bp_msk_and
-                                                         In single LMAC configurations, x = 63, y = 0
+                                                         _ phys_bp_msk_and = (CHAN_VECTOR<x:y> & MSK_AND<x:y>) == MSK_AND<x:y>
+                                                         _ phys_bp = phys_bp_msk_or || phys_bp_msk_and
+                                                         In single LMAC configurations, x = 63, y = 0.
                                                          In multi-LMAC configurations, x/y are set as follows:
-                                                         LMAC interface 0, x = 15, y = 0
-                                                         LMAC interface 1, x = 31, y = 16
-                                                         LMAC interface 2, x = 47, y = 32
-                                                         LMAC interface 3, x = 63, y = 48 */
+                                                         _ LMAC interface 0, x = 15, y = 0.
+                                                         _ LMAC interface 1, x = 31, y = 16.
+                                                         _ LMAC interface 2, x = 47, y = 32.
+                                                         _ LMAC interface 3, x = 63, y = 48. */
 #else
 	uint64_t msk_and                      : 64;
 #endif
@@ -3121,14 +3131,14 @@ union cvmx_bgxx_cmr_chan_msk_or {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t msk_or                       : 64; /**< Assert physical backpressure when the backpressure channel vector combined with MSK_OR
                                                          indicates backpressure as follows:
-                                                         phys_bp_msk_or = (CHAN_VECTOR<x:y> & MSK_OR<x:y>) & MSK_OR<x:y>
-                                                         phys_bp = phys_bp_msk_or || phys_bp_msk_and
-                                                         In single LMAC configurations, x = 63, y = 0
+                                                         _ phys_bp_msk_or = (CHAN_VECTOR<x:y> & MSK_AND<x:y>) & MSK_OR<x:y>
+                                                         _ phys_bp = phys_bp_msk_or || phys_bp_msk_and
+                                                         In single LMAC configurations, x = 63, y = 0.
                                                          In multi-LMAC configurations, x/y are set as follows:
-                                                         LMAC interface 0, x = 15, y = 0
-                                                         LMAC interface 1, x = 31, y = 16
-                                                         LMAC interface 2, x = 47, y = 32
-                                                         LMAC interface 3, x = 63, y = 48 */
+                                                         _ LMAC interface 0, x = 15, y = 0.
+                                                         _ LMAC interface 1, x = 31, y = 16.
+                                                         _ LMAC interface 2, x = 47, y = 32.
+                                                         _ LMAC interface 3, x = 63, y = 48. */
 #else
 	uint64_t msk_or                       : 64;
 #endif
@@ -3164,22 +3174,22 @@ union cvmx_bgxx_cmr_global_config {
                                                          interface. Setting this bit to 0 does not reset the X2P interface. After PKI comes out of
                                                          reset, software should clear CMR_X2P_RESET. */
 	uint64_t bgx_clk_enable               : 1;  /**< The global clock enable for BGX. Setting this bit overrides clock enables set by
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] and BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE], essentially
+                                                         BGX()_CMR()_CONFIG[ENABLE] and BGX()_CMR()_CONFIG[LMAC_TYPE], essentially
                                                          turning on clocks for the entire BGX. Setting this bit to 0 results in not overriding
-                                                         clock enables set by BGX(0..5)_CMR(0..3)_CONFIG[ENABLE] and
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE]. */
+                                                         clock enables set by BGX()_CMR()_CONFIG[ENABLE] and
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE]. */
 	uint64_t pmux_sds_sel                 : 1;  /**< SerDes/QLM output select. Specifies which QLM output is selected as the BGX input, as
                                                          follows:
-                                                           ------+----------------+----------------
-                                                           Block | PMUX_SDS_SEL=0 | PMUX_SDS_SEL=1
-                                                           ------+----------------+----------------
-                                                           BGX0  | QLM0           | QLM2
-                                                           BGX1  | QLM1           | QLM3
-                                                           BGX2  | QLM4           | N/A
-                                                           BGX3  | QLM5           | N/A
-                                                           BGX4  | QLM6           | N/A
-                                                           BGX5  | QLM7           | N/A
-                                                           ------+----------------+---------------- */
+                                                         <pre>
+                                                           Block   PMUX_SDS_SEL=0  PMUX_SDS_SEL=1
+                                                           --------------------------------------
+                                                           BGX0:   QLM0            QLM2
+                                                           BGX1:   QLM1            QLM3
+                                                           BGX2:   QLM4            N/A
+                                                           BGX3:   QLM5            N/A
+                                                           BGX4:   QLM6            N/A
+                                                           BGX5:   QLM7            N/A
+                                                         </pre> */
 #else
 	uint64_t pmux_sds_sel                 : 1;
 	uint64_t bgx_clk_enable               : 1;
@@ -3201,22 +3211,22 @@ union cvmx_bgxx_cmr_mem_ctrl {
 	struct cvmx_bgxx_cmr_mem_ctrl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_24_63               : 40;
-	uint64_t txb_skid_synd                : 2;  /**< Syndrome to flip and generate single-bit/double-bit for TXB SKID FIFO */
-	uint64_t txb_skid_cor_dis             : 1;  /**< ECC-correction disable for the TXB SKID FIFO */
-	uint64_t txb_fif_bk1_syn              : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for TXB main bank1 */
-	uint64_t txb_fif_bk1_cdis             : 1;  /**< ECC-correction disable for the TXB main bank1 */
-	uint64_t txb_fif_bk0_syn              : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for TXB main bank0 */
-	uint64_t txb_fif_bk0_cdis             : 1;  /**< ECC-correction disable for the TXB main bank0 */
-	uint64_t rxb_skid_synd                : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for RXB SKID FIFO */
-	uint64_t rxb_skid_cor_dis             : 1;  /**< ECC-correction disable for the RXB SKID FIFO */
-	uint64_t rxb_fif_bk1_syn1             : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for RXB main bank1 srf1 */
-	uint64_t rxb_fif_bk1_cdis1            : 1;  /**< ECC-correction disable for the RXB main bank1 srf1 */
-	uint64_t rxb_fif_bk1_syn0             : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for RXB main bank1 srf0 */
+	uint64_t txb_skid_synd                : 2;  /**< Syndrome to flip and generate single-bit/double-bit for TXB SKID FIFO. */
+	uint64_t txb_skid_cor_dis             : 1;  /**< ECC-correction disable for the TXB SKID FIFO. */
+	uint64_t txb_fif_bk1_syn              : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for TXB main bank1. */
+	uint64_t txb_fif_bk1_cdis             : 1;  /**< ECC-correction disable for the TXB main bank1. */
+	uint64_t txb_fif_bk0_syn              : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for TXB main bank0. */
+	uint64_t txb_fif_bk0_cdis             : 1;  /**< ECC-correction disable for the TXB main bank0. */
+	uint64_t rxb_skid_synd                : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for RXB SKID FIFO. */
+	uint64_t rxb_skid_cor_dis             : 1;  /**< ECC-correction disable for the RXB SKID FIFO. */
+	uint64_t rxb_fif_bk1_syn1             : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for RXB main bank1 srf1. */
+	uint64_t rxb_fif_bk1_cdis1            : 1;  /**< ECC-correction disable for the RXB main bank1 srf1. */
+	uint64_t rxb_fif_bk1_syn0             : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for RXB main bank1 srf0. */
 	uint64_t rxb_fif_bk1_cdis0            : 1;  /**< ECC-correction disable for the RXB main bank1 srf0. */
-	uint64_t rxb_fif_bk0_syn1             : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for RXB main bank0 srf1 */
-	uint64_t rxb_fif_bk0_cdis1            : 1;  /**< ECC-correction disable for the RXB main bank0 srf1 */
-	uint64_t rxb_fif_bk0_syn0             : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for RXB main bank0 srf0 */
-	uint64_t rxb_fif_bk0_cdis0            : 1;  /**< ECC-correction disable for the RXB main bank0 srf0 */
+	uint64_t rxb_fif_bk0_syn1             : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for RXB main bank0 srf1. */
+	uint64_t rxb_fif_bk0_cdis1            : 1;  /**< ECC-correction disable for the RXB main bank0 srf1. */
+	uint64_t rxb_fif_bk0_syn0             : 2;  /**< Syndrome to flip and generate single-bit/double-bit error for RXB main bank0 srf0. */
+	uint64_t rxb_fif_bk0_cdis0            : 1;  /**< ECC-correction disable for the RXB main bank0 srf0. */
 #else
 	uint64_t rxb_fif_bk0_cdis0            : 1;
 	uint64_t rxb_fif_bk0_syn0             : 2;
@@ -3249,24 +3259,24 @@ union cvmx_bgxx_cmr_mem_int {
 	struct cvmx_bgxx_cmr_mem_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_18_63               : 46;
-	uint64_t smu_in_overfl                : 1;  /**< RX SMU INFIFO overflow */
-	uint64_t gmp_in_overfl                : 1;  /**< RX GMP INFIFO overflow */
-	uint64_t txb_skid_sbe                 : 1;  /**< TXB SKID FIFO single-bit error */
-	uint64_t txb_skid_dbe                 : 1;  /**< TXB SKID FIFO double-bit error */
-	uint64_t txb_fif_bk1_sbe              : 1;  /**< TXB Main FIFO Bank1 single-bit error */
-	uint64_t txb_fif_bk1_dbe              : 1;  /**< TXB Main FIFO Bank1 double-bit error */
-	uint64_t txb_fif_bk0_sbe              : 1;  /**< TXB Main FIFO Bank0 single-bit error */
-	uint64_t txb_fif_bk0_dbe              : 1;  /**< TXB Main FIFO Bank0 double-bit error */
-	uint64_t rxb_skid_sbe                 : 1;  /**< RXB SKID FIFO single-bit error */
-	uint64_t rxb_skid_dbe                 : 1;  /**< RXB SKID FIFO double-bit error */
-	uint64_t rxb_fif_bk1_sbe1             : 1;  /**< RXB main FIFO bank1 srf1 single-bit error */
-	uint64_t rxb_fif_bk1_dbe1             : 1;  /**< RXB main FIFO bank1 srf1 double-bit error */
-	uint64_t rxb_fif_bk1_sbe0             : 1;  /**< RXB main FIFO bank1 srf0 single-bit error */
-	uint64_t rxb_fif_bk1_dbe0             : 1;  /**< RXB main FIFO bank1 srf0 double-bit error */
-	uint64_t rxb_fif_bk0_sbe1             : 1;  /**< RXB main FIFO bank0 srf1 single-bit error */
-	uint64_t rxb_fif_bk0_dbe1             : 1;  /**< RXB main FIFO bank0 srf1 double-bit error */
-	uint64_t rxb_fif_bk0_sbe0             : 1;  /**< RXB main FIFO bank0 srf0 single-bit error */
-	uint64_t rxb_fif_bk0_dbe0             : 1;  /**< RXB main FIFO bank0 srf0 double-bit error */
+	uint64_t smu_in_overfl                : 1;  /**< RX SMU INFIFO overflow. */
+	uint64_t gmp_in_overfl                : 1;  /**< RX GMP INFIFO overflow. */
+	uint64_t txb_skid_sbe                 : 1;  /**< TXB SKID FIFO single-bit error. */
+	uint64_t txb_skid_dbe                 : 1;  /**< TXB SKID FIFO double-bit error. */
+	uint64_t txb_fif_bk1_sbe              : 1;  /**< TXB Main FIFO Bank1 single-bit error. */
+	uint64_t txb_fif_bk1_dbe              : 1;  /**< TXB Main FIFO Bank1 double-bit error. */
+	uint64_t txb_fif_bk0_sbe              : 1;  /**< TXB Main FIFO Bank0 single-bit error. */
+	uint64_t txb_fif_bk0_dbe              : 1;  /**< TXB Main FIFO Bank0 double-bit error. */
+	uint64_t rxb_skid_sbe                 : 1;  /**< RXB SKID FIFO single-bit error. */
+	uint64_t rxb_skid_dbe                 : 1;  /**< RXB SKID FIFO double-bit error. */
+	uint64_t rxb_fif_bk1_sbe1             : 1;  /**< RXB main FIFO bank1 srf1 single-bit error. */
+	uint64_t rxb_fif_bk1_dbe1             : 1;  /**< RXB main FIFO bank1 srf1 double-bit error. */
+	uint64_t rxb_fif_bk1_sbe0             : 1;  /**< RXB main FIFO bank1 srf0 single-bit error. */
+	uint64_t rxb_fif_bk1_dbe0             : 1;  /**< RXB main FIFO bank1 srf0 double-bit error. */
+	uint64_t rxb_fif_bk0_sbe1             : 1;  /**< RXB main FIFO bank0 srf1 single-bit error. */
+	uint64_t rxb_fif_bk0_dbe1             : 1;  /**< RXB main FIFO bank0 srf1 double-bit error. */
+	uint64_t rxb_fif_bk0_sbe0             : 1;  /**< RXB main FIFO bank0 srf0 single-bit error. */
+	uint64_t rxb_fif_bk0_dbe0             : 1;  /**< RXB main FIFO bank0 srf0 double-bit error. */
 #else
 	uint64_t rxb_fif_bk0_dbe0             : 1;
 	uint64_t rxb_fif_bk0_sbe0             : 1;
@@ -3301,8 +3311,8 @@ union cvmx_bgxx_cmr_nxc_adr {
 	struct cvmx_bgxx_cmr_nxc_adr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t lmac_id                      : 4;  /**< Logged LMAC ID associated with NXC exceptions */
-	uint64_t channel                      : 12; /**< Logged channel for NXC exceptions */
+	uint64_t lmac_id                      : 4;  /**< Logged LMAC ID associated with NXC exceptions. */
+	uint64_t channel                      : 12; /**< Logged channel for NXC exceptions. */
 #else
 	uint64_t channel                      : 12;
 	uint64_t lmac_id                      : 4;
@@ -3325,7 +3335,7 @@ union cvmx_bgxx_cmr_rx_adrx_cam {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_54_63               : 10;
 	uint64_t id                           : 2;  /**< Logical MAC ID that this DMAC CAM address applies to. BGX has 32 DMAC CAM entries that can
-                                                         be accessed with the BGX*_CMR_RX_ADR_CAM(0..31) CSRs. These 32 DMAC entries can be used by
+                                                         be accessed with the BGX*_CMR_RX_ADR_CAM() CSRs. These 32 DMAC entries can be used by
                                                          any of the four SGMII MACs or the 10G/40G MACs using these register bits.
                                                          A typical configuration is to provide eight CAM entries per LMAC ID, which is configured
                                                          using the following settings:
@@ -3338,7 +3348,7 @@ union cvmx_bgxx_cmr_rx_adrx_cam {
                                                          1 = Include this address in the matching algorithm.
                                                          0 = Don't include this address in the matching algorithm. */
 	uint64_t adr                          : 48; /**< DMAC address in the CAM used for matching. The CAM matches against unicast or multicast
-                                                         DMAC addresses. All BGX(0..5)_CMR_RX_ADR(0..31)_CAM CSRs can be used in any of the
+                                                         DMAC addresses. All BGX()_CMR_RX_ADR()_CAM CSRs can be used in any of the
                                                          LMAC_TYPE combinations such that any BGX MAC can use any of the 32 common DMAC entries. */
 #else
 	uint64_t adr                          : 48;
@@ -3360,23 +3370,18 @@ union cvmx_bgxx_cmr_rx_lmacs {
 	struct cvmx_bgxx_cmr_rx_lmacs_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t lmacs                        : 3;  /**< "Number of LMACS: Specifies the number of LMACs that can be enabled.
+	uint64_t lmacs                        : 3;  /**< Number of LMACS. Specifies the number of LMACs that can be enabled.
                                                          This determines the logical RX buffer size per LMAC and the maximum
                                                          LMAC ID that can be used:
-                                                           ----------+---------------------------------------------------
-                                                           LMACS     |   RX buffer           Maximum
-                                                                         size per LMAC       LMAC ID
-                                                           ----------+---------------------------------------------------
-                                                           0         |   reserved
-                                                           1         |   64KB                0
-                                                           2         |   32KB                1
-                                                           3         |   16KB                2
-                                                           4         |   16KB                3
-                                                           5-7       |   reserved
-                                                           ----------+---------------------------------------------------
-                                                         Note: The maximum LMAC ID is determined by the smaller of
-                                                         BGX_CMR_RX_LMACS[LMACS] and BGX_CMR_TX_LMACS[LMACS]. The two fields
-                                                         should be set to the same value for normal operation." */
+                                                         0x0 = Reserved.
+                                                         0x1 = 64 KB per LMAC, maximum LMAC ID is 0.
+                                                         0x2 = 32 KB per LMAC, maximum LMAC ID is 1.
+                                                         0x3 = 16 KB per LMAC, maximum LMAC ID is 2.
+                                                         0x4 = 16 KB per LMAC, maximum LMAC ID is 3.
+                                                         0x5-0x7 = Reserved.
+                                                         Note the maximum LMAC ID is determined by the smaller of
+                                                         BGX()_CMR_RX_LMACS[LMACS] and BGX()_CMR_TX_LMACS[LMACS]. The two fields
+                                                         should be set to the same value for normal operation. */
 #else
 	uint64_t lmacs                        : 3;
 	uint64_t reserved_3_63                : 61;
@@ -3389,12 +3394,12 @@ typedef union cvmx_bgxx_cmr_rx_lmacs cvmx_bgxx_cmr_rx_lmacs_t;
 /**
  * cvmx_bgx#_cmr_rx_ovr_bp
  *
- * BGX(0..5)_CMR_RX_OVR_BP[EN<0>] must be set to one and BGX(0..5)_CMR_RX_OVR_BP[BP<0>] must be
+ * BGX()_CMR_RX_OVR_BP[EN<0>] must be set to one and BGX()_CMR_RX_OVR_BP[BP<0>] must be
  * cleared to zero (to forcibly disable hardware-automatic 802.3 PAUSE packet generation) with
- * the HiGig2 Protocol when BGX(0..5)_SMU(0..3)_HG2_CONTROL[HG2TX_EN]=0. (The HiGig2 protocol is
- * indicated by BGX(0..5)_SMU(0..3)_TX_CTL[HG_EN]=1 and BGX(0..5)_SMU(0..3)_RX_UDD_SKP[LEN]=16).
+ * the HiGig2 Protocol when BGX()_SMU()_HG2_CONTROL[HG2TX_EN]=0. (The HiGig2 protocol is
+ * indicated by BGX()_SMU()_TX_CTL[HG_EN]=1 and BGX()_SMU()_RX_UDD_SKP[LEN]=16).
  * Hardware can only auto-generate backpressure through HiGig2 messages (optionally, when
- * BGX(0..5)_SMU(0..3)_HG2_CONTROL[HG2TX_EN]=1) with the HiGig2 protocol.
+ * BGX()_SMU()_HG2_CONTROL[HG2TX_EN]=1) with the HiGig2 protocol.
  */
 union cvmx_bgxx_cmr_rx_ovr_bp {
 	uint64_t u64;
@@ -3402,10 +3407,12 @@ union cvmx_bgxx_cmr_rx_ovr_bp {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
 	uint64_t en                           : 4;  /**< Per-LMAC enable backpressure override.
-                                                         1 = Enable override, 0 = Don't enable
+                                                         0 = Don't enable.
+                                                         1 = Enable override.
                                                          Bit<8> represents LMAC 0, ..., bit<11> represents LMAC 3. */
 	uint64_t bp                           : 4;  /**< Per-LMAC backpressure status to use:
-                                                         1 = LMAC should be backpressured, 0 = LMAC is available
+                                                         0 = LMAC is available.
+                                                         1 = LMAC should be backpressured.
                                                          Bit<4> represents LMAC 0, ..., bit<7> represents LMAC 3. */
 	uint64_t ign_fifo_bp                  : 4;  /**< Ignore the RX FIFO BP_ON signal when computing backpressure. CMR does not backpressure the
                                                          MAC due to the FIFO length passing BP_ON mark. */
@@ -3431,22 +3438,17 @@ union cvmx_bgxx_cmr_tx_lmacs {
 	struct cvmx_bgxx_cmr_tx_lmacs_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t lmacs                        : 3;  /**< '"Number of LMACS: Specifies the number of LMACs that can be enabled.
+	uint64_t lmacs                        : 3;  /**< Number of LMACS: Specifies the number of LMACs that can be enabled.
                                                          This determines the logical TX buffer size per LMAC and the maximum
                                                          LMAC ID that can be used:
-                                                           ----------+---------------------------------------------------
-                                                           LMACS     |   TX buffer           Maximum
-                                                                         size per LMAC       LMAC ID
-                                                           ----------+---------------------------------------------------
-                                                           0         |   reserved
-                                                           1         |   32KB                0
-                                                           2         |   16KB                1
-                                                           3         |   8KB                 2
-                                                           4         |   8KB                 3
-                                                           5-7       |   reserved
-                                                           ----------+---------------------------------------------------
-                                                         NOTE: The maximum LMAC ID is determined by the smaller of BGX(0..5)_CMR_RX_LMACS[LMACS]
-                                                         and BGX(0..5)_CMR_TX_LMACS[LMACS]. The two fields should be set to the same value for
+                                                         0x0 = Reserved.
+                                                         0x1 = 32 KB per LMAC, maximum LMAC ID is 0.
+                                                         0x2 = 16 KB per LMAC, maximum LMAC ID is 1.
+                                                         0x3 = 8 KB per LMAC, maximum LMAC ID is 2.
+                                                         0x4 = 8 KB per LMAC, maximum LMAC ID is 3.
+                                                         0x5-0x7 = Reserved.
+                                                         The maximum LMAC ID is determined by the smaller of BGX()_CMR_RX_LMACS[LMACS]
+                                                         and BGX()_CMR_TX_LMACS[LMACS]. The two fields should be set to the same value for
                                                          normal operation.' */
 #else
 	uint64_t lmacs                        : 3;
@@ -3471,26 +3473,21 @@ union cvmx_bgxx_gmp_gmi_prtx_cfg {
 	uint64_t tx_idle                      : 1;  /**< TX machine is idle. */
 	uint64_t rx_idle                      : 1;  /**< RX machine is idle. */
 	uint64_t reserved_9_11                : 3;
-	uint64_t speed_msb                    : 1;  /**< Link speed MSB [SPEED_MSB:SPEED]
-                                                         0x2 = 10 Mb/s operation.
-                                                         0x0 = 100 Mb/s operation.
-                                                         0x1 = 1000 Mb/s operation.
-                                                         0x3 = Reserved.
-                                                         (SGMII/1000Base-X only) */
+	uint64_t speed_msb                    : 1;  /**< Link speed MSB (SGMII/1000Base-X only). See [SPEED]. */
 	uint64_t reserved_4_7                 : 4;
 	uint64_t slottime                     : 1;  /**< Slot time for half-duplex operation
+                                                         (SGMII/1000Base-X only):
                                                          0 = 512 bit times (10/100 Mb/s operation)
-                                                         1 = 4096 bit times (1000 Mb/s operation)
-                                                         (SGMII/1000Base-X only) */
-	uint64_t duplex                       : 1;  /**< Duplex mode:
-                                                         0 = half-duplex (collisions/extensions/bursts), 1 = full-duplex.
-                                                         (SGMII/1000Base-X only) */
-	uint64_t speed                        : 1;  /**< Link Speed LSB [SPEED_MSB:SPEED]
-                                                         0x2 = 10 Mb/s operation.
-                                                         0x0 = 100 Mb/s operation.
-                                                         0x1 = 1000 Mb/s operation.
-                                                         0x3 = Reserved.
-                                                         (SGMII/1000Base-X only) */
+                                                         1 = 4096 bit times (1000 Mb/s operation) */
+	uint64_t duplex                       : 1;  /**< Duplex mode
+                                                         (SGMII/1000Base-X only):
+                                                         0 = half-duplex (collisions/extensions/bursts):
+                                                         1 = full-duplex. */
+	uint64_t speed                        : 1;  /**< Link Speed LSB (SGMII/1000Base-X only):
+                                                         _ [SPEED_MSB:SPEED] = 0x0: 100 Mb/s operation.
+                                                         _ [SPEED_MSB:SPEED] = 0x1: 1000 Mb/s operation.
+                                                         _ [SPEED_MSB:SPEED] = 0x2: 10 Mb/s operation.
+                                                         _ [SPEED_MSB:SPEED] = 0x3: Reserved. */
 	uint64_t reserved_0_0                 : 1;
 #else
 	uint64_t reserved_0_0                 : 1;
@@ -3514,17 +3511,17 @@ typedef union cvmx_bgxx_gmp_gmi_prtx_cfg cvmx_bgxx_gmp_gmi_prtx_cfg_t;
  *
  * This register specifies the byte count used to determine when to accept or to filter a packet.
  * As each byte in a packet is received by GMI, the L2 byte count is compared against the
- * BGX(0..5)_GMP_GMI_RX(0..3)_DECISION[CNT]. In normal operation, the L2 header begins after the
- * PREAMBLE + SFD (BGX(0..5)_GMP_GMI_RX(0..3)_FRM_CTL[PRE_CHK] = 1) and any optional UDD skip
- * data (BGX(0..5)_GMP_GMI_RX(0..3)_UDD_SKP[LEN]).
+ * BGX()_GMP_GMI_RX()_DECISION[CNT]. In normal operation, the L2 header begins after the
+ * PREAMBLE + SFD (BGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] = 1) and any optional UDD skip
+ * data (BGX()_GMP_GMI_RX()_UDD_SKP[LEN]).
  *
  * INTERNAL: Notes:
  * As each byte in a packet is received by GMI, the L2 byte count is compared
- * against the BGX_GMP_GMI_RX_DECISION[CNT].  The L2 byte count is the number of bytes
+ * against the BGX()_GMP_GMI_RX()_DECISION[CNT].  The L2 byte count is the number of bytes
  * from the beginning of the L2 header (DMAC).  In normal operation, the L2
- * header begins after the PREAMBLE+SFD (BGX_GMP_GMI_RX_FRM_CTL[PRE_CHK]=1) and any
- * optional UDD skip data (BGX_GMP_GMI_RX_UDD_SKP[LEN]).
- * When BGX_GMP_GMI_RX_FRM_CTL[PRE_CHK] is clear, PREAMBLE+SFD are prepended to the
+ * header begins after the PREAMBLE+SFD (BGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]=1) and any
+ * optional UDD skip data (BGX()_GMP_GMI_RX()_UDD_SKP[LEN]).
+ * When BGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear, PREAMBLE+SFD are prepended to the
  * packet and would require UDD skip length to account for them.
  * Port Mode
  * - Full Duplex
@@ -3533,9 +3530,11 @@ typedef union cvmx_bgxx_gmp_gmi_prtx_cfg cvmx_bgxx_gmp_gmi_prtx_cfg_t;
  * - Half Duplex
  *     L2 Size <  BGX_RX_DECISION - Drop packet. Packet is unconditionally dropped.
  *     L2 Size >= BGX_RX_DECISION - Accept packet.
- * where L2_size = MAX(0, total_packet_size - BGX_GMP_GMI_RX_UDD_SKP[LEN] -
- *                        ((BGX_GMP_GMI_RX_FRM_CTL[PRE_CHK]==1)*8))
- * BGX_GMP_GMI_RX_DECISION = The byte count to decide when to accept or filter a packet
+ *
+ * where L2_size = MAX(0, total_packet_size - BGX()_GMP_GMI_RX()_UDD_SKP[LEN] -
+ *                        ((BGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]==1)*8))
+ *
+ * BGX()_GMP_GMI_RX()_DECISION = The byte count to decide when to accept or filter a packet
  */
 union cvmx_bgxx_gmp_gmi_rxx_decision {
 	uint64_t u64;
@@ -3590,9 +3589,10 @@ typedef union cvmx_bgxx_gmp_gmi_rxx_frm_chk cvmx_bgxx_gmp_gmi_rxx_frm_chk_t;
  * This register controls the handling of the frames.
  * The CTL_BCK/CTL_DRP bits control how the hardware handles incoming PAUSE packets. The most
  * common modes of operation:
- * CTL_BCK = 1, CTL_DRP = 1: hardware handles everything
- * CTL_BCK = 0, CTL_DRP = 0: software sees all PAUSE frames
- * CTL_BCK = 0, CTL_DRP = 1: all PAUSE frames are completely ignored
+ * _ CTL_BCK = 1, CTL_DRP = 1: hardware handles everything.
+ * _ CTL_BCK = 0, CTL_DRP = 0: software sees all PAUSE frames.
+ * _ CTL_BCK = 0, CTL_DRP = 1: all PAUSE frames are completely ignored.
+ *
  * These control bits should be set to CTL_BCK = 0,CTL_DRP = 0 in half-duplex mode. Since PAUSE
  * packets only apply to full duplex operation, any PAUSE packet would constitute an exception
  * which should be handled by the processing cores. PAUSE packets should not be forwarded.
@@ -3615,19 +3615,19 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_ctl {
 	uint64_t ptp_mode                     : 1;  /**< Timestamp mode. When PTP_MODE is set, a 64-bit timestamp is prepended to every incoming
                                                          packet.
                                                          The timestamp bytes are added to the packet in such a way as to not modify the packet's
-                                                         receive byte count. This implies that the BGX(0..5)_GMP_GMI_RX(0..3)_JABBER,
-                                                         BGX(0..5)_GMP_GMI_RX(0..3)_DECISION, BGX(0..5)_GMP_GMI_RX(0..3)_UDD_SKP, and
-                                                         BGX(0..5)_CMR(0..3)_RX_STAT* do not require any adjustment as they operate on the received
+                                                         receive byte count. This implies that the BGX()_GMP_GMI_RX()_JABBER,
+                                                         BGX()_GMP_GMI_RX()_DECISION, BGX()_GMP_GMI_RX()_UDD_SKP, and
+                                                         BGX()_CMR()_RX_STAT0..BGX()_CMR()_RX_STAT8
+                                                         do not require any adjustment as they operate on the received
                                                          packet size. When the packet reaches PKI, its size reflects the additional bytes and is
                                                          subject to the following restrictions:
                                                          If PTP_MODE = 1 and PRE_CHK = 1, PRE_STRP must be 1.
-                                                         If PTP_MODE = 1
-                                                         * PKI_CL(0..3)_PKIND(0..63)_SKIP[FCS_SKIP,INST_SKIP] should be increased by 8.
-                                                         * PKI_CL(0..3)_PKIND(0..63)_CFG[HG_EN] should be 0.
-                                                         * PKI_FRM_LEN_CHK(0..1)[MAXLEN] should be increased by 8.
-                                                         * PKI_FRM_LEN_CHK(0..1)[MINLEN] should be increased by 8.
-                                                         * PKI_TAG_INC(0..31)_MASK[EN] should be adjusted.
-                                                         This supported in uCode in CN78XX >>> PIP_PRT_CFGB(0..63)[ALT_SKP_EN] should be 0. */
+                                                         If PTP_MODE = 1:
+                                                         * PKI_CL()_PKIND()_SKIP[FCS_SKIP,INST_SKIP] should be increased by 8.
+                                                         * PKI_CL()_PKIND()_CFG[HG_EN] should be 0.
+                                                         * PKI_FRM_LEN_CHK()[MAXLEN] should be increased by 8.
+                                                         * PKI_FRM_LEN_CHK()[MINLEN] should be increased by 8.
+                                                         * PKI_TAG_INC()_MASK[EN] should be adjusted. */
 	uint64_t reserved_11_11               : 1;
 	uint64_t null_dis                     : 1;  /**< When set, do not modify the MOD bits on NULL ticks due to partial packets. */
 	uint64_t pre_align                    : 1;  /**< When set, PREAMBLE parser aligns the SFD byte regardless of the number of previous
@@ -3654,8 +3654,8 @@ union cvmx_bgxx_gmp_gmi_rxx_frm_ctl {
 	uint64_t pre_chk                      : 1;  /**< Check the preamble for correctness. This port is configured to send a valid 802.3 PREAMBLE
                                                          to begin every frame. GMI checks that a valid PREAMBLE is received (based on PRE_FREE).
                                                          When a problem does occur within the PREAMBLE sequence, the frame is marked as bad and not
-                                                         sent into the core. The BGX(0..5)_SMU(0..3)_RX_INT[PCTERR] interrupt is also raised.
-                                                         When BGX(0..5)_SMU(0..3)_TX_CTL[HG_EN] is set, PRE_CHK must be 0. If PTP_MODE = 1 and
+                                                         sent into the core. The BGX()_SMU()_RX_INT[PCTERR] interrupt is also raised.
+                                                         When BGX()_SMU()_TX_CTL[HG_EN] is set, PRE_CHK must be 0. If PTP_MODE = 1 and
                                                          PRE_CHK = 1, PRE_STRP must be 1. */
 #else
 	uint64_t pre_chk                      : 1;
@@ -3708,45 +3708,55 @@ typedef union cvmx_bgxx_gmp_gmi_rxx_ifg cvmx_bgxx_gmp_gmi_rxx_ifg_t;
  *
  * "These registers allow interrupts to be sent to the control processor.
  * * Exception conditions <10:0> can also set the rcv/opcode in the received packet's work-queue
- * entry. BGX(0..5)_GMP_GMI_RX(0..3)_FRM_CHK provides a bit mask for configuring which conditions
+ * entry. BGX()_GMP_GMI_RX()_FRM_CHK provides a bit mask for configuring which conditions
  * set the error.
  * In half duplex operation, the expectation is that collisions will appear as either MINERR or
  * CAREXT errors.
  *
  * INTERNAL: Notes:
  * (2) exception conditions 10:0 can also set the rcv/opcode in the received
- * packet's workQ entry.  The BGX_GMP_GMI_RX_FRM_CHK register provides a bit mask
+ * packet's workQ entry.  The BGX()_GMP_GMI_RX()_FRM_CHK register provides a bit mask
  * for configuring which conditions set the error.
+ *
  * (3) in half duplex operation, the expectation is that collisions will appear
  * as either MINERR o r CAREXT errors.
+ *
  * (4) JABBER An RX Jabber error indicates that a packet was received which
  * is longer than the maximum allowed packet as defined by the
  * system.  GMI will truncate the packet at the JABBER count.
  * Failure to do so could lead to system instabilty.
+ *
  * (5) NIBERR This error is illegal at 1000Mbs speeds
- * (BGX_GMP_GMI_RX_PRT_CFG[SPEED]==0) and will never assert.
+ * (BGX()_GMP_GMI_RX()_PRT_CFG[SPEED]==0) and will never assert.
+ *
  * (6) MAXERR for untagged frames, the total frame DA+SA+TL+DATA+PAD+FCS >
- * BGX_GMP_GMI_RX_FRM_MAX.  For tagged frames, DA+SA+VLAN+TL+DATA+PAD+FCS
- * > BGX_GMP_GMI_RX_FRM_MAX + 4*VLAN_VAL + 4*VLAN_STACKED.
+ * BGX()_GMP_GMI_RX()_FRM_MAX.  For tagged frames, DA+SA+VLAN+TL+DATA+PAD+FCS
+ * > BGX()_GMP_GMI_RX()_FRM_MAX + 4*VLAN_VAL + 4*VLAN_STACKED.
+ *
  * (7) MINERR total frame DA+SA+TL+DATA+PAD+FCS < 64
+ *
  * (8) ALNERR Indicates that the packet received was not an integer number of
  * bytes.  If FCS checking is enabled, ALNERR will only assert if
  * the FCS is bad.  If FCS checking is disabled, ALNERR will
  * assert in all non-integer frame cases.
+ *
  * (9) Collisions Collisions can only occur in half-duplex mode.  A collision
  * is assumed by the receiver when the slottime
- * (BGX_GMP_GMI_PRT_CFG[SLOTTIME]) is not satisfied.  In 10/100 mode,
+ * (BGX()_GMP_GMI_PRT_CFG[SLOTTIME]) is not satisfied.  In 10/100 mode,
  * this will result in a frame < SLOTTIME.  In 1000 mode, it
  * could result either in frame < SLOTTIME or a carrier extend
  * error with the SLOTTIME.  These conditions are visible by...
  * . transfer ended before slottime COLDET
  * . carrier extend error           CAREXT
+ *
  * (A) LENERR Length errors occur when the received packet does not match the
  * length field.  LENERR is only checked for packets between 64
  * and 1500 bytes.  For untagged frames, the length must exact
  * match.  For tagged frames the length or length+4 must match.
+ *
  * (B) PCTERR checks that the frame begins with a valid PREAMBLE sequence.
  * Does not check the number of PREAMBLE cycles.
+ *
  * (C) OVRERR
  * OVRERR is an architectural assertion check internal to GMI to
  * make sure no assumption was violated.  In a correctly operating
@@ -3767,7 +3777,7 @@ union cvmx_bgxx_gmp_gmi_rxx_int {
 	uint64_t reserved_12_63               : 52;
 	uint64_t ifgerr                       : 1;  /**< Interframe gap violation. Does not necessarily indicate a failure. SGMII/1000Base-X only. */
 	uint64_t coldet                       : 1;  /**< Collision detection. Collisions can only occur in half-duplex mode. A collision is assumed
-                                                         by the receiver when the slottime (BGX(0..5)_GMP_GMI_PRT(0..3)_CFG[SLOTTIME]) is not
+                                                         by the receiver when the slottime (BGX()_GMP_GMI_PRT()_CFG[SLOTTIME]) is not
                                                          satisfied. In 10/100 mode, this will result in a frame < SLOTTIME. In 1000 mode, it could
                                                          result either in frame < SLOTTIME or a carrier extend error with the SLOTTIME. These
                                                          conditions are visible by 1) transfer ended before slottime - COLDET or 2) carrier extend
@@ -3811,15 +3821,8 @@ typedef union cvmx_bgxx_gmp_gmi_rxx_int cvmx_bgxx_gmp_gmi_rxx_int_t;
 /**
  * cvmx_bgx#_gmp_gmi_rx#_jabber
  *
- * Notes:
- * CNT must be 8-byte aligned such that CNT[2:0] == 0
- * The packet that will be sent to the packet input logic will have an
- * additionl 8 bytes if BGX_GMP_GMI_RX_FRM_CTL[PRE_CHK] is set and
- * BGX_GMP_GMI_RX_FRM_CTL[PRE_STRP] is clear.  The max packet that will be sent is
- * defined as...
- * max_sized_packet = BGX_GMP_GMI_RX_JABBER[CNT]+((BGX_GMP_GMI_RX_FRM_CTL[PRE_CHK] &
- * !BGX_GMP_GMI_RX_FRM_CTL[PRE_STRP])*8)
- * BGX_GMP_GMI_RX_JABBER = The max size packet after which GMI will truncate
+ * This register specifies the maximum size for packets, beyond which the GMI truncates.
+ *
  */
 union cvmx_bgxx_gmp_gmi_rxx_jabber {
 	uint64_t u64;
@@ -3847,23 +3850,26 @@ typedef union cvmx_bgxx_gmp_gmi_rxx_jabber cvmx_bgxx_gmp_gmi_rxx_jabber_t;
  * INTERNAL: Notes:
  * (1) The skip bytes are part of the packet and will be sent down the NCB
  * packet interface and will be handled by PKI.
+ *
  * (2) The system can determine if the UDD bytes are included in the FCS check
  * by using the FCSSEL field - if the FCS check is enabled.
+ *
  * (3) Assume that the preamble/sfd is always at the start of the frame - even
  * before UDD bytes.  In most cases, there will be no preamble in these
  * cases since it will be packet interface in direct communication to
  * another packet interface (MAC to MAC) without a PHY involved.
+ *
  * (4) We can still do address filtering and control packet filtering is the
  * user desires.
+ *
  * (5) UDD_SKP must be 0 in half-duplex operation unless
- * BGX_GMP_GMI_RX_FRM_CTL[PRE_CHK] is clear.  If BGX_GMP_GMI_RX_FRM_CTL[PRE_CHK] is clear,
+ * BGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear.  If BGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is
+ * clear,
  * then UDD_SKP will normally be 8.
+ *
  * (6) In all cases, the UDD bytes will be sent down the packet interface as
  * part of the packet.  The UDD bytes are never stripped from the actual
  * packet.
- * (7) If LEN != 0, then BGX_GMP_GMI_RX_FRM_CHK[LENERR] will be disabled and
- * BGX_GMP_GMI_RX_INT[LENERR] will be zero
- * BGX_GMP_GMI_RX_UDD_SKP = Amount of User-defined data before the start of the L2 data
  */
 union cvmx_bgxx_gmp_gmi_rxx_udd_skp {
 	uint64_t u64;
@@ -3873,14 +3879,16 @@ union cvmx_bgxx_gmp_gmi_rxx_udd_skp {
 	uint64_t fcssel                       : 1;  /**< Include the skip bytes in the FCS calculation.
                                                          0 = All skip bytes are included in FCS.
                                                          1 = The skip bytes are not included in FCS.
-                                                         When BGX(0..5)_GMP_GMI_TX(0..3)_CTL[HG_EN] is set, this field must be 0.
+                                                         When BGX()_GMP_GMI_TX()_CTL[HG_EN] is set, this field must be 0.
                                                          The skip bytes are part of the packet and are sent down the NCB packet interface and are
                                                          handled by PKI. The system can determine if the UDD bytes are included in the FCS check by
                                                          using the FCSSEL field, if the FCS check is enabled. */
 	uint64_t reserved_7_7                 : 1;
 	uint64_t len                          : 7;  /**< Amount of user-defined data before the start of the L2C data, in bytes.
                                                          Setting to 0 means L2C comes first; maximum value is 64.
-                                                         LEN must be 0x0 in half-duplex operation. */
+                                                         LEN must be 0x0 in half-duplex operation.
+                                                         If LEN != 0, then BGX()_GMP_GMI_RX()_FRM_CHK[MINERR] will be disabled and
+                                                         BGX()_GMP_GMI_RX()_INT[MINERR] will be zero. */
 #else
 	uint64_t len                          : 7;
 	uint64_t reserved_7_7                 : 1;
@@ -3919,7 +3927,7 @@ union cvmx_bgxx_gmp_gmi_txx_append {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
 	uint64_t force_fcs                    : 1;  /**< Append the Ethernet FCS on each PAUSE packet. PAUSE packets are normally padded to 60
-                                                         bytes. If BGX(0..5)_GMP_GMI_TX(0..3)_MIN_PKT[MIN_SIZE] exceeds 59, then FCS_C is not used. */
+                                                         bytes. If BGX()_GMP_GMI_TX()_MIN_PKT[MIN_SIZE] exceeds 59, then FCS_C is not used. */
 	uint64_t fcs                          : 1;  /**< Append the Ethernet FCS on each packet. */
 	uint64_t pad                          : 1;  /**< Append PAD bytes such that minimum-sized packet is transmitted. */
 	uint64_t preamble                     : 1;  /**< Prepend the Ethernet preamble on each transfer. */
@@ -4014,7 +4022,7 @@ union cvmx_bgxx_gmp_gmi_txx_min_pkt {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
 	uint64_t min_size                     : 8;  /**< Minimum frame size in bytes before the FCS is applied.
-                                                         Padding is only appended when BGX(0..5)_GMP_GMI_TX(0..3)_APPEND[PAD] for the corresponding
+                                                         Padding is only appended when BGX()_GMP_GMI_TX()_APPEND[PAD] for the corresponding
                                                          LMAC is set.
                                                          In SGMII mode, packets are padded to MIN_SIZE+1. The reset value pads to 60 bytes. */
 #else
@@ -4032,17 +4040,20 @@ typedef union cvmx_bgxx_gmp_gmi_txx_min_pkt cvmx_bgxx_gmp_gmi_txx_min_pkt_t;
  * This register specifies how often PAUSE packets are sent.
  *
  * INTERNAL: Notes:
- * Choosing proper values of BGX_GMP_GMI_TX_PAUSE_PKT_TIME[TIME] and
- * BGX_GMP_GMI_TX_PAUSE_PKT_INTERVAL[INTERVAL] can be challenging to the system
+ * Choosing proper values of BGX()_GMP_GMI_TX_PAUSE_PKT_TIME[PTIME] and
+ * BGX()_GMP_GMI_TX_PAUSE_PKT_INTERVAL[INTERVAL] can be challenging to the system
  * designer.  It is suggested that TIME be much greater than INTERVAL and
- * BGX_GMP_GMI_TX_PAUSE_ZERO[SEND] be set.  This allows a periodic refresh of the PAUSE
+ * BGX()_GMP_GMI_TX_PAUSE_ZERO[SEND] be set.  This allows a periodic refresh of the PAUSE
  * count and then when the backpressure condition is lifted, a PAUSE packet
  * with TIME==0 will be sent indicating that Octane is ready for additional
  * data.
- * If the system chooses to not set BGX_GMP_GMI_TX_PAUSE_ZERO[SEND], then it is
+ *
+ * If the system chooses to not set BGX()_GMP_GMI_TX_PAUSE_ZERO[SEND], then it is
  * suggested that TIME and INTERVAL are programmed such that they satisify the
- * following rule...
- * INTERVAL <= TIME - (largest_pkt_size + IFG + pause_pkt_size)
+ * following rule:
+ *
+ * _ INTERVAL <= TIME - (largest_pkt_size + IFG + pause_pkt_size)
+ *
  * where largest_pkt_size is that largest packet that the system can send
  * (normally 1518B), IFG is the interframe gap and pause_pkt_size is the size
  * of the PAUSE packet (normally 64B).
@@ -4053,7 +4064,7 @@ union cvmx_bgxx_gmp_gmi_txx_pause_pkt_interval {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t interval                     : 16; /**< Arbitrate for a 802.3 PAUSE packet or CBFC PAUSE packet every (INTERVAL * 512) bit-times.
-                                                         Normally, 0 < INTERVAL < BGX(0..5)_GMP_GMI_TX(0..3)_PAUSE_PKT_TIME[TIME].
+                                                         Normally, 0 < INTERVAL < BGX()_GMP_GMI_TX()_PAUSE_PKT_TIME[PTIME].
                                                          INTERVAL = 0 only sends a single PAUSE packet for each backpressure event. */
 #else
 	uint64_t interval                     : 16;
@@ -4074,8 +4085,8 @@ union cvmx_bgxx_gmp_gmi_txx_pause_pkt_time {
 	uint64_t reserved_16_63               : 48;
 	uint64_t ptime                        : 16; /**< Provides the pause_time field placed in outbound 802.3 PAUSE packets or CBFC PAUSE packets
                                                          in 512 bit-times. Normally, P_TIME >
-                                                         BGX(0..5)_GMP_GMI_TX(0..3)_PAUSE_PKT_INTERVAL[INTERVAL]. For programming information see
-                                                         BGX(0..5)_GMP_GMI_TX(0..3)_PAUSE_PKT_INTERVAL. */
+                                                         BGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL[INTERVAL]. For programming information see
+                                                         BGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL. */
 #else
 	uint64_t ptime                        : 16;
 	uint64_t reserved_16_63               : 48;
@@ -4131,14 +4142,14 @@ union cvmx_bgxx_gmp_gmi_txx_sgmii_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t align                        : 1;  /**< Align the transmission to even cycles: (SGMII/1000BASE-X half-duplex only)
-                                                         Recommended value is: ALIGN = !BGX(0..5)_GMP_GMI_TX(0..3)_APPEND[PREAMBLE].
+                                                         Recommended value is: ALIGN = !BGX()_GMP_GMI_TX()_APPEND[PREAMBLE].
                                                          (See Transmit Conversion to Code groups, Transmit Conversion to Code Groups for a complete
                                                          discussion.)
-                                                         0 = Data can be sent on any cycle. In this mode, the interface functions at maximum
+                                                         _ 0 = Data can be sent on any cycle. In this mode, the interface functions at maximum
                                                          bandwidth. It is possible for the TX PCS machine to drop the first byte of the TX frame.
-                                                         When BGX(0..5)_GMP_GMI_TX(0..3)_APPEND[PREAMBLE] is set, the first byte is a preamble
+                                                         When BGX()_GMP_GMI_TX()_APPEND[PREAMBLE] is set, the first byte is a preamble
                                                          byte, which can be dropped to compensate for an extended IPG.
-                                                         1 = Data is only sent on even cycles. In this mode, there can be bandwidth implications
+                                                         _ 1 = Data is only sent on even cycles. In this mode, there can be bandwidth implications
                                                          when sending odd-byte packets as the IPG can extend an extra cycle. There will be no loss
                                                          of data. */
 #else
@@ -4201,10 +4212,10 @@ union cvmx_bgxx_gmp_gmi_txx_thresh {
                                                          interface. This field should be large enough to prevent underflow on the packet interface
                                                          and must never be set to 0x0.
                                                          10G/40G Mode, CNT = 0x100. In all modes, this register cannot exceed the TX FIFO depth as
-                                                         follows.
-                                                         BGX*_CMR*_TX_LMACS = 0,1:  CNT maximum = 0x7FF
-                                                         BGX*_CMR*_TX_LMACS = 2:     CNT maximum = 0x3FF
-                                                         BGX*_CMR*_TX_LMACS = 3,4:  CNT maximum = 0x1FF */
+                                                         follows:
+                                                         _ BGX()_CMR_TX_LMACS = 0,1:  CNT maximum = 0x7FF.
+                                                         _ BGX()_CMR_TX_LMACS = 2:    CNT maximum = 0x3FF.
+                                                         _ BGX()_CMR_TX_LMACS = 3,4:  CNT maximum = 0x1FF. */
 #else
 	uint64_t cnt                          : 11;
 	uint64_t reserved_11_63               : 53;
@@ -4357,9 +4368,9 @@ union cvmx_bgxx_gmp_pcs_anx_adv {
 	uint64_t np                           : 1;  /**< Next page capable. This feature is not supported; this field is always 0. */
 	uint64_t reserved_14_14               : 1;
 	uint64_t rem_flt                      : 2;  /**< Remote fault.
-                                                         0x0 = Link OK, XMIT = DATA
-                                                         0x1 = Link failure (loss of sync, XMIT !=DATA)
-                                                         0x2 = Local device offline
+                                                         0x0 = Link OK, XMIT = DATA.
+                                                         0x1 = Link failure (loss of sync, XMIT !=DATA).
+                                                         0x2 = Local device offline.
                                                          0x3 = Auto-Negotiation error; failure to complete Auto-Negotiation. AN error is set if
                                                          resolution function precludes operation with link partner. */
 	uint64_t reserved_9_11                : 3;
@@ -4460,9 +4471,9 @@ typedef union cvmx_bgxx_gmp_pcs_anx_lp_abil cvmx_bgxx_gmp_pcs_anx_lp_abil_t;
 /**
  * cvmx_bgx#_gmp_pcs_an#_results
  *
- * This register is not valid when BGX(0..5)_GMP_PCS_MR(0..3)_CONTROL[AN_OVRD] is set to 1. If
- * BGX(0..5)_GMP_PCS_MR(0..3)_CONTROL[AN_OVRD] is set to 0 and
- * BGX(0..5)_GMP_PCS_AN(0..3)_RESULTS[AN_CPT] is set to 1, this register is valid.
+ * This register is not valid when BGX()_GMP_PCS_MISC()_CTL[AN_OVRD] is set to 1. If
+ * BGX()_GMP_PCS_MISC()_CTL[AN_OVRD] is set to 0 and
+ * BGX()_GMP_PCS_AN()_RESULTS[AN_CPT] is set to 1, this register is valid.
  */
 union cvmx_bgxx_gmp_pcs_anx_results {
 	uint64_t u64;
@@ -4578,14 +4589,11 @@ typedef union cvmx_bgxx_gmp_pcs_linkx_timer cvmx_bgxx_gmp_pcs_linkx_timer_t;
  * INTERNAL:
  * SGMII bit [12] is really a misnomer, it is a decode  of pi_qlm_cfg pins to indicate SGMII or
  * 1000Base-X modes.
- * Note: MODE bit
- * When MODE=1,  1000Base-X mode is selected. Auto negotiation will follow IEEE 802.3 clause 37.
- * When MODE=0,  SGMII mode is selected and the following note will apply.
+ *
  * Repeat note from SGM_AN_ADV register
  * NOTE: The SGMII AN Advertisement Register above will be sent during Auto Negotiation if the
- * MAC_PHY mode bit in misc_ctl_reg
- * is set (1=PHY mode). If the bit is not set (0=MAC mode), the tx_config_reg[14] becomes ACK bit
- * and [0] is always 1.
+ * MAC_PHY mode bit in misc_ctl_reg is set (1=PHY mode). If the bit is not set (0=MAC mode), the
+ * tx_config_reg[14] becomes ACK bit and [0] is always 1.
  * All other bits in tx_config_reg sent will be 0. The PHY dictates the Auto Negotiation results.
  * SGMII Misc Control Register
  */
@@ -4594,32 +4602,36 @@ union cvmx_bgxx_gmp_pcs_miscx_ctl {
 	struct cvmx_bgxx_gmp_pcs_miscx_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_13_63               : 51;
-	uint64_t sgmii                        : 1;  /**< SGMII mode. 1 = SGMII or 1000BASE-X mode selected, 0 = other mode selected. See
-                                                         GSER(0..13)_LANE_MODE[LMODE]. */
+	uint64_t sgmii                        : 1;  /**< SGMII mode.
+                                                         0 = other mode selected.
+                                                         1 = SGMII or 1000BASE-X mode selected.
+                                                         See GSER()_LANE_MODE[LMODE]. */
 	uint64_t gmxeno                       : 1;  /**< GMI enable override. When set, forces GMI to appear disabled. The enable/disable status of
                                                          GMI is checked only at SOP of every packet. */
 	uint64_t loopbck2                     : 1;  /**< Sets external loopback mode to return RX data back out via the TX data path. 0 = No
                                                          loopback, 1 = Loopback.
                                                          LOOPBCK1 and LOOPBCK2 modes may not be supported simultaneously. */
 	uint64_t mac_phy                      : 1;  /**< MAC/PHY.
-                                                         0 = MAC, 1 = PHY decides the TX_CONFIG_REG value to be sent during Auto-Negotiation. */
-	uint64_t mode                         : 1;  /**< Mode bit. 0 = SGMII, 1 = 1000Base X.
-                                                         1 = 1000Base-X mode is selected. Auto-Negotiation follows IEEE 802.3 clause 37.
-                                                         0 = SGMII mode is selected and the following note applies.
-                                                         The SGMII AN advertisement register (BGX(0..5)_GMP_PCS_SGM(0..3)_AN_ADV) is sent during
-                                                         Auto-Negotiation if BGX(0..5)_GMP_PCS_MISC(0..3)_CTL[MAC_PHY] = 1 (PHY mode). If [MAC_PHY]
+                                                         0 = MAC.
+                                                         1 = PHY decides the TX_CONFIG_REG value to be sent during Auto-Negotiation. */
+	uint64_t mode                         : 1;  /**< Mode bit.
+                                                         _ 0 = SGMII mode is selected and the following note applies.
+                                                         The SGMII AN advertisement register (BGX()_GMP_PCS_SGM()_AN_ADV) is sent during
+                                                         Auto-Negotiation if BGX()_GMP_PCS_MISC()_CTL[MAC_PHY] = 1 (PHY mode). If [MAC_PHY]
                                                          = 0 (MAC mode), the TX_CONFIG_REG<14> becomes ACK bit and <0> is always 1. All other bits
-                                                         in TX_CONFIG_REG sent are 0. The PHY dictates the Auto-Negotiation results. */
-	uint64_t an_ovrd                      : 1;  /**< Auto-Negotiation results override: 1 = enable override, 0 = disable.
-                                                         Auto-Negotiation is allowed to happen but the results are ignored when this bit is set.
-                                                         Duplex and Link speed values are set from BGX(0..5)_GMP_PCS_MISC(0..3)_CTL. */
-	uint64_t samp_pt                      : 7;  /**< Byte number in elongated frames for 10/100Mb/s operation for data sampling on RX side in
-                                                         PCS. Recommended values are 0x5 for
-                                                         100Mb/s operation and 0x32 for 10Mb/s operation.
-                                                         For 10Mb/s operation, this field should be set to a value less than 99 and greater than 0.
+                                                         in TX_CONFIG_REG sent are 0. The PHY dictates the Auto-Negotiation results.
+                                                         _ 1 = 1000Base-X mode is selected. Auto-Negotiation follows IEEE 802.3 clause 37. */
+	uint64_t an_ovrd                      : 1;  /**< Auto-Negotiation results override:
+                                                         0 = Disable.
+                                                         1 = Enable override. Auto-Negotiation is allowed to happen but the results are ignored
+                                                         when this bit is set.  Duplex and Link speed values are set from BGX()_GMP_PCS_MISC()_CTL. */
+	uint64_t samp_pt                      : 7;  /**< Byte number in elongated frames for 10/100 Mb/s operation for data sampling on RX side in
+                                                         PCS. Recommended values are 0x5 for 100 Mb/s operation and 0x32 for 10 Mb/s operation.
+                                                         For 10 Mb/s operation, this field should be set to a value less than 99 and greater than
+                                                         0.
                                                          If set out of this range, a value of 50 is used for actual sampling internally without
                                                          affecting the CSR field.
-                                                         For 100Mb/s operation this field should be set to a value less than 9 and greater than 0.
+                                                         For 100 Mb/s operation this field should be set to a value less than 9 and greater than 0.
                                                          If set out of this range, a value of 5 is used for actual sampling internally without
                                                          affecting the CSR field. */
 #else
@@ -4645,34 +4657,44 @@ union cvmx_bgxx_gmp_pcs_mrx_control {
 	struct cvmx_bgxx_gmp_pcs_mrx_control_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t reset                        : 1;  /**< Set to reset. 1 = software PCS reset, 0 = normal operation.
+	uint64_t reset                        : 1;  /**< Set to reset.
+                                                         0 = Normal operation.
+                                                         1 = Software PCS reset.
                                                          The bit returns to 0 after PCS has been reset. Takes 32 coprocessor-clock cycles to reset
                                                          PCS. */
-	uint64_t loopbck1                     : 1;  /**< Enable loopback: 1 = internal loopback mode, 0 = normal operation
+	uint64_t loopbck1                     : 1;  /**< Enable loopback:
+                                                           0 = Normal operation.
+                                                           1 = Internal loopback mode.
                                                          The loopback mode returns loopback TX data from GMII TX back to GMII RX interface. The
                                                          loopback happens in the PCS module. Auto-Negotiation is disabled even if AN_EN is set
                                                          during loopback. */
 	uint64_t spdlsb                       : 1;  /**< Least-significant bit of the link-speed field, i.e. SPD<0>. Refer to SPDMSB. */
-	uint64_t an_en                        : 1;  /**< Auto-Negotiation enable: 1 = enable, 0 = disable. */
-	uint64_t pwr_dn                       : 1;  /**< Power down: 1 = power down (hardware reset), 0 = normal operation. */
+	uint64_t an_en                        : 1;  /**< Auto-Negotiation enable. */
+	uint64_t pwr_dn                       : 1;  /**< Power down:
+                                                         0 = Normal operation.
+                                                         1 = Power down (hardware reset). */
 	uint64_t reserved_10_10               : 1;
 	uint64_t rst_an                       : 1;  /**< Reset Auto-Negotiation. When set, if AN_EN = 1 and
-                                                         BGX(0..5)_GMP_PCS_MR(0..3)_STATUS[AN_ABIL] = 1, Auto-Negotiation begins. Otherwise,
+                                                         BGX()_GMP_PCS_MR()_STATUS[AN_ABIL] = 1, Auto-Negotiation begins. Otherwise,
                                                          software write requests are ignored and this bit remains at 0. This bit clears itself to
                                                          0, when Auto-Negotiation starts. */
-	uint64_t dup                          : 1;  /**< Duplex mode: 1 = full duplex, 0 = half duplex; effective only if Auto-Negotiation is
-                                                         disabled. If BGX(0..5)_GMP_PCS_MR(0..3)_STATUS <15:9> and
-                                                         BGX(0..5)_GMP_PCS_AN(0..3)_ADV<15:12> allow only one duplex mode, this bit corresponds to
+	uint64_t dup                          : 1;  /**< Duplex mode:
+                                                           0 = half duplex; effective only if Auto-Negotiation is disabled.
+                                                           1 = full duplex.
+                                                         If BGX()_GMP_PCS_MR()_STATUS <15:9> and
+                                                         BGX()_GMP_PCS_AN()_ADV<15:12> allow only one duplex mode, this bit corresponds to
                                                          that value and any attempts to write are ignored. */
-	uint64_t coltst                       : 1;  /**< COL test: 1 = enable COL signal test, 0 = disable test.
+	uint64_t coltst                       : 1;  /**< Enable COL signal test.
                                                          During COL test, the COL signal reflects the GMII TX_EN signal with less than 16BT delay. */
 	uint64_t spdmsb                       : 1;  /**< Link speed most-significant bit, i.e SPD<1>; effective only if Auto-Negotiation is
                                                          disabled.
-                                                         SPDMSB SPDLSB Link Speed
-                                                         0 0 10 Mb/s
-                                                         0 1 100 Mb/s
-                                                         1 0 1000 Mb/s
-                                                         1 1 reserved */
+                                                         <pre>
+                                                         [SPDMSB]   [SPDLSB]   Link Speed
+                                                          0          0         10 Mb/s
+                                                          0          1         100 Mb/s
+                                                          1          0         1000 Mb/s
+                                                          1          1         reserved
+                                                         </pre> */
 	uint64_t uni                          : 1;  /**< Unidirectional (Std 802.3-2005, Clause 66.2). When set to 1, this bit overrides AN_EN and
                                                          disables the Auto-Negotiation variable mr_an_enable. Used in both 1000BASE-X and SGMII
                                                          modes. */
@@ -4701,7 +4723,7 @@ typedef union cvmx_bgxx_gmp_pcs_mrx_control cvmx_bgxx_gmp_pcs_mrx_control_t;
  * cvmx_bgx#_gmp_pcs_mr#_status
  *
  * Bits <15:9> in this register indicate the ability to operate when
- * BGX(0..5)_GMP_PCS_MISC(0..3)_CTL[MAC_PHY] is set to MAC mode. Bits <15:9> are always read as
+ * BGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set to MAC mode. Bits <15:9> are always read as
  * 0, indicating that the chip cannot operate in the corresponding modes. The field [RM_FLT] is a
  * 'don't care' when the selected mode is SGMII.
  */
@@ -4718,19 +4740,21 @@ union cvmx_bgxx_gmp_pcs_mrx_status {
 	uint64_t hun_t2fd                     : 1;  /**< Indicates 100BASE-T2 full duplex. */
 	uint64_t hun_t2hd                     : 1;  /**< Indicates 100BASE-T2 half duplex. */
 	uint64_t ext_st                       : 1;  /**< Extended status information. When set to 1, indicates that additional status data is
-                                                         available in BGX(0..5)_GMP_PCS_AN(0..3)_EXT_ST. */
+                                                         available in BGX()_GMP_PCS_AN()_EXT_ST. */
 	uint64_t reserved_7_7                 : 1;
 	uint64_t prb_sup                      : 1;  /**< Preamble not needed.
-                                                         1 = Can work without preamble bytes at the beginning of frames.
-                                                         0 = Cannot accept frames without preamble bytes. */
+                                                         0 = Cannot accept frames without preamble bytes.
+                                                         1 = Can work without preamble bytes at the beginning of frames. */
 	uint64_t an_cpt                       : 1;  /**< Indicates Auto-Negotiation is complete; the contents of the
-                                                         BGX(0..5)_GMP_PCS_AN(0..3)_RESULTS are valid. */
+                                                         BGX()_GMP_PCS_AN()_RESULTS are valid. */
 	uint64_t rm_flt                       : 1;  /**< Indicates remote fault condition occurred. This bit implements a latching-high behavior.
                                                          It is cleared when software reads this register or when
-                                                         BGX(0..5)_GMP_PCS_MR(0..3)_CONTROL[RESET] is asserted.
-                                                         See BGX(0..5)_GMP_PCS_AN(0..3)_ADV[REM_FLT] for fault conditions. */
+                                                         BGX()_GMP_PCS_MR()_CONTROL[RESET] is asserted.
+                                                         See BGX()_GMP_PCS_AN()_ADV[REM_FLT] for fault conditions. */
 	uint64_t an_abil                      : 1;  /**< Indicates Auto-Negotiation capable. */
-	uint64_t lnk_st                       : 1;  /**< Link state: 0 = link down, 1 = link up.
+	uint64_t lnk_st                       : 1;  /**< Link state:
+                                                           0 = link down.
+                                                           1 = link up.
                                                          Set during Auto-Negotiation process. Set whenever XMIT = DATA. Latching-low behavior when
                                                          link goes down. Link down value of the bit stays low until software reads the register. */
 	uint64_t reserved_1_1                 : 1;
@@ -4812,7 +4836,7 @@ typedef union cvmx_bgxx_gmp_pcs_rxx_sync cvmx_bgxx_gmp_pcs_rxx_sync_t;
  *
  * This is the SGMII Auto-Negotiation advertisement register (sent out as TX_CONFIG_REG). This
  * register is sent during Auto-Negotiation if
- * BGX(0..5)_GMP_PCS_MISC(0..3)_CTL[MAC_PHY] is set (1 = PHY mode). If the bit is not set (0 =
+ * BGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set (1 = PHY mode). If the bit is not set (0 =
  * MAC mode), the TX_CONFIG_REG<14> becomes ACK bit and <0> is always 1. All other bits in
  * TX_CONFIG_REG sent will be 0. The PHY dictates the Auto-Negotiation results.
  */
@@ -4910,7 +4934,7 @@ typedef union cvmx_bgxx_gmp_pcs_txx_states cvmx_bgxx_gmp_pcs_txx_states_t;
 /**
  * cvmx_bgx#_gmp_pcs_tx_rx#_polarity
  *
- * BGX(0..5)_GMP_PCS_TX_RX(0..3)_POLARITY[AUTORXPL] shows correct polarity needed on the link
+ * BGX()_GMP_PCS_TX_RX()_POLARITY[AUTORXPL] shows correct polarity needed on the link
  * receive path after code group synchronization is achieved.
  */
 union cvmx_bgxx_gmp_pcs_tx_rxx_polarity {
@@ -4919,11 +4943,11 @@ union cvmx_bgxx_gmp_pcs_tx_rxx_polarity {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
 	uint64_t rxovrd                       : 1;  /**< RX polarity override.
-                                                         0 = AUTORXPL determines polarity
-                                                         1 = RXPLRT determines polarity */
+                                                         0 = AUTORXPL determines polarity.
+                                                         1 = RXPLRT determines polarity. */
 	uint64_t autorxpl                     : 1;  /**< Auto RX polarity detected:
-                                                         0 = Normal polarity
-                                                         1 = Inverted polarity
+                                                         0 = Normal polarity.
+                                                         1 = Inverted polarity.
                                                          This bit always represents the correct RX polarity setting needed for successful RX path
                                                          operation, once a successful code group sync is obtained. */
 	uint64_t rxplrt                       : 1;  /**< RX polarity: 0 = Normal polarity, 1 = Inverted polarity. */
@@ -4957,10 +4981,10 @@ union cvmx_bgxx_smux_cbfc_ctl {
 	uint64_t bck_en                       : 1;  /**< Forward PFC/CBFC PAUSE information to the backpressure block. */
 	uint64_t drp_en                       : 1;  /**< Drop-control enable. When set, drop PFC/CBFC PAUSE frames. */
 	uint64_t tx_en                        : 1;  /**< Transmit enable. When set, allow for PFC/CBFC PAUSE packets. Must be clear in HiGig2 mode
-                                                         i.e. when BGX(0..5)_SMU(0..3)_TX_CTL[HG_EN] = 1 and BGX(0..5)_SMU(0..3)_RX_UDD_SKP[LEN] =
+                                                         i.e. when BGX()_SMU()_TX_CTL[HG_EN] = 1 and BGX()_SMU()_RX_UDD_SKP[LEN] =
                                                          16. */
 	uint64_t rx_en                        : 1;  /**< Receive enable. When set, allow for PFC/CBFC PAUSE packets. Must be clear in HiGig2 mode
-                                                         i.e. when BGX(0..5)_SMU(0..3)_TX_CTL[HG_EN] = 1 and BGX(0..5)_SMU(0..3)_RX_UDD_SKP[LEN] =
+                                                         i.e. when BGX()_SMU()_TX_CTL[HG_EN] = 1 and BGX()_SMU()_RX_UDD_SKP[LEN] =
                                                          16. */
 #else
 	uint64_t rx_en                        : 1;
@@ -4985,7 +5009,7 @@ union cvmx_bgxx_smux_ctrl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t tx_idle                      : 1;  /**< TX machine is idle. This indication pertains to the framer FSM and ignores the effects on
-                                                         the data-path controls or values which occur when BGX(0..5)_SMU(0..3)_TX_CTL[LS_BYP] is
+                                                         the data-path controls or values which occur when BGX()_SMU()_TX_CTL[LS_BYP] is
                                                          set. */
 	uint64_t rx_idle                      : 1;  /**< RX machine is idle. */
 #else
@@ -5002,7 +5026,7 @@ typedef union cvmx_bgxx_smux_ctrl cvmx_bgxx_smux_ctrl_t;
  * cvmx_bgx#_smu#_ext_loopback
  *
  * In loopback mode, the IFG1+IFG2 of local and remote parties must match exactly; otherwise one
- * of the two sides' loopback FIFO will overrun: BGX(0..5)_SMU(0..3)_TX_INT[LB_OVRFLW].
+ * of the two sides' loopback FIFO will overrun: BGX()_SMU()_TX_INT[LB_OVRFLW].
  */
 union cvmx_bgxx_smux_ext_loopback {
 	uint64_t u64;
@@ -5028,16 +5052,19 @@ typedef union cvmx_bgxx_smux_ext_loopback cvmx_bgxx_smux_ext_loopback_t;
  *
  * HiGig2 TX- and RX-enable are normally set together for HiGig2 messaging. Setting just the TX
  * or RX bit results in only the HG2 message transmit or receive capability.
+ *
  * Setting [PHYS_EN] and [LOGL_EN] to 1 allows link PAUSE or backpressure to PKO as per the
  * received HiGig2 message. Setting these fields to 0 disables link PAUSE and backpressure to PKO
  * in response to received messages.
- * BGX(0..5)_SMU(0..3)_TX_CTL[HG_EN] must be set (to enable HiGig) whenever either [HG2TX_EN] or
- * [HG2RX_EN] are set. BGX(0..5)_SMU(0..3)_RX_UDD_SKP[LEN] must be set to 16 (to select HiGig2)
+ *
+ * BGX()_SMU()_TX_CTL[HG_EN] must be set (to enable HiGig) whenever either [HG2TX_EN] or
+ * [HG2RX_EN] are set. BGX()_SMU()_RX_UDD_SKP[LEN] must be set to 16 (to select HiGig2)
  * whenever either [HG2TX_EN] or [HG2RX_EN] are set.
- * BGX(0..5)_CMR_RX_OVR_BP[EN<0>] must be set and BGX(0..5)_CMR_RX_OVR_BP[BP<0>] must be cleared
+ *
+ * BGX()_CMR_RX_OVR_BP[EN<0>] must be set and BGX()_CMR_RX_OVR_BP[BP<0>] must be cleared
  * to 0 (to forcibly disable hardware-automatic 802.3 PAUSE packet generation) with the HiGig2
- * Protocol when BGX(0..5)_SMU(0..3)_HG2_CONTROL[HG2TX_EN] = 0. (The HiGig2 protocol is indicated
- * by BGX(0..5)_SMU(0..3)_TX_CTL[HG_EN] = 1 and BGX(0..5)_SMU(0..3)_RX_UDD_SKP[LEN]=16.) Hardware
+ * Protocol when BGX()_SMU()_HG2_CONTROL[HG2TX_EN] = 0. (The HiGig2 protocol is indicated
+ * by BGX()_SMU()_TX_CTL[HG_EN] = 1 and BGX()_SMU()_RX_UDD_SKP[LEN]=16.) Hardware
  * can only autogenerate backpressure via HiGig2 messages (optionally, when HG2TX_EN = 1) with
  * the HiGig2 protocol.
  */
@@ -5047,7 +5074,7 @@ union cvmx_bgxx_smux_hg2_control {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_19_63               : 45;
 	uint64_t hg2tx_en                     : 1;  /**< Enable transmission of HG2 physical and logical messages. When set, also disables hardware
-                                                         autogenerated (802.3 and PFC/CBFC) PAUSE frames. (CN78XX cannot generate proper 802.3 or
+                                                         autogenerated (802.3 and PFC/CBFC) PAUSE frames. (CNXXXX cannot generate proper 802.3 or
                                                          PFC/CBFC PAUSE frames in HiGig2 mode.) */
 	uint64_t hg2rx_en                     : 1;  /**< Enable extraction and processing of HG2 message packet from RX flow. Physical and logical
                                                          PAUSE information is used to PAUSE physical-link, backpressure PKO. This field must be set
@@ -5080,10 +5107,10 @@ union cvmx_bgxx_smux_rx_bad_col_hi {
 	struct cvmx_bgxx_smux_rx_bad_col_hi_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_17_63               : 47;
-	uint64_t val                          : 1;  /**< Set when BGX(0..5)_SMU(0..3)_RX_INT[PCTERR] is set. */
-	uint64_t state                        : 8;  /**< When BGX(0..5)_SMU(0..3)_RX_INT[PCTERR] is set, contains the receive state at the time of
+	uint64_t val                          : 1;  /**< Set when BGX()_SMU()_RX_INT[PCTERR] is set. */
+	uint64_t state                        : 8;  /**< When BGX()_SMU()_RX_INT[PCTERR] is set, contains the receive state at the time of
                                                          the error. */
-	uint64_t lane_rxc                     : 8;  /**< When BGX(0..5)_SMU(0..3)_RX_INT[PCTERR] is set, contains the column at the time of the error. */
+	uint64_t lane_rxc                     : 8;  /**< When BGX()_SMU()_RX_INT[PCTERR] is set, contains the column at the time of the error. */
 #else
 	uint64_t lane_rxc                     : 8;
 	uint64_t state                        : 8;
@@ -5102,7 +5129,7 @@ union cvmx_bgxx_smux_rx_bad_col_lo {
 	uint64_t u64;
 	struct cvmx_bgxx_smux_rx_bad_col_lo_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t lane_rxd                     : 64; /**< When BGX(0..5)_SMU(0..3)_RX_INT[PCTERR] is set, LANE_RXD contains the XAUI/RXAUI column at
+	uint64_t lane_rxd                     : 64; /**< When BGX()_SMU()_RX_INT[PCTERR] is set, LANE_RXD contains the XAUI/RXAUI column at
                                                          the time of the error. */
 #else
 	uint64_t lane_rxd                     : 64;
@@ -5121,10 +5148,10 @@ union cvmx_bgxx_smux_rx_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t status                       : 2;  /**< Link status.
-                                                         0x0 = Link OK
-                                                         0x1 = Local fault
-                                                         0x2 = Remote fault
-                                                         0x3 = Reserved */
+                                                         0x0 = Link OK.
+                                                         0x1 = Local fault.
+                                                         0x2 = Remote fault.
+                                                         0x3 = Reserved. */
 #else
 	uint64_t status                       : 2;
 	uint64_t reserved_2_63                : 62;
@@ -5140,8 +5167,8 @@ typedef union cvmx_bgxx_smux_rx_ctl cvmx_bgxx_smux_rx_ctl_t;
  * This register specifies the byte count used to determine when to accept or to filter a packet.
  * As each byte in a packet is received by BGX, the L2 byte count (i.e. the number of bytes from
  * the beginning of the L2 header (DMAC)) is compared against CNT. In normal operation, the L2
- * header begins after the PREAMBLE + SFD (BGX(0..5)_SMU(0..3)_RX_FRM_CTL[PRE_CHK] = 1) and any
- * optional UDD skip data (BGX(0..5)_SMU(0..3)_RX_UDD_SKP[LEN]).
+ * header begins after the PREAMBLE + SFD (BGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 1) and any
+ * optional UDD skip data (BGX()_SMU()_RX_UDD_SKP[LEN]).
  */
 union cvmx_bgxx_smux_rx_decision {
 	uint64_t u64;
@@ -5197,9 +5224,10 @@ typedef union cvmx_bgxx_smux_rx_frm_chk cvmx_bgxx_smux_rx_frm_chk_t;
  * This register controls the handling of the frames.
  * The CTL_BCK/CTL_DRP bits control how the hardware handles incoming PAUSE packets. The most
  * common modes of operation:
- * CTL_BCK = 1, CTL_DRP = 1: hardware handles everything
- * CTL_BCK = 0, CTL_DRP = 0: software sees all PAUSE frames
- * CTL_BCK = 0, CTL_DRP = 1: all PAUSE frames are completely ignored
+ * _ CTL_BCK = 1, CTL_DRP = 1: hardware handles everything
+ * _ CTL_BCK = 0, CTL_DRP = 0: software sees all PAUSE frames
+ * _ CTL_BCK = 0, CTL_DRP = 1: all PAUSE frames are completely ignored
+ *
  * These control bits should be set to CTL_BCK = 0, CTL_DRP = 0 in half-duplex mode. Since PAUSE
  * packets only apply to full duplex operation, any PAUSE packet would constitute an exception
  * which should be handled by the processing cores. PAUSE packets should not be forwarded.
@@ -5212,26 +5240,25 @@ union cvmx_bgxx_smux_rx_frm_ctl {
 	uint64_t ptp_mode                     : 1;  /**< Timestamp mode. When PTP_MODE is set, a 64-bit timestamp is prepended to every incoming
                                                          packet.
                                                          The timestamp bytes are added to the packet in such a way as to not modify the packet's
-                                                         receive byte count. This implies that the BGX(0..5)_SMU(0..3)_RX_JABBER,
-                                                         BGX(0..5)_SMU(0..3)_RX_DECISION, and BGX(0..5)_SMU(0..3)_RX_UDD_SKP do not require any
+                                                         receive byte count. This implies that the BGX()_SMU()_RX_JABBER,
+                                                         BGX()_SMU()_RX_DECISION, and BGX()_SMU()_RX_UDD_SKP do not require any
                                                          adjustment as they operate on the received packet size. When the packet reaches PKI, its
                                                          size reflects the additional bytes and is subject to the following restrictions:
                                                          If PTP_MODE = 1 and PRE_CHK = 1, PRE_STRP must be 1.
-                                                         If PTP_MODE = 1
-                                                         * PKI_CL(0..3)_PKIND(0..63)_SKIP[FCS_SKIP,INST_SKIP] should be increased by 8
-                                                         * PKI_CL(0..3)_PKIND(0..63)_CFG[HG_EN] should be 0
-                                                         * PKI_FRM_LEN_CHK(0..1)[MAXLEN] should be increased by 8
-                                                         * PKI_FRM_LEN_CHK(0..1)[MINLEN] should be increased by 8
-                                                         * PKI_TAG_INC(0..31)_MASK should be adjusted
-                                                         This supported in uCode in CN78XX>>> PIP_PRT_CFGB(0..63)[ALT_SKP_EN] should be 0. */
+                                                         If PTP_MODE = 1:
+                                                         * PKI_CL()_PKIND()_SKIP[FCS_SKIP,INST_SKIP] should be increased by 8.
+                                                         * PKI_CL()_PKIND()_CFG[HG_EN] should be 0.
+                                                         * PKI_FRM_LEN_CHK()[MAXLEN] should be increased by 8.
+                                                         * PKI_FRM_LEN_CHK()[MINLEN] should be increased by 8.
+                                                         * PKI_TAG_INC()_MASK should be adjusted. */
 	uint64_t reserved_6_11                : 6;
 	uint64_t ctl_smac                     : 1;  /**< Control PAUSE frames can match station SMAC. */
 	uint64_t ctl_mcst                     : 1;  /**< Control PAUSE frames can match globally assign multicast address. */
 	uint64_t ctl_bck                      : 1;  /**< Forward PAUSE information to TX block. */
 	uint64_t ctl_drp                      : 1;  /**< Drop control PAUSE frames. */
 	uint64_t pre_strp                     : 1;  /**< Strip off the preamble (when present).
-                                                         0 = PREAMBLE + SFD is sent to core as part of frame
-                                                         1 = PREAMBLE + SFD is dropped
+                                                         0 = PREAMBLE + SFD is sent to core as part of frame.
+                                                         1 = PREAMBLE + SFD is dropped.
                                                          [PRE_CHK] must be set to enable this and all PREAMBLE features.
                                                          If PTP_MODE = 1 and PRE_CHK = 1, PRE_STRP must be 1.
                                                          When PRE_CHK is set (indicating that the PREAMBLE will be sent), PRE_STRP determines if
@@ -5243,8 +5270,8 @@ union cvmx_bgxx_smux_rx_frm_ctl {
                                                          This port is configured to send a valid 802.3 PREAMBLE to begin every frame. BGX checks
                                                          that a valid PREAMBLE is received (based on PRE_FREE). When a problem does occur within
                                                          the PREAMBLE sequence, the frame is marked as bad and not sent into the core. The
-                                                         BGX(0..5)_SMU(0..3)_RX_INT[PCTERR] interrupt is also raised.
-                                                         When BGX(0..5)_SMU(0..3)_TX_CTL[HG_EN] is set, PRE_CHK must be 0.
+                                                         BGX()_SMU()_RX_INT[PCTERR] interrupt is also raised.
+                                                         When BGX()_SMU()_TX_CTL[HG_EN] is set, PRE_CHK must be 0.
                                                          If PTP_MODE = 1 and PRE_CHK = 1, PRE_STRP must be 1. */
 #else
 	uint64_t pre_chk                      : 1;
@@ -5279,9 +5306,9 @@ union cvmx_bgxx_smux_rx_int {
                                                          HG2CC getting set never sets HG2FLD. */
 	uint64_t hg2fld                       : 1;  /**< HiGig2 received message field error:
                                                          MSG_TYPE field not 0x0, i.e. it is not a flow-control message, which is the only defined
-                                                         type for HiGig2
+                                                         type for HiGig2.
                                                          FWD_TYPE field not 0x0, i.e. it is not a link-level message, which is the only defined
-                                                         type for HiGig2
+                                                         type for HiGig2.
                                                          FC_OBJECT field is neither 0x0 for physical link, nor 0x2 for logical link. Those are the
                                                          only two defined types in HiGig2 */
 	uint64_t bad_term                     : 1;  /**< Frame is terminated by control character other than /T/. (XAUI/RXAUI mode only) The error
@@ -5292,7 +5319,8 @@ union cvmx_bgxx_smux_rx_int {
 	uint64_t loc_fault                    : 1;  /**< Local-fault sequence detected. (XAUI/RXAUI mode only) */
 	uint64_t rsverr                       : 1;  /**< Reserved opcodes. */
 	uint64_t pcterr                       : 1;  /**< Bad preamble/protocol. In XAUI/RXAUI mode, the column of data that was bad is logged in
-                                                         BGX(0..5)_SMU(0..3)_RX_BAD_COL_*. PCTERR checks that the frame begins with a valid
+                                                         BGX()_SMU()_RX_BAD_COL_LO and BGX()_SMU()_RX_BAD_COL_HI.
+                                                         PCTERR checks that the frame begins with a valid
                                                          PREAMBLE sequence. Does not check the number of PREAMBLE cycles. */
 	uint64_t skperr                       : 1;  /**< Skipper error. */
 	uint64_t rcverr                       : 1;  /**< Frame was received with data-reception error. */
@@ -5324,6 +5352,18 @@ typedef union cvmx_bgxx_smux_rx_int cvmx_bgxx_smux_rx_int_t;
 
 /**
  * cvmx_bgx#_smu#_rx_jabber
+ *
+ * This register specifies the maximum size for packets, beyond which the SMU truncates. In
+ * XAUI/RXAUI mode, port 0 is used for checking.
+ *
+ * INTERNAL:
+ * The packet that will be sent to the packet input logic will have an
+ * additionl 8 bytes if BGX()_SMU()_RX_FRM_CTL[PRE_CHK] is set and
+ * BGX()_SMU()_RX_FRM_CTL[PRE_STRP] is clear.  The max packet that will be sent is
+ * defined as:
+ *
+ * _ max_sized_packet = BGX()_SMU()_RX_JABBER[CNT]+((BGX()_SMU()_RX_FRM_CTL[PRE_CHK] &
+ * !BGX()_SMU()_RX_FRM_CTL[PRE_STRP])*8)
  */
 union cvmx_bgxx_smux_rx_jabber {
 	uint64_t u64;
@@ -5344,6 +5384,29 @@ typedef union cvmx_bgxx_smux_rx_jabber cvmx_bgxx_smux_rx_jabber_t;
 
 /**
  * cvmx_bgx#_smu#_rx_udd_skp
+ *
+ * This register specifies the amount of user-defined data (UDD) added before the start of the
+ * L2C data.
+ *
+ * INTERNAL:
+ *
+ * (1) The skip bytes are part of the packet and will be sent down the NCB
+ * packet interface and will be handled by PKI.
+ *
+ * (2) The system can determine if the UDD bytes are included in the FCS check
+ * by using the FCSSEL field if the FCS check is enabled.
+ *
+ * (3) Assume that the preamble/sfd is always at the start of the frame even
+ * before UDD bytes.  In most cases, there will be no preamble in these
+ * cases since it will be packet interface in direct communication to
+ * another packet interface (MAC to MAC) without a PHY involved.
+ *
+ * (4) We can still do address filtering and control packet filtering if the
+ * user desires.
+ *
+ * (6) In all cases, the UDD bytes will be sent down the packet interface as
+ * part of the packet.  The UDD bytes are never stripped from the actual
+ * packet.
  */
 union cvmx_bgxx_smux_rx_udd_skp {
 	uint64_t u64;
@@ -5351,9 +5414,9 @@ union cvmx_bgxx_smux_rx_udd_skp {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t fcssel                       : 1;  /**< Include the skip bytes in the FCS calculation.
-                                                         0 = All skip bytes are included in FCS
-                                                         1 = The skip bytes are not included in FCS
-                                                         When BGX(0..5)_SMU(0..3)_TX_CTL[HG_EN] is set, this field must be 0.
+                                                         0 = All skip bytes are included in FCS.
+                                                         1 = The skip bytes are not included in FCS.
+                                                         When BGX()_SMU()_TX_CTL[HG_EN] is set, this field must be 0.
                                                          The skip bytes are part of the packet and are sent through the IOI packet interface and
                                                          are handled by PKI. The system can determine if the UDD bytes are included in the FCS
                                                          check by using the FCSSEL field, if the FCS check is enabled. */
@@ -5361,7 +5424,7 @@ union cvmx_bgxx_smux_rx_udd_skp {
 	uint64_t len                          : 7;  /**< Amount of user-defined data before the start of the L2C data, in bytes.
                                                          Setting to 0 means L2C comes first; maximum value is 64.
                                                          LEN must be 0x0 in half-duplex operation.
-                                                         When BGX(0..5)_SMU(0..3)_TX_CTL[HG_EN] is set, this field must be set to 12 or 16
+                                                         When BGX()_SMU()_TX_CTL[HG_EN] is set, this field must be set to 12 or 16
                                                          (depending on HiGig header size) to account for the HiGig header.
                                                          LEN = 12 selects HiGig/HiGig+; LEN = 16 selects HiGig2. */
 #else
@@ -5397,7 +5460,7 @@ typedef union cvmx_bgxx_smux_smac cvmx_bgxx_smux_smac_t;
  * cvmx_bgx#_smu#_tx_append
  *
  * For more details on the interactions between FCS and PAD, see also the description of
- * BGX(0..5)_SMU(0..3)_TX_MIN_PKT[MIN_SIZE].
+ * BGX()_SMU()_TX_MIN_PKT[MIN_SIZE].
  */
 union cvmx_bgxx_smux_tx_append {
 	uint64_t u64;
@@ -5405,10 +5468,10 @@ union cvmx_bgxx_smux_tx_append {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_4_63                : 60;
 	uint64_t fcs_c                        : 1;  /**< Append the Ethernet FCS on each PAUSE packet. PAUSE packets are normally padded to 60
-                                                         bytes. If BGX(0..5)_SMU(0..3)_TX_MIN_PKT[MIN_SIZE] exceeds 59, then FCS_C is not used. */
+                                                         bytes. If BGX()_SMU()_TX_MIN_PKT[MIN_SIZE] exceeds 59, then FCS_C is not used. */
 	uint64_t fcs_d                        : 1;  /**< Append the Ethernet FCS on each data packet. */
 	uint64_t pad                          : 1;  /**< Append PAD bytes such that minimum-sized packet is transmitted. */
-	uint64_t preamble                     : 1;  /**< Prepend the Ethernet preamble on each transfer. When BGX(0..5)_SMU(0..3)_TX_CTL[HG_EN] is
+	uint64_t preamble                     : 1;  /**< Prepend the Ethernet preamble on each transfer. When BGX()_SMU()_TX_CTL[HG_EN] is
                                                          set, PREAMBLE must be 0. */
 #else
 	uint64_t preamble                     : 1;
@@ -5440,23 +5503,23 @@ union cvmx_bgxx_smux_tx_ctl {
                                                          default value should always be used for normal operation. */
 	uint64_t hg_pause_hgi                 : 2;  /**< HGI field for hardware-generated HiGig PAUSE packets. */
 	uint64_t hg_en                        : 1;  /**< Enable HiGig mode.
-                                                         When this field is set and BGX(0..5)_SMU(0..3)_RX_UDD_SKP[LEN] = 12, the interface is in
+                                                         When this field is set and BGX()_SMU()_RX_UDD_SKP[LEN] = 12, the interface is in
                                                          HiGig/HiGig+ mode and the following must be set:
-                                                         BGX(0..5)_SMU(0..3)_RX_FRM_CTL[PRE_CHK] = 0
-                                                         BGX(0..5)_SMU(0..3)_RX_UDD_SKP[FCSSEL] = 0
-                                                         BGX(0..5)_SMU(0..3)_RX_UDD_SKP[LEN] = 12
-                                                         BGX(0..5)_SMU(0..3)_TX_APPEND[PREAMBLE] = 0
-                                                         When this field is set and BGX(0..5)_SMU(0..3)_RX_UDD_SKP[LEN] = 16, the interface is in
+                                                         * BGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 0.
+                                                         * BGX()_SMU()_RX_UDD_SKP[FCSSEL] = 0.
+                                                         * BGX()_SMU()_RX_UDD_SKP[LEN] = 12.
+                                                         * BGX()_SMU()_TX_APPEND[PREAMBLE] = 0.
+                                                         When this field is set and BGX()_SMU()_RX_UDD_SKP[LEN] = 16, the interface is in
                                                          HiGig2 mode and the following must be set:
-                                                         BGX(0..5)_SMU(0..3)_RX_FRM_CTL[PRE_CHK] = 0
-                                                         BGX(0..5)_SMU(0..3)_RX_UDD_SKP[FCSSEL] = 0
-                                                         BGX(0..5)_SMU(0..3)_RX_UDD_SKP[LEN] = 16
-                                                         BGX(0..5)_SMU(0..3)_TX_APPEND[PREAMBLE] = 0
-                                                         BGX(0..5)_SMU(0..3)_CBFC_CTL[RX_EN] = 0
-                                                         BGX(0..5)_SMU(0..3)_CBFC_CTL[TX_EN] = 0 */
+                                                         * BGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 0.
+                                                         * BGX()_SMU()_RX_UDD_SKP[FCSSEL] = 0.
+                                                         * BGX()_SMU()_RX_UDD_SKP[LEN] = 16.
+                                                         * BGX()_SMU()_TX_APPEND[PREAMBLE] = 0.
+                                                         * BGX()_SMU()_CBFC_CTL[RX_EN] = 0.
+                                                         * BGX()_SMU()_CBFC_CTL[TX_EN] = 0. */
 	uint64_t l2p_bp_conv                  : 1;  /**< If set, causes TX to generate 802.3 pause packets when CMR applies logical backpressure
-                                                         (XOFF), if and only if BGX(0..5)_SMU(0..3)_CBFC_CTL[TX_EN] is clear and
-                                                         BGX(0..5)_SMU(0..3)_HG2_CONTROL[HG2TX_EN] is clear. */
+                                                         (XOFF), if and only if BGX()_SMU()_CBFC_CTL[TX_EN] is clear and
+                                                         BGX()_SMU()_HG2_CONTROL[HG2TX_EN] is clear. */
 	uint64_t ls_byp                       : 1;  /**< Bypass the link status, as determined by the XGMII receiver, and set the link status of
                                                          the transmitter to LS. */
 	uint64_t ls                           : 2;  /**< Link status.
@@ -5491,15 +5554,15 @@ typedef union cvmx_bgxx_smux_tx_ctl cvmx_bgxx_smux_tx_ctl_t;
  * * For XAUI/RXAUI/10Gbs/40Gbs systems that require IEEE 802.3 compatibility, the IFG1+IFG2 sum
  * must be 12.
  * * In loopback mode, the IFG1+IFG2 of local and remote parties must match exactly; otherwise
- * one of the two sides' loopback FIFO will overrun: BGX(0..5)_SMU(0..3)_TX_INT[LB_OVRFLW].
+ * one of the two sides' loopback FIFO will overrun: BGX()_SMU()_TX_INT[LB_OVRFLW].
  */
 union cvmx_bgxx_smux_tx_ifg {
 	uint64_t u64;
 	struct cvmx_bgxx_smux_tx_ifg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t ifg2                         : 4;  /**< 1/2 of the interframe gap timing (in IFG2*8 bits) */
-	uint64_t ifg1                         : 4;  /**< 1/2 of the interframe gap timing (in IFG1*8 bits) */
+	uint64_t ifg2                         : 4;  /**< 1/2 of the interframe gap timing (in IFG2*8 bits). */
+	uint64_t ifg1                         : 4;  /**< 1/2 of the interframe gap timing (in IFG1*8 bits). */
 #else
 	uint64_t ifg1                         : 4;
 	uint64_t ifg2                         : 4;
@@ -5522,7 +5585,7 @@ union cvmx_bgxx_smux_tx_int {
 	uint64_t lb_undflw                    : 1;  /**< TX loopback underflow. */
 	uint64_t fake_commit                  : 1;  /**< TX SMU started a packet with PTP on SOP and has not seen a commit for it from TX SPU after
                                                          2^SMU_TX_PTP_TIMEOUT_WIDTH (2^8) cycles so it faked a commit to CMR. */
-	uint64_t xchange                      : 1;  /**< Link status changed. This denotes a change to BGX(0..5)_SMU(0..3)_RX_CTL[STATUS]. */
+	uint64_t xchange                      : 1;  /**< Link status changed. This denotes a change to BGX()_SMU()_RX_CTL[STATUS]. */
 	uint64_t undflw                       : 1;  /**< TX underflow. */
 #else
 	uint64_t undflw                       : 1;
@@ -5546,7 +5609,7 @@ union cvmx_bgxx_smux_tx_min_pkt {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
 	uint64_t min_size                     : 8;  /**< Min frame in bytes inclusive of FCS, if applied. Padding is only appended when
-                                                         BGX(0..5)_SMU(0..3)_TX_APPEND[PAD] for the corresponding port is set. When FCS is added to
+                                                         BGX()_SMU()_TX_APPEND[PAD] for the corresponding port is set. When FCS is added to
                                                          a packet which was padded, the FCS always appears in the 4 octets preceding /T/ or /E/. */
 #else
 	uint64_t min_size                     : 8;
@@ -5592,11 +5655,11 @@ union cvmx_bgxx_smux_tx_pause_pkt_interval {
 	uint64_t hg2_intra_en                 : 1;  /**< Allow intrapacket HiGig2 message generation. Relevant only if HiGig2 message generation is enabled. */
 	uint64_t hg2_intra_interval           : 16; /**< Arbitrate for a HiGig2 message, every (INTERVAL*512) bit-times whilst sending regular
                                                          packet data. Relevant only if HiGig2 message generation and HG2_INTRA_EN are both set.
-                                                         Normally, 0 < INTERVAL < BGX(0..5)_SMU(0..3)_TX_PAUSE_PKT_TIME.
+                                                         Normally, 0 < INTERVAL < BGX()_SMU()_TX_PAUSE_PKT_TIME.
                                                          INTERVAL = 0 only sends a single PAUSE packet for each backpressure event. */
 	uint64_t interval                     : 16; /**< Arbitrate for a 802.3 PAUSE packet, HiGig2 message, or PFC/CBFC PAUSE packet every
                                                          (INTERVAL * 512) bit-times.
-                                                         Normally, 0 < INTERVAL < BGX(0..5)_SMU(0..3)_TX_PAUSE_PKT_TIME[TIME].
+                                                         Normally, 0 < INTERVAL < BGX()_SMU()_TX_PAUSE_PKT_TIME[PTIME].
                                                          INTERVAL = 0 only sends a single PAUSE packet for each backpressure event. */
 #else
 	uint64_t interval                     : 16;
@@ -5619,8 +5682,8 @@ union cvmx_bgxx_smux_tx_pause_pkt_time {
 	uint64_t reserved_16_63               : 48;
 	uint64_t p_time                       : 16; /**< Provides the pause_time field placed in outbound 802.3 PAUSE packets, HiGig2 messages, or
                                                          PFC/CBFC PAUSE packets in 512 bit-times. Normally, P_TIME >
-                                                         BGX(0..5)_SMU(0..3)_TX_PAUSE_PKT_INTERVAL[INTERVAL]. See programming notes in
-                                                         BGX(0..5)_SMU(0..3)_TX_PAUSE_PKT_INTERVAL. */
+                                                         BGX()_SMU()_TX_PAUSE_PKT_INTERVAL[INTERVAL]. See programming notes in
+                                                         BGX()_SMU()_TX_PAUSE_PKT_INTERVAL. */
 #else
 	uint64_t p_time                       : 16;
 	uint64_t reserved_16_63               : 48;
@@ -5722,9 +5785,9 @@ union cvmx_bgxx_smux_tx_thresh {
                                                          and must never be set to 0x0.
                                                          In 10G/40G mode, CNT = 0x100.
                                                          In all modes, this register cannot exceed the TX FIFO depth as follows.
-                                                         BGX(0..5)_CMR_TX_PRTS = 0,1:  CNT maximum = 0x7FF
-                                                         BGX(0..5)_CMR_TX_PRTS = 2:     CNT maximum = 0x3FF
-                                                         BGX(0..5)_CMR_TX_PRTS = 3,4:  CNT maximum = 0x1FF */
+                                                         _ BGX()_CMR_TX_PRTS = 0,1:  CNT maximum = 0x7FF.
+                                                         _ BGX()_CMR_TX_PRTS = 2:    CNT maximum = 0x3FF.
+                                                         _ BGX()_CMR_TX_PRTS = 3,4:  CNT maximum = 0x1FF. */
 #else
 	uint64_t cnt                          : 11;
 	uint64_t reserved_11_63               : 53;
@@ -5740,10 +5803,10 @@ typedef union cvmx_bgxx_smux_tx_thresh cvmx_bgxx_smux_tx_thresh_t;
  * Software programs this register with the contents of the AN-link code word base page to be
  * transmitted during Auto-Negotiation. (See Std 802.3 section 73.6 for details.) Any write
  * operations to this register prior to completion of Auto-Negotiation, as indicated by
- * BGX(0..5)_SPU(0..3)_AN_STATUS[AN_COMPLETE], should be followed by a renegotiation in order for
+ * BGX()_SPU()_AN_STATUS[AN_COMPLETE], should be followed by a renegotiation in order for
  * the new values to take effect. Renegotiation is initiated by setting
- * BGX(0..5)_SPU(0..3)_AN_STATUS[AN_RESTART]. Once Auto-Negotiation has completed, software can
- * examine this register along with BGX(0..5)_SPU(0..3)_AN_LP_BASE to determine the highest
+ * BGX()_SPU()_AN_CONTROL[AN_RESTART]. Once Auto-Negotiation has completed, software can
+ * examine this register along with BGX()_SPU()_AN_LP_BASE to determine the highest
  * common denominator technology.
  */
 union cvmx_bgxx_spux_an_adv {
@@ -5801,7 +5864,7 @@ typedef union cvmx_bgxx_spux_an_adv cvmx_bgxx_spux_an_adv_t;
  * cvmx_bgx#_spu#_an_bp_status
  *
  * The contents of this register (with the exception of the static BP_AN_ABLE bit) are updated
- * during Auto-Negotiation and are valid when BGX(0..5)_SPU(0..3)_AN_STATUS[AN_COMPLETE] is set.
+ * during Auto-Negotiation and are valid when BGX()_SPU()_AN_STATUS[AN_COMPLETE] is set.
  * At that time, one of the port type bits (A100G_CR10, A40G_CR4, A40G_KR4, A10G_KR, A10G_KX4,
  * A1G_KX) will be set depending on the AN priority resolution. If a BASE-R type is negotiated,
  * then the FEC bit will be set to indicate that FEC operation has been negotiated, and will be
@@ -5846,7 +5909,7 @@ union cvmx_bgxx_spux_an_control {
 	struct cvmx_bgxx_spux_an_control_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t an_reset                     : 1;  /**< Auto-Negotiation reset. Setting this bit or BGX(0..5)_SPU(0..3)_CONTROL1[RESET] to 1
+	uint64_t an_reset                     : 1;  /**< Auto-Negotiation reset. Setting this bit or BGX()_SPU()_CONTROL1[RESET] to 1
                                                          causes the following to happen:
                                                          * Resets the logical PCS (LPCS)
                                                          * Sets the Std 802.3 PCS, FEC and AN registers for the LPCS to their default states
@@ -5856,7 +5919,7 @@ union cvmx_bgxx_spux_an_control {
 	uint64_t reserved_14_14               : 1;
 	uint64_t xnp_en                       : 1;  /**< Extended next-page enable. */
 	uint64_t an_en                        : 1;  /**< Auto-Negotiation enable. This bit should not be set when
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] is set to RXAUI; auto-negotiation is not supported
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE] is set to RXAUI; auto-negotiation is not supported
                                                          in RXAUI mode. */
 	uint64_t reserved_10_11               : 2;
 	uint64_t an_restart                   : 1;  /**< Auto-Negotiation restart. Writing a 1 to this bit restarts the Auto-Negotiation process if
@@ -5882,7 +5945,7 @@ typedef union cvmx_bgxx_spux_an_control cvmx_bgxx_spux_an_control_t;
  *
  * This register captures the contents of the latest AN link code word base page received from
  * the link partner during Auto-Negotiation. (See Std 802.3 section 73.6 for details.)
- * BGX(0..5)_SPU(0..3)_AN_STATUS[PAGE_RX] is set when this register is updated by hardware.
+ * BGX()_SPU()_AN_STATUS[PAGE_RX] is set when this register is updated by hardware.
  */
 union cvmx_bgxx_spux_an_lp_base {
 	uint64_t u64;
@@ -5979,18 +6042,18 @@ union cvmx_bgxx_spux_an_status {
 	uint64_t reserved_8_8                 : 1;
 	uint64_t xnp_stat                     : 1;  /**< Extended next-page status. */
 	uint64_t page_rx                      : 1;  /**< Page received. This latching-high bit is set when a new page has been received and stored
-                                                         in BGX(0..5)_SPU(0..3)_AN_LP_BASE or BGX(0..5)_SPU(0..3)_AN_LP_XNP; stays set until a 1 is
+                                                         in BGX()_SPU()_AN_LP_BASE or BGX()_SPU()_AN_LP_XNP; stays set until a 1 is
                                                          written by software, Auto-Negotiation is disabled or restarted, or next page exchange is
-                                                         initiated. Note that in order to avoid read side effects, this is implemented as a write-1
-                                                         -to-clear bit, rather than latching high read-only as specified in 802.3. */
+                                                         initiated. Note that in order to avoid read side effects, this is implemented as a
+                                                         write-1-to-clear bit, rather than latching high read-only as specified in 802.3. */
 	uint64_t an_complete                  : 1;  /**< Auto-Negotiation complete. Set when the Auto-Negotiation process has been completed and
                                                          the link is up and running using the negotiated highest common denominator (HCD)
-                                                         technology. If AN is enabled (BGX(0..5)_SPU(0..3)_AN_CONTROL[AN_EN] = 1) and this bit is
+                                                         technology. If AN is enabled (BGX()_SPU()_AN_CONTROL[AN_EN] = 1) and this bit is
                                                          read as a zero, it indicates that the AN process has not been completed, and the contents
-                                                         of BGX(0..5)_SPU(0..3)_AN_LP_BASE, BGX(0..5)_SPU(0..3)_AN_XNP_TX, and
-                                                         BGX(0..5)_SPU(0..3)_AN_LP_XNP are as defined by the current state of the Auto-Negotiation
+                                                         of BGX()_SPU()_AN_LP_BASE, BGX()_SPU()_AN_XNP_TX, and
+                                                         BGX()_SPU()_AN_LP_XNP are as defined by the current state of the Auto-Negotiation
                                                          protocol, or as written for manual configuration. This bit is always zero when AN is
-                                                         disabled (BGX(0..5)_SPU(0..3)_AN_CONTROL[AN_EN] = 0). */
+                                                         disabled (BGX()_SPU()_AN_CONTROL[AN_EN] = 0). */
 	uint64_t rmt_flt                      : 1;  /**< Remote fault: Always 0. */
 	uint64_t an_able                      : 1;  /**< Auto-Negotiation ability: Always 1. */
 	uint64_t link_status                  : 1;  /**< Link status. This bit captures the state of the link_status variable as defined in 802.3
@@ -6069,10 +6132,10 @@ typedef union cvmx_bgxx_spux_an_xnp_tx cvmx_bgxx_spux_an_xnp_tx_t;
  *
  * This register implements the Std 802.3 multilane BASE-R PCS alignment status 1-4 registers
  * (3.50-3.53). It is valid only when the LPCS type is 40GBASE-R
- * (BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = 0x4), and always returns 0x0 for all other LPCS
+ * (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x4), and always returns 0x0 for all other LPCS
  * types. Std 802.3 bits that are not applicable to 40GBASE-R (e.g. status bits for PCS lanes
  * 19-4) are not implemented and marked as reserved. PCS lanes 3-0 are valid and are mapped to
- * physical SerDes lanes based on the programming of BGX(0..5)_CMR(0..3)_CONFIG[[LANE_TO_SDS].
+ * physical SerDes lanes based on the programming of BGX()_CMR()_CONFIG[[LANE_TO_SDS].
  */
 union cvmx_bgxx_spux_br_algn_status {
 	uint64_t u64;
@@ -6080,13 +6143,16 @@ union cvmx_bgxx_spux_br_algn_status {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_36_63               : 28;
 	uint64_t marker_lock                  : 4;  /**< Marker-locked status for PCS lanes 3-0.
-                                                         1 = locked, 0 = not locked */
+                                                         0 = Not locked.
+                                                         1 = Locked. */
 	uint64_t reserved_13_31               : 19;
 	uint64_t alignd                       : 1;  /**< All lanes are locked and aligned. This bit returns 1 when the logical PCS has locked and
                                                          aligned all associated receive lanes; returns 0 otherwise. For all other PCS types, this
                                                          bit always returns 0. */
 	uint64_t reserved_4_11                : 8;
-	uint64_t block_lock                   : 4;  /**< Block-lock status for PCS lanes 3-0: 1 = locked, 0 = not locked */
+	uint64_t block_lock                   : 4;  /**< Block-lock status for PCS lanes 3-0:
+                                                         0 = Not locked.
+                                                         1 = Locked. */
 #else
 	uint64_t block_lock                   : 4;
 	uint64_t reserved_4_11                : 8;
@@ -6105,11 +6171,12 @@ typedef union cvmx_bgxx_spux_br_algn_status cvmx_bgxx_spux_br_algn_status_t;
  *
  * This register implements the Std 802.3 BIP error-counter registers for PCS lanes 0-3
  * (3.200-3.203). It is valid only when the LPCS type is 40GBASE-R
- * (BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = 0x4), and always returns 0x0 for all other LPCS
+ * (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x4), and always returns 0x0 for all other LPCS
  * types. The counters are indexed by the RX PCS lane number based on the Alignment Marker
- * detected on each lane and captured in BGX(0..5)_SPU(0..3)_BR_LANE_MAP. Each counter counts the
+ * detected on each lane and captured in BGX()_SPU()_BR_LANE_MAP. Each counter counts the
  * BIP errors for its PCS lane, and is held at all ones in case of overflow. The counters are
  * reset to all 0s when this register is read by software.
+ *
  * The reset operation takes precedence over the increment operation; if the register is read on
  * the same clock cycle as an increment operation, the counter is reset to all 0s and the
  * increment operation is lost. The counters are writable for test purposes, rather than read-
@@ -6138,17 +6205,18 @@ typedef union cvmx_bgxx_spux_br_bip_err_cnt cvmx_bgxx_spux_br_bip_err_cnt_t;
  * cvmx_bgx#_spu#_br_lane_map
  *
  * This register implements the Std 802.3 lane 0-3 mapping registers (3.400-3.403). It is valid
- * only when the LPCS type is 40GBASE-R (BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = 0x4), and always
+ * only when the LPCS type is 40GBASE-R (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x4), and always
  * returns 0x0 for all other LPCS types. The LNx_MAPPING field for each programmed PCS lane
  * (called service interface in 802.3ba-2010) is valid when that lane has achieved alignment
  * marker lock on the receive side (i.e. the associated
- * BGX(0..5)_SPU(0..3)_BR_ALGN_STATUS[MARKER_LOCK] = 1), and is invalid otherwise. When valid, it
+ * BGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK] = 1), and is invalid otherwise. When valid, it
  * returns the actual detected receive PCS lane number based on the received alignment marker
  * contents received on that service interface.
+ *
  * The mapping is flexible because Std 802.3 allows multilane BASE-R receive lanes to be re-
  * ordered. Note that for the transmit side, each PCS lane is mapped to a physical SerDes lane
- * based on the programming of BGX(0..5)_CMR(0..3)_CONFIG[LANE_TO_SDS]. For the receive side,
- * BGX(0..5)_CMR(0..3)_CONFIG[LANE_TO_SDS] specifies the service interface to physical SerDes
+ * based on the programming of BGX()_CMR()_CONFIG[LANE_TO_SDS]. For the receive side,
+ * BGX()_CMR()_CONFIG[LANE_TO_SDS] specifies the service interface to physical SerDes
  * lane mapping, and this register specifies the PCS lane to service interface mapping.
  */
 union cvmx_bgxx_spux_br_lane_map {
@@ -6189,7 +6257,7 @@ union cvmx_bgxx_spux_br_pmd_control {
 	uint64_t train_en                     : 1;  /**< BASE-R training enable */
 	uint64_t train_restart                : 1;  /**< BASE-R training restart. Writing a 1 to this bit restarts the training process if the
                                                          TRAIN_EN bit in this register is also set. This is a self-clearing bit. Software should
-                                                         wait a minimum of 1.7ms after BGX(0..5)_SPU(0..3)_INT[TRAINING_FAILURE] is set before
+                                                         wait a minimum of 1.7ms after BGX()_SPU()_INT[TRAINING_FAILURE] is set before
                                                          restarting the training process. */
 #else
 	uint64_t train_restart                : 1;
@@ -6205,17 +6273,20 @@ typedef union cvmx_bgxx_spux_br_pmd_control cvmx_bgxx_spux_br_pmd_control_t;
  * cvmx_bgx#_spu#_br_pmd_ld_cup
  *
  * This register implements 802.3 MDIO register 1.153 for 10GBASE-R (when
- * BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = 10G_R)
+ * BGX()_CMR()_CONFIG[LMAC_TYPE] = 10G_R)
  * and MDIO registers 1.1300-1.1303 for 40GBASE-R (when
  * LMAC_TYPE = 40G_R). It is automatically cleared at the start of training. When link training
  * is in progress, each field reflects the contents of the coefficient update field in the
  * associated lane's outgoing training frame. The fields in this register are read/write even
  * though they are specified as read-only in 802.3.
- * If BGX(0..5)_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register must be updated
+ *
+ * If BGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register must be updated
  * by software during link training and hardware updates are disabled. If
- * BGX(0..5)_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear, this register is automatically
+ * BGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear, this register is automatically
  * updated by hardware, and it should not be written by software. The lane fields in this
- * register are indexed by logical PCS lane ID. The lane 0 field (LN0_*) is valid for both
+ * register are indexed by logical PCS lane ID.
+ *
+ * The lane 0 field (LN0_*) is valid for both
  * 10GBASE-R and 40GBASE-R. The remaining fields (LN1_*, LN2_*, LN3_*) are only valid for
  * 40GBASE-R.
  */
@@ -6245,15 +6316,17 @@ typedef union cvmx_bgxx_spux_br_pmd_ld_cup cvmx_bgxx_spux_br_pmd_ld_cup_t;
  * cvmx_bgx#_spu#_br_pmd_ld_rep
  *
  * This register implements 802.3 MDIO register 1.154 for 10GBASE-R (when
- * BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = IOG_R) and MDIO registers 1.1400-1.1403 for 40GBASE-R
+ * BGX()_CMR()_CONFIG[LMAC_TYPE] = IOG_R) and MDIO registers 1.1400-1.1403 for 40GBASE-R
  * (when LMAC_TYPE = 40G_R). It is automatically cleared at the start of training. Each field
  * reflects the contents of the status report field in the associated lane's outgoing training
  * frame. The fields in this register are read/write even though they are specified as read-only
- * in 802.3. If BGX(0..5)_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register must
+ * in 802.3. If BGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register must
  * be updated by software during link training and hardware updates are disabled. If
- * BGX(0..5)_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear, this register is automatically
+ * BGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear, this register is automatically
  * updated by hardware, and it should not be written by software. The lane fields in this
- * register are indexed by logical PCS lane ID. The lane 0 field (LN0_*) is valid for both
+ * register are indexed by logical PCS lane ID.
+ *
+ * The lane 0 field (LN0_*) is valid for both
  * 10GBASE-R and 40GBASE-R. The remaining fields (LN1_*, LN2_*, LN3_*) are only valid for
  * 40GBASE-R.
  */
@@ -6283,12 +6356,13 @@ typedef union cvmx_bgxx_spux_br_pmd_ld_rep cvmx_bgxx_spux_br_pmd_ld_rep_t;
  * cvmx_bgx#_spu#_br_pmd_lp_cup
  *
  * This register implements 802.3 MDIO register 1.152 for 10GBASE-R (when
- * BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = 10G_R)
+ * BGX()_CMR()_CONFIG[LMAC_TYPE] = 10G_R)
  * and MDIO registers 1.1100-1.1103 for 40GBASE-R (when
  * LMAC_TYPE = 40G_R). It is automatically cleared at the start of training. Each field reflects
  * the contents of the coefficient update field in the lane's most recently received training
  * frame. This register should not be written when link training is enabled, i.e. when TRAIN_EN
  * is set BR_PMD_CONTROL. The lane fields in this register are indexed by logical PCS lane ID.
+ *
  * The lane 0 field (LN0_*) is valid for both 10GBASE-R and 40GBASE-R. The remaining fields
  * (LN1_*, LN2_*, LN3_*) are only valid for 40GBASE-R.
  */
@@ -6318,11 +6392,13 @@ typedef union cvmx_bgxx_spux_br_pmd_lp_cup cvmx_bgxx_spux_br_pmd_lp_cup_t;
  * cvmx_bgx#_spu#_br_pmd_lp_rep
  *
  * This register implements 802.3 MDIO register 1.153 for 10GBASE-R (when
- * BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = 10G_R)
+ * BGX()_CMR()_CONFIG[LMAC_TYPE] = 10G_R)
  * and MDIO registers 1.1200-1.1203 for 40GBASE-R (when
  * LMAC_TYPE = 40G_R). It is automatically cleared at the start of training. Each field reflects
  * the contents of the status report field in the associated lane's most recently received
- * training frame. The lane fields in this register are indexed by logical PCS lane ID. The lane
+ * training frame. The lane fields in this register are indexed by logical PCS lane ID.
+ *
+ * The lane
  * 0 field (LN0_*) is valid for both 10GBASE-R and 40GBASE-R. The remaining fields (LN1_*, LN2_*,
  * LN3_*) are only valid for 40GBASE-R.
  */
@@ -6388,26 +6464,26 @@ union cvmx_bgxx_spux_br_status1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_13_63               : 51;
 	uint64_t rcv_lnk                      : 1;  /**< BASE-R receive link status.
-                                                         1 = BASE-R PCS receive-link up
                                                          0 = BASE-R PCS receive-link down.
+                                                         1 = BASE-R PCS receive-link up
                                                          This bit is a reflection of the PCS_status variable defined in Std 802.3 sections
                                                          49.2.14.1 and 82.3.1. */
 	uint64_t reserved_4_11                : 8;
 	uint64_t prbs9                        : 1;  /**< 10GBASE-R PRBS9 pattern testing ability. Always 0; PRBS9 pattern testing is not supported. */
 	uint64_t prbs31                       : 1;  /**< 10GBASE-R PRBS31 pattern testing ability. Always 0; PRBS31 pattern testing is not supported. */
 	uint64_t hi_ber                       : 1;  /**< BASE-R PCS high bit-error rate.
-                                                         1 = 64B/66B receiver is detecting a bit-error rate of >= 10.4
-                                                         0 = 64B/66B receiver is detecting a bit-error rate of < 10.4
+                                                         0 = 64B/66B receiver is detecting a bit-error rate of < 10.4.
+                                                         1 = 64B/66B receiver is detecting a bit-error rate of >= 10.4.
                                                          This bit is a direct reflection of the state of the HI_BER variable in the 64B/66B state
                                                          diagram and is defined in Std 802.3 sections 49.2.13.2.2 and 82.2.18.2.2. */
 	uint64_t blk_lock                     : 1;  /**< BASE-R PCS block lock.
-                                                         1 = 64B/66B receiver for BASE-R has block lock
-                                                         0 = No block lock
+                                                         0 = No block lock.
+                                                         1 = 64B/66B receiver for BASE-R has block lock.
                                                          This bit is a direct reflection of the state of the BLOCK_LOCK variable in the 64B/66B
                                                          state diagram and is defined in Std 802.3 sections 49.2.13.2.2 and 82.2.18.2.2.
                                                          For a multilane logical PCS (i.e. 40GBASE-R), this bit indicates that the receiver has
                                                          both block lock and alignment for all lanes and is identical to
-                                                         BGX(0..5)_SPU(0..3)_BR_ALGN_STATUS[ALIGND]. */
+                                                         BGX()_SPU()_BR_ALGN_STATUS[ALIGND]. */
 #else
 	uint64_t blk_lock                     : 1;
 	uint64_t hi_ber                       : 1;
@@ -6426,9 +6502,10 @@ typedef union cvmx_bgxx_spux_br_status1 cvmx_bgxx_spux_br_status1_t;
  * cvmx_bgx#_spu#_br_status2
  *
  * This register implements a combination of the following Std 802.3 registers:
- * * BASE-R PCS status 2 (MDIO address 3.33)
- * * BASE-R BER high-order counter (MDIO address 3.44)
- * Errored-blocks high-order counter (MDIO address 3.45).
+ * * BASE-R PCS status 2 (MDIO address 3.33).
+ * * BASE-R BER high-order counter (MDIO address 3.44).
+ * * Errored-blocks high-order counter (MDIO address 3.45).
+ *
  * Note that the relative locations of some fields have been moved from Std 802.3 in order to
  * make the register layout more software friendly: the BER counter high-order and low-order bits
  * from sections 3.44 and 3.33 have been combined into the contiguous, 22-bit BER_CNT field;
@@ -6460,16 +6537,16 @@ union cvmx_bgxx_spux_br_status2 {
                                                          increment operation is lost.
                                                          This field is writable for test purposes, rather than read-only as specified in Std 802.3. */
 	uint64_t latched_lock                 : 1;  /**< Latched-block lock.
-                                                         1 = 64B/66B receiver for BASE-R has block lock
-                                                         0 = No block
-                                                         This is a latching-low version of BGX(0..5)_SPU(0..3)_STATUS1[BLK_LOCK]; it stays clear
+                                                         0 = No block.
+                                                         1 = 64B/66B receiver for BASE-R has block lock.
+                                                         This is a latching-low version of BGX()_SPU()_BR_STATUS1[BLK_LOCK]; it stays clear
                                                          until the register is read by software.
                                                          Note that in order to avoid read side effects, this is implemented as a write-1-to-set
                                                          bit, rather than latching low read-only as specified in 802.3. */
 	uint64_t latched_ber                  : 1;  /**< Latched-high bit-error rate.
-                                                         1 = 64B/66B receiver is detecting a high BER
-                                                         0 = Not a high BER
-                                                         This is a latching-high version of BGX(0..5)_SPU(0..3)_STATUS1[HI_BER]; it stays set until
+                                                         0 = Not a high BER.
+                                                         1 = 64B/66B receiver is detecting a high BER.
+                                                         This is a latching-high version of BGX()_SPU()_BR_STATUS1[HI_BER]; it stays set until
                                                          the register is read by software.
                                                          Note that in order to avoid read side effects, this is implemented as a write-1-to-clear
                                                          bit, rather than latching high read-only as specified in 802.3. */
@@ -6501,7 +6578,8 @@ union cvmx_bgxx_spux_br_tp_control {
 	uint64_t reserved_8_63                : 56;
 	uint64_t scramble_tp                  : 1;  /**< Select scrambled idle test pattern. This bit selects the transmit test pattern used when
                                                          TX_TP_EN is set:
-                                                         1 = scrambled idle test pattern, 0 = square wave test pattern. */
+                                                         0 = Square wave test pattern.
+                                                         1 = Scrambled idle test pattern. */
 	uint64_t prbs9_tx                     : 1;  /**< 10GBASE-R PRBS9 TP transmit enable. Always 0; PRBS9 pattern testing is not supported. */
 	uint64_t prbs31_rx                    : 1;  /**< 10GBASE-R PRBS31 TP receive enable. Always 0; PRBS31 pattern testing is not supported. */
 	uint64_t prbs31_tx                    : 1;  /**< 10GBASE-R PRBS31 TP transmit enable. Always 0; PRBS31 pattern is not supported. */
@@ -6565,12 +6643,13 @@ union cvmx_bgxx_spux_bx_status {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_13_63               : 51;
 	uint64_t alignd                       : 1;  /**< 10GBASE-X lane-alignment status.
-                                                         1 = receive lanes aligned, 0 = receive lanes not aligned */
+                                                         0 = receive lanes not aligned.
+                                                         1 = receive lanes aligned. */
 	uint64_t pattst                       : 1;  /**< Pattern-testing ability. Always 0; 10GBASE-X pattern is testing not supported. */
 	uint64_t reserved_4_10                : 7;
 	uint64_t lsync                        : 4;  /**< Lane synchronization. BASE-X lane synchronization status for PCS lanes 3-0. Each bit is
                                                          set when the associated lane is code-group synchronized, and clear otherwise. If the PCS
-                                                         type is RXAUI (i.e. the associated BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = RXAUI), then
+                                                         type is RXAUI (i.e. the associated BGX()_CMR()_CONFIG[LMAC_TYPE] = RXAUI), then
                                                          only lanes 1-0 are valid. */
 #else
 	uint64_t lsync                        : 4;
@@ -6592,7 +6671,7 @@ union cvmx_bgxx_spux_control1 {
 	struct cvmx_bgxx_spux_control1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t reset                        : 1;  /**< Reset. Setting this bit or BGX(0..5)_SPU(0..3)_AN_CONTROL[AN_RESET] to 1 causes the
+	uint64_t reset                        : 1;  /**< Reset. Setting this bit or BGX()_SPU()_AN_CONTROL[AN_RESET] to 1 causes the
                                                          following to happen:
                                                          * Resets the logical PCS (LPCS)
                                                          * Sets the Std 802.3 PCS, FEC and AN registers for the LPCS to their default states
@@ -6604,25 +6683,25 @@ union cvmx_bgxx_spux_control1 {
 	uint64_t spdsel1                      : 1;  /**< Speed select 1: always 1. */
 	uint64_t reserved_12_12               : 1;
 	uint64_t lo_pwr                       : 1;  /**< Low power enable. When set, the LPCS is disabled (overriding the associated
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[ENABLE]), and the SerDes lanes associated with the LPCS are
+                                                         BGX()_CMR()_CONFIG[ENABLE]), and the SerDes lanes associated with the LPCS are
                                                          reset. */
 	uint64_t reserved_7_10                : 4;
 	uint64_t spdsel0                      : 1;  /**< Speed select 0: always 1. */
-	uint64_t spd                          : 4;  /**< "Speed selection.
+	uint64_t spd                          : 4;  /**< '"Speed selection.
                                                          Note that this is a read-only field rather than read/write as
                                                          specified in 802.3.
-                                                         The LPCS speed is actually configured by the associated
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE]. The read values returned by this field are as
+                                                         The LPCS speed is instead configured by the associated
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                          follows:
-                                                           ----------+---------------------------------------------------
-                                                           LMAC_TYPE |   Speed       SPD Read Value      Comment
-                                                           ----------+---------------------------------------------------
-                                                           XAUI      |   10G/20G     0x0                 20G if DXAUI
-                                                           RXAUI     |   10G         0x0
-                                                           10G_R     |   10G         0x0
-                                                           40G_R     |   40G         0x3
-                                                           Other     |   -           X
-                                                           ----------+---------------------------------------------------" */
+                                                         <pre>
+                                                           LMAC_TYPE   Speed       SPD Read Value    Comment
+                                                           ------------------------------------------------------
+                                                           XAUI        10G/20G     0x0               20G if DXAUI
+                                                           RXAUI       10G         0x0
+                                                           10G_R       10G         0x0
+                                                           40G_R       40G         0x3
+                                                           Other       -           X
+                                                         </pre>' */
 	uint64_t reserved_0_1                 : 2;
 #else
 	uint64_t reserved_0_1                 : 2;
@@ -6649,22 +6728,22 @@ union cvmx_bgxx_spux_control2 {
 	struct cvmx_bgxx_spux_control2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
-	uint64_t pcs_type                     : 3;  /**< "PCS type selection.
+	uint64_t pcs_type                     : 3;  /**< PCS type selection.
                                                          Note that this is a read-only field rather than read/write as
                                                          specified in 802.3.
-                                                         The LPCS speed is actually configured by the associated
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE]. The read values returned by this field are as
+                                                         The LPCS speed is instead configured by the associated
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE]. The read values returned by this field are as
                                                          follows:
-                                                           ----------+------------------------------------------
-                                                           LMAC_TYPE |   PCS_TYPE          Comment
-                                                                         Read Value
-                                                           ----------+------------------------------------------
-                                                           XAUI      |   0x1               10GBASE-X PCS type
-                                                           RXAUI     |   0x1               10GBASE-X PCS type
-                                                           10G_R     |   0x0               10GBASE-R PCS type
-                                                           40G_R     |   0x4               40GBASE-R PCS type
-                                                           Other     |   Undefined         Reserved
-                                                           ----------+------------------------------------------" */
+                                                         <pre>
+                                                                       PCS_TYPE
+                                                           LMAC_TYPE   Read Value      Comment
+                                                           -------------------------------------------------
+                                                           XAUI        0x1             10GBASE-X PCS type
+                                                           RXAUI       0x1             10GBASE-X PCS type
+                                                           10G_R       0x0             10GBASE-R PCS type
+                                                           40G_R       0x4             40GBASE-R PCS type
+                                                           Other       Undefined       Reserved
+                                                         </pre> */
 #else
 	uint64_t pcs_type                     : 3;
 	uint64_t reserved_3_63                : 61;
@@ -6682,10 +6761,10 @@ union cvmx_bgxx_spux_fec_abil {
 	struct cvmx_bgxx_spux_fec_abil_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t err_abil                     : 1;  /**< BASE-R FEC error-indication ability. Always 1 when the LPCS type is BASE-R, i.e.
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = 0x3 or 0x4. Always 0 otherwise. */
-	uint64_t fec_abil                     : 1;  /**< BASE-R FEC ability. Always 1 when the LPCS type is BASE-R, i.e.
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = 0x3 or 0x4. Always 0 otherwise. */
+	uint64_t err_abil                     : 1;  /**< BASE-R FEC error-indication ability. Always 1 when the LPCS type is BASE-R,
+                                                         i.e. BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x3 or 0x4. Always 0 otherwise. */
+	uint64_t fec_abil                     : 1;  /**< BASE-R FEC ability. Always 1 when the LPCS type is BASE-R,
+                                                         i.e. BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x3 or 0x4. Always 0 otherwise. */
 #else
 	uint64_t fec_abil                     : 1;
 	uint64_t err_abil                     : 1;
@@ -6711,7 +6790,7 @@ union cvmx_bgxx_spux_fec_control {
                                                          for some of the 32 64B/66B blocks belonging to the uncorrectable FEC block. See
                                                          802.3-2008/802.3ba-2010 section 74.7.4.5.1 for more details. */
 	uint64_t fec_en                       : 1;  /**< BASE-R FEC enable. When this bit is set and the LPCS type is BASE-R
-                                                         (BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = 0x4), forward error correction is enabled. FEC is
+                                                         (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x4), forward error correction is enabled. FEC is
                                                          disabled otherwise. Forward error correction is defined in IEEE Std
                                                          802.3-2008/802.3ba-2010 Clause 74. */
 #else
@@ -6728,11 +6807,12 @@ typedef union cvmx_bgxx_spux_fec_control cvmx_bgxx_spux_fec_control_t;
  * cvmx_bgx#_spu#_fec_corr_blks01
  *
  * This register is valid only when the LPCS type is BASE-R
- * (BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = 0x3 or 0x4). The FEC corrected-block counters are
+ * (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x3 or 0x4). The FEC corrected-block counters are
  * defined in Std 802.3 section 74.8.4.1. Each corrected-blocks counter increments by 1 for a
  * corrected FEC block, i.e. an FEC block that has been received with invalid parity on the
  * associated PCS lane and has been corrected by the FEC decoder. The counter is reset to all 0s
  * when the register is read, and held at all 1s in case of overflow.
+ *
  * The reset operation takes precedence over the increment operation; if the register is read on
  * the same clock cycle as an increment operation, the counter is reset to all 0s and the
  * increment operation is lost. The counters are writable for test purposes, rather than read-
@@ -6764,11 +6844,12 @@ typedef union cvmx_bgxx_spux_fec_corr_blks01 cvmx_bgxx_spux_fec_corr_blks01_t;
  * cvmx_bgx#_spu#_fec_corr_blks23
  *
  * This register is valid only when the LPCS type is 40GBASE-R
- * (BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = 0x4). The FEC corrected-block counters are defined in
+ * (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x4). The FEC corrected-block counters are defined in
  * Std 802.3 section 74.8.4.1. Each corrected-blocks counter increments by 1 for a corrected FEC
  * block, i.e. an FEC block that has been received with invalid parity on the associated PCS lane
  * and has been corrected by the FEC decoder. The counter is reset to all 0s when the register is
  * read, and held at all 1s in case of overflow.
+ *
  * The reset operation takes precedence over the increment operation; if the register is read on
  * the same clock cycle as an increment operation, the counter is reset to all 0s and the
  * increment operation is lost. The counters are writable for test purposes, rather than read-
@@ -6795,11 +6876,12 @@ typedef union cvmx_bgxx_spux_fec_corr_blks23 cvmx_bgxx_spux_fec_corr_blks23_t;
  * cvmx_bgx#_spu#_fec_uncorr_blks01
  *
  * This register is valid only when the LPCS type is BASE-R
- * (BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = 0x3 or 0x4). The FEC corrected-block counters are
+ * (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x3 or 0x4). The FEC corrected-block counters are
  * defined in Std 802.3 section 74.8.4.2. Each uncorrected-blocks counter increments by 1 for an
  * uncorrected FEC block, i.e. an FEC block that has been received with invalid parity on the
  * associated PCS lane and has not been corrected by the FEC decoder. The counter is reset to all
  * 0s when the register is read, and held at all 1s in case of overflow.
+ *
  * The reset operation takes precedence over the increment operation; if the register is read on
  * the same clock cycle as an increment operation, the counter is reset to all 0s and the
  * increment operation is lost. The counters are writable for test purposes, rather than read-
@@ -6831,11 +6913,12 @@ typedef union cvmx_bgxx_spux_fec_uncorr_blks01 cvmx_bgxx_spux_fec_uncorr_blks01_
  * cvmx_bgx#_spu#_fec_uncorr_blks23
  *
  * This register is valid only when the LPCS type is 40GBASE-R
- * (BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = 0x4). The FEC uncorrected-block counters are defined
+ * (BGX()_CMR()_CONFIG[LMAC_TYPE] = 0x4). The FEC uncorrected-block counters are defined
  * in Std 802.3 section 74.8.4.2. Each corrected-blocks counter increments by 1 for an
  * uncorrected FEC block, i.e. an FEC block that has been received with invalid parity on the
  * associated PCS lane and has not been corrected by the FEC decoder. The counter is reset to all
  * 0s when the register is read, and held at all 1s in case of overflow.
+ *
  * The reset operation takes precedence over the increment operation; if the register is read on
  * the same clock cycle as an increment operation, the counter is reset to all 0s and the
  * increment operation is lost. The counters are writable for test purposes, rather than read-
@@ -6868,32 +6951,32 @@ union cvmx_bgxx_spux_int {
 	uint64_t reserved_15_63               : 49;
 	uint64_t training_failure             : 1;  /**< BASE-R PMD training failure. Set when BASE-R PMD link training has failed on the 10GBASE-R
                                                          lane or any 40GBASE-R lane. Valid if the LPCS type selected by
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] is 10GBASE-R or 40GBASE-R and
-                                                         BGX(0..5)_SPU(0..3)_BR_PMD_CONTROL[TRAIN_EN] is 1, and never set otherwise. */
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE] is 10GBASE-R or 40GBASE-R and
+                                                         BGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is 1, and never set otherwise. */
 	uint64_t training_done                : 1;  /**< BASE-R PMD training done. Set when the 10GBASE-R lane or all 40GBASE-R lanes have
                                                          successfully completed BASE-R PMD link training. Valid if the LPCS type selected by
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] is 10GBASE-R or 40GBASE-R and
-                                                         BGX(0..5)_SPU(0..3)_BR_PMD_CONTROL[TRAIN_EN] is 1, and never set otherwise. */
-	uint64_t an_complete                  : 1;  /**< Auto-Negotiation complete. Set when BGX(0..5)_SPU(0..3)_AN_STATUS[AN_COMPLETE] is set,
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE] is 10GBASE-R or 40GBASE-R and
+                                                         BGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is 1, and never set otherwise. */
+	uint64_t an_complete                  : 1;  /**< Auto-Negotiation complete. Set when BGX()_SPU()_AN_STATUS[AN_COMPLETE] is set,
                                                          indicating that the Auto-Negotiation process has been completed and the link is up and
                                                          running using the negotiated highest common denominator (HCD) technology. */
 	uint64_t an_link_good                 : 1;  /**< Auto-Negotiation link good. Set when the an_link_good variable is set as defined in
                                                          802.3-2008 Figure 73-11, indicating that Auto-Negotiation has completed. */
 	uint64_t an_page_rx                   : 1;  /**< Auto-Negotiation page received. This bit is set along with
-                                                         BGX(0..5)_SPU(0..3)_AN_STATUS[PAGE_RX] when a new page has been received and stored in
-                                                         BGX(0..5)_SPU(0..3)_AN_LP_BASE or BGX(0..5)_SPU(0..3)_AN_LP_XNP. */
+                                                         BGX()_SPU()_AN_STATUS[PAGE_RX] when a new page has been received and stored in
+                                                         BGX()_SPU()_AN_LP_BASE or BGX()_SPU()_AN_LP_XNP. */
 	uint64_t fec_uncorr                   : 1;  /**< Uncorrectable FEC error. Set when an FEC block with an uncorrectable error is received on
                                                          the 10GBASE-R lane or any 40GBASE-R lane. Valid if the LPCS type selected by
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] is 10GBASE-R or 40GBASE-R, and never set otherwise. */
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE] is 10GBASE-R or 40GBASE-R, and never set otherwise. */
 	uint64_t fec_corr                     : 1;  /**< Correctable FEC error. Set when an FEC block with a correctable error is received on the
                                                          10GBASE-R lane or any 40GBASE-R lane. Valid if the LPCS type selected by
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] is 10GBASE-R or 40GBASE-R, and never set otherwise. */
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE] is 10GBASE-R or 40GBASE-R, and never set otherwise. */
 	uint64_t bip_err                      : 1;  /**< 40GBASE-R bit interleaved parity error. Set when a BIP error is detected on any lane.
-                                                         Valid if the LPCS type selected by BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] is 40GBASE-R, and
+                                                         Valid if the LPCS type selected by BGX()_CMR()_CONFIG[LMAC_TYPE] is 40GBASE-R, and
                                                          never set otherwise. */
 	uint64_t dbg_sync                     : 1;  /**< Sync failure debug. This interrupt is provided for link problem debugging help. It is set
-                                                         as follows based on the LPCS type selected by BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE], and
-                                                         whether FEC is enabled or disabled by BGX(0..5)_SPU(0..3)_FEC_CONTROL[FEC_EN]:
+                                                         as follows based on the LPCS type selected by BGX()_CMR()_CONFIG[LMAC_TYPE], and
+                                                         whether FEC is enabled or disabled by BGX()_SPU()_FEC_CONTROL[FEC_EN]:
                                                          * XAUI or RXAUI: Set when any lane's PCS synchronization state transitions from
                                                          SYNC_ACQUIRED_1 to SYNC_ACQUIRED_2 (see 802.3-2008 Figure 48-7).
                                                          * 10GBASE-R or 40GBASE-R with FEC disabled: Set when sh_invalid_cnt increments to 1 while
@@ -6902,11 +6985,11 @@ union cvmx_bgxx_spux_int {
                                                          while fec_block_lock is 1 (see 802.3-2008 Figure 74-8). */
 	uint64_t algnlos                      : 1;  /**< Loss of lane alignment. Set when lane-to-lane alignment is lost. This is only valid if the
                                                          logical PCS is a multilane type (i.e. XAUI, RXAUI or 40GBASE-R is selected by
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE]), and is never set otherwise. */
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE]), and is never set otherwise. */
 	uint64_t synlos                       : 1;  /**< Loss of lane sync. Lane code-group or block synchronization is lost on one or more lanes
                                                          associated with the LMAC/LPCS. Set as follows based on the LPCS type selected by
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE], and whether FEC is enabled or disabled by
-                                                         BGX(0..5)_SPU(0..3)_FEC_CONTROL[FEC_EN]:
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE], and whether FEC is enabled or disabled by
+                                                         BGX()_SPU()_FEC_CONTROL[FEC_EN]:
                                                          * XAUI or RXAUI: Set when any lane's PCS synchronization state transitions to LOSS_OF_SYNC
                                                          (see 802.3-2008 Figure 48-7)
                                                          * 10GBASE-R or 40GBASE-R with FEC disabled: set when the block_lock variable is cleared on
@@ -6915,12 +6998,12 @@ union cvmx_bgxx_spux_int {
                                                          on the 10G lane or any 40G lane (see 802.3-2008 Figure 74-8). */
 	uint64_t bitlckls                     : 1;  /**< Bit lock lost on one or more lanes associated with the LMAC/LPCS. */
 	uint64_t err_blk                      : 1;  /**< Errored block received. Set when an errored BASE-R block is received as described for
-                                                         BGX(0..5)_SPU(0..3)_BR_STATUS2[ERR_BLKS]. Valid if the LPCS type selected by
-                                                         BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] is 10GBASE-R or 40GBASE-R, and never set otherwise. */
+                                                         BGX()_SPU()_BR_STATUS2[ERR_BLKS]. Valid if the LPCS type selected by
+                                                         BGX()_CMR()_CONFIG[LMAC_TYPE] is 10GBASE-R or 40GBASE-R, and never set otherwise. */
 	uint64_t rx_link_down                 : 1;  /**< Set when the receive link goes down, which is the same condition that sets
-                                                         BGX(0..5)_SPU(0..3)_STATUS2[RCVFLT]. */
+                                                         BGX()_SPU()_STATUS2[RCVFLT]. */
 	uint64_t rx_link_up                   : 1;  /**< Set when the receive link comes up, which is the same condition that allows the setting of
-                                                         BGX(0..5)_SPU(0..3)_STATUS1[RCV_LNK]. */
+                                                         BGX()_SPU()_STATUS1[RCV_LNK]. */
 #else
 	uint64_t rx_link_up                   : 1;
 	uint64_t rx_link_down                 : 1;
@@ -6977,6 +7060,7 @@ typedef union cvmx_bgxx_spux_lpcs_states cvmx_bgxx_spux_lpcs_states_t;
  *
  * "* RX logical PCS lane polarity vector [3:0] = XOR_RXPLRT[3:0] ^ [4[RXPLRT]].
  *  * TX logical PCS lane polarity vector [3:0] = XOR_TXPLRT[3:0] ^ [4[TXPLRT]].
+ *
  *  In short, keep RXPLRT and TXPLRT cleared, and use XOR_RXPLRT and XOR_TXPLRT fields to define
  *  the polarity per logical PCS lane. Only bit 0 of vector is used for 10GBASE-R, and only bits
  * - 1:0 of vector are used for RXAUI."
@@ -6991,19 +7075,19 @@ union cvmx_bgxx_spux_misc_control {
                                                          being received, the packet is completed and all subsequent received packets are discarded
                                                          by the LPCS. Similarly, if this bit is cleared while a received packet is being discarded,
                                                          packet reception resumes after the current packet is fully discarded. When set for a
-                                                         40GBASE-R or 10GBASE-R LMAC/LPCS type (selected by BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE]),
+                                                         40GBASE-R or 10GBASE-R LMAC/LPCS type (selected by BGX()_CMR()_CONFIG[LMAC_TYPE]),
                                                          received errors and faults will be ignored while receive packets are discarded; idles will
                                                          be sent to the MAC layer (SMU) and the errored blocks counter
-                                                         (BGX(0..5)_SPU(0..3)_BR_STATUS2[ERR_BLKS]) will not increment. */
+                                                         (BGX()_SPU()_BR_STATUS2[ERR_BLKS]) will not increment. */
 	uint64_t skip_after_term              : 1;  /**< Enable sending of Idle Skip after Terminate. This bit is meaningful when the logical PCS
-                                                         type is XAUI or RXAUI (selected by BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE]), and has no
+                                                         type is XAUI or RXAUI (selected by BGX()_CMR()_CONFIG[LMAC_TYPE]), and has no
                                                          effect otherwise. When set, the LMAC/LPCS transmits more Idle Skip columns for clock
                                                          compensation. Typically set in HiGig/HiGig2 modes; clear otherwise. This field can be set
                                                          to ensure sufficient density of XAUI Idle Skip (||R||) columns with a small transmit
                                                          inter-frame gap (IFG) in order to allow the link partner's receiver to delete ||R
                                                          columns as needed for clock rate compensation. It is usually set when the LMAC's transmit
-                                                         IFG is set to 8 bytes in HiGig/HiGig2 modes (i.e. BGX(0..5)_SMU(0..3)_TX_IFG[IFG1] +
-                                                         BGX(0..5)_SMU(0..3)_TX_IFG[IFG2] = 8), and should be cleared when the transmit IFG is
+                                                         IFG is set to 8 bytes in HiGig/HiGig2 modes (i.e. BGX()_SMU()_TX_IFG[IFG1] +
+                                                         BGX()_SMU()_TX_IFG[IFG2] = 8), and should be cleared when the transmit IFG is
                                                          greater than 8 bytes. When this bit is set, the SPU will send an ||R|| column after a
                                                          ||T0|| column (terminate in lane 0) if no ||R|| was sent in the previous IFG. This is a
                                                          minor deviation from the functionality specified in 802.3-2008 Figure 48-6 (PCS transmit
@@ -7014,13 +7098,14 @@ union cvmx_bgxx_spux_misc_control {
                                                          error due to this functional change. When this bit is clear, the LMAC will fully conform
                                                          to the functionality specified in Figure 48-6. */
 	uint64_t intlv_rdisp                  : 1;  /**< RXAUI interleaved running disparity. This bit is meaningful when the logical PCS type is
-                                                         RXAUI (BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] = RXAUI), and has no effect otherwise. It
+                                                         RXAUI (BGX()_CMR()_CONFIG[LMAC_TYPE] = RXAUI), and has no effect otherwise. It
                                                          selects which disparity calculation to use when combining or splitting the RXAUI lanes, as
                                                          follows:
-                                                         0 = Common running disparity. Common running disparity is computed for even and odd code-
+                                                         _ 0 = Common running disparity. Common running disparity is computed for even and odd
+                                                         code-
                                                          groups of an RXAUI lane, i.e. interleave lanes before PCS layer as described in the Dune
                                                          Networks/Broadcom RXAUI v2.1 specification. This obeys 6.25GHz serdes disparity.
-                                                         1 = Interleaved running disparity: Running disparity is computed separately for even and
+                                                         _ 1 = Interleaved running disparity: Running disparity is computed separately for even and
                                                          odd code-groups of an RXAUI lane, i.e. interleave lanes after PCS layer as described in
                                                          the Marvell RXAUI Interface specification. This does not obey 6.25GHz SerDes disparity. */
 	uint64_t xor_rxplrt                   : 4;  /**< RX polarity control per logical PCS lane */
@@ -7074,16 +7159,18 @@ union cvmx_bgxx_spux_status1 {
 	struct cvmx_bgxx_spux_status1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t flt                          : 1;  /**< Fault: 1 = fault condition detected, 0 = no fault condition detected.
-                                                         This bit is a logical OR of BGX(0..5)_SPU(0..3)_STATUS2[XMTFLT, RCVFLT]. */
+	uint64_t flt                          : 1;  /**< Fault condition detected.
+                                                         This bit is a logical OR of BGX()_SPU()_STATUS2[XMTFLT, RCVFLT]. */
 	uint64_t reserved_3_6                 : 4;
-	uint64_t rcv_lnk                      : 1;  /**< PCS receive link status: 1 = receive link up, 0 = receive link down.
+	uint64_t rcv_lnk                      : 1;  /**< PCS receive link status:
+                                                           0 = receive link down.
+                                                           1 = receive link up.
                                                          This is a latching-low bit; it stays clear until the register is read by software.
-                                                         For a BASE-X logical PCS type (in the associated BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] =
-                                                         XAUI or RXAUI), this is a latching-low version of BGX(0..5)_SPU(0..3)_BX_STATUS[ALIGND].
-                                                         For a BASE-R logical PCS type (in the associated BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE] =
+                                                         For a BASE-X logical PCS type (in the associated BGX()_CMR()_CONFIG[LMAC_TYPE] =
+                                                         XAUI or RXAUI), this is a latching-low version of BGX()_SPU()_BX_STATUS[ALIGND].
+                                                         For a BASE-R logical PCS type (in the associated BGX()_CMR()_CONFIG[LMAC_TYPE] =
                                                          10G_R or 40G_R), this is a latching-low version of
-                                                         BGX(0..5)_SPU(0..3)_BR_STATUS1[RCV_LNK].
+                                                         BGX()_SPU()_BR_STATUS1[RCV_LNK].
                                                          Note that in order to avoid read side effects, this is implemented as a write-1-to-set
                                                          bit, rather than latching low read-only as specified in 802.3. */
 	uint64_t lpable                       : 1;  /**< Low-power ability. Always returns 1 to indicate that the LPCS supports low-power mode. */
@@ -7200,7 +7287,7 @@ union cvmx_bgxx_spu_dbg_control {
                                                          the link partner.
                                                          SPU captures the timestamp of the alignment marker received on each SerDes lane during
                                                          align/skew detection; the captured value can be read from the SerDes lane's
-                                                         BGX(0..5)_SPU_SDS(0..3)_SKEW_STATUS[SKEW_STATUS] field (AM_TIMESTAMP sub-field). If
+                                                         BGX()_SPU_SDS()_SKEW_STATUS[SKEW_STATUS] field (AM_TIMESTAMP sub-field). If
                                                          alignment markers are transmitted at about the same time on all lanes by the link partner,
                                                          then the difference between the AM_TIMESTAMP values for a pair of lanes represents the
                                                          approximate skew between those lanes.
@@ -7210,33 +7297,33 @@ union cvmx_bgxx_spu_dbg_control {
                                                          AM_TIMESTAMP delta from the captured timestamp value. The adjusted/normalized timestamp
                                                          value is then passed to SMU along with the SOP.
                                                          Software can determine the actual maximum skew of a 40GBASE-R link by examining the
-                                                         AM_TIMESTAMP values in the BGX(0..5)_SPU_SDS(0..3)_SKEW_STATUS registers, and decide if
+                                                         AM_TIMESTAMP values in the BGX()_SPU_SDS()_SKEW_STATUS registers, and decide if
                                                          timestamp normalization should be enabled or disabled to improve PTP accuracy.
                                                          Normalization improves accuracy for larger skew values but reduces the accuracy (due to
                                                          timestamp measurement errors) for small skew values. */
 	uint64_t rx_buf_flip_synd             : 8;  /**< Flip SPU RX_BUF FIFO ECC bits. Two bits per SerDes lane; used to inject single-bit and
                                                          double-bit errors into the ECC field on writes to the associated SPU RX_BUF lane FIFO, as
                                                          follows:
-                                                         0x0 = Normal operation
-                                                         0x1 = SBE on ECC bit 0
-                                                         0x2 = SBE on ECC bit 1
-                                                         0x3 = DBE on ECC bits 1:0 */
+                                                         0x0 = Normal operation.
+                                                         0x1 = SBE on ECC bit 0.
+                                                         0x2 = SBE on ECC bit 1.
+                                                         0x3 = DBE on ECC bits 1:0. */
 	uint64_t br_pmd_train_soft_en         : 1;  /**< Enable BASE-R PMD software controlled link training. This bit configures the operation
                                                          mode for BASE-R link training for all LMACs and lanes. When this bit is set along with
-                                                         BGX(0..5)_SPU(0..3)_BR_PMD_CONTROL[TRAIN_EN] for a given LMAC, the BASE-R link training
+                                                         BGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] for a given LMAC, the BASE-R link training
                                                          protocol for that LMAC is executed under software control, whereby the contents the
-                                                         BGX(0..5)_SPU(0..3)_BR_PMD_LD_CUP and BGX(0..5)_SPU(0..3)_BR_PMD_LD_REP registers are
+                                                         BGX()_SPU()_BR_PMD_LD_CUP and BGX()_SPU()_BR_PMD_LD_REP registers are
                                                          updated by software. When this bit is clear and
-                                                         BGX(0..5)_SPU(0..3)_BR_PMD_CONTROL[TRAIN_EN] is set, the link training protocol is fully
-                                                         automated in hardware, whereby the contents BGX(0..5)_SPU(0..3)_BR_PMD_LD_CUP and
-                                                         BGX(0..5)_SPU(0..3)_BR_PMD_LD_REP registers are automatically updated by hardware. */
+                                                         BGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set, the link training protocol is fully
+                                                         automated in hardware, whereby the contents BGX()_SPU()_BR_PMD_LD_CUP and
+                                                         BGX()_SPU()_BR_PMD_LD_REP registers are automatically updated by hardware. */
 	uint64_t an_arb_link_chk_en           : 1;  /**< Enable link status checking by Auto-Negotiation arbitration state machine. When Auto-
-                                                         Negotiation is enabled (BGX(0..5)_SPU(0..3)_AN_CONTROL[AN_EN] is set), this bit controls
+                                                         Negotiation is enabled (BGX()_SPU()_AN_CONTROL[AN_EN] is set), this bit controls
                                                          the behavior of the Auto-Negotiation arbitration state machine when it reaches the AN GOOD
                                                          CHECK state after DME pages are successfully exchanged, as defined in Figure 73-11 in
                                                          802.3-2008.
                                                          When this bit is set and the negotiated highest common denominator (HCD) technology
-                                                         matches BGX(0..5)_CMR(0..3)_CONFIG[LMAC_TYPE], the Auto-Negotiation arbitration SM
+                                                         matches BGX()_CMR()_CONFIG[LMAC_TYPE], the Auto-Negotiation arbitration SM
                                                          performs the actions defined for the AN GOOD CHECK state in Figure 73-11, i.e. run the
                                                          link_fail_inhibit timer and eventually transition to the AN GOOD or TRANSMIT DISABLE
                                                          state.
@@ -7245,13 +7332,13 @@ union cvmx_bgxx_spu_dbg_control {
                                                          appropriate actions to complete the Auto-Negotiation protocol, as follows:
                                                          * If this bit is clear and the HCD technology matches LMAC_TYPE, clear AN_EN in
                                                          AN_CONTROL.
-                                                         * Otherwise, disable the LPCS by clearing the BGX(0..5)_CMR(0..3)_CONFIG[ENABLE], clear
-                                                         BGX(0..5)_SPU(0..3)_AN_CONTROL[AN_EN], reconfigure the LPCS with the correct LMAC_TYPE,
-                                                         and re-enable the LPCS by setting BGX(0..5)_CMR(0..3)_CONFIG[ENABLE].
+                                                         * Otherwise, disable the LPCS by clearing the BGX()_CMR()_CONFIG[ENABLE], clear
+                                                         BGX()_SPU()_AN_CONTROL[AN_EN], reconfigure the LPCS with the correct LMAC_TYPE,
+                                                         and re-enable the LPCS by setting BGX()_CMR()_CONFIG[ENABLE].
                                                          In both cases, software should implement the link_fail_inhibit timer and verify the link
                                                          status as specified for the AN GOOD CHECK state. */
 	uint64_t rx_buf_cor_dis               : 1;  /**< When set, disables ECC correction on all SPU RX_BUF FIFOs. */
-	uint64_t scramble_dis                 : 1;  /**< BASE-R Scrambler/descrambler disable. Setting this bit to 1 disables the BASE-R scrambler
+	uint64_t scramble_dis                 : 1;  /**< BASE-R scrambler/descrambler disable. Setting this bit to 1 disables the BASE-R scrambler
                                                          & descrambler functions and FEC PN-2112 scrambler & descrambler functions for debug
                                                          purposes. */
 	uint64_t reserved_15_15               : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
index e83a2a7..ca48ab7 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu-defs.h
@@ -12962,10 +12962,10 @@ union cvmx_ciu_pp_pokex {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t poke                         : 1;  /**< Core poke. Writing any value to this register does the following:
-                                                         clears any pending interrupt generated by the associated watchdog
-                                                         resets CIU_WDOG(0..47)[STATE] to 0x0
-                                                         sets CIU_WDOG(0..47)[CNT] to ( CIU_WDOG(0..47)[LEN] << 8).
-                                                         Reading this register returns the associated CIU_WDOG(0..47) register. */
+                                                         * clears any pending interrupt generated by the associated watchdog.
+                                                         * resets CIU_WDOG()[STATE] to 0x0.
+                                                         * sets CIU_WDOG()[CNT] to ( CIU_WDOG()[LEN] << 8).
+                                                         Reading this register returns the associated CIU_WDOG() register. */
 #else
 	uint64_t poke                         : 1;
 	uint64_t reserved_1_63                : 63;
diff --git a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
index 73bca84..7f3dec2 100644
--- a/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-ciu3-defs.h
@@ -357,7 +357,7 @@ typedef union cvmx_ciu3_ctl cvmx_ciu3_ctl_t;
  * cvmx_ciu3_dest#_io_int
  *
  * This register contains reduced interrupt source numbers for delivery to software, indexed by
- * I/O bridge number. Fields are identical to CIU3_DEST(0..143)_PP_INT.
+ * I/O bridge number. Fields are identical to CIU3_DEST()_PP_INT.
  */
 union cvmx_ciu3_destx_io_int {
 	uint64_t u64;
@@ -366,11 +366,11 @@ union cvmx_ciu3_destx_io_int {
 	uint64_t reserved_52_63               : 12;
 	uint64_t intsn                        : 20; /**< Interrupt source number causing the current interrupt, or most recent interrupt if INTR is
                                                          clear. Note this field is not stored in the DEST ram itself; it is instead read from
-                                                         CIU3_IDT(0..255)_CTL[INTIDT][INTSN]. */
+                                                         CIU3_IDT()_CTL[INTSN]. */
 	uint64_t reserved_10_31               : 22;
 	uint64_t intidt                       : 8;  /**< IDT entry number causing the current interrupt, or most recent interrupt if INTR is clear. */
 	uint64_t newint                       : 1;  /**< New interrupt to be delivered. Internal state, for diagnostic use only. */
-	uint64_t intr                         : 1;  /**< Interrupt pending. This bit is recalculated when CIU3_ISC(0..1048575)_CTL or interrupts
+	uint64_t intr                         : 1;  /**< Interrupt pending. This bit is recalculated when CIU3_ISC()_CTL or interrupts
                                                          change, so does not need to be cleared by software. */
 #else
 	uint64_t intr                         : 1;
@@ -398,11 +398,11 @@ union cvmx_ciu3_destx_pp_int {
 	uint64_t reserved_52_63               : 12;
 	uint64_t intsn                        : 20; /**< Interrupt source number causing the current interrupt, or most recent interrupt if INTR is
                                                          clear. Note this field is not stored in the DEST ram itself; it is instead read from
-                                                         CIU3_IDT(0..255)_CTL[INTIDT][INTSN]. */
+                                                         CIU3_IDT()_CTL[INTSN]. */
 	uint64_t reserved_10_31               : 22;
 	uint64_t intidt                       : 8;  /**< IDT entry number causing the current interrupt, or most recent interrupt if INTR is clear. */
 	uint64_t newint                       : 1;  /**< New interrupt to be delivered. Internal state, for diagnostic use only. */
-	uint64_t intr                         : 1;  /**< Interrupt pending. This bit is recalculated when CIU3_ISC(0..1048575)_CTL or interrupts
+	uint64_t intr                         : 1;  /**< Interrupt pending. This bit is recalculated when CIU3_ISC()_CTL or interrupts
                                                          change, so does not need to be cleared by software. */
 #else
 	uint64_t intr                         : 1;
@@ -546,12 +546,12 @@ union cvmx_ciu3_intr_ram_ecc_st {
 	uint64_t reserved_52_63               : 12;
 	uint64_t addr                         : 20; /**< Latch the address for latest SBE/DBE that occurred. */
 	uint64_t reserved_6_31                : 26;
-	uint64_t sisc_dbe                     : 1;  /**< SISC Double-bit error observed. Throws CIU_INTSN_E::CIU3_ECC_SISC_DBE. */
-	uint64_t sisc_sbe                     : 1;  /**< SISC Single-bit error observed. Throws CIU_INTSN_E::CIU3_ECC_SISC_SBE. */
-	uint64_t idt_dbe                      : 1;  /**< IDT Double-bit error observed. Throws CIU_INTSN_E::CIU3_ECC_IDT_DBE. */
-	uint64_t idt_sbe                      : 1;  /**< IDT Single-bit error observed. Throws CIU_INTSN_E::CIU3_ECC_IDT_SBE. */
-	uint64_t isc_dbe                      : 1;  /**< ISC Double-bit error observed. Throws CIU_INTSN_E::CIU3_ECC_ISC_DBE. */
-	uint64_t isc_sbe                      : 1;  /**< ISC Single-bit error observed. Throws CIU_INTSN_E::CIU3_ECC_ISC_SBE. */
+	uint64_t sisc_dbe                     : 1;  /**< SISC Double-bit error observed. Throws CIU_INTSN_E::CIU_ECC_SISC_DBE. */
+	uint64_t sisc_sbe                     : 1;  /**< SISC Single-bit error observed. Throws CIU_INTSN_E::CIU_ECC_SISC_SBE. */
+	uint64_t idt_dbe                      : 1;  /**< IDT Double-bit error observed. Throws CIU_INTSN_E::CIU_ECC_IDT_DBE. */
+	uint64_t idt_sbe                      : 1;  /**< IDT Single-bit error observed. Throws CIU_INTSN_E::CIU_ECC_IDT_SBE. */
+	uint64_t isc_dbe                      : 1;  /**< ISC Double-bit error observed. Throws CIU_INTSN_E::CIU_ECC_ISC_DBE. */
+	uint64_t isc_sbe                      : 1;  /**< ISC Single-bit error observed. Throws CIU_INTSN_E::CIU_ECC_ISC_SBE. */
 #else
 	uint64_t isc_sbe                      : 1;
 	uint64_t isc_dbe                      : 1;
@@ -631,7 +631,7 @@ union cvmx_ciu3_iscx_ctl {
 	uint64_t idt                          : 8;  /**< Interrupt Delivery Table entry number. Zero indicates IDT delivery is disabled. This field
                                                          may only be changed when EN was previously clear, though it may be changed with the same
                                                          write that sets EN. Thus if EN is set, to change IDT two register writes are required, the
-                                                         first to clear EN (perhaps by a store to CIU3_ISC(0..1048575)_W1C), and the second to make
+                                                         first to clear EN (perhaps by a store to CIU3_ISC()_W1C), and the second to make
                                                          the change to IDT. */
 	uint64_t imp                          : 1;  /**< Entry implemented. Although the table has 1M entries, most of those do not correspond to
                                                          any INTSN, and as such are not implemented.
@@ -644,7 +644,7 @@ union cvmx_ciu3_iscx_ctl {
 	uint64_t sso                          : 1;  /**< Reserved. INTERNAL: Deprecated. Use SSO delivery. */
 	uint64_t en                           : 1;  /**< Enable interrupt delivery. */
 	uint64_t raw                          : 1;  /**< Interrupt pending before masking. Note read only, must use
-                                                         CIU3_ISC(0..1048575)_W1C/CIU3_ISC(0..1048575)_W1S to toggle. */
+                                                         CIU3_ISC()_W1C/CIU3_ISC()_W1S to toggle. */
 #else
 	uint64_t raw                          : 1;
 	uint64_t en                           : 1;
@@ -669,8 +669,8 @@ union cvmx_ciu3_iscx_w1c {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
 	uint64_t sso                          : 1;  /**< Reserved. INTERNAL: Deprecated. Use SSO work-queue-entry delivery. */
-	uint64_t en                           : 1;  /**< Clear enable interrupt delivery. See CIU3_ISC(0..1048575)_CTL[EN]. */
-	uint64_t raw                          : 1;  /**< Clear interrupt pending. See CIU3_ISC(0..1048575)_CTL[RAW]. */
+	uint64_t en                           : 1;  /**< Clear enable interrupt delivery. See CIU3_ISC()_CTL[EN]. */
+	uint64_t raw                          : 1;  /**< Clear interrupt pending. See CIU3_ISC()_CTL[RAW]. */
 #else
 	uint64_t raw                          : 1;
 	uint64_t en                           : 1;
@@ -691,8 +691,8 @@ union cvmx_ciu3_iscx_w1s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_3_63                : 61;
 	uint64_t sso                          : 1;  /**< Reserved. INTERNAL: Deprecated. Use SSO work-queue-entry delivery. */
-	uint64_t en                           : 1;  /**< Set enable interrupt delivery. See CIU3_ISC(0..1048575)_CTL[EN]. */
-	uint64_t raw                          : 1;  /**< Set interrupt pending. See CIU3_ISC(0..1048575)_CTL[RAW]. */
+	uint64_t en                           : 1;  /**< Set enable interrupt delivery. See CIU3_ISC()_CTL[EN]. */
+	uint64_t raw                          : 1;  /**< Set interrupt pending. See CIU3_ISC()_CTL[RAW]. */
 #else
 	uint64_t raw                          : 1;
 	uint64_t en                           : 1;
@@ -772,8 +772,8 @@ union cvmx_ciu3_timx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_37_63               : 27;
 	uint64_t one_shot                     : 1;  /**< One-shot mode when LEN != 0x0:
-                                                         0 = timer is in periodic mode.
-                                                         1 = timer is in one-shot mode. */
+                                                         0 = Timer is in periodic mode.
+                                                         1 = Timer is in one-shot mode. */
 	uint64_t len                          : 36; /**< Time-out length in coprocessor clock cycles. The timer disabled when LEN = 0x0. Periodic
                                                          interrupts will occur every LEN+1 coprocessor clock cycles when ONE_SHOT = 0 */
 #else
diff --git a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
index 482c867..fa33c6b 100644
--- a/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-dtx-defs.h
@@ -2839,7 +2839,7 @@ union cvmx_dtx_agl_bcst_rsp {
 	struct cvmx_dtx_agl_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -2861,7 +2861,8 @@ union cvmx_dtx_agl_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -2943,7 +2944,7 @@ union cvmx_dtx_ase_bcst_rsp {
 	struct cvmx_dtx_ase_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -2964,7 +2965,8 @@ union cvmx_dtx_ase_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -3042,7 +3044,7 @@ union cvmx_dtx_bgxx_bcst_rsp {
 	struct cvmx_dtx_bgxx_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -3063,7 +3065,8 @@ union cvmx_dtx_bgxx_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -3144,7 +3147,8 @@ union cvmx_dtx_broadcast_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -3209,7 +3213,7 @@ union cvmx_dtx_ciu_bcst_rsp {
 	struct cvmx_dtx_ciu_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -3230,7 +3234,8 @@ union cvmx_dtx_ciu_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -3308,7 +3313,7 @@ union cvmx_dtx_dfa_bcst_rsp {
 	struct cvmx_dtx_dfa_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -3331,7 +3336,8 @@ union cvmx_dtx_dfa_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -3417,7 +3423,7 @@ union cvmx_dtx_dpi_bcst_rsp {
 	struct cvmx_dtx_dpi_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -3440,7 +3446,8 @@ union cvmx_dtx_dpi_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -3526,7 +3533,7 @@ union cvmx_dtx_fpa_bcst_rsp {
 	struct cvmx_dtx_fpa_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -3549,7 +3556,8 @@ union cvmx_dtx_fpa_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -3635,7 +3643,7 @@ union cvmx_dtx_gmxx_bcst_rsp {
 	struct cvmx_dtx_gmxx_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -3657,7 +3665,8 @@ union cvmx_dtx_gmxx_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -3739,7 +3748,7 @@ union cvmx_dtx_gserx_bcst_rsp {
 	struct cvmx_dtx_gserx_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -3760,7 +3769,8 @@ union cvmx_dtx_gserx_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -3838,7 +3848,7 @@ union cvmx_dtx_hna_bcst_rsp {
 	struct cvmx_dtx_hna_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -3859,7 +3869,8 @@ union cvmx_dtx_hna_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -3937,7 +3948,7 @@ union cvmx_dtx_ila_bcst_rsp {
 	struct cvmx_dtx_ila_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -3958,7 +3969,8 @@ union cvmx_dtx_ila_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -4036,7 +4048,7 @@ union cvmx_dtx_ilk_bcst_rsp {
 	struct cvmx_dtx_ilk_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -4057,7 +4069,8 @@ union cvmx_dtx_ilk_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -4135,7 +4148,7 @@ union cvmx_dtx_iob_bcst_rsp {
 	struct cvmx_dtx_iob_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -4157,7 +4170,8 @@ union cvmx_dtx_iob_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -4239,7 +4253,7 @@ union cvmx_dtx_iobn_bcst_rsp {
 	struct cvmx_dtx_iobn_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -4260,7 +4274,8 @@ union cvmx_dtx_iobn_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -4338,7 +4353,7 @@ union cvmx_dtx_iobp_bcst_rsp {
 	struct cvmx_dtx_iobp_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -4359,7 +4374,8 @@ union cvmx_dtx_iobp_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -4437,7 +4453,7 @@ union cvmx_dtx_ipd_bcst_rsp {
 	struct cvmx_dtx_ipd_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -4459,7 +4475,8 @@ union cvmx_dtx_ipd_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -4541,7 +4558,7 @@ union cvmx_dtx_key_bcst_rsp {
 	struct cvmx_dtx_key_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -4563,7 +4580,8 @@ union cvmx_dtx_key_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -4645,7 +4663,7 @@ union cvmx_dtx_l2c_cbcx_bcst_rsp {
 	struct cvmx_dtx_l2c_cbcx_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -4668,7 +4686,8 @@ union cvmx_dtx_l2c_cbcx_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -4754,7 +4773,7 @@ union cvmx_dtx_l2c_mcix_bcst_rsp {
 	struct cvmx_dtx_l2c_mcix_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -4777,7 +4796,8 @@ union cvmx_dtx_l2c_mcix_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -4863,7 +4883,7 @@ union cvmx_dtx_l2c_tadx_bcst_rsp {
 	struct cvmx_dtx_l2c_tadx_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -4886,7 +4906,8 @@ union cvmx_dtx_l2c_tadx_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -4972,7 +4993,7 @@ union cvmx_dtx_lapx_bcst_rsp {
 	struct cvmx_dtx_lapx_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -4993,7 +5014,8 @@ union cvmx_dtx_lapx_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5071,7 +5093,7 @@ union cvmx_dtx_lbk_bcst_rsp {
 	struct cvmx_dtx_lbk_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -5092,7 +5114,8 @@ union cvmx_dtx_lbk_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5170,7 +5193,7 @@ union cvmx_dtx_lmcx_bcst_rsp {
 	struct cvmx_dtx_lmcx_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -5193,7 +5216,8 @@ union cvmx_dtx_lmcx_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5279,7 +5303,7 @@ union cvmx_dtx_mio_bcst_rsp {
 	struct cvmx_dtx_mio_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -5302,7 +5326,8 @@ union cvmx_dtx_mio_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5388,7 +5413,7 @@ union cvmx_dtx_ocx_lnkx_bcst_rsp {
 	struct cvmx_dtx_ocx_lnkx_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -5409,7 +5434,8 @@ union cvmx_dtx_ocx_lnkx_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5487,7 +5513,7 @@ union cvmx_dtx_ocx_olex_bcst_rsp {
 	struct cvmx_dtx_ocx_olex_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -5508,7 +5534,8 @@ union cvmx_dtx_ocx_olex_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5586,7 +5613,7 @@ union cvmx_dtx_ocx_top_bcst_rsp {
 	struct cvmx_dtx_ocx_top_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -5607,7 +5634,8 @@ union cvmx_dtx_ocx_top_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5685,7 +5713,7 @@ union cvmx_dtx_osm_bcst_rsp {
 	struct cvmx_dtx_osm_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -5706,7 +5734,8 @@ union cvmx_dtx_osm_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5784,7 +5813,7 @@ union cvmx_dtx_pcsx_bcst_rsp {
 	struct cvmx_dtx_pcsx_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -5806,7 +5835,8 @@ union cvmx_dtx_pcsx_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5888,7 +5918,7 @@ union cvmx_dtx_pemx_bcst_rsp {
 	struct cvmx_dtx_pemx_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -5911,7 +5941,8 @@ union cvmx_dtx_pemx_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -5997,7 +6028,7 @@ union cvmx_dtx_pip_bcst_rsp {
 	struct cvmx_dtx_pip_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -6019,7 +6050,8 @@ union cvmx_dtx_pip_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6101,7 +6133,7 @@ union cvmx_dtx_pki_pbe_bcst_rsp {
 	struct cvmx_dtx_pki_pbe_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -6122,7 +6154,8 @@ union cvmx_dtx_pki_pbe_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6200,7 +6233,7 @@ union cvmx_dtx_pki_pfe_bcst_rsp {
 	struct cvmx_dtx_pki_pfe_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -6221,7 +6254,8 @@ union cvmx_dtx_pki_pfe_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6299,7 +6333,7 @@ union cvmx_dtx_pki_pix_bcst_rsp {
 	struct cvmx_dtx_pki_pix_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -6320,7 +6354,8 @@ union cvmx_dtx_pki_pix_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6398,7 +6433,7 @@ union cvmx_dtx_pko_bcst_rsp {
 	struct cvmx_dtx_pko_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -6421,7 +6456,8 @@ union cvmx_dtx_pko_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6507,7 +6543,7 @@ union cvmx_dtx_pow_bcst_rsp {
 	struct cvmx_dtx_pow_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -6529,7 +6565,8 @@ union cvmx_dtx_pow_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6611,7 +6648,7 @@ union cvmx_dtx_rad_bcst_rsp {
 	struct cvmx_dtx_rad_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -6632,7 +6669,8 @@ union cvmx_dtx_rad_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6710,7 +6748,7 @@ union cvmx_dtx_rnm_bcst_rsp {
 	struct cvmx_dtx_rnm_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -6731,7 +6769,8 @@ union cvmx_dtx_rnm_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6809,7 +6848,7 @@ union cvmx_dtx_rst_bcst_rsp {
 	struct cvmx_dtx_rst_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -6832,7 +6871,8 @@ union cvmx_dtx_rst_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -6918,7 +6958,7 @@ union cvmx_dtx_sata_bcst_rsp {
 	struct cvmx_dtx_sata_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -6940,7 +6980,8 @@ union cvmx_dtx_sata_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7022,7 +7063,7 @@ union cvmx_dtx_sli_bcst_rsp {
 	struct cvmx_dtx_sli_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -7045,7 +7086,8 @@ union cvmx_dtx_sli_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7131,7 +7173,7 @@ union cvmx_dtx_sso_bcst_rsp {
 	struct cvmx_dtx_sso_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -7152,7 +7194,8 @@ union cvmx_dtx_sso_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7230,7 +7273,7 @@ union cvmx_dtx_tim_bcst_rsp {
 	struct cvmx_dtx_tim_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -7253,7 +7296,8 @@ union cvmx_dtx_tim_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7339,7 +7383,7 @@ union cvmx_dtx_usbdrdx_bcst_rsp {
 	struct cvmx_dtx_usbdrdx_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -7361,7 +7405,8 @@ union cvmx_dtx_usbdrdx_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7443,7 +7488,7 @@ union cvmx_dtx_usbhx_bcst_rsp {
 	struct cvmx_dtx_usbhx_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -7464,7 +7509,8 @@ union cvmx_dtx_usbhx_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
@@ -7542,7 +7588,7 @@ union cvmx_dtx_zip_bcst_rsp {
 	struct cvmx_dtx_zip_bcst_rsp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX Broadcast reads/writes. */
+	uint64_t ena                          : 1;  /**< Enable this DTX instance as the responder to DTX broadcast read/write operations. */
 #else
 	uint64_t ena                          : 1;
 	uint64_t reserved_1_63                : 63;
@@ -7563,7 +7609,8 @@ union cvmx_dtx_zip_ctl {
 	uint64_t active                       : 1;  /**< Force block's gated clocks on, so that the state of idle signals may be captured. */
 	uint64_t reserved_2_3                 : 2;
 	uint64_t echoen                       : 1;  /**< Drive debug bus with the value in DTX_MIO_ENA(0..1) instead of normal block debug data.
-                                                         Not applicable when SW directly reads the DAT(0..1) registers.  For diagnostic use only. */
+                                                         Not applicable when software directly reads the DAT(0..1) registers.  For diagnostic use
+                                                         only. */
 	uint64_t swap                         : 1;  /**< Swap the high and low 36-bit debug bus outputs. */
 #else
 	uint64_t swap                         : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
index 827a0e3..56c9053 100644
--- a/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-gserx-defs.h
@@ -625,6 +625,17 @@ static inline uint64_t CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(unsigned long offset,
 #define CVMX_GSERX_LANEX_PMA_LOOPBACK_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904400D0ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
 #endif
 #if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_GSERX_LANEX_PWR_CTRL(unsigned long offset, unsigned long block_id)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN78XX) && (((offset <= 3)) && ((block_id <= 13))))))
+		cvmx_warn("CVMX_GSERX_LANEX_PWR_CTRL(%lu,%lu) is invalid on this chip\n", offset, block_id);
+	return CVMX_ADD_IO_SEG(0x00011800904400D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576;
+}
+#else
+#define CVMX_GSERX_LANEX_PWR_CTRL(offset, block_id) (CVMX_ADD_IO_SEG(0x00011800904400D8ull) + (((offset) & 3) + ((block_id) & 15) * 0x10ull) * 1048576)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
 static inline uint64_t CVMX_GSERX_LANEX_RX_AEQ_OUT_0(unsigned long offset, unsigned long block_id)
 {
 	if (!(
@@ -1735,11 +1746,11 @@ union cvmx_gserx_ana_atest {
 	uint64_t reserved_12_63               : 52;
 	uint64_t ana_dac_b                    : 7;  /**< Used to control the B-side DAC input to the analog test block. Note that the QLM4 register
                                                          is tied to the analog test block, for non-OCI links. Note that the OCI4 register is tied
-                                                         to the analog test block, for OCI links. The other QLM GSER_ANA_DAC_B registers are
+                                                         to the analog test block, for OCI links. The other GSER()_ANA_ATEST registers are
                                                          unused. For diagnostic use only. */
 	uint64_t ana_dac_a                    : 5;  /**< Used to control A-side DAC input to the analog test block. Note that the QLM4 register is
                                                          tied to the analog test block, for non-OCI links. Note that the OCI4 register is tied to
-                                                         the analog test block, for OCI links. The other QLM GSER_ANA_DAC_A registers are unused.
+                                                         the analog test block, for OCI links. The other GSER()_ANA_ATEST registers are unused.
                                                          For diagnostic use only. */
 #else
 	uint64_t ana_dac_a                    : 5;
@@ -1761,7 +1772,7 @@ union cvmx_gserx_ana_sel {
 	uint64_t reserved_9_63                : 55;
 	uint64_t ana_sel                      : 9;  /**< Used to control the adr_global input to the analog test block. Note that the QLM0 register
                                                          is tied to the analog test block, for non-OCI links. Note that the QLM8 register is tied
-                                                         to the analog test block, for OCI links. The other QLM GSER_ANA_SEL registers are unused.
+                                                         to the analog test block, for OCI links. The other GSER()_ANA_SEL registers are unused.
                                                          For diagnostic use only. */
 #else
 	uint64_t ana_sel                      : 9;
@@ -1821,19 +1832,19 @@ union cvmx_gserx_br_rxx_eer {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t rxt_eer                      : 1;  /**< When RX Base-R Link Training is being performed under software control,
-                                                         (GSER(0..13)_BR_RX(0..3)_CTL[RXT_SWM] is set), writing this bit initiates an equalization
+                                                         (GSER()_BR_RX()_CTL[RXT_SWM] is set), writing this bit initiates an equalization
                                                          request to the RAW PCS. Reading this bit always returns a zero. */
 	uint64_t rxt_esv                      : 1;  /**< When performing an equalization request (RXT_EER), this bit, when set, indicates that the
                                                          Equalization Status (RXT_ESM) is valid. When issuing a RXT_EER request, it is expected
                                                          that RXT_ESV will get written to zero so that a valid RXT_ESM can be determined. */
 	uint64_t rxt_esm                      : 14; /**< When performing an equalization request (RXT_EER), this is the equalization status message
                                                          from the RAW PCS. It is valid when RXT_ESV is set.
-                                                         <13:6>: Figure of merit. An 8-bit output from the PHY indicating the quality of the
+                                                         _ <13:6>: Figure of merit. An 8-bit output from the PHY indicating the quality of the
                                                          received data eye. A higher value indicates better link equalization, with 8'd0 indicating
                                                          worst equalization setting and 8'd255 indicating the best equalization setting.
-                                                         <5:4>: RX recommended TXPOST direction change.
-                                                         <3:2>: RX recommended TXMAIN direction change.
-                                                         <1:0>: RX recommended TXPRE direction change.
+                                                         _ <5:4>: RX recommended TXPOST direction change.
+                                                         _ <3:2>: RX recommended TXMAIN direction change.
+                                                         _ <1:0>: RX recommended TXPRE direction change.
                                                          Recommended direction change outputs from the PHY for the link partner transmitter
                                                          coefficients.
                                                          0x0 = Hold.
@@ -1879,7 +1890,7 @@ union cvmx_gserx_br_txx_cur {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
 	uint64_t txt_cur                      : 14; /**< When TX Base-R Link Training is being performed under software control,
-                                                         (GSER_BR_TX(0..3)_CTL.TXT_SWM is set), this is the Coefficient Update to be written to the
+                                                         (GSER()_BR_TX()_CTL.TXT_SWM is set), this is the Coefficient Update to be written to the
                                                          PHY.
                                                          For diagnostic use only.
                                                          <13:9> = TX_POST<4:0>.
@@ -1902,10 +1913,10 @@ union cvmx_gserx_cfg {
 	struct cvmx_gserx_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
-	uint64_t bgx_quad                     : 1;  /**< For non-OCI links, indicates the BGX is in quad aggregation mode when GSER(0..7)_CFG[BGX]
+	uint64_t bgx_quad                     : 1;  /**< For non-OCI links, indicates the BGX is in quad aggregation mode when GSER()_CFG[BGX]
                                                          is also set. A single controller is used for all four lanes. For OCI links, this bit has
                                                          no meaning. */
-	uint64_t bgx_dual                     : 1;  /**< For non-OCI links, indicates the BGX is in dual aggregation mode when GSER(0..7)_CFG[BGX]
+	uint64_t bgx_dual                     : 1;  /**< For non-OCI links, indicates the BGX is in dual aggregation mode when GSER()_CFG[BGX]
                                                          is also set. A single controller is used for lanes 0 and 1 and another controller is used
                                                          for lanes 2 and 3. For OCI links, this bit has no meaning. */
 	uint64_t bgx                          : 1;  /**< For non-OCI links, indicates the GSER is configured for BGX mode. Only one of the BGX,
@@ -1936,7 +1947,7 @@ union cvmx_gserx_dbg {
 	struct cvmx_gserx_dbg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t rxqtm_on                     : 1;  /**< For non BGX/ILK configurations, setting this bit enables the RX FIFOs. This allows
+	uint64_t rxqtm_on                     : 1;  /**< For non-BGX/ILK configurations, setting this bit enables the RX FIFOs. This allows
                                                          received data to become visible to the RSL debug port. For diagnostic use only. */
 #else
 	uint64_t rxqtm_on                     : 1;
@@ -2817,9 +2828,9 @@ union cvmx_gserx_glbl_tad {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t pcs_sds_tad_8_5              : 4;  /**< AMON Specific mode selection.
-                                                         Set GSER(0..13)_GLBL_TM_ADMON[AMON_ON].
-                                                         Decodes 0x0 - 0x4 require GSER(0..13)_GLBL_TM_ADMON[LSEL] set.
-                                                         Decodes 0x5 - 0x5 do not require GSER(0..13)_GLBL_TM_ADMON[LSEL] set.
+                                                         Set GSER()_GLBL_TM_ADMON[AMON_ON].
+                                                         Decodes 0x0 - 0x4 require GSER()_GLBL_TM_ADMON[LSEL] set.
+                                                         Decodes 0x5 - 0x5 do not require GSER()_GLBL_TM_ADMON[LSEL] set.
                                                          In both cases, the resulting signals can be observed on the AMON pin.
                                                          0x0 = TX txdrv DAC 100ua sink current monitor.
                                                          0x1 = TX vcnt precision dcc.
@@ -2838,9 +2849,9 @@ union cvmx_gserx_glbl_tad {
                                                          0xE = Global PLL regulate VCO supply.
                                                          0xF = Global VCTRL for VCO varactor control. */
 	uint64_t pcs_sds_tad_4_0              : 5;  /**< DMON Specific mode selection.
-                                                         Set GSER(0..13)_GLBL_TM_ADMON[DMON_ON].
-                                                         Decodes 0x0 - 0xe require GSER(0..13)_GLBL_TM_ADMON[LSEL] set.
-                                                         Decodes 0xf - 0x1f do not require GSER(0..13)_GLBL_TM_ADMON[LSEL] set.
+                                                         Set GSER()_GLBL_TM_ADMON[DMON_ON].
+                                                         Decodes 0x0 - 0xe require GSER()_GLBL_TM_ADMON[LSEL] set.
+                                                         Decodes 0xf - 0x1f do not require GSER()_GLBL_TM_ADMON[LSEL] set.
                                                          In both cases, the resulting signals can be observed on the DMON pin.
                                                          0x00 = DFE Data Q.
                                                          0x01 = DFE Edge I.
@@ -2855,7 +2866,7 @@ union cvmx_gserx_glbl_tad {
                                                          0x0C-0x0E = Reserved.
                                                          0x0F = Special case to observe supply in global. Sds_vdda and a internal regulated supply
                                                          can be observed on DMON and DMONB
-                                                         respectively.  sds_vss can be observed on AMON. GSER(0..13)_GLBL_TM_ADMON[AMON_ON]
+                                                         respectively.  sds_vss can be observed on AMON. GSER()_GLBL_TM_ADMON[AMON_ON]
                                                          must not be set.
                                                          0x10: PLL_CLK 0 degree.
                                                          0x11: Sds_tst_fb_clk.
@@ -2953,13 +2964,13 @@ union cvmx_gserx_lanex_lbert_cfg {
 	uint64_t lbert_pg_mode                : 4;  /**< LBERT pattern generator mode; when changing modes,
                                                          must be disabled first:
                                                          0x0 = Disabled.
-                                                         0x1 = lfsr31   X^31 + X^28 + 1.
-                                                         0x2 = lfsr23   X^23 + X^18 + 1.
-                                                         0x3 = lfsr23   X^23 + X^21 + X^16 + X^8 + X^5 + X^2 + 1.
-                                                         0x4 = lfsr16   X^16 + X^5 + X^4 + X^3 + 1.
-                                                         0x5 = lfsr15   X^15 + X^14 + 1.
-                                                         0x6 = lfsr11   X^11 + X^9 + 1.
-                                                         0x7 = lfsr7    X^7 + X^6 + 1.
+                                                         0x1 = lfsr31 = X^31 + X^28 + 1.
+                                                         0x2 = lfsr23 = X^23 + X^18 + 1.
+                                                         0x3 = lfsr23 = X^23 + X^21 + X^16 + X^8 + X^5 + X^2 + 1.
+                                                         0x4 = lfsr16 = X^16 + X^5 + X^4 + X^3 + 1.
+                                                         0x5 = lfsr15 = X^15 + X^14 + 1.
+                                                         0x6 = lfsr11 = X^11 + X^9 + 1.
+                                                         0x7 = lfsr7  = X^7 + X^6 + 1.
                                                          0x8 = Fixed word (PAT0).
                                                          0x9 = DC-balanced word (PAT0, ~PAT0)
                                                          0xA = Fixed Pattern (000, PAT0, 3ff, ~PAT0).
@@ -2973,13 +2984,13 @@ union cvmx_gserx_lanex_lbert_cfg {
 	uint64_t lbert_pm_mode                : 4;  /**< LBERT pattern matcher mode; when changing modes,
                                                          must be disabled first:
                                                          0x0 = Disabled.
-                                                         0x1 = lfsr31   X^31 + X^28 + 1.
-                                                         0x2 = lfsr23   X^23 + X^18 + 1.
-                                                         0x3 = lfsr23   X^23 + X^21 + X^16 + X^8 + X^5 + X^2 + 1.
-                                                         0x4 = lfsr16   X^16 + X^5 + X^4 + X^3 + 1.
-                                                         0x5 = lfsr15   X^15 + X^14 + 1.
-                                                         0x6 = lfsr11   X^11 + X^9 + 1.
-                                                         0x7 = lfsr7    X^7 + X^6 + 1.
+                                                         0x1 = lfsr31 = X^31 + X^28 + 1.
+                                                         0x2 = lfsr23 = X^23 + X^18 + 1.
+                                                         0x3 = lfsr23 = X^23 + X^21 + X^16 + X^8 + X^5 + X^2 + 1.
+                                                         0x4 = lfsr16 = X^16 + X^5 + X^4 + X^3 + 1.
+                                                         0x5 = lfsr15 = X^15 + X^14 + 1.
+                                                         0x6 = lfsr11 = X^11 + X^9 + 1.
+                                                         0x7 = lfsr7  = X^7 + X^6 + 1.
                                                          0x8 = Fixed word (PAT0).
                                                          0x9 = DC-balanced word (PAT0, ~PAT0).
                                                          0xA = Fixed Pattern: (000, PAT0, 3ff, ~PAT0).
@@ -3042,7 +3053,7 @@ union cvmx_gserx_lanex_lbert_pat_cfg {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t lbert_pg_pat                 : 10; /**< Programmable 10-bit pattern to be used in the LBERT pattern mode;
-                                                         applies when GSER(0..13)_LANE(0..3)_LBERT_CFG[LBERT_PG_MODE]
+                                                         applies when GSER()_LANE()_LBERT_CFG[LBERT_PG_MODE]
                                                          is equal to 8, 9, or 10. */
 #else
 	uint64_t lbert_pg_pat                 : 10;
@@ -3066,7 +3077,7 @@ union cvmx_gserx_lanex_misc_cfg_0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t use_pma_polarity             : 1;  /**< If set, the PMA control is used to define the polarity.
-                                                         In not set, GSERX_LANE(0..3)_RX_CFG_0[CFG_RX_POL_INVERT]
+                                                         In not set, GSER()_LANE()_RX_CFG_0[CFG_RX_POL_INVERT]
                                                          is used. */
 	uint64_t cfg_pcs_loopback             : 1;  /**< Assert for Parallel Loopback Raw PCS TX to Raw PCS RX. */
 	uint64_t pcs_tx_mode_ovrrd_en         : 1;  /**< Override enable for Raw PCS TX data width. */
@@ -3150,27 +3161,27 @@ union cvmx_gserx_lanex_pcs_ctlifc_0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_14_63               : 50;
 	uint64_t cfg_tx_vboost_en_ovrrd_val   : 1;  /**< Specifies TX VBOOST Enable request when its override bit
-                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_VBOOST_EN_OVRRD_EN]. */
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_VBOOST_EN_OVRRD_EN]. */
 	uint64_t cfg_tx_coeff_req_ovrrd_val   : 1;  /**< Specifies TX Coefficient request when its override bit
-                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_COEFF_REQ_OVRRD_EN]. */
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_COEFF_REQ_OVRRD_EN]. */
 	uint64_t cfg_rx_cdr_coast_req_ovrrd_val : 1;/**< Specifies RX CDR Coast request when its override bit
-                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_RX_COAST_REQ_OVRRD_EN]. */
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_RX_COAST_REQ_OVRRD_EN]. */
 	uint64_t cfg_tx_detrx_en_req_ovrrd_val : 1; /**< Specifies TX Detect RX request when its override bit
-                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_DETRX_EN_REQ_OVRRD_EN]. */
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_DETRX_EN_REQ_OVRRD_EN]. */
 	uint64_t cfg_soft_reset_req_ovrrd_val : 1;  /**< Specifies Soft Reset request when its override bit
-                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_SOFT_RESET_REQ_OVRRD_EN]. */
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_SOFT_RESET_REQ_OVRRD_EN]. */
 	uint64_t cfg_lane_pwr_off_ovrrd_val   : 1;  /**< Specifies Lane Power Off Reset request when its override bit
-                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_LANE_PWR_OFF_OVRRD_EN]. */
-	uint64_t cfg_tx_mode_ovrrd_val        : 2;  /**< Overide PCS TX mode (data width) when its overide bit
-                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_MODE_OVRRD_EN].
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_LANE_PWR_OFF_OVRRD_EN]. */
+	uint64_t cfg_tx_mode_ovrrd_val        : 2;  /**< Override PCS TX mode (data width) when its override bit
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_MODE_OVRRD_EN].
                                                          0x0 = 8-bit raw data (not supported).
                                                          0x1 = 10-bit raw data (not supported).
                                                          0x2 = 16-bit raw data (not supported).
                                                          0x3 = 20-bit raw data. */
-	uint64_t cfg_tx_pstate_req_ovrrd_val  : 2;  /**< Overide TX pstate request when its overide bit
-                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_PSTATE_REQ_OVRRD_EN]. */
-	uint64_t cfg_lane_mode_req_ovrrd_val  : 4;  /**< Overide Lane Mode request when its overide bit
-                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_LANE_MODE_REQ_OVRRD_EN]. */
+	uint64_t cfg_tx_pstate_req_ovrrd_val  : 2;  /**< Override TX pstate request when its override bit
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_PSTATE_REQ_OVRRD_EN]. */
+	uint64_t cfg_lane_mode_req_ovrrd_val  : 4;  /**< Override Lane Mode request when its override bit
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_LANE_MODE_REQ_OVRRD_EN]. */
 #else
 	uint64_t cfg_lane_mode_req_ovrrd_val  : 4;
 	uint64_t cfg_tx_pstate_req_ovrrd_val  : 2;
@@ -3200,11 +3211,11 @@ union cvmx_gserx_lanex_pcs_ctlifc_1 {
 	struct cvmx_gserx_lanex_pcs_ctlifc_1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
-	uint64_t cfg_rx_pstate_req_ovrrd_val  : 2;  /**< Overide RX pstate request when its overide bit
-                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_PSTATE_REQ_OVRRD_EN]. */
+	uint64_t cfg_rx_pstate_req_ovrrd_val  : 2;  /**< Override RX pstate request when its override bit
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_PSTATE_REQ_OVRRD_EN]. */
 	uint64_t reserved_2_6                 : 5;
-	uint64_t cfg_rx_mode_ovrrd_val        : 2;  /**< Overide PCS RX mode (data width) when its overide bit
-                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_RX_MODE_OVRRD_EN].
+	uint64_t cfg_rx_mode_ovrrd_val        : 2;  /**< Override PCS RX mode (data width) when its override bit
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_RX_MODE_OVRRD_EN].
                                                          0x0 = 8-bit raw data (not supported).
                                                          0x1 = 10-bit raw data (not supported).
                                                          0x2 = 16-bit raw data (not supported).
@@ -3233,35 +3244,35 @@ union cvmx_gserx_lanex_pcs_ctlifc_2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t ctlifc_ovrrd_req             : 1;  /**< Writing to set this bit initiates a state machine interface request
-                                                         for GSERX_LANE(0..3)_PCS_CTLIFC_0 and GSERX_LANE(0..3)_PCS_CTLIFC_1
-                                                         overide values. */
+                                                         for GSER()_LANE()_PCS_CTLIFC_0 and GSER()_LANE()_PCS_CTLIFC_1
+                                                         override values. */
 	uint64_t reserved_9_14                : 6;
 	uint64_t cfg_tx_vboost_en_ovrrd_en    : 1;  /**< Override mac_pcs_txX vboost_en signal with the value specified in
-                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_VBOOST_EN_OVRRD_VAL]. */
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_VBOOST_EN_OVRRD_VAL]. */
 	uint64_t cfg_tx_coeff_req_ovrrd_en    : 1;  /**< Override mac_pcs_txX_coeff_req signal with the value specified in
-                                                         GSERX_LANE(0..3)_PCS_CTLIFC_0[CFG_TX_COEFF_REQ_OVRRD_VAL]. */
+                                                         GSER()_LANE()_PCS_CTLIFC_0[CFG_TX_COEFF_REQ_OVRRD_VAL]. */
 	uint64_t cfg_rx_cdr_coast_req_ovrrd_en : 1; /**< Override mac_pcs_rxX_cdr_coast signal with the value specified in
-                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_RX_COAST_REQ_OVRRD_VAL]. */
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_RX_COAST_REQ_OVRRD_VAL]. */
 	uint64_t cfg_tx_detrx_en_req_ovrrd_en : 1;  /**< Override mac_pcs_txX_detrx_en signal with the value specified in
-                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_DETRX_EN_REQ_OVRRD_VAL]. */
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_DETRX_EN_REQ_OVRRD_VAL]. */
 	uint64_t cfg_soft_reset_req_ovrrd_en  : 1;  /**< Override mac_pcs_laneX_soft_rst signal with the value specified in
-                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_SOFT_RESET_REQ_OVRRD_VAL]. */
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_SOFT_RESET_REQ_OVRRD_VAL]. */
 	uint64_t cfg_lane_pwr_off_ovrrd_en    : 1;  /**< Override mac_pcs_laneX_pwr_off signal with the value specified in
-                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_LANE_PWR_OFF_OVRRD_VAL]. */
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_LANE_PWR_OFF_OVRRD_VAL]. */
 	uint64_t cfg_tx_pstate_req_ovrrd_en   : 1;  /**< Override mac_pcs_txX_pstate[1:0] signal with the value specified in
-                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_TX_PSTATE_REQ_OVRRD_VAL].
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_TX_PSTATE_REQ_OVRRD_VAL].
                                                          When using this field to change the TX Power State, you must also set
                                                          the override enable bits for the lane_mode, soft_reset and lane_pwr_off
                                                          fields.  The corresponding orrd_val fields should be programmed so as
                                                          not to cause undesired changes. */
 	uint64_t cfg_rx_pstate_req_ovrrd_en   : 1;  /**< Override mac_pcs_rxX_pstate[1:0] signal with the value specified in
-                                                         GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_RX_PSTATE_REQ_OVRRD_VAL].
+                                                         GSER()_LANE()_PCS_CTLIFC_2[CFG_RX_PSTATE_REQ_OVRRD_VAL].
                                                          When using this field to change the RX Power State, you must also set
                                                          the override enable bits for the lane_mode, soft_reset and lane_pwr_off
                                                          fields.  The corresponding orrd_val fields should be programmed so as
                                                          not to cause undesired changes. */
 	uint64_t cfg_lane_mode_req_ovrrd_en   : 1;  /**< Override mac_pcs_laneX_mode[3:0] signal with the value specified in
-                                                         is asserted GSERX_LANE(0..3)_PCS_CTLIFC_2[CFG_LANE_MODE_REQ_OVRRD_VAL]. */
+                                                         is asserted GSER()_LANE()_PCS_CTLIFC_2[CFG_LANE_MODE_REQ_OVRRD_VAL]. */
 #else
 	uint64_t cfg_lane_mode_req_ovrrd_en   : 1;
 	uint64_t cfg_rx_pstate_req_ovrrd_en   : 1;
@@ -3294,7 +3305,7 @@ union cvmx_gserx_lanex_pma_loopback_ctrl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t cfg_ln_lpbk_mode_ovrrd_en    : 1;  /**< Enable override mac_pcs_loopbk_mode[3:0] with value of FG_LN_LPBK_MODE. */
-	uint64_t cfg_ln_lpbk_mode             : 1;  /**< Overide value when CFG_LN_LPBK_MODE_OVRRD_EN is set. */
+	uint64_t cfg_ln_lpbk_mode             : 1;  /**< Override value when CFG_LN_LPBK_MODE_OVRRD_EN is set. */
 #else
 	uint64_t cfg_ln_lpbk_mode             : 1;
 	uint64_t cfg_ln_lpbk_mode_ovrrd_en    : 1;
@@ -3306,6 +3317,82 @@ union cvmx_gserx_lanex_pma_loopback_ctrl {
 typedef union cvmx_gserx_lanex_pma_loopback_ctrl cvmx_gserx_lanex_pma_loopback_ctrl_t;
 
 /**
+ * cvmx_gser#_lane#_pwr_ctrl
+ *
+ * These registers are for diagnostic use only.
+ * These registers are only reset by hardware during chip cold reset.
+ * The values of the CSR fields in these registers do not change during chip warm or soft resets.
+ */
+union cvmx_gserx_lanex_pwr_ctrl {
+	uint64_t u64;
+	struct cvmx_gserx_lanex_pwr_ctrl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t tx_sds_fifo_reset_ovrrd_en   : 1;  /**< When asserted, TX_SDS_FIFO_RESET_OVVRD_VAL is used to specify the value of the reset
+                                                         signal for the TX FIFO supplying data to the SerDes p2s interface. */
+	uint64_t tx_sds_fifo_reset_ovrrd_val  : 1;  /**< When asserted, TX_SDS_FIFO_RESET_OVVRD_EN is asserted, this field is
+                                                         used to specify the value of the reset
+                                                         signal for the TX FIFO supplying data to the SerDes p2s interface. */
+	uint64_t tx_pcs_reset_ovrrd_val       : 1;  /**< When TX_PCS_RESET_OVRRD_EN is
+                                                         asserted, this field is used to specify the value of
+                                                         the reset signal for PCS TX logic. */
+	uint64_t rx_pcs_reset_ovrrd_val       : 1;  /**< When RX_PCS_RESET_OVRRD_EN is
+                                                         asserted, this field is used to specify the value of
+                                                         the reset signal for PCS RX logic. */
+	uint64_t reserved_9_10                : 2;
+	uint64_t rx_resetn_ovrrd_en           : 1;  /**< Override RX Power State machine rx_resetn
+                                                         control signal.  When set, the rx_resetn control signal is taken
+                                                         from the GSER()_LANE()_RX_CFG_0[RX_RESETN_OVRRD_VAL]
+                                                         control bit. */
+	uint64_t rx_resetn_ovrrd_val          : 1;  /**< Override RX Power State machine reset control
+                                                         signal. When set, reset control signals are specified in
+                                                         [RX_PCS_RESET_OVRRD_VAL]. */
+	uint64_t rx_lctrl_ovrrd_en            : 1;  /**< Override RX Power State machine loop control
+                                                         signals. */
+	uint64_t rx_lctrl_ovrrd_val           : 1;  /**< Override RX Power State machine power down
+                                                         control signal. When set, the power down control signal is
+                                                         specified by GSER()_LANE()_RX_CFG_1[RX_CHPD_OVRRD_VAL]. */
+	uint64_t tx_tristate_en_ovrrd_en      : 1;  /**< Override TX Power State machine TX tristate
+                                                         control signal.  When set, TX tristate control signal is specified
+                                                         in GSER()_LANE()_TX_CFG_0[TX_TRISTATE_EN_OVRRD_VAL]. */
+	uint64_t tx_pcs_reset_ovrrd_en        : 1;  /**< Override TX Power State machine reset control
+                                                         signal.  When set, reset control signals is specified in
+                                                         [TX_PCS_RESET_OVRRD_VAL]. */
+	uint64_t tx_elec_idle_ovrrd_en        : 1;  /**< Override mac_pcs_txX_elec_idle signal
+                                                         When set, TX electrical idle is controlled from
+                                                         GSER()_LANE()_TX_CFG_1[TX_ELEC_IDLE_OVRRD_VAL]
+                                                         mac_pcs_txX_elec_idle signal is ignored. */
+	uint64_t tx_pd_ovrrd_en               : 1;  /**< Override TX Power State machine TX lane
+                                                         power-down control signal
+                                                         When set, TX lane power down is controlled by
+                                                         GSER()_LANE()_TX_CFG_0[TX_CHPD_OVRRD_VAL]. */
+	uint64_t tx_p2s_resetn_ovrrd_en       : 1;  /**< Override TX Power State machine TX reset
+                                                         control signal
+                                                         When set, TX reset is controlled by
+                                                         GSER()_LANE()_TX_CFG_0[TX_RESETN_OVRRD_VAL]. */
+#else
+	uint64_t tx_p2s_resetn_ovrrd_en       : 1;
+	uint64_t tx_pd_ovrrd_en               : 1;
+	uint64_t tx_elec_idle_ovrrd_en        : 1;
+	uint64_t tx_pcs_reset_ovrrd_en        : 1;
+	uint64_t tx_tristate_en_ovrrd_en      : 1;
+	uint64_t rx_lctrl_ovrrd_val           : 1;
+	uint64_t rx_lctrl_ovrrd_en            : 1;
+	uint64_t rx_resetn_ovrrd_val          : 1;
+	uint64_t rx_resetn_ovrrd_en           : 1;
+	uint64_t reserved_9_10                : 2;
+	uint64_t rx_pcs_reset_ovrrd_val       : 1;
+	uint64_t tx_pcs_reset_ovrrd_val       : 1;
+	uint64_t tx_sds_fifo_reset_ovrrd_val  : 1;
+	uint64_t tx_sds_fifo_reset_ovrrd_en   : 1;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_gserx_lanex_pwr_ctrl_s    cn78xx;
+};
+typedef union cvmx_gserx_lanex_pwr_ctrl cvmx_gserx_lanex_pwr_ctrl_t;
+
+/**
  * cvmx_gser#_lane#_rx_aeq_out_0
  *
  * These registers are for diagnostic use only.
@@ -3340,9 +3427,9 @@ union cvmx_gserx_lanex_rx_aeq_out_1 {
 	struct cvmx_gserx_lanex_rx_aeq_out_1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
-	uint64_t sds_pcs_rx_aeq_out           : 15; /**< <14:10>: DFE TAP3
-                                                         <9:5>: DFE TAP2
-                                                         <4:0>: DFE TAP1 */
+	uint64_t sds_pcs_rx_aeq_out           : 15; /**< <14:10> = DFE TAP3.
+                                                         <9:5> = DFE TAP2.
+                                                         <4:0> = DFE TAP1. */
 #else
 	uint64_t sds_pcs_rx_aeq_out           : 15;
 	uint64_t reserved_15_63               : 49;
@@ -3391,7 +3478,7 @@ union cvmx_gserx_lanex_rx_cfg_0 {
 	uint64_t rx_datarate_ovrrd_en         : 1;  /**< Override enable for RX Power State Machine data rate signal. */
 	uint64_t pcs_sds_rx_tristate_enable   : 1;  /**< RX termination high-Z enable. */
 	uint64_t rx_resetn_ovvrd_val          : 1;  /**< This value overrides the RX Power State machine rx_resetn control
-                                                         signal when GSEX_LANE(0..3)_PWR_CTRL[RX_RESETN_OVRRD_EN] is set. */
+                                                         signal when GSER()_LANE()_PWR_CTRL[RX_RESETN_OVRRD_EN] is set. */
 	uint64_t pcs_sds_rx_eyemon_en         : 1;  /**< RX eyemon test enable. */
 	uint64_t pcs_sds_rx_pcm_ctrl          : 4;  /**< <11>: Reserved
                                                          <10-8>:
@@ -3405,15 +3492,9 @@ union cvmx_gserx_lanex_rx_cfg_0 {
                                                          0x1 = 1/2 data rate.
                                                          0x2 = 1/4 data rate.
                                                          0x3 = 1/8 data rate. */
-	uint64_t cfg_rx_pol_invert            : 1;  /**< Invert the receive data.  Allies with GSERX_LANE(0..3)_MISC_CFG_0[USE_PMA_POLARITY]
+	uint64_t cfg_rx_pol_invert            : 1;  /**< Invert the receive data.  Allies with GSER()_LANE()_MISC_CFG_0[USE_PMA_POLARITY]
                                                          is deasserted. */
-	uint64_t rx_subblk_pd_ovrrd_val       : 5;  /**< Override value for RX sub-block powerdown controls to RX
-                                                         when GSERX_LANE(0..3)_PWR_CTRL[RX_PD_OVVRD_EN] is asserted.
-                                                         <4> = CTLE.
-                                                         <3> = Reserved.
-                                                         <2> = Lane DLL.
-                                                         <1> = DFE/Samplers.
-                                                         <0> = Termination. */
+	uint64_t rx_subblk_pd_ovrrd_val       : 5;  /**< Not supported. */
 #else
 	uint64_t rx_subblk_pd_ovrrd_val       : 5;
 	uint64_t cfg_rx_pol_invert            : 1;
@@ -3442,18 +3523,17 @@ union cvmx_gserx_lanex_rx_cfg_1 {
 	struct cvmx_gserx_lanex_rx_cfg_1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t rx_chpd_ovrrd_val            : 1;  /**< Override value for RX bias powerdown.  Applies when
-                                                         GSERX_LANE(3..0)_PWR_CTRL[RX_PD_PVRRD_EN] is asserted. */
+	uint64_t rx_chpd_ovrrd_val            : 1;  /**< Not supported. */
 	uint64_t pcs_sds_rx_os_men            : 1;  /**< RX Offset manual enable. */
 	uint64_t eie_en_ovvrd_en              : 1;  /**< Override enable for Electrical-Idle-Exit circuit. */
 	uint64_t eie_en_ovvrd_val             : 1;  /**< Override value for Electrical-Idle-Exit circuit. */
 	uint64_t reserved_11_11               : 1;
-	uint64_t rx_pcie_mode_ovvrd_en        : 1;  /**< Override enable for RX_PCIE_MODE_OVVRD_VAL */
+	uint64_t rx_pcie_mode_ovvrd_en        : 1;  /**< Override enable for RX_PCIE_MODE_OVVRD_VAL. */
 	uint64_t rx_pcie_mode_ovvrd_val       : 1;  /**< Override value for RX_PCIE_MODE_OVVRD_VAL;
                                                          selects between RX terminations.
                                                          0x0 = pcs_sds_rx_terminate_to_vdda.
                                                          0x1 = VDDA. */
-	uint64_t cfg_rx_dll_locken            : 1;  /**< Enable DLL lock when GSERX_LANE()_RX_MISC_OVRRD[CFG_RX_DLL_LOCKEN_OVRRD_EN] is asserted. */
+	uint64_t cfg_rx_dll_locken            : 1;  /**< Enable DLL lock when GSER()_LANE()_RX_MISC_OVRRD[CFG_RX_DLL_LOCKEN_OVRRD_EN] is asserted. */
 	uint64_t pcs_sds_rx_cdr_ssc_mode      : 8;  /**< Per lane RX CDR SSC control:
                                                          <7:4> = Resrted.
                                                          <3> = Clean SSC error flag.
@@ -3494,17 +3574,18 @@ union cvmx_gserx_lanex_rx_cfg_2 {
                                                          1 = Terminate to sds_vdda. */
 	uint64_t pcs_sds_rx_sampler_boost     : 2;  /**< Controls amount of boost.
                                                          Note that this control can negatively impact reliability. */
-	uint64_t pcs_sds_rx_sampler_boost_en  : 1;  /**< Faster sampler c2q. For debug use only. */
+	uint64_t pcs_sds_rx_sampler_boost_en  : 1;  /**< Faster sampler c2q.
+                                                         For diagnostic use only. */
 	uint64_t reserved_10_10               : 1;
 	uint64_t rx_sds_rx_agc_mval           : 10; /**< AGC manual value only used when GSERX_LANE()_RX_CFG_5[RX_AGC_MEN_OVVRD_VAL] is set.
                                                          <9:8>: Reserved.
-                                                         <7:4>: Pre-CTL gain:
-                                                         0x0 = -6dB.
-                                                         0x1 = -5dB.
-                                                         0x3 = +5dB.
-                                                         <3:0>: Post-CTL gain (steps of 0.0875):
-                                                         0x0 = lowest.
-                                                         0xf = lowest * 2.3125. */
+                                                         <7:4>: Pre-CTL gain
+                                                         - 0 = -6dB
+                                                         - 1 = -5dB
+                                                         - 3 = +5dB.
+                                                         <3:0>: Post-CTL gain (steps of 0.0875)
+                                                         - 0x0 = lowest
+                                                         - 0xf = lowest * 2.3125. */
 #else
 	uint64_t rx_sds_rx_agc_mval           : 10;
 	uint64_t reserved_10_10               : 1;
@@ -3532,7 +3613,7 @@ union cvmx_gserx_lanex_rx_cfg_3 {
 	uint64_t reserved_16_63               : 48;
 	uint64_t cfg_rx_errdet_ctrl           : 16; /**< RX Adaptive Equalizer Control.
                                                          Value of pcs_sds_rx_err_det_ctrl when
-                                                         GSERX_LANE(0..3)_MISC_OVVRD[CFG_RS_ERRDET_CTRL_OVRRD_EN]
+                                                         GSER()_LANE()_RX_MISC_OVRRD[CFG_RS_ERRDET_CTRL_OVRRD_EN]
                                                          is set.
                                                          <15:13>: Starting delta (6.7mV/step, 13.4mV + 6.7mV*N).
                                                          <12:10>: Minimum delta to adapt to (6.7mV/step, 13.4mV + 6.7mV*N).
@@ -3567,7 +3648,7 @@ union cvmx_gserx_lanex_rx_cfg_4 {
 	uint64_t reserved_16_63               : 48;
 	uint64_t cfg_rx_errdet_ctrl           : 16; /**< RX adaptive equalizer control.
                                                          Value of pcs_sds_rx_err_det_ctrl when
-                                                         GSERX_LANE()_MISC_OVVRD[CFG_RS_ERRDET_CTRL_OVRRD_EN] is set.
+                                                         GSER()_LANE()_RX_MISC_OVRRD[CFG_RS_ERRDET_CTRL_OVRRD_EN] is set.
                                                          <15:14>: Reserved
                                                          <13:8>: Q/QB error sampler 0 threshold, 6.7mV/step, used for training/LMS.
                                                          <7>: Enable Window mode, after training has finished.
@@ -3578,7 +3659,7 @@ union cvmx_gserx_lanex_rx_cfg_4 {
                                                          0x3 = pre-CTLE gain, CTLE peak.
                                                          <4>: Offset cancellation enable.
                                                          <3:0>: Max CTLE peak setting during training when pcs_sds_rx_vma_ctl[7] is set in
-                                                         GSERX_LANE()_RX_VMA_CTRL. */
+                                                         GSER()_LANE()_RX_VMA_CTRL. */
 #else
 	uint64_t cfg_rx_errdet_ctrl           : 16;
 	uint64_t reserved_16_63               : 48;
@@ -3682,12 +3763,7 @@ union cvmx_gserx_lanex_rx_misc_ovrrd {
                                                          Detect Enable. */
 	uint64_t cfg_rx_eie_det_ovrrd_en      : 1;  /**< Override enable for RX Electrical-Idle-Exit
                                                          Detect Enable. */
-	uint64_t cfg_rx_cdr_ctrl_ovvrd_en     : 1;  /**< Override enable for RX CDR Control
-                                                         When asserted, the pcs_sds_rx_cdr_ctrl value
-                                                         is defined in registers
-                                                         GSERX_LANE(0..3)_RX_CDR_CTRL_0,
-                                                         GSERX_LANE(0..3)_RX_CDR_CTRL_1, and
-                                                         GSERX_LANE(0..3)_RX_CDR_CTRL_2. */
+	uint64_t cfg_rx_cdr_ctrl_ovvrd_en     : 1;  /**< Not supported. */
 	uint64_t cfg_rx_eq_eval_ovrrd_val     : 1;  /**< Training mode control in override mode. */
 	uint64_t cfg_rx_eq_eval_ovrrd_en      : 1;  /**< Override enable for RX-EQ Eval
                                                          When asserted, training mode is controlled by
@@ -3696,10 +3772,10 @@ union cvmx_gserx_lanex_rx_misc_ovrrd {
 	uint64_t cfg_rx_dll_locken_ovvrd_en   : 1;  /**< When asserted, override DLL lock enable
                                                          signal from the RX Power State machine with
                                                          CFG_RX_DLL_LOCKEN in register
-                                                         GSERX_LANE()_RX_CFG_1. */
+                                                         GSER()_LANE()_RX_CFG_1. */
 	uint64_t cfg_rx_errdet_ctrl_ovvrd_en  : 1;  /**< When asserted, pcs_sds_rx_err_det_ctrl is set
                                                          to cfg_rx_errdet_ctrl in registers
-                                                         GSERX_LANE()_RX_CFG_3 and GSERX_LANE()_RX_CFG_4. */
+                                                         GSER()_LANE()_RX_CFG_3 and GSER()_LANE()_RX_CFG_4. */
 	uint64_t reserved_0_3                 : 4;
 #else
 	uint64_t reserved_0_3                 : 4;
@@ -3735,10 +3811,10 @@ union cvmx_gserx_lanex_rx_precorr_ctrl {
 	uint64_t rx_precorr_en_ovrrd_en       : 1;  /**< Override enable for RX precorrelation calculation enable. */
 	uint64_t rx_precorr_en_ovrrd_val      : 1;  /**< Override value for RX precorrelation calculation enable. */
 	uint64_t pcs_sds_rx_precorr_scnt_ctrl : 2;  /**< RX precorrelation sample counter control.
-                                                         0x0 = Load max sample counter with 0x1ff.
-                                                         0x1 = Load max sample counter with 0x3ff.
-                                                         0x2 = Load max sample counter with 0x7ff.
-                                                         0x3 = Load max sample counter with 0xfff. */
+                                                         0x0 = Load max sample counter with 0x1FF.
+                                                         0x1 = Load max sample counter with 0x3FF.
+                                                         0x2 = Load max sample counter with 0x7FF.
+                                                         0x3 = Load max sample counter with 0xFFF. */
 #else
 	uint64_t pcs_sds_rx_precorr_scnt_ctrl : 2;
 	uint64_t rx_precorr_en_ovrrd_val      : 1;
@@ -3764,18 +3840,14 @@ union cvmx_gserx_lanex_rx_valbbd_ctrl_0 {
 	uint64_t reserved_14_63               : 50;
 	uint64_t agc_gain                     : 2;  /**< AGC gain. */
 	uint64_t dfe_gain                     : 2;  /**< DFE gain. */
-	uint64_t dfe_c5_mval                  : 4;  /**< DFE Tap5 manual value when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
-                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
-                                                         [DFE_C5_OVRD_VAL] are both set. */
-	uint64_t dfe_c5_msgn                  : 1;  /**< DFE Tap5 manual sign when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
-                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
-                                                         [DFE_C5_OVRD_VAL] are both set. */
-	uint64_t dfe_c4_mval                  : 4;  /**< DFE Tap4 manual value when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
-                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
-                                                         [DFE_C5_OVRD_VAL] are both set. */
-	uint64_t dfe_c4_msgn                  : 1;  /**< DFE Tap4 manual sign when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
-                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
-                                                         [DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c5_mval                  : 4;  /**< DFE Tap5 manual value when GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c5_msgn                  : 1;  /**< DFE Tap5 manual sign when GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c4_mval                  : 4;  /**< DFE Tap4 manual value when GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c4_msgn                  : 1;  /**< DFE Tap4 manual sign when GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_C5_OVRD_VAL] are both set. */
 #else
 	uint64_t dfe_c4_msgn                  : 1;
 	uint64_t dfe_c4_mval                  : 4;
@@ -3801,28 +3873,23 @@ union cvmx_gserx_lanex_rx_valbbd_ctrl_1 {
 	struct cvmx_gserx_lanex_rx_valbbd_ctrl_1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
-	uint64_t dfe_c3_mval                  : 4;  /**< DFE Tap3 manual value when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
-                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
-                                                         [DFE_C5_OVRD_VAL] are both set. */
-	uint64_t dfe_c3_msgn                  : 1;  /**< DFE Tap3 manual sign when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
-                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
-                                                         [DFE_C5_OVRD_VAL] are both set. */
-	uint64_t dfe_c2_mval                  : 4;  /**< DFE Tap2 manual value when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
-                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
-                                                         [DFE_C5_OVRD_VAL] are both set. */
-	uint64_t dfe_c2_msgn                  : 1;  /**< DFE Tap2 manual sign when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
-                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
-                                                         [DFE_C5_OVRD_VAL] are both set. */
-	uint64_t dfe_c1_mval                  : 4;  /**< DFE Tap1 manual value when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
-                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
-                                                         [DFE_C5_OVRD_VAL] are both set. Recommended settings: For the following modes:
+	uint64_t dfe_c3_mval                  : 4;  /**< DFE Tap3 manual value when GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c3_msgn                  : 1;  /**< DFE Tap3 manual sign when GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c2_mval                  : 4;  /**< DFE Tap2 manual value when GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c2_msgn                  : 1;  /**< DFE Tap2 manual sign when GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c1_mval                  : 4;  /**< DFE Tap1 manual value when GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_C5_OVRD_VAL] are both set.
+                                                         Recommended settings: For the following modes:
                                                          5G_REFCLK100, 5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that DFE_C1_MVAL
-                                                         be set to zero after setting GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM] and also after
-                                                         updating the GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2 register. In all other modes this
+                                                         be set to zero after setting GSER()_LANE_P()_MODE_1[VMA_MM] and also after
+                                                         updating the GSER()_LANE()_RX_VALBBD_CTRL_2 register. In all other modes this
                                                          register can be ignored. */
-	uint64_t dfe_c1_msgn                  : 1;  /**< DFE Tap1 manual sign when GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
-                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_2
-                                                         [DFE_C5_OVRD_VAL] are both set. */
+	uint64_t dfe_c1_msgn                  : 1;  /**< DFE Tap1 manual sign when GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_OVRD_EN] and
+                                                         GSER()_LANE()_RX_VALBBD_CTRL_2[DFE_C5_OVRD_VAL] are both set. */
 #else
 	uint64_t dfe_c1_msgn                  : 1;
 	uint64_t dfe_c1_mval                  : 4;
@@ -3849,30 +3916,30 @@ union cvmx_gserx_lanex_rx_valbbd_ctrl_2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_6_63                : 58;
 	uint64_t dfe_ovrd_en                  : 1;  /**< Override enable for DFE tap controls. When asserted, the register bits in
-                                                         GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_0 and GSER(0..13)_LANE(0..3)_RX_VALBBD_CTRL_1 are
+                                                         GSER()_LANE()_RX_VALBBD_CTRL_0 and GSER()_LANE()_RX_VALBBD_CTRL_1 are
                                                          used for controlling the DFE tap manual mode, instead the manual mode signal indexed by
-                                                         GSER(0..13)_LANE_MODE[LMODE]. Recommended settings: For the following modes: 5G_REFCLK100,
+                                                         GSER()_LANE_MODE[LMODE]. Recommended settings: For the following modes: 5G_REFCLK100,
                                                          5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that DFE tap controls be put in
                                                          manual mode by setting this bit. In all other modes this register can be ignored. */
 	uint64_t dfe_c5_ovrd_val              : 1;  /**< Override value for DFE Tap5 manual enable. Recommended settings: For the following modes;
                                                          5G_REFCLK100, 5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that the DFE Tap5
-                                                         manual enable be set after setting GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]. In all
+                                                         manual enable be set after setting GSER()_LANE_P()_MODE_1[VMA_MM]. In all
                                                          other modes this register can be ignored. */
 	uint64_t dfe_c4_ovrd_val              : 1;  /**< Override value for DFE Tap4 manual enable. Recommended settings: For the following modes:
                                                          5G_REFCLK100, 5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that the DFE Tap4
-                                                         manual enable be set after setting GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]. In all
+                                                         manual enable be set after setting GSER()_LANE_P()_MODE_1[VMA_MM]. In all
                                                          other modes this register can be ignored. */
 	uint64_t dfe_c3_ovrd_val              : 1;  /**< Override value for DFE Tap3 manual enable. Recommended settings: For the following modes;
                                                          5G_REFCLK100, 5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that the DFE Tap3
-                                                         manual enable be set after setting GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]. In all
+                                                         manual enable be set after setting GSER()_LANE_P()_MODE_1[VMA_MM]. In all
                                                          other modes this register can be ignored. */
 	uint64_t dfe_c2_ovrd_val              : 1;  /**< Override value for DFE Tap2 manual enable. Recommended settings: For the following modes;
                                                          5G_REFCLK100, 5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that the DFE Tap2
-                                                         manual enable be set after setting GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]. In all
+                                                         manual enable be set after setting GSER()_LANE_P()_MODE_1[VMA_MM]. In all
                                                          other modes this register can be ignored. */
 	uint64_t dfe_c1_ovrd_val              : 1;  /**< Override value for DFE Tap1 manual enable. Recommended settings: For the following modes;
                                                          5G_REFCLK100, 5G_REFCLK15625_QSGMII, and 5G_REFCLK125, it is recommended that the DFE Tap1
-                                                         manual enable be set after setting GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]. In all
+                                                         manual enable be set after setting GSER()_LANE_P()_MODE_1[VMA_MM]. In all
                                                          other modes this register can be ignored. */
 #else
 	uint64_t dfe_c1_ovrd_val              : 1;
@@ -3940,10 +4007,10 @@ union cvmx_gserx_lanex_rx_vma_status_0 {
 	struct cvmx_gserx_lanex_rx_vma_status_0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t sds_pcs_rx_vma_status        : 8;  /**< <8>: DFE Powerdown
-                                                         <7>: Reserved
-                                                         <6:2>: CTLE Peak
-                                                         <1:0>: CTLE Pole. */
+	uint64_t sds_pcs_rx_vma_status        : 8;  /**< <8> = DFE Powerdown.
+                                                         <7> = Reserved.
+                                                         <6:2> = CTLE Peak.
+                                                         <1:0> = CTLE Pole. */
 #else
 	uint64_t sds_pcs_rx_vma_status        : 8;
 	uint64_t reserved_8_63                : 56;
@@ -3965,7 +4032,7 @@ union cvmx_gserx_lanex_rx_vma_status_1 {
 	struct cvmx_gserx_lanex_rx_vma_status_1_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
-	uint64_t sds_pcs_rx_vma_status        : 16; /**< <15:8>: Output is controlled by GSERX_LANE(0..3)_RX_CFG_3[CFG_RX_ERRDET_CTRL[6:5]
+	uint64_t sds_pcs_rx_vma_status        : 16; /**< <15:8>: Output is controlled by GSER()_LANE()_RX_CFG_3[CFG_RX_ERRDET_CTRL[6:5]
                                                          0x0 = Pre-CTL gain, CTLE Peak.
                                                          0x1 = CTL pole, SDLL_IQ.
                                                          0x2 = Window counter[11:3].
@@ -4001,7 +4068,7 @@ union cvmx_gserx_lanex_tx_cfg_0 {
 	uint64_t tx_resetn_ovrd_val           : 1;  /**< TX P2S rest. */
 	uint64_t tx_cm_mode                   : 1;  /**< Assert to enable fast Common-Mode charge up. For simulation purposes only. */
 	uint64_t cfg_tx_swing                 : 5;  /**< TX output swing control.
-                                                         Default swing encoding when GSER(0..13)_LANE(0..3)_TX_CFG_1[TX_SWING_OVRRD_EN] is
+                                                         Default swing encoding when GSER()_LANE()_TX_CFG_1[TX_SWING_OVRRD_EN] is
                                                          asserted. */
 	uint64_t fast_rdet_mode               : 1;  /**< Assert to enable fast RX Detection. For simulation purposes only. */
 	uint64_t fast_tristate_mode           : 1;  /**< Assert to enable fast Tristate power up. For simulation purposes only. */
@@ -4128,11 +4195,11 @@ union cvmx_gserx_lanex_tx_cfg_3 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
 	uint64_t cfg_tx_vboost_en             : 1;  /**< Specifies the value of TX VBoost enable when
-                                                         GSER(0..13)_LANE(0..3)_TX_CFG_1[TX_VBOOST_EN_OVRRD_EN] is asserted. */
+                                                         GSER()_LANE()_TX_CFG_1[TX_VBOOST_EN_OVRRD_EN] is asserted. */
 	uint64_t reserved_7_13                : 7;
 	uint64_t pcs_sds_tx_gain              : 3;  /**< TX Gain. For debug use only. */
 	uint64_t pcs_sds_tx_srate_sel         : 3;  /**< Reserved. */
-	uint64_t cfg_tx_turbo_en              : 1;  /**< Specifies value ot TX turbo enable when GSER(0..13)_LANE(0..3)_TX_CFG_1[TX_TURBO_EN] is set. */
+	uint64_t cfg_tx_turbo_en              : 1;  /**< Specifies value ot TX turbo enable when GSER()_LANE()_TX_CFG_1[TX_TURBO_EN] is set. */
 #else
 	uint64_t cfg_tx_turbo_en              : 1;
 	uint64_t pcs_sds_tx_srate_sel         : 3;
@@ -4159,7 +4226,7 @@ union cvmx_gserx_lanex_tx_pre_emphasis {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t cfg_tx_premptap              : 9;  /**< Override preemphasis control. Applies when
-                                                         GSER(0..13)_LANE(0..3)_TX_CFG_3[TX_PREMPTAP_OVRD_EN] is asserted.
+                                                         GSER()_LANE()_TX_CFG_3[TX_PREMPTAP_OVRD_EN] is asserted.
                                                          <8:4> = Post-cursor.
                                                          <3:0> = Pre-cursor. */
 #else
@@ -4211,38 +4278,38 @@ union cvmx_gserx_lane_mode {
 	uint64_t lmode                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), used to index into the PHY
                                                          table to select electrical specs and link rate. Note that the PHY table can be modified
                                                          such that any supported link rate can be derived regardless of the configured LMODE.
-                                                         0x0: R_25G_REFCLK100
-                                                         0x1: R_5G_REFCLK100
-                                                         0x2: R_8G_REFCLK100
-                                                         0x3: R_125G_REFCLK15625_KX (not supported)
-                                                         0x4: R_3125G_REFCLK15625_XAUI
-                                                         For XAUI applications.
-                                                         0x5: R_103125G_REFCLK15625_KR
-                                                         For XFI, XLAUI, KR applications.
-                                                         0x6: R_125G_REFCLK15625_SGMII
-                                                         For SGMII applications.
-                                                         0x7: R_5G_REFCLK15625_QSGMII (not supported)
-                                                         0x8: R_625G_REFCLK15625_RXAUI
-                                                         For RXAUI, DXAUI applications.
-                                                         0x9: R_25G_REFCLK125
-                                                         0xA: R_5G_REFCLK125
-                                                         0xB: R_8G_REFCLK125
-                                                         0xC - 0xF: reserved
+                                                         0x0: R_25G_REFCLK100.
+                                                         0x1: R_5G_REFCLK100.
+                                                         0x2: R_8G_REFCLK100.
+                                                         0x3: R_125G_REFCLK15625_KX (not supported).
+                                                         0x4: R_3125G_REFCLK15625_XAUI.
+                                                         For XAUI applications:
+                                                         0x5: R_103125G_REFCLK15625_KR.
+                                                         For XFI, XLAUI, KR applications:
+                                                         0x6: R_125G_REFCLK15625_SGMII.
+                                                         For SGMII applications:
+                                                         0x7: R_5G_REFCLK15625_QSGMII (not supported).
+                                                         0x8: R_625G_REFCLK15625_RXAUI.
+                                                         For RXAUI, DXAUI applications:
+                                                         0x9: R_25G_REFCLK125.
+                                                         0xA: R_5G_REFCLK125.
+                                                         0xB: R_8G_REFCLK125.
+                                                         0xC - 0xF: Reserved.
                                                          This register is not used for PCIE configurations. For non-OCI links, this register
                                                          defaults to R_625G_REFCLK15625_RXAUI. For OCI links, the value is mapped at reset from the
-                                                         GSER_SPD and the appropriate table updates are performed so the rate is obtained for the
+                                                         GSER()_SPD and the appropriate table updates are performed so the rate is obtained for the
                                                          particular reference clock.
                                                          It is recommended that the PHY be in reset when reconfiguring the LMODE
-                                                         (GSER(0..13)_PHY_CTL[PHY_RESET] is set).
+                                                         (GSER()_PHY_CTL[PHY_RESET] is set).
                                                          Once the LMODE has been configured, and the PHY is out of reset, the table entries for the
                                                          selected LMODE must be updated to reflect the reference clock speed. Refer to the register
                                                          description and index into the table using the rate and reference speed to obtain the
                                                          recommended values.
-                                                         Write GSER(0..13)_PLL_P(Z)_MODE_0.
-                                                         Write GSER(0..13)_PLL_P(Z)_MODE_1.
-                                                         Write GSER(0..13)_LANE_P(Z)_MODE_0.
-                                                         Write GSER(0..13)_LANE_P(Z)_MODE_1.
-                                                         where Z equals LMODE. */
+                                                         _ Write GSER()_PLL_P()_MODE_0.
+                                                         _ Write GSER()_PLL_P()_MODE_1.
+                                                         _ Write GSER()_LANE_P()_MODE_0.
+                                                         _ Write GSER()_LANE_P()_MODE_1.
+                                                         where in "P(z)", z equals LMODE. */
 #else
 	uint64_t lmode                        : 4;
 	uint64_t reserved_4_63                : 60;
@@ -4256,8 +4323,8 @@ typedef union cvmx_gserx_lane_mode cvmx_gserx_lane_mode_t;
  * cvmx_gser#_lane_p#_mode_0
  *
  * These are the RAW PCS lane settings mode 0 registers. There is one register per
- * 4 lanes per GSER per GSER_LMODE_E (0..11). Only one entry is used at any given time in a
- * given GSER lane - the one selected by the corresponding GSER(0..13)_LANE_MODE[LMODE].
+ * 4 lanes per GSER per GSER_LMODE_E value (0..11). Only one entry is used at any given time in a
+ * given GSER lane - the one selected by the corresponding GSER()_LANE_MODE[LMODE].
  * These registers are only reset by hardware during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
@@ -4272,70 +4339,70 @@ union cvmx_gserx_lane_px_mode_0 {
                                                          0x2 = ~15dB of peaking at 5.5 GHz
                                                          0x3 = ~20dB of peaking at 6 GHz (Maximum bandwidth).
                                                          Recommended settings:
-                                                         R_25G_REFCLK100:          0x0
-                                                         R_5G_REFCLK100:           0x0
-                                                         R_8G_REFCLK100:           0x3
-                                                         R_125G_REFCLK15625_KX:    0x0
-                                                         R_3125G_REFCLK15625_XAUI: 0x0
-                                                         R_103125G_REFCLK15625_KR: 0x3
-                                                         R_125G_REFCLK15625_SGMII: 0x0
-                                                         R_5G_REFCLK15625_QSGMII:  0x0
-                                                         R_625G_REFCLK15625_RXAUI: 0x0
-                                                         R_25G_REFCLK125:          0x0
-                                                         R_5G_REFCLK125:           0x0
-                                                         R_8G_REFCLK125:           0x3 */
+                                                         _ R_25G_REFCLK100:          0x0
+                                                         _ R_5G_REFCLK100:           0x0
+                                                         _ R_8G_REFCLK100:           0x3
+                                                         _ R_125G_REFCLK15625_KX:    0x0
+                                                         _ R_3125G_REFCLK15625_XAUI: 0x0
+                                                         _ R_103125G_REFCLK15625_KR: 0x3
+                                                         _ R_125G_REFCLK15625_SGMII: 0x0
+                                                         _ R_5G_REFCLK15625_QSGMII:  0x0
+                                                         _ R_625G_REFCLK15625_RXAUI: 0x0
+                                                         _ R_25G_REFCLK125:          0x0
+                                                         _ R_5G_REFCLK125:           0x0
+                                                         _ R_8G_REFCLK125:           0x3 */
 	uint64_t pcie                         : 1;  /**< Selects between RX terminations.
                                                          - 0: Differential termination
                                                          - 1: Termination between pad and SDS_VDDS.
                                                           Recommended settings:
-                                                          R_25G_REFCLK100:          0x1
-                                                          R_5G_REFCLK100:           0x1
-                                                          R_8G_REFCLK100:           0x0
-                                                          R_125G_REFCLK15625_KX:    0x0
-                                                          R_3125G_REFCLK15625_XAUI: 0x0
-                                                          R_103125G_REFCLK15625_KR: 0x0
-                                                          R_125G_REFCLK15625_SGMII: 0x0
-                                                          R_5G_REFCLK15625_QSGMII:  0x0
-                                                          R_625G_REFCLK15625_RXAUI: 0x0
-                                                          R_25G_REFCLK125:          0x1
-                                                          R_5G_REFCLK125:           0x1
-                                                          R_8G_REFCLK125:           0x0 */
+                                                          _ R_25G_REFCLK100:          0x1
+                                                          _ R_5G_REFCLK100:           0x1
+                                                          _ R_8G_REFCLK100:           0x0
+                                                          _ R_125G_REFCLK15625_KX:    0x0
+                                                          _ R_3125G_REFCLK15625_XAUI: 0x0
+                                                          _ R_103125G_REFCLK15625_KR: 0x0
+                                                          _ R_125G_REFCLK15625_SGMII: 0x0
+                                                          _ R_5G_REFCLK15625_QSGMII:  0x0
+                                                          _ R_625G_REFCLK15625_RXAUI: 0x0
+                                                          _ R_25G_REFCLK125:          0x1
+                                                          _ R_5G_REFCLK125:           0x1
+                                                          _ R_8G_REFCLK125:           0x0 */
 	uint64_t tx_ldiv                      : 2;  /**< Configures clock divider used to determine the receive rate.
                                                          0x0 = full data rate.
                                                          0x1 = 1/2 data rate.
                                                          0x2 = 1/4 data rate.
                                                          0x3 = 1/8 data rate.
                                                          Recommended settings:
-                                                         R_25G_REFCLK100:          0x1
-                                                         R_5G_REFCLK100:           0x0
-                                                         R_8G_REFCLK100:           0x0
-                                                         R_125G_REFCLK15625_KX:    0x2
-                                                         R_3125G_REFCLK15625_XAUI: 0x1
-                                                         R_103125G_REFCLK15625_KR: 0x0
-                                                         R_125G_REFCLK15625_SGMII: 0x2
-                                                         R_5G_REFCLK15625_QSGMII:  0x0
-                                                         R_625G_REFCLK15625_RXAUI: 0x0
-                                                         R_25G_REFCLK125:          0x1
-                                                         R_5G_REFCLK125:           0x0
-                                                         R_8G_REFCLK125:           0x0 */
+                                                         _ R_25G_REFCLK100:          0x1
+                                                         _ R_5G_REFCLK100:           0x0
+                                                         _ R_8G_REFCLK100:           0x0
+                                                         _ R_125G_REFCLK15625_KX:    0x2
+                                                         _ R_3125G_REFCLK15625_XAUI: 0x1
+                                                         _ R_103125G_REFCLK15625_KR: 0x0
+                                                         _ R_125G_REFCLK15625_SGMII: 0x2
+                                                         _ R_5G_REFCLK15625_QSGMII:  0x0
+                                                         _ R_625G_REFCLK15625_RXAUI: 0x0
+                                                         _ R_25G_REFCLK125:          0x1
+                                                         _ R_5G_REFCLK125:           0x0
+                                                         _ R_8G_REFCLK125:           0x0 */
 	uint64_t rx_ldiv                      : 2;  /**< Configures clock divider used to determine the receive rate.
                                                          0x0 = full data rate
                                                          0x1 = 1/2 data rate
                                                          0x2 = 1/4 data rate
                                                          0x3 = 1/8 data rate
                                                          Recommended settings:
-                                                         R_25G_REFCLK100:          0x1
-                                                         R_5G_REFCLK100:           0x0
-                                                         R_8G_REFCLK100:           0x0
-                                                         R_125G_REFCLK15625_KX:    0x2
-                                                         R_3125G_REFCLK15625_XAUI: 0x1
-                                                         R_103125G_REFCLK15625_KR: 0x0
-                                                         R_125G_REFCLK15625_SGMII: 0x2
-                                                         R_5G_REFCLK15625_QSGMII:  0x0
-                                                         R_625G_REFCLK15625_RXAUI: 0x0
-                                                         R_25G_REFCLK125:          0x1
-                                                         R_5G_REFCLK125:           0x0
-                                                         R_8G_REFCLK125:           0x0 */
+                                                         _ R_25G_REFCLK100:          0x1
+                                                         _ R_5G_REFCLK100:           0x0
+                                                         _ R_8G_REFCLK100:           0x0
+                                                         _ R_125G_REFCLK15625_KX:    0x2
+                                                         _ R_3125G_REFCLK15625_XAUI: 0x1
+                                                         _ R_103125G_REFCLK15625_KR: 0x0
+                                                         _ R_125G_REFCLK15625_SGMII: 0x2
+                                                         _ R_5G_REFCLK15625_QSGMII:  0x0
+                                                         _ R_625G_REFCLK15625_RXAUI: 0x0
+                                                         _ R_25G_REFCLK125:          0x1
+                                                         _ R_5G_REFCLK125:           0x0
+                                                         _ R_8G_REFCLK125:           0x0 */
 	uint64_t srate                        : 3;  /**< Sample rate, used to generate strobe to effectively divide the clock down to a slower
                                                          rate.
                                                          0x0 = Full rate
@@ -4376,8 +4443,9 @@ typedef union cvmx_gserx_lane_px_mode_0 cvmx_gserx_lane_px_mode_0_t;
  * cvmx_gser#_lane_p#_mode_1
  *
  * These are the RAW PCS lane settings mode 1 registers. There is one register per 4 lanes,
- * (0..3) per GSER per GSER_LMODE_E (0..11). Only one entry is used at any given time in a given
- * GSER lane - the one selected by the corresponding GSER(0..13)_LANE_MODE[LMODE].
+ * (0..3) per GSER per GSER_LMODE_E value (0..11). Only one entry is used at any given time in a
+ * given
+ * GSER lane - the one selected by the corresponding GSER()_LANE_MODE[LMODE].
  * These registers are only reset by hardware during chip cold reset.
  * The values of the CSR fields in these registers do not change during chip warm or soft resets.
  */
@@ -4394,32 +4462,32 @@ union cvmx_gserx_lane_px_mode_1 {
                                                          1 = Manual DFE, fixed tap (3.125 Gbaud and lower). */
 	uint64_t cdr_fgain                    : 4;  /**< CDR frequency gain.
                                                          Recommended settings:
-                                                         R_25G_REFCLK100:          0xA
-                                                         R_5G_REFCLK100:           0xA
-                                                         R_8G_REFCLK100:           0xB
-                                                         R_125G_REFCLK15625_KX:    0xC
-                                                         R_3125G_REFCLK15625_XAUI: 0xC
-                                                         R_103125G_REFCLK15625_KR: 0xA
-                                                         R_125G_REFCLK15625_SGMII: 0xC
-                                                         R_5G_REFCLK15625_QSGMII:  0xC
-                                                         R_625G_REFCLK15625_RXAUI: 0xA
-                                                         R_25G_REFCLK125:          0xA
-                                                         R_5G_REFCLK125:           0xA
-                                                         R_8G_REFCLK125:           0xB */
+                                                         _ R_25G_REFCLK100:          0xA
+                                                         _ R_5G_REFCLK100:           0xA
+                                                         _ R_8G_REFCLK100:           0xB
+                                                         _ R_125G_REFCLK15625_KX:    0xC
+                                                         _ R_3125G_REFCLK15625_XAUI: 0xC
+                                                         _ R_103125G_REFCLK15625_KR: 0xA
+                                                         _ R_125G_REFCLK15625_SGMII: 0xC
+                                                         _ R_5G_REFCLK15625_QSGMII:  0xC
+                                                         _ R_625G_REFCLK15625_RXAUI: 0xA
+                                                         _ R_25G_REFCLK125:          0xA
+                                                         _ R_5G_REFCLK125:           0xA
+                                                         _ R_8G_REFCLK125:           0xB */
 	uint64_t ph_acc_adj                   : 10; /**< Phase accumulator adjust.
                                                          Recommended settings:
-                                                         R_25G_REFCLK100:          0x14
-                                                         R_5G_REFCLK100:           0x14
-                                                         R_8G_REFCLK100:           0x23
-                                                         R_125G_REFCLK15625_KX:    0x1E
-                                                         R_3125G_REFCLK15625_XAUI: 0x1E
-                                                         R_103125G_REFCLK15625_KR: 0xF
-                                                         R_125G_REFCLK15625_SGMII: 0x1E
-                                                         R_5G_REFCLK15625_QSGMII:  0x1E
-                                                         R_625G_REFCLK15625_RXAUI: 0x14
-                                                         R_25G_REFCLK125:          0x14
-                                                         R_5G_REFCLK125:           0x14
-                                                         R_8G_REFCLK125:           0x23 */
+                                                         _ R_25G_REFCLK100:          0x14
+                                                         _ R_5G_REFCLK100:           0x14
+                                                         _ R_8G_REFCLK100:           0x23
+                                                         _ R_125G_REFCLK15625_KX:    0x1E
+                                                         _ R_3125G_REFCLK15625_XAUI: 0x1E
+                                                         _ R_103125G_REFCLK15625_KR: 0xF
+                                                         _ R_125G_REFCLK15625_SGMII: 0x1E
+                                                         _ R_5G_REFCLK15625_QSGMII:  0x1E
+                                                         _ R_625G_REFCLK15625_RXAUI: 0x14
+                                                         _ R_25G_REFCLK125:          0x14
+                                                         _ R_5G_REFCLK125:           0x14
+                                                         _ R_8G_REFCLK125:           0x23 */
 #else
 	uint64_t ph_acc_adj                   : 10;
 	uint64_t cdr_fgain                    : 4;
@@ -4579,21 +4647,20 @@ union cvmx_gserx_lane_vma_fine_ctrl_0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t rx_sdll_iq_max_fine          : 4;  /**< RX Slice DLL IQ maximum value in VMA Fine mode (valid when
-                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_FINE_CFG_SEL]=1 and
-                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+                                                         GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and
+                                                         GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
 	uint64_t rx_sdll_iq_min_fine          : 4;  /**< RX slice DLL IQ minimum value in VMA fine mode (valid when
-                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_FINE_CFG_SEL]=1 and
-                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+                                                         GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and
+                                                         GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
 	uint64_t rx_sdll_iq_step_fine         : 2;  /**< RX Slice DLL IQ step size in VMA Fine mode (valid when
-                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_FINE_CFG_SEL]=1 and
-                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+                                                         GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and
+                                                         GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
 	uint64_t vma_window_wait_fine         : 3;  /**< Adaptation window wait setting (in VMA fine mode); used to control the number of samples
                                                          taken during the collection of statistics (valid when
-                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
-                                                         [VMA_FINE_CFG_SEL]=1 and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+                                                         GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
 	uint64_t lms_wait_time_fine           : 3;  /**< LMS wait time setting (in VMA fine mode); used to control the number of samples taken
-                                                         during the collection of statistics (valid when GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
-                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+                                                         during the collection of statistics (valid when
+                                                         GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
 #else
 	uint64_t lms_wait_time_fine           : 3;
 	uint64_t vma_window_wait_fine         : 3;
@@ -4620,13 +4687,11 @@ union cvmx_gserx_lane_vma_fine_ctrl_1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t rx_ctle_peak_max_fine        : 4;  /**< RX CTLE peak maximum value in VMA fine mode (valid when
-                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
-                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+                                                         GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
 	uint64_t rx_ctle_peak_min_fine        : 4;  /**< RX CTLE peak minimum value in VMA fine mode (valid when
-                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
-                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
-	uint64_t rx_ctle_peak_step_fine       : 2;  /**< RX CTLE Peak step size in VMA Fine mode (valid when GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
-                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+                                                         GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
+	uint64_t rx_ctle_peak_step_fine       : 2;  /**< RX CTLE Peak step size in VMA Fine mode (valid when
+                                                         GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
 #else
 	uint64_t rx_ctle_peak_step_fine       : 2;
 	uint64_t rx_ctle_peak_min_fine        : 4;
@@ -4651,14 +4716,11 @@ union cvmx_gserx_lane_vma_fine_ctrl_2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t rx_prectle_peak_max_fine     : 4;  /**< RX PRE-CTLE peak maximum value in VMA fine mode (valid when
-                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
-                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+                                                         GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
 	uint64_t rx_prectle_peak_min_fine     : 4;  /**< RX PRE-CTLE peak minimum value in VMA fine mode (valid when
-                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
-                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+                                                         GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
 	uint64_t rx_prectle_peak_step_fine    : 2;  /**< RX PRE-CTLE peak step size in VMA fine mode (valid when
-                                                         GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1
-                                                         [VMA_FINE_CFG_SEL=1] and GSER(0..13)_LANE(0..3)_P(0..11)_MODE_1[VMA_MM]=0). */
+                                                         GSER()_LANE_P()_MODE_1[VMA_FINE_CFG_SEL]=1 and GSER()_LANE_P()_MODE_1[VMA_MM]=0). */
 #else
 	uint64_t rx_prectle_peak_step_fine    : 2;
 	uint64_t rx_prectle_peak_min_fine     : 4;
@@ -5799,9 +5861,9 @@ union cvmx_gserx_phy_ctl {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
 	uint64_t phy_reset                    : 1;  /**< When asserted, the PHY is held in reset. This bit is initialized as follows:
-                                                         0 (not reset): Bootable PCIe, or OCI when GSER(8..13)_SPD[SPD] comes up in a bootable
+                                                         0 = (not reset) = Bootable PCIe, or OCI when GSER(8..13)_SPD[SPD] comes up in a bootable
                                                          mode.
-                                                         1 (reset): Non-bootable PCIe, BGX/ILK, or OCI when GSER(8..13)_SPD[SPD] comes up in
+                                                         1 = (reset) =  Non-bootable PCIe, BGX/ILK, or OCI when GSER(8..13)_SPD[SPD] comes up in
                                                          SW_MODE. */
 	uint64_t phy_pd                       : 1;  /**< When asserted, the PHY is powered down. */
 #else
@@ -5837,9 +5899,9 @@ typedef union cvmx_gserx_pipe_lpbk cvmx_gserx_pipe_lpbk_t;
 /**
  * cvmx_gser#_pll_p#_mode_0
  *
- * These are the RAW PCS PLL global settings mode 0 registers.There is one register per GSER per
- * GSER_LMODE_E(0..11). Only one entry is used at any given time in a given GSER - the one
- * selected by the corresponding GSER(0..13)_LANE_MODE[LMODE].
+ * These are the RAW PCS PLL global settings mode 0 registers. There is one register per GSER per
+ * GSER_LMODE_E value (0..11). Only one entry is used at any given time in a given GSER - the one
+ * selected by the corresponding GSER()_LANE_MODE[LMODE].
  * These registers are only reset by hardware during chip cold reset.
  * The values of the CSR fields in these registers do not change during subsequent chip warm or
  * soft resets.
@@ -5851,6 +5913,7 @@ union cvmx_gserx_pll_px_mode_0 {
 	uint64_t reserved_16_63               : 48;
 	uint64_t pll_icp                      : 4;  /**< PLL charge pump enable.
                                                          Recommended settings, which are based on the reference clock speed:
+                                                         <pre>
                                                                   100MHz 125MHz 156.25MHz
                                                          1.25G:    0x1    0x1    0x1
                                                          2.5G:     0x4    0x3    0x3
@@ -5859,26 +5922,27 @@ union cvmx_gserx_pll_px_mode_0 {
                                                          6.25G:    NS     0x1    0x1
                                                          8.0G:     0x3    0x2    NS
                                                          10.3125G: NS     NS     0x1
+                                                         </pre>
                                                          A 'NS' indicates that the rate is not supported at the specified reference clock. */
 	uint64_t pll_rloop                    : 3;  /**< Loop resistor tuning.
                                                          Recommended settings:
-                                                         1.25G:    0x3
-                                                         2.5G:     0x3
-                                                         3.125G:   0x3
-                                                         5.0G:     0x3
-                                                         6.25G:    0x3
-                                                         8.0G:     0x5
-                                                         10.3125G: 0x5 */
+                                                         _ 1.25G:    0x3
+                                                         _ 2.5G:     0x3
+                                                         _ 3.125G:   0x3
+                                                         _ 5.0G:     0x3
+                                                         _ 6.25G:    0x3
+                                                         _ 8.0G:     0x5
+                                                         _ 10.3125G: 0x5 */
 	uint64_t pll_pcs_div                  : 9;  /**< The divider that generates PCS_MAC_TX_CLK. The frequency of the clock is (pll_frequency /
                                                          PLL_PCS_DIV).
                                                          Recommended settings:
-                                                         1.25G:    0x28
-                                                         2.5G:     0x5
-                                                         3.125G:   0x14
-                                                         5.0G:     0xA
-                                                         6.25G:    0xA
-                                                         8.0G:     0xA
-                                                         10.3125G: 0xA */
+                                                         _ 1.25G:    0x28
+                                                         _ 2.5G:     0x5
+                                                         _ 3.125G:   0x14
+                                                         _ 5.0G:     0xA
+                                                         _ 6.25G:    0xA
+                                                         _ 8.0G:     0xA
+                                                         _ 10.3125G: 0xA */
 #else
 	uint64_t pll_pcs_div                  : 9;
 	uint64_t pll_rloop                    : 3;
@@ -5894,8 +5958,8 @@ typedef union cvmx_gserx_pll_px_mode_0 cvmx_gserx_pll_px_mode_0_t;
  * cvmx_gser#_pll_p#_mode_1
  *
  * These are the RAW PCS PLL global settings mode 1 registers. There is one register per GSER per
- * GSER_LMODE_E(0..11). Only one entry is used at any given time in a given GSER - the one
- * selected by the corresponding GSER(0..13)_LANE_MODE[LMODE].
+ * GSER_LMODE_E value (0..11). Only one entry is used at any given time in a given GSER - the one
+ * selected by the corresponding GSER()_LANE_MODE[LMODE].
  * These registers are only reset by hardware during chip cold reset.
  * The values of the CSR fields in this register do not change during subsequent chip warm or
  * soft resets.
@@ -5907,6 +5971,7 @@ union cvmx_gserx_pll_px_mode_1 {
 	uint64_t reserved_14_63               : 50;
 	uint64_t pll_16p5en                   : 1;  /**< Enable for the DIV 16.5 divided down clock.
                                                          Recommended settings, based on the reference clock speed:
+                                                         <pre>
                                                                   100MHz 125MHz 156.25MHz
                                                          1.25G:    0x1    0x1     0x1
                                                          2.5G:     0x0    0x0     0x0
@@ -5915,9 +5980,11 @@ union cvmx_gserx_pll_px_mode_1 {
                                                          6.25G:    NS     0x0     0x0
                                                          8.0G:     0x0    0x0     NS
                                                          10.3125G: NS     NS      0x1
+                                                         </pre>
                                                          A 'NS' indicates that the rate is not supported at the specified reference clock. */
 	uint64_t pll_cpadj                    : 2;  /**< PLL charge adjust.
                                                          Recommended settings, based on the reference clock speed:
+                                                         <pre>
                                                                    100MHz 125MHz 156.25MHz
                                                          1.25G:     0x2     0x2    0x3
                                                          2.5G:      0x2     0x1    0x2
@@ -5926,6 +5993,7 @@ union cvmx_gserx_pll_px_mode_1 {
                                                          6.25G:     NS      0x2    0x2
                                                          8.0G:      0x2     0x1    NS
                                                          10.3125G:  NS      NS     0x2
+                                                         </pre>
                                                          A 'NS' indicates that the rate is not supported at the specified reference clock. */
 	uint64_t pll_pcie3en                  : 1;  /**< Enable PCIE3 mode. Recommended settings:
                                                          0 = Any rate other than 8 Gbaud.
@@ -5935,6 +6003,7 @@ union cvmx_gserx_pll_px_mode_1 {
                                                          1 = Use LC-tank VCO. Recommended for rates 8 Gbaud and higher. */
 	uint64_t pll_div                      : 9;  /**< PLL divider in feedback path which sets the PLL frequency.
                                                          Recommended settings:
+                                                         <pre>
                                                                   100MHz 125MHz 156.25MHz
                                                          1.25G:    0x19   0x14    0x10
                                                          2.5G:     0x19   0x14    0x10
@@ -5943,6 +6012,7 @@ union cvmx_gserx_pll_px_mode_1 {
                                                          6.25G:    NS     0x19    0x14
                                                          8.0G:     0x28   0x20    NS
                                                          10.3125G: NS     NS      0x21
+                                                         </pre>
                                                          A 'NS' indicates that the rate is not supported at the specified reference clock. */
 #else
 	uint64_t pll_div                      : 9;
@@ -5983,7 +6053,7 @@ union cvmx_gserx_qlm_stat {
 	struct cvmx_gserx_qlm_stat_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t rst_rdy                      : 1;  /**< When asserted, the QLM is configured (CSR_GSER_CAV_CFG) and the PLLs are stable. The GSER
+	uint64_t rst_rdy                      : 1;  /**< When asserted, the QLM is configured and the PLLs are stable. The GSER
                                                          is ready to accept TX traffic from the MAC. */
 	uint64_t dcok                         : 1;  /**< When asserted, there is a PLL reference clock indicating there is power to the QLM. */
 #else
@@ -6070,7 +6140,7 @@ union cvmx_gserx_rx_coast {
 	uint64_t coast                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), control signals to freeze
                                                          the frequency of the per lane CDR in the PHY. The COAST signals are only valid in P0
                                                          state, come up asserted and are deasserted in hardware after detecting the electrical idle
-                                                         exit (GSER(0..13)_RX_EIE_DETSTS[EIESTS]). Once the COAST signal deasserts, the CDR is
+                                                         exit (GSER()_RX_EIE_DETSTS[EIESTS]). Once the COAST signal deasserts, the CDR is
                                                          allowed to lock. In BGX mode, the BGX MAC can also control the COAST inputs to the PHY to
                                                          allow Auto-Negotiation for backplane Ethernet. For diagnostic use only.
                                                          <3>: Lane 3.
@@ -6099,7 +6169,7 @@ union cvmx_gserx_rx_eie_deten {
 	uint64_t reserved_4_63                : 60;
 	uint64_t eiede                        : 4;  /**< For links that are not in PCIE mode (including all OCI links), these bits enable per lane
                                                          electrical idle exit (EIE) detection. When EIE is detected,
-                                                         GSER(0..13)_RX_EIE_DETSTS[EIELTCH] is asserted. EIEDE defaults to the enabled state. Once
+                                                         GSER()_RX_EIE_DETSTS[EIELTCH] is asserted. EIEDE defaults to the enabled state. Once
                                                          EIE has been detected, EIEDE must be disabled, and then enabled again to perform another
                                                          EIE detection.
                                                          <3>: Lane 3.
@@ -6131,20 +6201,21 @@ union cvmx_gserx_rx_eie_detsts {
                                                          <10>: Lane 2.
                                                          <9>: Lane 1.
                                                          <8>: Lane 0. */
-	uint64_t eiests                       : 4;  /**< When electrical idle exit detection is enabled (GSER(0..13)_RX_EIE_DETEN[EIEDE] is
+	uint64_t eiests                       : 4;  /**< When electrical idle exit detection is enabled (GSER()_RX_EIE_DETEN[EIEDE] is
                                                          asserted), indicates that an electrical idle exit condition (EIE) was detected. For higher
                                                          data rates, the received data needs to have sufficient low frequency content (for example,
                                                          idle symbols) for data transitions to be detected and for EIESTS to stay set accordingly.
                                                          Under most conditions, EIESTS
-                                                         will stay asserted until GSER(0..13)_RX_EIE_DETEN[EIEDE] is deasserted.
+                                                         will stay asserted until GSER()_RX_EIE_DETEN[EIEDE] is deasserted.
                                                          <7>: Lane 3.
                                                          <6>: Lane 2.
                                                          <5>: Lane 1.
                                                          <4>: Lane 0. */
-	uint64_t eieltch                      : 4;  /**< When electrical idle exit detection is enabled (GSER(0..13)_RX_EIE_DETEN[EIEDE] is
+	uint64_t eieltch                      : 4;  /**< When electrical idle exit detection is enabled (GSER()_RX_EIE_DETEN[EIEDE] is
                                                          asserted), indicates that an electrical idle exit condition (EIE) was detected. Once an
                                                          EIE condition has been detected, the per-lane EIELTCH will stay set until
-                                                         GSER_RX_EIE_DETEN.EIEDE is deasserted. Note that there may be RX bit errors until CDRLOCK
+                                                         GSER()_RX_EIE_DETEN[EIEDE] is deasserted. Note that there may be RX bit errors until
+                                                         CDRLOCK
                                                          is set.
                                                          <3>: Lane 3.
                                                          <2>: Lane 2.
@@ -6173,14 +6244,14 @@ union cvmx_gserx_rx_eie_filter {
                                                          electrical idle (EI). The PHY electrical idle exit detection supports a minimum pulse
                                                          width of 400ps, therefore configurations that run faster than 2.5G can indicate EI when
                                                          the serial lines are still driven. For rates faster than 2.5G, it takes 16K * 8 UI of
-                                                         consecutive deasserted GSER(0..13)_RX_EIE_DETSTS[EIESTS] for the GSER to infer EI. In the
+                                                         consecutive deasserted GSER()_RX_EIE_DETSTS[EIESTS] for the GSER to infer EI. In the
                                                          event of electrical idle inference, the following happens:
-                                                         * GSER(0..13)_RX_EIE_DETSTS[CDRLOCK]<lane> is zeroed
-                                                         * GSER(0..13)_RX_EIE_DETSTS[EIELTCH]<lane> is zeroed
-                                                         * GSER(0..13)_RX_EIE_DETSTS[EIESTS]<lane> is zeroed
-                                                         * GSER(0..13)_RX_COAST[COAST]<lane> is asserted to prevent the CDR from trying to lock on
+                                                         * GSER()_RX_EIE_DETSTS[CDRLOCK]<lane> is zeroed.
+                                                         * GSER()_RX_EIE_DETSTS[EIELTCH]<lane> is zeroed.
+                                                         * GSER()_RX_EIE_DETSTS[EIESTS]<lane> is zeroed.
+                                                         * GSER()_RX_COAST[COAST]<lane> is asserted to prevent the CDR from trying to lock on
                                                          the incoming data stream.
-                                                         * GSER(0..13)_RX_EIE_DETEN[EIEDE]<lane> deasserts for a short period of time, and then is
+                                                         * GSER()_RX_EIE_DETEN[EIEDE]<lane> deasserts for a short period of time, and then is
                                                          asserted to begin looking for the Electrical idle Exit condition.
                                                          Writing this register to a non-zero value causes the electrical idle inference to use the
                                                          EII_FILT count instead of the default settings. Each EII_FILT count represents 20 ns of
@@ -6615,37 +6686,39 @@ union cvmx_gserx_spd {
                                                          pins during chip cold reset. For non-OCI links, this field is not used.
                                                          For SPD settings that configure a non-default reference clock, hardware updates the PLL
                                                          settings of the specific lane mode (LMODE) table entry to derive the correct link rate.
-                                                         SPD     REFCLK     Link rate      LMODE
-                                                         0x0:    100 MHz    1.25 Gbaud     R_125G_REFCLK15625_KX
-                                                         0x1:    100 MHz    2.5 Gbaud      R_25G_REFCLK100
-                                                         0x2:    100 MHz    5 Gbaud        R_5G_REFCLK100
-                                                         0x3:    100 MHz    8 Gbaud        R_8G_REFCLK100
-                                                         0x4:    125 MHz    1.25 Gbaud     R_125G_REFCLK15625_KX
-                                                         0x5:    125 MHz    2.5 Gbaud      R_25G_REFCLK125
-                                                         0x6:    125 MHz    3.125 Gbaud    R_3125G_REFCLK15625_XAUI
-                                                         0x7:    125 MHz    5 Gbaud        R_5G_REFCLK125
-                                                         0x8:    125 MHz    6.25 Gbaud     R_625G_REFCLK15625_RXAUI
-                                                         0x9:    125 MHz    8 Gbaud        R_8G_REFCLK125
-                                                         0xA:    156.25 MHz 2.5 Gbaud      R_25G_REFCLK100
-                                                         0xB:    156.25 MHz 3.125 Gbaud    R_3125G_REFCLK15625_XAUI
-                                                         0xC:    156.25 MHz 5 Gbaud        R_5G_REFCLK125
-                                                         0xD:    156.25 MHz 6.25 Gbaud     R_625G_REFCLK15625_RXAUI
-                                                         0xE:    156.25 MHz 10.3125 Gbaud  R_103125G_REFCLK15625_KR
-                                                         0xF:               SW_MODE
+                                                         <pre>
+                                                         SPD   REFCLK      Link rate   LMODE
+                                                         0x0:  100 MHz     1.25 Gb     R_125G_REFCLK15625_KX
+                                                         0x1:  100 MHz     2.5 Gb      R_25G_REFCLK100
+                                                         0x2:  100 MHz     5 Gb        R_5G_REFCLK100
+                                                         0x3:  100 MHz     8 Gb        R_8G_REFCLK100
+                                                         0x4:  125 MHz     1.25 Gb     R_125G_REFCLK15625_KX
+                                                         0x5:  125 MHz     2.5 Gb      R_25G_REFCLK125
+                                                         0x6:  125 MHz     3.125 Gb    R_3125G_REFCLK15625_XAUI
+                                                         0x7:  125 MHz     5 Gb        R_5G_REFCLK125
+                                                         0x8:  125 MHz     6.25 Gb     R_625G_REFCLK15625_RXAUI
+                                                         0x9:  125 MHz     8 Gb        R_8G_REFCLK125
+                                                         0xA:  156.25 MHz  2.5 Gb      R_25G_REFCLK100
+                                                         0xB:  156.25 MHz  3.125 Gb    R_3125G_REFCLK15625_XAUI
+                                                         0xC:  156.25 MHz  5 Gb        R_5G_REFCLK125
+                                                         0xD:  156.25 MHz  6.25 Gb     R_625G_REFCLK15625_RXAUI
+                                                         0xE:  156.25 MHz  10.3125 Gb  R_103125G_REFCLK15625_KR
+                                                         0xF:                          SW_MODE
+                                                         </pre>
                                                          Note that a value of 0xF is called SW_MODE. The OCI link does not come up configured in
                                                          SW_MODE.
                                                          (Software must do all the OCI GSER configuration to use OCI in the case of SW_MODE.)
                                                          When SPD!=SW_MODE after a chip cold reset, the hardware has initialized the following
                                                          registers (based on the OCI_SPD selection):
-                                                          * GSER(8..13)_LANE_MODE[LMODE]=Z.
-                                                          * GSER(8..13)_PLL_P(Z)_MODE_0.
-                                                          * GSER(8..13)_PLL_P(Z)_MODE_1.
-                                                          * GSER(8..13)_LANE_P(Z)_MODE_0.
-                                                          * GSER(8..13)_LANE_P(Z)_MODE_1.
-                                                          * GSER(8..13)_LANE_RX_VALBBD_CTRL_0.
-                                                          * GSER(8..13)_LANE_RX_VALBBD_CTRL_1.
-                                                          * GSER(8..13)_LANE_RX_VALBBD_CTRL_2.
-                                                         where Z is the LMODE indicated by the prior table. */
+                                                          * GSER()_LANE_MODE[LMODE]=Z.
+                                                          * GSER()_PLL_P()_MODE_0.
+                                                          * GSER()_PLL_P()_MODE_1.
+                                                          * GSER()_LANE_P()_MODE_0.
+                                                          * GSER()_LANE_P()_MODE_1.
+                                                          * GSER()_LANE()_RX_VALBBD_CTRL_0.
+                                                          * GSER()_LANE()_RX_VALBBD_CTRL_1.
+                                                          * GSER()_LANE()_RX_VALBBD_CTRL_2.
+                                                          where in "GSER(x)", x is 8..13, and in "P(z)", z equals LMODE. */
 #else
 	uint64_t spd                          : 4;
 	uint64_t reserved_4_63                : 60;
@@ -6667,7 +6740,7 @@ union cvmx_gserx_srst {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
 	uint64_t srst                         : 1;  /**< When asserted, resets all per-lane state in the GSER with the exception of the PHY and the
-                                                         GSER_CFG. For diagnostic use only. */
+                                                         GSER()_CFG. For diagnostic use only. */
 #else
 	uint64_t srst                         : 1;
 	uint64_t reserved_1_63                : 63;
diff --git a/arch/mips/include/asm/octeon/cvmx-helper-fpa.h b/arch/mips/include/asm/octeon/cvmx-helper-fpa.h
index ab10b0c..98cbda8 100644
--- a/arch/mips/include/asm/octeon/cvmx-helper-fpa.h
+++ b/arch/mips/include/asm/octeon/cvmx-helper-fpa.h
@@ -146,4 +146,6 @@ extern int cvmx_helper_fpa3_shutdown_aura_and_pool(int node, int aura_id);
 
 extern int cvmx_helper_shutdown_fpa_pools(int node);
 
+extern int cvmx_helper_fpa_pool_init(int node, int pool_num, int block_size, int max_blocks, const char *name);
+
 #endif /* __CVMX_HELPER_H__ */
diff --git a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
index d09bd07..f6fe814 100644
--- a/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-lmcx-defs.h
@@ -1733,7 +1733,7 @@ union cvmx_lmcx_char_ctl {
                                                          LFSR priming period after DQ_CHAR_CHECK_ENABLE is set to 1, and is forced back to 0 when
                                                          DQ_CHAR_CHECK_ENABLE is set to 0. */
 	uint64_t dq_char_check_enable         : 1;  /**< Enable DQ pattern check. The transition from disabled to enabled clears
-                                                         LMC(0..3)_CHAR_DQ_ERR_COUNT. */
+                                                         LMC()_CHAR_DQ_ERR_COUNT. */
 	uint64_t dq_char_bit_sel              : 3;  /**< Select a bit within the byte for DQ characterization pattern check. */
 	uint64_t dq_char_byte_sel             : 4;  /**< Select a byte of data for DQ characterization pattern check. */
 	uint64_t dr                           : 1;  /**< Pattern at Data Rate (not Clock Rate) */
@@ -2406,11 +2406,12 @@ typedef union cvmx_lmcx_comp_ctl2 cvmx_lmcx_comp_ctl2_t;
  * This register controls certain parameters required for memory configuration. Note the
  * following:
  * * Priority order for hardware write operations to
- * LMC(0..3)_CONFIG/LMC(0..3)_FADR/LMC(0..3)_ECC_SYND: DED error > SEC error.
+ * LMC()_CONFIG/LMC()_FADR/LMC()_ECC_SYND: DED error > SEC error.
  * * The self-refresh entry sequence(s) power the DLL up/down (depending on
- * LMC(0..3)_MODEREG_PARAMS0[DLL]) when LMC(0..3)_CONFIG[SREF_WITH_DLL] is set.
- * * Prior to the self-refresh exit sequence, LMC(0..3)_MODEREG_PARAMS0 should be reprogrammed
+ * LMC()_MODEREG_PARAMS0[DLL]) when LMC()_CONFIG[SREF_WITH_DLL] is set.
+ * * Prior to the self-refresh exit sequence, LMC()_MODEREG_PARAMS0 should be reprogrammed
  * (if needed) to the appropriate values.
+ *
  * See LMC Initialization Sequence for the LMC bring-up sequence.
  */
 union cvmx_lmcx_config {
@@ -2418,7 +2419,7 @@ union cvmx_lmcx_config {
 	struct cvmx_lmcx_config_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_63_63               : 1;
-	uint64_t bg2_enable                   : 1;  /**< BG2 pin is active for DDR4 mode. Only has an effect when LMC(0..3)_CONFIG[MODEDDR4] = 1.
+	uint64_t bg2_enable                   : 1;  /**< BG2 pin is active for DDR4 mode. Only has an effect when LMC()_CONFIG[MODEDDR4] = 1.
                                                          Typically only cleared for DDR4 *16 devices, where there is no BG2 pin on the device. */
 	uint64_t mode_x4dev                   : 1;  /**< DDR *4 device mode. */
 	uint64_t mode32b                      : 1;  /**< 32b Datapath Mode                                          NS
@@ -3776,7 +3777,7 @@ union cvmx_lmcx_control {
 	uint64_t thrmax                       : 4;  /**< Fine rate matching max bucket size. In conjunction with the coarse rate matching logic,
                                                          the fine rate matching logic gives software the ability to prioritize DFA reads over L2C
                                                          writes. Higher PERSUB values result in a lower DFA read bandwidth.
-                                                         0x0 = Reserved */
+                                                         0x0 = Reserved. */
 	uint64_t crm_cnt                      : 5;  /**< Coarse count. */
 	uint64_t crm_thr                      : 5;  /**< Coarse rate matching threshold. */
 	uint64_t crm_max                      : 5;  /**< Coarse rate matching max bucket size. The coarse rate matching logic is used to control
@@ -3784,7 +3785,7 @@ union cvmx_lmcx_control {
                                                          reads being preferred over LMC reads/writes when CRM_CNT < CRM_THR. CRM_CNT increments by
                                                          1 when a DFA read is slotted and by 2 when a LMC read/write is slotted, and rolls over
                                                          when CRM_MAX is reached.
-                                                         0x0 = Reserved */
+                                                         0x0 = Reserved. */
 	uint64_t rodt_bprch                   : 1;  /**< When set, the turn-off time for the ODT pin during a
                                                          RD cmd is delayed an additional CK cycle. */
 	uint64_t wodt_bprch                   : 1;  /**< When set, the turn-off time for the ODT pin during a
@@ -5427,14 +5428,20 @@ typedef union cvmx_lmcx_ddr4_dimm_ctl cvmx_lmcx_ddr4_dimm_ctl_t;
  * This register controls the DDR_CK frequency. For details, refer to CK Speed Programming. See
  * LMC Initialization Sequence for the initialization sequence.
  * DDR PLL Bringup sequence:
+ *
  * 1. Write CLKF, DDR_PS_EN, DFM_PS_EN, DIFFAMP, CPS, CPB. If test mode is going to be activated,
  * then also write jtg__ddr_pll_tm_en1, jtg__ddr_pll_tm_en2, jtg__ddr_pll_tm_en3,
  * jtg__ddr_pll_tm_en4, jtg__dfa_pll_tm_en1, jtg__dfa_pll_tm_en2, jtg__dfa_pll_tm_en3,
- * jtg__dfa_pll_tm_en4, JTAG_TEST_MODE
- * 2. Wait 128 ref clock cycles (7680 rclk cycles)
- * 3. Write 1 to RESET_N
- * 4. Wait 1152 ref clocks (1152*16 rclk cycles)
- * 5. Write 0 to DDR_DIV_RESET and DFM_DIV_RESET
+ * jtg__dfa_pll_tm_en4, JTAG_TEST_MODE.
+ *
+ * 2. Wait 128 ref clock cycles (7680 rclk cycles).
+ *
+ * 3. Write 1 to RESET_N.
+ *
+ * 4. Wait 1152 ref clocks (1152*16 rclk cycles).
+ *
+ * 5. Write 0 to DDR_DIV_RESET and DFM_DIV_RESET.
+ *
  * 6. Wait 10 ref clock cycles (160 rclk cycles) before bringing up the DDR interface
  * If test mode is going to be activated, wait an additional 8191 ref clocks (8191*16 rclk+
  * cycles) to allow PLL clock alignment.
@@ -5446,7 +5453,7 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t reserved_44_63               : 20;
 	uint64_t bwadj                        : 12; /**< Bandwidth control for DCLK PLLs. */
 	uint64_t dclk_invert                  : 1;  /**< Invert dclk that feeds LMC/DDR at the south side of the chip. */
-	uint64_t phy_dcok                     : 1;  /**< Set to power up PHY logic after setting LMC(0..3)_DDR_PLL_CTL[DDR4_MODE]. */
+	uint64_t phy_dcok                     : 1;  /**< Set to power up PHY logic after setting LMC()_DDR_PLL_CTL[DDR4_MODE]. */
 	uint64_t ddr4_mode                    : 1;  /**< DDR4 mode select: 1 = DDR4, 0 = DDR3. */
 	uint64_t pll_fbslip                   : 1;  /**< PLL FBSLIP indication. */
 	uint64_t pll_lock                     : 1;  /**< PLL LOCK indication. */
@@ -5596,7 +5603,7 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t reserved_44_63               : 20;
 	uint64_t bwadj                        : 12; /**< Bandwidth control for DCLK PLLs. */
 	uint64_t dclk_invert                  : 1;  /**< Invert dclk that feeds LMC/DDR at the south side of the chip. */
-	uint64_t phy_dcok                     : 1;  /**< Set to power up PHY logic after setting LMC(0..3)_DDR_PLL_CTL[DDR4_MODE]. */
+	uint64_t phy_dcok                     : 1;  /**< Set to power up PHY logic after setting LMC()_DDR_PLL_CTL[DDR4_MODE]. */
 	uint64_t ddr4_mode                    : 1;  /**< DDR4 mode select: 1 = DDR4, 0 = DDR3. */
 	uint64_t pll_fbslip                   : 1;  /**< PLL FBSLIP indication. */
 	uint64_t pll_lock                     : 1;  /**< PLL LOCK indication. */
@@ -5605,7 +5612,7 @@ union cvmx_lmcx_ddr_pll_ctl {
 	uint64_t jtg_test_mode                : 1;  /**< Reserved; must be zero. INTERNAL: JTAG test mode. Clock alignment between DCLK & REFCLK as
                                                          well as FCLK & REFCLK can only be performed after the ddr_pll_divider_reset is deasserted.
                                                          SW need to wait at least 10 reference clock cycles after deasserting pll_divider_reset
-                                                         before asserting LMC(0..3)_DDR_PLL_CTL[JTG_TEST_MODE]. During alignment (which can take up
+                                                         before asserting LMC()_DDR_PLL_CTL[JTG_TEST_MODE]. During alignment (which can take up
                                                          to 160 microseconds) DCLK and FCLK can exhibit some high-frequency pulses. Therefore, all
                                                          bring up activities in that clock domain need to be delayed (when the chip operates in
                                                          jtg_test_mode) by about 160 microseconds to ensure that lock is achieved. */
@@ -5788,10 +5795,10 @@ typedef union cvmx_lmcx_dimmx_ddr4_params1 cvmx_lmcx_dimmx_ddr4_params1_t;
  *
  * This register contains values to be programmed into each control word in the corresponding
  * (registered) DIMM. The control words allow optimization of the device properties for different
- * raw card designs. Note that LMC only uses this CSR when LMC(0..3)_CONTROL[RDIMM_ENA]=1. During
+ * raw card designs. Note that LMC only uses this CSR when LMC()_CONTROL[RDIMM_ENA]=1. During
  * a power-up/init sequence, LMC writes these fields into the control words in the JEDEC standard
  * SSTE32882 registering clock driver on an RDIMM when corresponding
- * LMC(0..3)_DIMM_CTL[DIMM*_WMASK] bits are set.
+ * LMC()_DIMM_CTL[DIMM*_WMASK] bits are set.
  */
 union cvmx_lmcx_dimmx_params {
 	uint64_t u64;
@@ -5848,7 +5855,7 @@ typedef union cvmx_lmcx_dimmx_params cvmx_lmcx_dimmx_params_t;
 /**
  * cvmx_lmc#_dimm_ctl
  *
- * Note that this CSR is only used when LMC(0..3)_CONTROL[RDIMM_ENA] = 1. During a power-up/init
+ * Note that this CSR is only used when LMC()_CONTROL[RDIMM_ENA] = 1. During a power-up/init
  * sequence, this CSR controls LMC's write operations to the control words in the JEDEC standard
  * SSTE32882 registering clock driver on an RDIMM.
  */
@@ -6266,16 +6273,17 @@ typedef union cvmx_lmcx_dll_ctl3 cvmx_lmcx_dll_ctl3_t;
  * cvmx_lmc#_dual_memcfg
  *
  * This register controls certain parameters of dual-memory configuration.
+ *
  * This register enables the design to have two separate memory configurations, selected
  * dynamically by the reference address. Note however, that both configurations share
- * LMC(0..3)_CONTROL[XOR_BANK], LMC(0..3)_CONFIG [PBANK_LSB], LMC(0..3)_CONFIG[RANK_ENA], and all
+ * LMC()_CONTROL[XOR_BANK], LMC()_CONFIG [PBANK_LSB], LMC()_CONFIG[RANK_ENA], and all
  * timing parameters.
+ *
  * In this description:
  * * config0 refers to the normal memory configuration that is defined by the
- * LMC*_CONFIG[ROW_LSB] parameter
+ * LMC()_CONFIG[ROW_LSB] parameter
  * * config1 refers to the dual (or second) memory configuration that is defined by this
  * register.
- * Enable-mask to chip-select mapping is shown below:
  */
 union cvmx_lmcx_dual_memcfg {
 	uint64_t u64;
@@ -6367,6 +6375,7 @@ typedef union cvmx_lmcx_dual_memcfg cvmx_lmcx_dual_memcfg_t;
  * which bit of the 128-bits dataword to corrupt by asserting any of the CHAR_MASK0 and
  * CHAR_MASK2 bits. (CHAR_MASK0 and CHAR_MASK2 corresponds to the lower and upper 64-bit signal
  * that can corrupt any individual bit of the data).
+ *
  * CA parity error is generated by enabling CA_PARITY_CORRUPT_ENA bit of this register and
  * selecting the DDR command that the parity is to be corrupted with through CA_PARITY_SEL.
  */
@@ -6498,7 +6507,7 @@ union cvmx_lmcx_ext_config {
                                                          CS active, no command pins active, and address/bank address/bank group all low) on the
                                                          interface after an active command, rather than only forcing the CS inactive between
                                                          commands. */
-	uint64_t cal_ena                      : 1;  /**< Set to cause LMC to operate in CAL mode. First set LMC(0..3)_MODEREG_PARAMS3[CAL], then
+	uint64_t cal_ena                      : 1;  /**< Set to cause LMC to operate in CAL mode. First set LMC()_MODEREG_PARAMS3[CAL], then
                                                          set CAL_ENA. */
 	uint64_t reserved_27_27               : 1;
 	uint64_t par_include_a17              : 1;  /**< If set, include A17 in parity calculations in DDR4 mode. */
@@ -6608,16 +6617,16 @@ typedef union cvmx_lmcx_ext_config cvmx_lmcx_ext_config_t;
  *
  * This register only captures the first transaction with ECC errors. A DED error can over-write
  * this register with its failing addresses if the first error was a SEC. If you write
- * LMC(0..3)_INT -> SEC_ERR/DED_ERR, it clears the error bits and captures the next failing
+ * LMC()_INT -> SEC_ERR/DED_ERR, it clears the error bits and captures the next failing
  * address. If FDIMM is 1, that means the error is in the high DIMM.
- * LMC(0..3)_FADR captures the failing pre-scrambled address location (split into DIMM, bunk,
- * bank, etc). If scrambling is off, then LMC(0..3)_FADR will also capture the failing physical
- * location in the DRAM parts. LMC(0..3)_SCRAMBLED_FADR captures the actual failing address
+ * LMC()_FADR captures the failing pre-scrambled address location (split into DIMM, bunk,
+ * bank, etc). If scrambling is off, then LMC()_FADR will also capture the failing physical
+ * location in the DRAM parts. LMC()_SCRAMBLED_FADR captures the actual failing address
  * location in the physical DRAM parts, i.e.,
- * * If scrambling is on, LMC(0..3)_SCRAMBLED_FADR contains the failing physical location in the
+ * * If scrambling is on, LMC()_SCRAMBLED_FADR contains the failing physical location in the
  * DRAM parts (split into DIMM, bunk, bank, etc.)
  * If scrambling is off, the pre-scramble and post-scramble addresses are the same; and so the
- * contents of LMC(0..3)_SCRAMBLED_FADR match the contents of LMC(0..3)_FADR.
+ * contents of LMC()_SCRAMBLED_FADR match the contents of LMC()_FADR.
  */
 union cvmx_lmcx_fadr {
 	uint64_t u64;
@@ -7933,9 +7942,12 @@ union cvmx_lmcx_modereg_params3 {
 	uint64_t crc                          : 1;  /**< CRC mode. */
 	uint64_t lpasr                        : 2;  /**< LP auto self refresh. */
 	uint64_t tccd_l                       : 3;  /**< TCCD_L timing parameter:
-                                                         0x0 = 4. 0x3 = 7.
-                                                         0x1 = 5. 0x4 = 8.
-                                                         0x2 = 6. 0x5-0x7 = reserved. */
+                                                         0x0 = 4.
+                                                         0x1 = 5.
+                                                         0x2 = 6.
+                                                         0x3 = 7.
+                                                         0x4 = 8.
+                                                         0x5-0x7 = reserved. */
 	uint64_t rd_dbi                       : 1;  /**< Read DBI. */
 	uint64_t wr_dbi                       : 1;  /**< Write DBI. */
 	uint64_t dm                           : 1;  /**< Data mask enable. */
@@ -8064,7 +8076,7 @@ union cvmx_lmcx_mr_mpr_ctl {
 	uint64_t reserved_53_55               : 3;
 	uint64_t mr_wr_use_default_value      : 1;  /**< When set, write the value to the MR that is computed from the value set in various CSR
                                                          fields that would be used during initialization, rather that using the value in the
-                                                         LMC(0..3)_MR_MPR_CTL[MR_WR_ADDR]. Useful to rewrite the same value or to change single
+                                                         LMC()_MR_MPR_CTL[MR_WR_ADDR]. Useful to rewrite the same value or to change single
                                                          bits without having to compute a whole new value for the MR. */
 	uint64_t mpr_whole_byte_enable        : 1;  /**< Reserved. INTERNAL: Select a whole byte of DRAM data to read when whole-byte mode enabled. */
 	uint64_t mpr_byte_select              : 4;  /**< Reserved. INTERNAL: Select a whole byte of DRAM data to read when whole-byte mode enabled. */
@@ -8172,6 +8184,7 @@ typedef union cvmx_lmcx_mr_mpr_ctl cvmx_lmcx_mr_mpr_ctl_t;
  * For example, for a DIMM made of Samsung's K4B1G0846C-ZCF7 1Gb (16M * 8 bit * 8 bank) DDR3
  * parts, the column address width = 10; so with 10b of col, 3b of bus, 3b of bank, row_lsb = 16.
  * Therefore, row = mem_adr[29:16] and mem_msb = 4.
+ *
  * Note also that addresses greater than the max defined space (pbank_msb) are also treated as
  * NXM accesses.
  */
@@ -8275,7 +8288,7 @@ typedef union cvmx_lmcx_nxm cvmx_lmcx_nxm_t;
  *
  * This register captures only the first transaction with a NXM error while an interrupt is
  * pending, and only captures a subsequent event once the interrupt is cleared by writing a 1 to
- * LMC(0..3)_INT[NXM_ERR]. It captures the actual L2C-LMC address provided to the LMC that caused
+ * LMC()_INT[NXM_ERR]. It captures the actual L2C-LMC address provided to the LMC that caused
  * the NXM error. A read or write NXM error is captured only if enabled using the NXM event
  * enables.
  */
@@ -8417,19 +8430,19 @@ union cvmx_lmcx_phy_ctl {
 	uint64_t dsk_dbg_rd_complete          : 1;  /**< Reserved. INTERNAL: Indicates completion of a read operation, will clear to 0 when a read
                                                          operation is started, then set to 1 when operation is complete. */
 	uint64_t dsk_dbg_rd_data              : 10; /**< Reserved. INTERNAL: Data from a deskew read operation. Only valid when the
-                                                         LMCX_PHY_CTL[DSK_DBG_RD_COMPLETE] bit is set. */
+                                                         LMC()_PHY_CTL[DSK_DBG_RD_COMPLETE] bit is set. */
 	uint64_t dsk_dbg_rd_start             : 1;  /**< Reserved. INTERNAL: Write 1 to start deskew data read operation, will automatically clear
                                                          to 0. Write to 1 will also clear the complete bit. */
 	uint64_t dsk_dbg_clk_scaler           : 2;  /**< Reserved. INTERNAL: Adjust clock toggle rate for reading deskew debug information:
-                                                         0 = Deskew read clock toggles every 4 DCLKs
-                                                         1 = Deskew read clock toggles every 8 DCLKs
-                                                         2 = Deskew read clock toggles every 12 DCLKs
-                                                         3 = Deskew read clock toggles every 16 DCLKs */
+                                                         0x0 = Deskew read clock toggles every 4 DCLKs.
+                                                         0x1 = Deskew read clock toggles every 8 DCLKs.
+                                                         0x2 = Deskew read clock toggles every 12 DCLKs.
+                                                         0x3 = Deskew read clock toggles every 16 DCLKs. */
 	uint64_t dsk_dbg_offset               : 2;  /**< Reserved. INTERNAL: Offset to change delay of deskew debug data return time to LMC from
                                                          DDR PHY. */
 	uint64_t dsk_dbg_num_bits_sel         : 1;  /**< Reserved. INTERNAL: Deskew debug, select number of bits per byte lane.
-                                                         0 = 8 bits per byte lane, no DBI
-                                                         1 = 9 bits per byte lane, including DBI */
+                                                         0 = 8 bits per byte lane, no DBI.
+                                                         1 = 9 bits per byte lane, including DBI. */
 	uint64_t dsk_dbg_byte_sel             : 4;  /**< Reserved. INTERNAL: Deskew debug byte select for read operation. Values 0-3 correspond to
                                                          byte lanes 0-3, 4 is for ECC, 5-8 are byte lanes 4-7. */
 	uint64_t dsk_dbg_bit_sel              : 4;  /**< Reserved. INTERNAL: Deskew debug bit select for dsk read operation. */
@@ -9084,12 +9097,12 @@ typedef union cvmx_lmcx_rlevel_ctl cvmx_lmcx_rlevel_ctl_t;
 /**
  * cvmx_lmc#_rlevel_dbg
  *
- * A given read of LMC(0..3)_RLEVEL_DBG returns the read-leveling pass/fail results for all
+ * A given read of LMC()_RLEVEL_DBG returns the read-leveling pass/fail results for all
  * possible delay settings (i.e. the BITMASK) for only one byte in the last rank that the
- * hardware ran read-leveling on. LMC(0..3)_RLEVEL_CTL[BYTE] selects the particular byte. To get
+ * hardware ran read-leveling on. LMC()_RLEVEL_CTL[BYTE] selects the particular byte. To get
  * these pass/fail results for a different rank, you must run the hardware read-leveling again.
  * For example, it is possible to get the BITMASK results for every byte of every rank if you run
- * read-leveling separately for each rank, probing LMC(0..3)_RLEVEL_DBG between each read-
+ * read-leveling separately for each rank, probing LMC()_RLEVEL_DBG between each read-
  * leveling.
  */
 union cvmx_lmcx_rlevel_dbg {
@@ -9124,17 +9137,20 @@ typedef union cvmx_lmcx_rlevel_dbg cvmx_lmcx_rlevel_dbg_t;
  * of 1/4 CK, so the BYTEn values can range over 16 CK cycles. Each CSR is written by hardware
  * during a read-leveling sequence for the rank. (Hardware sets STATUS to 3 after hardware read-
  * leveling completes for the rank.)
- * If hardware is unable to find a match per LMC(0..3)_RLEVEL_CTL[OFFSET_EN] and
- * LMC(0..3)_RLEVEL_CTL[OFFSET], then hardware sets LMC(0..3)_RLEVEL_RANK(0..3)[BYTEn<5:0>] to
+ * If hardware is unable to find a match per LMC()_RLEVEL_CTL[OFFSET_EN] and
+ * LMC()_RLEVEL_CTL[OFFSET], then hardware sets LMC()_RLEVEL_RANK()[BYTEn<5:0>] to
  * 0x0.
+ *
  * Each CSR may also be written by software, but not while a read-leveling sequence is in
  * progress. (Hardware sets STATUS to 1 after a CSR write.) Software initiates a hardware read-
- * leveling sequence by programming LMC(0..3)_RLEVEL_CTL and writing INIT_START = 1 with
- * SEQ_SEL=1. See LMC*_RLEVEL_CTL.
- * LMC*_RLEVEL_RANKi values for ranks i without attached DRAM should be set such that they do not
+ * leveling sequence by programming LMC()_RLEVEL_CTL and writing INIT_START = 1 with
+ * SEQ_SEL=1. See LMC()_RLEVEL_CTL.
+ *
+ * LMC()_RLEVEL_RANKi values for ranks i without attached DRAM should be set such that they do
+ * not
  * increase the range of possible BYTE values for any byte lane. The easiest way to do this is to
- * set LMC*_RLEVEL_RANKi = LMC*_RLEVEL_RANKj, where j is some rank with attached DRAM whose
- * LMC*_RLEVEL_RANKj is already fully initialized.
+ * set LMC()_RLEVEL_RANKi = LMC()_RLEVEL_RANKj, where j is some rank with attached DRAM whose
+ * LMC()_RLEVEL_RANKj is already fully initialized.
  */
 union cvmx_lmcx_rlevel_rankx {
 	uint64_t u64;
@@ -9291,14 +9307,16 @@ typedef union cvmx_lmcx_rodt_ctl cvmx_lmcx_rodt_ctl_t;
  * System designers may desire to terminate DQ/DQS lines for higher frequency DDR operations,
  * especially on a multirank system. DDR3 DQ/DQS I/Os have built-in termination resistors that
  * can be turned on or off by the controller, after meeting TAOND and TAOF timing requirements.
+ *
  * Each rank has its own ODT pin that fans out to all the memory parts in that DIMM. System
  * designers may prefer different combinations of ODT ONs for read operations into different
- * ranks. CN78XX supports full programmability by way of the mask register below. Each rank
+ * ranks. CNXXXX supports full programmability by way of the mask register below. Each rank
  * position has its own 4-bit programmable field. When the controller does a read to that rank,
  * it sets the 4 ODT pins to the MASK pins below. For example, when doing a read from Rank0, a
  * system designer may desire to terminate the lines with the resistor on DIMM0/Rank1. The mask
  * RODT_D0_R0 would then be [0010].
- * CN78XX drives the appropriate mask values on the ODT pins by default. If this feature is not
+ *
+ * CNXXXX drives the appropriate mask values on the ODT pins by default. If this feature is not
  * required, write 0x0 in this register. Note that, as per the JEDEC DDR3 specifications, the ODT
  * pin for the rank that is being read should always be 0x0.
  * When a given RANK is selected, the RODT mask for that rank is used. The resulting RODT mask is
@@ -9437,17 +9455,20 @@ typedef union cvmx_lmcx_scramble_cfg1 cvmx_lmcx_scramble_cfg1_t;
 /**
  * cvmx_lmc#_scrambled_fadr
  *
- * LMC(0..3)_FADR captures the failing pre-scrambled address location (split into DIMM, bunk,
- * bank, etc). If scrambling is off, LMC(0..3)_FADR also captures the failing physical location
- * in the DRAM parts. LMC(0..3)_SCRAMBLED_FADR captures the actual failing address location in
+ * LMC()_FADR captures the failing pre-scrambled address location (split into DIMM, bunk,
+ * bank, etc). If scrambling is off, LMC()_FADR also captures the failing physical location
+ * in the DRAM parts. LMC()_SCRAMBLED_FADR captures the actual failing address location in
  * the physical DRAM parts, i.e.:
- * * If scrambling is on, LMC(0..3)_SCRAMBLED_FADR contains the failing physical location in the
+ *
+ * * If scrambling is on, LMC()_SCRAMBLED_FADR contains the failing physical location in the
  * DRAM parts (split into DIMM, bunk, bank, etc);
- * If scrambling is off, the pre-scramble and post-scramble addresses are the same, and so the
- * contents of LMC(0..3)_SCRAMBLED_FADR match the contents of LMC(0..3)_FADR.
+ *
+ * * If scrambling is off, the pre-scramble and post-scramble addresses are the same, and so the
+ * contents of LMC()_SCRAMBLED_FADR match the contents of LMC()_FADR.
+ *
  * This register only captures the first transaction with ECC errors. A DED error can over-write
  * this register with its failing addresses if the first error was a SEC. If you write
- * LMC(0..3)_CONFIG -> SEC_ERR/DED_ERR, it clears the error bits and captures the next failing
+ * LMC()_CONFIG -> SEC_ERR/DED_ERR, it clears the error bits and captures the next failing
  * address. If FDIMM is 1, that means the error is in the higher DIMM.
  */
 union cvmx_lmcx_scrambled_fadr {
@@ -9586,7 +9607,7 @@ union cvmx_lmcx_seq_ctl {
                                                          a second power-up/init, a DRESET assertion is required
                                                          between the first and the second. */
 	uint64_t init_start                   : 1;  /**< A 0->1 transition starts the DDR memory sequence that is selected by
-                                                         LMC(0..3)_SEQ_CTL[SEQ_SEL].
+                                                         LMC()_SEQ_CTL[SEQ_SEL].
                                                          This register is a one-shot and clears itself each time it is set. */
 #else
 	uint64_t init_start                   : 1;
@@ -10454,28 +10475,32 @@ union cvmx_lmcx_timing_params2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
 	uint64_t trtp                         : 4;  /**< Specifies the TRTP parameter, in cycles. Set this field as follows:
-                                                         RNDUP[TRTP(ns) / TCYC(ns)] - 1,
+                                                         _ RNDUP[TRTP(ns) / TCYC(ns)] - 1,
                                                          For DDR3, typical = max(4 nCK, 7.5ns).
                                                          For DDR4 the TRTP parameter is dictated by the TWR MR bits. */
 	uint64_t t_rw_op_max                  : 4;  /**< Specifies the maximum delay for a read or write operation to complete, used to set the
                                                          timing of MRW and MPR operations. Set this field as follows:
-                                                         RNDUP[Maximum operation delay (cycles) / 8]
+                                                         _ RNDUP[Maximum operation delay (cycles) / 8]
                                                          Typical = 0x7. */
 	uint64_t twtr_l                       : 4;  /**< Specifies TWTR_L constraints. Set this field as follows:
-                                                         RNDUP[TWTR_L(ns) / TCYC(ns)] - 1
+                                                         _ RNDUP[TWTR_L(ns) / TCYC(ns)] - 1
                                                          where TWTR_L is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not the
                                                          data rate).
                                                          Typical = MAX(4 nCK, 7.5 ns)
                                                          INTERNAL: Seems the '- 1' is because we add 1 back into slot timing equation */
 	uint64_t trrd_l                       : 3;  /**< Specifies TRRD_L constraints. Set this field as follows:
-                                                         RNDUP[TRRD_L(ns) / TCYC(ns)] - 1,
+                                                         _ RNDUP[TRRD_L(ns) / TCYC(ns)] - 1,
                                                          where TRRD_L is from the JEDEC DDR4 spec, and TCYC(ns) is the DDR clock frequency (not the
                                                          data rate).
-                                                         Typical = MAX(4 nCK, 7.5 ns)
-                                                         0x0 = reserved. 0x4 = five TCYC.
-                                                         0x1 = two TCYC. 0x5 = six TCYC.
-                                                         0x2 = three TCYC. 0x6 = seven TCYC.
-                                                         0x3 = four TCYC. 0x7 = eight TCYC. */
+                                                         Typical = MAX(4 nCK, 7.5 ns).
+                                                         0x0 = reserved.
+                                                         0x1 = two TCYC.
+                                                         0x2 = three TCYC.
+                                                         0x3 = four TCYC.
+                                                         0x4 = five TCYC.
+                                                         0x5 = six TCYC.
+                                                         0x6 = seven TCYC.
+                                                         0x7 = eight TCYC. */
 #else
 	uint64_t trrd_l                       : 3;
 	uint64_t twtr_l                       : 4;
@@ -10618,12 +10643,12 @@ typedef union cvmx_lmcx_wlevel_ctl cvmx_lmcx_wlevel_ctl_t;
 /**
  * cvmx_lmc#_wlevel_dbg
  *
- * A given write of LMC(0..3)_WLEVEL_DBG returns the write-leveling pass/fail results for all
+ * A given write of LMC()_WLEVEL_DBG returns the write-leveling pass/fail results for all
  * possible delay settings (i.e. the BITMASK) for only one byte in the last rank that the
- * hardware write-leveled. LMC(0..3)_WLEVEL_DBG[BYTE] selects the particular byte. To get these
+ * hardware write-leveled. LMC()_WLEVEL_DBG[BYTE] selects the particular byte. To get these
  * pass/fail results for a different rank, you must run the hardware write-leveling again. For
  * example, it is possible to get the BITMASK results for every byte of every rank if you run
- * write-leveling separately for each rank, probing LMC(0..3)_WLEVEL_DBG between each write-
+ * write-leveling separately for each rank, probing LMC()_WLEVEL_DBG between each write-
  * leveling.
  */
 union cvmx_lmcx_wlevel_dbg {
@@ -10666,26 +10691,30 @@ typedef union cvmx_lmcx_wlevel_dbg cvmx_lmcx_wlevel_dbg_t;
  *
  * Four of these CSRs exist per LMC, one for each rank. Write level setting is measured in units
  * of 1/8 CK, so the below BYTEn values can range over 4 CK cycles. Assuming
- * LMC(0..3)_WLEVEL_CTL[SSET]=0, the BYTEn<2:0> values are not used during write-leveling, and
+ * LMC()_WLEVEL_CTL[SSET]=0, the BYTEn<2:0> values are not used during write-leveling, and
  * they are overwritten by the hardware as part of the write-leveling sequence. (Hardware sets
  * STATUS to 3 after hardware write-leveling completes for the rank). Software needs to set
  * BYTEn<4:3> bits.
+ *
  * Each CSR may also be written by software, but not while a write-leveling sequence is in
  * progress. (Hardware sets STATUS to 1 after a CSR write.) Software initiates a hardware write-
- * leveling sequence by programming LMC*_WLEVEL_CTL and writing RANKMASK and INIT_START=1 with
+ * leveling sequence by programming LMC()_WLEVEL_CTL and writing RANKMASK and INIT_START=1 with
  * SEQ_SEL=6 in LMC*0_CONFIG.
+ *
  * LMC will then step through and accumulate write leveling results for 8 unique delay settings
- * (twice), starting at a delay of LMC(0..3)_WLEVEL_RANK(0..3) [BYTEn<4:3>]* 8 CK increasing by
- * 1/8 CK each setting. Hardware will then set LMC(0..3)_WLEVEL_RANK(0..3)[BYTEn<2:0>] to
+ * (twice), starting at a delay of LMC()_WLEVEL_RANK() [BYTEn<4:3>]* 8 CK increasing by
+ * 1/8 CK each setting. Hardware will then set LMC()_WLEVEL_RANK()[BYTEn<2:0>] to
  * indicate the first write leveling result of '1' that followed a result of '0' during the
  * sequence by searching for a '1100' pattern in the generated bitmask, except that LMC will
- * always write LMC(0..3)_WLEVEL_RANK(0..3)[BYTEn<0>]=0. If hardware is unable to find a match
- * for a '1100' pattern, then hardware sets LMC(0..3)_WLEVEL_RANK(0..3) [BYTEn<2:0>] to 0x4. See
- * LMC*_WLEVEL_CTL.
- * LMC*_WLEVEL_RANKi values for ranks i without attached DRAM should be set such that they do not
+ * always write LMC()_WLEVEL_RANK()[BYTEn<0>]=0. If hardware is unable to find a match
+ * for a '1100' pattern, then hardware sets LMC()_WLEVEL_RANK() [BYTEn<2:0>] to 0x4. See
+ * LMC()_WLEVEL_CTL.
+ *
+ * LMC()_WLEVEL_RANKi values for ranks i without attached DRAM should be set such that they do
+ * not
  * increase the range of possible BYTE values for any byte lane. The easiest way to do this is to
- * set LMC*_WLEVEL_RANKi = LMC*_WLEVEL_RANKj, where j is some rank with attached DRAM whose
- * LMC*_WLEVEL_RANKj is already fully initialized.
+ * set LMC()_WLEVEL_RANKi = LMC()_WLEVEL_RANKj, where j is some rank with attached DRAM whose
+ * LMC()_WLEVEL_RANKj is already fully initialized.
  */
 union cvmx_lmcx_wlevel_rankx {
 	uint64_t u64;
@@ -10886,12 +10915,13 @@ typedef union cvmx_lmcx_wodt_ctl1 cvmx_lmcx_wodt_ctl1_t;
  * can be turned on or off by the controller, after meeting TAOND and TAOF timing requirements.
  * Each rank has its own ODT pin that fans out to all of the memory parts in that DIMM. System
  * designers may prefer different combinations of ODT ONs for write operations into different
- * ranks. CN78XX supports full programmability by way of the mask register below. Each rank
+ * ranks. CNXXXX supports full programmability by way of the mask register below. Each rank
  * position has its own 8-bit programmable field. When the controller does a write to that rank,
  * it sets the 4 ODT pins to the mask pins below. For example, when doing a write into Rank0, a
  * system designer may desire to terminate the lines with the resistor on DIMM0/Rank1. The mask
  * WODT_D0_R0 would then be [00000010].
- * CN78XX drives the appropriate mask values on the ODT pins by default. If this feature is not
+ *
+ * CNXXXX drives the appropriate mask values on the ODT pins by default. If this feature is not
  * required, write 0x0 in this register. When a given RANK is selected, the WODT mask for that
  * RANK is used. The resulting WODT mask is driven to the DIMMs in the following manner:
  */
diff --git a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
index d9119a2..a43098c 100644
--- a/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-mixx-defs.h
@@ -384,7 +384,7 @@ union cvmx_mixx_ctl {
                                                          (MIX(0..1)_TSCTL[TSCNT]) is greater than
                                                          MIX(0..1)_CTL[TS_THRESH], then a programmable TimeStamp interrupt is issued (see
                                                          MIX(0..1)_INTR[TS]).
-                                                         For CN78XX, since the implementation only supports four outstanding timestamp interrupts,
+                                                         For CNXXXX, since the implementation only supports four outstanding timestamp interrupts,
                                                          this field should only be programmed from [0..3]. */
 	uint64_t crc_strip                    : 1;  /**< Hardware CRC strip enable. When enabled, the last 4 bytes (CRC) of the ingress packet are
                                                          not included in cumulative packet byte length. In other words, the cumulative LEN field
@@ -734,7 +734,7 @@ union cvmx_mixx_irhwm {
                                                          * in full-duplex mode: send periodic PAUSE packets.
                                                          * in half-duplex mode: force collisions.
                                                          This programmable mechanism is provided as a means to backpressure input traffic early
-                                                         enough so that packets are not dropped by CN78XX. */
+                                                         enough so that packets are not dropped by CNXXXX. */
 	uint64_t irhwm                        : 20; /**< I-Ring entry high-watermark threshold. Used to determine when the number of inbound
                                                          packets in system memory (MIX(0..1)_IRCNT[IRCNT]) exceeds this IRHWM threshold. */
 #else
diff --git a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
index 0478782..0414142 100644
--- a/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-oclax-defs.h
@@ -673,7 +673,7 @@ union cvmx_oclax_fsmx_andx_ix {
 	struct cvmx_oclax_fsmx_andx_ix_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
-	uint64_t mcd                          : 3;  /**< Multichip Debug (MCD) 0..2 inputs. */
+	uint64_t mcd                          : 3;  /**< Multichip debug (MCD) 0..2 inputs. */
 	uint64_t match                        : 4;  /**< Matcher 0..3 input. */
 	uint64_t fsm1_state                   : 4;  /**< FSM 1 last state. */
 	uint64_t fsm0_state                   : 4;  /**< FSM 0 last state. */
@@ -1095,7 +1095,7 @@ union cvmx_oclax_state_int {
 	uint64_t captured                     : 1;  /**< Capture started. Asserted when the first capture is made. Informational only; often masked. */
 	uint64_t fsm1_int                     : 1;  /**< FSM1 interrupt requested. */
 	uint64_t fsm0_int                     : 1;  /**< FSM0 interrupt requested. */
-	uint64_t mcd                          : 3;  /**< Multichip Debug (MCD0..2) set. Asserted on MCD received from another coprocessor or code,
+	uint64_t mcd                          : 3;  /**< Multichip debug (MCD0..2) set. Asserted on MCD received from another coprocessor or code,
                                                          or FSM MCD request or W1S to OCLA()_STATE_SET[MCD]. */
 	uint64_t trig                         : 1;  /**< Internal trigger set. Asserted on FSM internal trigger request or W1S to OCLA()_STATE_SET[TRIG]. */
 	uint64_t reserved_4_7                 : 4;
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
index 8f440eb..78e6d9d 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepvfx-defs.h
@@ -1166,7 +1166,7 @@ union cvmx_pcieepvfx_cfg030 {
 	uint32_t pf_en                        : 1;  /**< Phantom function enable. */
 	uint32_t etf_en                       : 1;  /**< Extended tag field enable. */
 	uint32_t mps                          : 3;  /**< Max payload size. Legal values: 0x0 = 128 B, 0x1 = 256 B.
-                                                         Larger sizes are not supported by CN78XX.
+                                                         Larger sizes are not supported by CNXXXX.
                                                          DPI_SLI_PRT()_CFG[MPS] must be set to the same value as this field for proper
                                                          functionality. */
 	uint32_t ro_en                        : 1;  /**< Enable relaxed ordering. */
diff --git a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
index a1dd087..8269e7d 100644
--- a/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pcieepx-defs.h
@@ -9064,7 +9064,7 @@ union cvmx_pcieepx_cfg111 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint32_t reserved_30_31               : 2;
 	uint32_t srs                          : 26; /**< "Supported resource sizes. PEM advertises the maximum allowable BAR size (512 GB -
-                                                         0xF_FFFF) when the fus__bar2_size_conf is in tact. When the fuse is blown, the CN78XX
+                                                         0xF_FFFF) when the fus__bar2_size_conf is in tact. When the fuse is blown, the CNXXXX
                                                          advertises a BAR size of 32TB (0x3FF_FFFF). The BAR is disabled at runtime by writing all
                                                          zeros through PEM()_CFG_WR to this field." */
 	uint32_t reserved_0_3                 : 4;
diff --git a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
index e1f3e83..1cf230d 100644
--- a/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pemx-defs.h
@@ -2087,7 +2087,7 @@ union cvmx_pemx_dbg_info {
 	uint64_t racpp                        : 1;  /**< Received a completion with poisoned payload. radm_rcvd_cpl_poisoned */
 	uint64_t ramtlp                       : 1;  /**< Received a malformed TLP. radm_mlf_tlp_err */
 	uint64_t rarwdns                      : 1;  /**< Received a request which device does not support. radm_rcvd_ur_req */
-	uint64_t caar                         : 1;  /**< Completer aborted a request. This bit is never set because CN78XX does not generate
+	uint64_t caar                         : 1;  /**< Completer aborted a request. This bit is never set because CNXXXX does not generate
                                                          completer aborts. */
 	uint64_t racca                        : 1;  /**< Received a completion with CA status. radm_rcvd_cpl_ca */
 	uint64_t racur                        : 1;  /**< Received a completion with UR status. radm_rcvd_cpl_ur */
diff --git a/arch/mips/include/asm/octeon/cvmx-pki-defs.h b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
index 2103dce..c2755bf 100644
--- a/arch/mips/include/asm/octeon/cvmx-pki-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-pki-defs.h
@@ -1114,19 +1114,19 @@ union cvmx_pki_aurax_cfg {
 	struct cvmx_pki_aurax_cfg_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t pkt_add                      : 2;  /**< Specifies what to add to FPA_AURA(0..1023)_CNT when PKI enqueues a packet:
+	uint64_t pkt_add                      : 2;  /**< Specifies what to add to FPA_AURA()_CNT when PKI enqueues a packet:
                                                          0 = zero.
                                                          1 = one.
-                                                         2 = The number of FPA buffers allocated; i.e. if PKI_STYLE(0..63)_BUF[DIS_WQ_DAT] is set,
+                                                         2 = The number of FPA buffers allocated; i.e. if PKI_STYLE()_BUF[DIS_WQ_DAT] is set,
                                                          WQE[BUFS]+1, else WQE[BUFS].
                                                          3 = WQE[LEN] (i.e. the packet length). */
 	uint64_t reserved_19_29               : 11;
 	uint64_t ena_red                      : 1;  /**< Enable RED drop between PASS and DROP levels. See also
-                                                         FPA_AURA(0..1023)_POOL_LEVELS[RED_ENA] and FPA_AURA(0..1023)_CNT_LEVELS[RED_ENA]. */
+                                                         FPA_AURA()_POOL_LEVELS[RED_ENA] and FPA_AURA()_CNT_LEVELS[RED_ENA]. */
 	uint64_t ena_drop                     : 1;  /**< Enable tail drop when maximum DROP level exceeded. See also
-                                                         FPA_AURA(0..1023)_POOL_LEVELS[DROP] and FPA_AURA(0..1023)_CNT_LEVELS[DROP]. */
+                                                         FPA_AURA()_POOL_LEVELS[DROP] and FPA_AURA()_CNT_LEVELS[DROP]. */
 	uint64_t ena_bp                       : 1;  /**< Enable asserting backpressure on BPID when maximum DROP level exceeded. See also
-                                                         FPA_AURA(0..1023)_POOL_LEVELS[RED_ENA] and FPA_AURA(0..1023)_CNT_LEVELS[RED_ENA]. */
+                                                         FPA_AURA()_POOL_LEVELS[RED_ENA] and FPA_AURA()_CNT_LEVELS[RED_ENA]. */
 	uint64_t reserved_10_15               : 6;
 	uint64_t bpid                         : 10; /**< Bpid to assert backpressure on. */
 #else
@@ -1157,19 +1157,19 @@ union cvmx_pki_bist_status0 {
 	uint64_t reserved_31_63               : 33;
 	uint64_t bist                         : 31; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. INTERNAL: This
                                                          register collects status for PKI_PFE.
-                                                         <30> - INB_ERRS
-                                                         <29> - INB OCTS
-                                                         <28> - INB PKTS
-                                                         <27> - LD FIF
-                                                         <26> - PBE STATE
-                                                         <25> - WADR STATE
-                                                         <24> - NXT PTAG
-                                                         <23> - CUR PTAG
-                                                         <22> - X2P FIF
-                                                         <21> - DROP FIF
-                                                         <20> - NXT BLK
-                                                         <19..16> - KMEM
-                                                         <15..0> - ASM BUFF */
+                                                         <30> = INB_ERRS.
+                                                         <29> = INB OCTS.
+                                                         <28> = INB PKTS.
+                                                         <27> = LD FIF.
+                                                         <26> = PBE STATE.
+                                                         <25> = WADR STATE.
+                                                         <24> = NXT PTAG.
+                                                         <23> = CUR PTAG.
+                                                         <22> = X2P FIF.
+                                                         <21> = DROP FIF.
+                                                         <20> = NXT BLK.
+                                                         <19..16> = KMEM.
+                                                         <15..0> = ASM BUFF. */
 #else
 	uint64_t bist                         : 31;
 	uint64_t reserved_31_63               : 33;
@@ -1192,24 +1192,24 @@ union cvmx_pki_bist_status1 {
 	uint64_t reserved_21_63               : 43;
 	uint64_t bist                         : 21; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. INTERNAL: This
                                                          register collects status for PKI_PBE.
-                                                         <20>: STATS_MEM0
-                                                         <19>: STATS_MEM1
-                                                         <18>: STATS_MEM2
-                                                         <17>: STATS_MEM3
-                                                         <16>: SWS
-                                                         <15>: WQEOUT
-                                                         <14>: DOA
-                                                         <13>: BPID
-                                                         <12:10>: Reserved
-                                                         <9>: PLC
-                                                         <8>: PKTWQ
-                                                         <7:6>: Reserved
-                                                         <5>: TAG
-                                                         <4>: AURA
-                                                         <3>: CHAN
-                                                         <2>: PBTAG
-                                                         <1>: STYLEWQ
-                                                         <0>: QPG */
+                                                         <20> = STATS_MEM0.
+                                                         <19> = STATS_MEM1.
+                                                         <18> = STATS_MEM2.
+                                                         <17> = STATS_MEM3.
+                                                         <16> = SWS.
+                                                         <15> = WQEOUT.
+                                                         <14> = DOA.
+                                                         <13> = BPID.
+                                                         <12 =10> = Reserved.
+                                                         <9> = PLC.
+                                                         <8> = PKTWQ.
+                                                         <7 =6> = Reserved.
+                                                         <5> = TAG.
+                                                         <4> = AURA.
+                                                         <3> = CHAN.
+                                                         <2> = PBTAG.
+                                                         <1> = STYLEWQ.
+                                                         <0> = QPG. */
 #else
 	uint64_t bist                         : 21;
 	uint64_t reserved_21_63               : 43;
@@ -1232,19 +1232,19 @@ union cvmx_pki_bist_status2 {
 	uint64_t reserved_25_63               : 39;
 	uint64_t bist                         : 25; /**< BIST results. Hardware sets a bit in BIST for memory that fails BIST. INTERNAL: This
                                                          register collects status for PKI_PIX (verif/vkits/pki/pki_mem_info_table.sv).
-                                                         - 24: IMEM
-                                                         - 23: IPEC3 / IPEs 10 .. 19 (RegFile + DMEM)
-                                                         - 22: IPEC3 / IPEs  0 ..  9 (RegFile + DMEM)
-                                                         - 21: IPEC2 / IPEs 10 .. 19 (RegFile + DMEM)
-                                                         - 20: IPEC2 / IPEs  0 ..  9 (RegFile + DMEM)
-                                                         - 19: IPEC1 / IPEs 10 .. 19 (RegFile + DMEM)
-                                                         - 18: IPEC1 / IPEs  0 ..  9 (RegFile + DMEM)
-                                                         - 17: IPEC0 / IPEs 10 .. 19 (RegFile + DMEM)
-                                                         - 16: IPEC0 / IPEs  0 ..  9 (RegFile + DMEM)
-                                                         15..12: IPEC SMEM
-                                                         11..8: IPEC PCAM ECC
-                                                         7..4: IPEC PCAM RES
-                                                         3..0: IPEC PCAM CAM */
+                                                         24 = IMEM.
+                                                         23 = IPEC3 / IPEs 10 .. 19 (RegFile + DMEM).
+                                                         22 = IPEC3 / IPEs  0 ..  9 (RegFile + DMEM).
+                                                         21 = IPEC2 / IPEs 10 .. 19 (RegFile + DMEM).
+                                                         20 = IPEC2 / IPEs  0 ..  9 (RegFile + DMEM).
+                                                         19 = IPEC1 / IPEs 10 .. 19 (RegFile + DMEM).
+                                                         18 = IPEC1 / IPEs  0 ..  9 (RegFile + DMEM).
+                                                         17 = IPEC0 / IPEs 10 .. 19 (RegFile + DMEM).
+                                                         16 = IPEC0 / IPEs  0 ..  9 (RegFile + DMEM).
+                                                         15..12 = IPEC SMEM.
+                                                         11..8 = IPEC PCAM ECC.
+                                                         7..4 = IPEC PCAM RES.
+                                                         3..0 = IPEC PCAM CAM. */
 #else
 	uint64_t bist                         : 25;
 	uint64_t reserved_25_63               : 39;
@@ -1398,14 +1398,14 @@ union cvmx_pki_clx_ecc_int {
 	struct cvmx_pki_clx_ecc_int_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_8_63                : 56;
-	uint64_t pcam1_dbe                    : 1;  /**< PCAM1 ECC double bit error. Throws PKI_INTSN_E::PKI_CL(0..3)_ECC_PCAM1_DBE. */
-	uint64_t pcam1_sbe                    : 1;  /**< PCAM1 ECC single bit error. Throws PKI_INTSN_E::PKI_CL(0..3)_ECC_PCAM1_SBE. */
-	uint64_t pcam0_dbe                    : 1;  /**< PCAM0 ECC double bit error. Throws PKI_INTSN_E::PKI_CL(0..3)_ECC_PCAM0_DBE. */
-	uint64_t pcam0_sbe                    : 1;  /**< PCAM0 ECC single bit error. Throws PKI_INTSN_E::PKI_CL(0..3)_ECC_PCAM0_SBE. */
-	uint64_t smem_dbe                     : 1;  /**< SMEM ECC double bit error. Throws PKI_INTSN_E::PKI_CL(0..3)_ECC_SMEM_DBE. */
-	uint64_t smem_sbe                     : 1;  /**< SMEM ECC single bit error. Throws PKI_INTSN_E::PKI_CL(0..3)_ECC_SMEM_SBE. */
-	uint64_t dmem_perr                    : 1;  /**< DMEM parity error. Throws PKI_INTSN_E::PKI_CL(0..3)_ECC_DMEM_PERR. */
-	uint64_t rf_perr                      : 1;  /**< RF RAM parity error. Throws PKI_INTSN_E::PKI_CL(0..3)_ECC_RF_PERR. */
+	uint64_t pcam1_dbe                    : 1;  /**< PCAM1 ECC double bit error. Throws PKI_INTSN_E::PKI_CL()_ECC_PCAM1_DBE. */
+	uint64_t pcam1_sbe                    : 1;  /**< PCAM1 ECC single bit error. Throws PKI_INTSN_E::PKI_CL()_ECC_PCAM1_SBE. */
+	uint64_t pcam0_dbe                    : 1;  /**< PCAM0 ECC double bit error. Throws PKI_INTSN_E::PKI_CL()_ECC_PCAM0_DBE. */
+	uint64_t pcam0_sbe                    : 1;  /**< PCAM0 ECC single bit error. Throws PKI_INTSN_E::PKI_CL()_ECC_PCAM0_SBE. */
+	uint64_t smem_dbe                     : 1;  /**< SMEM ECC double bit error. Throws PKI_INTSN_E::PKI_CL()_ECC_SMEM_DBE. */
+	uint64_t smem_sbe                     : 1;  /**< SMEM ECC single bit error. Throws PKI_INTSN_E::PKI_CL()_ECC_SMEM_SBE. */
+	uint64_t dmem_perr                    : 1;  /**< DMEM parity error. Throws PKI_INTSN_E::PKI_CL()_ECC_DMEM_PERR. */
+	uint64_t rf_perr                      : 1;  /**< RF RAM parity error. Throws PKI_INTSN_E::PKI_CL()_ECC_RF_PERR. */
 #else
 	uint64_t rf_perr                      : 1;
 	uint64_t dmem_perr                    : 1;
@@ -1431,17 +1431,17 @@ union cvmx_pki_clx_int {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_5_63                : 59;
 	uint64_t trapz                        : 1;  /**< Reserved. INTERNAL: Deprecated. PCAM sequencer trapz interrupt. Throws
-                                                         PKI_INTSN_E::PKI_CL(0..3)_INT_TRAPZ. Caused by TRAP sequence state, may indicate PKI
-                                                         enabled without proper sequencer code loaded in PKI_IMEM(0..2047). Based on PCAM sequencer
+                                                         PKI_INTSN_E::PKI_CL()_INT_TRAPZ. Caused by TRAP sequence state, may indicate PKI
+                                                         enabled without proper sequencer code loaded in PKI_IMEM(). Based on PCAM sequencer
                                                          execution, will likely throw an additional IPTINT interrupt. */
-	uint64_t iptint                       : 1;  /**< PCAM sequencer debug interrupt. Throws PKI_INTSN_E::PKI_CL(0..3)_INT_IPTINT. INTERNAL:
+	uint64_t iptint                       : 1;  /**< PCAM sequencer debug interrupt. Throws PKI_INTSN_E::PKI_CL()_INT_IPTINT. INTERNAL:
                                                          Caused by TRAP or INTR sequence state. */
 	uint64_t sched_conf                   : 1;  /**< PCAM/SMEM internal port conflict. Internal error, should not occur. Throws
-                                                         PKI_INTSN_E::PKI_CL(0..3)_INT_SCHED_CONF. INTERNAL: Sequencer mis-scheduled PCAM or SMEM
+                                                         PKI_INTSN_E::PKI_CL()_INT_SCHED_CONF. INTERNAL: Sequencer mis-scheduled PCAM or SMEM
                                                          ops with overlapping accesses. */
-	uint64_t pcam_conf                    : 2;  /**< PCAM(0..1) match hit multiple rows, indicating either a soft error in the PCAM or a
-                                                         programming error in PKI_CL(0..3)_PCAM(0..1)_MATCH(0..191) or related registers. Throws
-                                                         PKI_INTSN_E::PKI_CL(0..3)_INT_PCAM_CONF(0..1). Once a conflict is detected, the PCAM state
+	uint64_t pcam_conf                    : 2;  /**< PCAM() match hit multiple rows, indicating either a soft error in the PCAM or a
+                                                         programming error in PKI_CL()_PCAM()_MATCH() or related registers. Throws
+                                                         PKI_INTSN_E::PKI_CL()_INT_PCAM_CONF(). Once a conflict is detected, the PCAM state
                                                          is unpredictable and is required to be fully reconfigured before further valid processing
                                                          can take place. */
 #else
@@ -1467,49 +1467,44 @@ union cvmx_pki_clx_pcamx_actionx {
 	struct cvmx_pki_clx_pcamx_actionx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_31_63               : 33;
-	uint64_t pmc                          : 7;  /**< Parse Mode Change. Where to resume parsing after applying the scan offset (if any) as bit
+	uint64_t pmc                          : 7;  /**< Parse mode change. Where to resume parsing after applying the scan offset (if any) as bit
                                                          mask of which sequence steps to no longer process:
-                                                         <0> = LA (L2)
-                                                         <1> = LB (Custom)
-                                                         <2> = LC (L3)
-                                                         <3> = LD (Virt)
-                                                         <4> = LE (IL3)
-                                                         <5> = LF (L4)
-                                                         <6> = LG (Custom/Application)
+                                                         _ <0> = LA (L2)
+                                                         _ <1> = LB (Custom)
+                                                         _ <2> = LC (L3)
+                                                         _ <3> = LD (Virt)
+                                                         _ <4> = LE (IL3)
+                                                         _ <5> = LF (L4)
+                                                         _ <6> = LG (Custom/Application)
                                                          The legal values are:
-                                                         0x0 = no change in parsing
-                                                         0x1 = Skip further LA parsing; start LB parsing.
-                                                         For TERM==L2_CUSTOM only)
-                                                         0x3 = Skip further LA/LB parsing; start LC parsing.
-                                                         For TERMs through Ethertypes only)
-                                                         0x7 = Skip further LA-LC parsing; start LD parsing.
-                                                         For TERMs through L3FLAGS only)
-                                                         0x7F = Skip all parsing; no further packet inspection.
-                                                         For TERMs through L3FLAGS only)
+                                                         0x0 = no change in parsing.
+                                                         0x1 = Skip further LA parsing; start LB parsing. For TERM==L2_CUSTOM only).
+                                                         0x3 = Skip further LA/LB parsing; start LC parsing. For TERMs through Ethertypes only).
+                                                         0x7 = Skip further LA-LC parsing; start LD parsing. For TERMs through L3FLAGS only).
+                                                         0x7F = Skip all parsing; no further packet inspection. For TERMs through L3FLAGS only).
                                                          For example an Ethertype match action that wishes to resume with additional Ethertype
                                                          matches would use a zero PMC to indicate no parse mode change. An Ethertype match action
                                                          that wishes to not parse any additional Ethertypes and resume at LC would use 0x3.
                                                          Must be zero for invalid entries, or for TERMs that do not allow a parse mode change as
-                                                         specified in the PKI_PCAM_TERM_E table.
-                                                         See also Parse Mode. */
+                                                         specified in the PKI_PCAM_TERM_E table. */
 	uint64_t style_add                    : 8;  /**< Resulting interim style adder. If this CAM entry matches, the value to add to the current
-                                                         style (may wrap around through 256). See Styles. Must be zero for invalid entries. */
+                                                         style (may wrap around through 256). Must be zero for invalid entries. */
 	uint64_t pf                           : 3;  /**< Parse flag to set. Specifies the parse flag to set when entry matches, see PCAM actions
                                                          may also specify setting one of four user flags in the generated work queue entry,
                                                          WQE[PF1] through WQE[PF4]. These flags are not used by hardware; they are intended to
                                                          indicate to software that exceptional handling may be required, such as the presence of an
-                                                         encrypted packet.:
-                                                         0x0 = no change.
-                                                         0x1 = Set WQE[PF1].
-                                                         0x2 = Set WQE[PF2].
-                                                         0x3 = Set WQE[PF3].
-                                                         0x4 = Set WQE[PF4].
-                                                         else = reserved.
+                                                         encrypted packet:
+                                                         _ 0x0 = no change.
+                                                         _ 0x1 = Set WQE[PF1].
+                                                         _ 0x2 = Set WQE[PF2].
+                                                         _ 0x3 = Set WQE[PF3].
+                                                         _ 0x4 = Set WQE[PF4].
+                                                         _ else = reserved.
                                                          Must be zero for invalid entries. */
 	uint64_t setty                        : 5;  /**< Set pointer type. If non-zero, indicates the layer type to be set as described under
                                                          PKI_PCAM_TERM_E. Values are enumerated in PKI_LTYPE_E. Must be zero for invalid entries. */
-	uint64_t advance                      : 8;  /**< Relative number of bytes to advance scan pointer when entry matches. See Parser Skip and
-                                                         Advancing. Must be even. Must be zero for invalid entries and for TERMs that do not allow
+	uint64_t advance                      : 8;  /**< Relative number of bytes to advance scan pointer when entry matches.
+                                                         Must be even. Must be zero for invalid entries and for TERMs that do not allow
                                                          an advance as specified in the PKI_PCAM_TERM_E table. */
 #else
 	uint64_t advance                      : 8;
@@ -1531,16 +1526,15 @@ union cvmx_pki_clx_pcamx_matchx {
 	uint64_t u64;
 	struct cvmx_pki_clx_pcamx_matchx_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t data1                        : 32; /**< See DATA0. */
+	uint64_t data1                        : 32; /**< See [DATA0]. */
 	uint64_t data0                        : 32; /**< The packet data to compare against. Bits may be ignored in comparison based on [DATA0] and
-                                                         [DATA1]. If the entry matches, PKI_CL(0..3)_PCAM(0..1)_ACTION(0..191) will determine the
+                                                         [DATA1]. If the entry matches, PKI_CL()_PCAM()_ACTION() will determine the
                                                          action to be taken. See PKI_PCAM_TERM_E for comparison bit definitions.
                                                          The field value is ternary, where each bit matches as follows:
-                                                         DATA1<n> DATA0<n>
-                                                         0 0 Always match; data<n> don't care.
-                                                         0 1 Match when data<n> == 0.
-                                                         1 0 Match when data<n> == 1.
-                                                         1 1 Reserved. */
+                                                         _ DATA1<n>=0, DATA0<n>=0: Always match; data<n> don't care.
+                                                         _ DATA1<n>=0, DATA0<n>=1: Match when data<n> == 0.
+                                                         _ DATA1<n>=1, DATA0<n>=0: Match when data<n> == 1.
+                                                         _ DATA1<n>=1, DATA0<n>=1: Reserved. */
 #else
 	uint64_t data0                        : 32;
 	uint64_t data1                        : 32;
@@ -1559,26 +1553,24 @@ union cvmx_pki_clx_pcamx_termx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t valid                        : 1;  /**< Valid. */
 	uint64_t reserved_48_62               : 15;
-	uint64_t term1                        : 8;  /**< See TERM0. */
-	uint64_t style1                       : 8;  /**< See STYLE0. */
+	uint64_t term1                        : 8;  /**< See [TERM0]. */
+	uint64_t style1                       : 8;  /**< See [STYLE0]. */
 	uint64_t reserved_16_31               : 16;
 	uint64_t term0                        : 8;  /**< Comparison type. Enumerated with PKI_PCAM_TERM_E. The field value is ternary, where each
                                                          bit matches as follows:
-                                                         TERM1<n> TERM0<n>
-                                                         0 0 Always match; data<n> don't care.
-                                                         0 1 Match when data<n> == 0.
-                                                         1 0 Match when data<n> == 1.
-                                                         1 1 Reserved. */
+                                                         _ TERM1<n>=0, TERM0<n>=0: Always match; data<n> don't care.
+                                                         _ TERM1<n>=0, TERM0<n>=1: Match when data<n> == 0.
+                                                         _ TERM1<n>=1, TERM0<n>=0: Match when data<n> == 1.
+                                                         _ TERM1<n>=1, TERM0<n>=1: Reserved. */
 	uint64_t style0                       : 8;  /**< Previous interim style. The style that must have been calculated by the port
-                                                         PKI_CL(0..3)_PKIND(0..63)_STYLE[STYLE] or as modified by previous CAM hits's
-                                                         PKI_CL(0..3)_PCAM(0..1)_ACTION(0..191)[STYLE]. This is used to form AND style matches; see
+                                                         PKI_CL()_PKIND()_STYLE[STYLE] or as modified by previous CAM hits's
+                                                         PKI_CL()_PCAM()_ACTION()[STYLE]. This is used to form AND style matches; see
                                                          Styles.
                                                          The field value is ternary, where each bit matches as follows:
-                                                         STYLE1<n> STYLE0<n>
-                                                         0 0 Always match; data<n> don't care.
-                                                         0 1 Match when data<n> == 0.
-                                                         1 0 Match when data<n> == 1.
-                                                         1 1 Reserved. */
+                                                         _ STYLE1<n>=0, STYLE0<n>=0: Always match; data<n> don't care.
+                                                         _ STYLE1<n>=0, STYLE0<n>=1: Match when data<n> == 0.
+                                                         _ STYLE1<n>=1, STYLE0<n>=0: Match when data<n> == 1.
+                                                         _ STYLE1<n>=1, STYLE0<n>=1: Reserved. */
 #else
 	uint64_t style0                       : 8;
 	uint64_t term0                        : 8;
@@ -1605,7 +1597,7 @@ union cvmx_pki_clx_pkindx_cfg {
                                                          0 = FCS not present. FCS may not be checked nor stripped.
                                                          1 = FCS present; the last four bytes of the packet are part of the FCS and may not be
                                                          considered part of a IP, TCP or other header for length error checks.
-                                                         PKI_CL(0..3)_STYLE(0..63)_CFG[FCS_CHK or FCS_STRIP] may optionally be set. */
+                                                         PKI_CL()_STYLE()_CFG[FCS_CHK or FCS_STRIP] may optionally be set. */
 	uint64_t mpls_en                      : 1;  /**< Enable MPLS parsing.
                                                          0 = Any MPLS labels are ignored, but may be handled by custom Ethertype PCAM matchers.
                                                          1 = MPLS label stacks are parsed and skipped over. PKI_GBL_PEN[MPLS_PEN] must be set. */
@@ -1650,10 +1642,10 @@ typedef union cvmx_pki_clx_pkindx_cfg cvmx_pki_clx_pkindx_cfg_t;
  * cvmx_pki_cl#_pkind#_kmem#
  *
  * The register initialization value for each PKIND and register number (plus 32 or 48 based on
- * PKI_ICG(0..3)_CFG[MLO]). The other PKI_PKND* registers alias inside regions of
- * PKI_CL(0..3)_PKIND(0..63)_KMEM(0..15). To avoid confusing tools, these aliases have address
+ * PKI_ICG()_CFG[MLO]). The other PKI_PKND* registers alias inside regions of
+ * PKI_CL()_PKIND()_KMEM(). To avoid confusing tools, these aliases have address
  * bit 20 set; the PKI address decoder ignores bit 20 when accessing
- * PKI_CL(0..3)_PKIND(0..63)_KMEM(0..15).
+ * PKI_CL()_PKIND()_KMEM().
  */
 union cvmx_pki_clx_pkindx_kmemx {
 	uint64_t u64;
@@ -1728,7 +1720,7 @@ union cvmx_pki_clx_pkindx_skip {
                                                          even. If PTP_MODE, the 8-byte timestamp is prepended to the packet, and FCS_SKIP must be
                                                          at least 8. */
 	uint64_t inst_skip                    : 8;  /**< Skip amount from front of packet to begin parsing at. If
-                                                         PKI_CL(0..3)_PKIND(0..63)_CFG[INST_HDR] is set, points at the first byte of the
+                                                         PKI_CL()_PKIND()_CFG[INST_HDR] is set, points at the first byte of the
                                                          instruction header. If INST_HDR is clear, points at the first byte to begin parsing at.
                                                          The skip must be even. If PTP_MODE, the 8-byte timestamp is prepended to the packet, and
                                                          INST_SKIP must be at least 8. */
@@ -1751,20 +1743,20 @@ union cvmx_pki_clx_pkindx_style {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_15_63               : 49;
 	uint64_t pm                           : 7;  /**< Initial parse mode. Bit mask of which sequence steps to perform, refer to Parse Mode:
-                                                         <0> = LA (L2)
-                                                         <1> = LB (Custom)
-                                                         <2> = LC (L3)
-                                                         <3> = LD (L4 Virt)
-                                                         <4> = LE (IL3)
-                                                         <5> = LF (L4)
-                                                         <6> = LG (Custom/Application)
+                                                         _ <0> = LA (L2)
+                                                         _ <1> = LB (Custom)
+                                                         _ <2> = LC (L3)
+                                                         _ <3> = LD (L4 Virt)
+                                                         _ <4> = LE (IL3)
+                                                         _ <5> = LF (L4)
+                                                         _ <6> = LG (Custom/Application)
                                                          The legal values are:
-                                                         0x0 =   Parse LA..LG
-                                                         0x1 =   Parse LB..LG
-                                                         0x3 =   Parse LC..LG
-                                                         0x3F = Parse LG
-                                                         0x7F = Parse nothing
-                                                         else = Reserved */
+                                                         _ 0x0 = Parse LA..LG
+                                                         _ 0x1 = Parse LB..LG
+                                                         _ 0x3 = Parse LC..LG
+                                                         _ 0x3F = Parse LG
+                                                         _ 0x7F = Parse nothing
+                                                         _ else = Reserved */
 	uint64_t style                        : 8;  /**< Initial style. Initial style number for packets on this port, will remain as final style
                                                          if no PCAM entries match the packet. Note only 64 final styles exist, the upper two bits
                                                          will only be used for PCAM matching. */
@@ -1781,9 +1773,9 @@ typedef union cvmx_pki_clx_pkindx_style cvmx_pki_clx_pkindx_style_t;
 /**
  * cvmx_pki_cl#_smem#
  *
- * PKI_STYLE* registers alias inside regions of PKI_CL(0..3)_SMEM(0..2047). To avoid confusing
+ * PKI_STYLE* registers alias inside regions of PKI_CL()_SMEM(). To avoid confusing
  * tools, these aliases have address bit 20 set; the PKI address decoder ignores bit 20 when
- * accessing PKI_CL(0..3)_SMEM(0..2047).
+ * accessing PKI_CL()_SMEM().
  */
 union cvmx_pki_clx_smemx {
 	uint64_t u64;
@@ -1900,31 +1892,31 @@ union cvmx_pki_clx_stylex_cfg {
                                                          including VLAN tags.
                                                          1 = Length check uses equal comparison. Packets must have the exact padding necessary to
                                                          insure a minimum frame size and no more. */
-	uint64_t minmax_sel                   : 1;  /**< Selects which PKI_FRM_LEN_CHK(0..1) register is used for this pkind for MINERR and MAXERR
+	uint64_t minmax_sel                   : 1;  /**< Selects which PKI_FRM_LEN_CHK() register is used for this pkind for MINERR and MAXERR
                                                          checks.
-                                                         0 = use PKI_FRM_LEN_CHK0
-                                                         1 = use PKI_FRM_LEN_CHK1 */
+                                                         0 = use PKI_FRM_LEN_CHK0.
+                                                         1 = use PKI_FRM_LEN_CHK1. */
 	uint64_t maxerr_en                    : 1;  /**< Max frame error check enable. */
 	uint64_t minerr_en                    : 1;  /**< Min frame error check enable. This check is typically not enabled for incoming packets on
                                                          the DPI ports. */
 	uint64_t qpg_dis_grptag               : 1;  /**< Disable computing group using WQE[TAG]. */
 	uint64_t fcs_strip                    : 1;  /**< Strip L2 FCS bytes from packet, decrease WQE[LEN] by 4 bytes.
-                                                         PKI_CL(0..3)_PKIND(0..63)_CFG[FCS_PRES] must be set. */
-	uint64_t fcs_chk                      : 1;  /**< FCS checking enabled. PKI_CL(0..3)_PKIND(0..63)_CFG[FCS_PRES] must be set. */
+                                                         PKI_CL()_PKIND()_CFG[FCS_PRES] must be set. */
+	uint64_t fcs_chk                      : 1;  /**< FCS checking enabled. PKI_CL()_PKIND()_CFG[FCS_PRES] must be set. */
 	uint64_t rawdrp                       : 1;  /**< Allow RAW packet drop.
                                                          0 = Never drop packets with WQE[RAW] set.
-                                                         1 = Allow the PKI to drop RAW packets based on PKI_AURA(0..1023)_CFG[ENA_RED/ENA_DROP]. */
+                                                         1 = Allow the PKI to drop RAW packets based on PKI_AURA()_CFG[ENA_RED/ENA_DROP]. */
 	uint64_t drop                         : 1;  /**< Force packet dropping.
-                                                         0 = Drop packet based on PKI_AURA(0..1023)_CFG[ENA_RED/ENA_DROP].
-                                                         1 = Always drop the packet. Overrides NODROP, RAWDRP. */
+                                                         0 = Drop packet based on PKI_AURA()_CFG[ENA_RED/ENA_DROP].
+                                                         1 = Always drop the packet. Overrides [NODROP], [RAWDRP]. */
 	uint64_t nodrop                       : 1;  /**< Disable QoS packet drop.
-                                                         0 = Allowed to drop packet based on PKI_AURA(0..1023)_CFG[ENA_RED/ENA_DROP].
-                                                         1 = Never drop the packet. Overrides RAWDRP. */
+                                                         0 = Allowed to drop packet based on PKI_AURA()_CFG[ENA_RED/ENA_DROP].
+                                                         1 = Never drop the packet. Overrides [RAWDRP]. */
 	uint64_t qpg_dis_padd                 : 1;  /**< Disable computing port adder by QPG algorithm. */
 	uint64_t qpg_dis_grp                  : 1;  /**< Disable computing group by QPG algorithm. */
 	uint64_t qpg_dis_aura                 : 1;  /**< Disable computing aura by QPG algorithm. */
 	uint64_t reserved_11_15               : 5;
-	uint64_t qpg_base                     : 11; /**< Base index into PKI_QPG_TBL(0..2047). INTERNAL: Sequencer starts with QPG_BASE, performs
+	uint64_t qpg_base                     : 11; /**< Base index into PKI_QPG_TBL(). INTERNAL: Sequencer starts with QPG_BASE, performs
                                                          the QPG calculation and packs the resulting QPG index back into this field for PKI_BE_S. */
 #else
 	uint64_t qpg_base                     : 11;
@@ -1959,10 +1951,10 @@ union cvmx_pki_clx_stylex_cfg2 {
 	struct cvmx_pki_clx_stylex_cfg2_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_32_63               : 32;
-	uint64_t tag_inc                      : 4;  /**< Include masked tags using PKI_TAG_INC(0..31)_MASK. Each bit indicates to include the
+	uint64_t tag_inc                      : 4;  /**< Include masked tags using PKI_TAG_INC()_MASK. Each bit indicates to include the
                                                          corresponding PKI_TAG_INC_MASK range, see PKI_INST_HDR_S. */
 	uint64_t reserved_25_27               : 3;
-	uint64_t tag_masken                   : 1;  /**< Apply PKI_STYLE(0..63)_TAG_MASK to computed tag. INTERNAL: Sequencer must clear for PKI BE
+	uint64_t tag_masken                   : 1;  /**< Apply PKI_STYLE()_TAG_MASK to computed tag. INTERNAL: Sequencer must clear for PKI BE
                                                          when the tag comes from the PKI_INST_HDR_S. */
 	uint64_t tag_src_lg                   : 1;  /**< Include Layer G source address in tuple tag generation. */
 	uint64_t tag_src_lf                   : 1;  /**< Include Layer F source address in tuple tag generation. */
@@ -2034,7 +2026,7 @@ union cvmx_pki_clken {
 	struct cvmx_pki_clken_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t clken                        : 1;  /**< Controls the conditional clocking within PKI
+	uint64_t clken                        : 1;  /**< Controls the conditional clocking within PKI.
                                                          0 = Allow hardware to control the clocks.
                                                          1 = Force the clocks to be always on. */
 #else
@@ -2369,11 +2361,11 @@ union cvmx_pki_gbl_pen {
                                                          reductions.
                                                          1 = VXLAN/NVGRE parsing may be used. */
 	uint64_t clg_pen                      : 1;  /**< Custom LG parsing enable.
-                                                         0 = Custom LG is never used in any style; i.e. PKI_CL(0..3)_PKIND(0..63)_CFG[LG_CUSTOM] is
+                                                         0 = Custom LG is never used in any style; i.e. PKI_CL()_PKIND()_CFG[LG_CUSTOM] is
                                                          zero for all indices. This enables internal power and latency reductions.
                                                          1 = Custom LG parsing may be used. */
 	uint64_t cl2_pen                      : 1;  /**< Custom L2 parsing enable.
-                                                         0 = Custom L2 is never used in any style; i.e. PKI_CL(0..3)_PKIND(0..63)_L2_CUSTOM[VALID]
+                                                         0 = Custom L2 is never used in any style; i.e. PKI_CL()_PKIND()_L2_CUSTOM[VALID]
                                                          is zero for all indices. This enables internal power and latency reductions.
                                                          1 = Custom L2 parsing may be used. */
 	uint64_t l4_pen                       : 1;  /**< L4 parsing enable.
@@ -2389,20 +2381,20 @@ union cvmx_pki_gbl_pen {
                                                          reductions.
                                                          1 = L3 parsing may be used. */
 	uint64_t mpls_pen                     : 1;  /**< MPLS parsing enable.
-                                                         0 = MPLS parsing is never used in any style; i.e. PKI_CL(0..3)_PKIND(0..63)_CFG[MPLS_EN]
+                                                         0 = MPLS parsing is never used in any style; i.e. PKI_CL()_PKIND()_CFG[MPLS_EN]
                                                          is zero for all indices. This enables internal power and latency reductions.
                                                          1 = MPLS parsing may be used. */
 	uint64_t fulc_pen                     : 1;  /**< Fulcrum parsing enable.
                                                          0 = Fulcrum parsing is never used in any style; i.e.
-                                                         PKI_CL(0..3)_PKIND(0..63)_CFG[FULC_EN] is zero for all indices. This enables internal
+                                                         PKI_CL()_PKIND()_CFG[FULC_EN] is zero for all indices. This enables internal
                                                          power and latency reductions.
                                                          1 = Fulcrum parsing may be used. */
 	uint64_t dsa_pen                      : 1;  /**< DSA parsing enable. Must be zero if HG_PEN is set.
-                                                         0 = DSA parsing is never used in any style; i.e. PKI_CL(0..3)_PKIND(0..63)_CFG[DSA_EN] is
+                                                         0 = DSA parsing is never used in any style; i.e. PKI_CL()_PKIND()_CFG[DSA_EN] is
                                                          zero for all indices. This enables internal power and latency reductions.
                                                          1 = DSA parsing may be used. */
 	uint64_t hg_pen                       : 1;  /**< HiGig parsing enable. Must be zero if DSA_PEN is set.
-                                                         0 = HiGig parsing is never used in any style; i.e. PKI_CL(0..3)_PKIND(0..63)_CFG[HG2_EN,
+                                                         0 = HiGig parsing is never used in any style; i.e. PKI_CL()_PKIND()_CFG[HG2_EN,
                                                          HG_EN] are zero for all indices. This enables internal power and latency reductions.
                                                          1 = HiGig parsing may be used. */
 #else
@@ -2603,7 +2595,7 @@ union cvmx_pki_pcam_result {
 	uint64_t reserved_41_63               : 23;
 	uint64_t match                        : 1;  /**< Resulting match. */
 	uint64_t entry                        : 8;  /**< Resulting matching entry number, unpredictable unless [MATCH] set and [CONFLICT] is clear. */
-	uint64_t result                       : 32; /**< Resulting data from matching line's PKI_CL(0..3)_PCAM(0..1)_ACTION(0..191), or zero if no
+	uint64_t result                       : 32; /**< Resulting data from matching line's PKI_CL()_PCAM()_ACTION(), or zero if no
                                                          match. Unpredictable unless [CONFLICT] is clear. */
 #else
 	uint64_t result                       : 32;
@@ -2619,7 +2611,7 @@ union cvmx_pki_pcam_result {
 	uint64_t reserved_41_62               : 22;
 	uint64_t match                        : 1;  /**< Resulting match. */
 	uint64_t entry                        : 8;  /**< Resulting matching entry number, unpredictable unless [MATCH] set and [CONFLICT] is clear. */
-	uint64_t result                       : 32; /**< Resulting data from matching line's PKI_CL(0..3)_PCAM(0..1)_ACTION(0..191), or zero if no
+	uint64_t result                       : 32; /**< Resulting data from matching line's PKI_CL()_PCAM()_ACTION(), or zero if no
                                                          match. Unpredictable unless [CONFLICT] is clear. */
 #else
 	uint64_t result                       : 32;
@@ -2698,7 +2690,7 @@ union cvmx_pki_pkindx_icgsel {
 	struct cvmx_pki_pkindx_icgsel_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_2_63                : 62;
-	uint64_t icg                          : 2;  /**< Cluster group that will service traffic on this pkind. See also PKI_ICG(0..3)_CFG, the
+	uint64_t icg                          : 2;  /**< Cluster group that will service traffic on this pkind. See also PKI_ICG()_CFG, the
                                                          register to which this field indexes. */
 #else
 	uint64_t icg                          : 2;
@@ -3167,7 +3159,7 @@ union cvmx_pki_statx_stat14 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t drp_bcast                    : 48; /**< Number of packets with L2 broadcast DMAC that were dropped by RED, buffer exhaustion, or
-                                                         PKI_CL(0..3)_STYLE(0..63)_CFG[DROP]. See WQE[L2B] for the definition of L2 broadcast. */
+                                                         PKI_CL()_STYLE()_CFG[DROP]. See WQE[L2B] for the definition of L2 broadcast. */
 #else
 	uint64_t drp_bcast                    : 48;
 	uint64_t reserved_48_63               : 16;
@@ -3186,7 +3178,7 @@ union cvmx_pki_statx_stat15 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
 	uint64_t drp_mcast                    : 48; /**< Number of packets with L2 multicast DMAC that were dropped by RED, buffer exhaustion, or
-                                                         PKI_CL(0..3)_STYLE(0..63)_CFG[DROP]. See WQE[L2M] for the definition of L2 multicast. */
+                                                         PKI_CL()_STYLE()_CFG[DROP]. See WQE[L2M] for the definition of L2 multicast. */
 #else
 	uint64_t drp_mcast                    : 48;
 	uint64_t reserved_48_63               : 16;
@@ -3279,7 +3271,7 @@ union cvmx_pki_statx_stat3 {
 	struct cvmx_pki_statx_stat3_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t drp_pkts                     : 48; /**< Inbound packets dropped by RED, buffer exhaustion, or PKI_CL(0..3)_STYLE(0..63)_CFG[DROP]. */
+	uint64_t drp_pkts                     : 48; /**< Inbound packets dropped by RED, buffer exhaustion, or PKI_CL()_STYLE()_CFG[DROP]. */
 #else
 	uint64_t drp_pkts                     : 48;
 	uint64_t reserved_48_63               : 16;
@@ -3297,7 +3289,7 @@ union cvmx_pki_statx_stat4 {
 	struct cvmx_pki_statx_stat4_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_48_63               : 16;
-	uint64_t drp_octs                     : 48; /**< Inbound octets dropped by RED, buffer exhaustion, or PKI_CL(0..3)_STYLE(0..63)_CFG[DROP]. */
+	uint64_t drp_octs                     : 48; /**< Inbound octets dropped by RED, buffer exhaustion, or PKI_CL()_STYLE()_CFG[DROP]. */
 #else
 	uint64_t drp_octs                     : 48;
 	uint64_t reserved_48_63               : 16;
@@ -3412,9 +3404,9 @@ union cvmx_pki_stat_ctl {
 	uint64_t reserved_2_63                : 62;
 	uint64_t mode                         : 2;  /**< The PKI_STAT*_X registers can be indexed either by port kind (pkind), or final style.
                                                          (Does not apply to the PKI_STAT_INB* registers.)
-                                                         0 = X represents the packet's pkind
-                                                         1 = X represents the low 6-bits of packet's final style
-                                                         2,3 = Reserved */
+                                                         _ 0x0 = X represents the packet's pkind.
+                                                         _ 0x1 = X represents the low 6-bits of packet's final style.
+                                                         _ 0x2-0x3 = Reserved. */
 #else
 	uint64_t mode                         : 2;
 	uint64_t reserved_2_63                : 62;
@@ -3436,10 +3428,9 @@ union cvmx_pki_stylex_buf {
                                                          endian. Does not change the WQE header format, which is properly endian neutral. */
 	uint64_t wqe_hsz                      : 2;  /**< Work queue header size:
                                                          0x0 = WORD0..4, standard WQE_S. Note FIRST_SKIP may be set to not include WORD4 in memory.
-                                                         0x1 = WORD0..5
-                                                         0x2 = WORD0..6
-                                                         0x3 = WORD0..7
-                                                         else = Reserved
+                                                         0x1 = WORD0..5.
+                                                         0x2 = WORD0..6.
+                                                         0x3 = WORD0..7.
                                                          INTERNAL: Selects which PIX words are transferred to the PKI BE. If a word is not
                                                          transferred and the word will reach memory (FIRST_SKIP is greater than that word number),
                                                          then the final WQE memory word will be zero, not the PIX register contents. */
@@ -3448,19 +3439,20 @@ union cvmx_pki_stylex_buf {
 	uint64_t first_skip                   : 6;  /**< The number of eight-byte words from the top of the first MBUF that the PKI stores the next
                                                          pointer. If [DIS_WQ_DAT]=1, any value is legal. If [DIS_WQ_DAT]=0, legal values must
                                                          satisfy:
-                                                         * FIRST_SKIP <= PKI_STYLE(0..63)_BUF[MB_SIZE] - 18.
+                                                         * FIRST_SKIP <= PKI_STYLE()_BUF[MB_SIZE] - 18.
                                                          * FIRST_SKIP must be at least 0x4, but 0x5 is recommended minimum. 0x4 will drop WQE
                                                          WORD4, for use in backward compatible applications.
                                                          * WQE_SKIP * (128/8) + 4 <= FIRST_SKIP, to insure the minimum of four work-queue entry
                                                          words will fit within FIRST_SKIP. */
 	uint64_t later_skip                   : 6;  /**< The number of eight-byte words from the top of any MBUF that is not the first MBUF that
-                                                         PKI writes the next-pointer to. Legal values are 0 to PKI_STYLE(0..63)_BUF[MB_SIZE] - 18. */
+                                                         PKI writes the next-pointer to. Legal values are 0 to PKI_STYLE()_BUF[MB_SIZE] - 18. */
 	uint64_t opc_mode                     : 2;  /**< Select the style of write to the L2C.
-                                                         0 = all packet data and next-buffer pointers are written through to memory.
-                                                         1 = all packet data and next-buffer pointers are written into the cache.
-                                                         2 = the first aligned cache block holding the WQE and/or front packet data are written to
+                                                         0x0 = all packet data and next-buffer pointers are written through to memory.
+                                                         0x1 = all packet data and next-buffer pointers are written into the cache.
+                                                         0x2 = the first aligned cache block holding the WQE and/or front packet data are written
+                                                         to
                                                          the L2 cache. All remaining cache blocks are not written to the L2 cache.
-                                                         3 = the first two aligned cache blocks holding the WQE and front packet data are written
+                                                         0x3 = the first two aligned cache blocks holding the WQE and front packet data are written
                                                          to the L2 cache. All remaining cache blocks are not written to the L2 cache. */
 	uint64_t dis_wq_dat                   : 1;  /**< Separate first data buffer from the work queue entry.
                                                          0 = The packet link pointer will be at word [FIRST_SKIP] immediately followed by packet
@@ -3498,8 +3490,8 @@ union cvmx_pki_stylex_tag_mask {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_16_63               : 48;
 	uint64_t mask                         : 16; /**< When set, each bit excludes corresponding bit of the tuple computed tag from being
-                                                         included in the final tag. PKI_CL(0..3)_STYLE(0..63)_CFG2 [TAG_MASKEN] must be set. Does
-                                                         not affect tags from packets with a PKI_INST_HDR_S when PKI_INST_HDR[UTAG] is set. */
+                                                         included in the final tag. PKI_CL()_STYLE()_CFG2 [TAG_MASKEN] must be set. Does
+                                                         not affect tags from packets with a PKI_INST_HDR_S when PKI_INST_HDR_S[UTAG] is set. */
 #else
 	uint64_t mask                         : 16;
 	uint64_t reserved_16_63               : 48;
@@ -3523,7 +3515,7 @@ union cvmx_pki_stylex_tag_sel {
 	uint64_t reserved_11_15               : 5;
 	uint64_t tag_idx1                     : 3;  /**< Index for TAG_INC<1>. */
 	uint64_t reserved_3_7                 : 5;
-	uint64_t tag_idx0                     : 3;  /**< Index for TAG_INC<0>. This value is multipled by 4 to index into PKI_TAG_INC(0..31)_MASK.
+	uint64_t tag_idx0                     : 3;  /**< Index for TAG_INC<0>. This value is multipled by 4 to index into PKI_TAG_INC()_MASK.
                                                          See WQE[TAG]. */
 #else
 	uint64_t tag_idx0                     : 3;
@@ -3584,7 +3576,7 @@ union cvmx_pki_tag_incx_ctl {
 	struct cvmx_pki_tag_incx_ctl_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_12_63               : 52;
-	uint64_t ptr_sel                      : 4;  /**< Which pointer to use for the bitmask in PKI_TAG_INC(0..31)_MASK.
+	uint64_t ptr_sel                      : 4;  /**< Which pointer to use for the bitmask in PKI_TAG_INC()_MASK.
                                                          0 = Absolute from start of packet.
                                                          1-7 = Reserved.
                                                          8 = Relative to start of WQE[LAPTR]. LAPTR must be valid (see WQE[LAPTR]) or mask is
@@ -3604,7 +3596,7 @@ union cvmx_pki_tag_incx_ctl {
                                                          15 = Relative to start of WQE[VLPTR]. VLPTR must be valid (see WQE[VLPTR]) or mask is
                                                          ignored.
                                                          INTERNAL: Note excluding 0, the encoding matches the byte number to read from WQE WORD4. */
-	uint64_t offset                       : 8;  /**< Offset for PKI_TAG_INC(0..31)_MASK. Number of bytes to add to the selected pointer before
+	uint64_t offset                       : 8;  /**< Offset for PKI_TAG_INC()_MASK. Number of bytes to add to the selected pointer before
                                                          applying the mask. */
 #else
 	uint64_t offset                       : 8;
@@ -3624,7 +3616,7 @@ union cvmx_pki_tag_incx_mask {
 	struct cvmx_pki_tag_incx_mask_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t en                           : 64; /**< Include byte in mask-tag algorithm. Each EN bit corresponds to 64 consecutive bytes in the
-                                                         data stream, as controlled by PKI_TAG_INC(0..31)_CTL as described in WQE[TAG]. */
+                                                         data stream, as controlled by PKI_TAG_INC()_CTL as described in WQE[TAG]. */
 #else
 	uint64_t en                           : 64;
 #endif
diff --git a/arch/mips/include/asm/octeon/cvmx-pko3.h b/arch/mips/include/asm/octeon/cvmx-pko3.h
index a2a573e..c8c32c4 100644
--- a/arch/mips/include/asm/octeon/cvmx-pko3.h
+++ b/arch/mips/include/asm/octeon/cvmx-pko3.h
@@ -575,6 +575,8 @@ extern int cvmx_pko3_interface_options(int xiface, int index,
  */
 extern void cvmx_pko3_dq_options(unsigned node, unsigned dq, bool min_pad);
 
+extern int cvmx_pko3_internal_buffer_count(unsigned node);
+
 /* Packet descriptor - PKO3 command buffer + internal state */
 typedef struct cvmx_pko3_pdesc_s {
 	uint64_t *jump_buf;	/**< jump buffer vaddr */
diff --git a/arch/mips/include/asm/octeon/cvmx-rst-defs.h b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
index 398c6a9..7b49c41 100644
--- a/arch/mips/include/asm/octeon/cvmx-rst-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-rst-defs.h
@@ -332,7 +332,7 @@ union cvmx_rst_ctlx {
                                                          reset, this field is initialized as follows:
                                                          0 when RST_CTL*[HOST_MODE] = 0
                                                          1 when RST_CTL*[HOST_MODE] = 1
-                                                         When set, CN78XX drives the corresponding PERST*_L pin. Otherwise, CN78XX does not drive
+                                                         When set, CNXXXX drives the corresponding PERST*_L pin. Otherwise, CNXXXX does not drive
                                                          the corresponding PERST*_L pin. */
 	uint64_t rst_rcv                      : 1;  /**< Controls whether PERST*_L is received. A warm/soft reset will not change this field. On
                                                          cold reset, this field is initialized as follows:
@@ -526,7 +526,7 @@ union cvmx_rst_soft_prstx {
                                                          all modes, not just RC mode.
                                                          * If the RST_CTL*[HOST_MODE] = 0, SOFT_PRST resets to 0.
                                                          * If the RST_CTL*[HOST_MODE] = 1, SOFT_PRST resets to 1.
-                                                         When CN78XX is configured to drive PERST*_L (i.e.
+                                                         When CNXXXX is configured to drive PERST*_L (i.e.
                                                          RST_CTL(0..3)[RST_DRV] = 1), this controls the output value on PERST*_L. */
 #else
 	uint64_t soft_prst                    : 1;
@@ -547,7 +547,7 @@ union cvmx_rst_soft_rst {
 	struct cvmx_rst_soft_rst_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_1_63                : 63;
-	uint64_t soft_rst                     : 1;  /**< When set, resets the CN78XX core. When performing a soft reset from a remote PCIe host,
+	uint64_t soft_rst                     : 1;  /**< When set, resets the CNXXXX core. When performing a soft reset from a remote PCIe host,
                                                          always read this register and wait for the results before setting SOFT_RST to 1. */
 #else
 	uint64_t soft_rst                     : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-sli-defs.h b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
index d47e2b3..4e15a4d 100644
--- a/arch/mips/include/asm/octeon/cvmx-sli-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sli-defs.h
@@ -5708,7 +5708,8 @@ union cvmx_sli_pktx_input_control {
                                                          x belongs to MAC0 and ring y belongs to MAC1, they both could have a VF_NUM of 1. Legal
                                                          value are 0-64. */
 	uint64_t reserved_31_31               : 1;
-	uint64_t mac_num                      : 2;  /**< The MAC that the ring belongs to. Legal value are 0-3. */
+	uint64_t mac_num                      : 2;  /**< The MAC that the ring belongs to. Legal value are 0-3. This applies for both
+                                                         input and output rings. */
 	uint64_t reserved_27_28               : 2;
 	uint64_t rdsize                       : 2;  /**< Number of instructions to be read in one MAC read request for the 4 ports, 16 rings. Two
                                                          bit value are:
@@ -5719,7 +5720,8 @@ union cvmx_sli_pktx_input_control {
 	uint64_t is_64b                       : 1;  /**< When IS_64B=1, instruction input ring i uses 64B. */
 	uint64_t rst                          : 1;  /**< Packet reset. This bit is set for a ring when the ring enters the reset state. This can be
                                                          done by writing a 1 to the field, when a FLR associated with the ring occurs, or when an
-                                                         error response is received for a read done by the ring. See SLI_INT_SUM[PGL_ERR]. When
+                                                         error response is received for a read done by the ring. This applies for both
+                                                         input and output rings. See SLI_INT_SUM[PGL_ERR]. When
                                                          receiving a PGL_ERR interrupt, software should:
                                                          1. Wait 2ms to allow any outstanding reads to return or be timed out.
                                                          2. Write a 0 to this bit.
@@ -6152,11 +6154,14 @@ union cvmx_sli_pktx_output_control {
                                                          becomes ADDRTYPE<0> in DPI/SLI reads that fetch buffer/info pairs from packet output ring
                                                          (from address SLI_PKTx_SLIST_BADDR+ in MAC memory space.) ADDRTYPE<0> is the relaxed-order
                                                          attribute for PCIe. */
-	uint64_t enb                          : 1;  /**< Packet input enable. When ENB=1, packet input ring is enabled. When the ring is in reset,
+	uint64_t enb                          : 1;  /**< Packet output enable. When ENB=1, packet output ring is enabled. When the ring is in
+                                                         reset,
                                                          caused by a failing read associated with the ring, the ring being put into reset by
                                                          writing the reset bit associated with a ring, a FLR or the MAC the ring is associated with
                                                          being in reset, will cause this bit to clear and be able to be set again till the reset
-                                                         condition is removed. */
+                                                         condition is removed. This is a mirror of SLI_PKT_OUT_ENB (setting a bit here will set a
+                                                         bit
+                                                         in that CSR). */
 #else
 	uint64_t enb                          : 1;
 	uint64_t ror_p                        : 1;
diff --git a/arch/mips/include/asm/octeon/cvmx-sso-defs.h b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
index 6119efc..3845262 100644
--- a/arch/mips/include/asm/octeon/cvmx-sso-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-sso-defs.h
@@ -1317,8 +1317,8 @@ union cvmx_sso_aw_cfg {
 	uint64_t stt                          : 1;  /**< Use STT to bypass L2 allocation for XAQ store operations. */
 	uint64_t ldt                          : 1;  /**< Use LDT to bypass L2 allocation for XAQ load operations. */
 	uint64_t ldwb                         : 1;  /**< When reading XAQ cache lines, use LDWB transactions to invalidate the cache line. */
-	uint64_t rwen                         : 1;  /**< Enable XAQ operations. This bit should be set after SSO_XAQ(0..255)_HEAD_PTR and
-                                                         SSO_XAQ(0..255)_TAIL_PTR have been programmed. If cleared, all cached buffers will be
+	uint64_t rwen                         : 1;  /**< Enable XAQ operations. This bit should be set after SSO_XAQ()_HEAD_PTR and
+                                                         SSO_XAQ()_TAIL_PTR have been programmed. If cleared, all cached buffers will be
                                                          returned from the FPA as soon as possible, and TAQ arbitration is simplified. */
 #else
 	uint64_t rwen                         : 1;
@@ -1435,7 +1435,7 @@ union cvmx_sso_aw_we {
 	uint64_t reserved_29_63               : 35;
 	uint64_t rsvd_free                    : 13; /**< Number of free reserved entries. Used to ensure that each group can get a specific number
                                                          of entries. Must always be greater than or equal to the sum across all
-                                                         SSO_GRP(0..255)_IAQ_THR[RSVD_THR], and will generally be equal to that sum unless changes
+                                                         SSO_GRP()_IAQ_THR[RSVD_THR], and will generally be equal to that sum unless changes
                                                          to RSVD_THR are going to be made. To prevent races, software should not change this
                                                          register when SSO is being used; instead use SSO_AW_ADD[RSVD_FREE]. */
 	uint64_t reserved_13_15               : 3;
@@ -1570,16 +1570,16 @@ union cvmx_sso_bist_status0 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t bist                         : 10; /**< Memory BIST status. 0 = pass, 1 = fail. INTERNAL:
-                                                         <9> = WES
-                                                         <8> = FFF
-                                                         <7> = XAQ
-                                                         <6> = QTC
-                                                         <5> = INP
-                                                         <4> = LLM
-                                                         <3> = TIAQ_HPTR
-                                                         <2> = TIAQ_TPTR
-                                                         <1> = TOAQ_HPTR
-                                                         <0> = TOAQ_TPTR */
+                                                         <9> = WES.
+                                                         <8> = FFF.
+                                                         <7> = XAQ.
+                                                         <6> = QTC.
+                                                         <5> = INP.
+                                                         <4> = LLM.
+                                                         <3> = TIAQ_HPTR.
+                                                         <2> = TIAQ_TPTR.
+                                                         <1> = TOAQ_HPTR.
+                                                         <0> = TOAQ_TPTR. */
 #else
 	uint64_t bist                         : 10;
 	uint64_t reserved_10_63               : 54;
@@ -1601,13 +1601,13 @@ union cvmx_sso_bist_status1 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_7_63                : 57;
 	uint64_t bist                         : 7;  /**< Memory BIST status. 0 = pass, 1 = fail. INTERNAL:
-                                                         <6> = THRINT
-                                                         <5> = MASK
-                                                         <4> = GDW
-                                                         <3> = QIDX
-                                                         <2> = TPTR
-                                                         <1> = HPTR
-                                                         <0> = CNTR */
+                                                         <6> = THRINT.
+                                                         <5> = MASK.
+                                                         <4> = GDW.
+                                                         <3> = QIDX.
+                                                         <2> = TPTR.
+                                                         <1> = HPTR.
+                                                         <0> = CNTR. */
 #else
 	uint64_t bist                         : 7;
 	uint64_t reserved_7_63                : 57;
@@ -1629,15 +1629,15 @@ union cvmx_sso_bist_status2 {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_9_63                : 55;
 	uint64_t bist                         : 9;  /**< Memory BIST status. 0 = pass, 1 = fail. INTERNAL:
-                                                         <8> = PC_WS
-                                                         <7> = PC_WA
-                                                         <6> = PC_TS
-                                                         <5> = PC_DS
-                                                         <4> = NCB0
-                                                         <3> = PND
-                                                         <2> = OTH
-                                                         <1> = NIDX
-                                                         <0> = PIDX */
+                                                         <8> = PC_WS.
+                                                         <7> = PC_WA.
+                                                         <6> = PC_TS.
+                                                         <5> = PC_DS.
+                                                         <4> = NCB0.
+                                                         <3> = PND.
+                                                         <2> = OTH.
+                                                         <1> = NIDX.
+                                                         <0> = PIDX. */
 #else
 	uint64_t bist                         : 9;
 	uint64_t reserved_9_63                : 55;
@@ -2015,10 +2015,10 @@ union cvmx_sso_err0 {
 	uint64_t wes_sbe                      : 1;  /**< Single-bit error for WES RAM. Throws SSO_INTSN_E::SSO_ERR0_WES_SBE. */
 	uint64_t reserved_6_31                : 26;
 	uint64_t addwq_dropped                : 1;  /**< Add work dropped due to wrong command/DID requested. Throws
-                                                         SSO_INTSN_E::SSO_ERR0_ADD_WQDROPPED. */
+                                                         SSO_INTSN_E::SSO_ERR0_ADDWQ_DROPPED. */
 	uint64_t awempty                      : 1;  /**< Received add work with tag specified as EMPTY. Throws SSO_INTSN_E::SSO_ERR0_AWEMPTY. */
 	uint64_t grpdis                       : 1;  /**< Add work to disabled group. An ADDWQ was received and dropped to a group with
-                                                         SSO_GRP(0..255)_IAQ_THR[RSVD_THR] = 0. Throws SSO_INTSN_E::SSO_ERR0_GRPDIS. */
+                                                         SSO_GRP()_IAQ_THR[RSVD_THR] = 0. Throws SSO_INTSN_E::SSO_ERR0_GRPDIS. */
 	uint64_t bfp                          : 1;  /**< Bad-fill-packet error. The WAE VLD_CRC field was incorrect, or the XAQ next address was
                                                          zero. Throws SSO_INTSN_E::SSO_ERR0_BFP. */
 	uint64_t awe                          : 1;  /**< Out-of-memory error. (ADDWQ request is dropped.) Throws SSO_INTSN_E::SSO_ERR0_AWE. */
@@ -2331,7 +2331,7 @@ union cvmx_sso_grpx_aq_thr {
 	struct cvmx_sso_grpx_aq_thr_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_33_63               : 31;
-	uint64_t aq_thr                       : 33; /**< Total admission queue entry threshold. Compared against SSO_GRP(0..255)_AQ_CNT for
+	uint64_t aq_thr                       : 33; /**< Total admission queue entry threshold. Compared against SSO_GRP()_AQ_CNT for
                                                          triggering AQ interrupts. */
 #else
 	uint64_t aq_thr                       : 33;
@@ -2431,27 +2431,27 @@ union cvmx_sso_grpx_int {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t exe_dis                      : 1;  /**< Executable interrupt temporary disable. Corresponding [EXE_INT] bit cannot be set due to
                                                          IAQ_CNT/IAQ_THR check when this bit is set. EXE_DIS is cleared by hardware whenever:
-                                                         * SSO_GRP(0..255)_INT_CNT[IAQ_CNT] is zero, or
-                                                         * SSO_GRP(0..255)_INT_CNT[TC_CNT] is equal to 1 when periodic counter SSO_WQ_INT_PC[PC] is
+                                                         * SSO_GRP()_INT_CNT[IAQ_CNT] is zero, or
+                                                         * SSO_GRP()_INT_CNT[TC_CNT] is equal to 1 when periodic counter SSO_WQ_INT_PC[PC] is
                                                          equal to 0. */
 	uint64_t reserved_2_62                : 61;
 	uint64_t exe_int                      : 1;  /**< Work-executable interrupt. Generally used to indicate work is waiting for software. Throws
-                                                         SSO_INTSN_E::SSO_GRP(0..255)_EXE. Set by hardware whenever:
-                                                         * SSO_GRP(0..255)_INT_CNT[IAQ_CNT] >= SSO_GRP(0..255)_INT_THR [IAQ_THR] and [IAQ_THR] != 0
+                                                         SSO_INTSN_E::SSO_GRP()_EXE. Set by hardware whenever:
+                                                         * SSO_GRP()_INT_CNT[IAQ_CNT] >= SSO_GRP()_INT_THR [IAQ_THR] and [IAQ_THR] != 0
                                                          and EXE_DIS is clear.
-                                                         * SSO_GRP(0..255)_INT_CNT[DS_CNT] >= SSO_GRP(0..255)_INT_THR[DS_THR] and [DS_THR] != 0 and
+                                                         * SSO_GRP()_INT_CNT[DS_CNT] >= SSO_GRP()_INT_THR[DS_THR] and [DS_THR] != 0 and
                                                          EXE_DIS is clear.
-                                                         * SSO_GRP(0..255)_INT_CNT[CQ_CNT] >= SSO_GRP(0..255)_INT_THR[CQ_THR] and [CQ_THR] != 0 and
+                                                         * SSO_GRP()_INT_CNT[CQ_CNT] >= SSO_GRP()_INT_THR[CQ_THR] and [CQ_THR] != 0 and
                                                          EXE_DIS is clear.
-                                                         * SSO_GRP(0..255)_INT_CNT[TC_CNT] is equal to 1 when periodic counter SSO_WQ_INT_PC[PC] is
-                                                         equal to 0 and SSO_GRP(0..255)_INT_THR[TC_EN] is set and at least one of the following is
+                                                         * SSO_GRP()_INT_CNT[TC_CNT] is equal to 1 when periodic counter SSO_WQ_INT_PC[PC] is
+                                                         equal to 0 and SSO_GRP()_INT_THR[TC_EN] is set and at least one of the following is
                                                          true:
-                                                         SSO_GRP(0..255)_INT_CNT[IAQ_CNT] > 0
-                                                         SSO_GRP(0..255)_INT_CNT[DS_CNT] > 0
-                                                         SSO_GRP(0..255)_INT_CNT[CQ_CNT] > 0 */
-	uint64_t aq_int                       : 1;  /**< External group queue threshold interrupt. Set if SSO_GRP(0..255)_AQ_CNT changes, and the
-                                                         resulting value is equal to SSO_GRP(0..255)_AQ_THR. Throws
-                                                         SSO_INTSN_E::SSO_GRP(0..255)_AQ. */
+                                                         _ SSO_GRP()_INT_CNT[IAQ_CNT] > 0
+                                                         _ SSO_GRP()_INT_CNT[DS_CNT] > 0
+                                                         _ SSO_GRP()_INT_CNT[CQ_CNT] > 0 */
+	uint64_t aq_int                       : 1;  /**< External group queue threshold interrupt. Set if SSO_GRP()_AQ_CNT changes, and the
+                                                         resulting value is equal to SSO_GRP()_AQ_THR. Throws
+                                                         SSO_INTSN_E::SSO_GRP()_AQ. */
 #else
 	uint64_t aq_int                       : 1;
 	uint64_t exe_int                      : 1;
@@ -2475,14 +2475,14 @@ union cvmx_sso_grpx_int_cnt {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_61_63               : 3;
 	uint64_t tc_cnt                       : 13; /**< Time counter current value for this group. Hardware sets this field to the value of
-                                                         SSO_GRP(0..255)_INT_THR[TC_THR] whenever:
-                                                         * Corresponding SSO_GRP(0..255)_INT_CNT[IAQ_CNT, DS_CNT and CQ_CNT] are all equal to 0.
-                                                         * Corresponding SSO_GRP(0..255)_INT[EXE_INT] is written with a one to clear by software.
-                                                         * Corresponding SSO_GRP(0..255)_INT[EXE_DIS] is written with a one to clear by software.
-                                                         * Corresponding SSO_GRP(0..255)_INT_THR is written by software.
+                                                         SSO_GRP()_INT_THR[TC_THR] whenever:
+                                                         * Corresponding SSO_GRP()_INT_CNT[IAQ_CNT, DS_CNT and CQ_CNT] are all equal to 0.
+                                                         * Corresponding SSO_GRP()_INT[EXE_INT] is written with a one to clear by software.
+                                                         * Corresponding SSO_GRP()_INT[EXE_DIS] is written with a one to clear by software.
+                                                         * Corresponding SSO_GRP()_INT_THR is written by software.
                                                          * TC_CNT is equal to 1 and periodic counter SSO_WQ_INT_PC[PC] is equal to 0.
                                                          Otherwise, hardware decrements this field whenever the periodic counter SSO_WQ_INT_PC[PC]
-                                                         is equal to 0. This field is 0 whenever SSO_GRP(0..255)_INT_THR[TC_THR] is equal to 0. */
+                                                         is equal to 0. This field is 0 whenever SSO_GRP()_INT_THR[TC_THR] is equal to 0. */
 	uint64_t reserved_45_47               : 3;
 	uint64_t cq_cnt                       : 13; /**< Conflicted queue executable count for this group. */
 	uint64_t reserved_29_31               : 3;
@@ -2517,19 +2517,19 @@ union cvmx_sso_grpx_int_thr {
 	uint64_t tc_en                        : 1;  /**< Time counter interrupt enable for this group. This field must be zero when [TC_THR] is 0. */
 	uint64_t reserved_61_62               : 2;
 	uint64_t tc_thr                       : 13; /**< Time counter interrupt threshold for this group. Compared against
-                                                         SSO_GRP(0..255)_INT_CNT[TC_CNT]. When this field is equal to 0,
-                                                         SSO_GRP(0..255)_INT_CNT[TC_CNT] is zero. */
+                                                         SSO_GRP()_INT_CNT[TC_CNT]. When this field is equal to 0,
+                                                         SSO_GRP()_INT_CNT[TC_CNT] is zero. */
 	uint64_t reserved_45_47               : 3;
 	uint64_t cq_thr                       : 13; /**< Conflicted queue count threshold for this group. Compared against
-                                                         SSO_GRP(0..255)_INT_CNT[CQ_CNT]. When this field is 0, the threshold interrupt is
+                                                         SSO_GRP()_INT_CNT[CQ_CNT]. When this field is 0, the threshold interrupt is
                                                          disabled. */
 	uint64_t reserved_29_31               : 3;
 	uint64_t ds_thr                       : 13; /**< Deschedule count threshold for this group. Compared against
-                                                         SSO_GRP(0..255)_INT_CNT[DS_CNT]. When this field is 0, the threshold interrupt is
+                                                         SSO_GRP()_INT_CNT[DS_CNT]. When this field is 0, the threshold interrupt is
                                                          disabled. */
 	uint64_t reserved_13_15               : 3;
 	uint64_t iaq_thr                      : 13; /**< In-unit admission queue threshold for this group. Compared against
-                                                         SSO_GRP(0..255)_INT_CNT[IAQ_CNT]. When this field is 0, the threshold interrupt is
+                                                         SSO_GRP()_INT_CNT[IAQ_CNT]. When this field is 0, the threshold interrupt is
                                                          disabled. */
 #else
 	uint64_t iaq_thr                      : 13;
@@ -2565,7 +2565,7 @@ union cvmx_sso_grpx_pri {
 	uint64_t affinity                     : 4;  /**< Processor affinity arbitration weight to apply to this group. If zero, affinity is disabled. */
 	uint64_t reserved_3_7                 : 5;
 	uint64_t pri                          : 3;  /**< Priority for this group relative to other groups. To prevent a core from receiving work on
-                                                         a group use SSO_PP(0..47)_S(0..1)_GRPMSK(0..3).
+                                                         a group use SSO_PP()_S()_GRPMSK().
                                                          0x0 = highest priority.
                                                          0x7 = lowest priority.
                                                          Changing priority while GET_WORKs are in flight may result in a GET_WORK using either the
@@ -2790,16 +2790,16 @@ union cvmx_sso_gwe_random {
                                                          at. Changes on each work search, even if unsuccessful or retried. For diagnostic use only,
                                                          must not be zero. INTERNAL: Uses 16, 15, 13, 4 tap LFSR (this choice is important to
                                                          insure even group probabilities) with the formula:
-                                                         grp_to_start_arb_at = RND[7:0];
-                                                         RND_next[15:8] = RND[7:0];
-                                                         RND_next[7] = ^(RND[15:0] & 0xd008);
-                                                         RND_next[6] = ^(RND[15:0] & 0x6804);
-                                                         RND_next[5] = ^(RND[15:0] & 0x3402);
-                                                         RND_next[4] = ^(RND[15:0] & 0x1a01);
-                                                         RND_next[3] = ^(RND[15:0] & 0xdd08);
-                                                         RND_next[2] = ^(RND[15:0] & 0x6e84);
-                                                         RND_next[1] = ^(RND[15:0] & 0x3742);
-                                                         RND_next[0] = ^(RND[15:0] & 0x1ba1); */
+                                                         _ grp_to_start_arb_at = RND[7:0];
+                                                         _ RND_next[15:8] = RND[7:0];
+                                                         _ RND_next[7] = ^(RND[15:0] & 0xd008);
+                                                         _ RND_next[6] = ^(RND[15:0] & 0x6804);
+                                                         _ RND_next[5] = ^(RND[15:0] & 0x3402);
+                                                         _ RND_next[4] = ^(RND[15:0] & 0x1a01);
+                                                         _ RND_next[3] = ^(RND[15:0] & 0xdd08);
+                                                         _ RND_next[2] = ^(RND[15:0] & 0x6e84);
+                                                         _ RND_next[1] = ^(RND[15:0] & 0x3742);
+                                                         _ RND_next[0] = ^(RND[15:0] & 0x1ba1); */
 #else
 	uint64_t rnd                          : 16;
 	uint64_t reserved_16_63               : 48;
@@ -2987,8 +2987,8 @@ union cvmx_sso_ientx_wqpgrp {
 	uint64_t head                         : 1;  /**< SSO entry is at the head of a tag chain that is descheduled. */
 	uint64_t nosched                      : 1;  /**< The nosched bit for the SSO entry. */
 	uint64_t reserved_58_59               : 2;
-	uint64_t grp                          : 10; /**< Group of the SSO entry. The upper bits are not stored in the RAM, but rather indicate the
-                                                         OCI node number. */
+	uint64_t grp                          : 10; /**< Group of the SSO entry.
+                                                         The upper bits are not stored in the RAM, but rather indicate the OCI node number. */
 	uint64_t reserved_42_47               : 6;
 	uint64_t wqp                          : 42; /**< Work queue pointer held in the SSO entry. */
 #else
@@ -3009,7 +3009,7 @@ typedef union cvmx_sso_ientx_wqpgrp cvmx_sso_ientx_wqpgrp_t;
  * cvmx_sso_ipl_conf#
  *
  * Returns list status for the conflicted list indexed by group; see Debug Visibility.  Register
- * fields are identical to those in SSO_IPL_IAQ(0..255) above.
+ * fields are identical to those in SSO_IPL_IAQ() above.
  */
 union cvmx_sso_ipl_confx {
 	uint64_t u64;
@@ -3040,7 +3040,7 @@ typedef union cvmx_sso_ipl_confx cvmx_sso_ipl_confx_t;
  * cvmx_sso_ipl_desched#
  *
  * Returns list status for the deschedule list indexed by group; see Debug Visibility.  Register
- * fields are identical to those in SSO_IPL_IAQ(0..255) above.
+ * fields are identical to those in SSO_IPL_IAQ() above.
  */
 union cvmx_sso_ipl_deschedx {
 	uint64_t u64;
@@ -3302,10 +3302,10 @@ union cvmx_sso_nw_tim {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_10_63               : 54;
 	uint64_t nw_tim                       : 10; /**< New-work-timer period.
-                                                         0x0 = 1024 clock cycles
-                                                         0x1 = 2048 clock cycles
-                                                         0x2 = 3072 clock cycles
-                                                         ... etc. */
+                                                         0x0 = 1024 clock cycles.
+                                                         0x1 = 2048 clock cycles.
+                                                         0x2 = 3072 clock cycles.
+                                                         _ ... etc. */
 #else
 	uint64_t nw_tim                       : 10;
 	uint64_t reserved_10_63               : 54;
@@ -3611,12 +3611,12 @@ union cvmx_sso_ppx_sx_grpmskx {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t grp_msk                      : 64; /**< Core group mask. A one in any bit position sets the core's membership in the corresponding
                                                          group:
-                                                         GRPMSK(0) for groups <63:0>
-                                                         GRPMSK(1) for groups <127:64>
-                                                         GRPMSK(2) for groups <191:128>
-                                                         GRPMSK(3) for groups <255:192>
-                                                         A value of 0x0 in each GRPMSK(0..3) for a given core prevents the core from receiving new
-                                                         work. Cores that will never receive work should use GRPMSK(0..3)=0x0; while this setting
+                                                         _ GRPMSK(0) for groups <63:0>.
+                                                         _ GRPMSK(1) for groups <127:64>.
+                                                         _ GRPMSK(2) for groups <191:128>.
+                                                         _ GRPMSK(3) for groups <255:192>.
+                                                         A value of 0x0 in each GRPMSK() for a given core prevents the core from receiving new
+                                                         work. Cores that will never receive work should use GRPMSK()=0x0; while this setting
                                                          is not special in SSO, for backward and forward compatibility this may enable reallocation
                                                          of internal resources to the remaining (non-zero-mask) cores. */
 #else
@@ -3961,8 +3961,8 @@ union cvmx_sso_sl_ppx_links {
 	uint64_t reserved_60_62               : 3;
 	uint64_t index                        : 12; /**< The SSO entry attached to the core. */
 	uint64_t reserved_38_47               : 10;
-	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). The
-                                                         upper two bits are hardcoded to the node number. */
+	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
+                                                         The upper two bits are hardcoded to the node number. */
 	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t reserved_25_25               : 1;
@@ -4083,8 +4083,8 @@ union cvmx_sso_sl_ppx_tag {
 	uint64_t reserved_60_62               : 3;
 	uint64_t index                        : 12; /**< The SSO entry attached to the core. */
 	uint64_t reserved_46_47               : 2;
-	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). The
-                                                         upper two bits are hardcoded to the node number. */
+	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
+                                                         The upper two bits are hardcoded to the node number. */
 	uint64_t head                         : 1;  /**< Set when this SSO entry is at the head of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t tail                         : 1;  /**< Set when this SSO entry is at the tail of its tag list, or when in the UNTAGGED or EMPTY state. */
 	uint64_t tt                           : 2;  /**< The tag type attached to the core (updated when new tag list entered on SWTAG, SWTAG_FULL,
@@ -4118,8 +4118,8 @@ union cvmx_sso_sl_ppx_wqp {
 	struct cvmx_sso_sl_ppx_wqp_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t reserved_58_63               : 6;
-	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). The
-                                                         upper two bits are hardcoded to the node number. */
+	uint64_t grp                          : 10; /**< The group attached to the core (updated when new tag list entered on SWTAG_FULL).
+                                                         The upper two bits are hardcoded to the node number. */
 	uint64_t reserved_42_47               : 6;
 	uint64_t wqp                          : 42; /**< The WQP attached to the core (updated when new tag list entered on SWTAG_FULL.) */
 #else
@@ -4229,7 +4229,7 @@ union cvmx_sso_taq_cnt {
 	uint64_t reserved_27_63               : 37;
 	uint64_t rsvd_free                    : 11; /**< Number of free reserved buffers. Used to insure each group may get a specific number of
                                                          buffers. Must always be greater than or equal to the sum across all
-                                                         SSO_GRP(0..255)_TAQ_THR[RSVD_THR], and will generally be equal to that sum unless changes
+                                                         SSO_GRP()_TAQ_THR[RSVD_THR], and will generally be equal to that sum unless changes
                                                          to RSVD_THR are going to be made. To prevent races, software should not change this
                                                          register when SSO is being used; instead use SSO_TAQ_ADD[RSVD_FREE]. */
 	uint64_t reserved_11_15               : 5;
@@ -4256,17 +4256,17 @@ union cvmx_sso_tiaqx_status {
 	struct cvmx_sso_tiaqx_status_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t wae_head                     : 4;  /**< Head's WAE number within current cache line, 0-12. This provides the second index into
-                                                         SSO_TAQ(0..1279)_WAE(0..12)_TAG and SSO_TAQ(0..1279)_WAE(0..12)_WQP. */
+                                                         SSO_TAQ()_WAE()_TAG and SSO_TAQ()_WAE()_WQP. */
 	uint64_t wae_tail                     : 4;  /**< Tail's WAE number within current cache line, 0-12. This provides the second index into
-                                                         SSO_TAQ(0..1279)_WAE(0..12)_TAG and SSO_TAQ(0..1279)_WAE(0..12)_WQP. */
+                                                         SSO_TAQ()_WAE()_TAG and SSO_TAQ()_WAE()_WQP. */
 	uint64_t reserved_47_55               : 9;
 	uint64_t wae_used                     : 15; /**< Number of WAEs in use. */
 	uint64_t reserved_23_31               : 9;
-	uint64_t ent_head                     : 11; /**< Head's entry number. This provides the first index into SSO_TAQ(0..1279)_WAE(0..12)_TAG
-                                                         and SSO_TAQ(0..1279)_WAE(0..12)_WQP. */
+	uint64_t ent_head                     : 11; /**< Head's entry number. This provides the first index into SSO_TAQ()_WAE()_TAG
+                                                         and SSO_TAQ()_WAE()_WQP. */
 	uint64_t reserved_11_11               : 1;
-	uint64_t ent_tail                     : 11; /**< Tail's entry number. This provides the first index into SSO_TAQ(0..1279)_WAE(0..12)_TAG
-                                                         and SSO_TAQ(0..1279)_WAE(0..12)_WQP. */
+	uint64_t ent_tail                     : 11; /**< Tail's entry number. This provides the first index into SSO_TAQ()_WAE()_TAG
+                                                         and SSO_TAQ()_WAE()_WQP. */
 #else
 	uint64_t ent_tail                     : 11;
 	uint64_t reserved_11_11               : 1;
@@ -4296,15 +4296,15 @@ union cvmx_sso_toaqx_status {
 	uint64_t ext_vld                      : 1;  /**< External queuing is in use on this group. */
 	uint64_t partial                      : 1;  /**< Partial cache line is allocated to tail of queue. */
 	uint64_t wae_tail                     : 4;  /**< If PARTIAL is set, tail's WAE number within current cache line, 0-12. This provides the
-                                                         second index into SSO_TAQ(0..1279)_WAE(0..12)_TAG and SSO_TAQ(0..1279)_WAE(0..12)_WQP. */
+                                                         second index into SSO_TAQ()_WAE()_TAG and SSO_TAQ()_WAE()_WQP. */
 	uint64_t reserved_43_55               : 13;
 	uint64_t cl_used                      : 11; /**< Number of cache lines in use. */
 	uint64_t reserved_23_31               : 9;
-	uint64_t ent_head                     : 11; /**< Head's entry number. This provides the first index into SSO_TAQ(0..1279)_WAE(0..12)_TAG
-                                                         and SSO_TAQ(0..1279)_WAE(0..12)_WQP. */
+	uint64_t ent_head                     : 11; /**< Head's entry number. This provides the first index into SSO_TAQ()_WAE()_TAG
+                                                         and SSO_TAQ()_WAE()_WQP. */
 	uint64_t reserved_11_11               : 1;
-	uint64_t ent_tail                     : 11; /**< Tail's entry number. This provides the first index into SSO_TAQ(0..1279)_WAE(0..12)_TAG
-                                                         and SSO_TAQ(0..1279)_WAE(0..12)_WQP. */
+	uint64_t ent_tail                     : 11; /**< Tail's entry number. This provides the first index into SSO_TAQ()_WAE()_TAG
+                                                         and SSO_TAQ()_WAE()_WQP. */
 #else
 	uint64_t ent_tail                     : 11;
 	uint64_t reserved_11_11               : 1;
@@ -4602,14 +4602,14 @@ union cvmx_sso_ws_cfg {
 	uint64_t reserved_56_63               : 8;
 	uint64_t ocla_bp                      : 8;  /**< Enable OCLA backpressure stalls. For diagnostic use only.
                                                          INTERNAL:
-                                                         <55> NCBB input fifo stall (ncbo.)
-                                                         <54> Work-slot response. (arbrsp.)
-                                                         <53> Work-slot switching of descheduled work entries. (arbx.)
-                                                         <52> Work-slot SWTAG response. (arbs.)
-                                                         <51> Work-slot access to get-work engine. (arbgw.)
-                                                         <50> Work-slot CAM access. (arbc.)
-                                                         <49> Work-slot RAM access. (arbr.)
-                                                         <48> Work-slot pushes to AQ, CQ, DQ. (arbq.) */
+                                                         <55> = NCBB input fifo stall (ncbo).
+                                                         <54> = Work-slot response. (arbrsp).
+                                                         <53> = Work-slot switching of descheduled work entries. (arbx).
+                                                         <52> = Work-slot SWTAG response. (arbs).
+                                                         <51> = Work-slot access to get-work engine. (arbgw).
+                                                         <50> = Work-slot CAM access. (arbc).
+                                                         <49> = Work-slot RAM access. (arbr).
+                                                         <48> = Work-slot pushes to AQ, CQ, DQ. (arbq). */
 	uint64_t reserved_5_47                : 43;
 	uint64_t disable_pw                   : 1;  /**< Reserved. */
 	uint64_t arbc_step_en                 : 1;  /**< Enable single-stepping WS CAM arbiter, twice per 16 clocks. For diagnostic use only. */
@@ -4685,8 +4685,8 @@ typedef union cvmx_sso_xaqx_head_next cvmx_sso_xaqx_head_next_t;
  *
  * These registers contain the pointer to the first entry of the external linked list(s) for a
  * particular group. Software must initialize the external linked list(s) by programming
- * SSO_XAQ(0..255)_HEAD_PTR, SSO_XAQ(0..255)_HEAD_NEXT, SSO_XAQ(0..255)_TAIL_PTR and
- * SSO_XAQ(0..255)_TAIL_NEXT to identical values.
+ * SSO_XAQ()_HEAD_PTR, SSO_XAQ()_HEAD_NEXT, SSO_XAQ()_TAIL_PTR and
+ * SSO_XAQ()_TAIL_NEXT to identical values.
  */
 union cvmx_sso_xaqx_head_ptr {
 	uint64_t u64;
@@ -4713,7 +4713,7 @@ typedef union cvmx_sso_xaqx_head_ptr cvmx_sso_xaqx_head_ptr_t;
  *
  * These registers contain the pointer to the next buffer to become the tail when the final cache
  * line in this buffer is written.  Register fields are identical to those in
- * SSO_XAQ(0..255)_HEAD_NEXT above.
+ * SSO_XAQ()_HEAD_NEXT above.
  */
 union cvmx_sso_xaqx_tail_next {
 	uint64_t u64;
@@ -4737,7 +4737,7 @@ typedef union cvmx_sso_xaqx_tail_next cvmx_sso_xaqx_tail_next_t;
  * cvmx_sso_xaq#_tail_ptr
  *
  * These registers contain the pointer to the last entry of the external linked list(s) for a
- * particular group.  Register fields are identical to those in SSO_XAQ(0..255)_HEAD_PTR above.
+ * particular group.  Register fields are identical to those in SSO_XAQ()_HEAD_PTR above.
  */
 union cvmx_sso_xaqx_tail_ptr {
 	uint64_t u64;
@@ -4769,8 +4769,8 @@ union cvmx_sso_xaq_aura {
 	uint64_t reserved_12_63               : 52;
 	uint64_t node                         : 2;  /**< Node number of current chip, to ensure that the aura is on the local node. */
 	uint64_t laura                        : 10; /**< FPA local-node aura to use for SSO XAQ allocations and frees. The FPA aura selected by
-                                                         LAURA must select a pool with FPA_POOL(0..63)_CFG[NAT_ALIGN]=1, and
-                                                         (FPA_POOL(0..63)_CFG[BUF_SIZE] - FPA_POOL(0..63)_CFG[BUF_OFFSET]) >= 4 KB / 128. */
+                                                         LAURA must select a pool with FPA_POOL()_CFG[NAT_ALIGN]=1, and
+                                                         (FPA_POOL()_CFG[BUF_SIZE] - FPA_POOL()_CFG[BUF_OFFSET]) >= 4 KB / 128. */
 #else
 	uint64_t laura                        : 10;
 	uint64_t node                         : 2;
diff --git a/arch/mips/include/asm/octeon/cvmx-tim-defs.h b/arch/mips/include/asm/octeon/cvmx-tim-defs.h
index 6edc64a..ac0354f 100644
--- a/arch/mips/include/asm/octeon/cvmx-tim-defs.h
+++ b/arch/mips/include/asm/octeon/cvmx-tim-defs.h
@@ -698,7 +698,7 @@ union cvmx_tim_gpio_en {
 	struct cvmx_tim_gpio_en_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t gpio_en                      : 64; /**< Each bit corresponds to rings [63:0] respectively. This register reflects the values
-                                                         written to TIM_RING(0..63)_CTL1 [ENA_GPIO]. For debug only; Reserved. */
+                                                         written to TIM_RING()_CTL1 [ENA_GPIO]. For debug only; Reserved. */
 #else
 	uint64_t gpio_en                      : 64;
 #endif
@@ -723,7 +723,7 @@ union cvmx_tim_int0 {
 	struct cvmx_tim_int0_s {
 #ifdef __BIG_ENDIAN_BITFIELD
 	uint64_t int0                         : 64; /**< Interrupt bit per ring. Each bit indicates the ring number in error. Throws INTSN
-                                                         TIM_INTSN_E::TIM_RING(0..63)_SLOW */
+                                                         TIM_INTSN_E::TIM_RING()_SLOW. */
 #else
 	uint64_t int0                         : 64;
 #endif
@@ -1503,21 +1503,21 @@ union cvmx_tim_ringx_ctl0 {
 	struct cvmx_tim_ringx_ctl0_cn68xx     cn68xxp1;
 	struct cvmx_tim_ringx_ctl0_cn78xx {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t expire_offset                : 32; /**< Time at which the next bucket will be serviced, or offset. See also TIM_RING(0..63)_REL
+	uint64_t expire_offset                : 32; /**< Time at which the next bucket will be serviced, or offset. See also TIM_RING()_REL
                                                          for the position relative to current time.
-                                                         If TIM_RING(0..63)_CTL1[ENA] = 0, then contains an offset. When ENA transitions from a
+                                                         If TIM_RING()_CTL1[ENA] = 0, then contains an offset. When ENA transitions from a
                                                          zero to a one this offset will be added to the current time and loaded back into
                                                          EXPIRE_OFFSET. Thus the offset sets the delta time between ENA transitioning to one and
                                                          the very first time the ring will be serviced. Software should program different offsets
                                                          on each ring to reduce congestion to prevent many rings from otherwise expiring
                                                          concurrently.
-                                                         If TIM_RING(0..63)_CTL1[ENA] = 1, then contains the time the next bucket will be serviced.
+                                                         If TIM_RING()_CTL1[ENA] = 1, then contains the time the next bucket will be serviced.
                                                          When EXPIRE_OFFSET reaches the current time (TIM_FR_RN_CYCLES or TIM_FR_RN_GPIOS),
                                                          EXPIRE_OFFSET is set to the next expiration time (current time plus
-                                                         TIM_RING(0..63)_CTL0[INTERVAL]).
-                                                         EXPIRE_OFFSET is unpredictable after ENA_GPIO changes or TIM_RING(0..63)_CTL1[ENA]
+                                                         TIM_RING()_CTL0[INTERVAL]).
+                                                         EXPIRE_OFFSET is unpredictable after ENA_GPIO changes or TIM_RING()_CTL1[ENA]
                                                          transitions from 1 to 0, and must be reprogrammed before (re-) setting
-                                                         TIM_RING(0..63)_CTL1[ENA]. */
+                                                         TIM_RING()_CTL1[ENA]. */
 	uint64_t interval                     : 32; /**< Timer interval, measured in cycles or GPIO transitions.
                                                          For every 64 entries in a bucket, the interval should be at least 1u. Minimal recommended
                                                          value is 1u. */
@@ -1548,16 +1548,16 @@ union cvmx_tim_ringx_ctl1 {
                                                          0x2. */
 	uint64_t ena                          : 1;  /**< Ring timer enable. After a 1 to 0 transition on ENA, the hardware still completes a bucket
                                                          traversal for the ring if it were pending or active prior to the transition. When
-                                                         clearing, software must delay until TIM_RING(0..63)_REL[RING_ESR] = 0 to ensure the
+                                                         clearing, software must delay until TIM_RING()_REL[RING_ESR] = 0 to ensure the
                                                          completion of the traversal before reprogramming the ring. When setting, RCF_BUSY must be
                                                          clear. */
 	uint64_t ena_gpio                     : 1;  /**< When set, ring's timer tick is generated by the GPIO timer. The GPIO edge is defined by
                                                          TIM_REG_FLAGS[GPIO_EDGE]. The default value (zero) means that timer ticks are generated
                                                          from the internal timer. To change ENA_GPIO:
-                                                         1. TIM_RING(0..63)_CTL1[ENA] is cleared.
+                                                         1. TIM_RING()_CTL1[ENA] is cleared.
                                                          2. [ENA_GPIO] is changed.
-                                                         3. TIM_RING(0..63)_CTL0[EXPIRE_OFFSET] is reprogrammed appropriately.
-                                                         4. TIM_RING(0..63)_CTL1[ENA] is set. */
+                                                         3. TIM_RING()_CTL0[EXPIRE_OFFSET] is reprogrammed appropriately.
+                                                         4. TIM_RING()_CTL1[ENA] is set. */
 	uint64_t ena_prd                      : 1;  /**< Enable periodic mode, which disables the memory write of zeros to NUM_ENTRIES and
                                                          CHUNK_REMAINDER when a bucket is traversed. In periodic mode ENA_DFB and ENA_LDWB must
                                                          also be clear. */
@@ -1639,16 +1639,16 @@ union cvmx_tim_ringx_ctl1 {
                                                          0x2. */
 	uint64_t ena                          : 1;  /**< Ring timer enable. After a 1 to 0 transition on ENA, the hardware still completes a bucket
                                                          traversal for the ring if it were pending or active prior to the transition. When
-                                                         clearing, software must delay until TIM_RING(0..63)_REL[RING_ESR] = 0 to ensure the
+                                                         clearing, software must delay until TIM_RING()_REL[RING_ESR] = 0 to ensure the
                                                          completion of the traversal before reprogramming the ring. When setting, RCF_BUSY must be
                                                          clear. */
 	uint64_t ena_gpio                     : 1;  /**< When set, ring's timer tick is generated by the GPIO timer. The GPIO edge is defined by
                                                          TIM_REG_FLAGS[GPIO_EDGE]. The default value (zero) means that timer ticks are generated
                                                          from the internal timer. To change ENA_GPIO:
-                                                         1. TIM_RING(0..63)_CTL1[ENA] is cleared.
+                                                         1. TIM_RING()_CTL1[ENA] is cleared.
                                                          2. [ENA_GPIO] is changed.
-                                                         3. TIM_RING(0..63)_CTL0[EXPIRE_OFFSET] is reprogrammed appropriately.
-                                                         4. TIM_RING(0..63)_CTL1[ENA] is set. */
+                                                         3. TIM_RING()_CTL0[EXPIRE_OFFSET] is reprogrammed appropriately.
+                                                         4. TIM_RING()_CTL1[ENA] is set. */
 	uint64_t ena_prd                      : 1;  /**< Enable periodic mode, which disables the memory write of zeros to NUM_ENTRIES and
                                                          CHUNK_REMAINDER when a bucket is traversed. In periodic mode ENA_DFB and ENA_LDWB must
                                                          also be clear. */
@@ -1783,16 +1783,16 @@ union cvmx_tim_ringx_rel {
 	uint64_t u64;
 	struct cvmx_tim_ringx_rel_s {
 #ifdef __BIG_ENDIAN_BITFIELD
-	uint64_t cur_bucket                   : 20; /**< Current bucket. Indicates the ring's current bucket. See TIM_RING(0..63)_CTL1[BUCKET]. */
+	uint64_t cur_bucket                   : 20; /**< Current bucket. Indicates the ring's current bucket. See TIM_RING()_CTL1[BUCKET]. */
 	uint64_t reserved_34_43               : 10;
 	uint64_t ring_esr                     : 2;  /**< Ring expiration status register. These registers hold the expiration status of the ring.
                                                          0x0 = Ring has not expired.
                                                          0x1 = Interval expired. Ring is queued to be traversed.
                                                          0x2 = First interval expiration while ring is queued to be traversed.
                                                          0x3 = Second interval expiration while ring is queued to be traversed.
-                                                         This field is zeroed when TIM_RING(0..63)_CTL1[ENA] transitions from 0 -> 1. */
+                                                         This field is zeroed when TIM_RING()_CTL1[ENA] transitions from 0 to 1. */
 	uint64_t timercount                   : 32; /**< Timer count indicates how many timer ticks are left until the interval expiration,
-                                                         calculated as TIM_RING(0..63)_CTL0[EXPIRE_OFFSET] minus current time (TIM_FR_RN_CYCLES or
+                                                         calculated as TIM_RING()_CTL0[EXPIRE_OFFSET] minus current time (TIM_FR_RN_CYCLES or
                                                          TIM_FR_RN_GPIOS).
                                                          Once ENA = 1, TIMERCOUNT will be observed to count down timer ticks. When TIMERCOUNT
                                                          reaches 0x0, the ring's interval expired and the hardware forces a bucket traversal (and
@@ -1800,7 +1800,7 @@ union cvmx_tim_ringx_rel {
                                                          Typical initialization value should be interval/constant; Cavium recommends that the
                                                          constant be unique per ring. This creates an offset between the rings.
                                                          TIMERCOUNT becomes and remains unpredictable whenever ENA = 0 or ENA_GPIO changes. It is
-                                                         software's responsibility to set TIMERCOUNT before TIM_RING(0..63)_CTL1[ENA] transitions
+                                                         software's responsibility to set TIMERCOUNT before TIM_RING()_CTL1[ENA] transitions
                                                          from 0 -> 1. */
 #else
 	uint64_t timercount                   : 32;
diff --git a/arch/mips/include/asm/octeon/octeon-feature.h b/arch/mips/include/asm/octeon/octeon-feature.h
index 9f0cdbf..e2dd056 100644
--- a/arch/mips/include/asm/octeon/octeon-feature.h
+++ b/arch/mips/include/asm/octeon/octeon-feature.h
@@ -267,7 +267,7 @@ static inline int octeon_has_feature_OCTEON_FEATURE_TRA(void)
 static inline int octeon_has_feature_OCTEON_FEATURE_MGMT_PORT(void)
 {
 	return (OCTEON_IS_MODEL(OCTEON_CN56XX)
-		|| OCTEON_IS_MODEL(OCTEON_CN52XX)
+		|| OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)
 		|| OCTEON_IS_OCTEON2());	/* OCTEON II or later */
 }
 
-- 
2.6.2

